{"buggy_code": ["# Changes in oauthenticator\n\n\nFor detailed changes from the prior release, click on the version number, and\nits link will bring up a GitHub listing of changes. Use `git log` on the\ncommand line for details.\n\n\n## [Unreleased]\n\n## 0.12\n\n### [0.12.1] - 2020-11-20\n\n#### Bugs fixed\n\n* Avoid appending code, state parameters to `next_url` [#386](https://github.com/jupyterhub/oauthenticator/pull/386) ([@minrk](https://github.com/minrk))\n\n#### Maintenance and upkeep improvements\n\n* Remove support for python 3.5 [#384](https://github.com/jupyterhub/oauthenticator/pull/384) ([@consideRatio](https://github.com/consideRatio))\n* migrate from travis to github actions [#383](https://github.com/jupyterhub/oauthenticator/pull/383) ([@minrk](https://github.com/minrk))\n* CI: Stop testing py35 and don't test on tagged commits [#379](https://github.com/jupyterhub/oauthenticator/pull/379) ([@consideRatio](https://github.com/consideRatio))\n\n#### Contributors to this release\n\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2020-10-26&to=2020-11-18&type=c))\n\n[@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2020-10-26..2020-11-18&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2020-10-26..2020-11-18&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2020-10-26..2020-11-18&type=Issues)\n\n### [0.12.0] - 2020-10-26\n\n#### Enhancements made\n* [OpenShift] Enable cert verification for self-signed certs and auto-load auth api URL [#363](https://github.com/jupyterhub/oauthenticator/pull/363) ([@vpavlin](https://github.com/vpavlin))\n* [Globus] Support custom username handling [#357](https://github.com/jupyterhub/oauthenticator/pull/357) ([@NickolausDS](https://github.com/NickolausDS))\n* [Google] Adding refresh_token [#350](https://github.com/jupyterhub/oauthenticator/pull/350) ([@missingcharacter](https://github.com/missingcharacter))\n* [Google] Added optional support for google groups [#341](https://github.com/jupyterhub/oauthenticator/pull/341) ([@missingcharacter](https://github.com/missingcharacter))\n* [All] Added extra_authorize_params to pass extra params in the initial request to the identity provider [#338](https://github.com/jupyterhub/oauthenticator/pull/338) ([@NickolausDS](https://github.com/NickolausDS))\n* [GitLab] Improve subgroup support [#333](https://github.com/jupyterhub/oauthenticator/pull/333) ([@akhmerov](https://github.com/akhmerov))\n\n#### Bugs fixed\n* [All] Let auth cookie be influenced by JupyterHub's cookie_options configuration [#378](https://github.com/jupyterhub/oauthenticator/pull/378) ([@Wh1isper](https://github.com/Wh1isper))\n* [GitHub] Respect validate_server_cert attribute [#354](https://github.com/jupyterhub/oauthenticator/pull/354) ([@nvs-abhilash](https://github.com/nvs-abhilash))\n* [Generic] tls verify not being honored at the httprequest level when internal_ssl is enabled [#326](https://github.com/jupyterhub/oauthenticator/pull/326) ([@sstarcher](https://github.com/sstarcher))\n\n#### Maintenance and upkeep improvements\n* Rename OAuthenticator.whitelist to allow [#366](https://github.com/jupyterhub/oauthenticator/pull/366) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* Python package extra dependencies updated [#343](https://github.com/jupyterhub/oauthenticator/pull/343) ([@missingcharacter](https://github.com/missingcharacter))\n* [Generic] Fix failing GenericOAuthenticator tests [#339](https://github.com/jupyterhub/oauthenticator/pull/339) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* [Globus] Remove the need for globus_sdk as a python dependency [#337](https://github.com/jupyterhub/oauthenticator/pull/337) ([@NickolausDS](https://github.com/NickolausDS))\n\n#### Documentation improvements\n* Add changelog for 0.12.0 release [#377](https://github.com/jupyterhub/oauthenticator/pull/377) ([@consideRatio](https://github.com/consideRatio))\n* [Globus] Docs: explain identity_provider better [#362](https://github.com/jupyterhub/oauthenticator/pull/362) ([@NickolausDS](https://github.com/NickolausDS))\n* [OpenShift] Docs: fix broken link for OpenShift OAuth service accounts [#352](https://github.com/jupyterhub/oauthenticator/pull/352) ([@nscozzaro](https://github.com/nscozzaro))\n* Docs: Updating sphinx and pandas_sphinx_theme references [#345](https://github.com/jupyterhub/oauthenticator/pull/345) ([@missingcharacter](https://github.com/missingcharacter))\n* [Google] Added optional support for google groups [#341](https://github.com/jupyterhub/oauthenticator/pull/341) ([@missingcharacter](https://github.com/missingcharacter))\n* [Globus] Remove the need for globus_sdk as a python dependency [#337](https://github.com/jupyterhub/oauthenticator/pull/337) ([@NickolausDS](https://github.com/NickolausDS))\n* Update docs [#336](https://github.com/jupyterhub/oauthenticator/pull/336) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* [Generic] Usage example for Nextcloud [#268](https://github.com/jupyterhub/oauthenticator/pull/268) ([@arneki](https://github.com/arneki))\n\n#### Contributors to this release\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2020-01-31&to=2020-10-26&type=c))\n\n[@ablekh](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aablekh+updated%3A2020-01-31..2020-10-26&type=Issues) | [@akhmerov](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aakhmerov+updated%3A2020-01-31..2020-10-26&type=Issues) | [@Analect](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AAnalect+updated%3A2020-01-31..2020-10-26&type=Issues) | [@arneki](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aarneki+updated%3A2020-01-31..2020-10-26&type=Issues) | [@bellackn](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Abellackn+updated%3A2020-01-31..2020-10-26&type=Issues) | [@betatim](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Abetatim+updated%3A2020-01-31..2020-10-26&type=Issues) | [@CJCShadowsan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ACJCShadowsan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@cmseal](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Acmseal+updated%3A2020-01-31..2020-10-26&type=Issues) | [@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2020-01-31..2020-10-26&type=Issues) | [@d0m84](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ad0m84+updated%3A2020-01-31..2020-10-26&type=Issues) | [@daniel-ciocirlan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Adaniel-ciocirlan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@dmpe](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Admpe+updated%3A2020-01-31..2020-10-26&type=Issues) | [@dmvieira](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Admvieira+updated%3A2020-01-31..2020-10-26&type=Issues) | [@GeorgianaElena](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AGeorgianaElena+updated%3A2020-01-31..2020-10-26&type=Issues) | [@ghezalsherdil](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aghezalsherdil+updated%3A2020-01-31..2020-10-26&type=Issues) | [@guimou](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aguimou+updated%3A2020-01-31..2020-10-26&type=Issues) | [@gweis](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Agweis+updated%3A2020-01-31..2020-10-26&type=Issues) | [@hardik42](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ahardik42+updated%3A2020-01-31..2020-10-26&type=Issues) | [@hbuttguavus](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ahbuttguavus+updated%3A2020-01-31..2020-10-26&type=Issues) | [@jamescross91](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ajamescross91+updated%3A2020-01-31..2020-10-26&type=Issues) | [@linkcd](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Alinkcd+updated%3A2020-01-31..2020-10-26&type=Issues) | [@louis-she](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Alouis-she+updated%3A2020-01-31..2020-10-26&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2020-01-31..2020-10-26&type=Issues) | [@meeseeksmachine](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ameeseeksmachine+updated%3A2020-01-31..2020-10-26&type=Issues) | [@michec81](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amichec81+updated%3A2020-01-31..2020-10-26&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2020-01-31..2020-10-26&type=Issues) | [@missingcharacter](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amissingcharacter+updated%3A2020-01-31..2020-10-26&type=Issues) | [@mransley](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amransley+updated%3A2020-01-31..2020-10-26&type=Issues) | [@NickolausDS](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ANickolausDS+updated%3A2020-01-31..2020-10-26&type=Issues) | [@nscozzaro](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Anscozzaro+updated%3A2020-01-31..2020-10-26&type=Issues) | [@nvs-abhilash](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Anvs-abhilash+updated%3A2020-01-31..2020-10-26&type=Issues) | [@patback66](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Apatback66+updated%3A2020-01-31..2020-10-26&type=Issues) | [@PaulMazzuca](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3APaulMazzuca+updated%3A2020-01-31..2020-10-26&type=Issues) | [@RAbraham](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ARAbraham+updated%3A2020-01-31..2020-10-26&type=Issues) | [@sampathkethineedi](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asampathkethineedi+updated%3A2020-01-31..2020-10-26&type=Issues) | [@saurav-bhagat](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asaurav-bhagat+updated%3A2020-01-31..2020-10-26&type=Issues) | [@shivan10](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ashivan10+updated%3A2020-01-31..2020-10-26&type=Issues) | [@SolarisYan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ASolarisYan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@sstarcher](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asstarcher+updated%3A2020-01-31..2020-10-26&type=Issues) | [@support](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asupport+updated%3A2020-01-31..2020-10-26&type=Issues) | [@umar-sik](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aumar-sik+updated%3A2020-01-31..2020-10-26&type=Issues) | [@vpavlin](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Avpavlin+updated%3A2020-01-31..2020-10-26&type=Issues) | [@welcome](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Awelcome+updated%3A2020-01-31..2020-10-26&type=Issues) | [@Wh1isper](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AWh1isper+updated%3A2020-01-31..2020-10-26&type=Issues) | [@willingc](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Awillingc+updated%3A2020-01-31..2020-10-26&type=Issues) | [@yuvipanda](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ayuvipanda+updated%3A2020-01-31..2020-10-26&type=Issues) | [@zhiyuli](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Azhiyuli+updated%3A2020-01-31..2020-10-26&type=Issues)\n\n## 0.11\n\n### [0.11.0] - 2020-01-30\n\nThe main change in 0.11 is a refactoring of classes to remove mixins,\nreducing the amount of boilerplate needed.\nIn addition, there are some fixes to the Azure AD Authenticator.\nThis should be a fully backward-compatible change,\nexcept in cases where some subclasses were importing these now-unneeded mixin classes,\nsuch as GitHubLoginHandler, GitHubMixin, etc.\n\nAll options should now be configurable via the standard jupyterhub config file.\nThere should no longer be any options that are *only* configurable via environment variable.\n\nThis release also *removes* the latest Authenticators added in 0.10\n(AzureAdB2COAuthenticator, AWSCognitoOAuthenticator, YandexOAuthenticator),\nwhich were released without being fully supported and\nwhich can be achieved through configuration of existing classes,\nsuch as `AzureAd` and `Generic`.\n\nWe don't plan to accept further contributions of new providers if they can be achieved through customization or configuration of existing classes.\nRather, contributors are encouraged to provide example documentation for using new providers,\nor pull requests addressing gaps necessary to do so with the GenericOAuthenticator.\n\n([full changelog](https://github.com/jupyterhub/oauthenticator/compare/0.10.0...ae199077a3a580cb849af17ceccfe8e498134ea3))\n\n\n#### Merged PRs\n\n* [AzureAD] Don't pass resource when requesting a token [#328](https://github.com/jupyterhub/oauthenticator/pull/328) ([@craigminihan](https://github.com/craigminihan))\n* Remove mixins, per-Authenticator LoginHandler classes [#323](https://github.com/jupyterhub/oauthenticator/pull/323) ([@minrk](https://github.com/minrk))\n* [AzureAD] Add support for setting login_service [#319](https://github.com/jupyterhub/oauthenticator/pull/319) ([@zevaryx](https://github.com/zevaryx))\n* skeleton of sphinx docs [#316](https://github.com/jupyterhub/oauthenticator/pull/316) ([@minrk](https://github.com/minrk))\n\n#### Contributors to this release\n\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2019-11-27&to=2020-01-30&type=c))\n\n[@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2019-11-27..2020-01-30&type=Issues) | [@craigminihan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Acraigminihan+updated%3A2019-11-27..2020-01-30&type=Issues) | [@Dmitry1987](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ADmitry1987+updated%3A2019-11-27..2020-01-30&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2019-11-27..2020-01-30&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2019-11-27..2020-01-30&type=Issues) | [@NickolausDS](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ANickolausDS+updated%3A2019-11-27..2020-01-30&type=Issues) | [@zevaryx](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Azevaryx+updated%3A2019-11-27..2020-01-30&type=Issues)\n\n\n## 0.10\n\n### [0.10.0] - 2019-11-27\n\n#### New\n\n* Add AzureAdB2COAuthenticator [#307](https://github.com/jupyterhub/oauthenticator/pull/307) ([@linkcd](https://github.com/linkcd))\n* Add support for `GenericOAuthenticator.username_key` to hold a callable value [#305](https://github.com/jupyterhub/oauthenticator/pull/305) ([@eslavich](https://github.com/eslavich))\n* Add `AzureAdOAuthenticator.username_claim` config field [#280](https://github.com/jupyterhub/oauthenticator/pull/280) ([@jeff-sternberg](https://github.com/jeff-sternberg))\n* Add `AWSCognitoAuthenticator` [#269](https://github.com/jupyterhub/oauthenticator/pull/269) ([@jmartinc89](https://github.com/jmartinc89))\n\n#### Fixed\n\n* mediawiki: utf-8 > binary strings, req. mwoauth>=0.3.7 [#297](https://github.com/jupyterhub/oauthenticator/pull/297) ([@consideRatio](https://github.com/consideRatio))\n* Fixed Globus Logout Handler, added test [#288](https://github.com/jupyterhub/oauthenticator/pull/288) ([@NickolausDS](https://github.com/NickolausDS))\n* Include inherited members in GitLab auth checks, requires GitLab 12.4 or newer, but will fall back to previous behavior for older GitLab versions. [#283](https://github.com/jupyterhub/oauthenticator/pull/283) ([@vindvaki](https://github.com/vindvaki))\n\n#### Maintenance\n\n* Fixed content index in readme, and fixed typo in comments [#310](https://github.com/jupyterhub/oauthenticator/pull/310) ([@linkcd](https://github.com/linkcd))\n* Add scopes documentation to auth0 example [#303](https://github.com/jupyterhub/oauthenticator/pull/303) ([@jbradenbrown](https://github.com/jbradenbrown))\n* Add py3.8 for CI testing [#302](https://github.com/jupyterhub/oauthenticator/pull/302) ([@consideRatio](https://github.com/consideRatio))\n* Travis: Deploy releases to pypi [#301](https://github.com/jupyterhub/oauthenticator/pull/301) ([@manics](https://github.com/manics))\n* Disable MediaWiki's mwoauth==0.3.5 due to a regression [#295](https://github.com/jupyterhub/oauthenticator/pull/295) ([@consideRatio](https://github.com/consideRatio))\n* Add RELEASE.md [#294](https://github.com/jupyterhub/oauthenticator/pull/294) ([@consideRatio](https://github.com/consideRatio))\n* Add PyPI/Travis build badges to README.md [#293](https://github.com/jupyterhub/oauthenticator/pull/293) ([@consideRatio](https://github.com/consideRatio))\n* Fix project name typo [#292](https://github.com/jupyterhub/oauthenticator/pull/292) ([@kinow](https://github.com/kinow))\n* Use traitlet.default for Azure AD tenant_id [#282](https://github.com/jupyterhub/oauthenticator/pull/282) ([@jeff-sternberg](https://github.com/jeff-sternberg))\n* Add clarifying comment into README code block [#279](https://github.com/jupyterhub/oauthenticator/pull/279) ([@raethlein](https://github.com/raethlein))\n\n\n## 0.9\n\n### [0.9.0] - 2019-07-30\n\n- switch to asyncio coroutines from tornado coroutines (requires Python 3.5)\n- add `GenericOAuthenticator.userdata_token_method` configurable\n- add `GenericOAuthenticator.basic_auth` configurable\n- support for OpenShift 4.0 API changes\n\n\n## 0.8\n\n### [0.8.2] - 2019-04-16\n\n- Validate login URL redirects to avoid Open Redirect issues.\n\n### [0.8.1] - 2019-02-28\n\n- Provide better error messages\n- Allow auth scope to be array or strings\n- `GitHubOAuthenticator`: More efficient `org_whitelist` check\n- Use pytest-asyncio instead of pytest-tornado\n- CILogon: New additional_username_claims config for linked identities, fallback to the primary username claim\n- `GitLabOAuthenticator`: New `project_id_whitelist` config to whitelist users who have Developer+ access to the project\n- `GoogleOAuthenticator`: Allow email domains (`hosted_domain`) to be a list\n- Add `jupyterhub-authenticator` entrypoints for jupyterhub 1.0.\n- Cleanup & bugfixes\n\n### [0.8.0] - 2018-08-10\n\n- Add `azuread.AzureADOAuthenticator`\n- Add `CILogonOAuthenticator.idp_whitelist` and `CILogonOAuthenticator.strip_idp_domain` options\n- Add `GenericOAuthenticator.tls_verify` and `GenericOAuthenticator.extra_params` options\n- Add refresh token and scope to generic oauthenticator auth state\n- Better error messages when GitHub oauth fails\n- Stop normalizing mediawiki usernames, which can be case-sensitive\n- Fixes for group-membership checks with GitLab\n- Bugfixes in various authenticators\n- Deprecate GITLAB_HOST in favor of GITLAB_URL, since we expect `https://` in the url, not just the host.\n\n\n## 0.7\n\n### [0.7.3] - 2018-02-16\n\n0.7.3 is a security fix for CVE-2018-7206.\nIt fixes handling of `gitlab_group_whitelist` when using GitLabOAuthenticator.\nThe same fix is backported to 0.6.2.\n\n### [0.7.2] - 2017-10-27\n\n- Fix CILogon OAuth 2 implementation. ePPN claim is used for default username\n  (typically institutional email).\n  `CILogonOAuthenticator.username_claim` can be used to change which field is\n  used for JupyterHub usernames.\n- `GenericOAuthenticator.login_service` is now configurable.\n- default to GitLab API version 4 and allow v3 via GITLAB_API_VERSION=3 environment variable.\n- Add `GlobusOAuthenticator.revoke_tokens_on_logout` and\n  `GlobusOAuthenticator.logout_redirect_url` config for further clearing\n  of credentials on JupyterHub logout.\n\n### [0.7.1] - 2017-10-04\n\n- fix regression in 0.7.0 preventing authentication via providers other than GitHub, MediaWiki\n\n### [0.7.0] - 2017-10-02\n\n0.7.0 adds significant new functionality to all authenticators.\n\n- CILogon now uses OAuth 2 instead of OAuth 1, to be more consistent with the rest.\n- All OAuthenticators support `auth_state` when used with JupyterHub 0.8.\n  In every case, the auth_state is a dict with two keys: `access_token` and the\n  user-info reply identifying the user.\n  For instance, GitHubOAuthenticator auth_state looks like:\n\n  ```python\n  {\n    'acces_token': 'abc123',\n    'github_user': {\n      'username': 'fake-user',\n      'email': 'fake@email.com',\n      ...\n    }\n  }\n  ```\n\n  auth_state can be passed to Spawners by defining a `.pre_spawn_start` method.\n  See examples/auth_state for an example.\n- All OAuthenticators have a `.scope` trait, which is a list of string scopes to request.\n  See your OAuth provider's documentation for what scopes you may want.\n  This is useful in conjunction with `auth_state`, which may be used to pass access tokens\n  to Spawners via environment variables. `.scope` can control what permissions those\n  tokens will have. In general, OAuthenticator default scopes should only have read-only access to identify users.\n- GITHUB_HTTP environment variable can be used to talk to HTTP-only GitHub Enterprise deployments.\n\n## 0.6\n\n### [0.6.2] - 2018-02-16\n\n0.6.2 is a security fix for CVE-2018-7206.\nIt fixes handling of `gitlab_group_whitelist` when using GitLabOAuthenticator.\n\n### [0.6.1] - 2017-08-11\n\n0.6.1 has bugfixes for new behaviors in 0.6.0\n\n- Use `.login_url` and `next_url` from JupyterHub if defined (JupyterHub 0.8)\n- Fix empty login_url where final login redirect could be omitted\n- Fix mediawiki authenticator, which broke in 0.6.0\n- Encode state as base64 instead of JSON, for easier passing in URLs\n\n### [0.6.0] - 2017-07-25\n\n- Support for changes in upcoming JupyterHub 0.8\n- Refactor to share more code across providers\n- Deprecated GITHUB_CLIENT_ID and other provider-specific environment variables\n  for common options.\n  All OAuthenticators support the same OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET, and OAUTH_CALLBACK_URL environment variables.\n- New authenticators:\n  - auth0\n  - globus\n  - okpy\n  - openshift\n  - generic - a generic implementation that can work with any OAuth2 provider\n\n\n## 0.5\n\n### [0.5.1] - 2016-10-05\n\n- Fixes in BitbucketOAuthenticator.check_whitelist\n\n### [0.5.0] - 2016-09-02\n\n- Add GitLabOAuthenticator\n\n## 0.4\n\n### [0.4.1] - 2016-05-18\n\n- Fix typo preventing Google OAuth from working in 0.4.0\n\n### [0.4.0] - 2016-05-11\n\n- Enable username normalization (for mixed-case names on GitHub, requires JupyterHub 0.5).\n  This removes `GitHubOAuthenticator.username_map` introduced in 0.3,\n  because the oauth2 Authenticator has `.username_map` as of 0.5.\n\n## [0.3] - 2016-04-20\n\n- Add Google authenticator\n- Allow specifying OAuth scope\n- Add `GitHubOAuthenticator.username_map` for mapping GitHub usernames to system usernames.\n\n## [0.2] - 2016-01-04\n\n- Add mediawiki authenticator\n\n## 0.1 - 2015-12-22\n\n- First release\n\n\n[Unreleased]: https://github.com/jupyterhub/oauthenticator/compare/0.9.0...HEAD\n[0.9.0]: https://github.com/jupyterhub/oauthenticator/compare/0.8.2...0.9.0\n[0.8.2]: https://github.com/jupyterhub/oauthenticator/compare/0.8.1...0.8.2\n[0.8.1]: https://github.com/jupyterhub/oauthenticator/compare/0.8.0...0.8.1\n[0.8.0]: https://github.com/jupyterhub/oauthenticator/compare/0.7.3...0.8.0\n[0.7.3]: https://github.com/jupyterhub/oauthenticator/compare/0.7.2...0.7.3\n[0.7.2]: https://github.com/jupyterhub/oauthenticator/compare/0.7.1...0.7.2\n[0.7.1]: https://github.com/jupyterhub/oauthenticator/compare/0.7.0...0.7.1\n[0.7.0]: https://github.com/jupyterhub/oauthenticator/compare/0.6.1...0.7.0\n[0.6.2]: https://github.com/jupyterhub/oauthenticator/compare/0.6.1...0.6.2\n[0.6.1]: https://github.com/jupyterhub/oauthenticator/compare/0.6.0...0.6.1\n[0.6.0]:https://github.com/jupyterhub/oauthenticator/compare/0.5.1...0.6.0\n[0.5.1]:https://github.com/jupyterhub/oauthenticator/compare/0.5.0...0.5.1\n[0.5.0]:https://github.com/jupyterhub/oauthenticator/compare/0.4.1...0.5.0\n[0.4.1]: https://github.com/jupyterhub/oauthenticator/compare/0.4.0...0.4.1\n[0.4.0]:https://github.com/jupyterhub/oauthenticator/compare/0.3.0...0.4.0\n[0.3]: https://github.com/jupyterhub/oauthenticator/compare/0.2.0...0.3.0\n[0.2]: https://github.com/jupyterhub/oauthenticator/compare/0.1.0...0.2.0\n", "\"\"\"\nCustom Authenticator to use Bitbucket OAuth with JupyterHub\n\"\"\"\n\nimport json\nimport urllib\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set, default, observe\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\".format(access_token),\n    }\n\n\nclass BitbucketOAuthenticator(OAuthenticator):\n\n    _deprecated_aliases = {\n        \"team_whitelist\": (\"allowed_teams\", \"0.12.0\"),\n    }\n\n    @observe(*list(_deprecated_aliases))\n    def _deprecated_trait(self, change):\n        super()._deprecated_trait(change)\n\n    login_service = \"Bitbucket\"\n    client_id_env = 'BITBUCKET_CLIENT_ID'\n    client_secret_env = 'BITBUCKET_CLIENT_SECRET'\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://bitbucket.org/site/oauth2/authorize\"\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"https://bitbucket.org/site/oauth2/access_token\"\n\n    team_whitelist = Set(help=\"Deprecated, use `BitbucketOAuthenticator.allowed_teams`\", config=True,)\n\n    allowed_teams = Set(\n        config=True, help=\"Automatically allow members of selected teams\"\n    )\n\n\n    headers = {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\",\n    }\n\n    async def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n        url = url_concat(\"https://bitbucket.org/site/oauth2/access_token\", params)\n\n        bb_header = {\"Content-Type\": \"application/x-www-form-urlencoded;charset=utf-8\"}\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            auth_username=self.client_id,\n            auth_password=self.client_secret,\n            body=urllib.parse.urlencode(params).encode('utf-8'),\n            headers=bb_header,\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            \"https://api.bitbucket.org/2.0/user\",\n            method=\"GET\",\n            headers=_api_headers(access_token),\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n\n        # Check if user is a member of any allowed teams.\n        # This check is performed here, as the check requires `access_token`.\n        if self.allowed_teams:\n            user_in_team = await self._check_membership_allowed_teams(username, access_token)\n            if not user_in_team:\n                self.log.warning(\"%s not in team allowed list of users\", username)\n                return None\n\n        return {\n            'name': username,\n            'auth_state': {'access_token': access_token, 'bitbucket_user': resp_json},\n        }\n\n    async def _check_membership_allowed_teams(self, username, access_token):\n        http_client = AsyncHTTPClient()\n\n        headers = _api_headers(access_token)\n        # We verify the team membership by calling teams endpoint.\n        next_page = url_concat(\n            \"https://api.bitbucket.org/2.0/teams\", {'role': 'member'}\n        )\n        while next_page:\n            req = HTTPRequest(next_page, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req)\n            resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n            next_page = resp_json.get('next', None)\n\n            user_teams = set([entry[\"username\"] for entry in resp_json[\"values\"]])\n            # check if any of the organizations seen thus far are in the allowed list\n            if len(self.allowed_teams & user_teams) > 0:\n                return True\n        return False\n\n\nclass LocalBitbucketOAuthenticator(LocalAuthenticator, BitbucketOAuthenticator):\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"CILogon OAuthAuthenticator for JupyterHub\n\nUses OAuth 2.0 with cilogon.org (override with CILOGON_HOST)\n\nCaveats:\n\n- For allowed user list /admin purposes, username will be the ePPN by default.\n  This is typically an email address and may not work as a Unix userid.\n  Normalization may be required to turn the JupyterHub username into a Unix username.\n- Default username_claim of ePPN does not work for all providers,\n  e.g. generic OAuth such as Google.\n  Use `c.CILogonOAuthenticator.username_claim = 'email'` to use\n  email instead of ePPN as the JupyterHub username.\n\"\"\"\n\nimport json\nimport os\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom traitlets import Unicode, List, Bool, default, validate, observe\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\nclass CILogonLoginHandler(OAuthLoginHandler):\n    \"\"\"See http://www.cilogon.org/oidc for general information.\"\"\"\n\n    def authorize_redirect(self, *args, **kwargs):\n        \"\"\"Add idp, skin to redirect params\"\"\"\n        extra_params = kwargs.setdefault('extra_params', {})\n        if self.authenticator.idp:\n            extra_params[\"selected_idp\"] = self.authenticator.idp\n        if self.authenticator.skin:\n            extra_params[\"skin\"] = self.authenticator.skin\n\n        return super().authorize_redirect(*args, **kwargs)\n\n\nclass CILogonOAuthenticator(OAuthenticator):\n    _deprecated_aliases = {\n        \"idp_whitelist\": (\"allowed_idps\", \"0.12.0\"),\n    }\n\n    @observe(*list(_deprecated_aliases))\n    def _deprecated_trait(self, change):\n        super()._deprecated_trait(change)\n\n    login_service = \"CILogon\"\n\n    client_id_env = 'CILOGON_CLIENT_ID'\n    client_secret_env = 'CILOGON_CLIENT_SECRET'\n    login_handler = CILogonLoginHandler\n\n    cilogon_host = Unicode(os.environ.get(\"CILOGON_HOST\") or \"cilogon.org\", config=True)\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://%s/authorize\" % self.cilogon_host\n\n    @default(\"token_url\")\n    def _token_url(self):\n        return \"https://%s/oauth2/token\" % self.cilogon_host\n\n    scope = List(\n        Unicode(),\n        default_value=['openid', 'email', 'org.cilogon.userinfo'],\n        config=True,\n        help=\"\"\"The OAuth scopes to request.\n\n        See cilogon_scope.md for details.\n        At least 'openid' is required.\n        \"\"\",\n    )\n\n    @validate('scope')\n    def _validate_scope(self, proposal):\n        \"\"\"ensure openid is requested\"\"\"\n        if 'openid' not in proposal.value:\n            return ['openid'] + proposal.value\n        return proposal.value\n\n    idp_whitelist = List(help=\"Deprecated, use `CIlogonOAuthenticator.allowed_idps`\", config=True,)\n    allowed_idps = List(\n        config=True,\n        help=\"\"\"A list of IDP which can be stripped from the username after the @ sign.\"\"\",\n    )\n    strip_idp_domain = Bool(\n        False,\n        config=True,\n        help=\"\"\"Remove the IDP domain from the username. Note that only domains which\n             appear in the `allowed_idps` will be stripped.\"\"\",\n    )\n    idp = Unicode(\n        config=True,\n        help=\"\"\"The `idp` attribute is the SAML Entity ID of the user's selected\n            identity provider.\n\n            See https://cilogon.org/include/idplist.xml for the list of identity\n            providers supported by CILogon.\n        \"\"\",\n    )\n    skin = Unicode(\n        config=True,\n        help=\"\"\"The `skin` attribute is the name of the custom CILogon interface skin\n            for your application.\n\n            Contact help@cilogon.org to request a custom skin.\n        \"\"\",\n    )\n    username_claim = Unicode(\n        \"eppn\",\n        config=True,\n        help=\"\"\"The claim in the userinfo response from which to get the JupyterHub username\n\n            Examples include: eppn, email\n\n            What keys are available will depend on the scopes requested.\n\n            See http://www.cilogon.org/oidc for details.\n        \"\"\",\n    )\n\n    additional_username_claims = List(\n        config=True,\n        help=\"\"\"Additional claims to check if the username_claim fails.\n\n        This is useful for linked identities where not all of them return\n        the primary username_claim.\n        \"\"\",\n    )\n\n    async def authenticate(self, handler, data=None):\n        \"\"\"We set up auth_state based on additional CILogon info if we\n        receive it.\n        \"\"\"\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a CILogon Access Token\n        # See: http://www.cilogon.org/oidc\n        headers = {\"Accept\": \"application/json\", \"User-Agent\": \"JupyterHub\"}\n\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            redirect_uri=self.oauth_callback_url,\n            code=code,\n            grant_type='authorization_code',\n        )\n\n        url = url_concat(self.token_url, params)\n\n        req = HTTPRequest(url, headers=headers, method=\"POST\", body='')\n\n        resp = await http_client.fetch(req)\n        token_response = json.loads(resp.body.decode('utf8', 'replace'))\n        access_token = token_response['access_token']\n        self.log.info(\"Access token acquired.\")\n        # Determine who the logged in user is\n        params = dict(access_token=access_token)\n        req = HTTPRequest(\n            url_concat(\"https://%s/oauth2/userinfo\" % self.cilogon_host, params),\n            headers=headers,\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        claimlist = [self.username_claim]\n        if self.additional_username_claims:\n            claimlist.extend(self.additional_username_claims)\n\n        for claim in claimlist:\n            username = resp_json.get(claim)\n            if username:\n                break\n        if not username:\n            if len(claimlist) < 2:\n                self.log.error(\n                    \"Username claim %s not found in response: %s\",\n                    self.username_claim,\n                    sorted(resp_json.keys()),\n                )\n            else:\n                self.log.error(\n                    \"No username claim from %r in response: %s\",\n                    claimlist,\n                    sorted(resp_json.keys()),\n                )\n            raise web.HTTPError(500, \"Failed to get username from CILogon\")\n\n        if self.allowed_idps:\n            gotten_name, gotten_idp = username.split('@')\n            if gotten_idp not in self.allowed_idps:\n                self.log.error(\n                    \"Trying to login from not allowed domain %s\", gotten_idp\n                )\n                raise web.HTTPError(500, \"Trying to login from a domain not allowed\")\n            if len(self.allowed_idps) == 1 and self.strip_idp_domain:\n                username = gotten_name\n        userdict = {\"name\": username}\n        # Now we set up auth_state\n        userdict[\"auth_state\"] = auth_state = {}\n        # Save the token response and full CILogon reply in auth state\n        # These can be used for user provisioning\n        #  in the Lab/Notebook environment.\n        auth_state['token_response'] = token_response\n        # store the whole user model in auth_state.cilogon_user\n        # keep access_token as well, in case anyone was relying on it\n        auth_state['access_token'] = access_token\n        auth_state['cilogon_user'] = resp_json\n        return userdict\n\n\nclass LocalCILogonOAuthenticator(LocalAuthenticator, CILogonOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nAuthenticator to use GitHub OAuth with JupyterHub\n\"\"\"\n\n\nimport json\nimport os\nimport re\nimport string\nimport warnings\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient, HTTPError\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import List, Set, Unicode, default, observe\n\nfrom .common import next_page_from_links\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"token {}\".format(access_token),\n    }\n\n\nclass GitHubOAuthenticator(OAuthenticator):\n\n    # see github_scopes.md for details about scope config\n    # set scopes via config, e.g.\n    # c.GitHubOAuthenticator.scope = ['read:org']\n\n    _deprecated_aliases = {\n        \"github_organization_whitelist\": (\"allowed_organizations\", \"0.12.0\"),\n    }\n\n    @observe(*list(_deprecated_aliases))\n    def _deprecated_trait(self, change):\n        super()._deprecated_trait(change)\n\n    login_service = \"GitHub\"\n\n    github_url = Unicode(\"https://github.com\", config=True)\n\n    @default(\"github_url\")\n    def _github_url_default(self):\n        github_url = os.environ.get(\"GITHUB_URL\")\n        if not github_url:\n            # fallback on older GITHUB_HOST config,\n            # treated the same as GITHUB_URL\n            host = os.environ.get(\"GITHUB_HOST\")\n            if host:\n                if os.environ.get(\"GITHUB_HTTP\"):\n                    protocol = \"http\"\n                    warnings.warn(\n                        'Use of GITHUB_HOST with GITHUB_HTTP might be deprecated in the future. '\n                        'Use GITHUB_URL=http://{} to set host and protocol together.'.format(\n                            host\n                        ),\n                        PendingDeprecationWarning,\n                    )\n                else:\n                    protocol = \"https\"\n                github_url = \"{}://{}\".format(protocol, host)\n\n        if github_url:\n            if '://' not in github_url:\n                # ensure protocol is included, assume https if missing\n                github_url = 'https://' + github_url\n\n            return github_url\n        else:\n            # nothing specified, this is the true default\n            github_url = \"https://github.com\"\n\n        # ensure no trailing slash\n        return github_url.rstrip(\"/\")\n\n    github_api = Unicode(\"https://api.github.com\", config=True)\n\n    @default(\"github_api\")\n    def _github_api_default(self):\n        if self.github_url == \"https://github.com\":\n            return \"https://api.github.com\"\n        else:\n            return self.github_url + \"/api/v3\"\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"%s/login/oauth/authorize\" % (self.github_url)\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/login/oauth/access_token\" % (self.github_url)\n\n    # deprecated names\n    github_client_id = Unicode(config=True, help=\"DEPRECATED\")\n\n    def _github_client_id_changed(self, name, old, new):\n        self.log.warning(\"github_client_id is deprecated, use client_id\")\n        self.client_id = new\n\n    github_client_secret = Unicode(config=True, help=\"DEPRECATED\")\n\n    def _github_client_secret_changed(self, name, old, new):\n        self.log.warning(\"github_client_secret is deprecated, use client_secret\")\n        self.client_secret = new\n\n    client_id_env = 'GITHUB_CLIENT_ID'\n    client_secret_env = 'GITHUB_CLIENT_SECRET'\n\n    github_organization_whitelist = Set(help=\"Deprecated, use `GitHubOAuthenticator.allowed_organizations`\", config=True,)\n\n    allowed_organizations = Set(\n        config=True, help=\"Automatically allow members of selected organizations\"\n    )\n\n    async def authenticate(self, handler, data=None):\n        \"\"\"We set up auth_state based on additional GitHub info if we\n        receive it.\n        \"\"\"\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitHub Access Token\n        #\n        # See: https://developer.github.com/v3/oauth/\n\n        # GitHub specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id, client_secret=self.client_secret, code=code\n        )\n\n        url = url_concat(self.token_url, params)\n\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            headers={\"Accept\": \"application/json\"},\n            body='',  # Body is required for a POST...\n            validate_cert=self.validate_server_cert,\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        if 'access_token' in resp_json:\n            access_token = resp_json['access_token']\n        elif 'error_description' in resp_json:\n            raise HTTPError(\n                403,\n                \"An access token was not returned: {}\".format(\n                    resp_json['error_description']\n                ),\n            )\n        else:\n            raise HTTPError(500, \"Bad response: {}\".format(resp))\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            self.github_api + \"/user\",\n            method=\"GET\",\n            headers=_api_headers(access_token),\n            validate_cert=self.validate_server_cert,\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"login\"]\n        # username is now the GitHub userid.\n        if not username:\n            return None\n        # Check if user is a member of any allowed organizations.\n        # This check is performed here, as it requires `access_token`.\n        if self.allowed_organizations:\n            for org in self.allowed_organizations:\n                user_in_org = await self._check_membership_allowed_organizations(\n                    org, username, access_token\n                )\n                if user_in_org:\n                    break\n            else:  # User not found in member list for any organisation\n                self.log.warning(\"User %s is not in allowed org list\", username)\n                return None\n        userdict = {\"name\": username}\n        # Now we set up auth_state\n        userdict[\"auth_state\"] = auth_state = {}\n        # Save the access token and full GitHub reply (name, id, email) in auth state\n        # These can be used for user provisioning in the Lab/Notebook environment.\n        # e.g.\n        #  1) stash the access token\n        #  2) use the GitHub ID as the id\n        #  3) set up name/email for .gitconfig\n        auth_state['access_token'] = access_token\n        # store the whole user model in auth_state.github_user\n        auth_state['github_user'] = resp_json\n        # A public email will return in the initial query (assuming default scope).\n        # Private will not.\n\n        return userdict\n\n    async def _check_membership_allowed_organizations(self, org, username, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check membership of user `username` for organization `org` via api [check-membership](https://developer.github.com/v3/orgs/members/#check-membership)\n        # With empty scope (even if authenticated by an org member), this\n        #  will only await public org members.  You want 'read:org' in order\n        #  to be able to iterate through all members.\n        check_membership_url = \"%s/orgs/%s/members/%s\" % (\n            self.github_api,\n            org,\n            username,\n        )\n        req = HTTPRequest(\n            check_membership_url,\n            method=\"GET\",\n            headers=headers,\n            validate_cert=self.validate_server_cert,\n        )\n        self.log.debug(\n            \"Checking GitHub organization membership: %s in %s?\", username, org\n        )\n        resp = await http_client.fetch(req, raise_error=False)\n        print(resp)\n        if resp.code == 204:\n            self.log.info(\"Allowing %s as member of %s\", username, org)\n            return True\n        else:\n            try:\n                resp_json = json.loads((resp.body or b'').decode('utf8', 'replace'))\n                message = resp_json.get('message', '')\n            except ValueError:\n                message = ''\n            self.log.debug(\n                \"%s does not appear to be a member of %s (status=%s): %s\",\n                username,\n                org,\n                resp.code,\n                message,\n            )\n        return False\n\n\nclass LocalGitHubOAuthenticator(LocalAuthenticator, GitHubOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nCustom Authenticator to use GitLab OAuth with JupyterHub\n\"\"\"\n\n\nimport json\nimport os\nimport re\nimport sys\nimport warnings\nfrom urllib.parse import quote\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.escape import url_escape\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set, CUnicode, Unicode, default, observe\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\".format(access_token),\n    }\n\n\nclass GitLabOAuthenticator(OAuthenticator):\n    # see gitlab_scopes.md for details about scope config\n    # set scopes via config, e.g.\n    # c.GitLabOAuthenticator.scope = ['read_user']\n\n    _deprecated_aliases = {\n        \"gitlab_group_whitelist\": (\"allowed_gitlab_groups\", \"0.12.0\"),\n        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\")\n    }\n\n    @observe(*list(_deprecated_aliases))\n    def _deprecated_trait(self, change):\n        super()._deprecated_trait(change)\n\n    login_service = \"GitLab\"\n\n    client_id_env = 'GITLAB_CLIENT_ID'\n    client_secret_env = 'GITLAB_CLIENT_SECRET'\n\n    gitlab_url = Unicode(\"https://gitlab.com\", config=True)\n\n    @default(\"gitlab_url\")\n    def _default_gitlab_url(self):\n        \"\"\"get default gitlab url from env\"\"\"\n        gitlab_url = os.getenv('GITLAB_URL')\n        gitlab_host = os.getenv('GITLAB_HOST')\n\n        if not gitlab_url and gitlab_host:\n            warnings.warn(\n                'Use of GITLAB_HOST might be deprecated in the future. '\n                'Rename GITLAB_HOST environment variable to GITLAB_URL.',\n                PendingDeprecationWarning,\n            )\n            if gitlab_host.startswith(('https:', 'http:')):\n                gitlab_url = gitlab_host\n            else:\n                # Hides common mistake of users which set the GITLAB_HOST\n                # without a protocol specification.\n                gitlab_url = 'https://{0}'.format(gitlab_host)\n                warnings.warn(\n                    'The https:// prefix has been added to GITLAB_HOST.'\n                    'Set GITLAB_URL=\"{0}\" instead.'.format(gitlab_host)\n                )\n\n        # default to gitlab.com\n        if not gitlab_url:\n            gitlab_url = 'https://gitlab.com'\n\n        return gitlab_url\n\n    gitlab_api_version = CUnicode('4', config=True)\n\n    @default('gitlab_api_version')\n    def _gitlab_api_version_default(self):\n        return os.environ.get('GITLAB_API_VERSION') or '4'\n\n    gitlab_api = Unicode(config=True)\n\n    @default(\"gitlab_api\")\n    def _default_gitlab_api(self):\n        return '%s/api/v%s' % (self.gitlab_url, self.gitlab_api_version)\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"%s/oauth/authorize\" % self.gitlab_url\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/oauth/access_token\" % self.gitlab_url\n\n    gitlab_group_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_gitlab_groups`\", config=True,)\n\n    allowed_gitlab_groups = Set(\n        config=True, help=\"Automatically allow members of selected groups\"\n    )\n\n    gitlab_project_id_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_project_ids`\", config=True,)\n\n    allowed_project_ids = Set(\n        config=True,\n        help=\"Automatically allow members with Developer access to selected project ids\",\n    )\n\n    gitlab_version = None\n\n    async def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitLab Access Token\n        #\n        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md\n\n        # GitLab specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            code=code,\n            grant_type=\"authorization_code\",\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n        validate_server_cert = self.validate_server_cert\n\n        url = url_concat(\"%s/oauth/token\" % self.gitlab_url, params)\n\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            headers={\"Accept\": \"application/json\"},\n            validate_cert=validate_server_cert,\n            body='',  # Body is required for a POST...\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # memoize gitlab version for class lifetime\n        if self.gitlab_version is None:\n            self.gitlab_version = await self._get_gitlab_version(access_token)\n            self.member_api_variant = 'all/' if self.gitlab_version >= [12, 4] else ''\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            \"%s/user\" % self.gitlab_api,\n            method=\"GET\",\n            validate_cert=validate_server_cert,\n            headers=_api_headers(access_token),\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n        user_id = resp_json[\"id\"]\n        is_admin = resp_json.get(\"is_admin\", False)\n\n        # Check if user is a member of any allowed groups or projects.\n        # These checks are performed here, as it requires `access_token`.\n        user_in_group = user_in_project = False\n        is_group_specified = is_project_id_specified = False\n\n        if self.allowed_gitlab_groups:\n            is_group_specified = True\n            user_in_group = await self._check_membership_allowed_groups(user_id, access_token)\n\n        # We skip project_id check if user is in allowed group.\n        if self.allowed_project_ids and not user_in_group:\n            is_project_id_specified = True\n            user_in_project = await self._check_membership_allowed_project_ids(\n                user_id, access_token\n            )\n\n        no_config_specified = not (is_group_specified or is_project_id_specified)\n\n        if (\n            (is_group_specified and user_in_group)\n            or (is_project_id_specified and user_in_project)\n            or no_config_specified\n        ):\n            return {\n                'name': username,\n                'auth_state': {'access_token': access_token, 'gitlab_user': resp_json},\n            }\n        else:\n            self.log.warning(\"%s not in group or project allowed list\", username)\n            return None\n\n    async def _get_gitlab_version(self, access_token):\n        url = '%s/version' % self.gitlab_api\n        req = HTTPRequest(\n            url,\n            method=\"GET\",\n            headers=_api_headers(access_token),\n            validate_cert=self.validate_server_cert,\n        )\n        resp = await AsyncHTTPClient().fetch(req, raise_error=True)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n        version_strings = resp_json['version'].split('-')[0].split('.')[:3]\n        version_ints = list(map(int, version_strings))\n        return version_ints\n\n    async def _check_membership_allowed_groups(self, user_id, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check if user is a member of any group in the allowed list\n        for group in map(url_escape, self.allowed_gitlab_groups):\n            url = \"%s/groups/%s/members/%s%d\" % (\n                self.gitlab_api,\n                quote(group, safe=''),\n                self.member_api_variant,\n                user_id,\n            )\n            req = HTTPRequest(url, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req, raise_error=False)\n            if resp.code == 200:\n                return True  # user _is_ in group\n        return False\n\n    async def _check_membership_allowed_project_ids(self, user_id, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check if user has developer access to any project in the allowed list\n        for project in self.allowed_project_ids:\n            url = \"%s/projects/%s/members/%s%d\" % (\n                self.gitlab_api,\n                project,\n                self.member_api_variant,\n                user_id,\n            )\n            req = HTTPRequest(url, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req, raise_error=False)\n\n            if resp.body:\n                resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n                access_level = resp_json.get('access_level', 0)\n\n                # We only allow access level Developer and above\n                # Reference: https://docs.gitlab.com/ee/api/members.html\n                if resp.code == 200 and access_level >= 30:\n                    return True\n        return False\n\n\nclass LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nCustom Authenticator to use Google OAuth with JupyterHub.\n\nDerived from the GitHub OAuth authenticator.\n\"\"\"\n\nimport os\nimport json\nimport urllib.parse\n\nfrom tornado import gen\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\nfrom tornado.auth import GoogleOAuth2Mixin\nfrom tornado.web import HTTPError\n\nfrom traitlets import Dict, Unicode, List, default, validate, observe\n\nfrom jupyterhub.crypto import decrypt, EncryptionUnavailable, InvalidToken\nfrom jupyterhub.auth import LocalAuthenticator\nfrom jupyterhub.utils import url_path_join\n\nfrom .oauth2 import OAuthLoginHandler, OAuthCallbackHandler, OAuthenticator\n\ndef check_user_in_groups(member_groups, allowed_groups):\n    # Check if user is a member of any group in the allowed groups\n    if any(g in member_groups for g in allowed_groups):\n        return True  # user _is_ in group\n    else:\n        return False\n\n\nclass GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):\n    _deprecated_aliases = {\n        \"google_group_whitelist\": (\"allowed_google_groups\", \"0.12.0\"),\n    }\n\n    @observe(*list(_deprecated_aliases))\n    def _deprecated_trait(self, change):\n        super()._deprecated_trait(change)\n\n    google_api_url = Unicode(\"https://www.googleapis.com\", config=True)\n\n    @default('google_api_url')\n    def _google_api_url(self):\n        \"\"\"get default google apis url from env\"\"\"\n        google_api_url = os.getenv('GOOGLE_API_URL')\n\n        # default to googleapis.com\n        if not google_api_url:\n            google_api_url = 'https://www.googleapis.com'\n\n        return google_api_url\n\n    @default('scope')\n    def _scope_default(self):\n        return ['openid', 'email']\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://accounts.google.com/o/oauth2/v2/auth\"\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/oauth2/v4/token\" % (self.google_api_url)\n\n    google_service_account_keys = Dict(\n        Unicode(),\n        help=\"Service account keys to use with each domain, see https://developers.google.com/admin-sdk/directory/v1/guides/delegation\"\n    ).tag(config=True)\n\n    gsuite_administrator = Dict(\n        Unicode(),\n        help=\"Username of a G Suite Administrator for the service account to act as\"\n    ).tag(config=True)\n\n    google_group_whitelist = Dict(help=\"Deprecated, use `GoogleOAuthenticator.allowed_google_groups`\", config=True,)\n\n    allowed_google_groups = Dict(\n        List(Unicode()),\n        help=\"Automatically allow members of selected groups\"\n    ).tag(config=True)\n\n    admin_google_groups = Dict(\n        List(Unicode()),\n        help=\"Groups whose members should have Jupyterhub admin privileges\"\n    ).tag(config=True)\n\n    user_info_url = Unicode(\n        \"https://www.googleapis.com/oauth2/v1/userinfo\", config=True\n    )\n\n    hosted_domain = List(\n        Unicode(),\n        config=True,\n        help=\"\"\"List of domains used to restrict sign-in, e.g. mycollege.edu\"\"\",\n    )\n\n    @default('hosted_domain')\n    def _hosted_domain_from_env(self):\n        domains = []\n        for domain in os.environ.get('HOSTED_DOMAIN', '').split(';'):\n            if domain:\n                # check falsy to avoid trailing separators\n                # adding empty domains\n                domains.append(domain)\n        return domains\n\n    @validate('hosted_domain')\n    def _cast_hosted_domain(self, proposal):\n        \"\"\"handle backward-compatibility with hosted_domain is a single domain as a string\"\"\"\n        if isinstance(proposal.value, str):\n            # pre-0.9 hosted_domain was a string\n            # set it to a single item list\n            # (or if it's empty, an empty list)\n            if proposal.value == '':\n                return []\n            return [proposal.value]\n        return proposal.value\n\n    login_service = Unicode(\n        os.environ.get('LOGIN_SERVICE', 'Google'),\n        config=True,\n        help=\"\"\"Google Apps hosted domain string, e.g. My College\"\"\",\n    )\n\n    async def authenticate(self, handler, data=None, google_groups=None):\n        code = handler.get_argument(\"code\")\n        body = urllib.parse.urlencode(\n            dict(\n                code=code,\n                redirect_uri=self.get_callback_url(handler),\n                client_id=self.client_id,\n                client_secret=self.client_secret,\n                grant_type=\"authorization_code\",\n            )\n        )\n\n        http_client = AsyncHTTPClient()\n\n        response = await http_client.fetch(\n            self.token_url,\n            method=\"POST\",\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n            body=body,\n        )\n\n        user = json.loads(response.body.decode(\"utf-8\", \"replace\"))\n        access_token = str(user['access_token'])\n        refresh_token = user.get('refresh_token', None)\n\n        response = await http_client.fetch(\n            self.user_info_url + '?access_token=' + access_token\n        )\n\n        if not response:\n            handler.clear_all_cookies()\n            raise HTTPError(500, 'Google authentication failed')\n\n        bodyjs = json.loads(response.body.decode())\n        user_email = username = bodyjs['email']\n        user_email_domain = user_email.split('@')[1]\n\n        if not bodyjs['verified_email']:\n            self.log.warning(\"Google OAuth unverified email attempt: %s\", user_email)\n            raise HTTPError(403, \"Google email {} not verified\".format(user_email))\n\n        if self.hosted_domain:\n            if user_email_domain not in self.hosted_domain:\n                self.log.warning(\n                    \"Google OAuth unauthorized domain attempt: %s\", user_email\n                )\n                raise HTTPError(\n                    403,\n                    \"Google account domain @{} not authorized.\".format(\n                        user_email_domain\n                    ),\n                )\n            if len(self.hosted_domain) == 1:\n                # unambiguous domain, use only base name\n                username = user_email.split('@')[0]\n\n        if refresh_token is None:\n            self.log.debug(\"Refresh token was empty, will try to pull refresh_token from previous auth_state\")\n            user = handler.find_user(username)\n\n            if user:\n                self.log.debug(\"encrypted_auth_state was found, will try to decrypt and pull refresh_token from it\")\n                try:\n                    encrypted = user.encrypted_auth_state\n                    auth_state = await decrypt(encrypted)\n                    refresh_token = auth_state.get('refresh_token')\n                except (ValueError, InvalidToken, EncryptionUnavailable) as e:\n                    self.log.warning(\n                        \"Failed to retrieve encrypted auth_state for %s because %s\",\n                        username,\n                        e,\n                    )\n\n        user_info = {\n            'name': username,\n            'auth_state': {\n                'access_token': access_token,\n                'refresh_token': refresh_token,\n                'google_user': bodyjs\n            }\n        }\n\n        if self.admin_google_groups or self.allowed_google_groups:\n            user_info = await self._add_google_groups_info(user_info, google_groups)\n\n        return user_info\n\n    def _service_client_credentials(self, scopes, user_email_domain):\n        \"\"\"\n        Return a configured service client credentials for the API.\n        \"\"\"\n        try:\n            from google.oauth2 import service_account\n        except:\n            raise ImportError(\n                \"Could not import google.oauth2's service_account,\"\n                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"\n            )\n\n        gsuite_administrator_email = \"{}@{}\".format(self.gsuite_administrator[user_email_domain], user_email_domain)\n        self.log.debug(\"scopes are %s, user_email_domain is %s\", scopes, user_email_domain)\n        credentials = service_account.Credentials.from_service_account_file(\n            self.google_service_account_keys[user_email_domain],\n            scopes=scopes\n        )\n\n        credentials = credentials.with_subject(gsuite_administrator_email)\n\n        return credentials\n\n    def _service_client(self, service_name, service_version, credentials, http=None):\n        \"\"\"\n        Return a configured service client for the API.\n        \"\"\"\n        try:\n            from googleapiclient.discovery import build\n        except:\n            raise ImportError(\n                \"Could not import googleapiclient.discovery's build,\"\n                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"\n            )\n\n        self.log.debug(\"service_name is %s, service_version is %s\", service_name, service_version)\n\n        return build(\n            serviceName=service_name,\n            version=service_version,\n            credentials=credentials,\n            cache_discovery=False,\n            http=http)\n\n    async def _google_groups_for_user(self, user_email, credentials, http=None):\n        \"\"\"\n        Return google groups a given user is a member of\n        \"\"\"\n        service = self._service_client(\n            service_name='admin',\n            service_version='directory_v1',\n            credentials=credentials,\n            http=http)\n\n        results = service.groups().list(userKey=user_email).execute()\n        results = [ g['email'].split('@')[0] for g in results.get('groups', [{'email': None}]) ]\n        self.log.debug(\"user_email %s is a member of %s\", user_email, results)\n        return results\n\n    async def _add_google_groups_info(self, user_info, google_groups=None):\n        user_email_domain=user_info['auth_state']['google_user']['hd']\n        user_email=user_info['auth_state']['google_user']['email']\n        if google_groups is None:\n            credentials = self._service_client_credentials(\n                    scopes=['%s/auth/admin.directory.group.readonly' % (self.google_api_url)],\n                    user_email_domain=user_email_domain)\n            google_groups = await self._google_groups_for_user(\n                    user_email=user_email,\n                    credentials=credentials)\n        user_info['auth_state']['google_user']['google_groups'] = google_groups\n\n        # Check if user is a member of any admin groups.\n        if self.admin_google_groups:\n            is_admin = check_user_in_groups(google_groups, self.admin_google_groups[user_email_domain])\n        # Check if user is a member of any allowed groups.\n        user_in_group = check_user_in_groups(google_groups, self.allowed_google_groups[user_email_domain])\n\n        if self.admin_google_groups and (is_admin or user_in_group):\n            user_info['admin'] = is_admin\n            return user_info\n        elif user_in_group:\n            return user_info\n        else:\n            return None\n\n\nclass LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator):\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nBase classes for Custom Authenticator to use OAuth with JupyterHub\n\nMost of the code c/o Kyle Kelley (@rgbkrk)\n\"\"\"\n\nimport base64\nimport json\nimport os\nfrom urllib.parse import quote, urlparse\nimport uuid\n\nfrom tornado import web\nfrom tornado.auth import OAuth2Mixin\nfrom tornado.log import app_log\n\nfrom jupyterhub.handlers import BaseHandler\nfrom jupyterhub.auth import Authenticator\nfrom jupyterhub.utils import url_path_join\n\nfrom traitlets import Unicode, Bool, List, Dict, default, observe\n\n\ndef guess_callback_uri(protocol, host, hub_server_url):\n    return '{proto}://{host}{path}'.format(\n        proto=protocol, host=host, path=url_path_join(hub_server_url, 'oauth_callback')\n    )\n\n\nSTATE_COOKIE_NAME = 'oauthenticator-state'\n\n\ndef _serialize_state(state):\n    \"\"\"Serialize OAuth state to a base64 string after passing through JSON\"\"\"\n    json_state = json.dumps(state)\n    return base64.urlsafe_b64encode(json_state.encode('utf8')).decode('ascii')\n\n\ndef _deserialize_state(b64_state):\n    \"\"\"Deserialize OAuth state as serialized in _serialize_state\"\"\"\n    if isinstance(b64_state, str):\n        b64_state = b64_state.encode('ascii')\n    try:\n        json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')\n    except ValueError:\n        app_log.error(\"Failed to b64-decode state: %r\", b64_state)\n        return {}\n    try:\n        return json.loads(json_state)\n    except ValueError:\n        app_log.error(\"Failed to json-decode state: %r\", json_state)\n        return {}\n\n\nclass OAuthLoginHandler(OAuth2Mixin, BaseHandler):\n    \"\"\"Base class for OAuth login handler\n\n    Typically subclasses will need\n    \"\"\"\n\n    # these URLs are part of the OAuth2Mixin API\n    # get them from the Authenticator object\n    @property\n    def _OAUTH_AUTHORIZE_URL(self):\n        return self.authenticator.authorize_url\n\n    @property\n    def _OAUTH_ACCESS_TOKEN_URL(self):\n        return self.authenticator.token_url\n\n    @property\n    def _OAUTH_USERINFO_URL(self):\n        return self.authenticator.userdata_url\n\n    def set_state_cookie(self, state):\n        self._set_cookie(STATE_COOKIE_NAME, state, expires_days=1, httponly=True)\n\n    _state = None\n\n    def get_state(self):\n        next_url = original_next_url = self.get_argument('next', None)\n        if next_url:\n            # avoid browsers treating \\ as /\n            next_url = next_url.replace('\\\\', quote('\\\\'))\n            # disallow hostname-having urls,\n            # force absolute path redirect\n            urlinfo = urlparse(next_url)\n            next_url = urlinfo._replace(\n                scheme='', netloc='', path='/' + urlinfo.path.lstrip('/')\n            ).geturl()\n            if next_url != original_next_url:\n                self.log.warning(\n                    \"Ignoring next_url %r, using %r\", original_next_url, next_url\n                )\n        if self._state is None:\n            self._state = _serialize_state(\n                {'state_id': uuid.uuid4().hex, 'next_url': next_url}\n            )\n        return self._state\n\n    def get(self):\n        redirect_uri = self.authenticator.get_callback_url(self)\n        extra_params = self.authenticator.extra_authorize_params.copy()\n        self.log.info('OAuth redirect: %r', redirect_uri)\n        state = self.get_state()\n        self.set_state_cookie(state)\n        extra_params['state'] = state\n        self.authorize_redirect(\n            redirect_uri=redirect_uri,\n            client_id=self.authenticator.client_id,\n            scope=self.authenticator.scope,\n            extra_params=extra_params,\n            response_type='code',\n        )\n\n\nclass OAuthCallbackHandler(BaseHandler):\n    \"\"\"Basic handler for OAuth callback. Calls authenticator to verify username.\"\"\"\n\n    _state_cookie = None\n\n    def get_state_cookie(self):\n        \"\"\"Get OAuth state from cookies\n\n        To be compared with the value in redirect URL\n        \"\"\"\n        if self._state_cookie is None:\n            self._state_cookie = (\n                self.get_secure_cookie(STATE_COOKIE_NAME) or b''\n            ).decode('utf8', 'replace')\n            self.clear_cookie(STATE_COOKIE_NAME)\n        return self._state_cookie\n\n    def get_state_url(self):\n        \"\"\"Get OAuth state from URL parameters\n\n        to be compared with the value in cookies\n        \"\"\"\n        return self.get_argument(\"state\")\n\n    def check_state(self):\n        \"\"\"Verify OAuth state\n\n        compare value in cookie with redirect url param\n        \"\"\"\n        cookie_state = self.get_state_cookie()\n        url_state = self.get_state_url()\n        if not cookie_state:\n            raise web.HTTPError(400, \"OAuth state missing from cookies\")\n        if not url_state:\n            raise web.HTTPError(400, \"OAuth state missing from URL\")\n        if cookie_state != url_state:\n            self.log.warning(\"OAuth state mismatch: %s != %s\", cookie_state, url_state)\n            raise web.HTTPError(400, \"OAuth state mismatch\")\n\n    def check_error(self):\n        \"\"\"Check the OAuth code\"\"\"\n        error = self.get_argument(\"error\", False)\n        if error:\n            message = self.get_argument(\"error_description\", error)\n            raise web.HTTPError(400, \"OAuth error: %s\" % message)\n\n    def check_code(self):\n        \"\"\"Check the OAuth code\"\"\"\n        if not self.get_argument(\"code\", False):\n            raise web.HTTPError(400, \"OAuth callback made without a code\")\n\n    def check_arguments(self):\n        \"\"\"Validate the arguments of the redirect\n\n        Default:\n\n        - check for oauth-standard error, error_description arguments\n        - check that there's a code\n        - check that state matches\n        \"\"\"\n        self.check_error()\n        self.check_code()\n        self.check_state()\n\n    def append_query_parameters(self, url, exclude=None):\n        \"\"\"JupyterHub 1.2 appends query parameters by default in get_next_url\n\n        This is not appropriate for oauth callback handlers, where params are oauth state, code, etc.\n\n        Override the method used to append parameters to next_url to not preserve any parameters\n        \"\"\"\n        return url\n\n    def get_next_url(self, user=None):\n        \"\"\"Get the redirect target from the state field\"\"\"\n        state = self.get_state_url()\n        if state:\n            next_url = _deserialize_state(state).get('next_url')\n            if next_url:\n                return next_url\n        # JupyterHub 0.8 adds default .get_next_url for a fallback\n        if hasattr(BaseHandler, 'get_next_url'):\n            return super().get_next_url(user)\n        return url_path_join(self.hub.server.base_url, 'home')\n\n    async def _login_user_pre_08(self):\n        \"\"\"login_user simplifies the login+cookie+auth_state process in JupyterHub 0.8\n\n        _login_user_07 is for backward-compatibility with JupyterHub 0.7\n        \"\"\"\n        user_info = await self.authenticator.get_authenticated_user(self, None)\n        if user_info is None:\n            return\n        if isinstance(user_info, dict):\n            username = user_info['name']\n        else:\n            username = user_info\n        user = self.user_from_username(username)\n        self.set_login_cookie(user)\n        return user\n\n    if not hasattr(BaseHandler, 'login_user'):\n        # JupyterHub 0.7 doesn't have .login_user\n        login_user = _login_user_pre_08\n\n    async def get(self):\n        self.check_arguments()\n        user = await self.login_user()\n        if user is None:\n            # todo: custom error page?\n            raise web.HTTPError(403)\n        self.redirect(self.get_next_url(user))\n\n\nclass OAuthenticator(Authenticator):\n    \"\"\"Base class for OAuthenticators\n\n    Subclasses must override:\n\n    login_service (string identifying the service provider)\n    authenticate (method takes one arg - the request handler handling the oauth callback)\n    \"\"\"\n\n    login_handler = OAuthLoginHandler\n    callback_handler = OAuthCallbackHandler\n\n    authorize_url = Unicode(\n        config=True, help=\"\"\"The authenticate url for initiating oauth\"\"\"\n    )\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return os.environ.get(\"OAUTH2_AUTHORIZE_URL\", \"\")\n\n    token_url = Unicode(\n        config=True,\n        help=\"\"\"The url retrieving an access token at the completion of oauth\"\"\",\n    )\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return os.environ.get(\"OAUTH2_TOKEN_URL\", \"\")\n\n    userdata_url = Unicode(\n        config=True,\n        help=\"\"\"The url for retrieving user data with a completed access token\"\"\",\n    )\n    @default(\"userdata_url\")\n    def _userdata_url_default(self):\n        return os.environ.get(\"OAUTH2_USERDATA_URL\", \"\")\n\n    scope = List(\n        Unicode(),\n        config=True,\n        help=\"\"\"The OAuth scopes to request.\n        See the OAuth documentation of your OAuth provider for options.\n        For GitHub in particular, you can see github_scopes.md in this repo.\n        \"\"\",\n    )\n\n    extra_authorize_params = Dict(\n        config=True,\n        help=\"\"\"Extra GET params to send along with the initial OAuth request\n        to the OAuth provider.\"\"\",\n    )\n\n    login_service = 'override in subclass'\n    oauth_callback_url = Unicode(\n        os.getenv('OAUTH_CALLBACK_URL', ''),\n        config=True,\n        help=\"\"\"Callback URL to use.\n        Typically `https://{host}/hub/oauth_callback`\"\"\",\n    )\n\n    client_id_env = ''\n    client_id = Unicode(config=True)\n\n    def _client_id_default(self):\n        if self.client_id_env:\n            client_id = os.getenv(self.client_id_env, '')\n            if client_id:\n                return client_id\n        return os.getenv('OAUTH_CLIENT_ID', '')\n\n    client_secret_env = ''\n    client_secret = Unicode(config=True)\n\n    def _client_secret_default(self):\n        if self.client_secret_env:\n            client_secret = os.getenv(self.client_secret_env, '')\n            if client_secret:\n                return client_secret\n        return os.getenv('OAUTH_CLIENT_SECRET', '')\n\n    validate_server_cert_env = 'OAUTH_TLS_VERIFY'\n    validate_server_cert = Bool(config=True)\n\n    def _validate_server_cert_default(self):\n        env_value = os.getenv(self.validate_server_cert_env, '')\n        if env_value == '0':\n            return False\n        else:\n            return True\n\n    def login_url(self, base_url):\n        return url_path_join(base_url, 'oauth_login')\n\n\n    def get_callback_url(self, handler=None):\n        \"\"\"Get my OAuth redirect URL\n        \n        Either from config or guess based on the current request.\n        \"\"\"\n        if self.oauth_callback_url:\n            return self.oauth_callback_url\n        elif handler:\n            return guess_callback_uri(\n                handler.request.protocol,\n                handler.request.host,\n                handler.hub.server.base_url,\n            )\n        else:\n            raise ValueError(\n                \"Specify callback oauth_callback_url or give me a handler to guess with\"\n            )\n\n    def get_handlers(self, app):\n        return [\n            (r'/oauth_login', self.login_handler),\n            (r'/oauth_callback', self.callback_handler),\n        ]\n\n    async def authenticate(self, handler, data=None):\n        raise NotImplementedError()\n\n\n    def _deprecated_trait(self, change):\n        \"\"\"observer for deprecated traits\"\"\"\n        old_attr = change.name\n        new_attr, version = self._deprecated_aliases.get(old_attr)\n        new_value = getattr(self, new_attr)\n        if new_value != change.new:\n            # only warn if different\n            # protects backward-compatible config from warnings\n            # if they set the same value under both names\n            self.log.warning(\n                \"{cls}.{old} is deprecated in {cls} {version}, use {cls}.{new} instead\".format(\n                    cls=self.__class__.__name__,\n                    old=old_attr,\n                    new=new_attr,\n                    version=version,\n                )\n            )\n            setattr(self, new_attr, change.new)\n", "import os\nfrom unittest.mock import patch\n\nimport logging\nfrom pytest import fixture, mark\nfrom traitlets.config import Config\n\nfrom ..bitbucket import BitbucketOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(username):\n    \"\"\"Return a user model\"\"\"\n    return {\n        'username': username,\n    }\n\n@fixture\ndef bitbucket_client(client):\n    setup_oauth_mock(client,\n        host=['bitbucket.org', 'api.bitbucket.org'],\n        access_token_path='/site/oauth2/access_token',\n        user_path='/2.0/user',\n    )\n    return client\n\n\nasync def test_bitbucket(bitbucket_client):\n    authenticator = BitbucketOAuthenticator()\n    handler = bitbucket_client.handler_for_user(user_model('yorba'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'yorba'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'bitbucket_user' in auth_state\n\n\nasync def test_allowed_teams(bitbucket_client):\n    client = bitbucket_client\n    authenticator = BitbucketOAuthenticator()\n    authenticator.allowed_teams = ['blue']\n\n    teams = {\n        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],\n        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],\n    }\n    def list_teams(request):\n        token = request.headers['Authorization'].split(None, 1)[1]\n        username = client.access_tokens[token]['username']\n        values = []\n        for team, members in teams.items():\n            if username in members:\n                values.append({'username': team})\n        return {\n            'values': values\n        }\n\n    client.hosts['api.bitbucket.org'].append(\n        ('/2.0/teams', list_teams)\n    )\n\n    handler = client.handler_for_user(user_model('caboose'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'caboose'\n\n    handler = client.handler_for_user(user_model('donut'))\n    name = await authenticator.authenticate(handler)\n    assert name is None\n\n    # reverse it, just to be safe\n    authenticator.allowed_teams = ['red']\n\n    handler = client.handler_for_user(user_model('caboose'))\n    name = await authenticator.authenticate(handler)\n    assert name is None\n\n    handler = client.handler_for_user(user_model('donut'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'donut'\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.BitbucketOAuthenticator.team_whitelist = ['red']\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = BitbucketOAuthenticator(config=cfg, log=log)\n    assert caplog.record_tuples == [\n        (\n            log.name,\n            logging.WARNING,\n            'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '\n            'BitbucketOAuthenticator.allowed_teams instead',\n        )\n    ]\n\n    assert authenticator.allowed_teams == {\"red\"}\n", "import re\nimport functools\nimport json\nfrom io import BytesIO\n\nimport logging\nfrom pytest import fixture, mark\nfrom urllib.parse import urlparse, parse_qs\nfrom tornado.httpclient import HTTPRequest, HTTPResponse\nfrom tornado.httputil import HTTPHeaders\nfrom traitlets.config import Config\n\nfrom ..github import GitHubOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(username):\n    \"\"\"Return a user model\"\"\"\n    return {\n        'email': 'dinosaurs@space',\n        'id': 5,\n        'login': username,\n        'name': 'Hoban Washburn',\n    }\n\n@fixture\ndef github_client(client):\n    setup_oauth_mock(client,\n        host=['github.com', 'api.github.com'],\n        access_token_path='/login/oauth/access_token',\n        user_path='/user',\n        token_type='token',\n    )\n    return client\n\n\nasync def test_github(github_client):\n    authenticator = GitHubOAuthenticator()\n    handler = github_client.handler_for_user(user_model('wash'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'wash'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n\n    assert auth_state == {\n        'access_token': auth_state['access_token'],\n        'github_user': {\n            'email': 'dinosaurs@space',\n            'id': 5,\n            'login': name,\n            'name': 'Hoban Washburn',\n        }\n    }\n\n\ndef make_link_header(urlinfo, page):\n    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'\n                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}\n\n\nasync def test_allowed_org_membership(github_client):\n    client = github_client\n    authenticator = GitHubOAuthenticator()\n\n    ## Mock Github API\n\n    teams = {\n        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],\n        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],\n    }\n\n    member_regex = re.compile(r'/orgs/(.*)/members')\n\n    def team_members(paginate, request):\n        urlinfo = urlparse(request.url)\n        team = member_regex.match(urlinfo.path).group(1)\n\n        if team not in teams:\n            return HTTPResponse(request, 404)\n\n        if not paginate:\n            return [user_model(m) for m in teams[team]]\n        else:\n            page = parse_qs(urlinfo.query).get('page', ['1'])\n            page = int(page[0])\n            return team_members_paginated(\n                team, page, urlinfo, functools.partial(HTTPResponse, request))\n\n    def team_members_paginated(team, page, urlinfo, response):\n        if page < len(teams[team]):\n            headers = make_link_header(urlinfo, page + 1)\n        elif page == len(teams[team]):\n            headers = {}\n        else:\n            return response(400)\n\n        headers.update({'Content-Type': 'application/json'})\n\n        ret = [user_model(teams[team][page - 1])]\n\n        return response(200,\n                        headers=HTTPHeaders(headers),\n                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n\n\n    membership_regex = re.compile(r'/orgs/(.*)/members/(.*)')\n\n    def team_membership(request):\n        urlinfo = urlparse(request.url)\n        urlmatch = membership_regex.match(urlinfo.path)\n        team = urlmatch.group(1)\n        username = urlmatch.group(2)\n        print('Request team = %s, username = %s' % (team, username))\n        if team not in teams:\n            print('Team not found: team = %s' %(team))\n            return HTTPResponse(request, 404)\n        if username not in teams[team]:\n            print('Member not found: team = %s, username = %s' %(team, username))\n            return HTTPResponse(request, 404)\n        return HTTPResponse(request, 204)\n\n\n    ## Perform tests\n\n    for paginate in (False, True):\n        client_hosts = client.hosts['api.github.com']\n        client_hosts.append((membership_regex, team_membership))\n        client_hosts.append((member_regex, functools.partial(team_members, paginate)))\n\n        authenticator.allowed_organizations = ['blue']\n\n        handler = client.handler_for_user(user_model('caboose'))\n        user = await authenticator.authenticate(handler)\n        assert user['name'] == 'caboose'\n\n        handler = client.handler_for_user(user_model('donut'))\n        user = await authenticator.authenticate(handler)\n        assert user is None\n\n        # reverse it, just to be safe\n        authenticator.allowed_organizations = ['red']\n\n        handler = client.handler_for_user(user_model('caboose'))\n        user = await authenticator.authenticate(handler)\n        assert user is None\n\n        handler = client.handler_for_user(user_model('donut'))\n        user = await authenticator.authenticate(handler)\n        assert user['name'] == 'donut'\n\n        client_hosts.pop()\n        client_hosts.pop()\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GitHubOAuthenticator.github_organization_whitelist = [\"jupy\"]\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GitHubOAuthenticator(config=cfg, log=log)\n    assert caplog.record_tuples == [\n        (\n            log.name,\n            logging.WARNING,\n            'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '\n            'GitHubOAuthenticator.allowed_organizations instead',\n        )\n    ]\n\n    assert authenticator.allowed_organizations == {\"jupy\"}\n", "import re\nimport json\nfrom io import BytesIO\nimport functools\nimport collections\nfrom urllib.parse import urlparse, parse_qs\n\nimport logging\nfrom tornado.httpclient import HTTPResponse\nfrom tornado.httputil import HTTPHeaders\nfrom traitlets.config import Config\nfrom pytest import fixture, mark\n\nfrom ..gitlab import GitLabOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\nAPI_ENDPOINT = '/api/v%s' % (GitLabOAuthenticator().gitlab_api_version)\n\n\ndef user_model(username, id=1, is_admin=False):\n    \"\"\"Return a user model\"\"\"\n    user = {\n        'username': username,\n        'id': id,\n    }\n    if is_admin:\n      # Some versions of the API do not return the is_admin property\n        # for non-admin users (See #115).\n        user['is_admin'] = True\n    return user\n\n@fixture\ndef gitlab_client(client):\n    setup_oauth_mock(client,\n        host='gitlab.com',\n        access_token_path='/oauth/token',\n        user_path=API_ENDPOINT + '/user',\n    )\n    return client\n\ndef mock_api_version(client, version):\n    def mock_version_response(request):\n        ret = { 'version': version, 'revision': \"f79c1794977\" }\n        return HTTPResponse(request, 200,\n                            headers={'Content-Type': 'application/json'},\n                            buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n    regex = re.compile(API_ENDPOINT + '/version')\n    client.hosts['gitlab.com'].append((regex, mock_version_response))\n\nasync def test_gitlab(gitlab_client):\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(gitlab_client, '12.3.1-ee')\n    handler = gitlab_client.handler_for_user(user_model('wash'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'wash'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'gitlab_user' in auth_state\n\n\ndef make_link_header(urlinfo, page):\n    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'\n                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}\n\n\nasync def test_allowed_groups(gitlab_client):\n    client = gitlab_client\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(client, '12.4.0-ee')\n\n    ## set up fake Gitlab API\n\n    user_groups = collections.OrderedDict({\n        'grif': ['red', 'yellow'],\n        'simmons': ['red', 'yellow'],\n        'caboose': ['blue', 'yellow'],\n        'burns': ['blue', 'yellow'],\n    })\n\n    def group_user_model(username, is_admin=False):\n        return user_model(username,\n                          list(user_groups.keys()).index(username) + 1,\n                          is_admin)\n\n\n    member_regex = re.compile(API_ENDPOINT + r'/groups/(.*)/members/all/(.*)')\n    def is_member(request):\n        urlinfo = urlparse(request.url)\n        group, uid = member_regex.match(urlinfo.path).group(1, 2)\n        uname = list(user_groups.keys())[int(uid) - 1]\n        if group in user_groups[uname]:\n            return HTTPResponse(request, 200)\n        else:\n            return HTTPResponse(request, 404)\n\n    def groups(paginate, request):\n        urlinfo = urlparse(request.url)\n        _, token = request._headers.get('Authorization').split()\n        user = client.access_tokens[token]['username']\n        if not paginate:\n            return [{'path': group} for group in user_groups[user]]\n        else:\n            page = parse_qs(urlinfo.query).get('page', ['1'])\n            page = int(page[0])\n            return groups_paginated(user, page, urlinfo,\n                                    functools.partial(HTTPResponse, request))\n\n    def groups_paginated(user, page, urlinfo, response):\n        if page < len(user_groups[user]):\n            headers = make_link_header(urlinfo, page + 1)\n        elif page == len(user_groups[user]):\n            headers = {}\n        else:\n            return response(400)\n\n        headers.update({'Content-Type': 'application/json'})\n\n        ret = [{'path': user_groups[user][page - 1]}]\n\n        return response(200, headers=HTTPHeaders(headers),\n                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n\n    client.hosts['gitlab.com'].append(\n        (member_regex, is_member)\n    )\n\n    ## actual tests\n\n    for paginate in (False, True):\n        client.hosts['gitlab.com'].append(\n            (API_ENDPOINT + '/groups', functools.partial(groups, paginate))\n        )\n\n        authenticator.allowed_gitlab_groups = ['blue']\n\n        handler = client.handler_for_user(group_user_model('caboose'))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'caboose'\n\n        handler = client.handler_for_user(group_user_model('burns', is_admin=True))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'burns'\n\n        handler = client.handler_for_user(group_user_model('grif'))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        handler = client.handler_for_user(group_user_model('simmons', is_admin=True))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        # reverse it, just to be safe\n        authenticator.allowed_gitlab_groups = ['red']\n\n        handler = client.handler_for_user(group_user_model('caboose'))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        handler = client.handler_for_user(group_user_model('grif'))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'grif'\n\n        client.hosts['gitlab.com'].pop()\n\n\nasync def test_allowed_project_ids(gitlab_client):\n    client = gitlab_client\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(client, '12.4.0-pre')\n\n    user_projects = {\n        '1231231': {\n            '3588673': {\n                'id': 3588674,\n                'name': 'john',\n                'username': 'john',\n                'state': 'active',\n                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',\n                'web_url': 'https://gitlab.com/john',\n                'access_level': 10,  # Guest\n                'expires_at': '2030-02-23'\n            },\n            '3588674': {\n                'id': 3588674,\n                'name': 'harry',\n                'username': 'harry',\n                'state': 'active',\n                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',\n                'web_url': 'https://gitlab.com/harry',\n                'access_level': 30,  # Developer\n                'expires_at': '2030-02-23'\n            }\n        }\n    }\n    john_user_model = user_model('john', 3588673)\n    harry_user_model = user_model('harry', 3588674)\n    sheila_user_model = user_model('sheila', 3588675)\n\n    member_regex = re.compile(API_ENDPOINT + r'/projects/(.*)/members/all/(.*)')\n\n    def is_member(request):\n        urlinfo = urlparse(request.url)\n        project_id, uid = member_regex.match(urlinfo.path).group(1, 2)\n\n        if user_projects.get(project_id) and user_projects.get(project_id).get(uid):\n            res = user_projects.get(project_id).get(uid)\n            return HTTPResponse(request=request, code=200,\n                buffer=BytesIO(json.dumps(res).encode('utf8')),\n                headers={'Content-Type': 'application/json'},\n            )\n        else:\n            return HTTPResponse(request=request, code=404,\n                buffer=BytesIO(''.encode('utf8'))\n            )\n\n    client.hosts['gitlab.com'].append(\n        (member_regex, is_member)\n    )\n\n    authenticator.allowed_project_ids = [1231231]\n\n    # Forbidden since John has guest access\n    handler = client.handler_for_user(john_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    # Authenticated since Harry has developer access to the project\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'harry'\n\n    # Forbidden since Sheila doesn't have access to the project\n    handler = client.handler_for_user(sheila_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    authenticator.allowed_project_ids = [123123152543]\n\n    # Forbidden since the project does not exist.\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    authenticator.allowed_project_ids = [123123152543, 1231231]\n\n    # Authenticated since Harry has developer access to one of the project in the list\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'harry'\n\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GitLabOAuthenticator.gitlab_group_whitelist = {'red'}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GitLabOAuthenticator(config=cfg, log=log)\n    assert caplog.record_tuples == [\n        (\n            log.name,\n            logging.WARNING,\n            'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '\n            'GitLabOAuthenticator.allowed_gitlab_groups instead'\n        )\n    ]\n\n    assert authenticator.allowed_gitlab_groups == {'red'}\n", "import re\nfrom unittest.mock import Mock\n\nimport logging\nfrom pytest import fixture, mark, raises\nfrom tornado.web import Application, HTTPError\nfrom traitlets.config import Config\n\n\nfrom ..google import GoogleOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(email):\n    \"\"\"Return a user model\"\"\"\n    return {'email': email, 'hd': email.split('@')[1], 'verified_email': True}\n\n\n@fixture\ndef google_client(client):\n    setup_oauth_mock(\n        client,\n        host=['accounts.google.com', 'www.googleapis.com'],\n        access_token_path=re.compile('^(/o/oauth2/token|/oauth2/v4/token)$'),\n        user_path='/oauth2/v1/userinfo',\n    )\n    return client\n\n\nasync def test_google(google_client):\n    authenticator = GoogleOAuthenticator()\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'fake@email.com'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'google_user' in auth_state\n\n\nasync def test_hosted_domain(google_client):\n    authenticator = GoogleOAuthenticator(hosted_domain=['email.com'])\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake'\n\n    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))\n    with raises(HTTPError) as exc:\n        name = await authenticator.authenticate(handler)\n    assert exc.value.status_code == 403\n\n\nasync def test_multiple_hosted_domain(google_client):\n    authenticator = GoogleOAuthenticator(hosted_domain=['email.com', 'mycollege.edu'])\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake@email.com'\n\n    handler = google_client.handler_for_user(user_model('fake2@mycollege.edu'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake2@mycollege.edu'\n\n    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))\n    with raises(HTTPError) as exc:\n        name = await authenticator.authenticate(handler)\n    assert exc.value.status_code == 403\n\n\nasync def test_admin_google_groups(google_client):\n    authenticator = GoogleOAuthenticator(\n        hosted_domain=['email.com', 'mycollege.edu'],\n        admin_google_groups={'email.com': ['fakeadmingroup']},\n        allowed_google_groups={'email.com': ['fakegroup']}\n    )\n    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))\n    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])\n    admin_user = admin_user_info['admin']\n    assert admin_user == True\n    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))\n    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])\n    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']\n    admin_user = allowed_user_info['admin']\n    assert 'fakegroup' in allowed_user_groups\n    assert admin_user == False\n    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))\n    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])\n    assert allowed_user_groups is None\n\n\nasync def test_allowed_google_groups(google_client):\n    authenticator = GoogleOAuthenticator(\n        hosted_domain=['email.com', 'mycollege.edu'],\n        allowed_google_groups={'email.com': ['fakegroup']}\n    )\n    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))\n    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])\n    assert admin_user_info is None\n    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))\n    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])\n    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']\n    admin_field = allowed_user_info.get('admin')\n    assert 'fakegroup' in allowed_user_groups\n    assert admin_field is None\n    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))\n    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])\n    assert allowed_user_groups is None\n\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GoogleOAuthenticator.google_group_whitelist = {'email.com': ['group']}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GoogleOAuthenticator(config=cfg, log=log)\n    assert caplog.record_tuples == [\n        (\n            log.name,\n            logging.WARNING,\n            'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '\n            'GoogleOAuthenticator.allowed_google_groups instead',\n        )\n    ]\n\n    assert authenticator.allowed_google_groups == {'email.com': ['group']}\n"], "fixing_code": ["# Changes in oauthenticator\n\n\nFor detailed changes from the prior release, click on the version number, and\nits link will bring up a GitHub listing of changes. Use `git log` on the\ncommand line for details.\n\n\n## [Unreleased]\n\n## 0.12\n\n### [0.12.2] - 2020-11-30\n\nSecurity fix for GHSA-384w-5v3f-q499: Deprecated `c.Authenticator.whitelist` configuration was ignored instead of mapped to newer `c.Authenticator.allowed_users` when used with JupyterHub 1.2 and OAuthenticator 0.12.0-0.12.1.\n\n### [0.12.1] - 2020-11-20\n\n#### Bugs fixed\n\n* Avoid appending code, state parameters to `next_url` [#386](https://github.com/jupyterhub/oauthenticator/pull/386) ([@minrk](https://github.com/minrk))\n\n#### Maintenance and upkeep improvements\n\n* Remove support for python 3.5 [#384](https://github.com/jupyterhub/oauthenticator/pull/384) ([@consideRatio](https://github.com/consideRatio))\n* migrate from travis to github actions [#383](https://github.com/jupyterhub/oauthenticator/pull/383) ([@minrk](https://github.com/minrk))\n* CI: Stop testing py35 and don't test on tagged commits [#379](https://github.com/jupyterhub/oauthenticator/pull/379) ([@consideRatio](https://github.com/consideRatio))\n\n#### Contributors to this release\n\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2020-10-26&to=2020-11-18&type=c))\n\n[@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2020-10-26..2020-11-18&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2020-10-26..2020-11-18&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2020-10-26..2020-11-18&type=Issues)\n\n### [0.12.0] - 2020-10-26\n\n#### Enhancements made\n* [OpenShift] Enable cert verification for self-signed certs and auto-load auth api URL [#363](https://github.com/jupyterhub/oauthenticator/pull/363) ([@vpavlin](https://github.com/vpavlin))\n* [Globus] Support custom username handling [#357](https://github.com/jupyterhub/oauthenticator/pull/357) ([@NickolausDS](https://github.com/NickolausDS))\n* [Google] Adding refresh_token [#350](https://github.com/jupyterhub/oauthenticator/pull/350) ([@missingcharacter](https://github.com/missingcharacter))\n* [Google] Added optional support for google groups [#341](https://github.com/jupyterhub/oauthenticator/pull/341) ([@missingcharacter](https://github.com/missingcharacter))\n* [All] Added extra_authorize_params to pass extra params in the initial request to the identity provider [#338](https://github.com/jupyterhub/oauthenticator/pull/338) ([@NickolausDS](https://github.com/NickolausDS))\n* [GitLab] Improve subgroup support [#333](https://github.com/jupyterhub/oauthenticator/pull/333) ([@akhmerov](https://github.com/akhmerov))\n\n#### Bugs fixed\n* [All] Let auth cookie be influenced by JupyterHub's cookie_options configuration [#378](https://github.com/jupyterhub/oauthenticator/pull/378) ([@Wh1isper](https://github.com/Wh1isper))\n* [GitHub] Respect validate_server_cert attribute [#354](https://github.com/jupyterhub/oauthenticator/pull/354) ([@nvs-abhilash](https://github.com/nvs-abhilash))\n* [Generic] tls verify not being honored at the httprequest level when internal_ssl is enabled [#326](https://github.com/jupyterhub/oauthenticator/pull/326) ([@sstarcher](https://github.com/sstarcher))\n\n#### Maintenance and upkeep improvements\n* Rename OAuthenticator.whitelist to allow [#366](https://github.com/jupyterhub/oauthenticator/pull/366) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* Python package extra dependencies updated [#343](https://github.com/jupyterhub/oauthenticator/pull/343) ([@missingcharacter](https://github.com/missingcharacter))\n* [Generic] Fix failing GenericOAuthenticator tests [#339](https://github.com/jupyterhub/oauthenticator/pull/339) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* [Globus] Remove the need for globus_sdk as a python dependency [#337](https://github.com/jupyterhub/oauthenticator/pull/337) ([@NickolausDS](https://github.com/NickolausDS))\n\n#### Documentation improvements\n* Add changelog for 0.12.0 release [#377](https://github.com/jupyterhub/oauthenticator/pull/377) ([@consideRatio](https://github.com/consideRatio))\n* [Globus] Docs: explain identity_provider better [#362](https://github.com/jupyterhub/oauthenticator/pull/362) ([@NickolausDS](https://github.com/NickolausDS))\n* [OpenShift] Docs: fix broken link for OpenShift OAuth service accounts [#352](https://github.com/jupyterhub/oauthenticator/pull/352) ([@nscozzaro](https://github.com/nscozzaro))\n* Docs: Updating sphinx and pandas_sphinx_theme references [#345](https://github.com/jupyterhub/oauthenticator/pull/345) ([@missingcharacter](https://github.com/missingcharacter))\n* [Google] Added optional support for google groups [#341](https://github.com/jupyterhub/oauthenticator/pull/341) ([@missingcharacter](https://github.com/missingcharacter))\n* [Globus] Remove the need for globus_sdk as a python dependency [#337](https://github.com/jupyterhub/oauthenticator/pull/337) ([@NickolausDS](https://github.com/NickolausDS))\n* Update docs [#336](https://github.com/jupyterhub/oauthenticator/pull/336) ([@GeorgianaElena](https://github.com/GeorgianaElena))\n* [Generic] Usage example for Nextcloud [#268](https://github.com/jupyterhub/oauthenticator/pull/268) ([@arneki](https://github.com/arneki))\n\n#### Contributors to this release\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2020-01-31&to=2020-10-26&type=c))\n\n[@ablekh](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aablekh+updated%3A2020-01-31..2020-10-26&type=Issues) | [@akhmerov](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aakhmerov+updated%3A2020-01-31..2020-10-26&type=Issues) | [@Analect](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AAnalect+updated%3A2020-01-31..2020-10-26&type=Issues) | [@arneki](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aarneki+updated%3A2020-01-31..2020-10-26&type=Issues) | [@bellackn](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Abellackn+updated%3A2020-01-31..2020-10-26&type=Issues) | [@betatim](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Abetatim+updated%3A2020-01-31..2020-10-26&type=Issues) | [@CJCShadowsan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ACJCShadowsan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@cmseal](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Acmseal+updated%3A2020-01-31..2020-10-26&type=Issues) | [@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2020-01-31..2020-10-26&type=Issues) | [@d0m84](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ad0m84+updated%3A2020-01-31..2020-10-26&type=Issues) | [@daniel-ciocirlan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Adaniel-ciocirlan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@dmpe](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Admpe+updated%3A2020-01-31..2020-10-26&type=Issues) | [@dmvieira](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Admvieira+updated%3A2020-01-31..2020-10-26&type=Issues) | [@GeorgianaElena](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AGeorgianaElena+updated%3A2020-01-31..2020-10-26&type=Issues) | [@ghezalsherdil](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aghezalsherdil+updated%3A2020-01-31..2020-10-26&type=Issues) | [@guimou](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aguimou+updated%3A2020-01-31..2020-10-26&type=Issues) | [@gweis](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Agweis+updated%3A2020-01-31..2020-10-26&type=Issues) | [@hardik42](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ahardik42+updated%3A2020-01-31..2020-10-26&type=Issues) | [@hbuttguavus](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ahbuttguavus+updated%3A2020-01-31..2020-10-26&type=Issues) | [@jamescross91](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ajamescross91+updated%3A2020-01-31..2020-10-26&type=Issues) | [@linkcd](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Alinkcd+updated%3A2020-01-31..2020-10-26&type=Issues) | [@louis-she](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Alouis-she+updated%3A2020-01-31..2020-10-26&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2020-01-31..2020-10-26&type=Issues) | [@meeseeksmachine](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ameeseeksmachine+updated%3A2020-01-31..2020-10-26&type=Issues) | [@michec81](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amichec81+updated%3A2020-01-31..2020-10-26&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2020-01-31..2020-10-26&type=Issues) | [@missingcharacter](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amissingcharacter+updated%3A2020-01-31..2020-10-26&type=Issues) | [@mransley](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amransley+updated%3A2020-01-31..2020-10-26&type=Issues) | [@NickolausDS](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ANickolausDS+updated%3A2020-01-31..2020-10-26&type=Issues) | [@nscozzaro](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Anscozzaro+updated%3A2020-01-31..2020-10-26&type=Issues) | [@nvs-abhilash](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Anvs-abhilash+updated%3A2020-01-31..2020-10-26&type=Issues) | [@patback66](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Apatback66+updated%3A2020-01-31..2020-10-26&type=Issues) | [@PaulMazzuca](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3APaulMazzuca+updated%3A2020-01-31..2020-10-26&type=Issues) | [@RAbraham](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ARAbraham+updated%3A2020-01-31..2020-10-26&type=Issues) | [@sampathkethineedi](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asampathkethineedi+updated%3A2020-01-31..2020-10-26&type=Issues) | [@saurav-bhagat](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asaurav-bhagat+updated%3A2020-01-31..2020-10-26&type=Issues) | [@shivan10](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ashivan10+updated%3A2020-01-31..2020-10-26&type=Issues) | [@SolarisYan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ASolarisYan+updated%3A2020-01-31..2020-10-26&type=Issues) | [@sstarcher](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asstarcher+updated%3A2020-01-31..2020-10-26&type=Issues) | [@support](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Asupport+updated%3A2020-01-31..2020-10-26&type=Issues) | [@umar-sik](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aumar-sik+updated%3A2020-01-31..2020-10-26&type=Issues) | [@vpavlin](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Avpavlin+updated%3A2020-01-31..2020-10-26&type=Issues) | [@welcome](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Awelcome+updated%3A2020-01-31..2020-10-26&type=Issues) | [@Wh1isper](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AWh1isper+updated%3A2020-01-31..2020-10-26&type=Issues) | [@willingc](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Awillingc+updated%3A2020-01-31..2020-10-26&type=Issues) | [@yuvipanda](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Ayuvipanda+updated%3A2020-01-31..2020-10-26&type=Issues) | [@zhiyuli](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Azhiyuli+updated%3A2020-01-31..2020-10-26&type=Issues)\n\n## 0.11\n\n### [0.11.0] - 2020-01-30\n\nThe main change in 0.11 is a refactoring of classes to remove mixins,\nreducing the amount of boilerplate needed.\nIn addition, there are some fixes to the Azure AD Authenticator.\nThis should be a fully backward-compatible change,\nexcept in cases where some subclasses were importing these now-unneeded mixin classes,\nsuch as GitHubLoginHandler, GitHubMixin, etc.\n\nAll options should now be configurable via the standard jupyterhub config file.\nThere should no longer be any options that are *only* configurable via environment variable.\n\nThis release also *removes* the latest Authenticators added in 0.10\n(AzureAdB2COAuthenticator, AWSCognitoOAuthenticator, YandexOAuthenticator),\nwhich were released without being fully supported and\nwhich can be achieved through configuration of existing classes,\nsuch as `AzureAd` and `Generic`.\n\nWe don't plan to accept further contributions of new providers if they can be achieved through customization or configuration of existing classes.\nRather, contributors are encouraged to provide example documentation for using new providers,\nor pull requests addressing gaps necessary to do so with the GenericOAuthenticator.\n\n([full changelog](https://github.com/jupyterhub/oauthenticator/compare/0.10.0...ae199077a3a580cb849af17ceccfe8e498134ea3))\n\n\n#### Merged PRs\n\n* [AzureAD] Don't pass resource when requesting a token [#328](https://github.com/jupyterhub/oauthenticator/pull/328) ([@craigminihan](https://github.com/craigminihan))\n* Remove mixins, per-Authenticator LoginHandler classes [#323](https://github.com/jupyterhub/oauthenticator/pull/323) ([@minrk](https://github.com/minrk))\n* [AzureAD] Add support for setting login_service [#319](https://github.com/jupyterhub/oauthenticator/pull/319) ([@zevaryx](https://github.com/zevaryx))\n* skeleton of sphinx docs [#316](https://github.com/jupyterhub/oauthenticator/pull/316) ([@minrk](https://github.com/minrk))\n\n#### Contributors to this release\n\n([GitHub contributors page for this release](https://github.com/jupyterhub/oauthenticator/graphs/contributors?from=2019-11-27&to=2020-01-30&type=c))\n\n[@consideRatio](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3AconsideRatio+updated%3A2019-11-27..2020-01-30&type=Issues) | [@craigminihan](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Acraigminihan+updated%3A2019-11-27..2020-01-30&type=Issues) | [@Dmitry1987](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ADmitry1987+updated%3A2019-11-27..2020-01-30&type=Issues) | [@manics](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Amanics+updated%3A2019-11-27..2020-01-30&type=Issues) | [@minrk](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Aminrk+updated%3A2019-11-27..2020-01-30&type=Issues) | [@NickolausDS](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3ANickolausDS+updated%3A2019-11-27..2020-01-30&type=Issues) | [@zevaryx](https://github.com/search?q=repo%3Ajupyterhub%2Foauthenticator+involves%3Azevaryx+updated%3A2019-11-27..2020-01-30&type=Issues)\n\n\n## 0.10\n\n### [0.10.0] - 2019-11-27\n\n#### New\n\n* Add AzureAdB2COAuthenticator [#307](https://github.com/jupyterhub/oauthenticator/pull/307) ([@linkcd](https://github.com/linkcd))\n* Add support for `GenericOAuthenticator.username_key` to hold a callable value [#305](https://github.com/jupyterhub/oauthenticator/pull/305) ([@eslavich](https://github.com/eslavich))\n* Add `AzureAdOAuthenticator.username_claim` config field [#280](https://github.com/jupyterhub/oauthenticator/pull/280) ([@jeff-sternberg](https://github.com/jeff-sternberg))\n* Add `AWSCognitoAuthenticator` [#269](https://github.com/jupyterhub/oauthenticator/pull/269) ([@jmartinc89](https://github.com/jmartinc89))\n\n#### Fixed\n\n* mediawiki: utf-8 > binary strings, req. mwoauth>=0.3.7 [#297](https://github.com/jupyterhub/oauthenticator/pull/297) ([@consideRatio](https://github.com/consideRatio))\n* Fixed Globus Logout Handler, added test [#288](https://github.com/jupyterhub/oauthenticator/pull/288) ([@NickolausDS](https://github.com/NickolausDS))\n* Include inherited members in GitLab auth checks, requires GitLab 12.4 or newer, but will fall back to previous behavior for older GitLab versions. [#283](https://github.com/jupyterhub/oauthenticator/pull/283) ([@vindvaki](https://github.com/vindvaki))\n\n#### Maintenance\n\n* Fixed content index in readme, and fixed typo in comments [#310](https://github.com/jupyterhub/oauthenticator/pull/310) ([@linkcd](https://github.com/linkcd))\n* Add scopes documentation to auth0 example [#303](https://github.com/jupyterhub/oauthenticator/pull/303) ([@jbradenbrown](https://github.com/jbradenbrown))\n* Add py3.8 for CI testing [#302](https://github.com/jupyterhub/oauthenticator/pull/302) ([@consideRatio](https://github.com/consideRatio))\n* Travis: Deploy releases to pypi [#301](https://github.com/jupyterhub/oauthenticator/pull/301) ([@manics](https://github.com/manics))\n* Disable MediaWiki's mwoauth==0.3.5 due to a regression [#295](https://github.com/jupyterhub/oauthenticator/pull/295) ([@consideRatio](https://github.com/consideRatio))\n* Add RELEASE.md [#294](https://github.com/jupyterhub/oauthenticator/pull/294) ([@consideRatio](https://github.com/consideRatio))\n* Add PyPI/Travis build badges to README.md [#293](https://github.com/jupyterhub/oauthenticator/pull/293) ([@consideRatio](https://github.com/consideRatio))\n* Fix project name typo [#292](https://github.com/jupyterhub/oauthenticator/pull/292) ([@kinow](https://github.com/kinow))\n* Use traitlet.default for Azure AD tenant_id [#282](https://github.com/jupyterhub/oauthenticator/pull/282) ([@jeff-sternberg](https://github.com/jeff-sternberg))\n* Add clarifying comment into README code block [#279](https://github.com/jupyterhub/oauthenticator/pull/279) ([@raethlein](https://github.com/raethlein))\n\n\n## 0.9\n\n### [0.9.0] - 2019-07-30\n\n- switch to asyncio coroutines from tornado coroutines (requires Python 3.5)\n- add `GenericOAuthenticator.userdata_token_method` configurable\n- add `GenericOAuthenticator.basic_auth` configurable\n- support for OpenShift 4.0 API changes\n\n\n## 0.8\n\n### [0.8.2] - 2019-04-16\n\n- Validate login URL redirects to avoid Open Redirect issues.\n\n### [0.8.1] - 2019-02-28\n\n- Provide better error messages\n- Allow auth scope to be array or strings\n- `GitHubOAuthenticator`: More efficient `org_whitelist` check\n- Use pytest-asyncio instead of pytest-tornado\n- CILogon: New additional_username_claims config for linked identities, fallback to the primary username claim\n- `GitLabOAuthenticator`: New `project_id_whitelist` config to whitelist users who have Developer+ access to the project\n- `GoogleOAuthenticator`: Allow email domains (`hosted_domain`) to be a list\n- Add `jupyterhub-authenticator` entrypoints for jupyterhub 1.0.\n- Cleanup & bugfixes\n\n### [0.8.0] - 2018-08-10\n\n- Add `azuread.AzureADOAuthenticator`\n- Add `CILogonOAuthenticator.idp_whitelist` and `CILogonOAuthenticator.strip_idp_domain` options\n- Add `GenericOAuthenticator.tls_verify` and `GenericOAuthenticator.extra_params` options\n- Add refresh token and scope to generic oauthenticator auth state\n- Better error messages when GitHub oauth fails\n- Stop normalizing mediawiki usernames, which can be case-sensitive\n- Fixes for group-membership checks with GitLab\n- Bugfixes in various authenticators\n- Deprecate GITLAB_HOST in favor of GITLAB_URL, since we expect `https://` in the url, not just the host.\n\n\n## 0.7\n\n### [0.7.3] - 2018-02-16\n\n0.7.3 is a security fix for CVE-2018-7206.\nIt fixes handling of `gitlab_group_whitelist` when using GitLabOAuthenticator.\nThe same fix is backported to 0.6.2.\n\n### [0.7.2] - 2017-10-27\n\n- Fix CILogon OAuth 2 implementation. ePPN claim is used for default username\n  (typically institutional email).\n  `CILogonOAuthenticator.username_claim` can be used to change which field is\n  used for JupyterHub usernames.\n- `GenericOAuthenticator.login_service` is now configurable.\n- default to GitLab API version 4 and allow v3 via GITLAB_API_VERSION=3 environment variable.\n- Add `GlobusOAuthenticator.revoke_tokens_on_logout` and\n  `GlobusOAuthenticator.logout_redirect_url` config for further clearing\n  of credentials on JupyterHub logout.\n\n### [0.7.1] - 2017-10-04\n\n- fix regression in 0.7.0 preventing authentication via providers other than GitHub, MediaWiki\n\n### [0.7.0] - 2017-10-02\n\n0.7.0 adds significant new functionality to all authenticators.\n\n- CILogon now uses OAuth 2 instead of OAuth 1, to be more consistent with the rest.\n- All OAuthenticators support `auth_state` when used with JupyterHub 0.8.\n  In every case, the auth_state is a dict with two keys: `access_token` and the\n  user-info reply identifying the user.\n  For instance, GitHubOAuthenticator auth_state looks like:\n\n  ```python\n  {\n    'acces_token': 'abc123',\n    'github_user': {\n      'username': 'fake-user',\n      'email': 'fake@email.com',\n      ...\n    }\n  }\n  ```\n\n  auth_state can be passed to Spawners by defining a `.pre_spawn_start` method.\n  See examples/auth_state for an example.\n- All OAuthenticators have a `.scope` trait, which is a list of string scopes to request.\n  See your OAuth provider's documentation for what scopes you may want.\n  This is useful in conjunction with `auth_state`, which may be used to pass access tokens\n  to Spawners via environment variables. `.scope` can control what permissions those\n  tokens will have. In general, OAuthenticator default scopes should only have read-only access to identify users.\n- GITHUB_HTTP environment variable can be used to talk to HTTP-only GitHub Enterprise deployments.\n\n## 0.6\n\n### [0.6.2] - 2018-02-16\n\n0.6.2 is a security fix for CVE-2018-7206.\nIt fixes handling of `gitlab_group_whitelist` when using GitLabOAuthenticator.\n\n### [0.6.1] - 2017-08-11\n\n0.6.1 has bugfixes for new behaviors in 0.6.0\n\n- Use `.login_url` and `next_url` from JupyterHub if defined (JupyterHub 0.8)\n- Fix empty login_url where final login redirect could be omitted\n- Fix mediawiki authenticator, which broke in 0.6.0\n- Encode state as base64 instead of JSON, for easier passing in URLs\n\n### [0.6.0] - 2017-07-25\n\n- Support for changes in upcoming JupyterHub 0.8\n- Refactor to share more code across providers\n- Deprecated GITHUB_CLIENT_ID and other provider-specific environment variables\n  for common options.\n  All OAuthenticators support the same OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET, and OAUTH_CALLBACK_URL environment variables.\n- New authenticators:\n  - auth0\n  - globus\n  - okpy\n  - openshift\n  - generic - a generic implementation that can work with any OAuth2 provider\n\n\n## 0.5\n\n### [0.5.1] - 2016-10-05\n\n- Fixes in BitbucketOAuthenticator.check_whitelist\n\n### [0.5.0] - 2016-09-02\n\n- Add GitLabOAuthenticator\n\n## 0.4\n\n### [0.4.1] - 2016-05-18\n\n- Fix typo preventing Google OAuth from working in 0.4.0\n\n### [0.4.0] - 2016-05-11\n\n- Enable username normalization (for mixed-case names on GitHub, requires JupyterHub 0.5).\n  This removes `GitHubOAuthenticator.username_map` introduced in 0.3,\n  because the oauth2 Authenticator has `.username_map` as of 0.5.\n\n## [0.3] - 2016-04-20\n\n- Add Google authenticator\n- Allow specifying OAuth scope\n- Add `GitHubOAuthenticator.username_map` for mapping GitHub usernames to system usernames.\n\n## [0.2] - 2016-01-04\n\n- Add mediawiki authenticator\n\n## 0.1 - 2015-12-22\n\n- First release\n\n\n[Unreleased]: https://github.com/jupyterhub/oauthenticator/compare/0.9.0...HEAD\n[0.9.0]: https://github.com/jupyterhub/oauthenticator/compare/0.8.2...0.9.0\n[0.8.2]: https://github.com/jupyterhub/oauthenticator/compare/0.8.1...0.8.2\n[0.8.1]: https://github.com/jupyterhub/oauthenticator/compare/0.8.0...0.8.1\n[0.8.0]: https://github.com/jupyterhub/oauthenticator/compare/0.7.3...0.8.0\n[0.7.3]: https://github.com/jupyterhub/oauthenticator/compare/0.7.2...0.7.3\n[0.7.2]: https://github.com/jupyterhub/oauthenticator/compare/0.7.1...0.7.2\n[0.7.1]: https://github.com/jupyterhub/oauthenticator/compare/0.7.0...0.7.1\n[0.7.0]: https://github.com/jupyterhub/oauthenticator/compare/0.6.1...0.7.0\n[0.6.2]: https://github.com/jupyterhub/oauthenticator/compare/0.6.1...0.6.2\n[0.6.1]: https://github.com/jupyterhub/oauthenticator/compare/0.6.0...0.6.1\n[0.6.0]:https://github.com/jupyterhub/oauthenticator/compare/0.5.1...0.6.0\n[0.5.1]:https://github.com/jupyterhub/oauthenticator/compare/0.5.0...0.5.1\n[0.5.0]:https://github.com/jupyterhub/oauthenticator/compare/0.4.1...0.5.0\n[0.4.1]: https://github.com/jupyterhub/oauthenticator/compare/0.4.0...0.4.1\n[0.4.0]:https://github.com/jupyterhub/oauthenticator/compare/0.3.0...0.4.0\n[0.3]: https://github.com/jupyterhub/oauthenticator/compare/0.2.0...0.3.0\n[0.2]: https://github.com/jupyterhub/oauthenticator/compare/0.1.0...0.2.0\n", "\"\"\"\nCustom Authenticator to use Bitbucket OAuth with JupyterHub\n\"\"\"\n\nimport json\nimport urllib\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set, default, observe\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\".format(access_token),\n    }\n\n\nclass BitbucketOAuthenticator(OAuthenticator):\n\n    _deprecated_oauth_aliases = {\n        \"team_whitelist\": (\"allowed_teams\", \"0.12.0\"),\n        **OAuthenticator._deprecated_oauth_aliases,\n    }\n\n    login_service = \"Bitbucket\"\n    client_id_env = 'BITBUCKET_CLIENT_ID'\n    client_secret_env = 'BITBUCKET_CLIENT_SECRET'\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://bitbucket.org/site/oauth2/authorize\"\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"https://bitbucket.org/site/oauth2/access_token\"\n\n    team_whitelist = Set(help=\"Deprecated, use `BitbucketOAuthenticator.allowed_teams`\", config=True,)\n\n    allowed_teams = Set(\n        config=True, help=\"Automatically allow members of selected teams\"\n    )\n\n\n    headers = {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\",\n    }\n\n    async def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n        url = url_concat(\"https://bitbucket.org/site/oauth2/access_token\", params)\n\n        bb_header = {\"Content-Type\": \"application/x-www-form-urlencoded;charset=utf-8\"}\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            auth_username=self.client_id,\n            auth_password=self.client_secret,\n            body=urllib.parse.urlencode(params).encode('utf-8'),\n            headers=bb_header,\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            \"https://api.bitbucket.org/2.0/user\",\n            method=\"GET\",\n            headers=_api_headers(access_token),\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n\n        # Check if user is a member of any allowed teams.\n        # This check is performed here, as the check requires `access_token`.\n        if self.allowed_teams:\n            user_in_team = await self._check_membership_allowed_teams(username, access_token)\n            if not user_in_team:\n                self.log.warning(\"%s not in team allowed list of users\", username)\n                return None\n\n        return {\n            'name': username,\n            'auth_state': {'access_token': access_token, 'bitbucket_user': resp_json},\n        }\n\n    async def _check_membership_allowed_teams(self, username, access_token):\n        http_client = AsyncHTTPClient()\n\n        headers = _api_headers(access_token)\n        # We verify the team membership by calling teams endpoint.\n        next_page = url_concat(\n            \"https://api.bitbucket.org/2.0/teams\", {'role': 'member'}\n        )\n        while next_page:\n            req = HTTPRequest(next_page, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req)\n            resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n            next_page = resp_json.get('next', None)\n\n            user_teams = set([entry[\"username\"] for entry in resp_json[\"values\"]])\n            # check if any of the organizations seen thus far are in the allowed list\n            if len(self.allowed_teams & user_teams) > 0:\n                return True\n        return False\n\n\nclass LocalBitbucketOAuthenticator(LocalAuthenticator, BitbucketOAuthenticator):\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"CILogon OAuthAuthenticator for JupyterHub\n\nUses OAuth 2.0 with cilogon.org (override with CILOGON_HOST)\n\nCaveats:\n\n- For allowed user list /admin purposes, username will be the ePPN by default.\n  This is typically an email address and may not work as a Unix userid.\n  Normalization may be required to turn the JupyterHub username into a Unix username.\n- Default username_claim of ePPN does not work for all providers,\n  e.g. generic OAuth such as Google.\n  Use `c.CILogonOAuthenticator.username_claim = 'email'` to use\n  email instead of ePPN as the JupyterHub username.\n\"\"\"\n\nimport json\nimport os\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom traitlets import Unicode, List, Bool, default, validate, observe\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\nclass CILogonLoginHandler(OAuthLoginHandler):\n    \"\"\"See http://www.cilogon.org/oidc for general information.\"\"\"\n\n    def authorize_redirect(self, *args, **kwargs):\n        \"\"\"Add idp, skin to redirect params\"\"\"\n        extra_params = kwargs.setdefault('extra_params', {})\n        if self.authenticator.idp:\n            extra_params[\"selected_idp\"] = self.authenticator.idp\n        if self.authenticator.skin:\n            extra_params[\"skin\"] = self.authenticator.skin\n\n        return super().authorize_redirect(*args, **kwargs)\n\n\nclass CILogonOAuthenticator(OAuthenticator):\n    _deprecated_oauth_aliases = {\n        \"idp_whitelist\": (\"allowed_idps\", \"0.12.0\"),\n        **OAuthenticator._deprecated_oauth_aliases,\n    }\n\n    login_service = \"CILogon\"\n\n    client_id_env = 'CILOGON_CLIENT_ID'\n    client_secret_env = 'CILOGON_CLIENT_SECRET'\n    login_handler = CILogonLoginHandler\n\n    cilogon_host = Unicode(os.environ.get(\"CILOGON_HOST\") or \"cilogon.org\", config=True)\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://%s/authorize\" % self.cilogon_host\n\n    @default(\"token_url\")\n    def _token_url(self):\n        return \"https://%s/oauth2/token\" % self.cilogon_host\n\n    scope = List(\n        Unicode(),\n        default_value=['openid', 'email', 'org.cilogon.userinfo'],\n        config=True,\n        help=\"\"\"The OAuth scopes to request.\n\n        See cilogon_scope.md for details.\n        At least 'openid' is required.\n        \"\"\",\n    )\n\n    @validate('scope')\n    def _validate_scope(self, proposal):\n        \"\"\"ensure openid is requested\"\"\"\n        if 'openid' not in proposal.value:\n            return ['openid'] + proposal.value\n        return proposal.value\n\n    idp_whitelist = List(help=\"Deprecated, use `CIlogonOAuthenticator.allowed_idps`\", config=True,)\n    allowed_idps = List(\n        config=True,\n        help=\"\"\"A list of IDP which can be stripped from the username after the @ sign.\"\"\",\n    )\n    strip_idp_domain = Bool(\n        False,\n        config=True,\n        help=\"\"\"Remove the IDP domain from the username. Note that only domains which\n             appear in the `allowed_idps` will be stripped.\"\"\",\n    )\n    idp = Unicode(\n        config=True,\n        help=\"\"\"The `idp` attribute is the SAML Entity ID of the user's selected\n            identity provider.\n\n            See https://cilogon.org/include/idplist.xml for the list of identity\n            providers supported by CILogon.\n        \"\"\",\n    )\n    skin = Unicode(\n        config=True,\n        help=\"\"\"The `skin` attribute is the name of the custom CILogon interface skin\n            for your application.\n\n            Contact help@cilogon.org to request a custom skin.\n        \"\"\",\n    )\n    username_claim = Unicode(\n        \"eppn\",\n        config=True,\n        help=\"\"\"The claim in the userinfo response from which to get the JupyterHub username\n\n            Examples include: eppn, email\n\n            What keys are available will depend on the scopes requested.\n\n            See http://www.cilogon.org/oidc for details.\n        \"\"\",\n    )\n\n    additional_username_claims = List(\n        config=True,\n        help=\"\"\"Additional claims to check if the username_claim fails.\n\n        This is useful for linked identities where not all of them return\n        the primary username_claim.\n        \"\"\",\n    )\n\n    async def authenticate(self, handler, data=None):\n        \"\"\"We set up auth_state based on additional CILogon info if we\n        receive it.\n        \"\"\"\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a CILogon Access Token\n        # See: http://www.cilogon.org/oidc\n        headers = {\"Accept\": \"application/json\", \"User-Agent\": \"JupyterHub\"}\n\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            redirect_uri=self.oauth_callback_url,\n            code=code,\n            grant_type='authorization_code',\n        )\n\n        url = url_concat(self.token_url, params)\n\n        req = HTTPRequest(url, headers=headers, method=\"POST\", body='')\n\n        resp = await http_client.fetch(req)\n        token_response = json.loads(resp.body.decode('utf8', 'replace'))\n        access_token = token_response['access_token']\n        self.log.info(\"Access token acquired.\")\n        # Determine who the logged in user is\n        params = dict(access_token=access_token)\n        req = HTTPRequest(\n            url_concat(\"https://%s/oauth2/userinfo\" % self.cilogon_host, params),\n            headers=headers,\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        claimlist = [self.username_claim]\n        if self.additional_username_claims:\n            claimlist.extend(self.additional_username_claims)\n\n        for claim in claimlist:\n            username = resp_json.get(claim)\n            if username:\n                break\n        if not username:\n            if len(claimlist) < 2:\n                self.log.error(\n                    \"Username claim %s not found in response: %s\",\n                    self.username_claim,\n                    sorted(resp_json.keys()),\n                )\n            else:\n                self.log.error(\n                    \"No username claim from %r in response: %s\",\n                    claimlist,\n                    sorted(resp_json.keys()),\n                )\n            raise web.HTTPError(500, \"Failed to get username from CILogon\")\n\n        if self.allowed_idps:\n            gotten_name, gotten_idp = username.split('@')\n            if gotten_idp not in self.allowed_idps:\n                self.log.error(\n                    \"Trying to login from not allowed domain %s\", gotten_idp\n                )\n                raise web.HTTPError(500, \"Trying to login from a domain not allowed\")\n            if len(self.allowed_idps) == 1 and self.strip_idp_domain:\n                username = gotten_name\n        userdict = {\"name\": username}\n        # Now we set up auth_state\n        userdict[\"auth_state\"] = auth_state = {}\n        # Save the token response and full CILogon reply in auth state\n        # These can be used for user provisioning\n        #  in the Lab/Notebook environment.\n        auth_state['token_response'] = token_response\n        # store the whole user model in auth_state.cilogon_user\n        # keep access_token as well, in case anyone was relying on it\n        auth_state['access_token'] = access_token\n        auth_state['cilogon_user'] = resp_json\n        return userdict\n\n\nclass LocalCILogonOAuthenticator(LocalAuthenticator, CILogonOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nAuthenticator to use GitHub OAuth with JupyterHub\n\"\"\"\n\n\nimport json\nimport os\nimport re\nimport string\nimport warnings\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient, HTTPError\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import List, Set, Unicode, default, observe\n\nfrom .common import next_page_from_links\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"token {}\".format(access_token),\n    }\n\n\nclass GitHubOAuthenticator(OAuthenticator):\n\n    # see github_scopes.md for details about scope config\n    # set scopes via config, e.g.\n    # c.GitHubOAuthenticator.scope = ['read:org']\n\n    _deprecated_oauth_aliases = {\n        \"github_organization_whitelist\": (\"allowed_organizations\", \"0.12.0\"),\n        **OAuthenticator._deprecated_oauth_aliases,\n    }\n\n    login_service = \"GitHub\"\n\n    github_url = Unicode(\"https://github.com\", config=True)\n\n    @default(\"github_url\")\n    def _github_url_default(self):\n        github_url = os.environ.get(\"GITHUB_URL\")\n        if not github_url:\n            # fallback on older GITHUB_HOST config,\n            # treated the same as GITHUB_URL\n            host = os.environ.get(\"GITHUB_HOST\")\n            if host:\n                if os.environ.get(\"GITHUB_HTTP\"):\n                    protocol = \"http\"\n                    warnings.warn(\n                        'Use of GITHUB_HOST with GITHUB_HTTP might be deprecated in the future. '\n                        'Use GITHUB_URL=http://{} to set host and protocol together.'.format(\n                            host\n                        ),\n                        PendingDeprecationWarning,\n                    )\n                else:\n                    protocol = \"https\"\n                github_url = \"{}://{}\".format(protocol, host)\n\n        if github_url:\n            if '://' not in github_url:\n                # ensure protocol is included, assume https if missing\n                github_url = 'https://' + github_url\n\n            return github_url\n        else:\n            # nothing specified, this is the true default\n            github_url = \"https://github.com\"\n\n        # ensure no trailing slash\n        return github_url.rstrip(\"/\")\n\n    github_api = Unicode(\"https://api.github.com\", config=True)\n\n    @default(\"github_api\")\n    def _github_api_default(self):\n        if self.github_url == \"https://github.com\":\n            return \"https://api.github.com\"\n        else:\n            return self.github_url + \"/api/v3\"\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"%s/login/oauth/authorize\" % (self.github_url)\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/login/oauth/access_token\" % (self.github_url)\n\n    # deprecated names\n    github_client_id = Unicode(config=True, help=\"DEPRECATED\")\n\n    def _github_client_id_changed(self, name, old, new):\n        self.log.warning(\"github_client_id is deprecated, use client_id\")\n        self.client_id = new\n\n    github_client_secret = Unicode(config=True, help=\"DEPRECATED\")\n\n    def _github_client_secret_changed(self, name, old, new):\n        self.log.warning(\"github_client_secret is deprecated, use client_secret\")\n        self.client_secret = new\n\n    client_id_env = 'GITHUB_CLIENT_ID'\n    client_secret_env = 'GITHUB_CLIENT_SECRET'\n\n    github_organization_whitelist = Set(help=\"Deprecated, use `GitHubOAuthenticator.allowed_organizations`\", config=True,)\n\n    allowed_organizations = Set(\n        config=True, help=\"Automatically allow members of selected organizations\"\n    )\n\n    async def authenticate(self, handler, data=None):\n        \"\"\"We set up auth_state based on additional GitHub info if we\n        receive it.\n        \"\"\"\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitHub Access Token\n        #\n        # See: https://developer.github.com/v3/oauth/\n\n        # GitHub specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id, client_secret=self.client_secret, code=code\n        )\n\n        url = url_concat(self.token_url, params)\n\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            headers={\"Accept\": \"application/json\"},\n            body='',  # Body is required for a POST...\n            validate_cert=self.validate_server_cert,\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        if 'access_token' in resp_json:\n            access_token = resp_json['access_token']\n        elif 'error_description' in resp_json:\n            raise HTTPError(\n                403,\n                \"An access token was not returned: {}\".format(\n                    resp_json['error_description']\n                ),\n            )\n        else:\n            raise HTTPError(500, \"Bad response: {}\".format(resp))\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            self.github_api + \"/user\",\n            method=\"GET\",\n            headers=_api_headers(access_token),\n            validate_cert=self.validate_server_cert,\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"login\"]\n        # username is now the GitHub userid.\n        if not username:\n            return None\n        # Check if user is a member of any allowed organizations.\n        # This check is performed here, as it requires `access_token`.\n        if self.allowed_organizations:\n            for org in self.allowed_organizations:\n                user_in_org = await self._check_membership_allowed_organizations(\n                    org, username, access_token\n                )\n                if user_in_org:\n                    break\n            else:  # User not found in member list for any organisation\n                self.log.warning(\"User %s is not in allowed org list\", username)\n                return None\n        userdict = {\"name\": username}\n        # Now we set up auth_state\n        userdict[\"auth_state\"] = auth_state = {}\n        # Save the access token and full GitHub reply (name, id, email) in auth state\n        # These can be used for user provisioning in the Lab/Notebook environment.\n        # e.g.\n        #  1) stash the access token\n        #  2) use the GitHub ID as the id\n        #  3) set up name/email for .gitconfig\n        auth_state['access_token'] = access_token\n        # store the whole user model in auth_state.github_user\n        auth_state['github_user'] = resp_json\n        # A public email will return in the initial query (assuming default scope).\n        # Private will not.\n\n        return userdict\n\n    async def _check_membership_allowed_organizations(self, org, username, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check membership of user `username` for organization `org` via api [check-membership](https://developer.github.com/v3/orgs/members/#check-membership)\n        # With empty scope (even if authenticated by an org member), this\n        #  will only await public org members.  You want 'read:org' in order\n        #  to be able to iterate through all members.\n        check_membership_url = \"%s/orgs/%s/members/%s\" % (\n            self.github_api,\n            org,\n            username,\n        )\n        req = HTTPRequest(\n            check_membership_url,\n            method=\"GET\",\n            headers=headers,\n            validate_cert=self.validate_server_cert,\n        )\n        self.log.debug(\n            \"Checking GitHub organization membership: %s in %s?\", username, org\n        )\n        resp = await http_client.fetch(req, raise_error=False)\n        print(resp)\n        if resp.code == 204:\n            self.log.info(\"Allowing %s as member of %s\", username, org)\n            return True\n        else:\n            try:\n                resp_json = json.loads((resp.body or b'').decode('utf8', 'replace'))\n                message = resp_json.get('message', '')\n            except ValueError:\n                message = ''\n            self.log.debug(\n                \"%s does not appear to be a member of %s (status=%s): %s\",\n                username,\n                org,\n                resp.code,\n                message,\n            )\n        return False\n\n\nclass LocalGitHubOAuthenticator(LocalAuthenticator, GitHubOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nCustom Authenticator to use GitLab OAuth with JupyterHub\n\"\"\"\n\n\nimport json\nimport os\nimport re\nimport sys\nimport warnings\nfrom urllib.parse import quote\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import web\n\nfrom tornado.escape import url_escape\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set, CUnicode, Unicode, default, observe\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n\ndef _api_headers(access_token):\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"JupyterHub\",\n        \"Authorization\": \"Bearer {}\".format(access_token),\n    }\n\n\nclass GitLabOAuthenticator(OAuthenticator):\n    # see gitlab_scopes.md for details about scope config\n    # set scopes via config, e.g.\n    # c.GitLabOAuthenticator.scope = ['read_user']\n\n    _deprecated_oauth_aliases = {\n        \"gitlab_group_whitelist\": (\"allowed_gitlab_groups\", \"0.12.0\"),\n        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\"),\n        **OAuthenticator._deprecated_oauth_aliases,\n    }\n\n    login_service = \"GitLab\"\n\n    client_id_env = 'GITLAB_CLIENT_ID'\n    client_secret_env = 'GITLAB_CLIENT_SECRET'\n\n    gitlab_url = Unicode(\"https://gitlab.com\", config=True)\n\n    @default(\"gitlab_url\")\n    def _default_gitlab_url(self):\n        \"\"\"get default gitlab url from env\"\"\"\n        gitlab_url = os.getenv('GITLAB_URL')\n        gitlab_host = os.getenv('GITLAB_HOST')\n\n        if not gitlab_url and gitlab_host:\n            warnings.warn(\n                'Use of GITLAB_HOST might be deprecated in the future. '\n                'Rename GITLAB_HOST environment variable to GITLAB_URL.',\n                PendingDeprecationWarning,\n            )\n            if gitlab_host.startswith(('https:', 'http:')):\n                gitlab_url = gitlab_host\n            else:\n                # Hides common mistake of users which set the GITLAB_HOST\n                # without a protocol specification.\n                gitlab_url = 'https://{0}'.format(gitlab_host)\n                warnings.warn(\n                    'The https:// prefix has been added to GITLAB_HOST.'\n                    'Set GITLAB_URL=\"{0}\" instead.'.format(gitlab_host)\n                )\n\n        # default to gitlab.com\n        if not gitlab_url:\n            gitlab_url = 'https://gitlab.com'\n\n        return gitlab_url\n\n    gitlab_api_version = CUnicode('4', config=True)\n\n    @default('gitlab_api_version')\n    def _gitlab_api_version_default(self):\n        return os.environ.get('GITLAB_API_VERSION') or '4'\n\n    gitlab_api = Unicode(config=True)\n\n    @default(\"gitlab_api\")\n    def _default_gitlab_api(self):\n        return '%s/api/v%s' % (self.gitlab_url, self.gitlab_api_version)\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"%s/oauth/authorize\" % self.gitlab_url\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/oauth/access_token\" % self.gitlab_url\n\n    gitlab_group_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_gitlab_groups`\", config=True,)\n\n    allowed_gitlab_groups = Set(\n        config=True, help=\"Automatically allow members of selected groups\"\n    )\n\n    gitlab_project_id_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_project_ids`\", config=True,)\n\n    allowed_project_ids = Set(\n        config=True,\n        help=\"Automatically allow members with Developer access to selected project ids\",\n    )\n\n    gitlab_version = None\n\n    async def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitLab Access Token\n        #\n        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md\n\n        # GitLab specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            code=code,\n            grant_type=\"authorization_code\",\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n        validate_server_cert = self.validate_server_cert\n\n        url = url_concat(\"%s/oauth/token\" % self.gitlab_url, params)\n\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            headers={\"Accept\": \"application/json\"},\n            validate_cert=validate_server_cert,\n            body='',  # Body is required for a POST...\n        )\n\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # memoize gitlab version for class lifetime\n        if self.gitlab_version is None:\n            self.gitlab_version = await self._get_gitlab_version(access_token)\n            self.member_api_variant = 'all/' if self.gitlab_version >= [12, 4] else ''\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\n            \"%s/user\" % self.gitlab_api,\n            method=\"GET\",\n            validate_cert=validate_server_cert,\n            headers=_api_headers(access_token),\n        )\n        resp = await http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n        user_id = resp_json[\"id\"]\n        is_admin = resp_json.get(\"is_admin\", False)\n\n        # Check if user is a member of any allowed groups or projects.\n        # These checks are performed here, as it requires `access_token`.\n        user_in_group = user_in_project = False\n        is_group_specified = is_project_id_specified = False\n\n        if self.allowed_gitlab_groups:\n            is_group_specified = True\n            user_in_group = await self._check_membership_allowed_groups(user_id, access_token)\n\n        # We skip project_id check if user is in allowed group.\n        if self.allowed_project_ids and not user_in_group:\n            is_project_id_specified = True\n            user_in_project = await self._check_membership_allowed_project_ids(\n                user_id, access_token\n            )\n\n        no_config_specified = not (is_group_specified or is_project_id_specified)\n\n        if (\n            (is_group_specified and user_in_group)\n            or (is_project_id_specified and user_in_project)\n            or no_config_specified\n        ):\n            return {\n                'name': username,\n                'auth_state': {'access_token': access_token, 'gitlab_user': resp_json},\n            }\n        else:\n            self.log.warning(\"%s not in group or project allowed list\", username)\n            return None\n\n    async def _get_gitlab_version(self, access_token):\n        url = '%s/version' % self.gitlab_api\n        req = HTTPRequest(\n            url,\n            method=\"GET\",\n            headers=_api_headers(access_token),\n            validate_cert=self.validate_server_cert,\n        )\n        resp = await AsyncHTTPClient().fetch(req, raise_error=True)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n        version_strings = resp_json['version'].split('-')[0].split('.')[:3]\n        version_ints = list(map(int, version_strings))\n        return version_ints\n\n    async def _check_membership_allowed_groups(self, user_id, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check if user is a member of any group in the allowed list\n        for group in map(url_escape, self.allowed_gitlab_groups):\n            url = \"%s/groups/%s/members/%s%d\" % (\n                self.gitlab_api,\n                quote(group, safe=''),\n                self.member_api_variant,\n                user_id,\n            )\n            req = HTTPRequest(url, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req, raise_error=False)\n            if resp.code == 200:\n                return True  # user _is_ in group\n        return False\n\n    async def _check_membership_allowed_project_ids(self, user_id, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check if user has developer access to any project in the allowed list\n        for project in self.allowed_project_ids:\n            url = \"%s/projects/%s/members/%s%d\" % (\n                self.gitlab_api,\n                project,\n                self.member_api_variant,\n                user_id,\n            )\n            req = HTTPRequest(url, method=\"GET\", headers=headers)\n            resp = await http_client.fetch(req, raise_error=False)\n\n            if resp.body:\n                resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n                access_level = resp_json.get('access_level', 0)\n\n                # We only allow access level Developer and above\n                # Reference: https://docs.gitlab.com/ee/api/members.html\n                if resp.code == 200 and access_level >= 30:\n                    return True\n        return False\n\n\nclass LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nCustom Authenticator to use Google OAuth with JupyterHub.\n\nDerived from the GitHub OAuth authenticator.\n\"\"\"\n\nimport os\nimport json\nimport urllib.parse\n\nfrom tornado import gen\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\nfrom tornado.auth import GoogleOAuth2Mixin\nfrom tornado.web import HTTPError\n\nfrom traitlets import Dict, Unicode, List, default, validate, observe\n\nfrom jupyterhub.crypto import decrypt, EncryptionUnavailable, InvalidToken\nfrom jupyterhub.auth import LocalAuthenticator\nfrom jupyterhub.utils import url_path_join\n\nfrom .oauth2 import OAuthLoginHandler, OAuthCallbackHandler, OAuthenticator\n\ndef check_user_in_groups(member_groups, allowed_groups):\n    # Check if user is a member of any group in the allowed groups\n    if any(g in member_groups for g in allowed_groups):\n        return True  # user _is_ in group\n    else:\n        return False\n\n\nclass GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):\n    _deprecated_oauth_aliases = {\n        \"google_group_whitelist\": (\"allowed_google_groups\", \"0.12.0\"),\n        **OAuthenticator._deprecated_oauth_aliases,\n    }\n\n    google_api_url = Unicode(\"https://www.googleapis.com\", config=True)\n\n    @default('google_api_url')\n    def _google_api_url(self):\n        \"\"\"get default google apis url from env\"\"\"\n        google_api_url = os.getenv('GOOGLE_API_URL')\n\n        # default to googleapis.com\n        if not google_api_url:\n            google_api_url = 'https://www.googleapis.com'\n\n        return google_api_url\n\n    @default('scope')\n    def _scope_default(self):\n        return ['openid', 'email']\n\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return \"https://accounts.google.com/o/oauth2/v2/auth\"\n\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return \"%s/oauth2/v4/token\" % (self.google_api_url)\n\n    google_service_account_keys = Dict(\n        Unicode(),\n        help=\"Service account keys to use with each domain, see https://developers.google.com/admin-sdk/directory/v1/guides/delegation\"\n    ).tag(config=True)\n\n    gsuite_administrator = Dict(\n        Unicode(),\n        help=\"Username of a G Suite Administrator for the service account to act as\"\n    ).tag(config=True)\n\n    google_group_whitelist = Dict(help=\"Deprecated, use `GoogleOAuthenticator.allowed_google_groups`\", config=True,)\n\n    allowed_google_groups = Dict(\n        List(Unicode()),\n        help=\"Automatically allow members of selected groups\"\n    ).tag(config=True)\n\n    admin_google_groups = Dict(\n        List(Unicode()),\n        help=\"Groups whose members should have Jupyterhub admin privileges\"\n    ).tag(config=True)\n\n    user_info_url = Unicode(\n        \"https://www.googleapis.com/oauth2/v1/userinfo\", config=True\n    )\n\n    hosted_domain = List(\n        Unicode(),\n        config=True,\n        help=\"\"\"List of domains used to restrict sign-in, e.g. mycollege.edu\"\"\",\n    )\n\n    @default('hosted_domain')\n    def _hosted_domain_from_env(self):\n        domains = []\n        for domain in os.environ.get('HOSTED_DOMAIN', '').split(';'):\n            if domain:\n                # check falsy to avoid trailing separators\n                # adding empty domains\n                domains.append(domain)\n        return domains\n\n    @validate('hosted_domain')\n    def _cast_hosted_domain(self, proposal):\n        \"\"\"handle backward-compatibility with hosted_domain is a single domain as a string\"\"\"\n        if isinstance(proposal.value, str):\n            # pre-0.9 hosted_domain was a string\n            # set it to a single item list\n            # (or if it's empty, an empty list)\n            if proposal.value == '':\n                return []\n            return [proposal.value]\n        return proposal.value\n\n    login_service = Unicode(\n        os.environ.get('LOGIN_SERVICE', 'Google'),\n        config=True,\n        help=\"\"\"Google Apps hosted domain string, e.g. My College\"\"\",\n    )\n\n    async def authenticate(self, handler, data=None, google_groups=None):\n        code = handler.get_argument(\"code\")\n        body = urllib.parse.urlencode(\n            dict(\n                code=code,\n                redirect_uri=self.get_callback_url(handler),\n                client_id=self.client_id,\n                client_secret=self.client_secret,\n                grant_type=\"authorization_code\",\n            )\n        )\n\n        http_client = AsyncHTTPClient()\n\n        response = await http_client.fetch(\n            self.token_url,\n            method=\"POST\",\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n            body=body,\n        )\n\n        user = json.loads(response.body.decode(\"utf-8\", \"replace\"))\n        access_token = str(user['access_token'])\n        refresh_token = user.get('refresh_token', None)\n\n        response = await http_client.fetch(\n            self.user_info_url + '?access_token=' + access_token\n        )\n\n        if not response:\n            handler.clear_all_cookies()\n            raise HTTPError(500, 'Google authentication failed')\n\n        bodyjs = json.loads(response.body.decode())\n        user_email = username = bodyjs['email']\n        user_email_domain = user_email.split('@')[1]\n\n        if not bodyjs['verified_email']:\n            self.log.warning(\"Google OAuth unverified email attempt: %s\", user_email)\n            raise HTTPError(403, \"Google email {} not verified\".format(user_email))\n\n        if self.hosted_domain:\n            if user_email_domain not in self.hosted_domain:\n                self.log.warning(\n                    \"Google OAuth unauthorized domain attempt: %s\", user_email\n                )\n                raise HTTPError(\n                    403,\n                    \"Google account domain @{} not authorized.\".format(\n                        user_email_domain\n                    ),\n                )\n            if len(self.hosted_domain) == 1:\n                # unambiguous domain, use only base name\n                username = user_email.split('@')[0]\n\n        if refresh_token is None:\n            self.log.debug(\"Refresh token was empty, will try to pull refresh_token from previous auth_state\")\n            user = handler.find_user(username)\n\n            if user:\n                self.log.debug(\"encrypted_auth_state was found, will try to decrypt and pull refresh_token from it\")\n                try:\n                    encrypted = user.encrypted_auth_state\n                    auth_state = await decrypt(encrypted)\n                    refresh_token = auth_state.get('refresh_token')\n                except (ValueError, InvalidToken, EncryptionUnavailable) as e:\n                    self.log.warning(\n                        \"Failed to retrieve encrypted auth_state for %s because %s\",\n                        username,\n                        e,\n                    )\n\n        user_info = {\n            'name': username,\n            'auth_state': {\n                'access_token': access_token,\n                'refresh_token': refresh_token,\n                'google_user': bodyjs\n            }\n        }\n\n        if self.admin_google_groups or self.allowed_google_groups:\n            user_info = await self._add_google_groups_info(user_info, google_groups)\n\n        return user_info\n\n    def _service_client_credentials(self, scopes, user_email_domain):\n        \"\"\"\n        Return a configured service client credentials for the API.\n        \"\"\"\n        try:\n            from google.oauth2 import service_account\n        except:\n            raise ImportError(\n                \"Could not import google.oauth2's service_account,\"\n                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"\n            )\n\n        gsuite_administrator_email = \"{}@{}\".format(self.gsuite_administrator[user_email_domain], user_email_domain)\n        self.log.debug(\"scopes are %s, user_email_domain is %s\", scopes, user_email_domain)\n        credentials = service_account.Credentials.from_service_account_file(\n            self.google_service_account_keys[user_email_domain],\n            scopes=scopes\n        )\n\n        credentials = credentials.with_subject(gsuite_administrator_email)\n\n        return credentials\n\n    def _service_client(self, service_name, service_version, credentials, http=None):\n        \"\"\"\n        Return a configured service client for the API.\n        \"\"\"\n        try:\n            from googleapiclient.discovery import build\n        except:\n            raise ImportError(\n                \"Could not import googleapiclient.discovery's build,\"\n                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"\n            )\n\n        self.log.debug(\"service_name is %s, service_version is %s\", service_name, service_version)\n\n        return build(\n            serviceName=service_name,\n            version=service_version,\n            credentials=credentials,\n            cache_discovery=False,\n            http=http)\n\n    async def _google_groups_for_user(self, user_email, credentials, http=None):\n        \"\"\"\n        Return google groups a given user is a member of\n        \"\"\"\n        service = self._service_client(\n            service_name='admin',\n            service_version='directory_v1',\n            credentials=credentials,\n            http=http)\n\n        results = service.groups().list(userKey=user_email).execute()\n        results = [ g['email'].split('@')[0] for g in results.get('groups', [{'email': None}]) ]\n        self.log.debug(\"user_email %s is a member of %s\", user_email, results)\n        return results\n\n    async def _add_google_groups_info(self, user_info, google_groups=None):\n        user_email_domain=user_info['auth_state']['google_user']['hd']\n        user_email=user_info['auth_state']['google_user']['email']\n        if google_groups is None:\n            credentials = self._service_client_credentials(\n                    scopes=['%s/auth/admin.directory.group.readonly' % (self.google_api_url)],\n                    user_email_domain=user_email_domain)\n            google_groups = await self._google_groups_for_user(\n                    user_email=user_email,\n                    credentials=credentials)\n        user_info['auth_state']['google_user']['google_groups'] = google_groups\n\n        # Check if user is a member of any admin groups.\n        if self.admin_google_groups:\n            is_admin = check_user_in_groups(google_groups, self.admin_google_groups[user_email_domain])\n        # Check if user is a member of any allowed groups.\n        user_in_group = check_user_in_groups(google_groups, self.allowed_google_groups[user_email_domain])\n\n        if self.admin_google_groups and (is_admin or user_in_group):\n            user_info['admin'] = is_admin\n            return user_info\n        elif user_in_group:\n            return user_info\n        else:\n            return None\n\n\nclass LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator):\n    \"\"\"A version that mixes in local system user creation\"\"\"\n\n    pass\n", "\"\"\"\nBase classes for Custom Authenticator to use OAuth with JupyterHub\n\nMost of the code c/o Kyle Kelley (@rgbkrk)\n\"\"\"\n\nimport base64\nimport json\nimport os\nfrom urllib.parse import quote, urlparse\nimport uuid\n\nfrom tornado import web\nfrom tornado.auth import OAuth2Mixin\nfrom tornado.log import app_log\n\nfrom jupyterhub.handlers import BaseHandler\nfrom jupyterhub.auth import Authenticator\nfrom jupyterhub.utils import url_path_join\n\nfrom traitlets import Unicode, Bool, List, Dict, default, observe\n\n\ndef guess_callback_uri(protocol, host, hub_server_url):\n    return '{proto}://{host}{path}'.format(\n        proto=protocol, host=host, path=url_path_join(hub_server_url, 'oauth_callback')\n    )\n\n\nSTATE_COOKIE_NAME = 'oauthenticator-state'\n\n\ndef _serialize_state(state):\n    \"\"\"Serialize OAuth state to a base64 string after passing through JSON\"\"\"\n    json_state = json.dumps(state)\n    return base64.urlsafe_b64encode(json_state.encode('utf8')).decode('ascii')\n\n\ndef _deserialize_state(b64_state):\n    \"\"\"Deserialize OAuth state as serialized in _serialize_state\"\"\"\n    if isinstance(b64_state, str):\n        b64_state = b64_state.encode('ascii')\n    try:\n        json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')\n    except ValueError:\n        app_log.error(\"Failed to b64-decode state: %r\", b64_state)\n        return {}\n    try:\n        return json.loads(json_state)\n    except ValueError:\n        app_log.error(\"Failed to json-decode state: %r\", json_state)\n        return {}\n\n\nclass OAuthLoginHandler(OAuth2Mixin, BaseHandler):\n    \"\"\"Base class for OAuth login handler\n\n    Typically subclasses will need\n    \"\"\"\n\n    # these URLs are part of the OAuth2Mixin API\n    # get them from the Authenticator object\n    @property\n    def _OAUTH_AUTHORIZE_URL(self):\n        return self.authenticator.authorize_url\n\n    @property\n    def _OAUTH_ACCESS_TOKEN_URL(self):\n        return self.authenticator.token_url\n\n    @property\n    def _OAUTH_USERINFO_URL(self):\n        return self.authenticator.userdata_url\n\n    def set_state_cookie(self, state):\n        self._set_cookie(STATE_COOKIE_NAME, state, expires_days=1, httponly=True)\n\n    _state = None\n\n    def get_state(self):\n        next_url = original_next_url = self.get_argument('next', None)\n        if next_url:\n            # avoid browsers treating \\ as /\n            next_url = next_url.replace('\\\\', quote('\\\\'))\n            # disallow hostname-having urls,\n            # force absolute path redirect\n            urlinfo = urlparse(next_url)\n            next_url = urlinfo._replace(\n                scheme='', netloc='', path='/' + urlinfo.path.lstrip('/')\n            ).geturl()\n            if next_url != original_next_url:\n                self.log.warning(\n                    \"Ignoring next_url %r, using %r\", original_next_url, next_url\n                )\n        if self._state is None:\n            self._state = _serialize_state(\n                {'state_id': uuid.uuid4().hex, 'next_url': next_url}\n            )\n        return self._state\n\n    def get(self):\n        redirect_uri = self.authenticator.get_callback_url(self)\n        extra_params = self.authenticator.extra_authorize_params.copy()\n        self.log.info('OAuth redirect: %r', redirect_uri)\n        state = self.get_state()\n        self.set_state_cookie(state)\n        extra_params['state'] = state\n        self.authorize_redirect(\n            redirect_uri=redirect_uri,\n            client_id=self.authenticator.client_id,\n            scope=self.authenticator.scope,\n            extra_params=extra_params,\n            response_type='code',\n        )\n\n\nclass OAuthCallbackHandler(BaseHandler):\n    \"\"\"Basic handler for OAuth callback. Calls authenticator to verify username.\"\"\"\n\n    _state_cookie = None\n\n    def get_state_cookie(self):\n        \"\"\"Get OAuth state from cookies\n\n        To be compared with the value in redirect URL\n        \"\"\"\n        if self._state_cookie is None:\n            self._state_cookie = (\n                self.get_secure_cookie(STATE_COOKIE_NAME) or b''\n            ).decode('utf8', 'replace')\n            self.clear_cookie(STATE_COOKIE_NAME)\n        return self._state_cookie\n\n    def get_state_url(self):\n        \"\"\"Get OAuth state from URL parameters\n\n        to be compared with the value in cookies\n        \"\"\"\n        return self.get_argument(\"state\")\n\n    def check_state(self):\n        \"\"\"Verify OAuth state\n\n        compare value in cookie with redirect url param\n        \"\"\"\n        cookie_state = self.get_state_cookie()\n        url_state = self.get_state_url()\n        if not cookie_state:\n            raise web.HTTPError(400, \"OAuth state missing from cookies\")\n        if not url_state:\n            raise web.HTTPError(400, \"OAuth state missing from URL\")\n        if cookie_state != url_state:\n            self.log.warning(\"OAuth state mismatch: %s != %s\", cookie_state, url_state)\n            raise web.HTTPError(400, \"OAuth state mismatch\")\n\n    def check_error(self):\n        \"\"\"Check the OAuth code\"\"\"\n        error = self.get_argument(\"error\", False)\n        if error:\n            message = self.get_argument(\"error_description\", error)\n            raise web.HTTPError(400, \"OAuth error: %s\" % message)\n\n    def check_code(self):\n        \"\"\"Check the OAuth code\"\"\"\n        if not self.get_argument(\"code\", False):\n            raise web.HTTPError(400, \"OAuth callback made without a code\")\n\n    def check_arguments(self):\n        \"\"\"Validate the arguments of the redirect\n\n        Default:\n\n        - check for oauth-standard error, error_description arguments\n        - check that there's a code\n        - check that state matches\n        \"\"\"\n        self.check_error()\n        self.check_code()\n        self.check_state()\n\n    def append_query_parameters(self, url, exclude=None):\n        \"\"\"JupyterHub 1.2 appends query parameters by default in get_next_url\n\n        This is not appropriate for oauth callback handlers, where params are oauth state, code, etc.\n\n        Override the method used to append parameters to next_url to not preserve any parameters\n        \"\"\"\n        return url\n\n    def get_next_url(self, user=None):\n        \"\"\"Get the redirect target from the state field\"\"\"\n        state = self.get_state_url()\n        if state:\n            next_url = _deserialize_state(state).get('next_url')\n            if next_url:\n                return next_url\n        # JupyterHub 0.8 adds default .get_next_url for a fallback\n        if hasattr(BaseHandler, 'get_next_url'):\n            return super().get_next_url(user)\n        return url_path_join(self.hub.server.base_url, 'home')\n\n    async def _login_user_pre_08(self):\n        \"\"\"login_user simplifies the login+cookie+auth_state process in JupyterHub 0.8\n\n        _login_user_07 is for backward-compatibility with JupyterHub 0.7\n        \"\"\"\n        user_info = await self.authenticator.get_authenticated_user(self, None)\n        if user_info is None:\n            return\n        if isinstance(user_info, dict):\n            username = user_info['name']\n        else:\n            username = user_info\n        user = self.user_from_username(username)\n        self.set_login_cookie(user)\n        return user\n\n    if not hasattr(BaseHandler, 'login_user'):\n        # JupyterHub 0.7 doesn't have .login_user\n        login_user = _login_user_pre_08\n\n    async def get(self):\n        self.check_arguments()\n        user = await self.login_user()\n        if user is None:\n            # todo: custom error page?\n            raise web.HTTPError(403)\n        self.redirect(self.get_next_url(user))\n\n\nclass OAuthenticator(Authenticator):\n    \"\"\"Base class for OAuthenticators\n\n    Subclasses must override:\n\n    login_service (string identifying the service provider)\n    authenticate (method takes one arg - the request handler handling the oauth callback)\n    \"\"\"\n\n    login_handler = OAuthLoginHandler\n    callback_handler = OAuthCallbackHandler\n\n    authorize_url = Unicode(\n        config=True, help=\"\"\"The authenticate url for initiating oauth\"\"\"\n    )\n    @default(\"authorize_url\")\n    def _authorize_url_default(self):\n        return os.environ.get(\"OAUTH2_AUTHORIZE_URL\", \"\")\n\n    token_url = Unicode(\n        config=True,\n        help=\"\"\"The url retrieving an access token at the completion of oauth\"\"\",\n    )\n    @default(\"token_url\")\n    def _token_url_default(self):\n        return os.environ.get(\"OAUTH2_TOKEN_URL\", \"\")\n\n    userdata_url = Unicode(\n        config=True,\n        help=\"\"\"The url for retrieving user data with a completed access token\"\"\",\n    )\n    @default(\"userdata_url\")\n    def _userdata_url_default(self):\n        return os.environ.get(\"OAUTH2_USERDATA_URL\", \"\")\n\n    scope = List(\n        Unicode(),\n        config=True,\n        help=\"\"\"The OAuth scopes to request.\n        See the OAuth documentation of your OAuth provider for options.\n        For GitHub in particular, you can see github_scopes.md in this repo.\n        \"\"\",\n    )\n\n    extra_authorize_params = Dict(\n        config=True,\n        help=\"\"\"Extra GET params to send along with the initial OAuth request\n        to the OAuth provider.\"\"\",\n    )\n\n    login_service = 'override in subclass'\n    oauth_callback_url = Unicode(\n        os.getenv('OAUTH_CALLBACK_URL', ''),\n        config=True,\n        help=\"\"\"Callback URL to use.\n        Typically `https://{host}/hub/oauth_callback`\"\"\",\n    )\n\n    client_id_env = ''\n    client_id = Unicode(config=True)\n\n    def _client_id_default(self):\n        if self.client_id_env:\n            client_id = os.getenv(self.client_id_env, '')\n            if client_id:\n                return client_id\n        return os.getenv('OAUTH_CLIENT_ID', '')\n\n    client_secret_env = ''\n    client_secret = Unicode(config=True)\n\n    def _client_secret_default(self):\n        if self.client_secret_env:\n            client_secret = os.getenv(self.client_secret_env, '')\n            if client_secret:\n                return client_secret\n        return os.getenv('OAUTH_CLIENT_SECRET', '')\n\n    validate_server_cert_env = 'OAUTH_TLS_VERIFY'\n    validate_server_cert = Bool(config=True)\n\n    def _validate_server_cert_default(self):\n        env_value = os.getenv(self.validate_server_cert_env, '')\n        if env_value == '0':\n            return False\n        else:\n            return True\n\n    def login_url(self, base_url):\n        return url_path_join(base_url, 'oauth_login')\n\n\n    def get_callback_url(self, handler=None):\n        \"\"\"Get my OAuth redirect URL\n        \n        Either from config or guess based on the current request.\n        \"\"\"\n        if self.oauth_callback_url:\n            return self.oauth_callback_url\n        elif handler:\n            return guess_callback_uri(\n                handler.request.protocol,\n                handler.request.host,\n                handler.hub.server.base_url,\n            )\n        else:\n            raise ValueError(\n                \"Specify callback oauth_callback_url or give me a handler to guess with\"\n            )\n\n    def get_handlers(self, app):\n        return [\n            (r'/oauth_login', self.login_handler),\n            (r'/oauth_callback', self.callback_handler),\n        ]\n\n    async def authenticate(self, handler, data=None):\n        raise NotImplementedError()\n\n    _deprecated_oauth_aliases = {}\n\n    def _deprecated_oauth_trait(self, change):\n        \"\"\"observer for deprecated traits\"\"\"\n        old_attr = change.name\n        new_attr, version = self._deprecated_oauth_aliases.get(old_attr)\n        new_value = getattr(self, new_attr)\n        if new_value != change.new:\n            # only warn if different\n            # protects backward-compatible config from warnings\n            # if they set the same value under both names\n            self.log.warning(\n                \"{cls}.{old} is deprecated in {cls} {version}, use {cls}.{new} instead\".format(\n                    cls=self.__class__.__name__,\n                    old=old_attr,\n                    new=new_attr,\n                    version=version,\n                )\n            )\n            setattr(self, new_attr, change.new)\n\n    def __init__(self, **kwargs):\n        # observe deprecated config names in oauthenticator\n        if self._deprecated_oauth_aliases:\n            self.observe(\n                self._deprecated_oauth_trait, names=list(self._deprecated_oauth_aliases)\n            )\n        super().__init__(**kwargs)\n", "import os\nfrom unittest.mock import patch\n\nimport logging\nfrom pytest import fixture, mark\nfrom traitlets.config import Config\n\nfrom ..bitbucket import BitbucketOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(username):\n    \"\"\"Return a user model\"\"\"\n    return {\n        'username': username,\n    }\n\n@fixture\ndef bitbucket_client(client):\n    setup_oauth_mock(client,\n        host=['bitbucket.org', 'api.bitbucket.org'],\n        access_token_path='/site/oauth2/access_token',\n        user_path='/2.0/user',\n    )\n    return client\n\n\nasync def test_bitbucket(bitbucket_client):\n    authenticator = BitbucketOAuthenticator()\n    handler = bitbucket_client.handler_for_user(user_model('yorba'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'yorba'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'bitbucket_user' in auth_state\n\n\nasync def test_allowed_teams(bitbucket_client):\n    client = bitbucket_client\n    authenticator = BitbucketOAuthenticator()\n    authenticator.allowed_teams = ['blue']\n\n    teams = {\n        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],\n        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],\n    }\n    def list_teams(request):\n        token = request.headers['Authorization'].split(None, 1)[1]\n        username = client.access_tokens[token]['username']\n        values = []\n        for team, members in teams.items():\n            if username in members:\n                values.append({'username': team})\n        return {\n            'values': values\n        }\n\n    client.hosts['api.bitbucket.org'].append(\n        ('/2.0/teams', list_teams)\n    )\n\n    handler = client.handler_for_user(user_model('caboose'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'caboose'\n\n    handler = client.handler_for_user(user_model('donut'))\n    name = await authenticator.authenticate(handler)\n    assert name is None\n\n    # reverse it, just to be safe\n    authenticator.allowed_teams = ['red']\n\n    handler = client.handler_for_user(user_model('caboose'))\n    name = await authenticator.authenticate(handler)\n    assert name is None\n\n    handler = client.handler_for_user(user_model('donut'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'donut'\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.BitbucketOAuthenticator.team_whitelist = ['red']\n    cfg.BitbucketOAuthenticator.whitelist = {\"blue\"}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = BitbucketOAuthenticator(config=cfg, log=log)\n    assert (\n        log.name,\n        logging.WARNING,\n        'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '\n        'BitbucketOAuthenticator.allowed_teams instead',\n    ) in caplog.record_tuples\n\n    assert authenticator.allowed_teams == {\"red\"}\n    assert authenticator.allowed_users == {\"blue\"}\n", "import re\nimport functools\nimport json\nfrom io import BytesIO\n\nimport logging\nfrom pytest import fixture, mark\nfrom urllib.parse import urlparse, parse_qs\nfrom tornado.httpclient import HTTPRequest, HTTPResponse\nfrom tornado.httputil import HTTPHeaders\nfrom traitlets.config import Config\n\nfrom ..github import GitHubOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(username):\n    \"\"\"Return a user model\"\"\"\n    return {\n        'email': 'dinosaurs@space',\n        'id': 5,\n        'login': username,\n        'name': 'Hoban Washburn',\n    }\n\n@fixture\ndef github_client(client):\n    setup_oauth_mock(client,\n        host=['github.com', 'api.github.com'],\n        access_token_path='/login/oauth/access_token',\n        user_path='/user',\n        token_type='token',\n    )\n    return client\n\n\nasync def test_github(github_client):\n    authenticator = GitHubOAuthenticator()\n    handler = github_client.handler_for_user(user_model('wash'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'wash'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n\n    assert auth_state == {\n        'access_token': auth_state['access_token'],\n        'github_user': {\n            'email': 'dinosaurs@space',\n            'id': 5,\n            'login': name,\n            'name': 'Hoban Washburn',\n        }\n    }\n\n\ndef make_link_header(urlinfo, page):\n    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'\n                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}\n\n\nasync def test_allowed_org_membership(github_client):\n    client = github_client\n    authenticator = GitHubOAuthenticator()\n\n    ## Mock Github API\n\n    teams = {\n        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],\n        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],\n    }\n\n    member_regex = re.compile(r'/orgs/(.*)/members')\n\n    def team_members(paginate, request):\n        urlinfo = urlparse(request.url)\n        team = member_regex.match(urlinfo.path).group(1)\n\n        if team not in teams:\n            return HTTPResponse(request, 404)\n\n        if not paginate:\n            return [user_model(m) for m in teams[team]]\n        else:\n            page = parse_qs(urlinfo.query).get('page', ['1'])\n            page = int(page[0])\n            return team_members_paginated(\n                team, page, urlinfo, functools.partial(HTTPResponse, request))\n\n    def team_members_paginated(team, page, urlinfo, response):\n        if page < len(teams[team]):\n            headers = make_link_header(urlinfo, page + 1)\n        elif page == len(teams[team]):\n            headers = {}\n        else:\n            return response(400)\n\n        headers.update({'Content-Type': 'application/json'})\n\n        ret = [user_model(teams[team][page - 1])]\n\n        return response(200,\n                        headers=HTTPHeaders(headers),\n                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n\n\n    membership_regex = re.compile(r'/orgs/(.*)/members/(.*)')\n\n    def team_membership(request):\n        urlinfo = urlparse(request.url)\n        urlmatch = membership_regex.match(urlinfo.path)\n        team = urlmatch.group(1)\n        username = urlmatch.group(2)\n        print('Request team = %s, username = %s' % (team, username))\n        if team not in teams:\n            print('Team not found: team = %s' %(team))\n            return HTTPResponse(request, 404)\n        if username not in teams[team]:\n            print('Member not found: team = %s, username = %s' %(team, username))\n            return HTTPResponse(request, 404)\n        return HTTPResponse(request, 204)\n\n\n    ## Perform tests\n\n    for paginate in (False, True):\n        client_hosts = client.hosts['api.github.com']\n        client_hosts.append((membership_regex, team_membership))\n        client_hosts.append((member_regex, functools.partial(team_members, paginate)))\n\n        authenticator.allowed_organizations = ['blue']\n\n        handler = client.handler_for_user(user_model('caboose'))\n        user = await authenticator.authenticate(handler)\n        assert user['name'] == 'caboose'\n\n        handler = client.handler_for_user(user_model('donut'))\n        user = await authenticator.authenticate(handler)\n        assert user is None\n\n        # reverse it, just to be safe\n        authenticator.allowed_organizations = ['red']\n\n        handler = client.handler_for_user(user_model('caboose'))\n        user = await authenticator.authenticate(handler)\n        assert user is None\n\n        handler = client.handler_for_user(user_model('donut'))\n        user = await authenticator.authenticate(handler)\n        assert user['name'] == 'donut'\n\n        client_hosts.pop()\n        client_hosts.pop()\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GitHubOAuthenticator.github_organization_whitelist = [\"jupy\"]\n    cfg.Authenticator.whitelist = {\"user1\"}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GitHubOAuthenticator(config=cfg, log=log)\n    assert (\n        log.name,\n        logging.WARNING,\n        'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '\n        'GitHubOAuthenticator.allowed_organizations instead',\n    ) in caplog.record_tuples\n\n    assert authenticator.allowed_organizations == {\"jupy\"}\n    assert authenticator.allowed_users == {\"user1\"}\n", "import re\nimport json\nfrom io import BytesIO\nimport functools\nimport collections\nfrom urllib.parse import urlparse, parse_qs\n\nimport logging\nfrom tornado.httpclient import HTTPResponse\nfrom tornado.httputil import HTTPHeaders\nfrom traitlets.config import Config\nfrom pytest import fixture, mark\n\nfrom ..gitlab import GitLabOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\nAPI_ENDPOINT = '/api/v%s' % (GitLabOAuthenticator().gitlab_api_version)\n\n\ndef user_model(username, id=1, is_admin=False):\n    \"\"\"Return a user model\"\"\"\n    user = {\n        'username': username,\n        'id': id,\n    }\n    if is_admin:\n      # Some versions of the API do not return the is_admin property\n        # for non-admin users (See #115).\n        user['is_admin'] = True\n    return user\n\n@fixture\ndef gitlab_client(client):\n    setup_oauth_mock(client,\n        host='gitlab.com',\n        access_token_path='/oauth/token',\n        user_path=API_ENDPOINT + '/user',\n    )\n    return client\n\ndef mock_api_version(client, version):\n    def mock_version_response(request):\n        ret = { 'version': version, 'revision': \"f79c1794977\" }\n        return HTTPResponse(request, 200,\n                            headers={'Content-Type': 'application/json'},\n                            buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n    regex = re.compile(API_ENDPOINT + '/version')\n    client.hosts['gitlab.com'].append((regex, mock_version_response))\n\nasync def test_gitlab(gitlab_client):\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(gitlab_client, '12.3.1-ee')\n    handler = gitlab_client.handler_for_user(user_model('wash'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'wash'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'gitlab_user' in auth_state\n\n\ndef make_link_header(urlinfo, page):\n    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'\n                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}\n\n\nasync def test_allowed_groups(gitlab_client):\n    client = gitlab_client\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(client, '12.4.0-ee')\n\n    ## set up fake Gitlab API\n\n    user_groups = collections.OrderedDict({\n        'grif': ['red', 'yellow'],\n        'simmons': ['red', 'yellow'],\n        'caboose': ['blue', 'yellow'],\n        'burns': ['blue', 'yellow'],\n    })\n\n    def group_user_model(username, is_admin=False):\n        return user_model(username,\n                          list(user_groups.keys()).index(username) + 1,\n                          is_admin)\n\n\n    member_regex = re.compile(API_ENDPOINT + r'/groups/(.*)/members/all/(.*)')\n    def is_member(request):\n        urlinfo = urlparse(request.url)\n        group, uid = member_regex.match(urlinfo.path).group(1, 2)\n        uname = list(user_groups.keys())[int(uid) - 1]\n        if group in user_groups[uname]:\n            return HTTPResponse(request, 200)\n        else:\n            return HTTPResponse(request, 404)\n\n    def groups(paginate, request):\n        urlinfo = urlparse(request.url)\n        _, token = request._headers.get('Authorization').split()\n        user = client.access_tokens[token]['username']\n        if not paginate:\n            return [{'path': group} for group in user_groups[user]]\n        else:\n            page = parse_qs(urlinfo.query).get('page', ['1'])\n            page = int(page[0])\n            return groups_paginated(user, page, urlinfo,\n                                    functools.partial(HTTPResponse, request))\n\n    def groups_paginated(user, page, urlinfo, response):\n        if page < len(user_groups[user]):\n            headers = make_link_header(urlinfo, page + 1)\n        elif page == len(user_groups[user]):\n            headers = {}\n        else:\n            return response(400)\n\n        headers.update({'Content-Type': 'application/json'})\n\n        ret = [{'path': user_groups[user][page - 1]}]\n\n        return response(200, headers=HTTPHeaders(headers),\n                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))\n\n    client.hosts['gitlab.com'].append(\n        (member_regex, is_member)\n    )\n\n    ## actual tests\n\n    for paginate in (False, True):\n        client.hosts['gitlab.com'].append(\n            (API_ENDPOINT + '/groups', functools.partial(groups, paginate))\n        )\n\n        authenticator.allowed_gitlab_groups = ['blue']\n\n        handler = client.handler_for_user(group_user_model('caboose'))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'caboose'\n\n        handler = client.handler_for_user(group_user_model('burns', is_admin=True))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'burns'\n\n        handler = client.handler_for_user(group_user_model('grif'))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        handler = client.handler_for_user(group_user_model('simmons', is_admin=True))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        # reverse it, just to be safe\n        authenticator.allowed_gitlab_groups = ['red']\n\n        handler = client.handler_for_user(group_user_model('caboose'))\n        name = await authenticator.authenticate(handler)\n        assert name is None\n\n        handler = client.handler_for_user(group_user_model('grif'))\n        user_info = await authenticator.authenticate(handler)\n        name = user_info['name']\n        assert name == 'grif'\n\n        client.hosts['gitlab.com'].pop()\n\n\nasync def test_allowed_project_ids(gitlab_client):\n    client = gitlab_client\n    authenticator = GitLabOAuthenticator()\n    mock_api_version(client, '12.4.0-pre')\n\n    user_projects = {\n        '1231231': {\n            '3588673': {\n                'id': 3588674,\n                'name': 'john',\n                'username': 'john',\n                'state': 'active',\n                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',\n                'web_url': 'https://gitlab.com/john',\n                'access_level': 10,  # Guest\n                'expires_at': '2030-02-23'\n            },\n            '3588674': {\n                'id': 3588674,\n                'name': 'harry',\n                'username': 'harry',\n                'state': 'active',\n                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',\n                'web_url': 'https://gitlab.com/harry',\n                'access_level': 30,  # Developer\n                'expires_at': '2030-02-23'\n            }\n        }\n    }\n    john_user_model = user_model('john', 3588673)\n    harry_user_model = user_model('harry', 3588674)\n    sheila_user_model = user_model('sheila', 3588675)\n\n    member_regex = re.compile(API_ENDPOINT + r'/projects/(.*)/members/all/(.*)')\n\n    def is_member(request):\n        urlinfo = urlparse(request.url)\n        project_id, uid = member_regex.match(urlinfo.path).group(1, 2)\n\n        if user_projects.get(project_id) and user_projects.get(project_id).get(uid):\n            res = user_projects.get(project_id).get(uid)\n            return HTTPResponse(request=request, code=200,\n                buffer=BytesIO(json.dumps(res).encode('utf8')),\n                headers={'Content-Type': 'application/json'},\n            )\n        else:\n            return HTTPResponse(request=request, code=404,\n                buffer=BytesIO(''.encode('utf8'))\n            )\n\n    client.hosts['gitlab.com'].append(\n        (member_regex, is_member)\n    )\n\n    authenticator.allowed_project_ids = [1231231]\n\n    # Forbidden since John has guest access\n    handler = client.handler_for_user(john_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    # Authenticated since Harry has developer access to the project\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'harry'\n\n    # Forbidden since Sheila doesn't have access to the project\n    handler = client.handler_for_user(sheila_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    authenticator.allowed_project_ids = [123123152543]\n\n    # Forbidden since the project does not exist.\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    assert user_info is None\n\n    authenticator.allowed_project_ids = [123123152543, 1231231]\n\n    # Authenticated since Harry has developer access to one of the project in the list\n    handler = client.handler_for_user(harry_user_model)\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'harry'\n\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GitLabOAuthenticator.gitlab_group_whitelist = {'red'}\n    cfg.GitLabOAuthenticator.whitelist = {\"blue\"}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GitLabOAuthenticator(config=cfg, log=log)\n    assert (\n        log.name,\n        logging.WARNING,\n        'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '\n        'GitLabOAuthenticator.allowed_gitlab_groups instead',\n    ) in caplog.record_tuples\n\n    assert authenticator.allowed_gitlab_groups == {'red'}\n    assert authenticator.allowed_users == {\"blue\"}\n", "import re\nfrom unittest.mock import Mock\n\nimport logging\nfrom pytest import fixture, mark, raises\nfrom tornado.web import Application, HTTPError\nfrom traitlets.config import Config\n\n\nfrom ..google import GoogleOAuthenticator\n\nfrom .mocks import setup_oauth_mock\n\n\ndef user_model(email):\n    \"\"\"Return a user model\"\"\"\n    return {'email': email, 'hd': email.split('@')[1], 'verified_email': True}\n\n\n@fixture\ndef google_client(client):\n    setup_oauth_mock(\n        client,\n        host=['accounts.google.com', 'www.googleapis.com'],\n        access_token_path=re.compile('^(/o/oauth2/token|/oauth2/v4/token)$'),\n        user_path='/oauth2/v1/userinfo',\n    )\n    return client\n\n\nasync def test_google(google_client):\n    authenticator = GoogleOAuthenticator()\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    assert sorted(user_info) == ['auth_state', 'name']\n    name = user_info['name']\n    assert name == 'fake@email.com'\n    auth_state = user_info['auth_state']\n    assert 'access_token' in auth_state\n    assert 'google_user' in auth_state\n\n\nasync def test_hosted_domain(google_client):\n    authenticator = GoogleOAuthenticator(hosted_domain=['email.com'])\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake'\n\n    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))\n    with raises(HTTPError) as exc:\n        name = await authenticator.authenticate(handler)\n    assert exc.value.status_code == 403\n\n\nasync def test_multiple_hosted_domain(google_client):\n    authenticator = GoogleOAuthenticator(hosted_domain=['email.com', 'mycollege.edu'])\n    handler = google_client.handler_for_user(user_model('fake@email.com'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake@email.com'\n\n    handler = google_client.handler_for_user(user_model('fake2@mycollege.edu'))\n    user_info = await authenticator.authenticate(handler)\n    name = user_info['name']\n    assert name == 'fake2@mycollege.edu'\n\n    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))\n    with raises(HTTPError) as exc:\n        name = await authenticator.authenticate(handler)\n    assert exc.value.status_code == 403\n\n\nasync def test_admin_google_groups(google_client):\n    authenticator = GoogleOAuthenticator(\n        hosted_domain=['email.com', 'mycollege.edu'],\n        admin_google_groups={'email.com': ['fakeadmingroup']},\n        allowed_google_groups={'email.com': ['fakegroup']}\n    )\n    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))\n    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])\n    admin_user = admin_user_info['admin']\n    assert admin_user == True\n    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))\n    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])\n    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']\n    admin_user = allowed_user_info['admin']\n    assert 'fakegroup' in allowed_user_groups\n    assert admin_user == False\n    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))\n    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])\n    assert allowed_user_groups is None\n\n\nasync def test_allowed_google_groups(google_client):\n    authenticator = GoogleOAuthenticator(\n        hosted_domain=['email.com', 'mycollege.edu'],\n        allowed_google_groups={'email.com': ['fakegroup']}\n    )\n    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))\n    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])\n    assert admin_user_info is None\n    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))\n    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])\n    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']\n    admin_field = allowed_user_info.get('admin')\n    assert 'fakegroup' in allowed_user_groups\n    assert admin_field is None\n    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))\n    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])\n    assert allowed_user_groups is None\n\n\ndef test_deprecated_config(caplog):\n    cfg = Config()\n    cfg.GoogleOAuthenticator.google_group_whitelist = {'email.com': ['group']}\n    cfg.Authenticator.whitelist = {\"user1\"}\n\n    log = logging.getLogger(\"testlog\")\n    authenticator = GoogleOAuthenticator(config=cfg, log=log)\n    assert (\n        log.name,\n        logging.WARNING,\n        'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '\n        'GoogleOAuthenticator.allowed_google_groups instead',\n    ) in caplog.record_tuples\n\n    assert authenticator.allowed_google_groups == {'email.com': ['group']}\n    assert authenticator.allowed_users == {\"user1\"}\n"], "filenames": ["docs/source/changelog.md", "oauthenticator/bitbucket.py", "oauthenticator/cilogon.py", "oauthenticator/github.py", "oauthenticator/gitlab.py", "oauthenticator/google.py", "oauthenticator/oauth2.py", "oauthenticator/tests/test_bitbucket.py", "oauthenticator/tests/test_github.py", "oauthenticator/tests/test_gitlab.py", "oauthenticator/tests/test_google.py"], "buggy_code_start_loc": [11, 31, 47, 40, 40, 33, 350, 88, 158, 262, 116], "buggy_code_end_loc": [11, 38, 54, 47, 48, 40, 368, 101, 171, 275, 129], "fixing_code_start_loc": [12, 31, 47, 40, 40, 33, 350, 89, 159, 263, 117], "fixing_code_end_loc": [16, 34, 50, 43, 44, 36, 378, 102, 172, 276, 130], "type": "CWE-863", "message": "OAuthenticator is an OAuth login mechanism for JupyterHub. In oauthenticator from version 0.12.0 and before 0.12.2, the deprecated (in jupyterhub 1.2) configuration `Authenticator.whitelist`, which should be transparently mapped to `Authenticator.allowed_users` with a warning, is instead ignored by OAuthenticator classes, resulting in the same behavior as if this configuration has not been set. If this is the only mechanism of authorization restriction (i.e. no group or team restrictions in configuration) then all authenticated users will be allowed. Provider-based restrictions, including deprecated values such as `GitHubOAuthenticator.org_whitelist` are **not** affected. All users of OAuthenticator 0.12.0 and 0.12.1 with JupyterHub 1.2 (JupyterHub Helm chart 0.10.0-0.10.5) who use the `admin.whitelist.users` configuration in the jupyterhub helm chart or the `c.Authenticator.whitelist` configuration directly. Users of other deprecated configuration, e.g. `c.GitHubOAuthenticator.team_whitelist` are **not** affected. If you see a log line like this and expect a specific list of allowed usernames: \"[I 2020-11-27 16:51:54.528 JupyterHub app:1717] Not using allowed_users. Any authenticated user will be allowed.\" you are likely affected. Updating oauthenticator to 0.12.2 is recommended. A workaround is to replace the deprecated `c.Authenticator.whitelist = ...` with `c.Authenticator.allowed_users = ...`. If any users have been authorized during this time who should not have been, they must be deleted via the API or admin interface, per the referenced documentation.", "other": {"cve": {"id": "CVE-2020-26250", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-01T21:15:14.317", "lastModified": "2020-12-08T17:50:24.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OAuthenticator is an OAuth login mechanism for JupyterHub. In oauthenticator from version 0.12.0 and before 0.12.2, the deprecated (in jupyterhub 1.2) configuration `Authenticator.whitelist`, which should be transparently mapped to `Authenticator.allowed_users` with a warning, is instead ignored by OAuthenticator classes, resulting in the same behavior as if this configuration has not been set. If this is the only mechanism of authorization restriction (i.e. no group or team restrictions in configuration) then all authenticated users will be allowed. Provider-based restrictions, including deprecated values such as `GitHubOAuthenticator.org_whitelist` are **not** affected. All users of OAuthenticator 0.12.0 and 0.12.1 with JupyterHub 1.2 (JupyterHub Helm chart 0.10.0-0.10.5) who use the `admin.whitelist.users` configuration in the jupyterhub helm chart or the `c.Authenticator.whitelist` configuration directly. Users of other deprecated configuration, e.g. `c.GitHubOAuthenticator.team_whitelist` are **not** affected. If you see a log line like this and expect a specific list of allowed usernames: \"[I 2020-11-27 16:51:54.528 JupyterHub app:1717] Not using allowed_users. Any authenticated user will be allowed.\" you are likely affected. Updating oauthenticator to 0.12.2 is recommended. A workaround is to replace the deprecated `c.Authenticator.whitelist = ...` with `c.Authenticator.allowed_users = ...`. If any users have been authorized during this time who should not have been, they must be deleted via the API or admin interface, per the referenced documentation."}, {"lang": "es", "value": "OAuthenticator es un mecanismo de inicio de sesi\u00f3n de OAuth para JupyterHub.&#xa0;En oauthenticator desde la versi\u00f3n 0.12.0 y versiones anteriores a 0.12.2, la configuraci\u00f3n obsoleta (en jupyterhub versi\u00f3n 1.2) \"Authenticator.whitelist\", que debe asignarse de forma transparente a \"Authenticator.allowed_users\" con una advertencia, es ignorada por las clases OAuthenticator, resultando en el mismo comportamiento como si no se hubiera establecido esta configuraci\u00f3n.&#xa0;Si este es el \u00fanico mecanismo de restricci\u00f3n de autorizaci\u00f3n (es decir, sin restricciones de grupo o equipo en la configuraci\u00f3n), se permitir\u00e1n todos los usuarios autenticados.&#xa0;Las restricciones basadas en el proveedor, incluidos los valores obsoletos como \"GitHubOAuthenticator.org_whitelist\" **no** est\u00e1n afectados.&#xa0;Todos los usuarios de OAuthenticator versiones 0.12.0 y 0.12.1 con JupyterHub versi\u00f3n 1.2 (gr\u00e1fico JupyterHub Helm versiones 0.10.0-0.10.5) que usan la configuraci\u00f3n \"admin.whitelist.users\" en el gr\u00e1fico de helm jupyterhub o directamente la configuraci\u00f3n \"c.Authenticator.whitelist\".&#xa0;Los usuarios de otra configuraci\u00f3n obsoleta, por ejemplo, \"c.GitHubOAuthenticator.team_whitelist\" **no** se est\u00e1n afectados.&#xa0;Si ve una l\u00ednea de registro como esta y espera una lista espec\u00edfica de nombres de usuario permitidos: \"[I 2020-11-27 16: 51:54.528 aplicaci\u00f3n JupyterHub:1717] Sin usar allowed_users. Se permitir\u00e1 cualquier usuario autenticado\"&#xa0;es probable que est\u00e9 afectado.&#xa0;Se recomienda actualizar oauthenticator a la versi\u00f3n 0.12.2.&#xa0;Una soluci\u00f3n alternativa es reemplazar el obsoleto \"c.Authenticator.whitelist = ...\" con \"c.Authenticator.allowed_users = ...\".&#xa0;Si algunos usuarios has sido autorizados durante este tiempo que no deber\u00eda haberlo sido, se debe eliminar por medio de la API o la interfaz de administraci\u00f3n, seg\u00fan la documentaci\u00f3n de referencia"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.12.0", "versionEndExcluding": "0.12.2", "matchCriteriaId": "B843F30F-EB2C-4C27-8CB8-7DEF4FDA3B0A"}]}]}], "references": [{"url": "https://github.com/jupyterhub/oauthenticator/blob/master/docs/source/changelog.md#0122---2020-11-30", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/oauthenticator/commit/a4aac191c16cf6281f3d346615aefa75702b02d7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/oauthenticator/security/advisories/GHSA-384w-5v3f-q499", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jupyterhub.readthedocs.io/en/1.2.2/getting-started/authenticators-users-basics.html#add-or-remove-users-from-the-hub", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyterhub/oauthenticator/commit/a4aac191c16cf6281f3d346615aefa75702b02d7"}}