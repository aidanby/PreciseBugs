{"buggy_code": ["/**********************************************************************\n  regparse.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n#include \"st.h\"\n\n#ifdef DEBUG_NODE_FREE\n#include <stdio.h>\n#endif\n\n#define INIT_TAG_NAMES_ALLOC_NUM   5\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n#define IS_ALLOWED_CODE_IN_CALLOUT_NAME(c) \\\n  ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_' /* || c == '!' */)\n#define IS_ALLOWED_CODE_IN_CALLOUT_TAG_NAME(c) \\\n  ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')\n\n\nOnigSyntaxType OnigSyntaxOniguruma = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_ONIGURUMA |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP |\n      ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS |\n      ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME    |\n      ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE |\n      ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT | ONIG_SYN_OP2_ESC_U_HEX4 )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP |\n      ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT | ONIG_SYN_OP2_ESC_U_HEX4 )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_ONIGURUMA;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nextern void\nonig_warning(const char* s)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  (*onig_warn)(s);\n}\n\n#define DEFAULT_MAX_CAPTURE_NUM   32767\n\nstatic int MaxCaptureNum = DEFAULT_MAX_CAPTURE_NUM;\n\nextern int\nonig_set_capture_num_limit(int num)\n{\n  if (num < 0) return -1;\n\n  MaxCaptureNum = num;\n  return 0;\n}\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\nstatic int\nbbuf_init(BBuf* buf, int size)\n{\n  if (size <= 0) {\n    size   = 0;\n    buf->p = NULL;\n  }\n  else {\n    buf->p = (UChar* )xmalloc(size);\n    if (IS_NULL(buf->p)) return(ONIGERR_MEMORY);\n  }\n\n  buf->alloc = size;\n  buf->used  = 0;\n  return 0;\n}\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\nstatic int backref_rel_to_abs(int rel_no, ScanEnv* env)\n{\n  if (rel_no > 0) {\n    return env->num_mem + rel_no;\n  }\n  else {\n    return env->num_mem + 1 + rel_no;\n  }\n}\n\n#define OPTION_ON(v,f)     ((v) |= (f))\n#define OPTION_OFF(v,f)    ((v) &= ~(f))\n\n#define OPTION_NEGATE(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, MBCODE_START_POS(enc), ~((OnigCodePoint )0))\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r != 0) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  int len = (int )(end - src);\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\nstatic int\nsave_entry(ScanEnv* env, enum SaveType type, int* id)\n{\n  int nid = env->save_num;\n\n#if 0\n  if (IS_NULL(env->saves)) {\n    int n = 10;\n    env->saves = (SaveItem* )xmalloc(sizeof(SaveItem) * n);\n    CHECK_NULL_RETURN_MEMERR(env->saves);\n    env->save_alloc_num = n;\n  }\n  else if (env->save_alloc_num <= nid) {\n    int n = env->save_alloc_num * 2;\n    SaveItem* p = (SaveItem* )xrealloc(env->saves, sizeof(SaveItem) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    env->saves = p;\n    env->save_alloc_num = n;\n  }\n\n  env->saves[nid].type = type;\n#endif\n\n  env->save_num++;\n  *id = nid;\n  return 0;\n}\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#define PFETCH_READY  UChar* pfetch_prev\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n            int capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n                        const UChar* src, const UChar* src_end, int capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\ntypedef struct {\n  UChar* s;\n  UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_str_end_key* x, st_str_end_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\nstr_end_hash(st_str_end_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n                      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n                      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  CHECK_NULL_RETURN_MEMERR(key);\n\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n\n#ifdef USE_CALLOUT\n\ntypedef struct {\n  OnigEncoding enc;\n  int    type; /* callout type: single or not */\n  UChar* s;\n  UChar* end;\n} st_callout_name_key;\n\nstatic int\ncallout_name_table_cmp(st_callout_name_key* x, st_callout_name_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if (x->enc  != y->enc)  return 1;\n  if (x->type != y->type) return 1;\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\ncallout_name_table_hash(st_callout_name_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  /* use intptr_t for escape warning in Windows */\n  return val + (val >> 5) + ((intptr_t )x->enc & 0xffff) + x->type;\n}\n\nextern hash_table_type*\nonig_st_init_callout_name_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    callout_name_table_cmp,\n    callout_name_table_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_callout_name_table(hash_table_type* table,\n                                  OnigEncoding enc,\n                                  int type,\n                                  const UChar* str_key,\n                                  const UChar* end_key,\n                                  hash_data_type *value)\n{\n  st_callout_name_key key;\n\n  key.enc  = enc;\n  key.type = type;\n  key.s    = (UChar* )str_key;\n  key.end  = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nstatic int\nst_insert_callout_name_table(hash_table_type* table,\n                             OnigEncoding enc, int type,\n                             UChar* str_key, UChar* end_key,\n                             hash_data_type value)\n{\n  st_callout_name_key* key;\n  int result;\n\n  key = (st_callout_name_key* )xmalloc(sizeof(st_callout_name_key));\n  CHECK_NULL_RETURN_MEMERR(key);\n\n  /* key->s: don't duplicate, because str_key is duped in callout_name_entry() */\n  key->enc  = enc;\n  key->type = type;\n  key->s    = str_key;\n  key->end  = end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n#endif\n\n#endif /* USE_ST_LIBRARY */\n\n\n#define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n#ifdef USE_ST_LIBRARY\n\n#define INIT_NAMES_ALLOC_NUM    5\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#define NAMEBUF_SIZE    24\n#define NAMEBUF_SIZE_1  25\n\n#ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r != 0) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n                         e->name + e->name_len,\n                         e->back_num,\n                         (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                         arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num_entries;\n  else\n    return 0;\n}\n\n#else  /* USE_ST_LIBRARY */\n\n#define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n        fputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n        fprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n        for (j = 0; j < e->back_num; j++) {\n          if (j > 0) fprintf(fp, \", \");\n          fprintf(fp, \"%d\", e->back_refs[j]);\n        }\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name       = NULL;\n        e->name_len   = 0;\n        e->back_num   = 0;\n        e->back_alloc = 0;\n        if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n        e->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r != 0) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, UChar* name, UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n                  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n#endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int r;\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(INIT_NAMES_ALLOC_NUM);\n      CHECK_NULL_RETURN_MEMERR(t);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = onigenc_strdup(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n    r = onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                              (HashDataType )e);\n    if (r < 0) return r;\n\n    e->name_len   = (int )(name_end - name);\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n#else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].back_num   = 0;\n        t->e[i].back_alloc = 0;\n        t->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = onigenc_strdup(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n#endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n                                   name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n        alloc = e->back_alloc * 2;\n        e->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n        CHECK_NULL_RETURN_MEMERR(e->back_refs);\n        e->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n                           const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n                            const UChar* name_end, OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n        if (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n          return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\nextern int\nonig_noname_group_capture_is_active(regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n\n  return 1;\n}\n\n#ifdef USE_CALLOUT\n\ntypedef struct {\n  OnigCalloutType type;\n  int             in;\n  OnigCalloutFunc start_func;\n  OnigCalloutFunc end_func;\n  int             arg_num;\n  int             opt_arg_num;\n  unsigned int    arg_types[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigValue       opt_defaults[ONIG_CALLOUT_MAX_ARGS_NUM];\n  UChar*          name; /* reference to GlobalCalloutNameTable entry: e->name */\n} CalloutNameListEntry;\n\ntypedef struct {\n  int  n;\n  int  alloc;\n  CalloutNameListEntry* v;\n} CalloutNameListType;\n\nstatic CalloutNameListType* GlobalCalloutNameList;\n\nstatic int\nmake_callout_func_list(CalloutNameListType** rs, int init_size)\n{\n  CalloutNameListType* s;\n  CalloutNameListEntry* v;\n\n  *rs = 0;\n\n  s = xmalloc(sizeof(*s));\n  if (IS_NULL(s)) return ONIGERR_MEMORY;\n\n  v = (CalloutNameListEntry* )xmalloc(sizeof(CalloutNameListEntry) * init_size);\n  if (IS_NULL(v)) {\n    xfree(s);\n    return ONIGERR_MEMORY;\n  }\n\n  s->n = 0;\n  s->alloc = init_size;\n  s->v = v;\n\n  *rs = s;\n  return ONIG_NORMAL;\n}\n\nstatic void\nfree_callout_func_list(CalloutNameListType* s)\n{\n  if (IS_NOT_NULL(s)) {\n    if (IS_NOT_NULL(s->v)) {\n      int i, j;\n\n      for (i = 0; i < s->n; i++) {\n        CalloutNameListEntry* e = s->v + i;\n        for (j = e->arg_num - e->opt_arg_num; j < e->arg_num; j++) {\n          if (e->arg_types[j] == ONIG_TYPE_STRING) {\n            UChar* p = e->opt_defaults[j].s.start;\n            if (IS_NOT_NULL(p)) xfree(p);\n          }\n        }\n      }\n      xfree(s->v);\n    }\n    xfree(s);\n  }\n}\n\nstatic int\ncallout_func_list_add(CalloutNameListType* s, int* rid)\n{\n  if (s->n >= s->alloc) {\n    int new_size = s->alloc * 2;\n    CalloutNameListEntry* nv = (CalloutNameListEntry* )\n      xrealloc(s->v, sizeof(CalloutNameListEntry) * new_size);\n    if (IS_NULL(nv)) return ONIGERR_MEMORY;\n\n    s->alloc = new_size;\n    s->v = nv;\n  }\n\n  *rid = s->n;\n\n  xmemset(&(s->v[s->n]), 0, sizeof(*(s->v)));\n  s->n++;\n  return ONIG_NORMAL;\n}\n\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    id;\n} CalloutNameEntry;\n\n#ifdef USE_ST_LIBRARY\ntypedef st_table  CalloutNameTable;\n#else\ntypedef struct {\n  CalloutNameEntry* e;\n  int               num;\n  int               alloc;\n} CalloutNameTable;\n#endif\n\nstatic CalloutNameTable* GlobalCalloutNameTable;\nstatic int CalloutNameIDCounter;\n\n#ifdef USE_ST_LIBRARY\n\nstatic int\ni_free_callout_name_entry(st_callout_name_key* key, CalloutNameEntry* e,\n                          void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  /*xfree(key->s); */ /* is same as e->name */\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\ncallout_name_table_clear(CalloutNameTable* t)\n{\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_callout_name_entry, 0);\n  }\n  return 0;\n}\n\nstatic int\nglobal_callout_name_table_free(void)\n{\n  if (IS_NOT_NULL(GlobalCalloutNameTable)) {\n    int r = callout_name_table_clear(GlobalCalloutNameTable);\n    if (r != 0) return r;\n\n    onig_st_free_table(GlobalCalloutNameTable);\n    GlobalCalloutNameTable = 0;\n    CalloutNameIDCounter = 0;\n  }\n\n  return 0;\n}\n\nstatic CalloutNameEntry*\ncallout_name_find(OnigEncoding enc, int is_not_single,\n                  const UChar* name, const UChar* name_end)\n{\n  int r;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = GlobalCalloutNameTable;\n\n  e = (CalloutNameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    r = onig_st_lookup_callout_name_table(t, enc, is_not_single, name, name_end,\n                                          (HashDataType* )((void* )(&e)));\n    if (r == 0) { /* not found */\n      if (enc != ONIG_ENCODING_ASCII &&\n          ONIGENC_IS_ASCII_COMPATIBLE_ENCODING(enc)) {\n        enc = ONIG_ENCODING_ASCII;\n        onig_st_lookup_callout_name_table(t, enc, is_not_single, name, name_end,\n                                          (HashDataType* )((void* )(&e)));\n      }\n    }\n  }\n  return e;\n}\n\n#else\n\nstatic int\ncallout_name_table_clear(CalloutNameTable* t)\n{\n  int i;\n  CalloutNameEntry* e;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name     = NULL;\n        e->name_len = 0;\n        e->id       = 0;\n        e->func     = 0;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nstatic int\nglobal_callout_name_table_free(void)\n{\n  if (IS_NOT_NULL(GlobalCalloutNameTable)) {\n    int r = callout_name_table_clear(GlobalCalloutNameTable);\n    if (r != 0) return r;\n\n    xfree(GlobalCalloutNameTable);\n    GlobalCalloutNameTable = 0;\n    CalloutNameIDCounter = 0;\n  }\n  return 0;\n}\n\nstatic CalloutNameEntry*\ncallout_name_find(UChar* name, UChar* name_end)\n{\n  int i, len;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = Calloutnames;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (CalloutNameEntry* )NULL;\n}\n\n#endif\n\n/* name string must be single byte char string. */\nstatic int\ncallout_name_entry(CalloutNameEntry** rentry, OnigEncoding enc,\n                   int is_not_single, UChar* name, UChar* name_end)\n{\n  int r;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = GlobalCalloutNameTable;\n\n  *rentry = 0;\n  if (name_end - name <= 0)\n    return ONIGERR_INVALID_CALLOUT_NAME;\n\n  e = callout_name_find(enc, is_not_single, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_callout_name_table_with_size(INIT_NAMES_ALLOC_NUM);\n      CHECK_NULL_RETURN_MEMERR(t);\n      GlobalCalloutNameTable = t;\n    }\n    e = (CalloutNameEntry* )xmalloc(sizeof(CalloutNameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = onigenc_strdup(enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n\n    r = st_insert_callout_name_table(t, enc, is_not_single,\n                                     e->name, (e->name + (name_end - name)),\n                                     (HashDataType )e);\n    if (r < 0) return r;\n\n#else\n\n    int alloc;\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (CalloutNameTable* )xmalloc(sizeof(CalloutNameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (CalloutNameEntry* )xmalloc(sizeof(CalloutNameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      GlobalCalloutNameTable = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (CalloutNameEntry* )xrealloc(t->e, sizeof(CalloutNameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].id         = 0;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = onigenc_strdup(enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n#endif\n\n    CalloutNameIDCounter++;\n    e->id = CalloutNameIDCounter;\n    e->name_len = (int )(name_end - name);\n  }\n\n  *rentry = e;\n  return e->id;\n}\n\nstatic int\nis_allowed_callout_name(OnigEncoding enc, UChar* name, UChar* name_end)\n{\n  UChar* p;\n  OnigCodePoint c;\n\n  if (name >= name_end) return 0;\n\n  p = name;\n  while (p < name_end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, name_end);\n    if (! IS_ALLOWED_CODE_IN_CALLOUT_NAME(c))\n      return 0;\n\n    if (p == name) {\n      if (c >= '0' && c <= '9') return 0;\n    }\n\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n  }\n\n  return 1;\n}\n\nstatic int\nis_allowed_callout_tag_name(OnigEncoding enc, UChar* name, UChar* name_end)\n{\n  UChar* p;\n  OnigCodePoint c;\n\n  if (name >= name_end) return 0;\n\n  p = name;\n  while (p < name_end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, name_end);\n    if (! IS_ALLOWED_CODE_IN_CALLOUT_TAG_NAME(c))\n      return 0;\n\n    if (p == name) {\n      if (c >= '0' && c <= '9') return 0;\n    }\n\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n  }\n\n  return 1;\n}\n\nextern int\nonig_set_callout_of_name(OnigEncoding enc, OnigCalloutType callout_type,\n                         UChar* name, UChar* name_end, int in,\n                         OnigCalloutFunc start_func,\n                         OnigCalloutFunc end_func,\n                         int arg_num, unsigned int arg_types[],\n                         int opt_arg_num, OnigValue opt_defaults[])\n{\n  int r;\n  int i;\n  int j;\n  int id;\n  int is_not_single;\n  CalloutNameEntry* e;\n  CalloutNameListEntry* fe;\n\n  if (callout_type != ONIG_CALLOUT_TYPE_SINGLE)\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (arg_num < 0 || arg_num > ONIG_CALLOUT_MAX_ARGS_NUM)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (opt_arg_num < 0 || opt_arg_num > arg_num)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (start_func == 0 && end_func == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if ((in & ONIG_CALLOUT_IN_PROGRESS) == 0 && (in & ONIG_CALLOUT_IN_RETRACTION) == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  for (i = 0; i < arg_num; i++) {\n    unsigned int t = arg_types[i];\n    if (t == ONIG_TYPE_VOID)\n      return ONIGERR_INVALID_CALLOUT_ARG;\n    else {\n      if (i >= arg_num - opt_arg_num) {\n        if (t != ONIG_TYPE_LONG && t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING &&\n            t != ONIG_TYPE_TAG)\n          return ONIGERR_INVALID_CALLOUT_ARG;\n      }\n      else {\n        if (t != ONIG_TYPE_LONG) {\n          t = t & ~ONIG_TYPE_LONG;\n          if (t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING && t != ONIG_TYPE_TAG)\n            return ONIGERR_INVALID_CALLOUT_ARG;\n        }\n      }\n    }\n  }\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  is_not_single = (callout_type != ONIG_CALLOUT_TYPE_SINGLE);\n  id = callout_name_entry(&e, enc, is_not_single, name, name_end);\n  if (id < 0) return id;\n\n  r = ONIG_NORMAL;\n  if (IS_NULL(GlobalCalloutNameList)) {\n    r = make_callout_func_list(&GlobalCalloutNameList, 10);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  while (id >= GlobalCalloutNameList->n) {\n    int rid;\n    r = callout_func_list_add(GlobalCalloutNameList, &rid);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  fe = GlobalCalloutNameList->v + id;\n  fe->type         = callout_type;\n  fe->in           = in;\n  fe->start_func   = start_func;\n  fe->end_func     = end_func;\n  fe->arg_num      = arg_num;\n  fe->opt_arg_num  = opt_arg_num;\n  fe->name         = e->name;\n\n  for (i = 0; i < arg_num; i++) {\n    fe->arg_types[i] = arg_types[i];\n  }\n  for (i = arg_num - opt_arg_num, j = 0; i < arg_num; i++, j++) {\n    if (fe->arg_types[i] == ONIG_TYPE_STRING) {\n      OnigValue* val;\n      UChar* ds;\n\n      if (IS_NULL(opt_defaults)) return ONIGERR_INVALID_ARGUMENT;\n\n      val = opt_defaults + j;\n      ds = onigenc_strdup(enc, val->s.start, val->s.end);\n      CHECK_NULL_RETURN_MEMERR(ds);\n\n      fe->opt_defaults[i].s.start = ds;\n      fe->opt_defaults[i].s.end   = ds + (val->s.end - val->s.start);\n    }\n    else {\n      fe->opt_defaults[i] = opt_defaults[j];\n    }\n  }\n\n  r = id;\n  return r;\n}\n\nstatic int\nget_callout_name_id_by_name(OnigEncoding enc, int is_not_single,\n                            UChar* name, UChar* name_end, int* rid)\n{\n  int r;\n  CalloutNameEntry* e;\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  e = callout_name_find(enc, is_not_single, name, name_end);\n  if (IS_NULL(e)) {\n    return ONIGERR_UNDEFINED_CALLOUT_NAME;\n  }\n\n  r = ONIG_NORMAL;\n  *rid = e->id;\n\n  return r;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_start_func(regex_t* reg, int callout_num)\n{\n  /* If used for callouts of contents, return 0. */\n  CalloutListEntry* e;\n\n  e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->start_func;\n}\n\nextern const UChar*\nonig_get_callout_tag_start(regex_t* reg, int callout_num)\n{\n  CalloutListEntry* e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->tag_start;\n}\n\nextern const UChar*\nonig_get_callout_tag_end(regex_t* reg, int callout_num)\n{\n  CalloutListEntry* e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->tag_end;\n}\n\n\nextern OnigCalloutType\nonig_get_callout_type_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].type;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_start_func_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].start_func;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_end_func_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].end_func;\n}\n\nextern int\nonig_get_callout_in_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].in;\n}\n\nstatic int\nget_callout_arg_num_by_name_id(int name_id)\n{\n  return GlobalCalloutNameList->v[name_id].arg_num;\n}\n\nstatic int\nget_callout_opt_arg_num_by_name_id(int name_id)\n{\n  return GlobalCalloutNameList->v[name_id].opt_arg_num;\n}\n\nstatic unsigned int\nget_callout_arg_type_by_name_id(int name_id, int index)\n{\n  return GlobalCalloutNameList->v[name_id].arg_types[index];\n}\n\nstatic OnigValue\nget_callout_opt_default_by_name_id(int name_id, int index)\n{\n  return GlobalCalloutNameList->v[name_id].opt_defaults[index];\n}\n\nextern UChar*\nonig_get_callout_name_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].name;\n}\n\nextern int\nonig_global_callout_names_free(void)\n{\n  free_callout_func_list(GlobalCalloutNameList);\n  GlobalCalloutNameList = 0;\n\n  global_callout_name_table_free();\n  return ONIG_NORMAL;\n}\n\n\ntypedef st_table   CalloutTagTable;\ntypedef intptr_t   CalloutTagVal;\n\n#define CALLOUT_TAG_LIST_FLAG_TAG_EXIST     (1<<0)\n\nstatic int\ni_callout_callout_list_set(UChar* key, CalloutTagVal e, void* arg)\n{\n  int num;\n  RegexExt* ext = (RegexExt* )arg;\n\n  num = (int )e - 1;\n  ext->callout_list[num].flag |= CALLOUT_TAG_LIST_FLAG_TAG_EXIST;\n  return ST_CONTINUE;\n}\n\nstatic int\nsetup_ext_callout_list_values(regex_t* reg)\n{\n  int i, j;\n  RegexExt* ext;\n\n  ext = reg->extp;\n  if (IS_NOT_NULL(ext->tag_table)) {\n    onig_st_foreach((CalloutTagTable *)ext->tag_table, i_callout_callout_list_set,\n                    (st_data_t )ext);\n  }\n\n  for (i = 0; i < ext->callout_num; i++) {\n    CalloutListEntry* e = ext->callout_list + i;\n    if (e->of == ONIG_CALLOUT_OF_NAME) {\n      for (j = 0; j < e->u.arg.num; j++) {\n        if (e->u.arg.types[j] == ONIG_TYPE_TAG) {\n          UChar* start;\n          UChar* end;\n          int num;\n          start = e->u.arg.vals[j].s.start;\n          end   = e->u.arg.vals[j].s.end;\n          num = onig_get_callout_num_by_tag(reg, start, end);\n          if (num < 0) return num;\n          e->u.arg.vals[j].tag = num;\n        }\n      }\n    }\n  }\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)\n{\n  RegexExt* ext = reg->extp;\n\n  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;\n  if (callout_num > ext->callout_num) return 0;\n\n  return (ext->callout_list[callout_num].flag &\n          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0;\n}\n\nstatic int\ni_free_callout_tag_entry(UChar* key, CalloutTagVal e, void* arg ARG_UNUSED)\n{\n  xfree(key);\n  return ST_DELETE;\n}\n\nstatic int\ncallout_tag_table_clear(CalloutTagTable* t)\n{\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_callout_tag_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_callout_tag_table_free(void* table)\n{\n  CalloutTagTable* t = (CalloutTagTable* )table;\n\n  if (IS_NOT_NULL(t)) {\n    int r = callout_tag_table_clear(t);\n    if (r != 0) return r;\n\n    onig_st_free_table(t);\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_callout_num_by_tag(regex_t* reg,\n                            const UChar* tag, const UChar* tag_end)\n{\n  int r;\n  RegexExt* ext;\n  CalloutTagVal e;\n\n  ext = reg->extp;\n  if (IS_NULL(ext) || IS_NULL(ext->tag_table))\n    return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  r = onig_st_lookup_strend(ext->tag_table, tag, tag_end,\n                            (HashDataType* )((void* )(&e)));\n  if (r == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n  return (int )e;\n}\n\nstatic CalloutTagVal\ncallout_tag_find(CalloutTagTable* t, const UChar* name, const UChar* name_end)\n{\n  CalloutTagVal e;\n\n  e = -1;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\nstatic int\ncallout_tag_table_new(CalloutTagTable** rt)\n{\n  CalloutTagTable* t;\n\n  *rt = 0;\n  t = onig_st_init_strend_table_with_size(INIT_TAG_NAMES_ALLOC_NUM);\n  CHECK_NULL_RETURN_MEMERR(t);\n\n  *rt = t;\n  return ONIG_NORMAL;\n}\n\nstatic int\ncallout_tag_entry_raw(CalloutTagTable* t, UChar* name, UChar* name_end,\n                      CalloutTagVal entry_val)\n{\n  int r;\n  CalloutTagVal val;\n\n  if (name_end - name <= 0)\n    return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  val = callout_tag_find(t, name, name_end);\n  if (val >= 0)\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n\n  r = onig_st_insert_strend(t, name, name_end, (HashDataType )entry_val);\n  if (r < 0) return r;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\next_ensure_tag_table(regex_t* reg)\n{\n  int r;\n  RegexExt* ext;\n  CalloutTagTable* t;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  if (IS_NULL(ext->tag_table)) {\n    r = callout_tag_table_new(&t);\n    if (r != ONIG_NORMAL) return r;\n\n    ext->tag_table = t;\n  }\n\n  return ONIG_NORMAL;\n}\n\nstatic int\ncallout_tag_entry(regex_t* reg, UChar* name, UChar* name_end,\n                  CalloutTagVal entry_val)\n{\n  int r;\n  RegexExt* ext;\n  CalloutListEntry* e;\n\n  r = ext_ensure_tag_table(reg);\n  if (r != ONIG_NORMAL) return r;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  r = callout_tag_entry_raw(ext->tag_table, name, name_end, entry_val);\n\n  e = onig_reg_callout_list_at(reg, (int )entry_val);\n  CHECK_NULL_RETURN_MEMERR(e);\n  e->tag_start = name;\n  e->tag_end   = name_end;\n\n  return r;\n}\n\n#endif /* USE_CALLOUT */\n\n\n#define INIT_SCANENV_MEMENV_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  MEM_STATUS_CLEAR(env->capture_history);\n  MEM_STATUS_CLEAR(env->bt_mem_start);\n  MEM_STATUS_CLEAR(env->bt_mem_end);\n  MEM_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n\n#ifdef USE_CALL\n  env->unset_addr_list = NULL;\n  env->has_call_zero   = 0;\n#endif\n\n  env->num_mem    = 0;\n  env->num_named  = 0;\n  env->mem_alloc  = 0;\n  env->mem_env_dynamic = (MemEnv* )NULL;\n\n  xmemset(env->mem_env_static, 0, sizeof(env->mem_env_static));\n\n  env->parse_depth         = 0;\n  env->keep_num            = 0;\n  env->save_num            = 0;\n  env->save_alloc_num      = 0;\n  env->saves               = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  MemEnv* p;\n\n  need = env->num_mem + 1;\n  if (need > MaxCaptureNum && MaxCaptureNum != 0)\n    return ONIGERR_TOO_MANY_CAPTURES;\n\n  if (need >= SCANENV_MEMENV_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_env_dynamic)) {\n        alloc = INIT_SCANENV_MEMENV_ALLOC_SIZE;\n        p = (MemEnv* )xmalloc(sizeof(MemEnv) * alloc);\n        CHECK_NULL_RETURN_MEMERR(p);\n        xmemcpy(p, env->mem_env_static, sizeof(env->mem_env_static));\n      }\n      else {\n        alloc = env->mem_alloc * 2;\n        p = (MemEnv* )xrealloc(env->mem_env_dynamic, sizeof(MemEnv) * alloc);\n        CHECK_NULL_RETURN_MEMERR(p);\n      }\n\n      for (i = env->num_mem + 1; i < alloc; i++) {\n        p[i].node = NULL_NODE;\n#if 0\n        p[i].in   = 0;\n        p[i].recursion = 0;\n#endif\n      }\n\n      env->mem_env_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEMENV(env)[num].node = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"onig_node_free: %p\\n\", node);\n#endif\n\n  switch (NODE_TYPE(node)) {\n  case NODE_STRING:\n    if (STR_(node)->capacity != 0 &&\n        IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n      xfree(STR_(node)->s);\n    }\n    break;\n\n  case NODE_LIST:\n  case NODE_ALT:\n    onig_node_free(NODE_CAR(node));\n    {\n      Node* next_node = NODE_CDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      CClassNode* cc = CCLASS_(node);\n\n      if (cc->mbuf)\n        bbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NODE_BACKREF:\n    if (IS_NOT_NULL(BACKREF_(node)->back_dynamic))\n      xfree(BACKREF_(node)->back_dynamic);\n    break;\n\n  case NODE_BAG:\n    if (NODE_BODY(node))\n      onig_node_free(NODE_BODY(node));\n\n    {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_IF_ELSE) {\n        onig_node_free(en->te.Then);\n        onig_node_free(en->te.Else);\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n  case NODE_ANCHOR:\n    if (NODE_BODY(node))\n      onig_node_free(NODE_BODY(node));\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CALL:\n  case NODE_GIMMICK:\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic void\ncons_node_free_alone(Node* node)\n{\n  NODE_CAR(node) = 0;\n  NODE_CDR(node) = 0;\n  onig_node_free(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  CHECK_NULL_RETURN(node);\n  xmemset(node, 0, sizeof(*node));\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}\n\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CCLASS);\n  initialize_cclass(CCLASS_(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not, OnigOptionType options)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CTYPE);\n  CTYPE_(node)->ctype   = type;\n  CTYPE_(node)->not     = not;\n  CTYPE_(node)->options = options;\n  CTYPE_(node)->ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(type, options);\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}\n\nstatic Node*\nnode_new_anychar_with_fixed_option(OnigOptionType option)\n{\n  CtypeNode* ct;\n  Node* node;\n\n  node = node_new_anychar();\n  CHECK_NULL_RETURN(node);\n\n  ct = CTYPE_(node);\n  ct->options = option;\n  NODE_STATUS_ADD(node, FIXED_OPTION);\n  return node;\n}\n\nstatic int\nnode_new_no_newline(Node** node, ScanEnv* env)\n{\n  Node* n;\n\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_NONE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}\n\nstatic int\nnode_new_true_anychar(Node** node, ScanEnv* env)\n{\n  Node* n;\n\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_MULTILINE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_LIST);\n  NODE_CAR(node)  = left;\n  NODE_CDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NODE_CDR(list)))\n      list = NODE_CDR(list);\n\n    NODE_CDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_ALT);\n  NODE_CAR(node)  = left;\n  NODE_CDR(node) = right;\n  return node;\n}\n\nstatic Node*\nmake_list_or_alt(NodeType type, int n, Node* ns[])\n{\n  Node* r;\n\n  if (n <= 0) return NULL_NODE;\n\n  if (n == 1) {\n    r = node_new();\n    CHECK_NULL_RETURN(r);\n    NODE_SET_TYPE(r, type);\n    NODE_CAR(r) = ns[0];\n    NODE_CDR(r) = NULL_NODE;\n  }\n  else {\n    Node* right;\n\n    r = node_new();\n    CHECK_NULL_RETURN(r);\n\n    right = make_list_or_alt(type, n - 1, ns + 1);\n    if (IS_NULL(right)) {\n      onig_node_free(r);\n      return NULL_NODE;\n    }\n\n    NODE_SET_TYPE(r, type);\n    NODE_CAR(r) = ns[0];\n    NODE_CDR(r) = right;\n  }\n\n  return r;\n}\n\nstatic Node*\nmake_list(int n, Node* ns[])\n{\n  return make_list_or_alt(NODE_LIST, n, ns);\n}\n\nstatic Node*\nmake_alt(int n, Node* ns[])\n{\n  return make_list_or_alt(NODE_ALT, n, ns);\n}\n\nextern Node*\nonig_node_new_anchor(int type, int ascii_mode)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_ANCHOR);\n  ANCHOR_(node)->type       = type;\n  ANCHOR_(node)->char_len   = -1;\n  ANCHOR_(node)->ascii_mode = ascii_mode;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                 int exist_level, int nest_level,\n#endif\n                 ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_BACKREF);\n  BACKREF_(node)->back_num = back_num;\n  BACKREF_(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NODE_STATUS_ADD(node, BY_NAME);\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NODE_STATUS_ADD(node, NEST_LEVEL);\n    BACKREF_(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n        IS_NULL(SCANENV_MEMENV(env)[backrefs[i]].node)) {\n      NODE_STATUS_ADD(node, RECURSION);   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      BACKREF_(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    BACKREF_(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\nstatic Node*\nnode_new_backref_checker(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                         int exist_level, int nest_level,\n#endif\n                         ScanEnv* env)\n{\n  Node* node;\n\n  node = node_new_backref(back_num, backrefs, by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                          exist_level, nest_level,\n#endif\n                          env);\n  CHECK_NULL_RETURN(node);\n\n  NODE_STATUS_ADD(node, CHECKER);\n  return node;\n}\n\n#ifdef USE_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CALL);\n  CALL_(node)->by_number   = by_number;\n  CALL_(node)->name        = name;\n  CALL_(node)->name_end    = name_end;\n  CALL_(node)->group_num   = gnum;\n  CALL_(node)->entry_count = 1;\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_QUANT);\n  QUANT_(node)->lower           = lower;\n  QUANT_(node)->upper           = upper;\n  QUANT_(node)->greedy          = 1;\n  QUANT_(node)->emptiness       = BODY_IS_NOT_EMPTY;\n  QUANT_(node)->head_exact      = NULL_NODE;\n  QUANT_(node)->next_head_exact = NULL_NODE;\n  QUANT_(node)->is_refered      = 0;\n  if (by_number != 0)\n    NODE_STATUS_ADD(node, BY_NUMBER);\n\n  return node;\n}\n\nstatic Node*\nnode_new_bag(enum BagType type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_BAG);\n  BAG_(node)->type = type;\n\n  switch (type) {\n  case BAG_MEMORY:\n    BAG_(node)->m.regnum       =  0;\n    BAG_(node)->m.called_addr  = -1;\n    BAG_(node)->m.entry_count  =  1;\n    BAG_(node)->m.called_state =  0;\n    break;\n\n  case BAG_OPTION:\n    BAG_(node)->o.options =  0;\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    break;\n\n  case BAG_IF_ELSE:\n    BAG_(node)->te.Then = 0;\n    BAG_(node)->te.Else = 0;\n    break;\n  }\n\n  BAG_(node)->opt_count = 0;\n  return node;\n}\n\nextern Node*\nonig_node_new_bag(enum BagType type)\n{\n  return node_new_bag(type);\n}\n\nstatic Node*\nnode_new_bag_if_else(Node* cond, Node* Then, Node* Else)\n{\n  Node* n;\n  n = node_new_bag(BAG_IF_ELSE);\n  CHECK_NULL_RETURN(n);\n\n  NODE_BODY(n) = cond;\n  BAG_(n)->te.Then = Then;\n  BAG_(n)->te.Else = Else;\n  return n;\n}\n\nstatic Node*\nnode_new_memory(int is_named)\n{\n  Node* node = node_new_bag(BAG_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    NODE_STATUS_ADD(node, NAMED_GROUP);\n\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_bag(BAG_OPTION);\n  CHECK_NULL_RETURN(node);\n  BAG_(node)->o.options = option;\n  return node;\n}\n\nstatic Node*\nnode_new_group(Node* content)\n{\n  Node* node;\n\n  node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_LIST);\n  NODE_CAR(node) = content;\n  NODE_CDR(node) = NULL_NODE;\n\n  return node;\n}\n\nstatic Node*\nnode_drop_group(Node* group)\n{\n  Node* content;\n\n  content = NODE_CAR(group);\n  NODE_CAR(group) = NULL_NODE;\n  onig_node_free(group);\n  return content;\n}\n\nstatic int\nnode_new_fail(Node** node, ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->type = GIMMICK_FAIL;\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_save_gimmick(Node** node, enum SaveType save_type, ScanEnv* env)\n{\n  int id;\n  int r;\n\n  r = save_entry(env, save_type, &id);\n  if (r != ONIG_NORMAL) return r;\n\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id   = id;\n  GIMMICK_(*node)->type = GIMMICK_SAVE;\n  GIMMICK_(*node)->detail_type = (int )save_type;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_update_var_gimmick(Node** node, enum UpdateVarType update_var_type,\n                            int id, ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id   = id;\n  GIMMICK_(*node)->type = GIMMICK_UPDATE_VAR;\n  GIMMICK_(*node)->detail_type = (int )update_var_type;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_keep(Node** node, ScanEnv* env)\n{\n  int r;\n\n  r = node_new_save_gimmick(node, SAVE_KEEP, env);\n  if (r != 0) return r;\n\n  env->keep_num++;\n  return ONIG_NORMAL;\n}\n\n#ifdef USE_CALLOUT\n\nextern void\nonig_free_reg_callout_list(int n, CalloutListEntry* list)\n{\n  int i;\n  int j;\n\n  if (IS_NULL(list)) return ;\n\n  for (i = 0; i < n; i++) {\n    if (list[i].of == ONIG_CALLOUT_OF_NAME) {\n      for (j = 0; j < list[i].u.arg.passed_num; j++) {\n        if (list[i].u.arg.types[j] == ONIG_TYPE_STRING) {\n          if (IS_NOT_NULL(list[i].u.arg.vals[j].s.start))\n            xfree(list[i].u.arg.vals[j].s.start);\n        }\n      }\n    }\n    else { /* ONIG_CALLOUT_OF_CONTENTS */\n      if (IS_NOT_NULL(list[i].u.content.start)) {\n        xfree((void* )list[i].u.content.start);\n      }\n    }\n  }\n\n  xfree(list);\n}\n\nextern CalloutListEntry*\nonig_reg_callout_list_at(regex_t* reg, int num)\n{\n  RegexExt* ext = reg->extp;\n  CHECK_NULL_RETURN(ext);\n\n  if (num <= 0 || num > ext->callout_num)\n    return 0;\n\n  num--;\n  return ext->callout_list + num;\n}\n\nstatic int\nreg_callout_list_entry(ScanEnv* env, int* rnum)\n{\n#define INIT_CALLOUT_LIST_NUM  3\n\n  int num;\n  CalloutListEntry* list;\n  CalloutListEntry* e;\n  RegexExt* ext;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  if (IS_NULL(ext->callout_list)) {\n    list = (CalloutListEntry* )xmalloc(sizeof(*list) * INIT_CALLOUT_LIST_NUM);\n    CHECK_NULL_RETURN_MEMERR(list);\n\n    ext->callout_list = list;\n    ext->callout_list_alloc = INIT_CALLOUT_LIST_NUM;\n    ext->callout_num = 0;\n  }\n\n  num = ext->callout_num + 1;\n  if (num > ext->callout_list_alloc) {\n    int alloc = ext->callout_list_alloc * 2;\n    list = (CalloutListEntry* )xrealloc(ext->callout_list,\n                                        sizeof(CalloutListEntry) * alloc);\n    CHECK_NULL_RETURN_MEMERR(list);\n\n    ext->callout_list       = list;\n    ext->callout_list_alloc = alloc;\n  }\n\n  e = ext->callout_list + (num - 1);\n\n  e->flag             = 0;\n  e->of               = 0;\n  e->in               = ONIG_CALLOUT_OF_CONTENTS;\n  e->type             = 0;\n  e->tag_start        = 0;\n  e->tag_end          = 0;\n  e->start_func       = 0;\n  e->end_func         = 0;\n  e->u.arg.num        = 0;\n  e->u.arg.passed_num = 0;\n\n  ext->callout_num = num;\n  *rnum = num;\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_callout(Node** node, OnigCalloutOf callout_of, int num, int id,\n                 ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id          = id;\n  GIMMICK_(*node)->num         = num;\n  GIMMICK_(*node)->type        = GIMMICK_CALLOUT;\n  GIMMICK_(*node)->detail_type = (int )callout_of;\n\n  return ONIG_NORMAL;\n}\n#endif\n\nstatic int\nmake_text_segment(Node** node, ScanEnv* env)\n{\n  int r;\n  int i;\n  Node* x;\n  Node* ns[2];\n\n  /* \\X == (?>\\O(?:\\Y\\O)*) */\n\n  ns[1] = NULL_NODE;\n\n  r = ONIGERR_MEMORY;\n  ns[0] = onig_node_new_anchor(ANCR_NO_TEXT_SEGMENT_BOUNDARY, 0);\n  if (IS_NULL(ns[0])) goto err;\n\n  r = node_new_true_anychar(&ns[1], env);\n  if (r != 0) goto err1;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err;\n  ns[0] = x;\n  ns[1] = NULL_NODE;\n\n  x = node_new_quantifier(0, INFINITE_REPEAT, 1);\n  if (IS_NULL(x)) goto err;\n\n  NODE_BODY(x) = ns[0];\n  ns[0] = NULL_NODE;\n  ns[1] = x;\n\n  r = node_new_true_anychar(&ns[0], env);\n  if (r != 0) goto err1;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err;\n\n  ns[0] = x;\n  ns[1] = NULL_NODE;\n\n  x = node_new_bag(BAG_STOP_BACKTRACK);\n  if (IS_NULL(x)) goto err;\n\n  NODE_BODY(x) = ns[0];\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err:\n  r = ONIGERR_MEMORY;\n err1:\n  for (i = 0; i < 2; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n\n  ns[1] = absent;\n  ns[3] = step_one; /* for err */\n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n\n  if (possessive != 0) {\n    x = node_new_bag(BAG_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n\n  ns[1] = x; ns[2] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, SUPER);\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_tail(Node** node1, Node** node2, int pre_save_right_id,\n                 ScanEnv* env)\n{\n  int r;\n  int id;\n  Node* save;\n  Node* x;\n  Node* ns[2];\n\n  *node1 = *node2 = NULL_NODE;\n  save = ns[0] = ns[1] = NULL_NODE;\n\n  r = node_new_save_gimmick(&save, SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(save)->id;\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[1], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = NULL_NODE; ns[1] = x;\n\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node1 = save;\n  *node2 = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  onig_node_free(save);\n  onig_node_free(ns[0]);\n  onig_node_free(ns[1]);\n  return r;\n}\n\nstatic int\nmake_range_clear(Node** node, ScanEnv* env)\n{\n  int r;\n  int id;\n  Node* save;\n  Node* x;\n  Node* ns[2];\n\n  *node = NULL_NODE;\n  save = ns[0] = ns[1] = NULL_NODE;\n\n  r = node_new_save_gimmick(&save, SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(save)->id;\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[1], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = NULL_NODE; ns[1] = x;\n\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_INIT, 0, env);\n  if (r != 0) goto err;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  NODE_STATUS_ADD(x, SUPER);\n\n  ns[0] = save;\n  ns[1] = x;\n  save = NULL_NODE;\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  onig_node_free(save);\n  onig_node_free(ns[0]);\n  onig_node_free(ns[1]);\n  return r;\n}\n\nstatic int\nis_simple_one_char_repeat(Node* node, Node** rquant, Node** rbody,\n                          int* is_possessive, ScanEnv* env)\n{\n  Node* quant;\n  Node* body;\n\n  *rquant = *rbody = 0;\n  *is_possessive = 0;\n\n  if (NODE_TYPE(node) == NODE_QUANT) {\n    quant = node;\n  }\n  else {\n    if (NODE_TYPE(node) == NODE_BAG) {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_STOP_BACKTRACK) {\n        *is_possessive = 1;\n        quant = NODE_BAG_BODY(en);\n        if (NODE_TYPE(quant) != NODE_QUANT)\n          return 0;\n      }\n      else\n        return 0;\n    }\n    else\n      return 0;\n  }\n\n  if (QUANT_(quant)->greedy == 0)\n    return 0;\n\n  body = NODE_BODY(quant);\n  switch (NODE_TYPE(body)) {\n  case NODE_STRING:\n    {\n      int len;\n      StrNode* sn = STR_(body);\n      UChar *s = sn->s;\n\n      len = 0;\n      while (s < sn->end) {\n        s += enclen(env->enc, s);\n        len++;\n      }\n      if (len != 1)\n        return 0;\n    }\n\n  case NODE_CCLASS:\n    break;\n\n  default:\n    return 0;\n    break;\n  }\n\n  if (node != quant) {\n    NODE_BODY(node) = 0;\n    onig_node_free(node);\n  }\n  NODE_BODY(quant) = NULL_NODE;\n  *rquant = quant;\n  *rbody  = body;\n  return 1;\n}\n\nstatic int\nmake_absent_tree_for_simple_one_char_repeat(Node** node, Node* absent, Node* quant,\n                                            Node* body, int possessive, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id1;\n  int lower, upper;\n  Node* x;\n  Node* ns[4];\n\n  *node = NULL_NODE;\n  r = ONIGERR_MEMORY;\n  ns[0] = ns[1] = NULL_NODE;\n  ns[2] = body, ns[3] = absent;\n\n  lower = QUANT_(quant)->lower;\n  upper = QUANT_(quant)->upper;\n  onig_node_free(quant);\n\n  r = node_new_save_gimmick(&ns[0], SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id1 = GIMMICK_(ns[0])->id;\n\n  r = make_absent_engine(&ns[1], id1, absent, body, lower, upper, possessive,\n                         0, env);\n  if (r != 0) goto err;\n\n  ns[2] = ns[3] = NULL_NODE;\n\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id1, env);\n  if (r != 0) goto err;\n\n  x = make_list(3, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_tree(Node** node, Node* absent, Node* expr, int is_range_cutter,\n                 ScanEnv* env)\n{\n  int r;\n  int i;\n  int id1, id2;\n  int possessive;\n  Node* x;\n  Node* ns[7];\n\n  r = ONIGERR_MEMORY;\n  for (i = 0; i < 7; i++) ns[i] = NULL_NODE;\n  ns[4] = expr; ns[5] = absent;\n\n  if (is_range_cutter == 0) {\n    Node* quant;\n    Node* body;\n\n    if (expr == NULL_NODE) {\n      /* default expr \\O* */\n      quant = node_new_quantifier(0, INFINITE_REPEAT, 0);\n      if (IS_NULL(quant)) goto err0;\n\n      r = node_new_true_anychar(&body, env);\n      if (r != 0) {\n        onig_node_free(quant);\n        goto err;\n      }\n      possessive = 0;\n      goto simple;\n    }\n    else {\n      if (is_simple_one_char_repeat(expr, &quant, &body, &possessive, env)) {\n      simple:\n        r = make_absent_tree_for_simple_one_char_repeat(node, absent, quant,\n                                                        body, possessive, env);\n        if (r != 0) {\n          ns[4] = NULL_NODE;\n          onig_node_free(quant);\n          onig_node_free(body);\n          goto err;\n        }\n\n        return ONIG_NORMAL;\n      }\n    }\n  }\n\n  r = node_new_save_gimmick(&ns[0], SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id1 = GIMMICK_(ns[0])->id;\n\n  r = node_new_save_gimmick(&ns[1], SAVE_S, env);\n  if (r != 0) goto err;\n\n  id2 = GIMMICK_(ns[1])->id;\n\n  r = node_new_true_anychar(&ns[3], env);\n  if (r != 0) goto err;\n\n  possessive = 1;\n  r = make_absent_engine(&ns[2], id1, absent, ns[3], 0, INFINITE_REPEAT,\n                         possessive, is_range_cutter, env);\n  if (r != 0) goto err;\n\n  ns[3] = NULL_NODE;\n  ns[5] = NULL_NODE;\n\n  r = node_new_update_var_gimmick(&ns[3], UPDATE_VAR_S_FROM_STACK, id2, env);\n  if (r != 0) goto err;\n\n  if (is_range_cutter != 0) {\n    x = make_list(4, ns);\n    if (IS_NULL(x)) goto err0;\n  }\n  else {\n    r = make_absent_tail(&ns[5], &ns[6], id1, env);\n    if (r != 0) goto err;\n\n    x = make_list(7, ns);\n    if (IS_NULL(x)) goto err0;\n  }\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 7; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  int addlen = (int )(end - s);\n\n  if (addlen > 0) {\n    int len  = (int )(STR_(node)->end - STR_(node)->s);\n\n    if (STR_(node)->capacity > 0 || (len + addlen > NODE_STRING_BUF_SIZE - 1)) {\n      UChar* p;\n      int capa = len + addlen + NODE_STRING_MARGIN;\n\n      if (capa <= STR_(node)->capacity) {\n        onig_strcpy(STR_(node)->s + len, s, end);\n      }\n      else {\n        if (STR_(node)->s == STR_(node)->buf)\n          p = strcat_capa_from_static(STR_(node)->s, STR_(node)->end,\n                                      s, end, capa);\n        else\n          p = strcat_capa(STR_(node)->s, STR_(node)->end, s, end, capa);\n\n        CHECK_NULL_RETURN_MEMERR(p);\n        STR_(node)->s        = p;\n        STR_(node)->capacity = capa;\n      }\n    }\n    else {\n      onig_strcpy(STR_(node)->s + len, s, end);\n    }\n    STR_(node)->end = STR_(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  NODE_SET_TYPE(node, NODE_STRING);\n  STR_(node)->flag     = flag;\n  STR_(node)->capacity = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n}\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (STR_(node)->capacity != 0 &&\n      IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n    xfree(STR_(node)->s);\n  }\n\n  STR_(node)->capacity = 0;\n  STR_(node)->flag     = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_STRING);\n  STR_(node)->capacity = 0;\n  STR_(node)->flag     = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  CHECK_NULL_RETURN(node);\n  NODE_STRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  int i;\n  UChar p[1];\n  Node* node;\n\n  p[0] = c;\n  node = node_new_str_raw(p, p + 1);\n\n  /* clear buf tail */\n  for (i = 1; i < NODE_STRING_BUF_SIZE; i++)\n    STR_(node)->buf[i] = '\\0';\n\n  return node;\n}\n\nstatic Node*\nstr_node_split_last_char(Node* node, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* rn;\n  StrNode* sn;\n\n  sn = STR_(node);\n  rn = NULL_NODE;\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      rn = node_new_str(p, sn->end);\n      CHECK_NULL_RETURN(rn);\n      if (NODE_STRING_IS_RAW(node))\n        NODE_STRING_SET_RAW(rn);\n\n      sn->end = (UChar* )p;\n    }\n  }\n  return rn;\n}\n\nstatic int\nstr_node_can_be_split(Node* node, OnigEncoding enc)\n{\n  StrNode* sn = STR_(node);\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND) {\n    PFETCH(c);\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n        return -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int minlen,\n                                 int maxlen, OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  int n;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  n = 0;\n  while (! PEND && n < maxlen) {\n    PFETCH(c);\n    if (IS_CODE_XDIGIT_ASCII(enc, c)) {\n      n++;\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n        return ONIGERR_TOO_BIG_NUMBER; /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n\n  if (n < minlen)\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n                           OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (IS_CODE_DIGIT_ASCII(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BB_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BB_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(bbuf);\n  r = BB_INIT(bbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r != 0) {\n    xfree(bbuf);\n    *pbuf = 0;\n    return r;\n  }\n\n  n = 0;\n  BB_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, OnigCodePoint from, OnigCodePoint to)\n{\n  int r, inc_n, pos;\n  int low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r != 0) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  for (low = 0, bound = n; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ~((OnigCodePoint )0)) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0 && (OnigCodePoint )high < n) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n    int size = (n - high) * 2 * SIZE_CODE_POINT;\n\n    if (inc_n > 0) {\n      BB_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n    }\n    else {\n      BB_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BB_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BB_WRITE_CODE_POINT(bbuf, pos, from);\n  BB_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BB_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf(pbuf, from, to);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ~((OnigCodePoint )0)) break;\n    pre = to + 1;\n  }\n  if (to < ~((OnigCodePoint )0)) {\n    r = add_code_range_to_buf(pbuf, to + 1, ~((OnigCodePoint )0));\n  }\n  return r;\n}\n\n#define SWAP_BB_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n        return bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n        return not_code_range_buf(enc, bbuf2, pbuf);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, OnigCodePoint from1, OnigCodePoint to1,\n                OnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n        from1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n        if (from1 <= from2 - 1) {\n          r = add_code_range_to_buf(pbuf, from1, from2-1);\n          if (r != 0) return r;\n        }\n        from1 = to2 + 1;\n      }\n      else {\n        to1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n        from2 = data2[j*2];\n        to2   = data2[j*2+1];\n        if (from2 > to1) break;\n        if (to2 < from1) continue;\n        from = MAX(from1, from2);\n        to   = MIN(to1, to2);\n        r = add_code_range_to_buf(pbuf, from, to);\n        if (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n        return '\\v';\n      break;\n\n    default:\n      break;\n    }\n  }\n  return c;\n}\n\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n    return 1;\n    break;\n\n  case NODE_BAG:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NODE_BODY(node)); */\n    break;\n\n  case NODE_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NODE_CAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    return 0;\n    break;\n\n  case NODE_ALT:\n    do {\n      if (is_invalid_quantifier_target(NODE_CAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\nquantifier_type_num(QuantNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_INFINITE_REPEAT(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_INFINITE_REPEAT(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_INFINITE_REPEAT(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_INFINITE_REPEAT(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType ReduceTypeTable[6][6] = {\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QuantNode *p, *c;\n\n  p = QUANT_(pnode);\n  c = QUANT_(cnode);\n  pnum = quantifier_type_num(p);\n  cnum = quantifier_type_num(c);\n  if (pnum < 0 || cnum < 0) {\n    if ((p->lower == p->upper) && ! IS_INFINITE_REPEAT(p->upper)) {\n      if ((c->lower == c->upper) && ! IS_INFINITE_REPEAT(c->upper)) {\n        int n = onig_positive_int_multiply(p->lower, c->lower);\n        if (n >= 0) {\n          p->lower = p->upper = n;\n          NODE_BODY(pnode) = NODE_BODY(cnode);\n          goto remove_cnode;\n        }\n      }\n    }\n\n    return ;\n  }\n\n  switch(ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = INFINITE_REPEAT;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = INFINITE_REPEAT;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    NODE_BODY(pnode) = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = INFINITE_REPEAT;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    NODE_BODY(pnode) = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = INFINITE_REPEAT;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    NODE_BODY(pnode) = cnode;\n    return ;\n    break;\n  }\n\n remove_cnode:\n  NODE_BODY(cnode) = NULL_NODE;\n  onig_node_free(cnode);\n}\n\nstatic int\nnode_new_general_newline(Node** node, ScanEnv* env)\n{\n  int r;\n  int dlen, alen;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n  Node* crnl;\n  Node* ncc;\n  Node* x;\n  CClassNode* cc;\n\n  dlen = ONIGENC_CODE_TO_MBC(env->enc, 0x0d, buf);\n  if (dlen < 0) return dlen;\n  alen = ONIGENC_CODE_TO_MBC(env->enc, 0x0a, buf + dlen);\n  if (alen < 0) return alen;\n\n  crnl = node_new_str_raw(buf, buf + dlen + alen);\n  CHECK_NULL_RETURN_MEMERR(crnl);\n\n  ncc = node_new_cclass();\n  if (IS_NULL(ncc)) goto err2;\n\n  cc = CCLASS_(ncc);\n  if (dlen == 1) {\n    bitset_set_range(cc->bs, 0x0a, 0x0d);\n  }\n  else {\n    r = add_code_range(&(cc->mbuf), env, 0x0a, 0x0d);\n    if (r != 0) {\n    err1:\n      onig_node_free(ncc);\n    err2:\n      onig_node_free(crnl);\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  if (ONIGENC_IS_UNICODE_ENCODING(env->enc)) {\n    r = add_code_range(&(cc->mbuf), env, 0x85, 0x85);\n    if (r != 0) goto err1;\n    r = add_code_range(&(cc->mbuf), env, 0x2028, 0x2029);\n    if (r != 0) goto err1;\n  }\n\n  x = node_new_bag_if_else(crnl, 0, ncc);\n  if (IS_NULL(x)) goto err1;\n\n  *node = x;\n  return 0;\n}\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  TK_KEEP,             /* \\K */\n  TK_GENERAL_NEWLINE,  /* \\R */\n  TK_NO_NEWLINE,       /* \\N */\n  TK_TRUE_ANYCHAR,     /* \\O */\n  TK_TEXT_SEGMENT,     /* \\X */\n\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    int   anchor;\n    int   subtype;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n      int    by_number;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} PToken;\n\n\nstatic int\nfetch_interval_quantifier(UChar** src, UChar* end, PToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n        goto invalid;\n      up = INFINITE_REPEAT;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_INFINITE_REPEAT(up) && low > up) {\n    /* {n,m}+ supported case */\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL))\n      return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n\n    tok->u.repeat.possessive = 1;\n    {\n      int tmp;\n      tmp = low; low = up; up = tmp;\n    }\n  }\n  else\n    tok->u.repeat.possessive = 0;\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow) {\n    /* *src = p; */ /* !!! Don't do this line !!! */\n    return 1;  /* OK */\n  }\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n        v = fetch_escaped_value(&p, end, env, &c);\n        if (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n        c = 0177;\n      }\n      else {\n        if (c == MC_ESC(env->syntax)) {\n          v = fetch_escaped_value(&p, end, env, &c);\n          if (v < 0) return v;\n        }\n        c &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(PToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>';  break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')';  break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\nenum REF_NUM {\n  IS_NOT_NUM = 0,\n  IS_ABS_NUM = 1,\n  IS_REL_NUM = 2\n};\n\n#ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n   \\k<+num+n>, \\k<+num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n                      UChar** rname_end, ScanEnv* env,\n                      int* rback_num, int* rlevel, enum REF_NUM* num_type)\n{\n  int r, sign, exist_level;\n  int digit_count;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  exist_level = 0;\n  *num_type = IS_NOT_NUM;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  digit_count = 0;\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      *num_type = IS_ABS_NUM;\n      digit_count++;\n    }\n    else if (c == '-') {\n      *num_type = IS_REL_NUM;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (c == '+') {\n      *num_type = IS_REL_NUM;\n      sign = 1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (*num_type != IS_NOT_NUM && digit_count == 0)\n        r = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (*num_type != IS_NOT_NUM) {\n      if (IS_CODE_DIGIT_ASCII(enc, c)) {\n        digit_count++;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        *num_type = IS_NOT_NUM;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n        r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        goto end;\n      }\n      PFETCH(c);\n      if (! IS_CODE_DIGIT_ASCII(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n        PFETCH(c);\n        if (c == end_code)\n          goto end;\n      }\n    }\n\n  err:\n    name_end = end;\n  err2:\n    r = ONIGERR_INVALID_GROUP_NAME;\n  }\n\n end:\n  if (r == 0) {\n    if (*num_type != IS_NOT_NUM) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        if (*num_type == IS_REL_NUM)\n          goto err2;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n           UChar** rname_end, ScanEnv* env, int* rback_num,\n           enum REF_NUM* num_type, int ref)\n{\n  int r, sign;\n  int digit_count;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  digit_count = 0;\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  *num_type = IS_NOT_NUM;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      if (ref == 1)\n        *num_type = IS_ABS_NUM;\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n      digit_count++;\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n        *num_type = IS_REL_NUM;\n        sign = -1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n    }\n    else if (c == '+') {\n      if (ref == 1) {\n        *num_type = IS_REL_NUM;\n        sign = 1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n        if (*num_type != IS_NOT_NUM && digit_count == 0)\n          r = ONIGERR_INVALID_GROUP_NAME;\n        break;\n      }\n\n      if (*num_type != IS_NOT_NUM) {\n        if (IS_CODE_DIGIT_ASCII(enc, c)) {\n          digit_count++;\n        }\n        else {\n          if (!ONIGENC_IS_CODE_WORD(enc, c))\n            r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n          else\n            r = ONIGERR_INVALID_GROUP_NAME;\n\n          *num_type = IS_NOT_NUM;\n        }\n      }\n      else {\n        if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n          r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        }\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n\n    if (*num_type != IS_NOT_NUM) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        if (*num_type == IS_REL_NUM) {\n          r = ONIGERR_INVALID_GROUP_NAME;\n          goto err;\n        }\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n        break;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n\nstatic void\nCC_ESC_WARN(ScanEnv* env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                               env->pattern, env->pattern_end,\n                               (UChar* )\"character class has '%s' without escape\",\n                               c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, (env)->enc,\n                         (env)->pattern, (env)->pattern_end,\n                         (UChar* )\"regular expression has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n                  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n        x = ONIGENC_MBC_TO_CODE(enc, q, to);\n        if (x != s[i]) break;\n        q += enclen(enc, q);\n      }\n      if (i >= n) {\n        if (IS_NOT_NULL(next))\n          *next = q;\n        return p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n                         OnigCodePoint bad, OnigEncoding enc, OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p);\n      if (x == s[0]) {\n        for (i = 1; i < n && q < to; i++) {\n          x = ONIGENC_MBC_TO_CODE(enc, q, to);\n          if (x != s[i]) break;\n          q += enclen(enc, q);\n        }\n        if (i >= n) return 1;\n        p += enclen(enc, p);\n      }\n      else {\n        x = ONIGENC_MBC_TO_CODE(enc, p, to);\n        if (x == bad) return 0;\n        else if (x == MC_ESC(syn)) in_esc = 1;\n        p = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = c == 'P';\n\n        if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c2);\n          if (c2 == '^') {\n            tok->u.prop.not = tok->u.prop.not == 0;\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (IS_CODE_DIGIT_ASCII(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 8;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          c2 = PPEEK;\n          if (IS_CODE_XDIGIT_ASCII(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 16;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if (tok->u.c != c2) {\n        tok->u.code = c2;\n        tok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n        tok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n        PUNFETCH;\n        goto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n        tok->type = TK_CC_CC_OPEN;\n      }\n      else {\n        CC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n        !PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nfetch_token(PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      tok->u.repeat.possessive = 0;\n    greedy_check2:\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY) &&\n          tok->u.repeat.possessive == 0) {\n        PFETCH(c);\n        tok->u.repeat.greedy = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        tok->u.repeat.greedy = 1;\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL)) &&\n          tok->u.repeat.possessive == 0) {\n          PFETCH(c);\n          tok->u.repeat.possessive = 1;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_interval_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check2;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check2;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_BOUNDARY;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_NO_WORD_BOUNDARY;\n      break;\n\n    case 'y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_TEXT_SEGMENT_BOUNDARY;\n      break;\n\n    case 'Y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_NO_TEXT_SEGMENT_BOUNDARY;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'K':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) break;\n      tok->type = TK_KEEP;\n      break;\n\n    case 'R':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE)) break;\n      tok->type = TK_GENERAL_NEWLINE;\n      break;\n\n    case 'N':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_NO_NEWLINE;\n      break;\n\n    case 'O':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_TRUE_ANYCHAR;\n      break;\n\n    case 'X':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_TEXT_SEGMENT;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (IS_CODE_DIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          if (IS_CODE_XDIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEMENV(env)[num].node))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n          enum REF_NUM num_type;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                 env, &back_num, &tok->u.backref.level, &num_type);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(c, &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n\n#ifdef USE_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n          enum REF_NUM num_type;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env,\n                         &gnum, &num_type, 1);\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              gnum = backref_rel_to_abs(gnum, env);\n              if (gnum < 0) {\n                onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                               prev, name_end);\n                return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n              }\n            }\n            tok->u.call.by_number = 1;\n            tok->u.call.gnum      = gnum;\n          }\n          else {\n            tok->u.call.by_number = 0;\n            tok->u.call.gnum      = 0;\n          }\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = c == 'P';\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = tok->u.prop.not == 0;\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n        }\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_interval_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check2;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check2;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (! PEND) {\n          c = PPEEK;\n          if (c == '#') {\n            PFETCH(c);\n            while (1) {\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c == MC_ESC(syn)) {\n                if (! PEND) PFETCH(c);\n              }\n              else {\n                if (c == ')') break;\n              }\n            }\n            goto start;\n          }\n          else if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_PERL_SUBEXP_CALL)) {\n            int gnum;\n            UChar* name;\n            UChar* name_end;\n            enum REF_NUM num_type;\n\n            switch (c) {\n            case '&':\n              {\n                PINC;\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum,\n                               &num_type, 0);\n                if (r < 0) return r;\n\n                tok->type = TK_CALL;\n                tok->u.call.by_number = 0;\n                tok->u.call.gnum      = 0;\n                tok->u.call.name      = name;\n                tok->u.call.name_end  = name_end;\n              }\n              break;\n\n            case 'R':\n              tok->type = TK_CALL;\n              tok->u.call.by_number = 1;\n              tok->u.call.gnum      = 0;\n              tok->u.call.name      = p;\n              PINC;\n              if (! PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n              tok->u.call.name_end  = p;\n              break;\n\n            case '-':\n            case '+':\n              goto lparen_qmark_num;\n              break;\n            default:\n              if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto lparen_qmark_end;\n\n            lparen_qmark_num:\n              {\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env,\n                               &gnum, &num_type, 1);\n                if (r < 0) return r;\n\n                if (num_type == IS_NOT_NUM) {\n                  return ONIGERR_INVALID_GROUP_NAME;\n                }\n                else {\n                  if (num_type == IS_REL_NUM) {\n                    gnum = backref_rel_to_abs(gnum, env);\n                    if (gnum < 0) {\n                      onig_scan_env_set_error_string(env,\n                             ONIGERR_UNDEFINED_NAME_REFERENCE, name, name_end);\n                      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n                    }\n                  }\n                  tok->u.call.by_number = 1;\n                  tok->u.call.gnum      = gnum;\n                }\n\n                tok->type = TK_CALL;\n                tok->u.call.name     = name;\n                tok->u.call.name_end = name_end;\n              }\n              break;\n            }\n          }\n        }\n      lparen_qmark_end:\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCR_BEGIN_BUF : ANCR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCR_SEMI_END_BUF : ANCR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->options)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->options))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                         OnigEncoding enc ARG_UNUSED, OnigCodePoint sb_out,\n                         const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            r = add_code_range_to_buf(&(cc->mbuf), j,\n                                      ONIGENC_CODE_RANGE_TO(mbr, i));\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf),\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev; j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n        if (j >= sb_out) {\n          goto sb_end2;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n      if (prev == 0) goto end;\n    }\n\n    r = add_code_range_to_buf(&(cc->mbuf), prev, MAX_CODE_POINT);\n    if (r != 0) return r;\n  }\n\n end:\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc_by_range_limit(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                               OnigEncoding enc ARG_UNUSED,\n                               OnigCodePoint sb_out,\n                               const OnigCodePoint mbr[], OnigCodePoint limit)\n{\n  int i, r;\n  OnigCodePoint j;\n  OnigCodePoint from;\n  OnigCodePoint to;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j > limit) goto end;\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            to = ONIGENC_CODE_RANGE_TO(mbr, i);\n            if (to > limit) to = limit;\n            r = add_code_range_to_buf(&(cc->mbuf), j, to);\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      to   = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (from > limit) break;\n      if (to   > limit) to = limit;\n      r = add_code_range_to_buf(&(cc->mbuf), from, to);\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      if (from > limit) {\n        for (j = prev; j < sb_out; j++) {\n          BITSET_SET_BIT(cc->bs, j);\n        }\n        goto sb_end2;\n      }\n      for (j = prev; j < from; j++) {\n        if (j >= sb_out) goto sb_end2;\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (prev > limit) prev = limit;\n      prev++;\n      if (prev == 0) goto end;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      if (from > limit) goto last;\n\n      if (prev < from) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev, from - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (prev > limit) prev = limit;\n      prev++;\n      if (prev == 0) goto end;\n    }\n\n  last:\n    r = add_code_range_to_buf(&(cc->mbuf), prev, MAX_CODE_POINT);\n    if (r != 0) return r;\n  }\n\n end:\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, ScanEnv* env)\n{\n#define ASCII_LIMIT    127\n\n  int c, r;\n  int ascii_mode;\n  const OnigCodePoint *ranges;\n  OnigCodePoint limit;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(ctype, env->options);\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    if (ascii_mode == 0)\n      r = add_ctype_to_cc_by_range(cc, ctype, not, env->enc, sb_out, ranges);\n    else\n      r = add_ctype_to_cc_by_range_limit(cc, ctype, not, env->enc, sb_out,\n                                         ranges, ASCII_LIMIT);\n    return r;\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  r = 0;\n  limit = ascii_mode ? ASCII_LIMIT : SINGLE_BYTE_SIZE;\n\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < (int )limit; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      for (c = limit; c < SINGLE_BYTE_SIZE; c++) {\n        BITSET_SET_BIT(cc->bs, c);\n      }\n\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n  case ONIGENC_CTYPE_WORD:\n    if (not != 0) {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_CODE_TO_MBCLEN(enc, c) > 0 /* check invalid code point */\n            && ! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      for (c = limit; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_CODE_TO_MBCLEN(enc, c) > 0)\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    else {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      if (ascii_mode == 0)\n        ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static PosixBracketEntryType PBS[] = {\n    { (UChar* )\"alnum\",  ONIGENC_CTYPE_ALNUM,  5 },\n    { (UChar* )\"alpha\",  ONIGENC_CTYPE_ALPHA,  5 },\n    { (UChar* )\"blank\",  ONIGENC_CTYPE_BLANK,  5 },\n    { (UChar* )\"cntrl\",  ONIGENC_CTYPE_CNTRL,  5 },\n    { (UChar* )\"digit\",  ONIGENC_CTYPE_DIGIT,  5 },\n    { (UChar* )\"graph\",  ONIGENC_CTYPE_GRAPH,  5 },\n    { (UChar* )\"lower\",  ONIGENC_CTYPE_LOWER,  5 },\n    { (UChar* )\"print\",  ONIGENC_CTYPE_PRINT,  5 },\n    { (UChar* )\"punct\",  ONIGENC_CTYPE_PUNCT,  5 },\n    { (UChar* )\"space\",  ONIGENC_CTYPE_SPACE,  5 },\n    { (UChar* )\"upper\",  ONIGENC_CTYPE_UPPER,  5 },\n    { (UChar* )\"xdigit\", ONIGENC_CTYPE_XDIGIT, 6 },\n    { (UChar* )\"ascii\",  ONIGENC_CTYPE_ASCII,  5 },\n    { (UChar* )\"word\",   ONIGENC_CTYPE_WORD,   4 },\n    { (UChar* )NULL,     -1, 0 }\n  };\n\n  PosixBracketEntryType *pb;\n  int not, i, r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, env);\n      if (r != 0) return r;\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int\nparse_char_property(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = CCLASS_(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  return 0;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n                 enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, OnigCodePoint *from, OnigCodePoint to,\n               int* from_israw, int to_israw,\n               enum CCVALTYPE intype, enum CCVALTYPE* type,\n               enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*from > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*from));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *from, *from);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*from > 0xff || to > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*from > to) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*from, (int )to);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *from, to);\n        if (r < 0) return r;\n      }\n    }\n    else {\n      if (*from > to) {\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n          goto ccs_range_end;\n        else\n          return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n      }\n      bitset_set_range(cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n      r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*from, to);\n      if (r < 0) return r;\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *from_israw = to_israw;\n  *from       = to;\n  *type       = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n                 ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = CCLASS_(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        int i, j;\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        /* clear buf tail */\n        for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\\0';\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n                         &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\"[\");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) goto err;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) {\n          r = ctype;\n          goto err;\n        }\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) goto err;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\n        if (val_type == CCV_CLASS) {\n          r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n          goto err;\n        }\n\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\"-\");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\"-\");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = CCLASS_(anode);\n        r = or_cclass(cc, acc, env->enc);\n        onig_node_free(anode);\n\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != CCLASS_(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, PToken* tok, int term,\n                        UChar** src, UChar* end, ScanEnv* env, int group_head);\n\n#ifdef USE_CALLOUT\n\n/* (?{...}[tag][+-]) (?{{...}}[tag][+-]) */\nstatic int\nparse_callout_of_contents(Node** np, int cterm, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  int i;\n  int in;\n  int num;\n  OnigCodePoint c;\n  UChar* code_start;\n  UChar* code_end;\n  UChar* contents;\n  UChar* tag_start;\n  UChar* tag_end;\n  int brace_nest;\n  CalloutListEntry* e;\n  RegexExt* ext;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  brace_nest = 0;\n  while (PPEEK_IS('{')) {\n    brace_nest++;\n    PINC_S;\n    if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n  }\n\n  in = ONIG_CALLOUT_IN_PROGRESS;\n  code_start = p;\n  while (1) {\n    if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n    code_end = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      i = brace_nest;\n      while (i > 0) {\n        if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n        PFETCH_S(c);\n        if (c == '}') i--;\n        else break;\n      }\n      if (i == 0) break;\n    }\n  }\n\n  if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n  PFETCH_S(c);\n  if (c == '[') {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    tag_end = tag_start = p;\n    while (! PEND) {\n      if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n      tag_end = p;\n      PFETCH_S(c);\n      if (c == ']') break;\n    }\n    if (! is_allowed_callout_tag_name(enc, tag_start, tag_end))\n      return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    tag_start = tag_end = 0;\n  }\n\n  if (c == 'X') {\n    in |= ONIG_CALLOUT_IN_RETRACTION;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else if (c == '<') {\n    in = ONIG_CALLOUT_IN_RETRACTION;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else if (c == '>') { /* no needs (default) */\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n\n  if (c != cterm)\n    return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  r = reg_callout_list_entry(env, &num);\n  if (r != 0) return r;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  if (IS_NULL(ext->pattern)) {\n    r = onig_ext_set_pattern(env->reg, env->pattern, env->pattern_end);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  if (tag_start != tag_end) {\n    r = callout_tag_entry(env->reg, tag_start, tag_end, num);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  contents = onigenc_strdup(enc, code_start, code_end);\n  CHECK_NULL_RETURN_MEMERR(contents);\n\n  r = node_new_callout(np, ONIG_CALLOUT_OF_CONTENTS, num, ONIG_NON_NAME_ID, env);\n  if (r != 0) {\n    xfree(contents);\n    return r;\n  }\n\n  e = onig_reg_callout_list_at(env->reg, num);\n  if (IS_NULL(e)) {\n    xfree(contents);\n    return ONIGERR_MEMORY;\n  }\n\n  e->of      = ONIG_CALLOUT_OF_CONTENTS;\n  e->in      = in;\n  e->name_id = ONIG_NON_NAME_ID;\n  e->u.content.start = contents;\n  e->u.content.end   = contents + (code_end - code_start);\n\n  *src = p;\n  return 0;\n}\n\nstatic long\nparse_long(OnigEncoding enc, UChar* s, UChar* end, int sign_on, long max, long* rl)\n{\n  long v;\n  long d;\n  int flag;\n  UChar* p;\n  OnigCodePoint c;\n\n  if (s >= end) return ONIGERR_INVALID_CALLOUT_ARG;\n\n  flag = 1;\n  v = 0;\n  p = s;\n  while (p < end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, end);\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n    if (c >= '0' && c <= '9') {\n      d = (long )(c - '0');\n      if (v > (max - d) / 10)\n        return ONIGERR_INVALID_CALLOUT_ARG;\n\n      v = v * 10 + d;\n    }\n    else if (sign_on != 0 && (c == '-' || c == '+')) {\n      if (c == '-') flag = -1;\n    }\n    else\n      return ONIGERR_INVALID_CALLOUT_ARG;\n\n    sign_on = 0;\n  }\n\n  *rl = flag * v;\n  return ONIG_NORMAL;\n}\n\nstatic int\nparse_callout_args(int skip_mode, int cterm, UChar** src, UChar* end,\n                   unsigned int types[], OnigValue vals[], ScanEnv* env)\n{\n#define MAX_CALLOUT_ARG_BYTE_LENGTH   128\n\n  int r;\n  int n;\n  int esc;\n  int cn;\n  UChar* s;\n  UChar* e;\n  UChar* eesc;\n  OnigCodePoint c;\n  UChar* bufend;\n  UChar buf[MAX_CALLOUT_ARG_BYTE_LENGTH];\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  n = 0;\n  while (n < ONIG_CALLOUT_MAX_ARGS_NUM) {\n    c   = 0;\n    cn  = 0;\n    esc = 0;\n    eesc = 0;\n    bufend = buf;\n    s = e = p;\n    while (1) {\n      if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n      e = p;\n      PFETCH_S(c);\n      if (esc != 0) {\n        esc = 0;\n        if (c == '\\\\' || c == cterm || c == ',') {\n          /* */\n        }\n        else {\n          e = eesc;\n          cn++;\n        }\n        goto add_char;\n      }\n      else {\n        if (c == '\\\\') {\n          esc = 1;\n          eesc = e;\n        }\n        else if (c == cterm || c == ',')\n          break;\n        else {\n          size_t clen;\n\n        add_char:\n          if (skip_mode == 0) {\n            clen = p - e;\n            if (bufend + clen > buf + MAX_CALLOUT_ARG_BYTE_LENGTH)\n              return ONIGERR_INVALID_CALLOUT_ARG; /* too long argument */\n\n            xmemcpy(bufend, e, clen);\n            bufend += clen;\n          }\n          cn++;\n        }\n      }\n    }\n\n    if (cn != 0) {\n      if (skip_mode == 0) {\n        if ((types[n] & ONIG_TYPE_LONG) != 0) {\n          int fixed = 0;\n          if (cn > 0) {\n            long rl;\n            r = parse_long(enc, buf, bufend, 1, LONG_MAX, &rl);\n            if (r == ONIG_NORMAL) {\n              vals[n].l = rl;\n              fixed = 1;\n              types[n] = ONIG_TYPE_LONG;\n            }\n          }\n\n          if (fixed == 0) {\n            types[n] = (types[n] & ~ONIG_TYPE_LONG);\n            if (types[n] == ONIG_TYPE_VOID)\n              return ONIGERR_INVALID_CALLOUT_ARG;\n          }\n        }\n\n        switch (types[n]) {\n        case ONIG_TYPE_LONG:\n          break;\n\n        case ONIG_TYPE_CHAR:\n          if (cn != 1) return ONIGERR_INVALID_CALLOUT_ARG;\n          vals[n].c = ONIGENC_MBC_TO_CODE(enc, buf, bufend);\n          break;\n\n        case ONIG_TYPE_STRING:\n          {\n            UChar* rs = onigenc_strdup(enc, buf, bufend);\n            CHECK_NULL_RETURN_MEMERR(rs);\n            vals[n].s.start = rs;\n            vals[n].s.end   = rs + (e - s);\n          }\n          break;\n\n        case ONIG_TYPE_TAG:\n          if (eesc != 0 || ! is_allowed_callout_tag_name(enc, s, e))\n            return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n          vals[n].s.start = s;\n          vals[n].s.end   = e;\n          break;\n\n        case ONIG_TYPE_VOID:\n        case ONIG_TYPE_POINTER:\n          return ONIGERR_PARSER_BUG;\n          break;\n        }\n      }\n\n      n++;\n    }\n\n    if (c == cterm) break;\n  }\n\n  if (c != cterm) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  *src = p;\n  return n;\n}\n\n/* (*name[TAG]) (*name[TAG]{a,b,..}) */\nstatic int\nparse_callout_of_name(Node** np, int cterm, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  int i;\n  int in;\n  int num;\n  int name_id;\n  int arg_num;\n  int max_arg_num;\n  int opt_arg_num;\n  int is_not_single;\n  OnigCodePoint c;\n  UChar* name_start;\n  UChar* name_end;\n  UChar* tag_start;\n  UChar* tag_end;\n  Node*  node;\n  CalloutListEntry* e;\n  RegexExt* ext;\n  unsigned int types[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigValue    vals[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  /* PFETCH_READY; */\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  node = 0;\n  name_start = p;\n  while (1) {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    name_end = p;\n    PFETCH_S(c);\n    if (c == cterm || c == '[' || c == '{') break;\n  }\n\n  if (! is_allowed_callout_name(enc, name_start, name_end))\n    return ONIGERR_INVALID_CALLOUT_NAME;\n\n  if (c == '[') {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    tag_end = tag_start = p;\n    while (! PEND) {\n      if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n      tag_end = p;\n      PFETCH_S(c);\n      if (c == ']') break;\n    }\n    if (! is_allowed_callout_tag_name(enc, tag_start, tag_end))\n      return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    tag_start = tag_end = 0;\n  }\n\n  if (c == '{') {\n    UChar* save;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    /* read for single check only */\n    save = p;\n    arg_num = parse_callout_args(1, '}', &p, end, 0, 0, env);\n    if (arg_num < 0) return arg_num;\n\n    is_not_single = PPEEK_IS(cterm) ?  0 : 1;\n    p = save;\n    r = get_callout_name_id_by_name(enc, is_not_single, name_start, name_end,\n                                    &name_id);\n    if (r != ONIG_NORMAL) return r;\n\n    max_arg_num = get_callout_arg_num_by_name_id(name_id);\n    for (i = 0; i < max_arg_num; i++) {\n      types[i] = get_callout_arg_type_by_name_id(name_id, i);\n    }\n\n    arg_num = parse_callout_args(0, '}', &p, end, types, vals, env);\n    if (arg_num < 0) return arg_num;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    arg_num = 0;\n\n    is_not_single = 0;\n    r = get_callout_name_id_by_name(enc, is_not_single, name_start, name_end,\n                                      &name_id);\n    if (r != ONIG_NORMAL) return r;\n\n    max_arg_num = get_callout_arg_num_by_name_id(name_id);\n    for (i = 0; i < max_arg_num; i++) {\n      types[i] = get_callout_arg_type_by_name_id(name_id, i);\n    }\n  }\n\n  in = onig_get_callout_in_by_name_id(name_id);\n  opt_arg_num = get_callout_opt_arg_num_by_name_id(name_id);\n  if (arg_num > max_arg_num || arg_num < (max_arg_num - opt_arg_num))\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (c != cterm)\n    return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  r = reg_callout_list_entry(env, &num);\n  if (r != 0) return r;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  if (IS_NULL(ext->pattern)) {\n    r = onig_ext_set_pattern(env->reg, env->pattern, env->pattern_end);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  if (tag_start != tag_end) {\n    r = callout_tag_entry(env->reg, tag_start, tag_end, num);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  r = node_new_callout(&node, ONIG_CALLOUT_OF_NAME, num, name_id, env);\n  if (r != ONIG_NORMAL) return r;\n\n  e = onig_reg_callout_list_at(env->reg, num);\n  CHECK_NULL_RETURN_MEMERR(e);\n\n  e->of         = ONIG_CALLOUT_OF_NAME;\n  e->in         = in;\n  e->name_id    = name_id;\n  e->type       = onig_get_callout_type_by_name_id(name_id);\n  e->start_func = onig_get_callout_start_func_by_name_id(name_id);\n  e->end_func   = onig_get_callout_end_func_by_name_id(name_id);\n  e->u.arg.num        = max_arg_num;\n  e->u.arg.passed_num = arg_num;\n  for (i = 0; i < max_arg_num; i++) {\n    e->u.arg.types[i] = types[i];\n    if (i < arg_num)\n      e->u.arg.vals[i] = vals[i];\n    else\n      e->u.arg.vals[i] = get_callout_opt_default_by_name_id(name_id, i);\n  }\n\n  *np = node;\n  *src = p;\n  return 0;\n}\n#endif\n\nstatic int\nparse_bag(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env)\n{\n  int r, num;\n  Node *target;\n  OnigOptionType option;\n  OnigCodePoint c;\n  int list_capture;\n  OnigEncoding enc = env->enc;\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->options;\n  c = PPEEK;\n  if (c == '?' && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env, 0);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCR_PREC_READ, 0);\n      break;\n    case '!':  /*         preceding read */\n      *np = onig_node_new_anchor(ANCR_PREC_READ_NOT, 0);\n      break;\n    case '>':            /* (?>...) stop backtrack */\n      *np = node_new_bag(BAG_STOP_BACKTRACK);\n      break;\n\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n        goto named_group1;\n      }\n      else\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n        *np = onig_node_new_anchor(ANCR_LOOK_BEHIND, 0);\n      else if (c == '!')\n        *np = onig_node_new_anchor(ANCR_LOOK_BEHIND_NOT, 0);\n      else {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          UChar *name;\n          UChar *name_end;\n          enum REF_NUM num_type;\n\n          PUNFETCH;\n          c = '<';\n\n        named_group1:\n          list_capture = 0;\n\n        named_group2:\n          name = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num,\n                         &num_type, 0);\n          if (r < 0) return r;\n\n          num = scan_env_add_mem_entry(env);\n          if (num < 0) return num;\n          if (list_capture != 0 && num >= (int )MEM_STATUS_BITS_NUM)\n            return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n          r = name_add(env->reg, name, name_end, num, env);\n          if (r != 0) return r;\n          *np = node_new_memory(1);\n          CHECK_NULL_RETURN_MEMERR(*np);\n          BAG_(*np)->m.regnum = num;\n          if (list_capture != 0)\n            MEM_STATUS_ON_SIMPLE(env->capture_history, num);\n          env->num_named++;\n        }\n        else {\n          return ONIGERR_UNDEFINED_GROUP_OPTION;\n        }\n      }\n      break;\n\n    case '~':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP)) {\n        Node* absent;\n        Node* expr;\n        int head_bar;\n        int is_range_cutter;\n\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n        if (PPEEK_IS('|')) { /* (?~|generator|absent) */\n          PINC;\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n          head_bar = 1;\n          if (PPEEK_IS(')')) { /* (?~|)  : range clear */\n            PINC;\n            r = make_range_clear(np, env);\n            if (r != 0) return r;\n            goto end;\n          }\n        }\n        else\n          head_bar = 0;\n\n        r = fetch_token(tok, &p, end, env);\n        if (r < 0) return r;\n        r = parse_subexp(&absent, tok, term, &p, end, env, 1);\n        if (r < 0) {\n          onig_node_free(absent);\n          return r;\n        }\n\n        expr = NULL_NODE;\n        is_range_cutter = 0;\n        if (head_bar != 0) {\n          Node* top = absent;\n          if (NODE_TYPE(top) != NODE_ALT || IS_NULL(NODE_CDR(top))) {\n            expr = NULL_NODE;\n            is_range_cutter = 1;\n            /* return ONIGERR_INVALID_ABSENT_GROUP_GENERATOR_PATTERN; */\n          }\n          else {\n            absent = NODE_CAR(top);\n            expr   = NODE_CDR(top);\n            NODE_CAR(top) = NULL_NODE;\n            NODE_CDR(top) = NULL_NODE;\n            onig_node_free(top);\n            if (IS_NULL(NODE_CDR(expr))) {\n              top = expr;\n              expr = NODE_CAR(top);\n              NODE_CAR(top) = NULL_NODE;\n              onig_node_free(top);\n            }\n          }\n        }\n\n        r = make_absent_tree(np, absent, expr, is_range_cutter, env);\n        if (r != 0) {\n          return r;\n        }\n        goto end;\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_CALLOUT\n    case '{':\n      if (! IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS))\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n      r = parse_callout_of_contents(np, ')', &p, end, env);\n      if (r != 0) return r;\n\n      goto end;\n      break;\n#endif\n\n    case '(':\n      /* (?()...) */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE)) {\n        UChar *prev;\n        Node* condition;\n        int condition_is_checker;\n\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n        PFETCH(c);\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n        if (IS_CODE_DIGIT_ASCII(enc, c)\n            || c == '-' || c == '+' || c == '<' || c == '\\'') {\n          UChar* name_end;\n          int back_num;\n          int exist_level;\n          int level;\n          enum REF_NUM num_type;\n          int is_enclosed;\n\n          is_enclosed = (c == '<' || c == '\\'') ? 1 : 0;\n          if (! is_enclosed)\n            PUNFETCH;\n          prev = p;\n          exist_level = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level(\n                    (OnigCodePoint )(is_enclosed != 0 ? c : '('),\n                    &p, end, &name_end,\n                    env, &back_num, &level, &num_type);\n          if (r == 1) exist_level = 1;\n#else\n          r = fetch_name((OnigCodePoint )(is_enclosed != 0 ? c : '('),\n                         &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) {\n            if (is_enclosed == 0) {\n              goto any_condition;\n            }\n            else\n              return r;\n          }\n\n          condition_is_checker = 1;\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n\n            condition = node_new_backref_checker(1, &back_num, 0,\n#ifdef USE_BACKREF_WITH_LEVEL\n                                                 exist_level, level,\n#endif\n                                                 env);\n          }\n          else {\n            int num;\n            int* backs;\n\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            condition = node_new_backref_checker(num, backs, 1,\n#ifdef USE_BACKREF_WITH_LEVEL\n                                                 exist_level, level,\n#endif\n                                                 env);\n          }\n\n          if (is_enclosed != 0) {\n            if (PEND) goto err_if_else;\n            PFETCH(c);\n            if (c != ')') goto err_if_else;\n          }\n        }\n#ifdef USE_CALLOUT\n        else if (c == '?') {\n          if (IS_SYNTAX_OP2(env->syntax,\n                            ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS)) {\n            if (! PEND && PPEEK_IS('{')) {\n              /* condition part is callouts of contents: (?(?{...})THEN|ELSE) */\n              condition_is_checker = 0;\n              PFETCH(c);\n              r = parse_callout_of_contents(&condition, ')', &p, end, env);\n              if (r != 0) return r;\n              goto end_condition;\n            }\n          }\n          goto any_condition;\n        }\n        else if (c == '*' &&\n                 IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME)) {\n          condition_is_checker = 0;\n          r = parse_callout_of_name(&condition, ')', &p, end, env);\n          if (r != 0) return r;\n          goto end_condition;\n        }\n#endif\n        else {\n        any_condition:\n          PUNFETCH;\n          condition_is_checker = 0;\n          r = fetch_token(tok, &p, end, env);\n          if (r < 0) return r;\n          r = parse_subexp(&condition, tok, term, &p, end, env, 0);\n          if (r < 0) {\n            onig_node_free(condition);\n            return r;\n          }\n        }\n\n#ifdef USE_CALLOUT\n      end_condition:\n#endif\n        CHECK_NULL_RETURN_MEMERR(condition);\n\n        if (PEND) {\n        err_if_else:\n          onig_node_free(condition);\n          return ONIGERR_END_PATTERN_IN_GROUP;\n        }\n\n        if (PPEEK_IS(')')) { /* case: empty body: make backref checker */\n          if (condition_is_checker == 0) {\n            onig_node_free(condition);\n            return ONIGERR_INVALID_IF_ELSE_SYNTAX;\n          }\n          PFETCH(c);\n          *np = condition;\n        }\n        else { /* if-else */\n          int then_is_empty;\n          Node *Then, *Else;\n\n          Then = 0;\n          if (PPEEK_IS('|')) {\n            PFETCH(c);\n            then_is_empty = 1;\n          }\n          else\n            then_is_empty = 0;\n\n          r = fetch_token(tok, &p, end, env);\n          if (r < 0) {\n            onig_node_free(condition);\n            return r;\n          }\n          r = parse_subexp(&target, tok, term, &p, end, env, 1);\n          if (r < 0) {\n            onig_node_free(condition);\n            onig_node_free(target);\n            return r;\n          }\n\n          if (then_is_empty != 0) {\n            Else = target;\n          }\n          else {\n            if (NODE_TYPE(target) == NODE_ALT) {\n              Then = NODE_CAR(target);\n              if (NODE_CDR(NODE_CDR(target)) == NULL_NODE) {\n                Else = NODE_CAR(NODE_CDR(target));\n                cons_node_free_alone(NODE_CDR(target));\n              }\n              else {\n                Else = NODE_CDR(target);\n              }\n              cons_node_free_alone(target);\n            }\n            else {\n              Then = target;\n              Else = 0;\n            }\n          }\n\n          *np = node_new_bag_if_else(condition, Then, Else);\n          if (IS_NULL(*np)) {\n            onig_node_free(condition);\n            onig_node_free(Then);\n            onig_node_free(Else);\n            return ONIGERR_MEMORY;\n          }\n        }\n        goto end;\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          PFETCH(c);\n          if (c == '<' || c == '\\'') {\n            list_capture = 1;\n            goto named_group2; /* (?@<name>...) */\n          }\n          PUNFETCH;\n        }\n\n        *np = node_new_memory(0);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        num = scan_env_add_mem_entry(env);\n        if (num < 0) {\n          return num;\n        }\n        else if (num >= (int )MEM_STATUS_BITS_NUM) {\n          return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n        }\n        BAG_(*np)->m.regnum = num;\n        MEM_STATUS_ON_SIMPLE(env->capture_history, num);\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n    case 'W': case 'D': case 'S': case 'P':\n    case 'y':\n      {\n        int neg = 0;\n\n        while (1) {\n          switch (c) {\n          case ':':\n          case ')':\n            break;\n\n          case '-':  neg = 1; break;\n          case 'x':  OPTION_NEGATE(option, ONIG_OPTION_EXTEND,     neg); break;\n          case 'i':  OPTION_NEGATE(option, ONIG_OPTION_IGNORECASE, neg); break;\n          case 's':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              OPTION_NEGATE(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n\n          case 'm':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              OPTION_NEGATE(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n            }\n            else if (IS_SYNTAX_OP2(env->syntax,\n                        ONIG_SYN_OP2_OPTION_ONIGURUMA|ONIG_SYN_OP2_OPTION_RUBY)) {\n              OPTION_NEGATE(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n#ifdef USE_POSIXLINE_OPTION\n          case 'p':\n            OPTION_NEGATE(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n            break;\n#endif\n          case 'W': OPTION_NEGATE(option, ONIG_OPTION_WORD_IS_ASCII, neg); break;\n          case 'D': OPTION_NEGATE(option, ONIG_OPTION_DIGIT_IS_ASCII, neg); break;\n          case 'S': OPTION_NEGATE(option, ONIG_OPTION_SPACE_IS_ASCII, neg); break;\n          case 'P': OPTION_NEGATE(option, ONIG_OPTION_POSIX_IS_ASCII, neg); break;\n\n          case 'y': /* y{g}, y{w} */\n            {\n              if (! IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_ONIGURUMA))\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n              if (neg != 0) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              if (! PPEEK_IS('{')) return ONIGERR_UNDEFINED_GROUP_OPTION;\n              PFETCH(c);\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              switch (c) {\n              case 'g':\n                if (! ONIGENC_IS_UNICODE_ENCODING(enc))\n                  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_EXTENDED_GRAPHEME_CLUSTER, 0);\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_WORD, 1);\n                break;\n#ifdef USE_UNICODE_WORD_BREAK\n              case 'w':\n                if (! ONIGENC_IS_UNICODE_ENCODING(enc))\n                  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_WORD, 0);\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_EXTENDED_GRAPHEME_CLUSTER, 1);\n                break;\n#endif\n              default:\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n                break;\n              }\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c != '}')\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n              break;\n            } /* case 'y' */\n\n          default:\n            return ONIGERR_UNDEFINED_GROUP_OPTION;\n          }\n\n          if (c == ')') {\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            *src = p;\n            return 2; /* option only */\n          }\n          else if (c == ':') {\n            OnigOptionType prev = env->options;\n\n            env->options = option;\n            r = fetch_token(tok, &p, end, env);\n            if (r < 0) return r;\n            r = parse_subexp(&target, tok, term, &p, end, env, 0);\n            env->options = prev;\n            if (r < 0) {\n              onig_node_free(target);\n              return r;\n            }\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            NODE_BODY(*np) = target;\n            *src = p;\n            return 0;\n          }\n\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n          PFETCH(c);\n        } /* while (1) */\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n#ifdef USE_CALLOUT\n  else if (c == '*' &&\n           IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME)) {\n    PINC;\n    r = parse_callout_of_name(np, ')', &p, end, env);\n    if (r != 0) return r;\n\n    goto end;\n  }\n#endif\n  else {\n    if (ONIG_IS_OPTION_ON(env->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_memory(0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    BAG_(*np)->m.regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env, 0);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  NODE_BODY(*np) = target;\n\n  if (NODE_TYPE(*np) == NODE_BAG) {\n    if (BAG_(*np)->type == BAG_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, BAG_(*np)->m.regnum, *np);\n      if (r != 0) return r;\n    }\n  }\n\n end:\n  *src = p;\n  return 0;\n}\n\nstatic const char* PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QuantNode* qn;\n\n  qn = QUANT_(qnode);\n  if (qn->lower == 1 && qn->upper == 1)\n    return 1;\n\n  switch (NODE_TYPE(target)) {\n  case NODE_STRING:\n    if (group == 0) {\n      if (str_node_can_be_split(target, env->enc)) {\n        Node* n = str_node_split_last_char(target, env->enc);\n        if (IS_NOT_NULL(n)) {\n          NODE_BODY(qnode) = n;\n          return 2;\n        }\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QuantNode* qnt   = QUANT_(target);\n      int nestq_num   = quantifier_type_num(qn);\n      int targetq_num = quantifier_type_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (targetq_num >= 0 && nestq_num >= 0 &&\n          IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n        UChar buf[WARN_BUFSIZE];\n\n        switch(ReduceTypeTable[targetq_num][nestq_num]) {\n        case RQ_ASIS:\n          break;\n\n        case RQ_DEL:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                  env->pattern, env->pattern_end,\n                                  (UChar* )\"redundant nested repeat operator\");\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n\n        default:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                       env->pattern, env->pattern_end,\n            (UChar* )\"nested repeat operator %s and %s was replaced with '%s'\",\n            PopularQStr[targetq_num], PopularQStr[nestq_num],\n            ReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n        }\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0 && nestq_num < 0) {\n        if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n          /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n          if (! IS_INFINITE_REPEAT(qn->upper) && qn->upper > 1 && qn->greedy) {\n            qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n          }\n        }\n      }\n      else {\n        NODE_BODY(qnode) = target;\n        onig_reduce_nested_quantifier(qnode, target);\n        goto q_exit;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  NODE_BODY(qnode) = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[], int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  BitSetRef bs;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  bs = cc->bs;\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n        (is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        BITSET_SET_BIT(bs, *to);\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        if (IS_NCCLASS_NOT(cc)) {\n          BITSET_CLEAR_BIT(bs, *to);\n        }\n        else\n          BITSET_SET_BIT(bs, *to);\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n        && !IS_NCCLASS_NOT(cc)\n#endif\n        ) {\n      for (i = 0; i < to_len; i++) {\n        len = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n        if (i == 0) {\n          snode = onig_node_new_str(buf, buf + len);\n          CHECK_NULL_RETURN_MEMERR(snode);\n\n          /* char-class expanded multi-char only\n             compare with string folded at match time. */\n          NODE_STRING_SET_AMBIG(snode);\n        }\n        else {\n          r = onig_node_str_cat(snode, buf, buf + len);\n          if (r < 0) {\n            onig_node_free(snode);\n            return r;\n          }\n        }\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NODE_CDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** tp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, PToken* tok, int term, UChar** src, UChar* end,\n             ScanEnv* env, int group_head)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env, group_head);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    if (IS_NULL(*top)) {\n      onig_node_free(node);\n      return ONIGERR_MEMORY;\n    }\n\n    headp = &(NODE_CDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env, 0);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n\n      if (NODE_TYPE(node) == NODE_LIST) {\n        *headp = node;\n        while (IS_NOT_NULL(NODE_CDR(node))) node = NODE_CDR(node);\n        headp = &(NODE_CDR(node));\n      }\n      else {\n        *headp = node_new_list(node, NULL);\n        headp = &(NODE_CDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, PToken* tok, int term, UChar** src, UChar* end,\n             ScanEnv* env, int group_head)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n  r = parse_branch(&node, tok, term, src, end, env, group_head);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    if (IS_NULL(*top)) {\n      onig_node_free(node);\n      return ONIGERR_MEMORY;\n    }\n\n    headp = &(NODE_CDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env, 0);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n      *headp = onig_node_new_alt(node, NULL);\n      if (IS_NULL(*headp)) {\n        onig_node_free(node);\n        onig_node_free(*top);\n        return ONIGERR_MEMORY;\n      }\n\n      headp = &(NODE_CDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  PToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env, 0);\n  if (r < 0) return r;\n\n  return 0;\n}\n\n#ifdef USE_CALL\nstatic int\nmake_call_zero_body(Node* node, ScanEnv* env, Node** rnode)\n{\n  int r;\n\n  Node* x = node_new_memory(0 /* 0: is not named */);\n  CHECK_NULL_RETURN_MEMERR(x);\n\n  NODE_BODY(x) = node;\n  BAG_(x)->m.regnum = 0;\n  r = scan_env_set_mem_node(env, 0, x);\n  if (r != 0) {\n    onig_node_free(x);\n    return r;\n  }\n\n  *rnode = x;\n  return 0;\n}\n#endif\n\nextern int\nonig_parse_tree(Node** root, const UChar* pattern, const UChar* end,\n                regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n#ifdef USE_CALLOUT\n  RegexExt* ext;\n#endif\n\n  names_clear(reg);\n\n  scan_env_clear(env);\n  env->options        = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n\n  if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, pattern, end))\n    return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n\n#ifdef USE_CALL\n  if (r != 0) return r;\n\n  if (env->has_call_zero != 0) {\n    Node* zero_node;\n    r = make_call_zero_body(*root, env, &zero_node);\n    if (r != 0) return r;\n\n    *root = zero_node;\n  }\n#endif\n\n  reg->num_mem = env->num_mem;\n\n#ifdef USE_CALLOUT\n  ext = reg->extp;\n  if (IS_NOT_NULL(ext) && ext->callout_num > 0) {\n    r = setup_ext_callout_list_values(reg);\n  }\n#endif\n\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n                               UChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n"], "fixing_code": ["/**********************************************************************\n  regparse.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n#include \"st.h\"\n\n#ifdef DEBUG_NODE_FREE\n#include <stdio.h>\n#endif\n\n#define INIT_TAG_NAMES_ALLOC_NUM   5\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n#define IS_ALLOWED_CODE_IN_CALLOUT_NAME(c) \\\n  ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_' /* || c == '!' */)\n#define IS_ALLOWED_CODE_IN_CALLOUT_TAG_NAME(c) \\\n  ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')\n\n\nOnigSyntaxType OnigSyntaxOniguruma = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_ONIGURUMA |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP |\n      ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS |\n      ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME    |\n      ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE |\n      ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT | ONIG_SYN_OP2_ESC_U_HEX4 )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP |\n      ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT | ONIG_SYN_OP2_ESC_U_HEX4 )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_ONIGURUMA;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nextern void\nonig_warning(const char* s)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  (*onig_warn)(s);\n}\n\n#define DEFAULT_MAX_CAPTURE_NUM   32767\n\nstatic int MaxCaptureNum = DEFAULT_MAX_CAPTURE_NUM;\n\nextern int\nonig_set_capture_num_limit(int num)\n{\n  if (num < 0) return -1;\n\n  MaxCaptureNum = num;\n  return 0;\n}\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\nstatic int\nbbuf_init(BBuf* buf, int size)\n{\n  if (size <= 0) {\n    size   = 0;\n    buf->p = NULL;\n  }\n  else {\n    buf->p = (UChar* )xmalloc(size);\n    if (IS_NULL(buf->p)) return(ONIGERR_MEMORY);\n  }\n\n  buf->alloc = size;\n  buf->used  = 0;\n  return 0;\n}\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\nstatic int backref_rel_to_abs(int rel_no, ScanEnv* env)\n{\n  if (rel_no > 0) {\n    return env->num_mem + rel_no;\n  }\n  else {\n    return env->num_mem + 1 + rel_no;\n  }\n}\n\n#define OPTION_ON(v,f)     ((v) |= (f))\n#define OPTION_OFF(v,f)    ((v) &= ~(f))\n\n#define OPTION_NEGATE(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, MBCODE_START_POS(enc), ~((OnigCodePoint )0))\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r != 0) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  int len = (int )(end - src);\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\nstatic int\nsave_entry(ScanEnv* env, enum SaveType type, int* id)\n{\n  int nid = env->save_num;\n\n#if 0\n  if (IS_NULL(env->saves)) {\n    int n = 10;\n    env->saves = (SaveItem* )xmalloc(sizeof(SaveItem) * n);\n    CHECK_NULL_RETURN_MEMERR(env->saves);\n    env->save_alloc_num = n;\n  }\n  else if (env->save_alloc_num <= nid) {\n    int n = env->save_alloc_num * 2;\n    SaveItem* p = (SaveItem* )xrealloc(env->saves, sizeof(SaveItem) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    env->saves = p;\n    env->save_alloc_num = n;\n  }\n\n  env->saves[nid].type = type;\n#endif\n\n  env->save_num++;\n  *id = nid;\n  return 0;\n}\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#define PFETCH_READY  UChar* pfetch_prev\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n            int capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n                        const UChar* src, const UChar* src_end, int capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\ntypedef struct {\n  UChar* s;\n  UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_str_end_key* x, st_str_end_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\nstr_end_hash(st_str_end_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n                      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n                      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  CHECK_NULL_RETURN_MEMERR(key);\n\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n\n#ifdef USE_CALLOUT\n\ntypedef struct {\n  OnigEncoding enc;\n  int    type; /* callout type: single or not */\n  UChar* s;\n  UChar* end;\n} st_callout_name_key;\n\nstatic int\ncallout_name_table_cmp(st_callout_name_key* x, st_callout_name_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if (x->enc  != y->enc)  return 1;\n  if (x->type != y->type) return 1;\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\ncallout_name_table_hash(st_callout_name_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  /* use intptr_t for escape warning in Windows */\n  return val + (val >> 5) + ((intptr_t )x->enc & 0xffff) + x->type;\n}\n\nextern hash_table_type*\nonig_st_init_callout_name_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    callout_name_table_cmp,\n    callout_name_table_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_callout_name_table(hash_table_type* table,\n                                  OnigEncoding enc,\n                                  int type,\n                                  const UChar* str_key,\n                                  const UChar* end_key,\n                                  hash_data_type *value)\n{\n  st_callout_name_key key;\n\n  key.enc  = enc;\n  key.type = type;\n  key.s    = (UChar* )str_key;\n  key.end  = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nstatic int\nst_insert_callout_name_table(hash_table_type* table,\n                             OnigEncoding enc, int type,\n                             UChar* str_key, UChar* end_key,\n                             hash_data_type value)\n{\n  st_callout_name_key* key;\n  int result;\n\n  key = (st_callout_name_key* )xmalloc(sizeof(st_callout_name_key));\n  CHECK_NULL_RETURN_MEMERR(key);\n\n  /* key->s: don't duplicate, because str_key is duped in callout_name_entry() */\n  key->enc  = enc;\n  key->type = type;\n  key->s    = str_key;\n  key->end  = end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n#endif\n\n#endif /* USE_ST_LIBRARY */\n\n\n#define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n#ifdef USE_ST_LIBRARY\n\n#define INIT_NAMES_ALLOC_NUM    5\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#define NAMEBUF_SIZE    24\n#define NAMEBUF_SIZE_1  25\n\n#ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r != 0) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n                         e->name + e->name_len,\n                         e->back_num,\n                         (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                         arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num_entries;\n  else\n    return 0;\n}\n\n#else  /* USE_ST_LIBRARY */\n\n#define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n        fputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n        fprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n        for (j = 0; j < e->back_num; j++) {\n          if (j > 0) fprintf(fp, \", \");\n          fprintf(fp, \"%d\", e->back_refs[j]);\n        }\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name       = NULL;\n        e->name_len   = 0;\n        e->back_num   = 0;\n        e->back_alloc = 0;\n        if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n        e->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r != 0) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, UChar* name, UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n                  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n#endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int r;\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(INIT_NAMES_ALLOC_NUM);\n      CHECK_NULL_RETURN_MEMERR(t);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = onigenc_strdup(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n    r = onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                              (HashDataType )e);\n    if (r < 0) return r;\n\n    e->name_len   = (int )(name_end - name);\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n#else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].back_num   = 0;\n        t->e[i].back_alloc = 0;\n        t->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = onigenc_strdup(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n#endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n                                   name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n        alloc = e->back_alloc * 2;\n        e->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n        CHECK_NULL_RETURN_MEMERR(e->back_refs);\n        e->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n                           const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n                            const UChar* name_end, OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n        if (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n          return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\nextern int\nonig_noname_group_capture_is_active(regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n\n  return 1;\n}\n\n#ifdef USE_CALLOUT\n\ntypedef struct {\n  OnigCalloutType type;\n  int             in;\n  OnigCalloutFunc start_func;\n  OnigCalloutFunc end_func;\n  int             arg_num;\n  int             opt_arg_num;\n  unsigned int    arg_types[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigValue       opt_defaults[ONIG_CALLOUT_MAX_ARGS_NUM];\n  UChar*          name; /* reference to GlobalCalloutNameTable entry: e->name */\n} CalloutNameListEntry;\n\ntypedef struct {\n  int  n;\n  int  alloc;\n  CalloutNameListEntry* v;\n} CalloutNameListType;\n\nstatic CalloutNameListType* GlobalCalloutNameList;\n\nstatic int\nmake_callout_func_list(CalloutNameListType** rs, int init_size)\n{\n  CalloutNameListType* s;\n  CalloutNameListEntry* v;\n\n  *rs = 0;\n\n  s = xmalloc(sizeof(*s));\n  if (IS_NULL(s)) return ONIGERR_MEMORY;\n\n  v = (CalloutNameListEntry* )xmalloc(sizeof(CalloutNameListEntry) * init_size);\n  if (IS_NULL(v)) {\n    xfree(s);\n    return ONIGERR_MEMORY;\n  }\n\n  s->n = 0;\n  s->alloc = init_size;\n  s->v = v;\n\n  *rs = s;\n  return ONIG_NORMAL;\n}\n\nstatic void\nfree_callout_func_list(CalloutNameListType* s)\n{\n  if (IS_NOT_NULL(s)) {\n    if (IS_NOT_NULL(s->v)) {\n      int i, j;\n\n      for (i = 0; i < s->n; i++) {\n        CalloutNameListEntry* e = s->v + i;\n        for (j = e->arg_num - e->opt_arg_num; j < e->arg_num; j++) {\n          if (e->arg_types[j] == ONIG_TYPE_STRING) {\n            UChar* p = e->opt_defaults[j].s.start;\n            if (IS_NOT_NULL(p)) xfree(p);\n          }\n        }\n      }\n      xfree(s->v);\n    }\n    xfree(s);\n  }\n}\n\nstatic int\ncallout_func_list_add(CalloutNameListType* s, int* rid)\n{\n  if (s->n >= s->alloc) {\n    int new_size = s->alloc * 2;\n    CalloutNameListEntry* nv = (CalloutNameListEntry* )\n      xrealloc(s->v, sizeof(CalloutNameListEntry) * new_size);\n    if (IS_NULL(nv)) return ONIGERR_MEMORY;\n\n    s->alloc = new_size;\n    s->v = nv;\n  }\n\n  *rid = s->n;\n\n  xmemset(&(s->v[s->n]), 0, sizeof(*(s->v)));\n  s->n++;\n  return ONIG_NORMAL;\n}\n\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    id;\n} CalloutNameEntry;\n\n#ifdef USE_ST_LIBRARY\ntypedef st_table  CalloutNameTable;\n#else\ntypedef struct {\n  CalloutNameEntry* e;\n  int               num;\n  int               alloc;\n} CalloutNameTable;\n#endif\n\nstatic CalloutNameTable* GlobalCalloutNameTable;\nstatic int CalloutNameIDCounter;\n\n#ifdef USE_ST_LIBRARY\n\nstatic int\ni_free_callout_name_entry(st_callout_name_key* key, CalloutNameEntry* e,\n                          void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  /*xfree(key->s); */ /* is same as e->name */\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\ncallout_name_table_clear(CalloutNameTable* t)\n{\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_callout_name_entry, 0);\n  }\n  return 0;\n}\n\nstatic int\nglobal_callout_name_table_free(void)\n{\n  if (IS_NOT_NULL(GlobalCalloutNameTable)) {\n    int r = callout_name_table_clear(GlobalCalloutNameTable);\n    if (r != 0) return r;\n\n    onig_st_free_table(GlobalCalloutNameTable);\n    GlobalCalloutNameTable = 0;\n    CalloutNameIDCounter = 0;\n  }\n\n  return 0;\n}\n\nstatic CalloutNameEntry*\ncallout_name_find(OnigEncoding enc, int is_not_single,\n                  const UChar* name, const UChar* name_end)\n{\n  int r;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = GlobalCalloutNameTable;\n\n  e = (CalloutNameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    r = onig_st_lookup_callout_name_table(t, enc, is_not_single, name, name_end,\n                                          (HashDataType* )((void* )(&e)));\n    if (r == 0) { /* not found */\n      if (enc != ONIG_ENCODING_ASCII &&\n          ONIGENC_IS_ASCII_COMPATIBLE_ENCODING(enc)) {\n        enc = ONIG_ENCODING_ASCII;\n        onig_st_lookup_callout_name_table(t, enc, is_not_single, name, name_end,\n                                          (HashDataType* )((void* )(&e)));\n      }\n    }\n  }\n  return e;\n}\n\n#else\n\nstatic int\ncallout_name_table_clear(CalloutNameTable* t)\n{\n  int i;\n  CalloutNameEntry* e;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name     = NULL;\n        e->name_len = 0;\n        e->id       = 0;\n        e->func     = 0;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nstatic int\nglobal_callout_name_table_free(void)\n{\n  if (IS_NOT_NULL(GlobalCalloutNameTable)) {\n    int r = callout_name_table_clear(GlobalCalloutNameTable);\n    if (r != 0) return r;\n\n    xfree(GlobalCalloutNameTable);\n    GlobalCalloutNameTable = 0;\n    CalloutNameIDCounter = 0;\n  }\n  return 0;\n}\n\nstatic CalloutNameEntry*\ncallout_name_find(UChar* name, UChar* name_end)\n{\n  int i, len;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = Calloutnames;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (CalloutNameEntry* )NULL;\n}\n\n#endif\n\n/* name string must be single byte char string. */\nstatic int\ncallout_name_entry(CalloutNameEntry** rentry, OnigEncoding enc,\n                   int is_not_single, UChar* name, UChar* name_end)\n{\n  int r;\n  CalloutNameEntry* e;\n  CalloutNameTable* t = GlobalCalloutNameTable;\n\n  *rentry = 0;\n  if (name_end - name <= 0)\n    return ONIGERR_INVALID_CALLOUT_NAME;\n\n  e = callout_name_find(enc, is_not_single, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_callout_name_table_with_size(INIT_NAMES_ALLOC_NUM);\n      CHECK_NULL_RETURN_MEMERR(t);\n      GlobalCalloutNameTable = t;\n    }\n    e = (CalloutNameEntry* )xmalloc(sizeof(CalloutNameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = onigenc_strdup(enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n\n    r = st_insert_callout_name_table(t, enc, is_not_single,\n                                     e->name, (e->name + (name_end - name)),\n                                     (HashDataType )e);\n    if (r < 0) return r;\n\n#else\n\n    int alloc;\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (CalloutNameTable* )xmalloc(sizeof(CalloutNameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (CalloutNameEntry* )xmalloc(sizeof(CalloutNameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      GlobalCalloutNameTable = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (CalloutNameEntry* )xrealloc(t->e, sizeof(CalloutNameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].id         = 0;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = onigenc_strdup(enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n#endif\n\n    CalloutNameIDCounter++;\n    e->id = CalloutNameIDCounter;\n    e->name_len = (int )(name_end - name);\n  }\n\n  *rentry = e;\n  return e->id;\n}\n\nstatic int\nis_allowed_callout_name(OnigEncoding enc, UChar* name, UChar* name_end)\n{\n  UChar* p;\n  OnigCodePoint c;\n\n  if (name >= name_end) return 0;\n\n  p = name;\n  while (p < name_end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, name_end);\n    if (! IS_ALLOWED_CODE_IN_CALLOUT_NAME(c))\n      return 0;\n\n    if (p == name) {\n      if (c >= '0' && c <= '9') return 0;\n    }\n\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n  }\n\n  return 1;\n}\n\nstatic int\nis_allowed_callout_tag_name(OnigEncoding enc, UChar* name, UChar* name_end)\n{\n  UChar* p;\n  OnigCodePoint c;\n\n  if (name >= name_end) return 0;\n\n  p = name;\n  while (p < name_end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, name_end);\n    if (! IS_ALLOWED_CODE_IN_CALLOUT_TAG_NAME(c))\n      return 0;\n\n    if (p == name) {\n      if (c >= '0' && c <= '9') return 0;\n    }\n\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n  }\n\n  return 1;\n}\n\nextern int\nonig_set_callout_of_name(OnigEncoding enc, OnigCalloutType callout_type,\n                         UChar* name, UChar* name_end, int in,\n                         OnigCalloutFunc start_func,\n                         OnigCalloutFunc end_func,\n                         int arg_num, unsigned int arg_types[],\n                         int opt_arg_num, OnigValue opt_defaults[])\n{\n  int r;\n  int i;\n  int j;\n  int id;\n  int is_not_single;\n  CalloutNameEntry* e;\n  CalloutNameListEntry* fe;\n\n  if (callout_type != ONIG_CALLOUT_TYPE_SINGLE)\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (arg_num < 0 || arg_num > ONIG_CALLOUT_MAX_ARGS_NUM)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (opt_arg_num < 0 || opt_arg_num > arg_num)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (start_func == 0 && end_func == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if ((in & ONIG_CALLOUT_IN_PROGRESS) == 0 && (in & ONIG_CALLOUT_IN_RETRACTION) == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  for (i = 0; i < arg_num; i++) {\n    unsigned int t = arg_types[i];\n    if (t == ONIG_TYPE_VOID)\n      return ONIGERR_INVALID_CALLOUT_ARG;\n    else {\n      if (i >= arg_num - opt_arg_num) {\n        if (t != ONIG_TYPE_LONG && t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING &&\n            t != ONIG_TYPE_TAG)\n          return ONIGERR_INVALID_CALLOUT_ARG;\n      }\n      else {\n        if (t != ONIG_TYPE_LONG) {\n          t = t & ~ONIG_TYPE_LONG;\n          if (t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING && t != ONIG_TYPE_TAG)\n            return ONIGERR_INVALID_CALLOUT_ARG;\n        }\n      }\n    }\n  }\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  is_not_single = (callout_type != ONIG_CALLOUT_TYPE_SINGLE);\n  id = callout_name_entry(&e, enc, is_not_single, name, name_end);\n  if (id < 0) return id;\n\n  r = ONIG_NORMAL;\n  if (IS_NULL(GlobalCalloutNameList)) {\n    r = make_callout_func_list(&GlobalCalloutNameList, 10);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  while (id >= GlobalCalloutNameList->n) {\n    int rid;\n    r = callout_func_list_add(GlobalCalloutNameList, &rid);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  fe = GlobalCalloutNameList->v + id;\n  fe->type         = callout_type;\n  fe->in           = in;\n  fe->start_func   = start_func;\n  fe->end_func     = end_func;\n  fe->arg_num      = arg_num;\n  fe->opt_arg_num  = opt_arg_num;\n  fe->name         = e->name;\n\n  for (i = 0; i < arg_num; i++) {\n    fe->arg_types[i] = arg_types[i];\n  }\n  for (i = arg_num - opt_arg_num, j = 0; i < arg_num; i++, j++) {\n    if (fe->arg_types[i] == ONIG_TYPE_STRING) {\n      OnigValue* val;\n      UChar* ds;\n\n      if (IS_NULL(opt_defaults)) return ONIGERR_INVALID_ARGUMENT;\n\n      val = opt_defaults + j;\n      ds = onigenc_strdup(enc, val->s.start, val->s.end);\n      CHECK_NULL_RETURN_MEMERR(ds);\n\n      fe->opt_defaults[i].s.start = ds;\n      fe->opt_defaults[i].s.end   = ds + (val->s.end - val->s.start);\n    }\n    else {\n      fe->opt_defaults[i] = opt_defaults[j];\n    }\n  }\n\n  r = id;\n  return r;\n}\n\nstatic int\nget_callout_name_id_by_name(OnigEncoding enc, int is_not_single,\n                            UChar* name, UChar* name_end, int* rid)\n{\n  int r;\n  CalloutNameEntry* e;\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  e = callout_name_find(enc, is_not_single, name, name_end);\n  if (IS_NULL(e)) {\n    return ONIGERR_UNDEFINED_CALLOUT_NAME;\n  }\n\n  r = ONIG_NORMAL;\n  *rid = e->id;\n\n  return r;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_start_func(regex_t* reg, int callout_num)\n{\n  /* If used for callouts of contents, return 0. */\n  CalloutListEntry* e;\n\n  e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->start_func;\n}\n\nextern const UChar*\nonig_get_callout_tag_start(regex_t* reg, int callout_num)\n{\n  CalloutListEntry* e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->tag_start;\n}\n\nextern const UChar*\nonig_get_callout_tag_end(regex_t* reg, int callout_num)\n{\n  CalloutListEntry* e = onig_reg_callout_list_at(reg, callout_num);\n  CHECK_NULL_RETURN(e);\n  return e->tag_end;\n}\n\n\nextern OnigCalloutType\nonig_get_callout_type_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].type;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_start_func_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].start_func;\n}\n\nextern OnigCalloutFunc\nonig_get_callout_end_func_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].end_func;\n}\n\nextern int\nonig_get_callout_in_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].in;\n}\n\nstatic int\nget_callout_arg_num_by_name_id(int name_id)\n{\n  return GlobalCalloutNameList->v[name_id].arg_num;\n}\n\nstatic int\nget_callout_opt_arg_num_by_name_id(int name_id)\n{\n  return GlobalCalloutNameList->v[name_id].opt_arg_num;\n}\n\nstatic unsigned int\nget_callout_arg_type_by_name_id(int name_id, int index)\n{\n  return GlobalCalloutNameList->v[name_id].arg_types[index];\n}\n\nstatic OnigValue\nget_callout_opt_default_by_name_id(int name_id, int index)\n{\n  return GlobalCalloutNameList->v[name_id].opt_defaults[index];\n}\n\nextern UChar*\nonig_get_callout_name_by_name_id(int name_id)\n{\n  if (name_id < 0 || name_id >= GlobalCalloutNameList->n)\n    return 0;\n\n  return GlobalCalloutNameList->v[name_id].name;\n}\n\nextern int\nonig_global_callout_names_free(void)\n{\n  free_callout_func_list(GlobalCalloutNameList);\n  GlobalCalloutNameList = 0;\n\n  global_callout_name_table_free();\n  return ONIG_NORMAL;\n}\n\n\ntypedef st_table   CalloutTagTable;\ntypedef intptr_t   CalloutTagVal;\n\n#define CALLOUT_TAG_LIST_FLAG_TAG_EXIST     (1<<0)\n\nstatic int\ni_callout_callout_list_set(UChar* key, CalloutTagVal e, void* arg)\n{\n  int num;\n  RegexExt* ext = (RegexExt* )arg;\n\n  num = (int )e - 1;\n  ext->callout_list[num].flag |= CALLOUT_TAG_LIST_FLAG_TAG_EXIST;\n  return ST_CONTINUE;\n}\n\nstatic int\nsetup_ext_callout_list_values(regex_t* reg)\n{\n  int i, j;\n  RegexExt* ext;\n\n  ext = reg->extp;\n  if (IS_NOT_NULL(ext->tag_table)) {\n    onig_st_foreach((CalloutTagTable *)ext->tag_table, i_callout_callout_list_set,\n                    (st_data_t )ext);\n  }\n\n  for (i = 0; i < ext->callout_num; i++) {\n    CalloutListEntry* e = ext->callout_list + i;\n    if (e->of == ONIG_CALLOUT_OF_NAME) {\n      for (j = 0; j < e->u.arg.num; j++) {\n        if (e->u.arg.types[j] == ONIG_TYPE_TAG) {\n          UChar* start;\n          UChar* end;\n          int num;\n          start = e->u.arg.vals[j].s.start;\n          end   = e->u.arg.vals[j].s.end;\n          num = onig_get_callout_num_by_tag(reg, start, end);\n          if (num < 0) return num;\n          e->u.arg.vals[j].tag = num;\n        }\n      }\n    }\n  }\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)\n{\n  RegexExt* ext = reg->extp;\n\n  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;\n  if (callout_num > ext->callout_num) return 0;\n\n  return (ext->callout_list[callout_num].flag &\n          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0;\n}\n\nstatic int\ni_free_callout_tag_entry(UChar* key, CalloutTagVal e, void* arg ARG_UNUSED)\n{\n  xfree(key);\n  return ST_DELETE;\n}\n\nstatic int\ncallout_tag_table_clear(CalloutTagTable* t)\n{\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_callout_tag_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_callout_tag_table_free(void* table)\n{\n  CalloutTagTable* t = (CalloutTagTable* )table;\n\n  if (IS_NOT_NULL(t)) {\n    int r = callout_tag_table_clear(t);\n    if (r != 0) return r;\n\n    onig_st_free_table(t);\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_callout_num_by_tag(regex_t* reg,\n                            const UChar* tag, const UChar* tag_end)\n{\n  int r;\n  RegexExt* ext;\n  CalloutTagVal e;\n\n  ext = reg->extp;\n  if (IS_NULL(ext) || IS_NULL(ext->tag_table))\n    return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  r = onig_st_lookup_strend(ext->tag_table, tag, tag_end,\n                            (HashDataType* )((void* )(&e)));\n  if (r == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n  return (int )e;\n}\n\nstatic CalloutTagVal\ncallout_tag_find(CalloutTagTable* t, const UChar* name, const UChar* name_end)\n{\n  CalloutTagVal e;\n\n  e = -1;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\nstatic int\ncallout_tag_table_new(CalloutTagTable** rt)\n{\n  CalloutTagTable* t;\n\n  *rt = 0;\n  t = onig_st_init_strend_table_with_size(INIT_TAG_NAMES_ALLOC_NUM);\n  CHECK_NULL_RETURN_MEMERR(t);\n\n  *rt = t;\n  return ONIG_NORMAL;\n}\n\nstatic int\ncallout_tag_entry_raw(CalloutTagTable* t, UChar* name, UChar* name_end,\n                      CalloutTagVal entry_val)\n{\n  int r;\n  CalloutTagVal val;\n\n  if (name_end - name <= 0)\n    return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  val = callout_tag_find(t, name, name_end);\n  if (val >= 0)\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n\n  r = onig_st_insert_strend(t, name, name_end, (HashDataType )entry_val);\n  if (r < 0) return r;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\next_ensure_tag_table(regex_t* reg)\n{\n  int r;\n  RegexExt* ext;\n  CalloutTagTable* t;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  if (IS_NULL(ext->tag_table)) {\n    r = callout_tag_table_new(&t);\n    if (r != ONIG_NORMAL) return r;\n\n    ext->tag_table = t;\n  }\n\n  return ONIG_NORMAL;\n}\n\nstatic int\ncallout_tag_entry(regex_t* reg, UChar* name, UChar* name_end,\n                  CalloutTagVal entry_val)\n{\n  int r;\n  RegexExt* ext;\n  CalloutListEntry* e;\n\n  r = ext_ensure_tag_table(reg);\n  if (r != ONIG_NORMAL) return r;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  r = callout_tag_entry_raw(ext->tag_table, name, name_end, entry_val);\n\n  e = onig_reg_callout_list_at(reg, (int )entry_val);\n  CHECK_NULL_RETURN_MEMERR(e);\n  e->tag_start = name;\n  e->tag_end   = name_end;\n\n  return r;\n}\n\n#endif /* USE_CALLOUT */\n\n\n#define INIT_SCANENV_MEMENV_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  MEM_STATUS_CLEAR(env->capture_history);\n  MEM_STATUS_CLEAR(env->bt_mem_start);\n  MEM_STATUS_CLEAR(env->bt_mem_end);\n  MEM_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n\n#ifdef USE_CALL\n  env->unset_addr_list = NULL;\n  env->has_call_zero   = 0;\n#endif\n\n  env->num_mem    = 0;\n  env->num_named  = 0;\n  env->mem_alloc  = 0;\n  env->mem_env_dynamic = (MemEnv* )NULL;\n\n  xmemset(env->mem_env_static, 0, sizeof(env->mem_env_static));\n\n  env->parse_depth         = 0;\n  env->keep_num            = 0;\n  env->save_num            = 0;\n  env->save_alloc_num      = 0;\n  env->saves               = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  MemEnv* p;\n\n  need = env->num_mem + 1;\n  if (need > MaxCaptureNum && MaxCaptureNum != 0)\n    return ONIGERR_TOO_MANY_CAPTURES;\n\n  if (need >= SCANENV_MEMENV_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_env_dynamic)) {\n        alloc = INIT_SCANENV_MEMENV_ALLOC_SIZE;\n        p = (MemEnv* )xmalloc(sizeof(MemEnv) * alloc);\n        CHECK_NULL_RETURN_MEMERR(p);\n        xmemcpy(p, env->mem_env_static, sizeof(env->mem_env_static));\n      }\n      else {\n        alloc = env->mem_alloc * 2;\n        p = (MemEnv* )xrealloc(env->mem_env_dynamic, sizeof(MemEnv) * alloc);\n        CHECK_NULL_RETURN_MEMERR(p);\n      }\n\n      for (i = env->num_mem + 1; i < alloc; i++) {\n        p[i].node = NULL_NODE;\n#if 0\n        p[i].in   = 0;\n        p[i].recursion = 0;\n#endif\n      }\n\n      env->mem_env_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEMENV(env)[num].node = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"onig_node_free: %p\\n\", node);\n#endif\n\n  switch (NODE_TYPE(node)) {\n  case NODE_STRING:\n    if (STR_(node)->capacity != 0 &&\n        IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n      xfree(STR_(node)->s);\n    }\n    break;\n\n  case NODE_LIST:\n  case NODE_ALT:\n    onig_node_free(NODE_CAR(node));\n    {\n      Node* next_node = NODE_CDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      CClassNode* cc = CCLASS_(node);\n\n      if (cc->mbuf)\n        bbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NODE_BACKREF:\n    if (IS_NOT_NULL(BACKREF_(node)->back_dynamic))\n      xfree(BACKREF_(node)->back_dynamic);\n    break;\n\n  case NODE_BAG:\n    if (NODE_BODY(node))\n      onig_node_free(NODE_BODY(node));\n\n    {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_IF_ELSE) {\n        onig_node_free(en->te.Then);\n        onig_node_free(en->te.Else);\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n  case NODE_ANCHOR:\n    if (NODE_BODY(node))\n      onig_node_free(NODE_BODY(node));\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CALL:\n  case NODE_GIMMICK:\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic void\ncons_node_free_alone(Node* node)\n{\n  NODE_CAR(node) = 0;\n  NODE_CDR(node) = 0;\n  onig_node_free(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  CHECK_NULL_RETURN(node);\n  xmemset(node, 0, sizeof(*node));\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}\n\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CCLASS);\n  initialize_cclass(CCLASS_(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not, OnigOptionType options)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CTYPE);\n  CTYPE_(node)->ctype   = type;\n  CTYPE_(node)->not     = not;\n  CTYPE_(node)->options = options;\n  CTYPE_(node)->ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(type, options);\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}\n\nstatic Node*\nnode_new_anychar_with_fixed_option(OnigOptionType option)\n{\n  CtypeNode* ct;\n  Node* node;\n\n  node = node_new_anychar();\n  CHECK_NULL_RETURN(node);\n\n  ct = CTYPE_(node);\n  ct->options = option;\n  NODE_STATUS_ADD(node, FIXED_OPTION);\n  return node;\n}\n\nstatic int\nnode_new_no_newline(Node** node, ScanEnv* env)\n{\n  Node* n;\n\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_NONE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}\n\nstatic int\nnode_new_true_anychar(Node** node, ScanEnv* env)\n{\n  Node* n;\n\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_MULTILINE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_LIST);\n  NODE_CAR(node)  = left;\n  NODE_CDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NODE_CDR(list)))\n      list = NODE_CDR(list);\n\n    NODE_CDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_ALT);\n  NODE_CAR(node)  = left;\n  NODE_CDR(node) = right;\n  return node;\n}\n\nstatic Node*\nmake_list_or_alt(NodeType type, int n, Node* ns[])\n{\n  Node* r;\n\n  if (n <= 0) return NULL_NODE;\n\n  if (n == 1) {\n    r = node_new();\n    CHECK_NULL_RETURN(r);\n    NODE_SET_TYPE(r, type);\n    NODE_CAR(r) = ns[0];\n    NODE_CDR(r) = NULL_NODE;\n  }\n  else {\n    Node* right;\n\n    r = node_new();\n    CHECK_NULL_RETURN(r);\n\n    right = make_list_or_alt(type, n - 1, ns + 1);\n    if (IS_NULL(right)) {\n      onig_node_free(r);\n      return NULL_NODE;\n    }\n\n    NODE_SET_TYPE(r, type);\n    NODE_CAR(r) = ns[0];\n    NODE_CDR(r) = right;\n  }\n\n  return r;\n}\n\nstatic Node*\nmake_list(int n, Node* ns[])\n{\n  return make_list_or_alt(NODE_LIST, n, ns);\n}\n\nstatic Node*\nmake_alt(int n, Node* ns[])\n{\n  return make_list_or_alt(NODE_ALT, n, ns);\n}\n\nextern Node*\nonig_node_new_anchor(int type, int ascii_mode)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_ANCHOR);\n  ANCHOR_(node)->type       = type;\n  ANCHOR_(node)->char_len   = -1;\n  ANCHOR_(node)->ascii_mode = ascii_mode;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                 int exist_level, int nest_level,\n#endif\n                 ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_BACKREF);\n  BACKREF_(node)->back_num = back_num;\n  BACKREF_(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NODE_STATUS_ADD(node, BY_NAME);\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NODE_STATUS_ADD(node, NEST_LEVEL);\n    BACKREF_(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n        IS_NULL(SCANENV_MEMENV(env)[backrefs[i]].node)) {\n      NODE_STATUS_ADD(node, RECURSION);   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      BACKREF_(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    BACKREF_(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\nstatic Node*\nnode_new_backref_checker(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                         int exist_level, int nest_level,\n#endif\n                         ScanEnv* env)\n{\n  Node* node;\n\n  node = node_new_backref(back_num, backrefs, by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                          exist_level, nest_level,\n#endif\n                          env);\n  CHECK_NULL_RETURN(node);\n\n  NODE_STATUS_ADD(node, CHECKER);\n  return node;\n}\n\n#ifdef USE_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_CALL);\n  CALL_(node)->by_number   = by_number;\n  CALL_(node)->name        = name;\n  CALL_(node)->name_end    = name_end;\n  CALL_(node)->group_num   = gnum;\n  CALL_(node)->entry_count = 1;\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_QUANT);\n  QUANT_(node)->lower           = lower;\n  QUANT_(node)->upper           = upper;\n  QUANT_(node)->greedy          = 1;\n  QUANT_(node)->emptiness       = BODY_IS_NOT_EMPTY;\n  QUANT_(node)->head_exact      = NULL_NODE;\n  QUANT_(node)->next_head_exact = NULL_NODE;\n  QUANT_(node)->is_refered      = 0;\n  if (by_number != 0)\n    NODE_STATUS_ADD(node, BY_NUMBER);\n\n  return node;\n}\n\nstatic Node*\nnode_new_bag(enum BagType type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_BAG);\n  BAG_(node)->type = type;\n\n  switch (type) {\n  case BAG_MEMORY:\n    BAG_(node)->m.regnum       =  0;\n    BAG_(node)->m.called_addr  = -1;\n    BAG_(node)->m.entry_count  =  1;\n    BAG_(node)->m.called_state =  0;\n    break;\n\n  case BAG_OPTION:\n    BAG_(node)->o.options =  0;\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    break;\n\n  case BAG_IF_ELSE:\n    BAG_(node)->te.Then = 0;\n    BAG_(node)->te.Else = 0;\n    break;\n  }\n\n  BAG_(node)->opt_count = 0;\n  return node;\n}\n\nextern Node*\nonig_node_new_bag(enum BagType type)\n{\n  return node_new_bag(type);\n}\n\nstatic Node*\nnode_new_bag_if_else(Node* cond, Node* Then, Node* Else)\n{\n  Node* n;\n  n = node_new_bag(BAG_IF_ELSE);\n  CHECK_NULL_RETURN(n);\n\n  NODE_BODY(n) = cond;\n  BAG_(n)->te.Then = Then;\n  BAG_(n)->te.Else = Else;\n  return n;\n}\n\nstatic Node*\nnode_new_memory(int is_named)\n{\n  Node* node = node_new_bag(BAG_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    NODE_STATUS_ADD(node, NAMED_GROUP);\n\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_bag(BAG_OPTION);\n  CHECK_NULL_RETURN(node);\n  BAG_(node)->o.options = option;\n  return node;\n}\n\nstatic Node*\nnode_new_group(Node* content)\n{\n  Node* node;\n\n  node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_LIST);\n  NODE_CAR(node) = content;\n  NODE_CDR(node) = NULL_NODE;\n\n  return node;\n}\n\nstatic Node*\nnode_drop_group(Node* group)\n{\n  Node* content;\n\n  content = NODE_CAR(group);\n  NODE_CAR(group) = NULL_NODE;\n  onig_node_free(group);\n  return content;\n}\n\nstatic int\nnode_new_fail(Node** node, ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->type = GIMMICK_FAIL;\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_save_gimmick(Node** node, enum SaveType save_type, ScanEnv* env)\n{\n  int id;\n  int r;\n\n  r = save_entry(env, save_type, &id);\n  if (r != ONIG_NORMAL) return r;\n\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id   = id;\n  GIMMICK_(*node)->type = GIMMICK_SAVE;\n  GIMMICK_(*node)->detail_type = (int )save_type;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_update_var_gimmick(Node** node, enum UpdateVarType update_var_type,\n                            int id, ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id   = id;\n  GIMMICK_(*node)->type = GIMMICK_UPDATE_VAR;\n  GIMMICK_(*node)->detail_type = (int )update_var_type;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_keep(Node** node, ScanEnv* env)\n{\n  int r;\n\n  r = node_new_save_gimmick(node, SAVE_KEEP, env);\n  if (r != 0) return r;\n\n  env->keep_num++;\n  return ONIG_NORMAL;\n}\n\n#ifdef USE_CALLOUT\n\nextern void\nonig_free_reg_callout_list(int n, CalloutListEntry* list)\n{\n  int i;\n  int j;\n\n  if (IS_NULL(list)) return ;\n\n  for (i = 0; i < n; i++) {\n    if (list[i].of == ONIG_CALLOUT_OF_NAME) {\n      for (j = 0; j < list[i].u.arg.passed_num; j++) {\n        if (list[i].u.arg.types[j] == ONIG_TYPE_STRING) {\n          if (IS_NOT_NULL(list[i].u.arg.vals[j].s.start))\n            xfree(list[i].u.arg.vals[j].s.start);\n        }\n      }\n    }\n    else { /* ONIG_CALLOUT_OF_CONTENTS */\n      if (IS_NOT_NULL(list[i].u.content.start)) {\n        xfree((void* )list[i].u.content.start);\n      }\n    }\n  }\n\n  xfree(list);\n}\n\nextern CalloutListEntry*\nonig_reg_callout_list_at(regex_t* reg, int num)\n{\n  RegexExt* ext = reg->extp;\n  CHECK_NULL_RETURN(ext);\n\n  if (num <= 0 || num > ext->callout_num)\n    return 0;\n\n  num--;\n  return ext->callout_list + num;\n}\n\nstatic int\nreg_callout_list_entry(ScanEnv* env, int* rnum)\n{\n#define INIT_CALLOUT_LIST_NUM  3\n\n  int num;\n  CalloutListEntry* list;\n  CalloutListEntry* e;\n  RegexExt* ext;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  if (IS_NULL(ext->callout_list)) {\n    list = (CalloutListEntry* )xmalloc(sizeof(*list) * INIT_CALLOUT_LIST_NUM);\n    CHECK_NULL_RETURN_MEMERR(list);\n\n    ext->callout_list = list;\n    ext->callout_list_alloc = INIT_CALLOUT_LIST_NUM;\n    ext->callout_num = 0;\n  }\n\n  num = ext->callout_num + 1;\n  if (num > ext->callout_list_alloc) {\n    int alloc = ext->callout_list_alloc * 2;\n    list = (CalloutListEntry* )xrealloc(ext->callout_list,\n                                        sizeof(CalloutListEntry) * alloc);\n    CHECK_NULL_RETURN_MEMERR(list);\n\n    ext->callout_list       = list;\n    ext->callout_list_alloc = alloc;\n  }\n\n  e = ext->callout_list + (num - 1);\n\n  e->flag             = 0;\n  e->of               = 0;\n  e->in               = ONIG_CALLOUT_OF_CONTENTS;\n  e->type             = 0;\n  e->tag_start        = 0;\n  e->tag_end          = 0;\n  e->start_func       = 0;\n  e->end_func         = 0;\n  e->u.arg.num        = 0;\n  e->u.arg.passed_num = 0;\n\n  ext->callout_num = num;\n  *rnum = num;\n  return ONIG_NORMAL;\n}\n\nstatic int\nnode_new_callout(Node** node, OnigCalloutOf callout_of, int num, int id,\n                 ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id          = id;\n  GIMMICK_(*node)->num         = num;\n  GIMMICK_(*node)->type        = GIMMICK_CALLOUT;\n  GIMMICK_(*node)->detail_type = (int )callout_of;\n\n  return ONIG_NORMAL;\n}\n#endif\n\nstatic int\nmake_text_segment(Node** node, ScanEnv* env)\n{\n  int r;\n  int i;\n  Node* x;\n  Node* ns[2];\n\n  /* \\X == (?>\\O(?:\\Y\\O)*) */\n\n  ns[1] = NULL_NODE;\n\n  r = ONIGERR_MEMORY;\n  ns[0] = onig_node_new_anchor(ANCR_NO_TEXT_SEGMENT_BOUNDARY, 0);\n  if (IS_NULL(ns[0])) goto err;\n\n  r = node_new_true_anychar(&ns[1], env);\n  if (r != 0) goto err1;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err;\n  ns[0] = x;\n  ns[1] = NULL_NODE;\n\n  x = node_new_quantifier(0, INFINITE_REPEAT, 1);\n  if (IS_NULL(x)) goto err;\n\n  NODE_BODY(x) = ns[0];\n  ns[0] = NULL_NODE;\n  ns[1] = x;\n\n  r = node_new_true_anychar(&ns[0], env);\n  if (r != 0) goto err1;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err;\n\n  ns[0] = x;\n  ns[1] = NULL_NODE;\n\n  x = node_new_bag(BAG_STOP_BACKTRACK);\n  if (IS_NULL(x)) goto err;\n\n  NODE_BODY(x) = ns[0];\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err:\n  r = ONIGERR_MEMORY;\n err1:\n  for (i = 0; i < 2; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n\n  ns[1] = absent;\n  ns[3] = step_one; /* for err */\n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n\n  if (possessive != 0) {\n    x = node_new_bag(BAG_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n\n  ns[1] = x; ns[2] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, SUPER);\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_tail(Node** node1, Node** node2, int pre_save_right_id,\n                 ScanEnv* env)\n{\n  int r;\n  int id;\n  Node* save;\n  Node* x;\n  Node* ns[2];\n\n  *node1 = *node2 = NULL_NODE;\n  save = ns[0] = ns[1] = NULL_NODE;\n\n  r = node_new_save_gimmick(&save, SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(save)->id;\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[1], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = NULL_NODE; ns[1] = x;\n\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node1 = save;\n  *node2 = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  onig_node_free(save);\n  onig_node_free(ns[0]);\n  onig_node_free(ns[1]);\n  return r;\n}\n\nstatic int\nmake_range_clear(Node** node, ScanEnv* env)\n{\n  int r;\n  int id;\n  Node* save;\n  Node* x;\n  Node* ns[2];\n\n  *node = NULL_NODE;\n  save = ns[0] = ns[1] = NULL_NODE;\n\n  r = node_new_save_gimmick(&save, SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(save)->id;\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[1], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = NULL_NODE; ns[1] = x;\n\n  r = node_new_update_var_gimmick(&ns[0], UPDATE_VAR_RIGHT_RANGE_INIT, 0, env);\n  if (r != 0) goto err;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  NODE_STATUS_ADD(x, SUPER);\n\n  ns[0] = save;\n  ns[1] = x;\n  save = NULL_NODE;\n  x = make_list(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  onig_node_free(save);\n  onig_node_free(ns[0]);\n  onig_node_free(ns[1]);\n  return r;\n}\n\nstatic int\nis_simple_one_char_repeat(Node* node, Node** rquant, Node** rbody,\n                          int* is_possessive, ScanEnv* env)\n{\n  Node* quant;\n  Node* body;\n\n  *rquant = *rbody = 0;\n  *is_possessive = 0;\n\n  if (NODE_TYPE(node) == NODE_QUANT) {\n    quant = node;\n  }\n  else {\n    if (NODE_TYPE(node) == NODE_BAG) {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_STOP_BACKTRACK) {\n        *is_possessive = 1;\n        quant = NODE_BAG_BODY(en);\n        if (NODE_TYPE(quant) != NODE_QUANT)\n          return 0;\n      }\n      else\n        return 0;\n    }\n    else\n      return 0;\n  }\n\n  if (QUANT_(quant)->greedy == 0)\n    return 0;\n\n  body = NODE_BODY(quant);\n  switch (NODE_TYPE(body)) {\n  case NODE_STRING:\n    {\n      int len;\n      StrNode* sn = STR_(body);\n      UChar *s = sn->s;\n\n      len = 0;\n      while (s < sn->end) {\n        s += enclen(env->enc, s);\n        len++;\n      }\n      if (len != 1)\n        return 0;\n    }\n\n  case NODE_CCLASS:\n    break;\n\n  default:\n    return 0;\n    break;\n  }\n\n  if (node != quant) {\n    NODE_BODY(node) = 0;\n    onig_node_free(node);\n  }\n  NODE_BODY(quant) = NULL_NODE;\n  *rquant = quant;\n  *rbody  = body;\n  return 1;\n}\n\nstatic int\nmake_absent_tree_for_simple_one_char_repeat(Node** node, Node* absent, Node* quant,\n                                            Node* body, int possessive, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id1;\n  int lower, upper;\n  Node* x;\n  Node* ns[4];\n\n  *node = NULL_NODE;\n  r = ONIGERR_MEMORY;\n  ns[0] = ns[1] = NULL_NODE;\n  ns[2] = body, ns[3] = absent;\n\n  lower = QUANT_(quant)->lower;\n  upper = QUANT_(quant)->upper;\n  onig_node_free(quant);\n\n  r = node_new_save_gimmick(&ns[0], SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id1 = GIMMICK_(ns[0])->id;\n\n  r = make_absent_engine(&ns[1], id1, absent, body, lower, upper, possessive,\n                         0, env);\n  if (r != 0) goto err;\n\n  ns[2] = ns[3] = NULL_NODE;\n\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  id1, env);\n  if (r != 0) goto err;\n\n  x = make_list(3, ns);\n  if (IS_NULL(x)) goto err0;\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nstatic int\nmake_absent_tree(Node** node, Node* absent, Node* expr, int is_range_cutter,\n                 ScanEnv* env)\n{\n  int r;\n  int i;\n  int id1, id2;\n  int possessive;\n  Node* x;\n  Node* ns[7];\n\n  r = ONIGERR_MEMORY;\n  for (i = 0; i < 7; i++) ns[i] = NULL_NODE;\n  ns[4] = expr; ns[5] = absent;\n\n  if (is_range_cutter == 0) {\n    Node* quant;\n    Node* body;\n\n    if (expr == NULL_NODE) {\n      /* default expr \\O* */\n      quant = node_new_quantifier(0, INFINITE_REPEAT, 0);\n      if (IS_NULL(quant)) goto err0;\n\n      r = node_new_true_anychar(&body, env);\n      if (r != 0) {\n        onig_node_free(quant);\n        goto err;\n      }\n      possessive = 0;\n      goto simple;\n    }\n    else {\n      if (is_simple_one_char_repeat(expr, &quant, &body, &possessive, env)) {\n      simple:\n        r = make_absent_tree_for_simple_one_char_repeat(node, absent, quant,\n                                                        body, possessive, env);\n        if (r != 0) {\n          ns[4] = NULL_NODE;\n          onig_node_free(quant);\n          onig_node_free(body);\n          goto err;\n        }\n\n        return ONIG_NORMAL;\n      }\n    }\n  }\n\n  r = node_new_save_gimmick(&ns[0], SAVE_RIGHT_RANGE, env);\n  if (r != 0) goto err;\n\n  id1 = GIMMICK_(ns[0])->id;\n\n  r = node_new_save_gimmick(&ns[1], SAVE_S, env);\n  if (r != 0) goto err;\n\n  id2 = GIMMICK_(ns[1])->id;\n\n  r = node_new_true_anychar(&ns[3], env);\n  if (r != 0) goto err;\n\n  possessive = 1;\n  r = make_absent_engine(&ns[2], id1, absent, ns[3], 0, INFINITE_REPEAT,\n                         possessive, is_range_cutter, env);\n  if (r != 0) goto err;\n\n  ns[3] = NULL_NODE;\n  ns[5] = NULL_NODE;\n\n  r = node_new_update_var_gimmick(&ns[3], UPDATE_VAR_S_FROM_STACK, id2, env);\n  if (r != 0) goto err;\n\n  if (is_range_cutter != 0) {\n    x = make_list(4, ns);\n    if (IS_NULL(x)) goto err0;\n  }\n  else {\n    r = make_absent_tail(&ns[5], &ns[6], id1, env);\n    if (r != 0) goto err;\n\n    x = make_list(7, ns);\n    if (IS_NULL(x)) goto err0;\n  }\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 7; i++) onig_node_free(ns[i]);\n  return r;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  int addlen = (int )(end - s);\n\n  if (addlen > 0) {\n    int len  = (int )(STR_(node)->end - STR_(node)->s);\n\n    if (STR_(node)->capacity > 0 || (len + addlen > NODE_STRING_BUF_SIZE - 1)) {\n      UChar* p;\n      int capa = len + addlen + NODE_STRING_MARGIN;\n\n      if (capa <= STR_(node)->capacity) {\n        onig_strcpy(STR_(node)->s + len, s, end);\n      }\n      else {\n        if (STR_(node)->s == STR_(node)->buf)\n          p = strcat_capa_from_static(STR_(node)->s, STR_(node)->end,\n                                      s, end, capa);\n        else\n          p = strcat_capa(STR_(node)->s, STR_(node)->end, s, end, capa);\n\n        CHECK_NULL_RETURN_MEMERR(p);\n        STR_(node)->s        = p;\n        STR_(node)->capacity = capa;\n      }\n    }\n    else {\n      onig_strcpy(STR_(node)->s + len, s, end);\n    }\n    STR_(node)->end = STR_(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  NODE_SET_TYPE(node, NODE_STRING);\n  STR_(node)->flag     = flag;\n  STR_(node)->capacity = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n}\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (STR_(node)->capacity != 0 &&\n      IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n    xfree(STR_(node)->s);\n  }\n\n  STR_(node)->capacity = 0;\n  STR_(node)->flag     = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  NODE_SET_TYPE(node, NODE_STRING);\n  STR_(node)->capacity = 0;\n  STR_(node)->flag     = 0;\n  STR_(node)->s        = STR_(node)->buf;\n  STR_(node)->end      = STR_(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  CHECK_NULL_RETURN(node);\n  NODE_STRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  int i;\n  UChar p[1];\n  Node* node;\n\n  p[0] = c;\n  node = node_new_str_raw(p, p + 1);\n\n  /* clear buf tail */\n  for (i = 1; i < NODE_STRING_BUF_SIZE; i++)\n    STR_(node)->buf[i] = '\\0';\n\n  return node;\n}\n\nstatic Node*\nstr_node_split_last_char(Node* node, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* rn;\n  StrNode* sn;\n\n  sn = STR_(node);\n  rn = NULL_NODE;\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      rn = node_new_str(p, sn->end);\n      CHECK_NULL_RETURN(rn);\n      if (NODE_STRING_IS_RAW(node))\n        NODE_STRING_SET_RAW(rn);\n\n      sn->end = (UChar* )p;\n    }\n  }\n  return rn;\n}\n\nstatic int\nstr_node_can_be_split(Node* node, OnigEncoding enc)\n{\n  StrNode* sn = STR_(node);\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND) {\n    PFETCH(c);\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n        return -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int minlen,\n                                 int maxlen, OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  int n;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  n = 0;\n  while (! PEND && n < maxlen) {\n    PFETCH(c);\n    if (IS_CODE_XDIGIT_ASCII(enc, c)) {\n      n++;\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n        return ONIGERR_TOO_BIG_NUMBER; /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n\n  if (n < minlen)\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n                           OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (IS_CODE_DIGIT_ASCII(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BB_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BB_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(bbuf);\n  r = BB_INIT(bbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r != 0) {\n    xfree(bbuf);\n    *pbuf = 0;\n    return r;\n  }\n\n  n = 0;\n  BB_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, OnigCodePoint from, OnigCodePoint to)\n{\n  int r, inc_n, pos;\n  int low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r != 0) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  for (low = 0, bound = n; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ~((OnigCodePoint )0)) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0 && (OnigCodePoint )high < n) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n    int size = (n - high) * 2 * SIZE_CODE_POINT;\n\n    if (inc_n > 0) {\n      BB_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n    }\n    else {\n      BB_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BB_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BB_WRITE_CODE_POINT(bbuf, pos, from);\n  BB_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BB_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf(pbuf, from, to);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ~((OnigCodePoint )0)) break;\n    pre = to + 1;\n  }\n  if (to < ~((OnigCodePoint )0)) {\n    r = add_code_range_to_buf(pbuf, to + 1, ~((OnigCodePoint )0));\n  }\n  return r;\n}\n\n#define SWAP_BB_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n        return bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n        return not_code_range_buf(enc, bbuf2, pbuf);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, OnigCodePoint from1, OnigCodePoint to1,\n                OnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n        from1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n        if (from1 <= from2 - 1) {\n          r = add_code_range_to_buf(pbuf, from1, from2-1);\n          if (r != 0) return r;\n        }\n        from1 = to2 + 1;\n      }\n      else {\n        to1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BB_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n        from2 = data2[j*2];\n        to2   = data2[j*2+1];\n        if (from2 > to1) break;\n        if (to2 < from1) continue;\n        from = MAX(from1, from2);\n        to   = MIN(to1, to2);\n        r = add_code_range_to_buf(pbuf, from, to);\n        if (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n        return '\\v';\n      break;\n\n    default:\n      break;\n    }\n  }\n  return c;\n}\n\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n    return 1;\n    break;\n\n  case NODE_BAG:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NODE_BODY(node)); */\n    break;\n\n  case NODE_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NODE_CAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    return 0;\n    break;\n\n  case NODE_ALT:\n    do {\n      if (is_invalid_quantifier_target(NODE_CAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\nquantifier_type_num(QuantNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_INFINITE_REPEAT(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_INFINITE_REPEAT(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_INFINITE_REPEAT(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_INFINITE_REPEAT(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType ReduceTypeTable[6][6] = {\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QuantNode *p, *c;\n\n  p = QUANT_(pnode);\n  c = QUANT_(cnode);\n  pnum = quantifier_type_num(p);\n  cnum = quantifier_type_num(c);\n  if (pnum < 0 || cnum < 0) {\n    if ((p->lower == p->upper) && ! IS_INFINITE_REPEAT(p->upper)) {\n      if ((c->lower == c->upper) && ! IS_INFINITE_REPEAT(c->upper)) {\n        int n = onig_positive_int_multiply(p->lower, c->lower);\n        if (n >= 0) {\n          p->lower = p->upper = n;\n          NODE_BODY(pnode) = NODE_BODY(cnode);\n          goto remove_cnode;\n        }\n      }\n    }\n\n    return ;\n  }\n\n  switch(ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = INFINITE_REPEAT;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = INFINITE_REPEAT;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    NODE_BODY(pnode) = NODE_BODY(cnode);\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    NODE_BODY(pnode) = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = INFINITE_REPEAT;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    NODE_BODY(pnode) = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = INFINITE_REPEAT;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    NODE_BODY(pnode) = cnode;\n    return ;\n    break;\n  }\n\n remove_cnode:\n  NODE_BODY(cnode) = NULL_NODE;\n  onig_node_free(cnode);\n}\n\nstatic int\nnode_new_general_newline(Node** node, ScanEnv* env)\n{\n  int r;\n  int dlen, alen;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n  Node* crnl;\n  Node* ncc;\n  Node* x;\n  CClassNode* cc;\n\n  dlen = ONIGENC_CODE_TO_MBC(env->enc, 0x0d, buf);\n  if (dlen < 0) return dlen;\n  alen = ONIGENC_CODE_TO_MBC(env->enc, 0x0a, buf + dlen);\n  if (alen < 0) return alen;\n\n  crnl = node_new_str_raw(buf, buf + dlen + alen);\n  CHECK_NULL_RETURN_MEMERR(crnl);\n\n  ncc = node_new_cclass();\n  if (IS_NULL(ncc)) goto err2;\n\n  cc = CCLASS_(ncc);\n  if (dlen == 1) {\n    bitset_set_range(cc->bs, 0x0a, 0x0d);\n  }\n  else {\n    r = add_code_range(&(cc->mbuf), env, 0x0a, 0x0d);\n    if (r != 0) {\n    err1:\n      onig_node_free(ncc);\n    err2:\n      onig_node_free(crnl);\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  if (ONIGENC_IS_UNICODE_ENCODING(env->enc)) {\n    r = add_code_range(&(cc->mbuf), env, 0x85, 0x85);\n    if (r != 0) goto err1;\n    r = add_code_range(&(cc->mbuf), env, 0x2028, 0x2029);\n    if (r != 0) goto err1;\n  }\n\n  x = node_new_bag_if_else(crnl, 0, ncc);\n  if (IS_NULL(x)) goto err1;\n\n  *node = x;\n  return 0;\n}\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  TK_KEEP,             /* \\K */\n  TK_GENERAL_NEWLINE,  /* \\R */\n  TK_NO_NEWLINE,       /* \\N */\n  TK_TRUE_ANYCHAR,     /* \\O */\n  TK_TEXT_SEGMENT,     /* \\X */\n\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    int   anchor;\n    int   subtype;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n      int    by_number;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} PToken;\n\n\nstatic int\nfetch_interval_quantifier(UChar** src, UChar* end, PToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n        goto invalid;\n      up = INFINITE_REPEAT;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_INFINITE_REPEAT(up) && low > up) {\n    /* {n,m}+ supported case */\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL))\n      return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n\n    tok->u.repeat.possessive = 1;\n    {\n      int tmp;\n      tmp = low; low = up; up = tmp;\n    }\n  }\n  else\n    tok->u.repeat.possessive = 0;\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow) {\n    /* *src = p; */ /* !!! Don't do this line !!! */\n    return 1;  /* OK */\n  }\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n        v = fetch_escaped_value(&p, end, env, &c);\n        if (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n        c = 0177;\n      }\n      else {\n        if (c == MC_ESC(env->syntax)) {\n          v = fetch_escaped_value(&p, end, env, &c);\n          if (v < 0) return v;\n        }\n        c &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(PToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>';  break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')';  break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\nenum REF_NUM {\n  IS_NOT_NUM = 0,\n  IS_ABS_NUM = 1,\n  IS_REL_NUM = 2\n};\n\n#ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n   \\k<+num+n>, \\k<+num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n                      UChar** rname_end, ScanEnv* env,\n                      int* rback_num, int* rlevel, enum REF_NUM* num_type)\n{\n  int r, sign, exist_level;\n  int digit_count;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  exist_level = 0;\n  *num_type = IS_NOT_NUM;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  digit_count = 0;\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      *num_type = IS_ABS_NUM;\n      digit_count++;\n    }\n    else if (c == '-') {\n      *num_type = IS_REL_NUM;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (c == '+') {\n      *num_type = IS_REL_NUM;\n      sign = 1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (*num_type != IS_NOT_NUM && digit_count == 0)\n        r = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (*num_type != IS_NOT_NUM) {\n      if (IS_CODE_DIGIT_ASCII(enc, c)) {\n        digit_count++;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        *num_type = IS_NOT_NUM;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n        r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        goto end;\n      }\n      PFETCH(c);\n      if (! IS_CODE_DIGIT_ASCII(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n        PFETCH(c);\n        if (c == end_code)\n          goto end;\n      }\n    }\n\n  err:\n    name_end = end;\n  err2:\n    r = ONIGERR_INVALID_GROUP_NAME;\n  }\n\n end:\n  if (r == 0) {\n    if (*num_type != IS_NOT_NUM) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        if (*num_type == IS_REL_NUM)\n          goto err2;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n           UChar** rname_end, ScanEnv* env, int* rback_num,\n           enum REF_NUM* num_type, int ref)\n{\n  int r, sign;\n  int digit_count;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  digit_count = 0;\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  *num_type = IS_NOT_NUM;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      if (ref == 1)\n        *num_type = IS_ABS_NUM;\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n      digit_count++;\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n        *num_type = IS_REL_NUM;\n        sign = -1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n    }\n    else if (c == '+') {\n      if (ref == 1) {\n        *num_type = IS_REL_NUM;\n        sign = 1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n        if (*num_type != IS_NOT_NUM && digit_count == 0)\n          r = ONIGERR_INVALID_GROUP_NAME;\n        break;\n      }\n\n      if (*num_type != IS_NOT_NUM) {\n        if (IS_CODE_DIGIT_ASCII(enc, c)) {\n          digit_count++;\n        }\n        else {\n          if (!ONIGENC_IS_CODE_WORD(enc, c))\n            r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n          else\n            r = ONIGERR_INVALID_GROUP_NAME;\n\n          *num_type = IS_NOT_NUM;\n        }\n      }\n      else {\n        if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n          r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        }\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n\n    if (*num_type != IS_NOT_NUM) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        if (*num_type == IS_REL_NUM) {\n          r = ONIGERR_INVALID_GROUP_NAME;\n          goto err;\n        }\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n        break;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n\nstatic void\nCC_ESC_WARN(ScanEnv* env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                               env->pattern, env->pattern_end,\n                               (UChar* )\"character class has '%s' without escape\",\n                               c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, (env)->enc,\n                         (env)->pattern, (env)->pattern_end,\n                         (UChar* )\"regular expression has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n                  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n        x = ONIGENC_MBC_TO_CODE(enc, q, to);\n        if (x != s[i]) break;\n        q += enclen(enc, q);\n      }\n      if (i >= n) {\n        if (IS_NOT_NULL(next))\n          *next = q;\n        return p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n                         OnigCodePoint bad, OnigEncoding enc, OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p);\n      if (x == s[0]) {\n        for (i = 1; i < n && q < to; i++) {\n          x = ONIGENC_MBC_TO_CODE(enc, q, to);\n          if (x != s[i]) break;\n          q += enclen(enc, q);\n        }\n        if (i >= n) return 1;\n        p += enclen(enc, p);\n      }\n      else {\n        x = ONIGENC_MBC_TO_CODE(enc, p, to);\n        if (x == bad) return 0;\n        else if (x == MC_ESC(syn)) in_esc = 1;\n        p = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = c == 'P';\n\n        if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c2);\n          if (c2 == '^') {\n            tok->u.prop.not = tok->u.prop.not == 0;\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (IS_CODE_DIGIT_ASCII(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 8;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          c2 = PPEEK;\n          if (IS_CODE_XDIGIT_ASCII(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 16;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if (tok->u.c != c2) {\n        tok->u.code = c2;\n        tok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n        tok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n        PUNFETCH;\n        goto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n        tok->type = TK_CC_CC_OPEN;\n      }\n      else {\n        CC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n        !PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nfetch_token(PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      tok->u.repeat.possessive = 0;\n    greedy_check2:\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY) &&\n          tok->u.repeat.possessive == 0) {\n        PFETCH(c);\n        tok->u.repeat.greedy = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        tok->u.repeat.greedy = 1;\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL)) &&\n          tok->u.repeat.possessive == 0) {\n          PFETCH(c);\n          tok->u.repeat.possessive = 1;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_interval_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check2;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check2;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_BOUNDARY;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_NO_WORD_BOUNDARY;\n      break;\n\n    case 'y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_TEXT_SEGMENT_BOUNDARY;\n      break;\n\n    case 'Y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_NO_TEXT_SEGMENT_BOUNDARY;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'K':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) break;\n      tok->type = TK_KEEP;\n      break;\n\n    case 'R':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE)) break;\n      tok->type = TK_GENERAL_NEWLINE;\n      break;\n\n    case 'N':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_NO_NEWLINE;\n      break;\n\n    case 'O':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_TRUE_ANYCHAR;\n      break;\n\n    case 'X':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_X_Y_TEXT_SEGMENT)) break;\n      tok->type = TK_TEXT_SEGMENT;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (IS_CODE_DIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          if (IS_CODE_XDIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEMENV(env)[num].node))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n          enum REF_NUM num_type;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                 env, &back_num, &tok->u.backref.level, &num_type);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(c, &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n\n#ifdef USE_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n          enum REF_NUM num_type;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env,\n                         &gnum, &num_type, 1);\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              gnum = backref_rel_to_abs(gnum, env);\n              if (gnum < 0) {\n                onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                               prev, name_end);\n                return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n              }\n            }\n            tok->u.call.by_number = 1;\n            tok->u.call.gnum      = gnum;\n          }\n          else {\n            tok->u.call.by_number = 0;\n            tok->u.call.gnum      = 0;\n          }\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = c == 'P';\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = tok->u.prop.not == 0;\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n        }\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = INFINITE_REPEAT;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_interval_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check2;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check2;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (! PEND) {\n          c = PPEEK;\n          if (c == '#') {\n            PFETCH(c);\n            while (1) {\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c == MC_ESC(syn)) {\n                if (! PEND) PFETCH(c);\n              }\n              else {\n                if (c == ')') break;\n              }\n            }\n            goto start;\n          }\n          else if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_PERL_SUBEXP_CALL)) {\n            int gnum;\n            UChar* name;\n            UChar* name_end;\n            enum REF_NUM num_type;\n\n            switch (c) {\n            case '&':\n              {\n                PINC;\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum,\n                               &num_type, 0);\n                if (r < 0) return r;\n\n                tok->type = TK_CALL;\n                tok->u.call.by_number = 0;\n                tok->u.call.gnum      = 0;\n                tok->u.call.name      = name;\n                tok->u.call.name_end  = name_end;\n              }\n              break;\n\n            case 'R':\n              tok->type = TK_CALL;\n              tok->u.call.by_number = 1;\n              tok->u.call.gnum      = 0;\n              tok->u.call.name      = p;\n              PINC;\n              if (! PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n              tok->u.call.name_end  = p;\n              break;\n\n            case '-':\n            case '+':\n              goto lparen_qmark_num;\n              break;\n            default:\n              if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto lparen_qmark_end;\n\n            lparen_qmark_num:\n              {\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env,\n                               &gnum, &num_type, 1);\n                if (r < 0) return r;\n\n                if (num_type == IS_NOT_NUM) {\n                  return ONIGERR_INVALID_GROUP_NAME;\n                }\n                else {\n                  if (num_type == IS_REL_NUM) {\n                    gnum = backref_rel_to_abs(gnum, env);\n                    if (gnum < 0) {\n                      onig_scan_env_set_error_string(env,\n                             ONIGERR_UNDEFINED_NAME_REFERENCE, name, name_end);\n                      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n                    }\n                  }\n                  tok->u.call.by_number = 1;\n                  tok->u.call.gnum      = gnum;\n                }\n\n                tok->type = TK_CALL;\n                tok->u.call.name     = name;\n                tok->u.call.name_end = name_end;\n              }\n              break;\n            }\n          }\n        }\n      lparen_qmark_end:\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCR_BEGIN_BUF : ANCR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCR_SEMI_END_BUF : ANCR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->options)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->options))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                         OnigEncoding enc ARG_UNUSED, OnigCodePoint sb_out,\n                         const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            r = add_code_range_to_buf(&(cc->mbuf), j,\n                                      ONIGENC_CODE_RANGE_TO(mbr, i));\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf),\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev; j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n        if (j >= sb_out) {\n          goto sb_end2;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n      if (prev == 0) goto end;\n    }\n\n    r = add_code_range_to_buf(&(cc->mbuf), prev, MAX_CODE_POINT);\n    if (r != 0) return r;\n  }\n\n end:\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc_by_range_limit(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                               OnigEncoding enc ARG_UNUSED,\n                               OnigCodePoint sb_out,\n                               const OnigCodePoint mbr[], OnigCodePoint limit)\n{\n  int i, r;\n  OnigCodePoint j;\n  OnigCodePoint from;\n  OnigCodePoint to;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j > limit) goto end;\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            to = ONIGENC_CODE_RANGE_TO(mbr, i);\n            if (to > limit) to = limit;\n            r = add_code_range_to_buf(&(cc->mbuf), j, to);\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      to   = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (from > limit) break;\n      if (to   > limit) to = limit;\n      r = add_code_range_to_buf(&(cc->mbuf), from, to);\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      if (from > limit) {\n        for (j = prev; j < sb_out; j++) {\n          BITSET_SET_BIT(cc->bs, j);\n        }\n        goto sb_end2;\n      }\n      for (j = prev; j < from; j++) {\n        if (j >= sb_out) goto sb_end2;\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (prev > limit) prev = limit;\n      prev++;\n      if (prev == 0) goto end;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      from = ONIGENC_CODE_RANGE_FROM(mbr, i);\n      if (from > limit) goto last;\n\n      if (prev < from) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev, from - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i);\n      if (prev > limit) prev = limit;\n      prev++;\n      if (prev == 0) goto end;\n    }\n\n  last:\n    r = add_code_range_to_buf(&(cc->mbuf), prev, MAX_CODE_POINT);\n    if (r != 0) return r;\n  }\n\n end:\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, ScanEnv* env)\n{\n#define ASCII_LIMIT    127\n\n  int c, r;\n  int ascii_mode;\n  const OnigCodePoint *ranges;\n  OnigCodePoint limit;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(ctype, env->options);\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    if (ascii_mode == 0)\n      r = add_ctype_to_cc_by_range(cc, ctype, not, env->enc, sb_out, ranges);\n    else\n      r = add_ctype_to_cc_by_range_limit(cc, ctype, not, env->enc, sb_out,\n                                         ranges, ASCII_LIMIT);\n    return r;\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  r = 0;\n  limit = ascii_mode ? ASCII_LIMIT : SINGLE_BYTE_SIZE;\n\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < (int )limit; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      for (c = limit; c < SINGLE_BYTE_SIZE; c++) {\n        BITSET_SET_BIT(cc->bs, c);\n      }\n\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n  case ONIGENC_CTYPE_WORD:\n    if (not != 0) {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_CODE_TO_MBCLEN(enc, c) > 0 /* check invalid code point */\n            && ! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      for (c = limit; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_CODE_TO_MBCLEN(enc, c) > 0)\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    else {\n      for (c = 0; c < (int )limit; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      if (ascii_mode == 0)\n        ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static PosixBracketEntryType PBS[] = {\n    { (UChar* )\"alnum\",  ONIGENC_CTYPE_ALNUM,  5 },\n    { (UChar* )\"alpha\",  ONIGENC_CTYPE_ALPHA,  5 },\n    { (UChar* )\"blank\",  ONIGENC_CTYPE_BLANK,  5 },\n    { (UChar* )\"cntrl\",  ONIGENC_CTYPE_CNTRL,  5 },\n    { (UChar* )\"digit\",  ONIGENC_CTYPE_DIGIT,  5 },\n    { (UChar* )\"graph\",  ONIGENC_CTYPE_GRAPH,  5 },\n    { (UChar* )\"lower\",  ONIGENC_CTYPE_LOWER,  5 },\n    { (UChar* )\"print\",  ONIGENC_CTYPE_PRINT,  5 },\n    { (UChar* )\"punct\",  ONIGENC_CTYPE_PUNCT,  5 },\n    { (UChar* )\"space\",  ONIGENC_CTYPE_SPACE,  5 },\n    { (UChar* )\"upper\",  ONIGENC_CTYPE_UPPER,  5 },\n    { (UChar* )\"xdigit\", ONIGENC_CTYPE_XDIGIT, 6 },\n    { (UChar* )\"ascii\",  ONIGENC_CTYPE_ASCII,  5 },\n    { (UChar* )\"word\",   ONIGENC_CTYPE_WORD,   4 },\n    { (UChar* )NULL,     -1, 0 }\n  };\n\n  PosixBracketEntryType *pb;\n  int not, i, r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, env);\n      if (r != 0) return r;\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int\nparse_char_property(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = CCLASS_(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  return 0;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n                 enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, OnigCodePoint *from, OnigCodePoint to,\n               int* from_israw, int to_israw,\n               enum CCVALTYPE intype, enum CCVALTYPE* type,\n               enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*from > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*from));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *from, *from);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*from > 0xff || to > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*from > to) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*from, (int )to);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *from, to);\n        if (r < 0) return r;\n      }\n    }\n    else {\n      if (*from > to) {\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n          goto ccs_range_end;\n        else\n          return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n      }\n      bitset_set_range(cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n      r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*from, to);\n      if (r < 0) return r;\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *from_israw = to_israw;\n  *from       = to;\n  *type       = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n                 ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = CCLASS_(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        int i, j;\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        /* clear buf tail */\n        for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\\0';\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n                         &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\"[\");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) goto err;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) {\n          r = ctype;\n          goto err;\n        }\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) goto err;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\n        if (val_type == CCV_CLASS) {\n          r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n          goto err;\n        }\n\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\"-\");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\"-\");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = CCLASS_(anode);\n        r = or_cclass(cc, acc, env->enc);\n        onig_node_free(anode);\n\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != CCLASS_(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, PToken* tok, int term,\n                        UChar** src, UChar* end, ScanEnv* env, int group_head);\n\n#ifdef USE_CALLOUT\n\n/* (?{...}[tag][+-]) (?{{...}}[tag][+-]) */\nstatic int\nparse_callout_of_contents(Node** np, int cterm, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  int i;\n  int in;\n  int num;\n  OnigCodePoint c;\n  UChar* code_start;\n  UChar* code_end;\n  UChar* contents;\n  UChar* tag_start;\n  UChar* tag_end;\n  int brace_nest;\n  CalloutListEntry* e;\n  RegexExt* ext;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  brace_nest = 0;\n  while (PPEEK_IS('{')) {\n    brace_nest++;\n    PINC_S;\n    if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n  }\n\n  in = ONIG_CALLOUT_IN_PROGRESS;\n  code_start = p;\n  while (1) {\n    if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n    code_end = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      i = brace_nest;\n      while (i > 0) {\n        if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n        PFETCH_S(c);\n        if (c == '}') i--;\n        else break;\n      }\n      if (i == 0) break;\n    }\n  }\n\n  if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n  PFETCH_S(c);\n  if (c == '[') {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    tag_end = tag_start = p;\n    while (! PEND) {\n      if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n      tag_end = p;\n      PFETCH_S(c);\n      if (c == ']') break;\n    }\n    if (! is_allowed_callout_tag_name(enc, tag_start, tag_end))\n      return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    tag_start = tag_end = 0;\n  }\n\n  if (c == 'X') {\n    in |= ONIG_CALLOUT_IN_RETRACTION;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else if (c == '<') {\n    in = ONIG_CALLOUT_IN_RETRACTION;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else if (c == '>') { /* no needs (default) */\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n\n  if (c != cterm)\n    return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  r = reg_callout_list_entry(env, &num);\n  if (r != 0) return r;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  if (IS_NULL(ext->pattern)) {\n    r = onig_ext_set_pattern(env->reg, env->pattern, env->pattern_end);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  if (tag_start != tag_end) {\n    r = callout_tag_entry(env->reg, tag_start, tag_end, num);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  contents = onigenc_strdup(enc, code_start, code_end);\n  CHECK_NULL_RETURN_MEMERR(contents);\n\n  r = node_new_callout(np, ONIG_CALLOUT_OF_CONTENTS, num, ONIG_NON_NAME_ID, env);\n  if (r != 0) {\n    xfree(contents);\n    return r;\n  }\n\n  e = onig_reg_callout_list_at(env->reg, num);\n  if (IS_NULL(e)) {\n    xfree(contents);\n    return ONIGERR_MEMORY;\n  }\n\n  e->of      = ONIG_CALLOUT_OF_CONTENTS;\n  e->in      = in;\n  e->name_id = ONIG_NON_NAME_ID;\n  e->u.content.start = contents;\n  e->u.content.end   = contents + (code_end - code_start);\n\n  *src = p;\n  return 0;\n}\n\nstatic long\nparse_long(OnigEncoding enc, UChar* s, UChar* end, int sign_on, long max, long* rl)\n{\n  long v;\n  long d;\n  int flag;\n  UChar* p;\n  OnigCodePoint c;\n\n  if (s >= end) return ONIGERR_INVALID_CALLOUT_ARG;\n\n  flag = 1;\n  v = 0;\n  p = s;\n  while (p < end) {\n    c = ONIGENC_MBC_TO_CODE(enc, p, end);\n    p += ONIGENC_MBC_ENC_LEN(enc, p);\n    if (c >= '0' && c <= '9') {\n      d = (long )(c - '0');\n      if (v > (max - d) / 10)\n        return ONIGERR_INVALID_CALLOUT_ARG;\n\n      v = v * 10 + d;\n    }\n    else if (sign_on != 0 && (c == '-' || c == '+')) {\n      if (c == '-') flag = -1;\n    }\n    else\n      return ONIGERR_INVALID_CALLOUT_ARG;\n\n    sign_on = 0;\n  }\n\n  *rl = flag * v;\n  return ONIG_NORMAL;\n}\n\nstatic int\nparse_callout_args(int skip_mode, int cterm, UChar** src, UChar* end,\n                   unsigned int types[], OnigValue vals[], ScanEnv* env)\n{\n#define MAX_CALLOUT_ARG_BYTE_LENGTH   128\n\n  int r;\n  int n;\n  int esc;\n  int cn;\n  UChar* s;\n  UChar* e;\n  UChar* eesc;\n  OnigCodePoint c;\n  UChar* bufend;\n  UChar buf[MAX_CALLOUT_ARG_BYTE_LENGTH];\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  n = 0;\n  while (n < ONIG_CALLOUT_MAX_ARGS_NUM) {\n    c   = 0;\n    cn  = 0;\n    esc = 0;\n    eesc = 0;\n    bufend = buf;\n    s = e = p;\n    while (1) {\n      if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n      e = p;\n      PFETCH_S(c);\n      if (esc != 0) {\n        esc = 0;\n        if (c == '\\\\' || c == cterm || c == ',') {\n          /* */\n        }\n        else {\n          e = eesc;\n          cn++;\n        }\n        goto add_char;\n      }\n      else {\n        if (c == '\\\\') {\n          esc = 1;\n          eesc = e;\n        }\n        else if (c == cterm || c == ',')\n          break;\n        else {\n          size_t clen;\n\n        add_char:\n          if (skip_mode == 0) {\n            clen = p - e;\n            if (bufend + clen > buf + MAX_CALLOUT_ARG_BYTE_LENGTH)\n              return ONIGERR_INVALID_CALLOUT_ARG; /* too long argument */\n\n            xmemcpy(bufend, e, clen);\n            bufend += clen;\n          }\n          cn++;\n        }\n      }\n    }\n\n    if (cn != 0) {\n      if (skip_mode == 0) {\n        if ((types[n] & ONIG_TYPE_LONG) != 0) {\n          int fixed = 0;\n          if (cn > 0) {\n            long rl;\n            r = parse_long(enc, buf, bufend, 1, LONG_MAX, &rl);\n            if (r == ONIG_NORMAL) {\n              vals[n].l = rl;\n              fixed = 1;\n              types[n] = ONIG_TYPE_LONG;\n            }\n          }\n\n          if (fixed == 0) {\n            types[n] = (types[n] & ~ONIG_TYPE_LONG);\n            if (types[n] == ONIG_TYPE_VOID)\n              return ONIGERR_INVALID_CALLOUT_ARG;\n          }\n        }\n\n        switch (types[n]) {\n        case ONIG_TYPE_LONG:\n          break;\n\n        case ONIG_TYPE_CHAR:\n          if (cn != 1) return ONIGERR_INVALID_CALLOUT_ARG;\n          vals[n].c = ONIGENC_MBC_TO_CODE(enc, buf, bufend);\n          break;\n\n        case ONIG_TYPE_STRING:\n          {\n            UChar* rs = onigenc_strdup(enc, buf, bufend);\n            CHECK_NULL_RETURN_MEMERR(rs);\n            vals[n].s.start = rs;\n            vals[n].s.end   = rs + (e - s);\n          }\n          break;\n\n        case ONIG_TYPE_TAG:\n          if (eesc != 0 || ! is_allowed_callout_tag_name(enc, s, e))\n            return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n          vals[n].s.start = s;\n          vals[n].s.end   = e;\n          break;\n\n        case ONIG_TYPE_VOID:\n        case ONIG_TYPE_POINTER:\n          return ONIGERR_PARSER_BUG;\n          break;\n        }\n      }\n\n      n++;\n    }\n\n    if (c == cterm) break;\n  }\n\n  if (c != cterm) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  *src = p;\n  return n;\n}\n\n/* (*name[TAG]) (*name[TAG]{a,b,..}) */\nstatic int\nparse_callout_of_name(Node** np, int cterm, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  int i;\n  int in;\n  int num;\n  int name_id;\n  int arg_num;\n  int max_arg_num;\n  int opt_arg_num;\n  int is_not_single;\n  OnigCodePoint c;\n  UChar* name_start;\n  UChar* name_end;\n  UChar* tag_start;\n  UChar* tag_end;\n  Node*  node;\n  CalloutListEntry* e;\n  RegexExt* ext;\n  unsigned int types[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigValue    vals[ONIG_CALLOUT_MAX_ARGS_NUM];\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  /* PFETCH_READY; */\n  if (PEND) return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  node = 0;\n  name_start = p;\n  while (1) {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    name_end = p;\n    PFETCH_S(c);\n    if (c == cterm || c == '[' || c == '{') break;\n  }\n\n  if (! is_allowed_callout_name(enc, name_start, name_end))\n    return ONIGERR_INVALID_CALLOUT_NAME;\n\n  if (c == '[') {\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    tag_end = tag_start = p;\n    while (! PEND) {\n      if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n      tag_end = p;\n      PFETCH_S(c);\n      if (c == ']') break;\n    }\n    if (! is_allowed_callout_tag_name(enc, tag_start, tag_end))\n      return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    tag_start = tag_end = 0;\n  }\n\n  if (c == '{') {\n    UChar* save;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    /* read for single check only */\n    save = p;\n    arg_num = parse_callout_args(1, '}', &p, end, 0, 0, env);\n    if (arg_num < 0) return arg_num;\n\n    is_not_single = PPEEK_IS(cterm) ?  0 : 1;\n    p = save;\n    r = get_callout_name_id_by_name(enc, is_not_single, name_start, name_end,\n                                    &name_id);\n    if (r != ONIG_NORMAL) return r;\n\n    max_arg_num = get_callout_arg_num_by_name_id(name_id);\n    for (i = 0; i < max_arg_num; i++) {\n      types[i] = get_callout_arg_type_by_name_id(name_id, i);\n    }\n\n    arg_num = parse_callout_args(0, '}', &p, end, types, vals, env);\n    if (arg_num < 0) return arg_num;\n\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n    PFETCH_S(c);\n  }\n  else {\n    arg_num = 0;\n\n    is_not_single = 0;\n    r = get_callout_name_id_by_name(enc, is_not_single, name_start, name_end,\n                                      &name_id);\n    if (r != ONIG_NORMAL) return r;\n\n    max_arg_num = get_callout_arg_num_by_name_id(name_id);\n    for (i = 0; i < max_arg_num; i++) {\n      types[i] = get_callout_arg_type_by_name_id(name_id, i);\n    }\n  }\n\n  in = onig_get_callout_in_by_name_id(name_id);\n  opt_arg_num = get_callout_opt_arg_num_by_name_id(name_id);\n  if (arg_num > max_arg_num || arg_num < (max_arg_num - opt_arg_num))\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (c != cterm)\n    return ONIGERR_INVALID_CALLOUT_PATTERN;\n\n  r = reg_callout_list_entry(env, &num);\n  if (r != 0) return r;\n\n  ext = onig_get_regex_ext(env->reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n  if (IS_NULL(ext->pattern)) {\n    r = onig_ext_set_pattern(env->reg, env->pattern, env->pattern_end);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  if (tag_start != tag_end) {\n    r = callout_tag_entry(env->reg, tag_start, tag_end, num);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  r = node_new_callout(&node, ONIG_CALLOUT_OF_NAME, num, name_id, env);\n  if (r != ONIG_NORMAL) return r;\n\n  e = onig_reg_callout_list_at(env->reg, num);\n  CHECK_NULL_RETURN_MEMERR(e);\n\n  e->of         = ONIG_CALLOUT_OF_NAME;\n  e->in         = in;\n  e->name_id    = name_id;\n  e->type       = onig_get_callout_type_by_name_id(name_id);\n  e->start_func = onig_get_callout_start_func_by_name_id(name_id);\n  e->end_func   = onig_get_callout_end_func_by_name_id(name_id);\n  e->u.arg.num        = max_arg_num;\n  e->u.arg.passed_num = arg_num;\n  for (i = 0; i < max_arg_num; i++) {\n    e->u.arg.types[i] = types[i];\n    if (i < arg_num)\n      e->u.arg.vals[i] = vals[i];\n    else\n      e->u.arg.vals[i] = get_callout_opt_default_by_name_id(name_id, i);\n  }\n\n  *np = node;\n  *src = p;\n  return 0;\n}\n#endif\n\nstatic int\nparse_bag(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env)\n{\n  int r, num;\n  Node *target;\n  OnigOptionType option;\n  OnigCodePoint c;\n  int list_capture;\n  OnigEncoding enc = env->enc;\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->options;\n  c = PPEEK;\n  if (c == '?' && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env, 0);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCR_PREC_READ, 0);\n      break;\n    case '!':  /*         preceding read */\n      *np = onig_node_new_anchor(ANCR_PREC_READ_NOT, 0);\n      break;\n    case '>':            /* (?>...) stop backtrack */\n      *np = node_new_bag(BAG_STOP_BACKTRACK);\n      break;\n\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n        goto named_group1;\n      }\n      else\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n        *np = onig_node_new_anchor(ANCR_LOOK_BEHIND, 0);\n      else if (c == '!')\n        *np = onig_node_new_anchor(ANCR_LOOK_BEHIND_NOT, 0);\n      else {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          UChar *name;\n          UChar *name_end;\n          enum REF_NUM num_type;\n\n          PUNFETCH;\n          c = '<';\n\n        named_group1:\n          list_capture = 0;\n\n        named_group2:\n          name = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num,\n                         &num_type, 0);\n          if (r < 0) return r;\n\n          num = scan_env_add_mem_entry(env);\n          if (num < 0) return num;\n          if (list_capture != 0 && num >= (int )MEM_STATUS_BITS_NUM)\n            return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n          r = name_add(env->reg, name, name_end, num, env);\n          if (r != 0) return r;\n          *np = node_new_memory(1);\n          CHECK_NULL_RETURN_MEMERR(*np);\n          BAG_(*np)->m.regnum = num;\n          if (list_capture != 0)\n            MEM_STATUS_ON_SIMPLE(env->capture_history, num);\n          env->num_named++;\n        }\n        else {\n          return ONIGERR_UNDEFINED_GROUP_OPTION;\n        }\n      }\n      break;\n\n    case '~':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_TILDE_ABSENT_GROUP)) {\n        Node* absent;\n        Node* expr;\n        int head_bar;\n        int is_range_cutter;\n\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n        if (PPEEK_IS('|')) { /* (?~|generator|absent) */\n          PINC;\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n          head_bar = 1;\n          if (PPEEK_IS(')')) { /* (?~|)  : range clear */\n            PINC;\n            r = make_range_clear(np, env);\n            if (r != 0) return r;\n            goto end;\n          }\n        }\n        else\n          head_bar = 0;\n\n        r = fetch_token(tok, &p, end, env);\n        if (r < 0) return r;\n        r = parse_subexp(&absent, tok, term, &p, end, env, 1);\n        if (r < 0) {\n          onig_node_free(absent);\n          return r;\n        }\n\n        expr = NULL_NODE;\n        is_range_cutter = 0;\n        if (head_bar != 0) {\n          Node* top = absent;\n          if (NODE_TYPE(top) != NODE_ALT || IS_NULL(NODE_CDR(top))) {\n            expr = NULL_NODE;\n            is_range_cutter = 1;\n            /* return ONIGERR_INVALID_ABSENT_GROUP_GENERATOR_PATTERN; */\n          }\n          else {\n            absent = NODE_CAR(top);\n            expr   = NODE_CDR(top);\n            NODE_CAR(top) = NULL_NODE;\n            NODE_CDR(top) = NULL_NODE;\n            onig_node_free(top);\n            if (IS_NULL(NODE_CDR(expr))) {\n              top = expr;\n              expr = NODE_CAR(top);\n              NODE_CAR(top) = NULL_NODE;\n              onig_node_free(top);\n            }\n          }\n        }\n\n        r = make_absent_tree(np, absent, expr, is_range_cutter, env);\n        if (r != 0) {\n          return r;\n        }\n        goto end;\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_CALLOUT\n    case '{':\n      if (! IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS))\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n      r = parse_callout_of_contents(np, ')', &p, end, env);\n      if (r != 0) return r;\n\n      goto end;\n      break;\n#endif\n\n    case '(':\n      /* (?()...) */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LPAREN_IF_ELSE)) {\n        UChar *prev;\n        Node* condition;\n        int condition_is_checker;\n\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n        PFETCH(c);\n        if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n        if (IS_CODE_DIGIT_ASCII(enc, c)\n            || c == '-' || c == '+' || c == '<' || c == '\\'') {\n          UChar* name_end;\n          int back_num;\n          int exist_level;\n          int level;\n          enum REF_NUM num_type;\n          int is_enclosed;\n\n          is_enclosed = (c == '<' || c == '\\'') ? 1 : 0;\n          if (! is_enclosed)\n            PUNFETCH;\n          prev = p;\n          exist_level = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level(\n                    (OnigCodePoint )(is_enclosed != 0 ? c : '('),\n                    &p, end, &name_end,\n                    env, &back_num, &level, &num_type);\n          if (r == 1) exist_level = 1;\n#else\n          r = fetch_name((OnigCodePoint )(is_enclosed != 0 ? c : '('),\n                         &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) {\n            if (is_enclosed == 0) {\n              goto any_condition;\n            }\n            else\n              return r;\n          }\n\n          condition_is_checker = 1;\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n\n            condition = node_new_backref_checker(1, &back_num, 0,\n#ifdef USE_BACKREF_WITH_LEVEL\n                                                 exist_level, level,\n#endif\n                                                 env);\n          }\n          else {\n            int num;\n            int* backs;\n\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            condition = node_new_backref_checker(num, backs, 1,\n#ifdef USE_BACKREF_WITH_LEVEL\n                                                 exist_level, level,\n#endif\n                                                 env);\n          }\n\n          if (is_enclosed != 0) {\n            if (PEND) goto err_if_else;\n            PFETCH(c);\n            if (c != ')') goto err_if_else;\n          }\n        }\n#ifdef USE_CALLOUT\n        else if (c == '?') {\n          if (IS_SYNTAX_OP2(env->syntax,\n                            ONIG_SYN_OP2_QMARK_BRACE_CALLOUT_CONTENTS)) {\n            if (! PEND && PPEEK_IS('{')) {\n              /* condition part is callouts of contents: (?(?{...})THEN|ELSE) */\n              condition_is_checker = 0;\n              PFETCH(c);\n              r = parse_callout_of_contents(&condition, ')', &p, end, env);\n              if (r != 0) return r;\n              goto end_condition;\n            }\n          }\n          goto any_condition;\n        }\n        else if (c == '*' &&\n                 IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME)) {\n          condition_is_checker = 0;\n          r = parse_callout_of_name(&condition, ')', &p, end, env);\n          if (r != 0) return r;\n          goto end_condition;\n        }\n#endif\n        else {\n        any_condition:\n          PUNFETCH;\n          condition_is_checker = 0;\n          r = fetch_token(tok, &p, end, env);\n          if (r < 0) return r;\n          r = parse_subexp(&condition, tok, term, &p, end, env, 0);\n          if (r < 0) {\n            onig_node_free(condition);\n            return r;\n          }\n        }\n\n#ifdef USE_CALLOUT\n      end_condition:\n#endif\n        CHECK_NULL_RETURN_MEMERR(condition);\n\n        if (PEND) {\n        err_if_else:\n          onig_node_free(condition);\n          return ONIGERR_END_PATTERN_IN_GROUP;\n        }\n\n        if (PPEEK_IS(')')) { /* case: empty body: make backref checker */\n          if (condition_is_checker == 0) {\n            onig_node_free(condition);\n            return ONIGERR_INVALID_IF_ELSE_SYNTAX;\n          }\n          PFETCH(c);\n          *np = condition;\n        }\n        else { /* if-else */\n          int then_is_empty;\n          Node *Then, *Else;\n\n          Then = 0;\n          if (PPEEK_IS('|')) {\n            PFETCH(c);\n            then_is_empty = 1;\n          }\n          else\n            then_is_empty = 0;\n\n          r = fetch_token(tok, &p, end, env);\n          if (r < 0) {\n            onig_node_free(condition);\n            return r;\n          }\n          r = parse_subexp(&target, tok, term, &p, end, env, 1);\n          if (r < 0) {\n            onig_node_free(condition);\n            onig_node_free(target);\n            return r;\n          }\n\n          if (then_is_empty != 0) {\n            Else = target;\n          }\n          else {\n            if (NODE_TYPE(target) == NODE_ALT) {\n              Then = NODE_CAR(target);\n              if (NODE_CDR(NODE_CDR(target)) == NULL_NODE) {\n                Else = NODE_CAR(NODE_CDR(target));\n                cons_node_free_alone(NODE_CDR(target));\n              }\n              else {\n                Else = NODE_CDR(target);\n              }\n              cons_node_free_alone(target);\n            }\n            else {\n              Then = target;\n              Else = 0;\n            }\n          }\n\n          *np = node_new_bag_if_else(condition, Then, Else);\n          if (IS_NULL(*np)) {\n            onig_node_free(condition);\n            onig_node_free(Then);\n            onig_node_free(Else);\n            return ONIGERR_MEMORY;\n          }\n        }\n        goto end;\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          PFETCH(c);\n          if (c == '<' || c == '\\'') {\n            list_capture = 1;\n            goto named_group2; /* (?@<name>...) */\n          }\n          PUNFETCH;\n        }\n\n        *np = node_new_memory(0);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        num = scan_env_add_mem_entry(env);\n        if (num < 0) {\n          return num;\n        }\n        else if (num >= (int )MEM_STATUS_BITS_NUM) {\n          return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n        }\n        BAG_(*np)->m.regnum = num;\n        MEM_STATUS_ON_SIMPLE(env->capture_history, num);\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n    case 'W': case 'D': case 'S': case 'P':\n    case 'y':\n      {\n        int neg = 0;\n\n        while (1) {\n          switch (c) {\n          case ':':\n          case ')':\n            break;\n\n          case '-':  neg = 1; break;\n          case 'x':  OPTION_NEGATE(option, ONIG_OPTION_EXTEND,     neg); break;\n          case 'i':  OPTION_NEGATE(option, ONIG_OPTION_IGNORECASE, neg); break;\n          case 's':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              OPTION_NEGATE(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n\n          case 'm':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              OPTION_NEGATE(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n            }\n            else if (IS_SYNTAX_OP2(env->syntax,\n                        ONIG_SYN_OP2_OPTION_ONIGURUMA|ONIG_SYN_OP2_OPTION_RUBY)) {\n              OPTION_NEGATE(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n#ifdef USE_POSIXLINE_OPTION\n          case 'p':\n            OPTION_NEGATE(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n            break;\n#endif\n          case 'W': OPTION_NEGATE(option, ONIG_OPTION_WORD_IS_ASCII, neg); break;\n          case 'D': OPTION_NEGATE(option, ONIG_OPTION_DIGIT_IS_ASCII, neg); break;\n          case 'S': OPTION_NEGATE(option, ONIG_OPTION_SPACE_IS_ASCII, neg); break;\n          case 'P': OPTION_NEGATE(option, ONIG_OPTION_POSIX_IS_ASCII, neg); break;\n\n          case 'y': /* y{g}, y{w} */\n            {\n              if (! IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_ONIGURUMA))\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n              if (neg != 0) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              if (! PPEEK_IS('{')) return ONIGERR_UNDEFINED_GROUP_OPTION;\n              PFETCH(c);\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              switch (c) {\n              case 'g':\n                if (! ONIGENC_IS_UNICODE_ENCODING(enc))\n                  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_EXTENDED_GRAPHEME_CLUSTER, 0);\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_WORD, 1);\n                break;\n#ifdef USE_UNICODE_WORD_BREAK\n              case 'w':\n                if (! ONIGENC_IS_UNICODE_ENCODING(enc))\n                  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_WORD, 0);\n                OPTION_NEGATE(option, ONIG_OPTION_TEXT_SEGMENT_EXTENDED_GRAPHEME_CLUSTER, 1);\n                break;\n#endif\n              default:\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n                break;\n              }\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c != '}')\n                return ONIGERR_UNDEFINED_GROUP_OPTION;\n              break;\n            } /* case 'y' */\n\n          default:\n            return ONIGERR_UNDEFINED_GROUP_OPTION;\n          }\n\n          if (c == ')') {\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            *src = p;\n            return 2; /* option only */\n          }\n          else if (c == ':') {\n            OnigOptionType prev = env->options;\n\n            env->options = option;\n            r = fetch_token(tok, &p, end, env);\n            if (r < 0) return r;\n            r = parse_subexp(&target, tok, term, &p, end, env, 0);\n            env->options = prev;\n            if (r < 0) {\n              onig_node_free(target);\n              return r;\n            }\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            NODE_BODY(*np) = target;\n            *src = p;\n            return 0;\n          }\n\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n          PFETCH(c);\n        } /* while (1) */\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n#ifdef USE_CALLOUT\n  else if (c == '*' &&\n           IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ASTERISK_CALLOUT_NAME)) {\n    PINC;\n    r = parse_callout_of_name(np, ')', &p, end, env);\n    if (r != 0) return r;\n\n    goto end;\n  }\n#endif\n  else {\n    if (ONIG_IS_OPTION_ON(env->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_memory(0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    BAG_(*np)->m.regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env, 0);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  NODE_BODY(*np) = target;\n\n  if (NODE_TYPE(*np) == NODE_BAG) {\n    if (BAG_(*np)->type == BAG_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, BAG_(*np)->m.regnum, *np);\n      if (r != 0) return r;\n    }\n  }\n\n end:\n  *src = p;\n  return 0;\n}\n\nstatic const char* PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QuantNode* qn;\n\n  qn = QUANT_(qnode);\n  if (qn->lower == 1 && qn->upper == 1)\n    return 1;\n\n  switch (NODE_TYPE(target)) {\n  case NODE_STRING:\n    if (group == 0) {\n      if (str_node_can_be_split(target, env->enc)) {\n        Node* n = str_node_split_last_char(target, env->enc);\n        if (IS_NOT_NULL(n)) {\n          NODE_BODY(qnode) = n;\n          return 2;\n        }\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QuantNode* qnt   = QUANT_(target);\n      int nestq_num   = quantifier_type_num(qn);\n      int targetq_num = quantifier_type_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (targetq_num >= 0 && nestq_num >= 0 &&\n          IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n        UChar buf[WARN_BUFSIZE];\n\n        switch(ReduceTypeTable[targetq_num][nestq_num]) {\n        case RQ_ASIS:\n          break;\n\n        case RQ_DEL:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                  env->pattern, env->pattern_end,\n                                  (UChar* )\"redundant nested repeat operator\");\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n\n        default:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                       env->pattern, env->pattern_end,\n            (UChar* )\"nested repeat operator %s and %s was replaced with '%s'\",\n            PopularQStr[targetq_num], PopularQStr[nestq_num],\n            ReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n        }\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0 && nestq_num < 0) {\n        if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n          /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n          if (! IS_INFINITE_REPEAT(qn->upper) && qn->upper > 1 && qn->greedy) {\n            qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n          }\n        }\n      }\n      else {\n        NODE_BODY(qnode) = target;\n        onig_reduce_nested_quantifier(qnode, target);\n        goto q_exit;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  NODE_BODY(qnode) = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[], int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  BitSetRef bs;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  bs = cc->bs;\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n        (is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        BITSET_SET_BIT(bs, *to);\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        if (IS_NCCLASS_NOT(cc)) {\n          BITSET_CLEAR_BIT(bs, *to);\n        }\n        else\n          BITSET_SET_BIT(bs, *to);\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n        && !IS_NCCLASS_NOT(cc)\n#endif\n        ) {\n      for (i = 0; i < to_len; i++) {\n        len = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n        if (i == 0) {\n          snode = onig_node_new_str(buf, buf + len);\n          CHECK_NULL_RETURN_MEMERR(snode);\n\n          /* char-class expanded multi-char only\n             compare with string folded at match time. */\n          NODE_STRING_SET_AMBIG(snode);\n        }\n        else {\n          r = onig_node_str_cat(snode, buf, buf + len);\n          if (r < 0) {\n            onig_node_free(snode);\n            return r;\n          }\n        }\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NODE_CDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group;\n  Node* qn;\n  Node** tp;\n  unsigned int parse_depth;\n\n  group = 0;\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  parse_depth = env->parse_depth;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      parse_depth++;\n      if (parse_depth > ParseDepthLimit)\n        return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, PToken* tok, int term, UChar** src, UChar* end,\n             ScanEnv* env, int group_head)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env, group_head);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    if (IS_NULL(*top)) {\n      onig_node_free(node);\n      return ONIGERR_MEMORY;\n    }\n\n    headp = &(NODE_CDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env, 0);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n\n      if (NODE_TYPE(node) == NODE_LIST) {\n        *headp = node;\n        while (IS_NOT_NULL(NODE_CDR(node))) node = NODE_CDR(node);\n        headp = &(NODE_CDR(node));\n      }\n      else {\n        *headp = node_new_list(node, NULL);\n        headp = &(NODE_CDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, PToken* tok, int term, UChar** src, UChar* end,\n             ScanEnv* env, int group_head)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n  r = parse_branch(&node, tok, term, src, end, env, group_head);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    if (IS_NULL(*top)) {\n      onig_node_free(node);\n      return ONIGERR_MEMORY;\n    }\n\n    headp = &(NODE_CDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env, 0);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n      *headp = onig_node_new_alt(node, NULL);\n      if (IS_NULL(*headp)) {\n        onig_node_free(node);\n        onig_node_free(*top);\n        return ONIGERR_MEMORY;\n      }\n\n      headp = &(NODE_CDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  PToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env, 0);\n  if (r < 0) return r;\n\n  return 0;\n}\n\n#ifdef USE_CALL\nstatic int\nmake_call_zero_body(Node* node, ScanEnv* env, Node** rnode)\n{\n  int r;\n\n  Node* x = node_new_memory(0 /* 0: is not named */);\n  CHECK_NULL_RETURN_MEMERR(x);\n\n  NODE_BODY(x) = node;\n  BAG_(x)->m.regnum = 0;\n  r = scan_env_set_mem_node(env, 0, x);\n  if (r != 0) {\n    onig_node_free(x);\n    return r;\n  }\n\n  *rnode = x;\n  return 0;\n}\n#endif\n\nextern int\nonig_parse_tree(Node** root, const UChar* pattern, const UChar* end,\n                regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n#ifdef USE_CALLOUT\n  RegexExt* ext;\n#endif\n\n  names_clear(reg);\n\n  scan_env_clear(env);\n  env->options        = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n\n  if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, pattern, end))\n    return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n\n#ifdef USE_CALL\n  if (r != 0) return r;\n\n  if (env->has_call_zero != 0) {\n    Node* zero_node;\n    r = make_call_zero_body(*root, env, &zero_node);\n    if (r != 0) return r;\n\n    *root = zero_node;\n  }\n#endif\n\n  reg->num_mem = env->num_mem;\n\n#ifdef USE_CALLOUT\n  ext = reg->extp;\n  if (IS_NOT_NULL(ext) && ext->callout_num > 0) {\n    r = setup_ext_callout_list_values(reg);\n  }\n#endif\n\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n                               UChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n"], "filenames": ["src/regparse.c"], "buggy_code_start_loc": [6241], "buggy_code_end_loc": [8147], "fixing_code_start_loc": [6242], "fixing_code_end_loc": [8157], "type": "CWE-674", "message": "Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.", "other": {"cve": {"id": "CVE-2019-16163", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-09T17:15:13.347", "lastModified": "2023-02-28T14:35:00.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c."}, {"lang": "es", "value": "Oniguruma versiones anteriores a 6.9.3, permite un Agotamiento de la Pila en el archivo regcomp.c debido a la recursi\u00f3n en el archivo regparse.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oniguruma_project:oniguruma:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.3", "matchCriteriaId": "F46239D9-B0F5-4B47-9EE3-743D79F5CD66"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}], "references": [{"url": "https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/kkos/oniguruma/compare/v6.9.2...v6.9.3", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "https://github.com/kkos/oniguruma/issues/147", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NWOWZZNFSAWM3BUTQNAE3PD44A6JU4KE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZW47MSFZ6WYOAOFXHBDGU4LYACFRKC2Y/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4460-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180"}}