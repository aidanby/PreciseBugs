{"buggy_code": ["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, {createRef} from 'react';\nimport PropTypes from 'prop-types';\nimport filesize from 'filesize';\nimport {MatrixClientPeg} from '../../../MatrixClientPeg';\nimport * as sdk from '../../../index';\nimport { _t } from '../../../languageHandler';\nimport {decryptFile} from '../../../utils/DecryptFile';\nimport Tinter from '../../../Tinter';\nimport request from 'browser-request';\nimport Modal from '../../../Modal';\nimport AccessibleButton from \"../elements/AccessibleButton\";\n\n\n// A cached tinted copy of require(\"../../../../res/img/download.svg\")\nlet tintedDownloadImageURL;\n// Track a list of mounted MFileBody instances so that we can update\n// the require(\"../../../../res/img/download.svg\") when the tint changes.\nlet nextMountId = 0;\nconst mounts = {};\n\n/**\n * Updates the tinted copy of require(\"../../../../res/img/download.svg\") when the tint changes.\n */\nfunction updateTintedDownloadImage() {\n    // Download the svg as an XML document.\n    // We could cache the XML response here, but since the tint rarely changes\n    // it's probably not worth it.\n    // Also note that we can't use fetch here because fetch doesn't support\n    // file URLs, which the download image will be if we're running from\n    // the filesystem (like in an Electron wrapper).\n    request({uri: require(\"../../../../res/img/download.svg\")}, (err, response, body) => {\n        if (err) return;\n\n        const svg = new DOMParser().parseFromString(body, \"image/svg+xml\");\n        // Apply the fixups to the XML.\n        const fixups = Tinter.calcSvgFixups([{contentDocument: svg}]);\n        Tinter.applySvgFixups(fixups);\n        // Encoded the fixed up SVG as a data URL.\n        const svgString = new XMLSerializer().serializeToString(svg);\n        tintedDownloadImageURL = \"data:image/svg+xml;base64,\" + window.btoa(svgString);\n        // Notify each mounted MFileBody that the URL has changed.\n        Object.keys(mounts).forEach(function(id) {\n            mounts[id].tint();\n        });\n    });\n}\n\nTinter.registerTintable(updateTintedDownloadImage);\n\n// User supplied content can contain scripts, we have to be careful that\n// we don't accidentally run those script within the same origin as the\n// client. Otherwise those scripts written by remote users can read\n// the access token and end-to-end keys that are in local storage.\n//\n// For attachments downloaded directly from the homeserver we can use\n// Content-Security-Policy headers to disable script execution.\n//\n// But attachments with end-to-end encryption are more difficult to handle.\n// We need to decrypt the attachment on the client and then display it.\n// To display the attachment we need to turn the decrypted bytes into a URL.\n//\n// There are two ways to turn bytes into URLs, data URL and blob URLs.\n// Data URLs aren't suitable for downloading a file because Chrome has a\n// 2MB limit on the size of URLs that can be viewed in the browser or\n// downloaded. This limit does not seem to apply when the url is used as\n// the source attribute of an image tag.\n//\n// Blob URLs are generated using window.URL.createObjectURL and unfortunately\n// for our purposes they inherit the origin of the page that created them.\n// This means that any scripts that run when the URL is viewed will be able\n// to access local storage.\n//\n// The easiest solution is to host the code that generates the blob URL on\n// a different domain to the client.\n// Another possibility is to generate the blob URL within a sandboxed iframe.\n// The downside of using a second domain is that it complicates hosting,\n// the downside of using a sandboxed iframe is that the browers are overly\n// restrictive in what you are allowed to do with the generated URL.\n\n/**\n * Get the current CSS style for a DOMElement.\n * @param {HTMLElement} element The element to get the current style of.\n * @return {string} The CSS style encoded as a string.\n */\nfunction computedStyle(element) {\n    if (!element) {\n        return \"\";\n    }\n    const style = window.getComputedStyle(element, null);\n    let cssText = style.cssText;\n    if (cssText == \"\") {\n        // Firefox doesn't implement \".cssText\" for computed styles.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n        for (let i = 0; i < style.length; i++) {\n            cssText += style[i] + \":\";\n            cssText += style.getPropertyValue(style[i]) + \";\";\n        }\n    }\n    return cssText;\n}\n\nexport default class MFileBody extends React.Component {\n    static propTypes = {\n        /* the MatrixEvent to show */\n        mxEvent: PropTypes.object.isRequired,\n        /* already decrypted blob */\n        decryptedBlob: PropTypes.object,\n        /* called when the download link iframe is shown */\n        onHeightChanged: PropTypes.func,\n        /* the shape of the tile, used */\n        tileShape: PropTypes.string,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            decryptedBlob: (this.props.decryptedBlob ? this.props.decryptedBlob : null),\n        };\n\n        this._iframe = createRef();\n        this._dummyLink = createRef();\n        this._downloadImage = createRef();\n    }\n\n    /**\n     * Extracts a human readable label for the file attachment to use as\n     * link text.\n     *\n     * @param {Object} content The \"content\" key of the matrix event.\n     * @return {string} the human readable link text for the attachment.\n     */\n    presentableTextForFile(content) {\n        let linkText = _t(\"Attachment\");\n        if (content.body && content.body.length > 0) {\n            // The content body should be the name of the file including a\n            // file extension.\n            linkText = content.body;\n        }\n\n        if (content.info && content.info.size) {\n            // If we know the size of the file then add it as human readable\n            // string to the end of the link text so that the user knows how\n            // big a file they are downloading.\n            // The content.info also contains a MIME-type but we don't display\n            // it since it is \"ugly\", users generally aren't aware what it\n            // means and the type of the attachment can usually be inferrered\n            // from the file extension.\n            linkText += ' (' + filesize(content.info.size) + ')';\n        }\n        return linkText;\n    }\n\n    _getContentUrl() {\n        const content = this.props.mxEvent.getContent();\n        return MatrixClientPeg.get().mxcUrlToHttp(content.url);\n    }\n\n    componentDidMount() {\n        // Add this to the list of mounted components to receive notifications\n        // when the tint changes.\n        this.id = nextMountId++;\n        mounts[this.id] = this;\n        this.tint();\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        if (this.props.onHeightChanged && !prevState.decryptedBlob && this.state.decryptedBlob) {\n            this.props.onHeightChanged();\n        }\n    }\n\n    componentWillUnmount() {\n        // Remove this from the list of mounted components\n        delete mounts[this.id];\n    }\n\n    tint = () => {\n        // Update our tinted copy of require(\"../../../../res/img/download.svg\")\n        if (this._downloadImage.current) {\n            this._downloadImage.current.src = tintedDownloadImageURL;\n        }\n        if (this._iframe.current) {\n            // If the attachment is encrypted then the download image\n            // will be inside the iframe so we wont be able to update\n            // it directly.\n            this._iframe.current.contentWindow.postMessage({\n                imgSrc: tintedDownloadImageURL,\n                style: computedStyle(this._dummyLink.current),\n            }, \"*\");\n        }\n    };\n\n    render() {\n        const content = this.props.mxEvent.getContent();\n        const text = this.presentableTextForFile(content);\n        const isEncrypted = content.file !== undefined;\n        const fileName = content.body && content.body.length > 0 ? content.body : _t(\"Attachment\");\n        const contentUrl = this._getContentUrl();\n        const ErrorDialog = sdk.getComponent(\"dialogs.ErrorDialog\");\n        const fileSize = content.info ? content.info.size : null;\n        const fileType = content.info ? content.info.mimetype : \"application/octet-stream\";\n\n        if (isEncrypted) {\n            if (this.state.decryptedBlob === null) {\n                // Need to decrypt the attachment\n                // Wait for the user to click on the link before downloading\n                // and decrypting the attachment.\n                let decrypting = false;\n                const decrypt = (e) => {\n                    if (decrypting) {\n                        return false;\n                    }\n                    decrypting = true;\n                    decryptFile(content.file).then((blob) => {\n                        this.setState({\n                            decryptedBlob: blob,\n                        });\n                    }).catch((err) => {\n                        console.warn(\"Unable to decrypt attachment: \", err);\n                        Modal.createTrackedDialog('Error decrypting attachment', '', ErrorDialog, {\n                            title: _t(\"Error\"),\n                            description: _t(\"Error decrypting attachment\"),\n                        });\n                    }).finally(() => {\n                        decrypting = false;\n                    });\n                };\n\n                // This button should actually Download because usercontent/ will try to click itself\n                // but it is not guaranteed between various browsers' settings.\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <AccessibleButton onClick={decrypt}>\n                                { _t(\"Decrypt %(text)s\", { text: text }) }\n                            </AccessibleButton>\n                        </div>\n                    </span>\n                );\n            }\n\n            // When the iframe loads we tell it to render a download link\n            const onIframeLoad = (ev) => {\n                ev.target.contentWindow.postMessage({\n                    imgSrc: tintedDownloadImageURL,\n                    style: computedStyle(this._dummyLink.current),\n                    blob: this.state.decryptedBlob,\n                    // Set a download attribute for encrypted files so that the file\n                    // will have the correct name when the user tries to download it.\n                    // We can't provide a Content-Disposition header like we would for HTTP.\n                    download: fileName,\n                    textContent: _t(\"Download %(text)s\", { text: text }),\n                    // only auto-download if a user triggered this iframe explicitly\n                    auto: !this.props.decryptedBlob,\n                }, \"*\");\n            };\n\n            const url = \"usercontent/\"; // XXX: this path should probably be passed from the skin\n\n            // If the attachment is encrypted then put the link inside an iframe.\n            return (\n                <span className=\"mx_MFileBody\">\n                    <div className=\"mx_MFileBody_download\">\n                        <div style={{display: \"none\"}}>\n                            { /*\n                              * Add dummy copy of the \"a\" tag\n                              * We'll use it to learn how the download link\n                              * would have been styled if it was rendered inline.\n                              */ }\n                            <a ref={this._dummyLink} />\n                        </div>\n                        <iframe\n                            src={`${url}?origin=${encodeURIComponent(window.location.origin)}`}\n                            onLoad={onIframeLoad}\n                            ref={this._iframe}\n                            sandbox=\"allow-scripts allow-downloads allow-downloads-without-user-activation\" />\n                    </div>\n                </span>\n            );\n        } else if (contentUrl) {\n            const downloadProps = {\n                target: \"_blank\",\n                rel: \"noreferrer noopener\",\n\n                // We set the href regardless of whether or not we intercept the download\n                // because we don't really want to convert the file to a blob eagerly, and\n                // still want \"open in new tab\" and \"save link as\" to work.\n                href: contentUrl,\n            };\n\n            // Blobs can only have up to 500mb, so if the file reports as being too large then\n            // we won't try and convert it. Likewise, if the file size is unknown then we'll assume\n            // it is too big. There is the risk of the reported file size and the actual file size\n            // being different, however the user shouldn't normally run into this problem.\n            const fileTooBig = typeof(fileSize) === 'number' ? fileSize > 524288000 : true;\n\n            if ([\"application/pdf\"].includes(fileType) && !fileTooBig) {\n                // We want to force a download on this type, so use an onClick handler.\n                downloadProps[\"onClick\"] = (e) => {\n                    console.log(`Downloading ${fileType} as blob (unencrypted)`);\n\n                    // Avoid letting the <a> do its thing\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    // Start a fetch for the download\n                    // Based upon https://stackoverflow.com/a/49500465\n                    fetch(contentUrl).then((response) => response.blob()).then((blob) => {\n                        const blobUrl = URL.createObjectURL(blob);\n\n                        // We have to create an anchor to download the file\n                        const tempAnchor = document.createElement('a');\n                        tempAnchor.download = fileName;\n                        tempAnchor.href = blobUrl;\n                        document.body.appendChild(tempAnchor); // for firefox: https://stackoverflow.com/a/32226068\n                        tempAnchor.click();\n                        tempAnchor.remove();\n                    });\n                };\n            } else {\n                // Else we are hoping the browser will do the right thing\n                downloadProps[\"download\"] = fileName;\n            }\n\n            // If the attachment is not encrypted then we check whether we\n            // are being displayed in the room timeline or in a list of\n            // files in the right hand side of the screen.\n            if (this.props.tileShape === \"file_grid\") {\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <a className=\"mx_MFileBody_downloadLink\" {...downloadProps}>\n                                { fileName }\n                            </a>\n                            <div className=\"mx_MImageBody_size\">\n                                { content.info && content.info.size ? filesize(content.info.size) : \"\" }\n                            </div>\n                        </div>\n                    </span>\n                );\n            } else {\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <a {...downloadProps}>\n                                <img src={tintedDownloadImageURL} width=\"12\" height=\"14\" ref={this._downloadImage} />\n                                { _t(\"Download %(text)s\", { text: text }) }\n                            </a>\n                        </div>\n                    </span>\n                );\n            }\n        } else {\n            const extra = text ? (': ' + text) : '';\n            return <span className=\"mx_MFileBody\">\n                { _t(\"Invalid file%(extra)s\", { extra: extra }) }\n            </span>;\n        }\n    }\n}\n", "const params = window.location.search.substring(1).split('&');\nlet lockOrigin;\nfor (let i = 0; i < params.length; ++i) {\n    const parts = params[i].split('=');\n    if (parts[0] === 'origin') lockOrigin = decodeURIComponent(parts[1]);\n}\n\nfunction remoteRender(event) {\n    const data = event.data;\n\n    const img = document.createElement(\"img\");\n    img.id = \"img\";\n    img.src = data.imgSrc;\n    img.style = data.imgStyle;\n\n    const a = document.createElement(\"a\");\n    a.id = \"a\";\n    a.rel = \"noreferrer noopener\";\n    a.download = data.download;\n    a.style = data.style;\n    a.style.fontFamily = \"Arial, Helvetica, Sans-Serif\";\n    a.href = window.URL.createObjectURL(data.blob);\n    a.appendChild(img);\n    a.appendChild(document.createTextNode(data.textContent));\n\n    const body = document.body;\n    // Don't display scrollbars if the link takes more than one line to display.\n    body.style = \"margin: 0px; overflow: hidden\";\n    body.appendChild(a);\n\n    if (event.data.auto) {\n        a.click(); // try to trigger download automatically\n    }\n}\n\nfunction remoteSetTint(event) {\n    const data = event.data;\n\n    const img = document.getElementById(\"img\");\n    img.src = data.imgSrc;\n    img.style = data.imgStyle;\n\n    const a = document.getElementById(\"a\");\n    a.style = data.style;\n}\n\nwindow.onmessage = function(e) {\n    if (e.origin === lockOrigin) {\n        if (e.data.blob) remoteRender(e);\n        else remoteSetTint(e);\n    }\n};\n"], "fixing_code": ["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, {createRef} from 'react';\nimport PropTypes from 'prop-types';\nimport filesize from 'filesize';\nimport {MatrixClientPeg} from '../../../MatrixClientPeg';\nimport * as sdk from '../../../index';\nimport { _t } from '../../../languageHandler';\nimport {decryptFile} from '../../../utils/DecryptFile';\nimport Tinter from '../../../Tinter';\nimport request from 'browser-request';\nimport Modal from '../../../Modal';\nimport AccessibleButton from \"../elements/AccessibleButton\";\n\n\n// A cached tinted copy of require(\"../../../../res/img/download.svg\")\nlet tintedDownloadImageURL;\n// Track a list of mounted MFileBody instances so that we can update\n// the require(\"../../../../res/img/download.svg\") when the tint changes.\nlet nextMountId = 0;\nconst mounts = {};\n\n/**\n * Updates the tinted copy of require(\"../../../../res/img/download.svg\") when the tint changes.\n */\nfunction updateTintedDownloadImage() {\n    // Download the svg as an XML document.\n    // We could cache the XML response here, but since the tint rarely changes\n    // it's probably not worth it.\n    // Also note that we can't use fetch here because fetch doesn't support\n    // file URLs, which the download image will be if we're running from\n    // the filesystem (like in an Electron wrapper).\n    request({uri: require(\"../../../../res/img/download.svg\")}, (err, response, body) => {\n        if (err) return;\n\n        const svg = new DOMParser().parseFromString(body, \"image/svg+xml\");\n        // Apply the fixups to the XML.\n        const fixups = Tinter.calcSvgFixups([{contentDocument: svg}]);\n        Tinter.applySvgFixups(fixups);\n        // Encoded the fixed up SVG as a data URL.\n        const svgString = new XMLSerializer().serializeToString(svg);\n        tintedDownloadImageURL = \"data:image/svg+xml;base64,\" + window.btoa(svgString);\n        // Notify each mounted MFileBody that the URL has changed.\n        Object.keys(mounts).forEach(function(id) {\n            mounts[id].tint();\n        });\n    });\n}\n\nTinter.registerTintable(updateTintedDownloadImage);\n\n// User supplied content can contain scripts, we have to be careful that\n// we don't accidentally run those script within the same origin as the\n// client. Otherwise those scripts written by remote users can read\n// the access token and end-to-end keys that are in local storage.\n//\n// For attachments downloaded directly from the homeserver we can use\n// Content-Security-Policy headers to disable script execution.\n//\n// But attachments with end-to-end encryption are more difficult to handle.\n// We need to decrypt the attachment on the client and then display it.\n// To display the attachment we need to turn the decrypted bytes into a URL.\n//\n// There are two ways to turn bytes into URLs, data URL and blob URLs.\n// Data URLs aren't suitable for downloading a file because Chrome has a\n// 2MB limit on the size of URLs that can be viewed in the browser or\n// downloaded. This limit does not seem to apply when the url is used as\n// the source attribute of an image tag.\n//\n// Blob URLs are generated using window.URL.createObjectURL and unfortunately\n// for our purposes they inherit the origin of the page that created them.\n// This means that any scripts that run when the URL is viewed will be able\n// to access local storage.\n//\n// The easiest solution is to host the code that generates the blob URL on\n// a different domain to the client.\n// Another possibility is to generate the blob URL within a sandboxed iframe.\n// The downside of using a second domain is that it complicates hosting,\n// the downside of using a sandboxed iframe is that the browers are overly\n// restrictive in what you are allowed to do with the generated URL.\n\n/**\n * Get the current CSS style for a DOMElement.\n * @param {HTMLElement} element The element to get the current style of.\n * @return {string} The CSS style encoded as a string.\n */\nfunction computedStyle(element) {\n    if (!element) {\n        return \"\";\n    }\n    const style = window.getComputedStyle(element, null);\n    let cssText = style.cssText;\n    if (cssText == \"\") {\n        // Firefox doesn't implement \".cssText\" for computed styles.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n        for (let i = 0; i < style.length; i++) {\n            cssText += style[i] + \":\";\n            cssText += style.getPropertyValue(style[i]) + \";\";\n        }\n    }\n    return cssText;\n}\n\nexport default class MFileBody extends React.Component {\n    static propTypes = {\n        /* the MatrixEvent to show */\n        mxEvent: PropTypes.object.isRequired,\n        /* already decrypted blob */\n        decryptedBlob: PropTypes.object,\n        /* called when the download link iframe is shown */\n        onHeightChanged: PropTypes.func,\n        /* the shape of the tile, used */\n        tileShape: PropTypes.string,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            decryptedBlob: (this.props.decryptedBlob ? this.props.decryptedBlob : null),\n        };\n\n        this._iframe = createRef();\n        this._dummyLink = createRef();\n        this._downloadImage = createRef();\n    }\n\n    /**\n     * Extracts a human readable label for the file attachment to use as\n     * link text.\n     *\n     * @param {Object} content The \"content\" key of the matrix event.\n     * @return {string} the human readable link text for the attachment.\n     */\n    presentableTextForFile(content) {\n        let linkText = _t(\"Attachment\");\n        if (content.body && content.body.length > 0) {\n            // The content body should be the name of the file including a\n            // file extension.\n            linkText = content.body;\n        }\n\n        if (content.info && content.info.size) {\n            // If we know the size of the file then add it as human readable\n            // string to the end of the link text so that the user knows how\n            // big a file they are downloading.\n            // The content.info also contains a MIME-type but we don't display\n            // it since it is \"ugly\", users generally aren't aware what it\n            // means and the type of the attachment can usually be inferrered\n            // from the file extension.\n            linkText += ' (' + filesize(content.info.size) + ')';\n        }\n        return linkText;\n    }\n\n    _getContentUrl() {\n        const content = this.props.mxEvent.getContent();\n        return MatrixClientPeg.get().mxcUrlToHttp(content.url);\n    }\n\n    componentDidMount() {\n        // Add this to the list of mounted components to receive notifications\n        // when the tint changes.\n        this.id = nextMountId++;\n        mounts[this.id] = this;\n        this.tint();\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        if (this.props.onHeightChanged && !prevState.decryptedBlob && this.state.decryptedBlob) {\n            this.props.onHeightChanged();\n        }\n    }\n\n    componentWillUnmount() {\n        // Remove this from the list of mounted components\n        delete mounts[this.id];\n    }\n\n    tint = () => {\n        // Update our tinted copy of require(\"../../../../res/img/download.svg\")\n        if (this._downloadImage.current) {\n            this._downloadImage.current.src = tintedDownloadImageURL;\n        }\n        if (this._iframe.current) {\n            // If the attachment is encrypted then the download image\n            // will be inside the iframe so we wont be able to update\n            // it directly.\n            this._iframe.current.contentWindow.postMessage({\n                imgSrc: tintedDownloadImageURL,\n                style: computedStyle(this._dummyLink.current),\n            }, \"*\");\n        }\n    };\n\n    render() {\n        const content = this.props.mxEvent.getContent();\n        const text = this.presentableTextForFile(content);\n        const isEncrypted = content.file !== undefined;\n        const fileName = content.body && content.body.length > 0 ? content.body : _t(\"Attachment\");\n        const contentUrl = this._getContentUrl();\n        const ErrorDialog = sdk.getComponent(\"dialogs.ErrorDialog\");\n        const fileSize = content.info ? content.info.size : null;\n        const fileType = content.info ? content.info.mimetype : \"application/octet-stream\";\n\n        if (isEncrypted) {\n            if (this.state.decryptedBlob === null) {\n                // Need to decrypt the attachment\n                // Wait for the user to click on the link before downloading\n                // and decrypting the attachment.\n                let decrypting = false;\n                const decrypt = (e) => {\n                    if (decrypting) {\n                        return false;\n                    }\n                    decrypting = true;\n                    decryptFile(content.file).then((blob) => {\n                        this.setState({\n                            decryptedBlob: blob,\n                        });\n                    }).catch((err) => {\n                        console.warn(\"Unable to decrypt attachment: \", err);\n                        Modal.createTrackedDialog('Error decrypting attachment', '', ErrorDialog, {\n                            title: _t(\"Error\"),\n                            description: _t(\"Error decrypting attachment\"),\n                        });\n                    }).finally(() => {\n                        decrypting = false;\n                    });\n                };\n\n                // This button should actually Download because usercontent/ will try to click itself\n                // but it is not guaranteed between various browsers' settings.\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <AccessibleButton onClick={decrypt}>\n                                { _t(\"Decrypt %(text)s\", { text: text }) }\n                            </AccessibleButton>\n                        </div>\n                    </span>\n                );\n            }\n\n            // When the iframe loads we tell it to render a download link\n            const onIframeLoad = (ev) => {\n                ev.target.contentWindow.postMessage({\n                    imgSrc: tintedDownloadImageURL,\n                    style: computedStyle(this._dummyLink.current),\n                    blob: this.state.decryptedBlob,\n                    // Set a download attribute for encrypted files so that the file\n                    // will have the correct name when the user tries to download it.\n                    // We can't provide a Content-Disposition header like we would for HTTP.\n                    download: fileName,\n                    textContent: _t(\"Download %(text)s\", { text: text }),\n                    // only auto-download if a user triggered this iframe explicitly\n                    auto: !this.props.decryptedBlob,\n                }, \"*\");\n            };\n\n            const url = \"usercontent/\"; // XXX: this path should probably be passed from the skin\n\n            // If the attachment is encrypted then put the link inside an iframe.\n            return (\n                <span className=\"mx_MFileBody\">\n                    <div className=\"mx_MFileBody_download\">\n                        <div style={{display: \"none\"}}>\n                            { /*\n                              * Add dummy copy of the \"a\" tag\n                              * We'll use it to learn how the download link\n                              * would have been styled if it was rendered inline.\n                              */ }\n                            <a ref={this._dummyLink} />\n                        </div>\n                        <iframe\n                            src={url}\n                            onLoad={onIframeLoad}\n                            ref={this._iframe}\n                            sandbox=\"allow-scripts allow-downloads allow-downloads-without-user-activation\" />\n                    </div>\n                </span>\n            );\n        } else if (contentUrl) {\n            const downloadProps = {\n                target: \"_blank\",\n                rel: \"noreferrer noopener\",\n\n                // We set the href regardless of whether or not we intercept the download\n                // because we don't really want to convert the file to a blob eagerly, and\n                // still want \"open in new tab\" and \"save link as\" to work.\n                href: contentUrl,\n            };\n\n            // Blobs can only have up to 500mb, so if the file reports as being too large then\n            // we won't try and convert it. Likewise, if the file size is unknown then we'll assume\n            // it is too big. There is the risk of the reported file size and the actual file size\n            // being different, however the user shouldn't normally run into this problem.\n            const fileTooBig = typeof(fileSize) === 'number' ? fileSize > 524288000 : true;\n\n            if ([\"application/pdf\"].includes(fileType) && !fileTooBig) {\n                // We want to force a download on this type, so use an onClick handler.\n                downloadProps[\"onClick\"] = (e) => {\n                    console.log(`Downloading ${fileType} as blob (unencrypted)`);\n\n                    // Avoid letting the <a> do its thing\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    // Start a fetch for the download\n                    // Based upon https://stackoverflow.com/a/49500465\n                    fetch(contentUrl).then((response) => response.blob()).then((blob) => {\n                        const blobUrl = URL.createObjectURL(blob);\n\n                        // We have to create an anchor to download the file\n                        const tempAnchor = document.createElement('a');\n                        tempAnchor.download = fileName;\n                        tempAnchor.href = blobUrl;\n                        document.body.appendChild(tempAnchor); // for firefox: https://stackoverflow.com/a/32226068\n                        tempAnchor.click();\n                        tempAnchor.remove();\n                    });\n                };\n            } else {\n                // Else we are hoping the browser will do the right thing\n                downloadProps[\"download\"] = fileName;\n            }\n\n            // If the attachment is not encrypted then we check whether we\n            // are being displayed in the room timeline or in a list of\n            // files in the right hand side of the screen.\n            if (this.props.tileShape === \"file_grid\") {\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <a className=\"mx_MFileBody_downloadLink\" {...downloadProps}>\n                                { fileName }\n                            </a>\n                            <div className=\"mx_MImageBody_size\">\n                                { content.info && content.info.size ? filesize(content.info.size) : \"\" }\n                            </div>\n                        </div>\n                    </span>\n                );\n            } else {\n                return (\n                    <span className=\"mx_MFileBody\">\n                        <div className=\"mx_MFileBody_download\">\n                            <a {...downloadProps}>\n                                <img src={tintedDownloadImageURL} width=\"12\" height=\"14\" ref={this._downloadImage} />\n                                { _t(\"Download %(text)s\", { text: text }) }\n                            </a>\n                        </div>\n                    </span>\n                );\n            }\n        } else {\n            const extra = text ? (': ' + text) : '';\n            return <span className=\"mx_MFileBody\">\n                { _t(\"Invalid file%(extra)s\", { extra: extra }) }\n            </span>;\n        }\n    }\n}\n", "function remoteRender(event) {\n    const data = event.data;\n\n    const img = document.createElement(\"img\");\n    img.id = \"img\";\n    img.src = data.imgSrc;\n    img.style = data.imgStyle;\n\n    const a = document.createElement(\"a\");\n    a.id = \"a\";\n    a.rel = \"noreferrer noopener\";\n    a.download = data.download;\n    a.style = data.style;\n    a.style.fontFamily = \"Arial, Helvetica, Sans-Serif\";\n    a.href = window.URL.createObjectURL(data.blob);\n    a.appendChild(img);\n    a.appendChild(document.createTextNode(data.textContent));\n\n    const body = document.body;\n    // Don't display scrollbars if the link takes more than one line to display.\n    body.style = \"margin: 0px; overflow: hidden\";\n    body.appendChild(a);\n\n    if (event.data.auto) {\n        a.click(); // try to trigger download automatically\n    }\n}\n\nfunction remoteSetTint(event) {\n    const data = event.data;\n\n    const img = document.getElementById(\"img\");\n    img.src = data.imgSrc;\n    img.style = data.imgStyle;\n\n    const a = document.getElementById(\"a\");\n    a.style = data.style;\n}\n\nwindow.onmessage = function(e) {\n    if (e.origin === window.location.origin) {\n        if (e.data.blob) remoteRender(e);\n        else remoteSetTint(e);\n    }\n};\n"], "filenames": ["src/components/views/messages/MFileBody.js", "src/usercontent/index.js"], "buggy_code_start_loc": [291, 1], "buggy_code_end_loc": [292, 49], "fixing_code_start_loc": [291, 0], "fixing_code_end_loc": [292, 42], "type": "CWE-345", "message": "matrix-react-sdk is an npm package which is a Matrix SDK for React Javascript. In matrix-react-sdk before version 3.15.0, the user content sandbox can be abused to trick users into opening unexpected documents. The content is opened with a `blob` origin that cannot access Matrix user data, so messages and secrets are not at risk. This has been fixed in version 3.15.0.", "other": {"cve": {"id": "CVE-2021-21320", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-02T03:15:13.213", "lastModified": "2021-03-08T19:39:42.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-react-sdk is an npm package which is a Matrix SDK for React Javascript. In matrix-react-sdk before version 3.15.0, the user content sandbox can be abused to trick users into opening unexpected documents. The content is opened with a `blob` origin that cannot access Matrix user data, so messages and secrets are not at risk. This has been fixed in version 3.15.0."}, {"lang": "es", "value": "matrix-react-sdk es un paquete npm que es un Matrix SDK para React Javascript.&#xa0;En matrix-react-sdk anterior a la versi\u00f3n 3.15.0, el sandbox del contenido del usuario puede ser abusado para enga\u00f1ar a los usuarios para que abran documentos inesperados.&#xa0;El contenido es abierto con un origen \"blob\" que no puede acceder a los datos del usuario de Matrix, por lo que los mensajes y secretos no est\u00e1n en riesgo.&#xa0;Esto ha sido corregido en la versi\u00f3n 3.15.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix-react-sdk_project:matrix-react-sdk:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.15.0", "matchCriteriaId": "AFAB6F64-94AF-40C9-9D0F-960483AED3F5"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-react-sdk/commit/b386f0c73b95ecbb6ea7f8f79c6ff5171a8dedd1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-react-sdk/pull/5657", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-react-sdk/security/advisories/GHSA-52mq-6jcv-j79x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/matrix-react-sdk", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-react-sdk/commit/b386f0c73b95ecbb6ea7f8f79c6ff5171a8dedd1"}}