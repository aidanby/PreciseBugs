{"buggy_code": ["package validatemodels\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\nconst (\n\tdatastoreEngineFlag = \"datastore-engine\"\n\tdatastoreURIFlag    = \"datastore-uri\"\n)\n\nfunc NewValidateCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"validate-models\",\n\t\tShort: \"Validate authorization models. NOTE: this command is in beta and may be removed in future releases.\",\n\t\tLong:  \"List all authorization models across all stores and run validations against them.\\nNOTE: this command is in beta and may be removed in future releases.\",\n\t\tRunE:  runValidate,\n\t\tArgs:  cobra.NoArgs,\n\t}\n\n\tflags := cmd.Flags()\n\tflags.String(datastoreEngineFlag, \"\", \"the datastore engine\")\n\tflags.String(datastoreURIFlag, \"\", \"the connection uri to the datastore\")\n\n\t// NOTE: if you add a new flag here, update the function below, too\n\n\tcmd.PreRun = bindRunFlagsFunc(flags)\n\n\treturn cmd\n}\n\ntype validationResult struct {\n\tStoreID       string `json:\"store_id\"`\n\tModelID       string `json:\"model_id\"`\n\tIsLatestModel bool   `json:\"is_latest_model\"`\n\tError         string `json:\"error\"`\n}\n\nfunc runValidate(_ *cobra.Command, _ []string) error {\n\tengine := viper.GetString(datastoreEngineFlag)\n\turi := viper.GetString(datastoreURIFlag)\n\n\tctx := context.Background()\n\n\tvar (\n\t\tdb  storage.OpenFGADatastore\n\t\terr error\n\t)\n\tswitch engine {\n\tcase \"mysql\":\n\t\tdb, err = mysql.New(uri, sqlcommon.NewConfig())\n\tcase \"postgres\":\n\t\tdb, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"\":\n\t\treturn fmt.Errorf(\"missing datastore engine type\")\n\tcase \"memory\":\n\t\tfallthrough\n\tdefault:\n\t\treturn fmt.Errorf(\"storage engine '%s' is unsupported\", engine)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open a connection to the datastore: %v\", err)\n\t}\n\n\tvalidationResults, err := ValidateAllAuthorizationModels(ctx, db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmarshalled, err := json.MarshalIndent(validationResults, \" \", \"    \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error gathering validation results: %w\", err)\n\t}\n\tfmt.Println(string(marshalled))\n\n\treturn nil\n}\n\n// ValidateAllAuthorizationModels lists all stores and then, for each store, lists all models.\n// Then it runs validation on each model.\nfunc ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatastore) ([]validationResult, error) {\n\tvalidationResults := make([]validationResult, 0)\n\n\tcontinuationTokenStores := \"\"\n\n\tfor {\n\t\t// fetch a page of stores\n\t\tstores, tokenStores, err := db.ListStores(ctx, storage.PaginationOptions{\n\t\t\tPageSize: 100,\n\t\t\tFrom:     continuationTokenStores,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error reading stores: %w\", err)\n\t\t}\n\n\t\t// validate each store\n\t\tfor _, store := range stores {\n\n\t\t\tlatestModelID, err := db.FindLatestAuthorizationModelID(ctx, store.Id)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"no models in store %s \\n\", store.Id)\n\t\t\t}\n\n\t\t\tcontinuationTokenModels := \"\"\n\n\t\t\tfor {\n\t\t\t\t// fetch a page of models for that store\n\t\t\t\tmodels, tokenModels, err := db.ReadAuthorizationModels(ctx, store.Id, storage.PaginationOptions{\n\t\t\t\t\tPageSize: 100,\n\t\t\t\t\tFrom:     continuationTokenModels,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"error reading authorization models: %w\", err)\n\t\t\t\t}\n\n\t\t\t\t// validate each model\n\t\t\t\tfor _, model := range models {\n\t\t\t\t\t_, err := typesystem.NewAndValidate(model)\n\n\t\t\t\t\tvalidationResult := validationResult{\n\t\t\t\t\t\tStoreID:       store.Id,\n\t\t\t\t\t\tModelID:       model.Id,\n\t\t\t\t\t\tIsLatestModel: model.Id == latestModelID,\n\t\t\t\t\t}\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tvalidationResult.Error = err.Error()\n\t\t\t\t\t}\n\t\t\t\t\tvalidationResults = append(validationResults, validationResult)\n\t\t\t\t}\n\n\t\t\t\tcontinuationTokenModels = string(tokenModels)\n\n\t\t\t\tif continuationTokenModels == \"\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// next page of stores\n\t\tcontinuationTokenStores = string(tokenStores)\n\n\t\tif continuationTokenStores == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn validationResults, nil\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// ExpandQuery resolves a target TupleKey into a UsersetTree by expanding type definitions.\ntype ExpandQuery struct {\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n}\n\n// NewExpandQuery creates a new ExpandQuery using the supplied backends for retrieving data.\nfunc NewExpandQuery(datastore storage.OpenFGADatastore, logger logger.Logger) *ExpandQuery {\n\treturn &ExpandQuery{logger: logger, datastore: datastore}\n}\n\nfunc (q *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\tmodelID := req.GetAuthorizationModelId()\n\ttupleKey := req.GetTupleKey()\n\tobject := tupleKey.GetObject()\n\trelation := tupleKey.GetRelation()\n\n\tif object == \"\" || relation == \"\" {\n\t\treturn nil, serverErrors.InvalidExpandInput\n\t}\n\n\ttk := tupleUtils.NewTupleKey(object, relation, \"\")\n\n\tmodel, err := q.datastore.ReadAuthorizationModel(ctx, store, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(model.GetSchemaVersion()) {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\ttypesys := typesystem.New(model)\n\n\tif err = validation.ValidateObject(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\terr = validation.ValidateRelation(typesys, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tobjectType := tupleUtils.GetType(object)\n\trel, err := typesys.GetRelation(objectType, relation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn nil, serverErrors.TypeNotFound(objectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn nil, serverErrors.RelationNotFound(relation, objectType, tk)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tuserset := rel.GetRewrite()\n\n\troot, err := q.resolveUserset(ctx, store, userset, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &openfgapb.ExpandResponse{\n\t\tTree: &openfgapb.UsersetTree{\n\t\t\tRoot: root,\n\t\t},\n\t}, nil\n}\n\nfunc (q *ExpandQuery) resolveUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.Userset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUserset\")\n\tdefer span.End()\n\n\tswitch us := userset.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\treturn q.resolveThis(ctx, store, tk, typesys)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn q.resolveComputedUserset(ctx, us.ComputedUserset, tk)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn q.resolveTupleToUserset(ctx, store, us.TupleToUserset, tk, typesys)\n\tcase *openfgapb.Userset_Union:\n\t\treturn q.resolveUnionUserset(ctx, store, us.Union, tk, typesys)\n\tcase *openfgapb.Userset_Difference:\n\t\treturn q.resolveDifferenceUserset(ctx, store, us.Difference, tk, typesys)\n\tcase *openfgapb.Userset_Intersection:\n\t\treturn q.resolveIntersectionUserset(ctx, store, us.Intersection, tk, typesys)\n\tdefault:\n\t\treturn nil, serverErrors.UnsupportedUserSet\n\t}\n}\n\n// resolveThis resolves a DirectUserset into a leaf node containing a distinct set of users with that relation.\nfunc (q *ExpandQuery) resolveThis(ctx context.Context, store string, tk *openfgapb.TupleKey, typesys *typesystem.TypeSystem) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveThis\")\n\tdefer span.End()\n\n\ttupleIter, err := q.datastore.Read(ctx, store, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(tupleIter),\n\t\tvalidation.FilterInvalidTuples(typesys),\n\t)\n\tdefer filteredIter.Stop()\n\n\tdistinctUsers := make(map[string]bool)\n\tfor {\n\t\ttk, err := filteredIter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tdistinctUsers[tk.GetUser()] = true\n\t}\n\n\tusers := make([]string, 0, len(distinctUsers))\n\tfor u := range distinctUsers {\n\t\tusers = append(users, u)\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\tUsers: users,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveComputedUserset builds a leaf node containing the result of resolving a ComputedUserset rewrite.\nfunc (q *ExpandQuery) resolveComputedUserset(ctx context.Context, userset *openfgapb.ObjectRelation, tk *openfgapb.TupleKey) (*openfgapb.UsersetTree_Node, error) {\n\t_, span := tracer.Start(ctx, \"resolveComputedUserset\")\n\tdefer span.End()\n\n\tcomputed := &openfgapb.TupleKey{\n\t\tObject:   userset.GetObject(),\n\t\tRelation: userset.GetRelation(),\n\t}\n\n\tif len(computed.Object) == 0 {\n\t\tcomputed.Object = tk.Object\n\t}\n\n\tif len(computed.Relation) == 0 {\n\t\tcomputed.Relation = tk.Relation\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\tUserset: toObjectRelation(computed),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveTupleToUserset creates a new leaf node containing the result of expanding a TupleToUserset rewrite.\nfunc (q *ExpandQuery) resolveTupleToUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.TupleToUserset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveTupleToUserset\")\n\tdefer span.End()\n\n\ttargetObject := tk.GetObject()\n\n\ttupleset := userset.GetTupleset().GetRelation()\n\n\tobjectType := tupleUtils.GetType(targetObject)\n\t_, err := typesys.GetRelation(objectType, tupleset)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn nil, serverErrors.TypeNotFound(objectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn nil, serverErrors.RelationNotFound(tupleset, objectType, tupleUtils.NewTupleKey(tk.Object, tupleset, tk.User))\n\t\t}\n\t}\n\n\ttsKey := &openfgapb.TupleKey{\n\t\tObject:   targetObject,\n\t\tRelation: tupleset,\n\t}\n\n\tif tsKey.GetRelation() == \"\" {\n\t\ttsKey.Relation = tk.GetRelation()\n\t}\n\n\ttupleIter, err := q.datastore.Read(ctx, store, tsKey)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(tupleIter),\n\t\tvalidation.FilterInvalidTuples(typesys),\n\t)\n\tdefer filteredIter.Stop()\n\n\tvar computed []*openfgapb.UsersetTree_Computed\n\tseen := make(map[string]bool)\n\tfor {\n\t\ttk, err := filteredIter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tuser := tk.GetUser()\n\n\t\ttObject, tRelation := tupleUtils.SplitObjectRelation(user)\n\t\t// We only proceed in the case that tRelation == userset.GetComputedUserset().GetRelation().\n\t\t// tRelation may be empty, and in this case, we set it to userset.GetComputedUserset().GetRelation().\n\t\tif tRelation == \"\" {\n\t\t\ttRelation = userset.GetComputedUserset().GetRelation()\n\t\t}\n\n\t\tcs := &openfgapb.TupleKey{\n\t\t\tObject:   tObject,\n\t\t\tRelation: tRelation,\n\t\t}\n\n\t\tcomputedRelation := toObjectRelation(cs)\n\t\tif !seen[computedRelation] {\n\t\t\tcomputed = append(computed, &openfgapb.UsersetTree_Computed{Userset: computedRelation})\n\t\t\tseen[computedRelation] = true\n\t\t}\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\tTupleset: toObjectRelation(tsKey),\n\t\t\t\t\t\tComputed: computed,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUnionUserset creates an intermediate Usertree node containing the union of its children.\nfunc (q *ExpandQuery) resolveUnionUserset(\n\tctx context.Context,\n\tstore string,\n\tusersets *openfgapb.Usersets,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUnionUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, usersets.Child, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveIntersectionUserset create an intermediate Usertree node containing the intersection of its children\nfunc (q *ExpandQuery) resolveIntersectionUserset(\n\tctx context.Context,\n\tstore string,\n\tusersets *openfgapb.Usersets,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveIntersectionUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, usersets.Child, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveDifferenceUserset creates and intermediate Usertree node containing the difference of its children\nfunc (q *ExpandQuery) resolveDifferenceUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.Difference,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveDifferenceUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, []*openfgapb.Userset{userset.Base, userset.Subtract}, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbase := nodes[0]\n\tsubtract := nodes[1]\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: subtract,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUsersets creates Usertree nodes for multiple Usersets\nfunc (q *ExpandQuery) resolveUsersets(\n\tctx context.Context,\n\tstore string,\n\tusersets []*openfgapb.Userset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) ([]*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUsersets\")\n\tdefer span.End()\n\n\tout := make([]*openfgapb.UsersetTree_Node, len(usersets))\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tfor i, us := range usersets {\n\t\t// https://golang.org/doc/faq#closures_and_goroutines\n\t\ti, us := i, us\n\t\tgrp.Go(func() error {\n\t\t\tnode, err := q.resolveUserset(ctx, store, us, tk, typesys)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tout[i] = node\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc toObjectRelation(tk *openfgapb.TupleKey) string {\n\treturn tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n}\n", "package commands\n\nimport (\n\t\"context\"\n\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\n// WriteAuthorizationModelCommand performs updates of the store authorization model.\ntype WriteAuthorizationModelCommand struct {\n\tbackend storage.TypeDefinitionWriteBackend\n\tlogger  logger.Logger\n}\n\nfunc NewWriteAuthorizationModelCommand(\n\tbackend storage.TypeDefinitionWriteBackend,\n\tlogger logger.Logger,\n) *WriteAuthorizationModelCommand {\n\treturn &WriteAuthorizationModelCommand{\n\t\tbackend: backend,\n\t\tlogger:  logger,\n\t}\n}\n\n// Execute the command using the supplied request.\nfunc (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\t// Until this is solved: https://github.com/envoyproxy/protoc-gen-validate/issues/74\n\tif len(req.GetTypeDefinitions()) > w.backend.MaxTypesPerAuthorizationModel() {\n\t\treturn nil, serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", w.backend.MaxTypesPerAuthorizationModel())\n\t}\n\n\t// Fill in the schema version for old requests, which don't contain it, while we migrate to the new schema version.\n\tif req.SchemaVersion == \"\" {\n\t\treq.SchemaVersion = typesystem.SchemaVersion1_1\n\t}\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              ulid.Make().String(),\n\t\tSchemaVersion:   req.GetSchemaVersion(),\n\t\tTypeDefinitions: req.GetTypeDefinitions(),\n\t}\n\n\t_, err := typesystem.NewAndValidate(model)\n\tif err != nil {\n\t\treturn nil, serverErrors.InvalidAuthorizationModelInput(err)\n\t}\n\n\terr = w.backend.WriteAuthorizationModel(ctx, req.GetStoreId(), model)\n\tif err != nil {\n\t\treturn nil, serverErrors.NewInternalError(\"Error writing authorization model configuration\", err)\n\t}\n\n\treturn &openfgapb.WriteAuthorizationModelResponse{\n\t\tAuthorizationModelId: model.Id,\n\t}, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\tgrpc_ctxtags \"github.com/grpc-ecosystem/go-grpc-middleware/tags\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\thttpmiddleware \"github.com/openfga/openfga/pkg/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype ExperimentalFeatureFlag string\n\nconst (\n\tAuthorizationModelIDHeader = \"openfga-authorization-model-id\"\n\tauthorizationModelIDKey    = \"authorization_model_id\"\n\n\tcheckConcurrencyLimit = 100\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server\")\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgapb.UnimplementedOpenFGAServiceServer\n\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n\tencoder   encoder.Encoder\n\ttransport gateway.Transport\n\tconfig    *Config\n}\n\ntype Dependencies struct {\n\tDatastore    storage.OpenFGADatastore\n\tLogger       logger.Logger\n\tTransport    gateway.Transport\n\tTokenEncoder encoder.Encoder\n}\n\ntype Config struct {\n\tResolveNodeLimit       uint32\n\tChangelogHorizonOffset int\n\tListObjectsDeadline    time.Duration\n\tListObjectsMaxResults  uint32\n\tExperimentals          []ExperimentalFeatureFlag\n}\n\n// New creates a new Server which uses the supplied backends\n// for managing data.\nfunc New(dependencies *Dependencies, config *Config) *Server {\n\n\treturn &Server{\n\t\tlogger:    dependencies.Logger,\n\t\tdatastore: dependencies.Datastore,\n\t\tencoder:   dependencies.TokenEncoder,\n\t\ttransport: dependencies.Transport,\n\t\tconfig:    config,\n\t}\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequest) (*openfgapb.ListObjectsResponse, error) {\n\tstoreID := req.GetStoreId()\n\ttargetObjectType := req.GetType()\n\n\tctx, span := tracer.Start(ctx, \"ListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", targetObjectType),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tmodelID := req.GetAuthorizationModelId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, modelID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn nil, err\n\t}\n\n\ttypesys := typesystem.New(model)\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\treturn q.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 targetObjectType,\n\t\tRelation:             req.Relation,\n\t\tUser:                 req.User,\n\t})\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest, srv openfgapb.OpenFGAService_StreamedListObjectsServer) error {\n\tctx := srv.Context()\n\tctx, span := tracer.Start(ctx, \"StreamedListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", req.GetType()),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn serverErrors.AuthorizationModelNotFound(req.GetAuthorizationModelId())\n\t\t}\n\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\ttypesys := typesystem.New(model)\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treq.AuthorizationModelId = modelID\n\treturn q.ExecuteStreamed(ctx, req, srv)\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgapb.ReadRequest) (*openfgapb.ReadResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgapb.ReadRequest{\n\t\tStoreId:           req.GetStoreId(),\n\t\tTupleKey:          tk,\n\t\tPageSize:          req.GetPageSize(),\n\t\tContinuationToken: req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgapb.WriteRequest) (*openfgapb.WriteResponse, error) {\n\tctx, span := tracer.Start(ctx, \"Write\")\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.logger)\n\treturn cmd.Execute(ctx, &openfgapb.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(model.GetSchemaVersion()) {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\ttypesys := typesystem.New(model)\n\n\tif err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tcheckResolver := graph.NewLocalChecker(\n\t\tstorage.NewCombinedTupleReader(s.datastore, req.ContextualTuples.GetTupleKeys()),\n\t\tcheckConcurrencyLimit)\n\n\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\tStoreID:              req.GetStoreId(),\n\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\tTupleKey:             req.GetTupleKey(),\n\t\tContextualTuples:     req.ContextualTuples.GetTupleKeys(),\n\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\tDepth: s.config.ResolveNodeLimit,\n\t\t},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) {\n\t\t\treturn nil, serverErrors.AuthorizationModelResolutionTooComplex\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tres := &openfgapb.CheckResponse{\n\t\tAllowed: resp.Allowed,\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewExpandQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, &openfgapb.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgapb.ReadAuthorizationModelRequest) (*openfgapb.ReadAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAuthorizationModel\")\n\tdefer span.End()\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgapb.ReadAuthorizationModelsRequest) (*openfgapb.ReadAuthorizationModelsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModels\")\n\tdefer span.End()\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgapb.WriteAssertionsRequest) (*openfgapb.WriteAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAssertions\")\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgapb.WriteAssertionsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgapb.ReadAssertionsRequest) (*openfgapb.ReadAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAssertions\")\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), modelID)\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgapb.ReadChangesRequest) (*openfgapb.ReadChangesResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.logger, s.encoder, s.config.ChangelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgapb.CreateStoreRequest) (*openfgapb.CreateStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"CreateStore\")\n\tdefer span.End()\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgapb.DeleteStoreRequest) (*openfgapb.DeleteStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"DeleteStore\")\n\tdefer span.End()\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgapb.GetStoreRequest) (*openfgapb.GetStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"GetStore\")\n\tdefer span.End()\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgapb.ListStoresRequest) (*openfgapb.ListStoresResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ListStores\")\n\tdefer span.End()\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// resolveAuthorizationModelID takes a modelID. If it is empty, it will find\n// and return the latest authorization modelID. If is not empty, it will\n// validate it and return it.\n//\n// This allows caching of types. If the user inserts a new authorization model\n// and doesn't provide this field (which should be rate limited more\n// aggressively) the in-flight requests won't be affected and newer calls will\n// use the updated authorization model.\nfunc (s *Server) resolveAuthorizationModelID(ctx context.Context, store, modelID string) (string, error) {\n\tctx, span := tracer.Start(ctx, \"resolveAuthorizationModelID\")\n\tdefer span.End()\n\n\tdefer func() {\n\t\tspan.SetAttributes(attribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(modelID)})\n\t\tgrpc_ctxtags.Extract(ctx).Set(authorizationModelIDKey, modelID)\n\t\t_ = grpc.SetHeader(ctx, metadata.Pairs(AuthorizationModelIDHeader, modelID))\n\t}()\n\n\tvar err error\n\tif modelID != \"\" {\n\t\tif _, err := ulid.Parse(modelID); err != nil {\n\t\t\treturn \"\", serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn modelID, nil\n\t}\n\n\tif modelID, err = s.datastore.FindLatestAuthorizationModelID(ctx, store); err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn \"\", serverErrors.LatestAuthorizationModelNotFound(store)\n\t\t}\n\n\t\treturn \"\", serverErrors.HandleError(\"\", err)\n\t}\n\n\treturn modelID, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\tmockstorage \"github.com/openfga/openfga/pkg/storage/mocks\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"postgres\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"memory\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"mysql\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\ttuple := &openfgapb.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgapb.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(tuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tLogger:    logger.NewNoopLogger(),\n\t\tTransport: gateway.NewNoopTransport(),\n\t}, &Config{\n\t\tResolveNodeLimit: 25,\n\t})\n\n\tcheckResponse, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user:*] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\ttuple := &openfgapb.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgapb.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgapb.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgapb.Tuple{tuple}), nil\n\t\t\t})\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tLogger:    logger.NewNoopLogger(),\n\t\tTransport: gateway.NewNoopTransport(),\n\t}, &Config{\n\t\tResolveNodeLimit: 25,\n\t})\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Truef(t, end < 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveAuthorizationModelID(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\tgot, err := s.resolveAuthorizationModelID(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, got)\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\t_, err := s.resolveAuthorizationModelID(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgapb.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs TestListObjects_Unoptimized_UnhappyPaths many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n    `)\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      25,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\n// This test ensures that when the data storage fails, ListObjects v0 throws an error\nfunc TestListObjects_Unoptimized_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: parser.MustParse(`\n\t\ttype user\n\n\t\ttype repo\n\t\t  relations\n\t\t    define allowed: [user] as self\n\t\t    define viewer: [user] as self and allowed\n\t\t`),\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      25,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\n// This test ensures that when the data storage fails, ListObjects v1 throws an error\nfunc TestListObjects_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: \"document\",\n\t\tRelation:   \"viewer\",\n\t\tUserFilter: []*openfgapb.ObjectRelation{\n\t\t\t{Object: \"user:*\"},\n\t\t\t{Object: \"user:bob\"},\n\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      25,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := Server{\n\t\tdatastore: mockDatastore,\n\t\ttransport: transport,\n\t\tlogger:    logger,\n\t\tconfig: &Config{\n\t\t\tResolveNodeLimit:      25,\n\t\t\tListObjectsDeadline:   5 * time.Second,\n\t\t\tListObjectsMaxResults: 1000,\n\t\t},\n\t}\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_expand\", func(t *testing.T) {\n\t\t_, err := s.Expand(ctx, &openfgapb.ExpandRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga\",\n\t\t\t\t\"reader\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgapb.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgapb.TupleKeys{TupleKeys: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\",\n\t\t\t\t\t\"reader\",\n\t\t\t\t\t\"user:anne\"),\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgapb.WriteAuthorizationModelRequest{\n\t\t\tStoreId:         store,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustParse(`type repo`),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgapb.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgapb.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) storage.OpenFGADatastore {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc ConnectedObjectsTest(t *testing.T, ds storage.OpenFGADatastore) {\n\n\ttests := []struct {\n\t\tname             string\n\t\tmodel            string\n\t\ttuples           []*openfgapb.TupleKey\n\t\trequest          *commands.ConnectedObjectsRequest\n\t\tresolveNodeLimit uint32\n\t\tlimit            uint32\n\t\texpectedObjects  []string\n\t\texpectedError    error\n\t}{\n\t\t{\n\t\t\tname: \"restrict_results_based_on_limit\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{},\n\t\t\t},\n\t\t\tlimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"folder:folder1\", \"folder:folder2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user, group#member] as self\n\t\t\t    define viewer as owner\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user, group#member] as self or viewer from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"folder:folder1\", \"folder:folder2\", \"folder:folder3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &commands.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgapb.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"group:opensource\", \"group:eng\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user] as self\n\t\t\t    define editor as owner\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t    define member as manager\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define member: [user,team#member] as self or admin\n\n\t\t\ttype trial\n\t\t\t  relations\n\t\t\t    define editor: [user,team#member] as self or owner\n\t\t\t    define owner: [user] as self\n\t\t\t    define viewer: [user,team#member] as self or editor\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"trial:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define viewer: [organization] as self\n\t\t\t    define can_view as viewer\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [organization] as self\n\t\t\t    define view as can_view from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"connected_objects_with_public_user_access_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"connected_objects_with_public_user_access_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user, user:*, group#member] as self or writer\n\t\t\t\tdefine writer: [user, user:*, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:x\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgapb.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, employee:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:eng_handbook\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t    define reader: [org#dept_member] as self or writer\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:eng_handbook\"},\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"node:abc\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.Typesystem = typesystem.New(model)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tif test.resolveNodeLimit == 0 {\n\t\t\t\ttest.resolveNodeLimit = defaultResolveNodeLimit\n\t\t\t}\n\n\t\t\tconnectedObjectsCmd := commands.ConnectedObjectsCommand{\n\t\t\t\tDatastore:        ds,\n\t\t\t\tResolveNodeLimit: test.resolveNodeLimit,\n\t\t\t\tLimit:            test.limit,\n\t\t\t}\n\n\t\t\tresultChan := make(chan commands.ListObjectsResult, 100)\n\t\t\tdone := make(chan struct{})\n\n\t\t\tvar results []string\n\t\t\tgo func() {\n\t\t\t\tfor result := range resultChan {\n\t\t\t\t\tresults = append(results, result.ObjectID)\n\t\t\t\t}\n\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tgo func() {\n\t\t\t\terr = connectedObjectsCmd.StreamedConnectedObjects(timeoutCtx, test.request, resultChan)\n\t\t\t\trequire.ErrorIs(err, test.expectedError)\n\t\t\t\tclose(resultChan)\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-timeoutCtx.Done():\n\t\t\t\trequire.FailNow(\"timed out waiting for response\")\n\t\t\tcase <-done:\n\t\t\t}\n\n\t\t\tif test.expectedError == nil {\n\t\t\t\tsort.Strings(results)\n\t\t\t\tsort.Strings(test.expectedObjects)\n\n\t\t\t\trequire.Equal(test.expectedObjects, results)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/testing/protocmp\"\n)\n\nfunc TestExpandQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    *openfgapb.AuthorizationModel\n\t\ttuples   []*openfgapb.TupleKey\n\t\trequest  *openfgapb.ExpandRequest\n\t\texpected *openfgapb.ExpandResponse\n\t}{\n\t\t{\n\t\t\tname: \"1.1_simple_direct\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_computed_userset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  typesystem.This(),\n\t\t\t\t\t\t\t\"writer\": typesystem.ComputedUserset(\"admin\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset_II\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"amy\", // should be skipped since it's not a valid target for a tupleset relation\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset_implicit\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_simple_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t\t\"writer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_simple_difference\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  typesystem.This(),\n\t\t\t\t\t\t\t\"banned\": typesystem.This(),\n\t\t\t\t\t\t\t\"active_admin\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\"),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"banned\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"banned\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"active_admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t\t// Writers must be both directly in 'writers', and in 'admins'\n\t\t\t\t\t\t\t\"writer\": typesystem.Intersection(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_complex_tree\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":         typesystem.This(),\n\t\t\t\t\t\t\t\"owner\":         typesystem.This(),\n\t\t\t\t\t\t\t\"banned_writer\": typesystem.This(),\n\t\t\t\t\t\t\t// Users can write if they are direct members of writers, or repo_writers\n\t\t\t\t\t\t\t// in the org, unless they are also in banned_writers\n\t\t\t\t\t\t\t\"writer\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.Union(\n\t\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"owner\", \"repo_writer\")),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"banned_writer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"owner\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"banned_writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_writer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Userset: \"org:openfga#repo_writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_Tuple_involving_userset_that_is_not_involved_in_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"editor\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"document\", \"editor\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"document:2#editor\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"parent\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#parent\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"document:2#editor\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_TupleToUserset_involving_wildcard_is_skipped\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:X\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"document:1#parent\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_Tuple_involving_userset_skipped_if_it_is_referenced_in_a_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"editor\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"document\", \"editor\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"document:2#editor\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"document:1#parent\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_Tuple_involving_userset_skipped_if_same_ComputedUserset_involved_in_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{Type: \"user\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"document\", \"viewer\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"document:2#viewer\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"document:1#parent\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_Tupleset_relation_involving_rewrite_skipped\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t\"editor\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.This(), typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{Type: \"document\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{Type: \"user\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"editor\", \"document:2\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"document:1#viewer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"document:1#parent\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// arrange\n\t\t\tstore := ulid.Make().String()\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, test.model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = test.model.Id\n\n\t\t\t// act\n\t\t\tquery := commands.NewExpandQuery(datastore, logger)\n\t\t\tgot, err := query.Execute(ctx, test.request)\n\t\t\trequire.NoError(err)\n\n\t\t\t// assert\n\t\t\tif diff := cmp.Diff(test.expected, got, protocmp.Transform()); diff != \"\" {\n\t\t\t\tt.Errorf(\"mismatch (-want, +got):\\n%s\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgapb.AuthorizationModel\n\t\ttuples        []*openfgapb.TupleKey\n\t\trequest       *openfgapb.ExpandRequest\n\t\tallowSchema10 bool\n\t\texpected      error\n\t}{\n\t\t{\n\t\t\tname: \"missing_object_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected:      serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"missing_object_id_and_type_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \":\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid 'object' field format\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"missing_object_id_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"github:\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid 'object' field format\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"missing_relation_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected:      serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_object_type_not_found_in_model\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"foo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\t&tuple.TypeNotFoundError{TypeName: \"foo\"},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_relation_not_found_in_model\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\t&tuple.RelationNotFoundError{\n\t\t\t\t\tTypeName: \"repo\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// arrange\n\t\t\tstore := ulid.Make().String()\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, test.model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = test.model.Id\n\n\t\t\t// act\n\t\t\tquery := commands.NewExpandQuery(datastore, logger)\n\t\t\tresp, err := query.Execute(ctx, test.request)\n\n\t\t\t// assert\n\t\t\trequire.Nil(resp)\n\t\t\trequire.ErrorIs(err, test.expected)\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/mocks\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/grpc\"\n)\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n\tchannel chan string\n}\n\nfunc (x *mockStreamServer) Send(m *openfgapb.StreamedListObjectsResponse) error {\n\tx.channel <- m.Object\n\treturn nil\n}\n\ntype listObjectsTestCase struct {\n\tname                   string\n\tschema                 string\n\ttuples                 []*openfgapb.TupleKey\n\tmodel                  string\n\tobjectType             string\n\tuser                   string\n\trelation               string\n\tcontextualTuples       *openfgapb.ContextualTupleKeys\n\tallResults             []string //all the results. the server may return less\n\tmaxResults             uint32\n\tminimumResultsExpected uint32\n\tlistObjectsDeadline    time.Duration // 1 minute if not set\n\treadTuplesDelay        time.Duration // if set, purposely use a slow storage to slow down read and simulate timeout\n}\n\nfunc TestListObjectsRespectsMaxResults(t *testing.T, ds storage.OpenFGADatastore) {\n\ttestCases := []listObjectsTestCase{\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_reverse_expansion_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgapb.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_ttu_in_model_and_reverse_expansion_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:x\", \"viewer\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:x\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:x\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"parent\", \"folder:x\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\", \"document:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_concurrent_checks_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t\tdefine blocked: [user] as self\n\t\t\t\tdefine admin: [user] as self but not blocked\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:       \"user:charlie\",\n\t\t\tobjectType: \"org\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgapb.TupleKey{tuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:2\", \"org:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_maxresults_is_higher_than_actual_result_length\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:1\", \"admin\", \"user:bob\"),\n\t\t\t},\n\t\t\tuser:                   \"user:bob\",\n\t\t\tobjectType:             \"team\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"team:1\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_max_results_when_deadline_timeout_and_returns_no_error_and_no_results\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"repo\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 0,\n\t\t\t// We expect empty array to be returned as list object will timeout due to readTuplesDelay > listObjectsDeadline\n\t\t\tallResults:          []string{},\n\t\t\tlistObjectsDeadline: 1 * time.Second,\n\t\t\treadTuplesDelay:     2 * time.Second, // We are mocking the ds to slow down the read call and simulate timeout\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := context.Background()\n\t\t\tstoreID := ulid.Make().String()\n\n\t\t\t// arrange: write model\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   test.schema,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, storeID, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// arrange: write tuples\n\t\t\terr = ds.Write(context.Background(), storeID, nil, test.tuples)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// act: run ListObjects\n\n\t\t\tlistObjectsDeadline := time.Minute\n\t\t\tif test.listObjectsDeadline > 0 {\n\t\t\t\tlistObjectsDeadline = test.listObjectsDeadline\n\t\t\t}\n\n\t\t\tdatastore := ds\n\t\t\tif test.readTuplesDelay > 0 {\n\t\t\t\tdatastore = mocks.NewMockSlowDataStorage(ds, test.readTuplesDelay)\n\t\t\t}\n\n\t\t\tlistObjectsQuery := &commands.ListObjectsQuery{\n\t\t\t\tDatastore:             datastore,\n\t\t\t\tLogger:                logger.NewNoopLogger(),\n\t\t\t\tListObjectsDeadline:   listObjectsDeadline,\n\t\t\t\tListObjectsMaxResults: test.maxResults,\n\t\t\t\tResolveNodeLimit:      defaultResolveNodeLimit,\n\t\t\t}\n\t\t\ttypesys := typesystem.New(model)\n\t\t\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\t\t\t// assertions\n\t\t\tt.Run(\"streaming_endpoint\", func(t *testing.T) {\n\t\t\t\tserver := &mockStreamServer{\n\t\t\t\t\tchannel: make(chan string, len(test.allResults)),\n\t\t\t\t}\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tvar streamedObjectIds []string\n\t\t\t\tgo func() {\n\t\t\t\t\tfor x := range server.channel {\n\t\t\t\t\t\tstreamedObjectIds = append(streamedObjectIds, x)\n\t\t\t\t\t}\n\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t}()\n\n\t\t\t\terr := listObjectsQuery.ExecuteStreamed(ctx, &openfgapb.StreamedListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t}, server)\n\t\t\t\tclose(server.channel)\n\t\t\t\t<-done\n\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.GreaterOrEqual(t, len(streamedObjectIds), int(test.minimumResultsExpected))\n\t\t\t\trequire.ElementsMatch(t, test.allResults, streamedObjectIds)\n\t\t\t})\n\n\t\t\tt.Run(\"regular_endpoint\", func(t *testing.T) {\n\t\t\t\tres, err := listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t})\n\n\t\t\t\trequire.NotNil(t, res)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.LessOrEqual(t, len(res.Objects), int(test.maxResults))\n\t\t\t\trequire.GreaterOrEqual(t, len(res.Objects), int(test.minimumResultsExpected))\n\t\t\t\trequire.Subset(t, test.allResults, res.Objects)\n\t\t\t})\n\t\t})\n\t}\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar listObjectsResponse *openfgapb.ListObjectsResponse //nolint\n\nfunc BenchmarkListObjectsWithReverseExpand(b *testing.B, ds storage.OpenFGADatastore) {\n\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:            ulid.Make().String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\tn := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgapb.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite(); j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(n))\n\t\t\tuser := fmt.Sprintf(\"user:%s\", strconv.Itoa(n))\n\n\t\t\ttuples = append(tuples, tuple.NewTupleKey(obj, \"viewer\", user))\n\n\t\t\tn += 1\n\t\t}\n\n\t\terr = ds.Write(ctx, store, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\tlistObjectsQuery := commands.ListObjectsQuery{\n\t\tDatastore:        ds,\n\t\tLogger:           logger.NewNoopLogger(),\n\t\tResolveNodeLimit: defaultResolveNodeLimit,\n\t}\n\n\tvar r *openfgapb.ListObjectsResponse\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:999\",\n\t\t})\n\t}\n\n\tlistObjectsResponse = r\n}\n\nfunc BenchmarkListObjectsWithConcurrentChecks(b *testing.B, ds storage.OpenFGADatastore) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype document\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n\t`)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              ulid.Make().String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}\n\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\tn := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgapb.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite()/2; j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(n))\n\t\t\tuser := fmt.Sprintf(\"user:%s\", strconv.Itoa(n))\n\n\t\t\ttuples = append(\n\t\t\t\ttuples,\n\t\t\t\ttuple.NewTupleKey(obj, \"viewer\", user),\n\t\t\t\ttuple.NewTupleKey(obj, \"allowed\", user),\n\t\t\t)\n\n\t\t\tn += 1\n\t\t}\n\n\t\terr = ds.Write(ctx, store, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\tlistObjectsQuery := commands.ListObjectsQuery{\n\t\tDatastore:        ds,\n\t\tLogger:           logger.NewNoopLogger(),\n\t\tResolveNodeLimit: defaultResolveNodeLimit,\n\t}\n\n\tvar r *openfgapb.ListObjectsResponse\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:999\",\n\t\t})\n\t}\n\n\tlistObjectsResponse = r\n}\n", "package test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/openfga/openfga/pkg/storage\"\n)\n\nconst (\n\tdefaultResolveNodeLimit = 25\n)\n\nfunc RunAllTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tRunQueryTests(t, ds)\n\tRunCommandTests(t, ds)\n}\n\nfunc RunQueryTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tt.Run(\"TestReadAuthorizationModelQueryErrors\", func(t *testing.T) { TestReadAuthorizationModelQueryErrors(t, ds) })\n\tt.Run(\"TestSuccessfulReadAuthorizationModelQuery\", func(t *testing.T) { TestSuccessfulReadAuthorizationModelQuery(t, ds) })\n\tt.Run(\"TestReadAuthorizationModel\", func(t *testing.T) { ReadAuthorizationModelTest(t, ds) })\n\n\tt.Run(\"TestExpandQuery\", func(t *testing.T) { TestExpandQuery(t, ds) })\n\tt.Run(\"TestExpandQueryErrors\", func(t *testing.T) { TestExpandQueryErrors(t, ds) })\n\n\tt.Run(\"TestGetStoreQuery\", func(t *testing.T) { TestGetStoreQuery(t, ds) })\n\tt.Run(\"TestGetStoreSucceeds\", func(t *testing.T) { TestGetStoreSucceeds(t, ds) })\n\tt.Run(\"TestListStores\", func(t *testing.T) { TestListStores(t, ds) })\n\n\tt.Run(\"TestReadAssertionQuery\", func(t *testing.T) { TestReadAssertionQuery(t, ds) })\n\n\tt.Run(\"TestReadQuerySuccess\", func(t *testing.T) { ReadQuerySuccessTest(t, ds) })\n\tt.Run(\"TestReadQueryError\", func(t *testing.T) { ReadQueryErrorTest(t, ds) })\n\tt.Run(\"TestReadAllTuples\", func(t *testing.T) { ReadAllTuplesTest(t, ds) })\n\tt.Run(\"TestReadAllTuplesInvalidContinuationToken\", func(t *testing.T) { ReadAllTuplesInvalidContinuationTokenTest(t, ds) })\n\n\tt.Run(\"TestReadAuthorizationModelsWithoutPaging\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsWithoutPaging(t, ds) },\n\t)\n\n\tt.Run(\"TestReadAuthorizationModelsWithPaging\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsWithPaging(t, ds) },\n\t)\n\n\tt.Run(\"TestReadAuthorizationModelsInvalidContinuationToken\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsInvalidContinuationToken(t, ds) },\n\t)\n\n\tt.Run(\"TestReadChanges\", func(t *testing.T) { TestReadChanges(t, ds) })\n\tt.Run(\"TestReadChangesReturnsSameContTokenWhenNoChanges\",\n\t\tfunc(t *testing.T) { TestReadChangesReturnsSameContTokenWhenNoChanges(t, ds) },\n\t)\n\n\tt.Run(\"TestListObjectsRespectsMaxResults\", func(t *testing.T) { TestListObjectsRespectsMaxResults(t, ds) })\n}\n\nfunc RunCommandTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tt.Run(\"TestWriteCommand\", func(t *testing.T) { TestWriteCommand(t, ds) })\n\tt.Run(\"TestWriteAuthorizationModel\", func(t *testing.T) { WriteAuthorizationModelTest(t, ds) })\n\tt.Run(\"TestWriteAssertions\", func(t *testing.T) { TestWriteAssertions(t, ds) })\n\tt.Run(\"TestCreateStore\", func(t *testing.T) { TestCreateStore(t, ds) })\n\tt.Run(\"TestDeleteStore\", func(t *testing.T) { TestDeleteStore(t, ds) })\n\tt.Run(\"TestConnectedObjects\", func(t *testing.T) { ConnectedObjectsTest(t, ds) })\n}\n\nfunc RunAllBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {\n\tRunListObjectsBenchmarks(b, ds)\n}\n\nfunc RunListObjectsBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {\n\tb.Run(\"BenchmarkListObjectsWithReverseExpand\", func(b *testing.B) { BenchmarkListObjectsWithReverseExpand(b, ds) })\n\tb.Run(\"BenchmarkListObjectsWithConcurrentChecks\", func(b *testing.B) { BenchmarkListObjectsWithConcurrentChecks(b, ds) })\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID := ulid.Make().String()\n\n\titems := make([]*openfgapb.TypeDefinition, datastore.MaxTypesPerAuthorizationModel()+1)\n\titems[0] = &openfgapb.TypeDefinition{\n\t\tType: \"user\",\n\t}\n\tfor i := 1; i < datastore.MaxTypesPerAuthorizationModel(); i++ {\n\t\titems[i] = &openfgapb.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t},\n\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname          string\n\t\trequest       *openfgapb.WriteAuthorizationModelRequest\n\t\tallowSchema10 bool\n\t\terr           error\n\t}{\n\t\t{\n\t\t\tname: \"fails_if_too_many_types\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", datastore.MaxTypesPerAuthorizationModel()),\n\t\t},\n\t\t{\n\t\t\tname: \"fails_if_a_relation_is_not_defined\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{ObjectType: \"repo\", Relation: \"owner\"}),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_type_info_metadata_is_omitted_in_1.1_model\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:       storeID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the assignable relation 'reader' in object type 'document' must contain at least one relation type\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_writing_1_0_model_because_it_will_be_interpreted_as_1_1\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(typesystem.AssignableRelationError(\"document\", \"reader\")),\n\t\t},\n\t\t{\n\t\t\tname: \"Works_if_no_schema_version\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\n\t\t\tif err == nil {\n\t\t\t\t_, err = ulid.Parse(resp.AuthorizationModelId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package typesystem\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\ntype ctxKey string\n\nconst (\n\tSchemaVersion1_0 string = \"1.0\"\n\tSchemaVersion1_1 string = \"1.1\"\n\n\ttypesystemCtxKey ctxKey = \"typesystem-context-key\"\n)\n\nvar (\n\tErrDuplicateTypes        = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion  = errors.New(\"invalid schema version\")\n\tErrInvalidModel          = errors.New(\"invalid authorization model encountered\")\n\tErrRelationUndefined     = errors.New(\"undefined relation\")\n\tErrObjectTypeUndefined   = errors.New(\"undefined object type\")\n\tErrInvalidUsersetRewrite = errors.New(\"invalid userset rewrite definition\")\n\tErrReservedKeywords      = errors.New(\"self and this are reserved keywords\")\n\tErrCycle                 = errors.New(\"an authorization model cannot contain a cycle\")\n)\n\nfunc IsSchemaVersionSupported(version string) bool {\n\tswitch version {\n\tcase SchemaVersion1_1:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// ContextWithTypesystem attaches the provided TypeSystem to the parent context.\nfunc ContextWithTypesystem(parent context.Context, typesys *TypeSystem) context.Context {\n\treturn context.WithValue(parent, typesystemCtxKey, typesys)\n}\n\n// TypesystemFromContext returns the TypeSystem from the provided context (if any).\nfunc TypesystemFromContext(ctx context.Context) (*TypeSystem, bool) {\n\ttypesys, ok := ctx.Value(typesystemCtxKey).(*TypeSystem)\n\treturn typesys, ok\n}\n\nfunc DirectRelationReference(objectType, relation string) *openfgapb.RelationReference {\n\trelationReference := &openfgapb.RelationReference{\n\t\tType: objectType,\n\t}\n\tif relation != \"\" {\n\t\trelationReference.RelationOrWildcard = &openfgapb.RelationReference_Relation{\n\t\t\tRelation: relation,\n\t\t}\n\t}\n\n\treturn relationReference\n}\n\nfunc WildcardRelationReference(objectType string) *openfgapb.RelationReference {\n\treturn &openfgapb.RelationReference{\n\t\tType: objectType,\n\t\tRelationOrWildcard: &openfgapb.RelationReference_Wildcard{\n\t\t\tWildcard: &openfgapb.Wildcard{},\n\t\t},\n\t}\n}\n\nfunc This() *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tupleset, computedUserset string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: tupleset,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: computedUserset,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Union{\n\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgapb.Userset, sub *openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\ntype TypeSystem struct {\n\t// [objectType] => typeDefinition\n\ttypeDefinitions map[string]*openfgapb.TypeDefinition\n\t// [objectType] => [relationName] => relation\n\trelations     map[string]map[string]*openfgapb.Relation\n\tmodelID       string\n\tschemaVersion string\n}\n\n// New creates a *TypeSystem from an *openfgapb.AuthorizationModel.\n// It assumes that the input model is valid. If you need to run validations, use NewAndValidate.\nfunc New(model *openfgapb.AuthorizationModel) *TypeSystem {\n\ttds := make(map[string]*openfgapb.TypeDefinition, len(model.GetTypeDefinitions()))\n\trelations := make(map[string]map[string]*openfgapb.Relation, len(model.GetTypeDefinitions()))\n\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttds[td.GetType()] = td\n\t\ttdRelations := make(map[string]*openfgapb.Relation, len(td.GetRelations()))\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\tr := &openfgapb.Relation{\n\t\t\t\tName:     relation,\n\t\t\t\tRewrite:  rewrite,\n\t\t\t\tTypeInfo: &openfgapb.RelationTypeInfo{},\n\t\t\t}\n\n\t\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t\t}\n\n\t\t\ttdRelations[relation] = r\n\t\t}\n\t\trelations[td.GetType()] = tdRelations\n\t}\n\n\treturn &TypeSystem{\n\t\tmodelID:         model.GetId(),\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t\trelations:       relations,\n\t}\n}\n\n// GetAuthorizationModelID returns the id for the authorization model this\n// TypeSystem was constructed for.\nfunc (t *TypeSystem) GetAuthorizationModelID() string {\n\treturn t.modelID\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgapb.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\n// GetRelations returns all relations in the TypeSystem for a given type\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgapb.Relation, error) {\n\t_, ok := t.GetTypeDefinition(objectType)\n\tif !ok {\n\t\treturn nil, &ObjectTypeUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tErr:        ErrObjectTypeUndefined,\n\t\t}\n\t}\n\n\treturn t.relations[objectType], nil\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgapb.Relation, error) {\n\trelations, err := t.GetRelations(objectType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, &RelationUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tRelation:   relation,\n\t\t\tErr:        ErrRelationUndefined,\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// GetRelationReferenceAsString returns team#member, or team:*, or an empty string if the input is nil.\nfunc GetRelationReferenceAsString(rr *openfgapb.RelationReference) string {\n\tif rr == nil {\n\t\treturn \"\"\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgapb.RelationReference_Relation); ok {\n\t\treturn fmt.Sprintf(\"%s#%s\", rr.GetType(), rr.GetRelation())\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgapb.RelationReference_Wildcard); ok {\n\t\treturn fmt.Sprintf(\"%s:*\", rr.GetType())\n\t}\n\n\tpanic(\"unexpected relation reference\")\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) ([]*openfgapb.RelationReference, error) {\n\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes(), nil\n}\n\n// IsDirectlyRelated determines whether the type of the target DirectRelationReference contains the source DirectRelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgapb.RelationReference, source *openfgapb.RelationReference) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif source.GetType() == typeRestriction.GetType() {\n\n\t\t\t// type with no relation or wildcard (e.g. 'user')\n\t\t\tif typeRestriction.GetRelationOrWildcard() == nil && source.GetRelationOrWildcard() == nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// typed wildcard (e.g. 'user:*')\n\t\t\tif typeRestriction.GetWildcard() != nil && source.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tif typeRestriction.GetRelation() != \"\" && source.GetRelation() != \"\" &&\n\t\t\t\ttypeRestriction.GetRelation() == source.GetRelation() {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n/*\n * IsPubliclyAssignable returns true if the provided objectType is part of a typed wildcard type restriction\n * on the target relation.\n *\n * type user\n *\n * type document\n *   relations\n *     define viewer: [user:*]\n *\n * In the example above, the 'user' objectType is publicly assignable to the 'document#viewer' relation.\n */\nfunc (t *TypeSystem) IsPubliclyAssignable(target *openfgapb.RelationReference, objectType string) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetType() == objectType {\n\t\t\tif typeRestriction.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) HasTypeInfo(objectType, relation string) (bool, error) {\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif t.GetSchemaVersion() == SchemaVersion1_1 && r.GetTypeInfo() != nil {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesIntersection returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect intersections or any of the types related to\n// the provided relation are defined by one or more direct or indirect intersections.\nfunc (t *TypeSystem) RelationInvolvesIntersection(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesIntersection(objectType, relation, visited)\n}\n\nfunc (t *TypeSystem) relationInvolvesIntersection(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsIntersection {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgapb.Userset_Intersection:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesExclusion returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect exclusions or any of the types related to\n// the provided relation are defined by one or more direct or indirect exclusions.\nfunc (t *TypeSystem) RelationInvolvesExclusion(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesExclusion(objectType, relation, visited)\n\n}\n\nfunc (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsExclusion {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgapb.Userset_Difference:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// NewAndValidate is like New but also validates the model according to the following rules:\n//  1. Checks that the *TypeSystem have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the *TypeSystem (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the *TypeSystem has a v1.1 schema version (with types on relations), then additionally\n// validate the *TypeSystem according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc NewAndValidate(model *openfgapb.AuthorizationModel) (*TypeSystem, error) {\n\tt := New(model)\n\tschemaVersion := t.GetSchemaVersion()\n\n\tif !IsSchemaVersionSupported(schemaVersion) {\n\t\treturn nil, ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn nil, ErrDuplicateTypes\n\t}\n\n\tif err := t.validateNames(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Validate the userset rewrites\n\tfor _, td := range t.typeDefinitions {\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\terr := t.isUsersetRewriteValid(td.GetType(), relation, rewrite)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := t.ensureNoCyclesInTupleToUsersetDefinitions(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := t.ensureNoCyclesInComputedRewrite(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif schemaVersion == SchemaVersion1_1 {\n\t\tif err := t.validateRelationTypeRestrictions(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn t, nil\n}\n\nfunc containsDuplicateType(model *openfgapb.AuthorizationModel) bool {\n\tseen := make(map[string]struct{}, len(model.GetTypeDefinitions()))\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\n// validateNames ensures that a model doesn't have object types or relations\n// called \"self\" or \"this\"\nfunc (t *TypeSystem) validateNames() error {\n\tfor _, td := range t.typeDefinitions {\n\t\tobjectType := td.GetType()\n\t\tif objectType == \"self\" || objectType == \"this\" {\n\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}\n\t\t}\n\n\t\tfor relation := range td.GetRelations() {\n\t\t\tif relation == \"self\" || relation == \"this\" {\n\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if the rewrite on objectType#relation is valid.\nfunc (t *TypeSystem) isUsersetRewriteValid(objectType, relation string, rewrite *openfgapb.Userset) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t}\n\n\tswitch r := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tcomputedUserset := r.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t\t}\n\t\tif _, err := t.GetRelation(objectType, computedUserset); err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\ttupleset := r.TupleToUserset.GetTupleset().GetRelation()\n\n\t\ttuplesetRelation, err := t.GetRelation(objectType, tupleset)\n\t\tif err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: tupleset, Err: ErrRelationUndefined}\n\t\t}\n\n\t\t// tupleset relations must only be direct relationships, no rewrites are allowed on them\n\t\ttuplesetRewrite := tuplesetRelation.GetRewrite()\n\t\tif reflect.TypeOf(tuplesetRewrite.GetUserset()) != reflect.TypeOf(&openfgapb.Userset_This{}) {\n\t\t\treturn fmt.Errorf(\"the '%s#%s' relation is referenced in at least one tupleset and thus must be a direct relation\", objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := r.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\tif t.GetSchemaVersion() == SchemaVersion1_1 {\n\t\t\t// for 1.1 models, relation `computedUserset` has to be defined in one of the types declared by the tupleset's list of allowed types\n\t\t\tuserTypes := tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, rr := range userTypes {\n\t\t\t\tif _, err := t.GetRelation(rr.GetType(), computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%w: %s does not appear as a relation in any of the directly related user types %s\", ErrRelationUndefined, computedUserset, userTypes)\n\t\t} else {\n\t\t\t// for 1.0 models, relation `computedUserset` has to be defined _somewhere_ in the model\n\t\t\tfor typeName := range t.relations {\n\t\t\t\tif _, err := t.GetRelation(typeName, computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &RelationUndefinedError{ObjectType: \"\", Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range r.Union.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range r.Intersection.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\terr := t.isUsersetRewriteValid(objectType, relation, r.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = t.isUsersetRewriteValid(objectType, relation, r.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) validateRelationTypeRestrictions() error {\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, err := t.GetRelations(objectType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor name, relation := range relations {\n\t\t\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tassignable := t.IsDirectlyAssignable(relation)\n\n\t\t\tif assignable && len(relatedTypes) == 0 {\n\t\t\t\treturn AssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tif assignable && len(relatedTypes) == 1 {\n\t\t\t\trelatedObjectType := relatedTypes[0].GetType()\n\t\t\t\trelatedRelation := relatedTypes[0].GetRelation()\n\t\t\t\tif objectType == relatedObjectType && name == relatedRelation {\n\t\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: name, Cause: ErrCycle}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !assignable && len(relatedTypes) != 0 {\n\t\t\t\treturn NonAssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tfor _, related := range relatedTypes {\n\t\t\t\trelatedObjectType := related.GetType()\n\t\t\t\trelatedRelation := related.GetRelation()\n\n\t\t\t\tif _, err := t.GetRelations(relatedObjectType); err != nil {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\n\t\t\t\tif related.GetRelationOrWildcard() != nil {\n\t\t\t\t\t// The type of the relation cannot contain a userset or wildcard if the relation is a tupleset relation.\n\t\t\t\t\tif ok, _ := t.IsTuplesetRelation(objectType, name); ok {\n\t\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t\t}\n\n\t\t\t\t\tif relatedRelation != \"\" {\n\t\t\t\t\t\tif _, err := t.GetRelation(relatedObjectType, relatedRelation); err != nil {\n\t\t\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ensureNoCyclesInTupleToUsersetDefinitions throws an error on the following models because `viewer` is a cycle.\n//\n//\ttype folder\n//\t  relations\n//\t    define parent: [folder] as self\n//\t    define viewer as viewer from parent\n//\n// and\n//\n//\ttype folder\n//\t  relations\n//\t    define parent as self\n//\t    define viewer as viewer from parent\nfunc (t *TypeSystem) ensureNoCyclesInTupleToUsersetDefinitions() error {\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, err := t.GetRelations(objectType)\n\t\tif err == nil {\n\t\t\tfor relationName, relation := range relations {\n\t\t\t\tswitch cyclicDefinition := relation.GetRewrite().Userset.(type) {\n\t\t\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\t\t\t// define viewer as viewer from parent\n\t\t\t\t\tif cyclicDefinition.TupleToUserset.ComputedUserset.GetRelation() == relationName {\n\t\t\t\t\t\ttuplesetRelationName := cyclicDefinition.TupleToUserset.GetTupleset().GetRelation()\n\t\t\t\t\t\ttuplesetRelation, err := t.GetRelation(objectType, tuplesetRelationName)\n\t\t\t\t\t\t// define parent: [folder] as self\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tswitch tuplesetRelation.GetRewrite().Userset.(type) {\n\t\t\t\t\t\t\tcase *openfgapb.Userset_This:\n\t\t\t\t\t\t\t\tif t.schemaVersion == SchemaVersion1_0 && len(t.typeDefinitions) == 1 {\n\t\t\t\t\t\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relationName, Cause: ErrCycle}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif t.schemaVersion == SchemaVersion1_1 && len(tuplesetRelation.TypeInfo.DirectlyRelatedUserTypes) == 1 && tuplesetRelation.TypeInfo.DirectlyRelatedUserTypes[0].Type == objectType {\n\t\t\t\t\t\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relationName, Cause: ErrCycle}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ensureNoCyclesInComputedRewrite throws an error on the following model because `folder` type is a cycle.\n//\n//\t type folder\n//\t\t relations\n//\t\t  define parent as child\n//\t\t  define child as parent\nfunc (t *TypeSystem) ensureNoCyclesInComputedRewrite() error {\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, err := t.GetRelations(objectType)\n\t\tif err == nil {\n\t\t\tfor sourceRelationName, relation := range relations {\n\t\t\t\tswitch source := relation.GetRewrite().Userset.(type) {\n\t\t\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\t\t\ttarget := source.ComputedUserset.GetRelation()\n\t\t\t\t\ttargetRelation, err := t.GetRelation(objectType, target)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tswitch rewrite := targetRelation.GetRewrite().Userset.(type) {\n\t\t\t\t\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\t\t\t\t\tif rewrite.ComputedUserset.GetRelation() == sourceRelationName {\n\t\t\t\t\t\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrCycle}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgapb.Relation) bool {\n\treturn RewriteContainsSelf(relation.GetRewrite())\n}\n\n// RewriteContainsSelf returns true if the provided userset rewrite\n// is defined by one or more self referencing definitions.\nfunc RewriteContainsSelf(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_This); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsIntersection returns true if the provided userset rewrite\n// is defined by one or more direct or indirect intersections.\nfunc RewriteContainsIntersection(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_Intersection); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsExclusion returns true if the provided userset rewrite\n// is defined by one or more direct or indirect exclusions.\nfunc RewriteContainsExclusion(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_Difference); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\ntype InvalidTypeError struct {\n\tObjectType string\n\tCause      error\n}\n\nfunc (e *InvalidTypeError) Error() string {\n\treturn fmt.Sprintf(\"the definition of type '%s' is invalid\", e.ObjectType)\n}\n\nfunc (e *InvalidTypeError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype InvalidRelationError struct {\n\tObjectType string\n\tRelation   string\n\tCause      error\n}\n\nfunc (e *InvalidRelationError) Error() string {\n\treturn fmt.Sprintf(\"the definition of relation '%s' in object type '%s' is invalid\", e.Relation, e.ObjectType)\n}\n\nfunc (e *InvalidRelationError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype ObjectTypeUndefinedError struct {\n\tObjectType string\n\tErr        error\n}\n\nfunc (e *ObjectTypeUndefinedError) Error() string {\n\treturn fmt.Sprintf(\"'%s' is an undefined object type\", e.ObjectType)\n}\n\nfunc (e *ObjectTypeUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\ntype RelationUndefinedError struct {\n\tObjectType string\n\tRelation   string\n\tErr        error\n}\n\nfunc (e *RelationUndefinedError) Error() string {\n\n\tif e.ObjectType != \"\" {\n\t\treturn fmt.Sprintf(\"'%s#%s' relation is undefined\", e.ObjectType, e.Relation)\n\t}\n\n\treturn fmt.Sprintf(\"'%s' relation is undefined\", e.Relation)\n}\n\nfunc (e *RelationUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = tuple.ToObjectRelationString(relatedObjectType, relatedRelation)\n\t}\n\n\treturn fmt.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n\n// getAllTupleToUsersetsDefinitions returns a map where the key is the object type and the value\n// is another map where key=relationName, value=list of tuple to usersets declared in that relation\nfunc (t *TypeSystem) getAllTupleToUsersetsDefinitions() map[string]map[string][]*openfgapb.TupleToUserset {\n\tresponse := make(map[string]map[string][]*openfgapb.TupleToUserset, 0)\n\tfor typeName, typeDef := range t.typeDefinitions {\n\t\tresponse[typeName] = make(map[string][]*openfgapb.TupleToUserset, 0)\n\t\tfor relationName, relationDef := range typeDef.GetRelations() {\n\t\t\tttus := make([]*openfgapb.TupleToUserset, 0)\n\t\t\tresponse[typeName][relationName] = t.tupleToUsersetsDefinitions(relationDef, &ttus)\n\t\t}\n\t}\n\n\treturn response\n}\n\n// IsTuplesetRelation returns a boolean indicating if the provided relation is defined under a\n// TupleToUserset rewrite as a tupleset relation (i.e. the right hand side of a `X from Y`).\nfunc (t *TypeSystem) IsTuplesetRelation(objectType, relation string) (bool, error) {\n\n\t_, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, ttuDefinitions := range t.getAllTupleToUsersetsDefinitions()[objectType] {\n\t\tfor _, ttuDef := range ttuDefinitions {\n\t\t\tif ttuDef.Tupleset.Relation == relation {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) tupleToUsersetsDefinitions(relationDef *openfgapb.Userset, resp *[]*openfgapb.TupleToUserset) []*openfgapb.TupleToUserset {\n\tif relationDef.GetTupleToUserset() != nil {\n\t\t*resp = append(*resp, relationDef.GetTupleToUserset())\n\t}\n\tif relationDef.GetUnion() != nil {\n\t\tfor _, child := range relationDef.GetUnion().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetIntersection() != nil {\n\t\tfor _, child := range relationDef.GetIntersection().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetDifference() != nil {\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetBase(), resp)\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetSubtract(), resp)\n\t}\n\treturn *resp\n}\n\n// WalkUsersetRewriteHandler is a userset rewrite handler that is applied to a node in a userset rewrite\n// tree. Implementations of the WalkUsersetRewriteHandler should return a non-nil value when the traversal\n// over the rewrite tree should terminate and nil if traversal should proceed to other nodes in the tree.\ntype WalkUsersetRewriteHandler func(rewrite *openfgapb.Userset) interface{}\n\n// WalkUsersetRewrite recursively walks the provided userset rewrite and invokes the provided WalkUsersetRewriteHandler\n// to each node in the userset rewrite tree until the first non-nil response is encountered.\nfunc WalkUsersetRewrite(rewrite *openfgapb.Userset, handler WalkUsersetRewriteHandler) (interface{}, error) {\n\n\tvar children []*openfgapb.Userset\n\n\tif result := handler(rewrite); result != nil {\n\t\treturn result, nil\n\t}\n\n\tswitch t := rewrite.Userset.(type) {\n\tcase *openfgapb.Userset_This:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_Union:\n\t\tchildren = t.Union.GetChild()\n\tcase *openfgapb.Userset_Intersection:\n\t\tchildren = t.Intersection.GetChild()\n\tcase *openfgapb.Userset_Difference:\n\t\tchildren = append(children, t.Difference.GetBase(), t.Difference.GetSubtract())\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected userset rewrite type encountered\")\n\t}\n\n\tfor _, child := range children {\n\t\tresult, err := WalkUsersetRewrite(child, handler)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif result != nil {\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n", "package typesystem\n\nimport (\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc TestSuccessfulRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"empty_relations\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero_length_relations_is_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"empty_rewrites\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_computedUserset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_to_relation_which_does_not_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_tupleset_is_not_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"notavalidrelation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_computed_userset_is_not_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define reader as notavalidrelation from writer\n\t\t\t\t\tdefine writer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Relation_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"this\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Relation_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"self\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Type_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"this\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Type_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"self\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Auth_Model_1.1_Has_A_Cycle_And_Only_One_Type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t\tdefine viewer as viewer from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrCycle,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(test.model)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\t\t})\n\t}\n}\nfunc TestSuccessfulRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_an_objectType_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_a_type_and_type#relation_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"admin\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"relational_type_which_does_not_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_type_of_form_type#relation_where_relation_doesn't_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType:               \"group\",\n\t\t\t\t\t\t\t\t\t\t\tRelationOrWildcard: &openfgapb.RelationReference_Relation{Relation: \"admin\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"admin\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_this\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_wit_no_type:_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_relation_with_a_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: NonAssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\":   This(),\n\t\t\t\t\t\t\t\"can_view\": TupleToUserset(\"parent\", \"member\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"member\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite_included_in_a_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(TupleToUserset(\"parent\", \"viewer\"), This()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"parent\"),\n\t\t},\n\t\t{\n\t\t\tname: \"WildcardNotAllowedInTheTuplesetPartOfTTU\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tWildcardRelationReference(\"folder\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(test.model)\n\t\t\trequire.EqualError(t, err, test.err.Error())\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgapb.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computeduserset_through_ttu_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define manage: [user] as self\n\t\t\t    define editor: [user] as self and manage\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member and allowed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self and allowed\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesIntersection(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesExclusion(t *testing.T) {\n\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgapb.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computed_userset_through_ttu_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define viewer: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define removed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member but not removed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesExclusion(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsTuplesetRelation(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgapb.AuthorizationModel\n\t\tobjectType    string\n\t\trelation      string\n\t\texpected      bool\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"undefined_object_type_returns_error\",\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation_returns_error\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_tupleset_relation\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_exclusion\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Difference(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tUnion(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tIntersection(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_exclusion\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tDifference(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"not_a_tupleset_relation\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(test.model)\n\n\t\t\tactual, err := typesys.IsTuplesetRelation(test.objectType, test.relation)\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsDirectlyRelated(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tmodel  string\n\t\ttarget *openfgapb.RelationReference\n\t\tsource *openfgapb.RelationReference\n\t\tresult bool\n\t}{\n\t\t{\n\t\t\tname: \"wildcard_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"wildcard_and_direct\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"relation_not_related\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"manager\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_userset\",\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"group\", \"member\"),\n\t\t\tresult: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsDirectlyRelated(test.target, test.source)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.result, ok)\n\t\t})\n\t}\n}\n\nfunc TestIsPubliclyAssignable(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\ttarget     *openfgapb.RelationReference\n\t\tobjectType string\n\t\tresult     bool\n\t}{\n\t\t{\n\t\t\tname: \"1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     true,\n\t\t},\n\t\t{\n\t\t\tname: \"2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"3\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [employee:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsPubliclyAssignable(test.target, test.objectType)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, ok, test.result)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsExclusion(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgapb.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) but not restricted\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsExclusion(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgapb.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) and allowed\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsIntersection(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestGetRelationReferenceAsString(t *testing.T) {\n\trequire.Equal(t, \"\", GetRelationReferenceAsString(nil))\n\trequire.Equal(t, \"team#member\", GetRelationReferenceAsString(DirectRelationReference(\"team\", \"member\")))\n\trequire.Equal(t, \"team:*\", GetRelationReferenceAsString(WildcardRelationReference(\"team\")))\n}\n"], "fixing_code": ["package validatemodels\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\nconst (\n\tdatastoreEngineFlag = \"datastore-engine\"\n\tdatastoreURIFlag    = \"datastore-uri\"\n)\n\nfunc NewValidateCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"validate-models\",\n\t\tShort: \"Validate authorization models. NOTE: this command is in beta and may be removed in future releases.\",\n\t\tLong:  \"List all authorization models across all stores and run validations against them.\\nNOTE: this command is in beta and may be removed in future releases.\",\n\t\tRunE:  runValidate,\n\t\tArgs:  cobra.NoArgs,\n\t}\n\n\tflags := cmd.Flags()\n\tflags.String(datastoreEngineFlag, \"\", \"the datastore engine\")\n\tflags.String(datastoreURIFlag, \"\", \"the connection uri to the datastore\")\n\n\t// NOTE: if you add a new flag here, update the function below, too\n\n\tcmd.PreRun = bindRunFlagsFunc(flags)\n\n\treturn cmd\n}\n\ntype validationResult struct {\n\tStoreID       string `json:\"store_id\"`\n\tModelID       string `json:\"model_id\"`\n\tIsLatestModel bool   `json:\"is_latest_model\"`\n\tError         string `json:\"error\"`\n}\n\nfunc runValidate(_ *cobra.Command, _ []string) error {\n\tengine := viper.GetString(datastoreEngineFlag)\n\turi := viper.GetString(datastoreURIFlag)\n\n\tctx := context.Background()\n\n\tvar (\n\t\tdb  storage.OpenFGADatastore\n\t\terr error\n\t)\n\tswitch engine {\n\tcase \"mysql\":\n\t\tdb, err = mysql.New(uri, sqlcommon.NewConfig())\n\tcase \"postgres\":\n\t\tdb, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"\":\n\t\treturn fmt.Errorf(\"missing datastore engine type\")\n\tcase \"memory\":\n\t\tfallthrough\n\tdefault:\n\t\treturn fmt.Errorf(\"storage engine '%s' is unsupported\", engine)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open a connection to the datastore: %v\", err)\n\t}\n\n\tvalidationResults, err := ValidateAllAuthorizationModels(ctx, db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmarshalled, err := json.MarshalIndent(validationResults, \" \", \"    \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error gathering validation results: %w\", err)\n\t}\n\tfmt.Println(string(marshalled))\n\n\treturn nil\n}\n\n// ValidateAllAuthorizationModels lists all stores and then, for each store, lists all models.\n// Then it runs validation on each model.\nfunc ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatastore) ([]validationResult, error) {\n\tvalidationResults := make([]validationResult, 0)\n\n\tcontinuationTokenStores := \"\"\n\n\tfor {\n\t\t// fetch a page of stores\n\t\tstores, tokenStores, err := db.ListStores(ctx, storage.PaginationOptions{\n\t\t\tPageSize: 100,\n\t\t\tFrom:     continuationTokenStores,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error reading stores: %w\", err)\n\t\t}\n\n\t\t// validate each store\n\t\tfor _, store := range stores {\n\n\t\t\tlatestModelID, err := db.FindLatestAuthorizationModelID(ctx, store.Id)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"no models in store %s \\n\", store.Id)\n\t\t\t}\n\n\t\t\tcontinuationTokenModels := \"\"\n\n\t\t\tfor {\n\t\t\t\t// fetch a page of models for that store\n\t\t\t\tmodels, tokenModels, err := db.ReadAuthorizationModels(ctx, store.Id, storage.PaginationOptions{\n\t\t\t\t\tPageSize: 100,\n\t\t\t\t\tFrom:     continuationTokenModels,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"error reading authorization models: %w\", err)\n\t\t\t\t}\n\n\t\t\t\t// validate each model\n\t\t\t\tfor _, model := range models {\n\t\t\t\t\t_, err := typesystem.NewAndValidate(context.Background(), model)\n\n\t\t\t\t\tvalidationResult := validationResult{\n\t\t\t\t\t\tStoreID:       store.Id,\n\t\t\t\t\t\tModelID:       model.Id,\n\t\t\t\t\t\tIsLatestModel: model.Id == latestModelID,\n\t\t\t\t\t}\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tvalidationResult.Error = err.Error()\n\t\t\t\t\t}\n\t\t\t\t\tvalidationResults = append(validationResults, validationResult)\n\t\t\t\t}\n\n\t\t\t\tcontinuationTokenModels = string(tokenModels)\n\n\t\t\t\tif continuationTokenModels == \"\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// next page of stores\n\t\tcontinuationTokenStores = string(tokenStores)\n\n\t\tif continuationTokenStores == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn validationResults, nil\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// ExpandQuery resolves a target TupleKey into a UsersetTree by expanding type definitions.\ntype ExpandQuery struct {\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n}\n\n// NewExpandQuery creates a new ExpandQuery using the supplied backends for retrieving data.\nfunc NewExpandQuery(datastore storage.OpenFGADatastore, logger logger.Logger) *ExpandQuery {\n\treturn &ExpandQuery{logger: logger, datastore: datastore}\n}\n\nfunc (q *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\tmodelID := req.GetAuthorizationModelId()\n\ttupleKey := req.GetTupleKey()\n\tobject := tupleKey.GetObject()\n\trelation := tupleKey.GetRelation()\n\n\tif object == \"\" || relation == \"\" {\n\t\treturn nil, serverErrors.InvalidExpandInput\n\t}\n\n\ttk := tupleUtils.NewTupleKey(object, relation, \"\")\n\n\tmodel, err := q.datastore.ReadAuthorizationModel(ctx, store, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(model.GetSchemaVersion()) {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\ttypesys, err := typesystem.NewAndValidate(ctx, model)\n\tif err != nil {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)\n\t}\n\n\tif err = validation.ValidateObject(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\terr = validation.ValidateRelation(typesys, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tobjectType := tupleUtils.GetType(object)\n\trel, err := typesys.GetRelation(objectType, relation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn nil, serverErrors.TypeNotFound(objectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn nil, serverErrors.RelationNotFound(relation, objectType, tk)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tuserset := rel.GetRewrite()\n\n\troot, err := q.resolveUserset(ctx, store, userset, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &openfgapb.ExpandResponse{\n\t\tTree: &openfgapb.UsersetTree{\n\t\t\tRoot: root,\n\t\t},\n\t}, nil\n}\n\nfunc (q *ExpandQuery) resolveUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.Userset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUserset\")\n\tdefer span.End()\n\n\tswitch us := userset.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\treturn q.resolveThis(ctx, store, tk, typesys)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn q.resolveComputedUserset(ctx, us.ComputedUserset, tk)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn q.resolveTupleToUserset(ctx, store, us.TupleToUserset, tk, typesys)\n\tcase *openfgapb.Userset_Union:\n\t\treturn q.resolveUnionUserset(ctx, store, us.Union, tk, typesys)\n\tcase *openfgapb.Userset_Difference:\n\t\treturn q.resolveDifferenceUserset(ctx, store, us.Difference, tk, typesys)\n\tcase *openfgapb.Userset_Intersection:\n\t\treturn q.resolveIntersectionUserset(ctx, store, us.Intersection, tk, typesys)\n\tdefault:\n\t\treturn nil, serverErrors.UnsupportedUserSet\n\t}\n}\n\n// resolveThis resolves a DirectUserset into a leaf node containing a distinct set of users with that relation.\nfunc (q *ExpandQuery) resolveThis(ctx context.Context, store string, tk *openfgapb.TupleKey, typesys *typesystem.TypeSystem) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveThis\")\n\tdefer span.End()\n\n\ttupleIter, err := q.datastore.Read(ctx, store, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(tupleIter),\n\t\tvalidation.FilterInvalidTuples(typesys),\n\t)\n\tdefer filteredIter.Stop()\n\n\tdistinctUsers := make(map[string]bool)\n\tfor {\n\t\ttk, err := filteredIter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tdistinctUsers[tk.GetUser()] = true\n\t}\n\n\tusers := make([]string, 0, len(distinctUsers))\n\tfor u := range distinctUsers {\n\t\tusers = append(users, u)\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\tUsers: users,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveComputedUserset builds a leaf node containing the result of resolving a ComputedUserset rewrite.\nfunc (q *ExpandQuery) resolveComputedUserset(ctx context.Context, userset *openfgapb.ObjectRelation, tk *openfgapb.TupleKey) (*openfgapb.UsersetTree_Node, error) {\n\t_, span := tracer.Start(ctx, \"resolveComputedUserset\")\n\tdefer span.End()\n\n\tcomputed := &openfgapb.TupleKey{\n\t\tObject:   userset.GetObject(),\n\t\tRelation: userset.GetRelation(),\n\t}\n\n\tif len(computed.Object) == 0 {\n\t\tcomputed.Object = tk.Object\n\t}\n\n\tif len(computed.Relation) == 0 {\n\t\tcomputed.Relation = tk.Relation\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\tUserset: toObjectRelation(computed),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveTupleToUserset creates a new leaf node containing the result of expanding a TupleToUserset rewrite.\nfunc (q *ExpandQuery) resolveTupleToUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.TupleToUserset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveTupleToUserset\")\n\tdefer span.End()\n\n\ttargetObject := tk.GetObject()\n\n\ttupleset := userset.GetTupleset().GetRelation()\n\n\tobjectType := tupleUtils.GetType(targetObject)\n\t_, err := typesys.GetRelation(objectType, tupleset)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn nil, serverErrors.TypeNotFound(objectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn nil, serverErrors.RelationNotFound(tupleset, objectType, tupleUtils.NewTupleKey(tk.Object, tupleset, tk.User))\n\t\t}\n\t}\n\n\ttsKey := &openfgapb.TupleKey{\n\t\tObject:   targetObject,\n\t\tRelation: tupleset,\n\t}\n\n\tif tsKey.GetRelation() == \"\" {\n\t\ttsKey.Relation = tk.GetRelation()\n\t}\n\n\ttupleIter, err := q.datastore.Read(ctx, store, tsKey)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(tupleIter),\n\t\tvalidation.FilterInvalidTuples(typesys),\n\t)\n\tdefer filteredIter.Stop()\n\n\tvar computed []*openfgapb.UsersetTree_Computed\n\tseen := make(map[string]bool)\n\tfor {\n\t\ttk, err := filteredIter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tuser := tk.GetUser()\n\n\t\ttObject, tRelation := tupleUtils.SplitObjectRelation(user)\n\t\t// We only proceed in the case that tRelation == userset.GetComputedUserset().GetRelation().\n\t\t// tRelation may be empty, and in this case, we set it to userset.GetComputedUserset().GetRelation().\n\t\tif tRelation == \"\" {\n\t\t\ttRelation = userset.GetComputedUserset().GetRelation()\n\t\t}\n\n\t\tcs := &openfgapb.TupleKey{\n\t\t\tObject:   tObject,\n\t\t\tRelation: tRelation,\n\t\t}\n\n\t\tcomputedRelation := toObjectRelation(cs)\n\t\tif !seen[computedRelation] {\n\t\t\tcomputed = append(computed, &openfgapb.UsersetTree_Computed{Userset: computedRelation})\n\t\t\tseen[computedRelation] = true\n\t\t}\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\tTupleset: toObjectRelation(tsKey),\n\t\t\t\t\t\tComputed: computed,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUnionUserset creates an intermediate Usertree node containing the union of its children.\nfunc (q *ExpandQuery) resolveUnionUserset(\n\tctx context.Context,\n\tstore string,\n\tusersets *openfgapb.Usersets,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUnionUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, usersets.Child, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveIntersectionUserset create an intermediate Usertree node containing the intersection of its children\nfunc (q *ExpandQuery) resolveIntersectionUserset(\n\tctx context.Context,\n\tstore string,\n\tusersets *openfgapb.Usersets,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveIntersectionUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, usersets.Child, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveDifferenceUserset creates and intermediate Usertree node containing the difference of its children\nfunc (q *ExpandQuery) resolveDifferenceUserset(\n\tctx context.Context,\n\tstore string,\n\tuserset *openfgapb.Difference,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveDifferenceUserset\")\n\tdefer span.End()\n\n\tnodes, err := q.resolveUsersets(ctx, store, []*openfgapb.Userset{userset.Base, userset.Subtract}, tk, typesys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbase := nodes[0]\n\tsubtract := nodes[1]\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: subtract,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUsersets creates Usertree nodes for multiple Usersets\nfunc (q *ExpandQuery) resolveUsersets(\n\tctx context.Context,\n\tstore string,\n\tusersets []*openfgapb.Userset,\n\ttk *openfgapb.TupleKey,\n\ttypesys *typesystem.TypeSystem,\n) ([]*openfgapb.UsersetTree_Node, error) {\n\tctx, span := tracer.Start(ctx, \"resolveUsersets\")\n\tdefer span.End()\n\n\tout := make([]*openfgapb.UsersetTree_Node, len(usersets))\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tfor i, us := range usersets {\n\t\t// https://golang.org/doc/faq#closures_and_goroutines\n\t\ti, us := i, us\n\t\tgrp.Go(func() error {\n\t\t\tnode, err := q.resolveUserset(ctx, store, us, tk, typesys)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tout[i] = node\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc toObjectRelation(tk *openfgapb.TupleKey) string {\n\treturn tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n}\n", "package commands\n\nimport (\n\t\"context\"\n\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\n// WriteAuthorizationModelCommand performs updates of the store authorization model.\ntype WriteAuthorizationModelCommand struct {\n\tbackend storage.TypeDefinitionWriteBackend\n\tlogger  logger.Logger\n}\n\nfunc NewWriteAuthorizationModelCommand(\n\tbackend storage.TypeDefinitionWriteBackend,\n\tlogger logger.Logger,\n) *WriteAuthorizationModelCommand {\n\treturn &WriteAuthorizationModelCommand{\n\t\tbackend: backend,\n\t\tlogger:  logger,\n\t}\n}\n\n// Execute the command using the supplied request.\nfunc (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\t// Until this is solved: https://github.com/envoyproxy/protoc-gen-validate/issues/74\n\tif len(req.GetTypeDefinitions()) > w.backend.MaxTypesPerAuthorizationModel() {\n\t\treturn nil, serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", w.backend.MaxTypesPerAuthorizationModel())\n\t}\n\n\t// Fill in the schema version for old requests, which don't contain it, while we migrate to the new schema version.\n\tif req.SchemaVersion == \"\" {\n\t\treq.SchemaVersion = typesystem.SchemaVersion1_1\n\t}\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              ulid.Make().String(),\n\t\tSchemaVersion:   req.GetSchemaVersion(),\n\t\tTypeDefinitions: req.GetTypeDefinitions(),\n\t}\n\n\t_, err := typesystem.NewAndValidate(ctx, model)\n\tif err != nil {\n\t\treturn nil, serverErrors.InvalidAuthorizationModelInput(err)\n\t}\n\n\terr = w.backend.WriteAuthorizationModel(ctx, req.GetStoreId(), model)\n\tif err != nil {\n\t\treturn nil, serverErrors.NewInternalError(\"Error writing authorization model configuration\", err)\n\t}\n\n\treturn &openfgapb.WriteAuthorizationModelResponse{\n\t\tAuthorizationModelId: model.Id,\n\t}, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\tgrpc_ctxtags \"github.com/grpc-ecosystem/go-grpc-middleware/tags\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\thttpmiddleware \"github.com/openfga/openfga/pkg/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype ExperimentalFeatureFlag string\n\nconst (\n\tAuthorizationModelIDHeader = \"openfga-authorization-model-id\"\n\tauthorizationModelIDKey    = \"authorization_model_id\"\n\n\tcheckConcurrencyLimit = 100\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server\")\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgapb.UnimplementedOpenFGAServiceServer\n\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n\tencoder   encoder.Encoder\n\ttransport gateway.Transport\n\tconfig    *Config\n}\n\ntype Dependencies struct {\n\tDatastore    storage.OpenFGADatastore\n\tLogger       logger.Logger\n\tTransport    gateway.Transport\n\tTokenEncoder encoder.Encoder\n}\n\ntype Config struct {\n\tResolveNodeLimit       uint32\n\tChangelogHorizonOffset int\n\tListObjectsDeadline    time.Duration\n\tListObjectsMaxResults  uint32\n\tExperimentals          []ExperimentalFeatureFlag\n}\n\n// New creates a new Server which uses the supplied backends\n// for managing data.\nfunc New(dependencies *Dependencies, config *Config) *Server {\n\n\treturn &Server{\n\t\tlogger:    dependencies.Logger,\n\t\tdatastore: dependencies.Datastore,\n\t\tencoder:   dependencies.TokenEncoder,\n\t\ttransport: dependencies.Transport,\n\t\tconfig:    config,\n\t}\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequest) (*openfgapb.ListObjectsResponse, error) {\n\tstoreID := req.GetStoreId()\n\ttargetObjectType := req.GetType()\n\n\tctx, span := tracer.Start(ctx, \"ListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", targetObjectType),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tmodelID := req.GetAuthorizationModelId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, modelID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn nil, err\n\t}\n\n\ttypesys, err := typesystem.NewAndValidate(ctx, model)\n\tif err != nil {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\treturn q.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 targetObjectType,\n\t\tRelation:             req.Relation,\n\t\tUser:                 req.User,\n\t})\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest, srv openfgapb.OpenFGAService_StreamedListObjectsServer) error {\n\tctx := srv.Context()\n\tctx, span := tracer.Start(ctx, \"StreamedListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", req.GetType()),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn serverErrors.AuthorizationModelNotFound(req.GetAuthorizationModelId())\n\t\t}\n\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\ttypesys, err := typesystem.NewAndValidate(ctx, model)\n\tif err != nil {\n\t\treturn serverErrors.ValidationError(typesystem.ErrInvalidModel)\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treq.AuthorizationModelId = modelID\n\treturn q.ExecuteStreamed(ctx, req, srv)\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgapb.ReadRequest) (*openfgapb.ReadResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgapb.ReadRequest{\n\t\tStoreId:           req.GetStoreId(),\n\t\tTupleKey:          tk,\n\t\tPageSize:          req.GetPageSize(),\n\t\tContinuationToken: req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgapb.WriteRequest) (*openfgapb.WriteResponse, error) {\n\tctx, span := tracer.Start(ctx, \"Write\")\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.logger)\n\treturn cmd.Execute(ctx, &openfgapb.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodel, err := s.datastore.ReadAuthorizationModel(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(model.GetSchemaVersion()) {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\ttypesys, err := typesystem.NewAndValidate(ctx, model)\n\tif err != nil {\n\t\treturn nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)\n\t}\n\n\tif err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tcheckResolver := graph.NewLocalChecker(\n\t\tstorage.NewCombinedTupleReader(s.datastore, req.ContextualTuples.GetTupleKeys()),\n\t\tcheckConcurrencyLimit)\n\n\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\tStoreID:              req.GetStoreId(),\n\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\tTupleKey:             req.GetTupleKey(),\n\t\tContextualTuples:     req.ContextualTuples.GetTupleKeys(),\n\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\tDepth: s.config.ResolveNodeLimit,\n\t\t},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) {\n\t\t\treturn nil, serverErrors.AuthorizationModelResolutionTooComplex\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tres := &openfgapb.CheckResponse{\n\t\tAllowed: resp.Allowed,\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewExpandQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, &openfgapb.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgapb.ReadAuthorizationModelRequest) (*openfgapb.ReadAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAuthorizationModel\")\n\tdefer span.End()\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgapb.ReadAuthorizationModelsRequest) (*openfgapb.ReadAuthorizationModelsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModels\")\n\tdefer span.End()\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgapb.WriteAssertionsRequest) (*openfgapb.WriteAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAssertions\")\n\tdefer span.End()\n\n\tstoreID := req.GetStoreId()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgapb.WriteAssertionsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgapb.ReadAssertionsRequest) (*openfgapb.ReadAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAssertions\")\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), modelID)\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgapb.ReadChangesRequest) (*openfgapb.ReadChangesResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.logger, s.encoder, s.config.ChangelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgapb.CreateStoreRequest) (*openfgapb.CreateStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"CreateStore\")\n\tdefer span.End()\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgapb.DeleteStoreRequest) (*openfgapb.DeleteStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"DeleteStore\")\n\tdefer span.End()\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgapb.GetStoreRequest) (*openfgapb.GetStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"GetStore\")\n\tdefer span.End()\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgapb.ListStoresRequest) (*openfgapb.ListStoresResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ListStores\")\n\tdefer span.End()\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// resolveAuthorizationModelID takes a modelID. If it is empty, it will find\n// and return the latest authorization modelID. If is not empty, it will\n// validate it and return it.\n//\n// This allows caching of types. If the user inserts a new authorization model\n// and doesn't provide this field (which should be rate limited more\n// aggressively) the in-flight requests won't be affected and newer calls will\n// use the updated authorization model.\nfunc (s *Server) resolveAuthorizationModelID(ctx context.Context, store, modelID string) (string, error) {\n\tctx, span := tracer.Start(ctx, \"resolveAuthorizationModelID\")\n\tdefer span.End()\n\n\tdefer func() {\n\t\tspan.SetAttributes(attribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(modelID)})\n\t\tgrpc_ctxtags.Extract(ctx).Set(authorizationModelIDKey, modelID)\n\t\t_ = grpc.SetHeader(ctx, metadata.Pairs(AuthorizationModelIDHeader, modelID))\n\t}()\n\n\tvar err error\n\tif modelID != \"\" {\n\t\tif _, err := ulid.Parse(modelID); err != nil {\n\t\t\treturn \"\", serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\treturn modelID, nil\n\t}\n\n\tif modelID, err = s.datastore.FindLatestAuthorizationModelID(ctx, store); err != nil {\n\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\treturn \"\", serverErrors.LatestAuthorizationModelNotFound(store)\n\t\t}\n\n\t\treturn \"\", serverErrors.HandleError(\"\", err)\n\t}\n\n\treturn modelID, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\tmockstorage \"github.com/openfga/openfga/pkg/storage/mocks\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"postgres\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"memory\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"mysql\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\ttuple := &openfgapb.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgapb.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(tuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tLogger:    logger.NewNoopLogger(),\n\t\tTransport: gateway.NewNoopTransport(),\n\t}, &Config{\n\t\tResolveNodeLimit: test.DefaultResolveNodeLimit,\n\t})\n\n\tcheckResponse, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestOperationsWithInvalidModel(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\t// The model is invalid\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n        define admin: [user] as self\n\t    define r1: [user] as self and r2 and r3\n\t    define r2: [user] as self and r1 and r3\n\t    define r3: [user] as self and r1 and r2\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"r1\", \"user:anne\")\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgapb.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// the model is error and err should return\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tLogger:    logger.NewNoopLogger(),\n\t\tTransport: gateway.NewNoopTransport(),\n\t}, &Config{\n\t\tResolveNodeLimit: test.DefaultResolveNodeLimit,\n\t})\n\n\t_, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.Error(t, err)\n\te, ok := status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\n\terr = s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t}, NewMockStreamServer())\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.Expand(ctx, &openfgapb.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user:*] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\ttuple := &openfgapb.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgapb.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgapb.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgapb.Tuple{tuple}), nil\n\t\t\t})\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tLogger:    logger.NewNoopLogger(),\n\t\tTransport: gateway.NewNoopTransport(),\n\t}, &Config{\n\t\tResolveNodeLimit: test.DefaultResolveNodeLimit,\n\t})\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Truef(t, end < 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveAuthorizationModelID(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\tgot, err := s.resolveAuthorizationModelID(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, got)\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := New(&Dependencies{\n\t\t\tDatastore: mockDatastore,\n\t\t\tTransport: transport,\n\t\t\tLogger:    logger,\n\t\t}, &Config{})\n\n\t\t_, err := s.resolveAuthorizationModelID(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgapb.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs TestListObjects_Unoptimized_UnhappyPaths many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n    `)\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      test.DefaultResolveNodeLimit,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\n// This test ensures that when the data storage fails, ListObjects v0 throws an error\nfunc TestListObjects_Unoptimized_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: parser.MustParse(`\n\t\ttype user\n\n\t\ttype repo\n\t\t  relations\n\t\t    define allowed: [user] as self\n\t\t    define viewer: [user] as self and allowed\n\t\t`),\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      test.DefaultResolveNodeLimit,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\n// This test ensures that when the data storage fails, ListObjects v1 throws an error\nfunc TestListObjects_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: \"document\",\n\t\tRelation:   \"viewer\",\n\t\tUserFilter: []*openfgapb.ObjectRelation{\n\t\t\t{Object: \"user:*\"},\n\t\t\t{Object: \"user:bob\"},\n\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := New(&Dependencies{\n\t\tDatastore: mockDatastore,\n\t\tTransport: transport,\n\t\tLogger:    logger,\n\t}, &Config{\n\t\tResolveNodeLimit:      test.DefaultResolveNodeLimit,\n\t\tListObjectsDeadline:   5 * time.Second,\n\t\tListObjectsMaxResults: 1000,\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\ttransport := gateway.NewNoopTransport()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgapb.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ListObjectsByType(gomock.Any(), store, \"repo\").AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := Server{\n\t\tdatastore: mockDatastore,\n\t\ttransport: transport,\n\t\tlogger:    logger,\n\t\tconfig: &Config{\n\t\t\tResolveNodeLimit:      test.DefaultResolveNodeLimit,\n\t\t\tListObjectsDeadline:   5 * time.Second,\n\t\t\tListObjectsMaxResults: 1000,\n\t\t},\n\t}\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgapb.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_expand\", func(t *testing.T) {\n\t\t_, err := s.Expand(ctx, &openfgapb.ExpandRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga\",\n\t\t\t\t\"reader\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgapb.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgapb.TupleKeys{TupleKeys: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\",\n\t\t\t\t\t\"reader\",\n\t\t\t\t\t\"user:anne\"),\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgapb.WriteAuthorizationModelRequest{\n\t\t\tStoreId:         store,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustParse(`type repo`),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgapb.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgapb.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgapb.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) storage.OpenFGADatastore {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc ConnectedObjectsTest(t *testing.T, ds storage.OpenFGADatastore) {\n\n\ttests := []struct {\n\t\tname             string\n\t\tmodel            string\n\t\ttuples           []*openfgapb.TupleKey\n\t\trequest          *commands.ConnectedObjectsRequest\n\t\tresolveNodeLimit uint32\n\t\tlimit            uint32\n\t\texpectedObjects  []string\n\t\texpectedError    error\n\t}{\n\t\t{\n\t\t\tname: \"restrict_results_based_on_limit\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{},\n\t\t\t},\n\t\t\tlimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"folder:folder1\", \"folder:folder2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user, group#member] as self\n\t\t\t    define viewer as owner\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user, group#member] as self or viewer from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:doc1\", \"document:doc2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"folder:folder1\", \"folder:folder2\", \"folder:folder3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &commands.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgapb.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"group:opensource\", \"group:eng\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user] as self\n\t\t\t    define editor as owner\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t    define member as manager\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define member: [user,team#member] as self or admin\n\n\t\t\ttype trial\n\t\t\t  relations\n\t\t\t    define editor: [user,team#member] as self or owner\n\t\t\t    define owner: [user] as self\n\t\t\t    define viewer: [user,team#member] as self or editor\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"trial:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define viewer: [organization] as self\n\t\t\t    define can_view as viewer\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [organization] as self\n\t\t\t    define view as can_view from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"connected_objects_with_public_user_access_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"connected_objects_with_public_user_access_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user, user:*, group#member] as self or writer\n\t\t\t\tdefine writer: [user, user:*, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:x\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{\n\t\t\t\t\tObject: &openfgapb.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &commands.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgapb.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgapb.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\", \"document:2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, employee:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"document:1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:eng_handbook\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t    define reader: [org#dept_member] as self or writer\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"resource:eng_handbook\"},\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &commands.ConnectedObjectsRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &commands.UserRefObject{Object: &openfgapb.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedObjects: []string{\"node:abc\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.Typesystem = typesystem.New(model)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tif test.resolveNodeLimit == 0 {\n\t\t\t\ttest.resolveNodeLimit = DefaultResolveNodeLimit\n\t\t\t}\n\n\t\t\tconnectedObjectsCmd := commands.ConnectedObjectsCommand{\n\t\t\t\tDatastore:        ds,\n\t\t\t\tResolveNodeLimit: test.resolveNodeLimit,\n\t\t\t\tLimit:            test.limit,\n\t\t\t}\n\n\t\t\tresultChan := make(chan commands.ListObjectsResult, 100)\n\t\t\tdone := make(chan struct{})\n\n\t\t\tvar results []string\n\t\t\tgo func() {\n\t\t\t\tfor result := range resultChan {\n\t\t\t\t\tresults = append(results, result.ObjectID)\n\t\t\t\t}\n\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tgo func() {\n\t\t\t\terr = connectedObjectsCmd.StreamedConnectedObjects(timeoutCtx, test.request, resultChan)\n\t\t\t\trequire.ErrorIs(err, test.expectedError)\n\t\t\t\tclose(resultChan)\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-timeoutCtx.Done():\n\t\t\t\trequire.FailNow(\"timed out waiting for response\")\n\t\t\tcase <-done:\n\t\t\t}\n\n\t\t\tif test.expectedError == nil {\n\t\t\t\tsort.Strings(results)\n\t\t\t\tsort.Strings(test.expectedObjects)\n\n\t\t\t\trequire.Equal(test.expectedObjects, results)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/testing/protocmp\"\n)\n\nfunc TestExpandQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    *openfgapb.AuthorizationModel\n\t\ttuples   []*openfgapb.TupleKey\n\t\trequest  *openfgapb.ExpandRequest\n\t\texpected *openfgapb.ExpandResponse\n\t}{\n\t\t{\n\t\t\tname: \"1.1_simple_direct\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_computed_userset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  typesystem.This(),\n\t\t\t\t\t\t\t\"writer\": typesystem.ComputedUserset(\"admin\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset_II\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"amy\", // should be skipped since it's not a valid target for a tupleset relation\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_tuple_to_userset_implicit\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":   typesystem.TupleToUserset(\"manager\", \"repo_admin\"),\n\t\t\t\t\t\t\t\"manager\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"manager\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_admin\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_simple_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t\t\"writer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_simple_difference\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  typesystem.This(),\n\t\t\t\t\t\t\t\"banned\": typesystem.This(),\n\t\t\t\t\t\t\t\"active_admin\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\"),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"banned\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"banned\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"active_admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": typesystem.This(),\n\t\t\t\t\t\t\t// Writers must be both directly in 'writers', and in 'admins'\n\t\t\t\t\t\t\t\"writer\": typesystem.Intersection(\n\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"admin\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_complex_tree\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":         typesystem.This(),\n\t\t\t\t\t\t\t\"owner\":         typesystem.This(),\n\t\t\t\t\t\t\t\"banned_writer\": typesystem.This(),\n\t\t\t\t\t\t\t// Users can write if they are direct members of writers, or repo_writers\n\t\t\t\t\t\t\t// in the org, unless they are also in banned_writers\n\t\t\t\t\t\t\t\"writer\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.Union(\n\t\t\t\t\t\t\t\t\ttypesystem.This(),\n\t\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"owner\", \"repo_writer\")),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"banned_writer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"owner\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"banned_writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"org\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"repo_writer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"repo_writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"user:jon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"user:jon\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Userset: \"org:openfga#repo_writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_Tuple_involving_userset_that_is_not_involved_in_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"editor\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"document\", \"editor\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"document:2#editor\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"parent\", \"\"),\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"document:1#parent\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"document:2#editor\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// arrange\n\t\t\tstore := ulid.Make().String()\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, test.model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = test.model.Id\n\n\t\t\t// act\n\t\t\tquery := commands.NewExpandQuery(datastore, logger)\n\t\t\tgot, err := query.Execute(ctx, test.request)\n\t\t\trequire.NoError(err)\n\n\t\t\t// assert\n\t\t\tif diff := cmp.Diff(test.expected, got, protocmp.Transform()); diff != \"\" {\n\t\t\t\tt.Errorf(\"mismatch (-want, +got):\\n%s\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgapb.AuthorizationModel\n\t\ttuples        []*openfgapb.TupleKey\n\t\trequest       *openfgapb.ExpandRequest\n\t\tallowSchema10 bool\n\t\texpected      error\n\t}{\n\t\t{\n\t\t\tname: \"missing_object_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected:      serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"missing_object_id_and_type_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \":\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid 'object' field format\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"missing_object_id_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"github:\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid 'object' field format\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"missing_relation_in_request\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected:      serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_object_type_not_found_in_model\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"foo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\t&tuple.TypeNotFoundError{TypeName: \"foo\"},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"1.1_relation_not_found_in_model\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tId:            ulid.Make().String(),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{Type: \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\texpected: serverErrors.ValidationError(\n\t\t\t\t&tuple.RelationNotFoundError{\n\t\t\t\t\tTypeName: \"repo\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// arrange\n\t\t\tstore := ulid.Make().String()\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, test.model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\trequire.NoError(err)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = test.model.Id\n\n\t\t\t// act\n\t\t\tquery := commands.NewExpandQuery(datastore, logger)\n\t\t\tresp, err := query.Execute(ctx, test.request)\n\n\t\t\t// assert\n\t\t\trequire.Nil(resp)\n\t\t\trequire.ErrorIs(err, test.expected)\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/mocks\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/grpc\"\n)\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n\tchannel chan string\n}\n\nfunc (x *mockStreamServer) Send(m *openfgapb.StreamedListObjectsResponse) error {\n\tx.channel <- m.Object\n\treturn nil\n}\n\ntype listObjectsTestCase struct {\n\tname                   string\n\tschema                 string\n\ttuples                 []*openfgapb.TupleKey\n\tmodel                  string\n\tobjectType             string\n\tuser                   string\n\trelation               string\n\tcontextualTuples       *openfgapb.ContextualTupleKeys\n\tallResults             []string //all the results. the server may return less\n\tmaxResults             uint32\n\tminimumResultsExpected uint32\n\tlistObjectsDeadline    time.Duration // 1 minute if not set\n\treadTuplesDelay        time.Duration // if set, purposely use a slow storage to slow down read and simulate timeout\n}\n\nfunc TestListObjectsRespectsMaxResults(t *testing.T, ds storage.OpenFGADatastore) {\n\ttestCases := []listObjectsTestCase{\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_reverse_expansion_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgapb.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_ttu_in_model_and_reverse_expansion_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:x\", \"viewer\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:x\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:x\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"parent\", \"folder:x\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\", \"document:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_concurrent_checks_implementation\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t\tdefine blocked: [user] as self\n\t\t\t\tdefine admin: [user] as self but not blocked\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:       \"user:charlie\",\n\t\t\tobjectType: \"org\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgapb.TupleKey{tuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:2\", \"org:3\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_when_schema_1_1_and_maxresults_is_higher_than_actual_result_length\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:1\", \"admin\", \"user:bob\"),\n\t\t\t},\n\t\t\tuser:                   \"user:bob\",\n\t\t\tobjectType:             \"team\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"team:1\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"respects_max_results_when_deadline_timeout_and_returns_no_error_and_no_results\",\n\t\t\tschema: typesystem.SchemaVersion1_1,\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"repo\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 0,\n\t\t\t// We expect empty array to be returned as list object will timeout due to readTuplesDelay > listObjectsDeadline\n\t\t\tallResults:          []string{},\n\t\t\tlistObjectsDeadline: 1 * time.Second,\n\t\t\treadTuplesDelay:     2 * time.Second, // We are mocking the ds to slow down the read call and simulate timeout\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := context.Background()\n\t\t\tstoreID := ulid.Make().String()\n\n\t\t\t// arrange: write model\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   test.schema,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, storeID, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// arrange: write tuples\n\t\t\terr = ds.Write(context.Background(), storeID, nil, test.tuples)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// act: run ListObjects\n\n\t\t\tlistObjectsDeadline := time.Minute\n\t\t\tif test.listObjectsDeadline > 0 {\n\t\t\t\tlistObjectsDeadline = test.listObjectsDeadline\n\t\t\t}\n\n\t\t\tdatastore := ds\n\t\t\tif test.readTuplesDelay > 0 {\n\t\t\t\tdatastore = mocks.NewMockSlowDataStorage(ds, test.readTuplesDelay)\n\t\t\t}\n\n\t\t\tlistObjectsQuery := &commands.ListObjectsQuery{\n\t\t\t\tDatastore:             datastore,\n\t\t\t\tLogger:                logger.NewNoopLogger(),\n\t\t\t\tListObjectsDeadline:   listObjectsDeadline,\n\t\t\t\tListObjectsMaxResults: test.maxResults,\n\t\t\t\tResolveNodeLimit:      DefaultResolveNodeLimit,\n\t\t\t}\n\t\t\ttypesys := typesystem.New(model)\n\t\t\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\t\t\t// assertions\n\t\t\tt.Run(\"streaming_endpoint\", func(t *testing.T) {\n\t\t\t\tserver := &mockStreamServer{\n\t\t\t\t\tchannel: make(chan string, len(test.allResults)),\n\t\t\t\t}\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tvar streamedObjectIds []string\n\t\t\t\tgo func() {\n\t\t\t\t\tfor x := range server.channel {\n\t\t\t\t\t\tstreamedObjectIds = append(streamedObjectIds, x)\n\t\t\t\t\t}\n\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t}()\n\n\t\t\t\terr := listObjectsQuery.ExecuteStreamed(ctx, &openfgapb.StreamedListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t}, server)\n\t\t\t\tclose(server.channel)\n\t\t\t\t<-done\n\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.GreaterOrEqual(t, len(streamedObjectIds), int(test.minimumResultsExpected))\n\t\t\t\trequire.ElementsMatch(t, test.allResults, streamedObjectIds)\n\t\t\t})\n\n\t\t\tt.Run(\"regular_endpoint\", func(t *testing.T) {\n\t\t\t\tres, err := listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t})\n\n\t\t\t\trequire.NotNil(t, res)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.LessOrEqual(t, len(res.Objects), int(test.maxResults))\n\t\t\t\trequire.GreaterOrEqual(t, len(res.Objects), int(test.minimumResultsExpected))\n\t\t\t\trequire.Subset(t, test.allResults, res.Objects)\n\t\t\t})\n\t\t})\n\t}\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar listObjectsResponse *openfgapb.ListObjectsResponse //nolint\n\nfunc BenchmarkListObjectsWithReverseExpand(b *testing.B, ds storage.OpenFGADatastore) {\n\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:            ulid.Make().String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\tn := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgapb.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite(); j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(n))\n\t\t\tuser := fmt.Sprintf(\"user:%s\", strconv.Itoa(n))\n\n\t\t\ttuples = append(tuples, tuple.NewTupleKey(obj, \"viewer\", user))\n\n\t\t\tn += 1\n\t\t}\n\n\t\terr = ds.Write(ctx, store, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\tlistObjectsQuery := commands.ListObjectsQuery{\n\t\tDatastore:        ds,\n\t\tLogger:           logger.NewNoopLogger(),\n\t\tResolveNodeLimit: DefaultResolveNodeLimit,\n\t}\n\n\tvar r *openfgapb.ListObjectsResponse\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:999\",\n\t\t})\n\t}\n\n\tlistObjectsResponse = r\n}\n\nfunc BenchmarkListObjectsWithConcurrentChecks(b *testing.B, ds storage.OpenFGADatastore) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype document\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n\t`)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              ulid.Make().String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}\n\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\tn := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgapb.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite()/2; j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(n))\n\t\t\tuser := fmt.Sprintf(\"user:%s\", strconv.Itoa(n))\n\n\t\t\ttuples = append(\n\t\t\t\ttuples,\n\t\t\t\ttuple.NewTupleKey(obj, \"viewer\", user),\n\t\t\t\ttuple.NewTupleKey(obj, \"allowed\", user),\n\t\t\t)\n\n\t\t\tn += 1\n\t\t}\n\n\t\terr = ds.Write(ctx, store, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\tlistObjectsQuery := commands.ListObjectsQuery{\n\t\tDatastore:        ds,\n\t\tLogger:           logger.NewNoopLogger(),\n\t\tResolveNodeLimit: DefaultResolveNodeLimit,\n\t}\n\n\tvar r *openfgapb.ListObjectsResponse\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = listObjectsQuery.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:999\",\n\t\t})\n\t}\n\n\tlistObjectsResponse = r\n}\n", "package test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/openfga/openfga/pkg/storage\"\n)\n\nconst (\n\tDefaultResolveNodeLimit = 25\n)\n\nfunc RunAllTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tRunQueryTests(t, ds)\n\tRunCommandTests(t, ds)\n}\n\nfunc RunQueryTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tt.Run(\"TestReadAuthorizationModelQueryErrors\", func(t *testing.T) { TestReadAuthorizationModelQueryErrors(t, ds) })\n\tt.Run(\"TestSuccessfulReadAuthorizationModelQuery\", func(t *testing.T) { TestSuccessfulReadAuthorizationModelQuery(t, ds) })\n\tt.Run(\"TestReadAuthorizationModel\", func(t *testing.T) { ReadAuthorizationModelTest(t, ds) })\n\tt.Run(\"TestExpandQuery\", func(t *testing.T) { TestExpandQuery(t, ds) })\n\tt.Run(\"TestExpandQueryErrors\", func(t *testing.T) { TestExpandQueryErrors(t, ds) })\n\n\tt.Run(\"TestGetStoreQuery\", func(t *testing.T) { TestGetStoreQuery(t, ds) })\n\tt.Run(\"TestGetStoreSucceeds\", func(t *testing.T) { TestGetStoreSucceeds(t, ds) })\n\tt.Run(\"TestListStores\", func(t *testing.T) { TestListStores(t, ds) })\n\n\tt.Run(\"TestReadAssertionQuery\", func(t *testing.T) { TestReadAssertionQuery(t, ds) })\n\n\tt.Run(\"TestReadQuerySuccess\", func(t *testing.T) { ReadQuerySuccessTest(t, ds) })\n\tt.Run(\"TestReadQueryError\", func(t *testing.T) { ReadQueryErrorTest(t, ds) })\n\tt.Run(\"TestReadAllTuples\", func(t *testing.T) { ReadAllTuplesTest(t, ds) })\n\tt.Run(\"TestReadAllTuplesInvalidContinuationToken\", func(t *testing.T) { ReadAllTuplesInvalidContinuationTokenTest(t, ds) })\n\n\tt.Run(\"TestReadAuthorizationModelsWithoutPaging\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsWithoutPaging(t, ds) },\n\t)\n\n\tt.Run(\"TestReadAuthorizationModelsWithPaging\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsWithPaging(t, ds) },\n\t)\n\n\tt.Run(\"TestReadAuthorizationModelsInvalidContinuationToken\",\n\t\tfunc(t *testing.T) { TestReadAuthorizationModelsInvalidContinuationToken(t, ds) },\n\t)\n\n\tt.Run(\"TestReadChanges\", func(t *testing.T) { TestReadChanges(t, ds) })\n\tt.Run(\"TestReadChangesReturnsSameContTokenWhenNoChanges\",\n\t\tfunc(t *testing.T) { TestReadChangesReturnsSameContTokenWhenNoChanges(t, ds) },\n\t)\n\n\tt.Run(\"TestListObjectsRespectsMaxResults\", func(t *testing.T) { TestListObjectsRespectsMaxResults(t, ds) })\n}\n\nfunc RunCommandTests(t *testing.T, ds storage.OpenFGADatastore) {\n\tt.Run(\"TestWriteCommand\", func(t *testing.T) { TestWriteCommand(t, ds) })\n\tt.Run(\"TestWriteAuthorizationModel\", func(t *testing.T) { WriteAuthorizationModelTest(t, ds) })\n\tt.Run(\"TestWriteAssertions\", func(t *testing.T) { TestWriteAssertions(t, ds) })\n\tt.Run(\"TestCreateStore\", func(t *testing.T) { TestCreateStore(t, ds) })\n\tt.Run(\"TestDeleteStore\", func(t *testing.T) { TestDeleteStore(t, ds) })\n\tt.Run(\"TestConnectedObjects\", func(t *testing.T) { ConnectedObjectsTest(t, ds) })\n}\n\nfunc RunAllBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {\n\tRunListObjectsBenchmarks(b, ds)\n}\n\nfunc RunListObjectsBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {\n\tb.Run(\"BenchmarkListObjectsWithReverseExpand\", func(b *testing.B) { BenchmarkListObjectsWithReverseExpand(b, ds) })\n\tb.Run(\"BenchmarkListObjectsWithConcurrentChecks\", func(b *testing.B) { BenchmarkListObjectsWithConcurrentChecks(b, ds) })\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID := ulid.Make().String()\n\n\titems := make([]*openfgapb.TypeDefinition, datastore.MaxTypesPerAuthorizationModel()+1)\n\titems[0] = &openfgapb.TypeDefinition{\n\t\tType: \"user\",\n\t}\n\tfor i := 1; i < datastore.MaxTypesPerAuthorizationModel(); i++ {\n\t\titems[i] = &openfgapb.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t},\n\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname          string\n\t\trequest       *openfgapb.WriteAuthorizationModelRequest\n\t\tallowSchema10 bool\n\t\terr           error\n\t}{\n\t\t{\n\t\t\tname: \"fails_if_too_many_types\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", datastore.MaxTypesPerAuthorizationModel()),\n\t\t},\n\t\t{\n\t\t\tname: \"fails_if_a_relation_is_not_defined\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{ObjectType: \"repo\", Relation: \"owner\"}),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_type_info_metadata_is_omitted_in_1.1_model\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:       storeID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the assignable relation 'reader' in object type 'document' must contain at least one relation type\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_writing_1_0_model_because_it_will_be_interpreted_as_1_1\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(typesystem.AssignableRelationError(\"document\", \"reader\")),\n\t\t},\n\t\t{\n\t\t\tname: \"Works_if_no_schema_version\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_1\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrCycle,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_2\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_3\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self but not restricted\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrCycle,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"rewritten_relation_in_intersection_unresolvable\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin and action2 and action3\n\t\t\t\t    define action2 as admin and action1 and action3\n\t\t\t\t    define action3 as admin and action1 and action2\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"action1\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer as editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tname: \"rewritten_relation_in_exclusion_unresolvable\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin but not action2\n\t\t\t\t    define action2 as admin but not action3\n\t\t\t\t    define action3 as admin but not action1\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"action1\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [document] as self\n\t\t\t\t    define viewer as editor from parent\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t    define editor as viewer\n\t\t\t\t    define viewer as editor from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t    define can_view as viewer but not restricted\n\t\t\t\t    define can_view_actual as can_view\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"relation_with_union_of_ttu_rewrites\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype org\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype group\n\t\t\t\t  relations\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype feature\n\t\t\t\t  relations\n\t\t\t\t    define accessible as admin from subscriber_org or member from subscriber_group\n\t\t\t\t    define subscriber_group: [group] as self\n\t\t\t\t    define subscriber_org: [org] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"type_name_is_empty_string\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\tfmt.Errorf(\"the type name of a type definition cannot be an empty string\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_name_is_empty_string\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\tfmt.Errorf(\"type 'user' defines a relation with an empty string for a name\"),\n\t\t\t),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\n\t\t\tif err == nil {\n\t\t\t\t_, err = ulid.Parse(resp.AuthorizationModelId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package typesystem\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel\"\n\t\"golang.org/x/exp/maps\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/typesystem\")\n\ntype ctxKey string\n\nconst (\n\tSchemaVersion1_0 string = \"1.0\"\n\tSchemaVersion1_1 string = \"1.1\"\n\n\ttypesystemCtxKey ctxKey = \"typesystem-context-key\"\n)\n\nvar (\n\tErrDuplicateTypes        = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion  = errors.New(\"invalid schema version\")\n\tErrInvalidModel          = errors.New(\"invalid authorization model encountered\")\n\tErrRelationUndefined     = errors.New(\"undefined relation\")\n\tErrObjectTypeUndefined   = errors.New(\"undefined object type\")\n\tErrInvalidUsersetRewrite = errors.New(\"invalid userset rewrite definition\")\n\tErrReservedKeywords      = errors.New(\"self and this are reserved keywords\")\n\tErrCycle                 = errors.New(\"an authorization model cannot contain a cycle\")\n\tErrNoEntrypoints         = errors.New(\"no entrypoints defined\")\n)\n\nfunc IsSchemaVersionSupported(version string) bool {\n\tswitch version {\n\tcase SchemaVersion1_1:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// ContextWithTypesystem attaches the provided TypeSystem to the parent context.\nfunc ContextWithTypesystem(parent context.Context, typesys *TypeSystem) context.Context {\n\treturn context.WithValue(parent, typesystemCtxKey, typesys)\n}\n\n// TypesystemFromContext returns the TypeSystem from the provided context (if any).\nfunc TypesystemFromContext(ctx context.Context) (*TypeSystem, bool) {\n\ttypesys, ok := ctx.Value(typesystemCtxKey).(*TypeSystem)\n\treturn typesys, ok\n}\n\nfunc DirectRelationReference(objectType, relation string) *openfgapb.RelationReference {\n\trelationReference := &openfgapb.RelationReference{\n\t\tType: objectType,\n\t}\n\tif relation != \"\" {\n\t\trelationReference.RelationOrWildcard = &openfgapb.RelationReference_Relation{\n\t\t\tRelation: relation,\n\t\t}\n\t}\n\n\treturn relationReference\n}\n\nfunc WildcardRelationReference(objectType string) *openfgapb.RelationReference {\n\treturn &openfgapb.RelationReference{\n\t\tType: objectType,\n\t\tRelationOrWildcard: &openfgapb.RelationReference_Wildcard{\n\t\t\tWildcard: &openfgapb.Wildcard{},\n\t\t},\n\t}\n}\n\nfunc This() *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tupleset, computedUserset string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: tupleset,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: computedUserset,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Union{\n\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgapb.Userset, sub *openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\ntype TypeSystem struct {\n\t// [objectType] => typeDefinition\n\ttypeDefinitions map[string]*openfgapb.TypeDefinition\n\t// [objectType] => [relationName] => relation\n\trelations     map[string]map[string]*openfgapb.Relation\n\tmodelID       string\n\tschemaVersion string\n}\n\n// New creates a *TypeSystem from an *openfgapb.AuthorizationModel.\n// It assumes that the input model is valid. If you need to run validations, use NewAndValidate.\nfunc New(model *openfgapb.AuthorizationModel) *TypeSystem {\n\ttds := make(map[string]*openfgapb.TypeDefinition, len(model.GetTypeDefinitions()))\n\trelations := make(map[string]map[string]*openfgapb.Relation, len(model.GetTypeDefinitions()))\n\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttypeName := td.GetType()\n\n\t\ttds[typeName] = td\n\t\ttdRelations := make(map[string]*openfgapb.Relation, len(td.GetRelations()))\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\tr := &openfgapb.Relation{\n\t\t\t\tName:     relation,\n\t\t\t\tRewrite:  rewrite,\n\t\t\t\tTypeInfo: &openfgapb.RelationTypeInfo{},\n\t\t\t}\n\n\t\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t\t}\n\n\t\t\ttdRelations[relation] = r\n\t\t}\n\t\trelations[typeName] = tdRelations\n\t}\n\n\treturn &TypeSystem{\n\t\tmodelID:         model.GetId(),\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t\trelations:       relations,\n\t}\n}\n\n// GetAuthorizationModelID returns the id for the authorization model this\n// TypeSystem was constructed for.\nfunc (t *TypeSystem) GetAuthorizationModelID() string {\n\treturn t.modelID\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgapb.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\n// GetRelations returns all relations in the TypeSystem for a given type\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgapb.Relation, error) {\n\t_, ok := t.GetTypeDefinition(objectType)\n\tif !ok {\n\t\treturn nil, &ObjectTypeUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tErr:        ErrObjectTypeUndefined,\n\t\t}\n\t}\n\n\treturn t.relations[objectType], nil\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgapb.Relation, error) {\n\trelations, err := t.GetRelations(objectType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, &RelationUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tRelation:   relation,\n\t\t\tErr:        ErrRelationUndefined,\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// GetRelationReferenceAsString returns team#member, or team:*, or an empty string if the input is nil.\nfunc GetRelationReferenceAsString(rr *openfgapb.RelationReference) string {\n\tif rr == nil {\n\t\treturn \"\"\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgapb.RelationReference_Relation); ok {\n\t\treturn fmt.Sprintf(\"%s#%s\", rr.GetType(), rr.GetRelation())\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgapb.RelationReference_Wildcard); ok {\n\t\treturn fmt.Sprintf(\"%s:*\", rr.GetType())\n\t}\n\n\tpanic(\"unexpected relation reference\")\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) ([]*openfgapb.RelationReference, error) {\n\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes(), nil\n}\n\n// IsDirectlyRelated determines whether the type of the target DirectRelationReference contains the source DirectRelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgapb.RelationReference, source *openfgapb.RelationReference) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif source.GetType() == typeRestriction.GetType() {\n\n\t\t\t// type with no relation or wildcard (e.g. 'user')\n\t\t\tif typeRestriction.GetRelationOrWildcard() == nil && source.GetRelationOrWildcard() == nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// typed wildcard (e.g. 'user:*')\n\t\t\tif typeRestriction.GetWildcard() != nil && source.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tif typeRestriction.GetRelation() != \"\" && source.GetRelation() != \"\" &&\n\t\t\t\ttypeRestriction.GetRelation() == source.GetRelation() {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n/*\n * IsPubliclyAssignable returns true if the provided objectType is part of a typed wildcard type restriction\n * on the target relation.\n *\n * type user\n *\n * type document\n *   relations\n *     define viewer: [user:*]\n *\n * In the example above, the 'user' objectType is publicly assignable to the 'document#viewer' relation.\n */\nfunc (t *TypeSystem) IsPubliclyAssignable(target *openfgapb.RelationReference, objectType string) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetType() == objectType {\n\t\t\tif typeRestriction.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) HasTypeInfo(objectType, relation string) (bool, error) {\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif t.GetSchemaVersion() == SchemaVersion1_1 && r.GetTypeInfo() != nil {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesIntersection returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect intersections or any of the types related to\n// the provided relation are defined by one or more direct or indirect intersections.\nfunc (t *TypeSystem) RelationInvolvesIntersection(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesIntersection(objectType, relation, visited)\n}\n\nfunc (t *TypeSystem) relationInvolvesIntersection(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsIntersection {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgapb.Userset_Intersection:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesExclusion returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect exclusions or any of the types related to\n// the provided relation are defined by one or more direct or indirect exclusions.\nfunc (t *TypeSystem) RelationInvolvesExclusion(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesExclusion(objectType, relation, visited)\n\n}\n\nfunc (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsExclusion {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgapb.Userset_Difference:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// hasEntrypoints recursively walks the rewrite definition for the given relation to determine if there is at least\n// one path in the rewrite rule that could relate to at least one concrete object type. If there is no such path that\n// could lead to at least one relationship with some object type, then false is returned along with an error indicating\n// no entrypoints were found. If at least one relationship with a specific object type is found while walking the rewrite,\n// then true is returned along with a nil error.\nfunc hasEntrypoints(\n\ttypedefs map[string]map[string]*openfgapb.Relation,\n\ttypeName, relationName string,\n\trewrite *openfgapb.Userset,\n\tvisitedRelations map[string]map[string]struct{},\n) (bool, error) {\n\n\tv := maps.Clone(visitedRelations)\n\n\tif val, ok := v[typeName]; ok {\n\t\tval[relationName] = struct{}{}\n\t} else {\n\t\tv[typeName] = map[string]struct{}{\n\t\t\trelationName: {},\n\t\t}\n\t}\n\n\trelation, ok := typedefs[typeName][relationName]\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, relationName)\n\t}\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgapb.Userset_This:\n\t\tfor _, assignableType := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tif assignableType.GetRelationOrWildcard() == nil || assignableType.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tassignableTypeName := assignableType.GetType()\n\t\t\tassignableRelationName := assignableType.GetRelation()\n\n\t\t\tassignableRelation, ok := typedefs[assignableTypeName][assignableRelationName]\n\t\t\tif !ok {\n\t\t\t\treturn false, fmt.Errorf(\"undefined type definition for '%s#%s'\", assignableTypeName, assignableRelationName)\n\t\t\t}\n\n\t\t\tif _, ok := v[assignableTypeName][assignableRelationName]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\thasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, assignableRelationName, assignableRelation.GetRewrite(), v)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoint {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, nil\n\tcase *openfgapb.Userset_ComputedUserset:\n\n\t\tcomputedRelationName := rw.ComputedUserset.GetRelation()\n\t\tcomputedRelation, ok := typedefs[typeName][computedRelationName]\n\t\tif !ok {\n\t\t\treturn false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, computedRelationName)\n\t\t}\n\n\t\tif _, ok := v[typeName][computedRelationName]; ok {\n\t\t\treturn false, nil\n\t\t}\n\n\t\thasEntrypoint, err := hasEntrypoints(typedefs, typeName, computedRelationName, computedRelation.GetRewrite(), v)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\treturn hasEntrypoint, nil\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\ttuplesetRelationName := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\tcomputedRelationName := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\ttuplesetRelation, ok := typedefs[typeName][tuplesetRelationName]\n\t\tif !ok {\n\t\t\treturn false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, tuplesetRelationName)\n\t\t}\n\n\t\tfor _, assignableType := range tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tassignableTypeName := assignableType.GetType()\n\n\t\t\tif assignableRelation, ok := typedefs[assignableTypeName][computedRelationName]; ok {\n\t\t\t\tif _, ok := v[assignableTypeName][computedRelationName]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, computedRelationName, assignableRelation.GetRewrite(), v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\n\t\t\t\tif hasEntrypoint {\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false, nil\n\n\tcase *openfgapb.Userset_Union:\n\n\t\tfor _, child := range rw.Union.Child {\n\n\t\t\thasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoints {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, nil\n\tcase *openfgapb.Userset_Intersection:\n\n\t\tfor _, child := range rw.Intersection.Child {\n\n\t\t\t// all of the children must have an entrypoint\n\t\t\thasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif !hasEntrypoints {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\n\t\treturn true, nil\n\tcase *openfgapb.Userset_Difference:\n\n\t\tv := maps.Clone(visitedRelations)\n\n\t\thasEntrypoint, err := hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetBase(), v)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, nil\n\t\t}\n\n\t\thasEntrypoint, err = hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetSubtract(), v)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, nil\n\t\t}\n\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// NewAndValidate is like New but also validates the model according to the following rules:\n//  1. Checks that the *TypeSystem have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the *TypeSystem (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the *TypeSystem has a v1.1 schema version (with types on relations), then additionally\n// validate the *TypeSystem according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc NewAndValidate(ctx context.Context, model *openfgapb.AuthorizationModel) (*TypeSystem, error) {\n\t_, span := tracer.Start(ctx, \"typesystem.NewAndValidate\")\n\tdefer span.End()\n\n\tt := New(model)\n\tschemaVersion := t.GetSchemaVersion()\n\n\tif !IsSchemaVersionSupported(schemaVersion) {\n\t\treturn nil, ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn nil, ErrDuplicateTypes\n\t}\n\n\tif err := t.validateNames(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttypedefsMap := t.typeDefinitions\n\n\ttypeNames := make([]string, 0, len(typedefsMap))\n\tfor typeName := range typedefsMap {\n\t\ttypeNames = append(typeNames, typeName)\n\t}\n\n\t// range over the type definitions in sorted order to produce a deterministic outcome\n\tsort.Strings(typeNames)\n\n\tfor _, typeName := range typeNames {\n\t\ttypedef := typedefsMap[typeName]\n\n\t\trelationMap := typedef.GetRelations()\n\t\trelationNames := make([]string, 0, len(relationMap))\n\t\tfor relationName := range relationMap {\n\t\t\trelationNames = append(relationNames, relationName)\n\t\t}\n\n\t\t// range over the relations in sorted order to produce a deterministic outcome\n\t\tsort.Strings(relationNames)\n\n\t\tfor _, relationName := range relationNames {\n\n\t\t\terr := t.validateRelation(typeName, relationName, relationMap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := t.ensureNoCyclesInTupleToUsersetDefinitions(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := t.ensureNoCyclesInComputedRewrite(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn t, nil\n}\n\n// validateRelation applies all of the validation rules to a relation definition in a model. A relation\n// must meet all of the rewrite validation, type restriction valdiation, and entrypoint validation criteria\n// for it to be valid. Otherrwise an error is returned.\nfunc (t *TypeSystem) validateRelation(typeName, relationName string, relationMap map[string]*openfgapb.Userset) error {\n\n\trewrite := relationMap[relationName]\n\n\terr := t.isUsersetRewriteValid(typeName, relationName, rewrite)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = t.validateTypeRestrictions(typeName, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvisitedRelations := map[string]map[string]struct{}{}\n\n\thasEntrypoints, err := hasEntrypoints(t.relations, typeName, relationName, rewrite, visitedRelations)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !hasEntrypoints {\n\t\treturn &InvalidRelationError{\n\t\t\tObjectType: typeName,\n\t\t\tRelation:   relationName,\n\t\t\tCause:      fmt.Errorf(\"no entrypoints found for relation '%s#%s': %w\", typeName, relationName, ErrNoEntrypoints),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc containsDuplicateType(model *openfgapb.AuthorizationModel) bool {\n\tseen := make(map[string]struct{}, len(model.GetTypeDefinitions()))\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\n// validateNames ensures that a model doesn't have object types or relations\n// called \"self\" or \"this\"\nfunc (t *TypeSystem) validateNames() error {\n\tfor _, td := range t.typeDefinitions {\n\t\tobjectType := td.GetType()\n\n\t\tif objectType == \"\" {\n\t\t\treturn fmt.Errorf(\"the type name of a type definition cannot be an empty string\")\n\t\t}\n\n\t\tif objectType == \"self\" || objectType == \"this\" {\n\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}\n\t\t}\n\n\t\tfor relation := range td.GetRelations() {\n\t\t\tif relation == \"\" {\n\t\t\t\treturn fmt.Errorf(\"type '%s' defines a relation with an empty string for a name\", objectType)\n\t\t\t}\n\n\t\t\tif relation == \"self\" || relation == \"this\" {\n\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if the rewrite on objectType#relation is valid.\nfunc (t *TypeSystem) isUsersetRewriteValid(objectType, relation string, rewrite *openfgapb.Userset) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t}\n\n\tswitch r := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tcomputedUserset := r.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t\t}\n\t\tif _, err := t.GetRelation(objectType, computedUserset); err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\ttupleset := r.TupleToUserset.GetTupleset().GetRelation()\n\n\t\ttuplesetRelation, err := t.GetRelation(objectType, tupleset)\n\t\tif err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: tupleset, Err: ErrRelationUndefined}\n\t\t}\n\n\t\t// tupleset relations must only be direct relationships, no rewrites are allowed on them\n\t\ttuplesetRewrite := tuplesetRelation.GetRewrite()\n\t\tif reflect.TypeOf(tuplesetRewrite.GetUserset()) != reflect.TypeOf(&openfgapb.Userset_This{}) {\n\t\t\treturn fmt.Errorf(\"the '%s#%s' relation is referenced in at least one tupleset and thus must be a direct relation\", objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := r.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\tif t.GetSchemaVersion() == SchemaVersion1_1 {\n\t\t\t// for 1.1 models, relation `computedUserset` has to be defined in one of the types declared by the tupleset's list of allowed types\n\t\t\tuserTypes := tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, rr := range userTypes {\n\t\t\t\tif _, err := t.GetRelation(rr.GetType(), computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%w: %s does not appear as a relation in any of the directly related user types %s\", ErrRelationUndefined, computedUserset, userTypes)\n\t\t} else {\n\t\t\t// for 1.0 models, relation `computedUserset` has to be defined _somewhere_ in the model\n\t\t\tfor typeName := range t.relations {\n\t\t\t\tif _, err := t.GetRelation(typeName, computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &RelationUndefinedError{ObjectType: \"\", Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range r.Union.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range r.Intersection.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\terr := t.isUsersetRewriteValid(objectType, relation, r.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = t.isUsersetRewriteValid(objectType, relation, r.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateTypeRestrictions validates the type restrictions of a given relation using the following rules:\n//  1. An assignable relation must have one or more type restrictions.\n//  2. A non-assignable relation must not have any type restrictions.\n//  3. For each type restriction referenced for an assignable relation, each of the referenced types and relations\n//     must be defined in the model.\n//  4. If the provided relation is a tupleset relation, then the type restriction must be on a direct object.\nfunc (t *TypeSystem) validateTypeRestrictions(objectType string, relationName string) error {\n\n\trelation, err := t.GetRelation(objectType, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\tassignable := t.IsDirectlyAssignable(relation)\n\n\tif assignable && len(relatedTypes) == 0 {\n\t\treturn AssignableRelationError(objectType, relationName)\n\t}\n\n\tif !assignable && len(relatedTypes) != 0 {\n\t\treturn NonAssignableRelationError(objectType, relationName)\n\t}\n\n\tfor _, related := range relatedTypes {\n\t\trelatedObjectType := related.GetType()\n\t\trelatedRelation := related.GetRelation()\n\n\t\tif _, err := t.GetRelations(relatedObjectType); err != nil {\n\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t}\n\n\t\tif related.GetRelationOrWildcard() != nil {\n\t\t\t// The type of the relation cannot contain a userset or wildcard if the relation is a tupleset relation.\n\t\t\tif ok, _ := t.IsTuplesetRelation(objectType, relationName); ok {\n\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t}\n\n\t\t\tif relatedRelation != \"\" {\n\t\t\t\tif _, err := t.GetRelation(relatedObjectType, relatedRelation); err != nil {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ensureNoCyclesInTupleToUsersetDefinitions throws an error on the following models because `viewer` is a cycle.\n//\n//\ttype folder\n//\t  relations\n//\t    define parent: [folder] as self\n//\t    define viewer as viewer from parent\n//\n// and\n//\n//\ttype folder\n//\t  relations\n//\t    define parent as self\n//\t    define viewer as viewer from parent\nfunc (t *TypeSystem) ensureNoCyclesInTupleToUsersetDefinitions() error {\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, err := t.GetRelations(objectType)\n\t\tif err == nil {\n\t\t\tfor relationName, relation := range relations {\n\t\t\t\tswitch cyclicDefinition := relation.GetRewrite().Userset.(type) {\n\t\t\t\tcase *openfgapb.Userset_TupleToUserset:\n\t\t\t\t\t// define viewer as viewer from parent\n\t\t\t\t\tif cyclicDefinition.TupleToUserset.ComputedUserset.GetRelation() == relationName {\n\t\t\t\t\t\ttuplesetRelationName := cyclicDefinition.TupleToUserset.GetTupleset().GetRelation()\n\t\t\t\t\t\ttuplesetRelation, err := t.GetRelation(objectType, tuplesetRelationName)\n\t\t\t\t\t\t// define parent: [folder] as self\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tswitch tuplesetRelation.GetRewrite().Userset.(type) {\n\t\t\t\t\t\t\tcase *openfgapb.Userset_This:\n\t\t\t\t\t\t\t\tif t.schemaVersion == SchemaVersion1_0 && len(t.typeDefinitions) == 1 {\n\t\t\t\t\t\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relationName, Cause: ErrCycle}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif t.schemaVersion == SchemaVersion1_1 && len(tuplesetRelation.TypeInfo.DirectlyRelatedUserTypes) == 1 && tuplesetRelation.TypeInfo.DirectlyRelatedUserTypes[0].Type == objectType {\n\t\t\t\t\t\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relationName, Cause: ErrCycle}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ensureNoCyclesInComputedRewrite throws an error on the following model because `folder` type is a cycle.\n//\n//\t type folder\n//\t\t relations\n//\t\t  define parent as child\n//\t\t  define child as parent\nfunc (t *TypeSystem) ensureNoCyclesInComputedRewrite() error {\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, err := t.GetRelations(objectType)\n\t\tif err == nil {\n\t\t\tfor sourceRelationName, relation := range relations {\n\t\t\t\tswitch source := relation.GetRewrite().Userset.(type) {\n\t\t\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\t\t\ttarget := source.ComputedUserset.GetRelation()\n\t\t\t\t\ttargetRelation, err := t.GetRelation(objectType, target)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tswitch rewrite := targetRelation.GetRewrite().Userset.(type) {\n\t\t\t\t\t\tcase *openfgapb.Userset_ComputedUserset:\n\t\t\t\t\t\t\tif rewrite.ComputedUserset.GetRelation() == sourceRelationName {\n\t\t\t\t\t\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrCycle}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgapb.Relation) bool {\n\treturn RewriteContainsSelf(relation.GetRewrite())\n}\n\n// RewriteContainsSelf returns true if the provided userset rewrite\n// is defined by one or more self referencing definitions.\nfunc RewriteContainsSelf(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_This); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsIntersection returns true if the provided userset rewrite\n// is defined by one or more direct or indirect intersections.\nfunc RewriteContainsIntersection(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_Intersection); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsExclusion returns true if the provided userset rewrite\n// is defined by one or more direct or indirect exclusions.\nfunc RewriteContainsExclusion(rewrite *openfgapb.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgapb.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgapb.Userset_Difference); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\ntype InvalidTypeError struct {\n\tObjectType string\n\tCause      error\n}\n\nfunc (e *InvalidTypeError) Error() string {\n\treturn fmt.Sprintf(\"the definition of type '%s' is invalid\", e.ObjectType)\n}\n\nfunc (e *InvalidTypeError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype InvalidRelationError struct {\n\tObjectType string\n\tRelation   string\n\tCause      error\n}\n\nfunc (e *InvalidRelationError) Error() string {\n\treturn fmt.Sprintf(\"the definition of relation '%s' in object type '%s' is invalid\", e.Relation, e.ObjectType)\n}\n\nfunc (e *InvalidRelationError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype ObjectTypeUndefinedError struct {\n\tObjectType string\n\tErr        error\n}\n\nfunc (e *ObjectTypeUndefinedError) Error() string {\n\treturn fmt.Sprintf(\"'%s' is an undefined object type\", e.ObjectType)\n}\n\nfunc (e *ObjectTypeUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\ntype RelationUndefinedError struct {\n\tObjectType string\n\tRelation   string\n\tErr        error\n}\n\nfunc (e *RelationUndefinedError) Error() string {\n\n\tif e.ObjectType != \"\" {\n\t\treturn fmt.Sprintf(\"'%s#%s' relation is undefined\", e.ObjectType, e.Relation)\n\t}\n\n\treturn fmt.Sprintf(\"'%s' relation is undefined\", e.Relation)\n}\n\nfunc (e *RelationUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = tuple.ToObjectRelationString(relatedObjectType, relatedRelation)\n\t}\n\n\treturn fmt.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n\n// getAllTupleToUsersetsDefinitions returns a map where the key is the object type and the value\n// is another map where key=relationName, value=list of tuple to usersets declared in that relation\nfunc (t *TypeSystem) getAllTupleToUsersetsDefinitions() map[string]map[string][]*openfgapb.TupleToUserset {\n\tresponse := make(map[string]map[string][]*openfgapb.TupleToUserset, 0)\n\tfor typeName, typeDef := range t.typeDefinitions {\n\t\tresponse[typeName] = make(map[string][]*openfgapb.TupleToUserset, 0)\n\t\tfor relationName, relationDef := range typeDef.GetRelations() {\n\t\t\tttus := make([]*openfgapb.TupleToUserset, 0)\n\t\t\tresponse[typeName][relationName] = t.tupleToUsersetsDefinitions(relationDef, &ttus)\n\t\t}\n\t}\n\n\treturn response\n}\n\n// IsTuplesetRelation returns a boolean indicating if the provided relation is defined under a\n// TupleToUserset rewrite as a tupleset relation (i.e. the right hand side of a `X from Y`).\nfunc (t *TypeSystem) IsTuplesetRelation(objectType, relation string) (bool, error) {\n\n\t_, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, ttuDefinitions := range t.getAllTupleToUsersetsDefinitions()[objectType] {\n\t\tfor _, ttuDef := range ttuDefinitions {\n\t\t\tif ttuDef.Tupleset.Relation == relation {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) tupleToUsersetsDefinitions(relationDef *openfgapb.Userset, resp *[]*openfgapb.TupleToUserset) []*openfgapb.TupleToUserset {\n\tif relationDef.GetTupleToUserset() != nil {\n\t\t*resp = append(*resp, relationDef.GetTupleToUserset())\n\t}\n\tif relationDef.GetUnion() != nil {\n\t\tfor _, child := range relationDef.GetUnion().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetIntersection() != nil {\n\t\tfor _, child := range relationDef.GetIntersection().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetDifference() != nil {\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetBase(), resp)\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetSubtract(), resp)\n\t}\n\treturn *resp\n}\n\n// WalkUsersetRewriteHandler is a userset rewrite handler that is applied to a node in a userset rewrite\n// tree. Implementations of the WalkUsersetRewriteHandler should return a non-nil value when the traversal\n// over the rewrite tree should terminate and nil if traversal should proceed to other nodes in the tree.\ntype WalkUsersetRewriteHandler func(rewrite *openfgapb.Userset) interface{}\n\n// WalkUsersetRewrite recursively walks the provided userset rewrite and invokes the provided WalkUsersetRewriteHandler\n// to each node in the userset rewrite tree until the first non-nil response is encountered.\nfunc WalkUsersetRewrite(rewrite *openfgapb.Userset, handler WalkUsersetRewriteHandler) (interface{}, error) {\n\n\tvar children []*openfgapb.Userset\n\n\tif result := handler(rewrite); result != nil {\n\t\treturn result, nil\n\t}\n\n\tswitch t := rewrite.Userset.(type) {\n\tcase *openfgapb.Userset_This:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgapb.Userset_Union:\n\t\tchildren = t.Union.GetChild()\n\tcase *openfgapb.Userset_Intersection:\n\t\tchildren = t.Intersection.GetChild()\n\tcase *openfgapb.Userset_Difference:\n\t\tchildren = append(children, t.Difference.GetBase(), t.Difference.GetSubtract())\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected userset rewrite type encountered\")\n\t}\n\n\tfor _, child := range children {\n\t\tresult, err := WalkUsersetRewrite(child, handler)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif result != nil {\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n", "package typesystem\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc TestNewAndValidate(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         string\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define action1 as admin and action2 and action3\n\t\t\t    define action2 as admin and action1 and action3\n\t\t\t    define action3 as admin and action1 and action2\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t\tdefine action1 as admin but not action2\n\t\t\t\tdefine action2 as admin but not action3\n\t\t\t\tdefine action3 as admin but not action1\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [document] as self\n\t\t\t    define viewer as editor from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t\tdefine editor as viewer\n\t\t\t    define viewer as editor from parent\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t    define can_view as viewer but not restricted\n\t\t\t    define can_view_actual as can_view\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t})\n\t}\n}\n\nfunc TestSuccessfulRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"empty_relations\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero_length_relations_is_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"intersection_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"exclusion_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor but not editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"empty_rewrites\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_computedUserset\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_to_relation_which_does_not_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_tupleset_is_not_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"notavalidrelation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_computed_userset_is_not_valid\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define reader as notavalidrelation from writer\n\t\t\t\t\tdefine writer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Relation_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"this\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Relation_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"self\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Type_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"this\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Type_Name\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"self\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Auth_Model_1.1_Has_A_Cycle_And_Only_One_Type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t\tdefine viewer as viewer from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrNoEntrypoints,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\t\t})\n\t}\n}\nfunc TestSuccessfulRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_an_objectType_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_a_type_and_type#relation_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"admin\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgapb.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"relational_type_which_does_not_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_type_of_form_type#relation_where_relation_doesn't_exist\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType:               \"group\",\n\t\t\t\t\t\t\t\t\t\t\tRelationOrWildcard: &openfgapb.RelationReference_Relation{Relation: \"admin\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"admin\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_this\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_wit_no_type:_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference base\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference_subtract\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_relation_with_a_type\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: NonAssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\":   This(),\n\t\t\t\t\t\t\t\"can_view\": TupleToUserset(\"parent\", \"member\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"member\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite_included_in_a_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(TupleToUserset(\"parent\", \"viewer\"), This()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"parent\"),\n\t\t},\n\t\t{\n\t\t\tname: \"WildcardNotAllowedInTheTuplesetPartOfTTU\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tWildcardRelationReference(\"folder\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.EqualError(t, err, test.err.Error())\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgapb.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computeduserset_through_ttu_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define manage: [user] as self\n\t\t\t    define editor: [user] as self and manage\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member and allowed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self and allowed\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesIntersection(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesExclusion(t *testing.T) {\n\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgapb.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computed_userset_through_ttu_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define viewer: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define removed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member but not removed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesExclusion(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsTuplesetRelation(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgapb.AuthorizationModel\n\t\tobjectType    string\n\t\trelation      string\n\t\texpected      bool\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"undefined_object_type_returns_error\",\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation_returns_error\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_tupleset_relation\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_exclusion\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Difference(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_union\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tUnion(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_intersection\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tIntersection(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_exclusion\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tDifference(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"not_a_tupleset_relation\",\n\t\t\tmodel: &openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(test.model)\n\n\t\t\tactual, err := typesys.IsTuplesetRelation(test.objectType, test.relation)\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsDirectlyRelated(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tmodel  string\n\t\ttarget *openfgapb.RelationReference\n\t\tsource *openfgapb.RelationReference\n\t\tresult bool\n\t}{\n\t\t{\n\t\t\tname: \"wildcard_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"wildcard_and_direct\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"relation_not_related\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"manager\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_userset\",\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"group\", \"member\"),\n\t\t\tresult: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsDirectlyRelated(test.target, test.source)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.result, ok)\n\t\t})\n\t}\n}\n\nfunc TestIsPubliclyAssignable(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\ttarget     *openfgapb.RelationReference\n\t\tobjectType string\n\t\tresult     bool\n\t}{\n\t\t{\n\t\t\tname: \"1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     true,\n\t\t},\n\t\t{\n\t\t\tname: \"2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"3\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [employee:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsPubliclyAssignable(test.target, test.objectType)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, ok, test.result)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsExclusion(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgapb.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) but not restricted\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsExclusion(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgapb.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) and allowed\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgapb.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsIntersection(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestGetRelationReferenceAsString(t *testing.T) {\n\trequire.Equal(t, \"\", GetRelationReferenceAsString(nil))\n\trequire.Equal(t, \"team#member\", GetRelationReferenceAsString(DirectRelationReference(\"team\", \"member\")))\n\trequire.Equal(t, \"team:*\", GetRelationReferenceAsString(WildcardRelationReference(\"team\")))\n}\n"], "filenames": ["cmd/validatemodels/validate_models.go", "pkg/server/commands/expand.go", "pkg/server/commands/write_authzmodel.go", "pkg/server/server.go", "pkg/server/server_test.go", "pkg/server/test/connected_objects.go", "pkg/server/test/expand.go", "pkg/server/test/list_objects.go", "pkg/server/test/server.go", "pkg/server/test/write_authzmodel.go", "pkg/typesystem/typesystem.go", "pkg/typesystem/typesystem_test.go"], "buggy_code_start_loc": [129, 54, 48, 108, 178, 911, 92, 206, 10, 8, 7, 3], "buggy_code_end_loc": [130, 55, 49, 241, 591, 912, 1135, 383, 23, 137, 813, 1056], "fixing_code_start_loc": [129, 54, 48, 108, 178, 911, 93, 206, 10, 9, 8, 4], "fixing_code_end_loc": [130, 58, 49, 250, 678, 912, 867, 383, 21, 431, 1041, 1233], "type": "CWE-835", "message": "OPenFGA is an open source authorization/permission engine built for developers. OpenFGA versions v1.1.0 and prior are vulnerable to a DoS attack when Check and ListObjects calls are executed against authorization models that contain circular relationship definitions. Users are affected by this vulnerability if they are using OpenFGA v1.1.0 or earlier, and if you are executing `Check` or `ListObjects` calls against a vulnerable authorization model. Users are advised to upgrade to version 1.1.1. There are no known workarounds for this vulnerability. Users that do not have circular relationships in their models are not affected.", "other": {"cve": {"id": "CVE-2023-35933", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-26T20:15:10.580", "lastModified": "2023-07-06T18:13:47.323", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OPenFGA is an open source authorization/permission engine built for developers. OpenFGA versions v1.1.0 and prior are vulnerable to a DoS attack when Check and ListObjects calls are executed against authorization models that contain circular relationship definitions. Users are affected by this vulnerability if they are using OpenFGA v1.1.0 or earlier, and if you are executing `Check` or `ListObjects` calls against a vulnerable authorization model. Users are advised to upgrade to version 1.1.1. There are no known workarounds for this vulnerability. Users that do not have circular relationships in their models are not affected."}, {"lang": "es", "value": "OpenFGA es un motor de autorizaci\u00f3n/permiso de c\u00f3digo abierto creado para desarrolladores. Las versiones v1.1.0 y anteriores de OpenFGA son vulnerables a un ataque DoS cuando se ejecutan llamadas a \"Check\" y \"ListObjects\" contra modelos de autorizaci\u00f3n que contienen definiciones de relaciones circulares. Los usuarios se ven afectados por esta vulnerabilidad si utilizan OpenFGA v1.1.0 o anterior, y si se ejecutan llamadas \"Check\" o \"ListObjects\" contra un modelo de autorizaci\u00f3n vulnerable. Se recomienda a los usuarios que actualicen la versi\u00f3n 1.1.1. No se conocen soluciones para esta vulnerabilidad. Los usuarios que no tengan relaciones circulares en sus modelos no se ver\u00e1n afectados. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "9095E429-49EA-4877-9CE1-F014340AEA2F"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/087ce392595f3c319ab3028b5089118ea4063452", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-hr9r-8phq-5x8j", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://openfga.dev/api/service#/Relationship%20Queries/Check", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://openfga.dev/api/service#/Relationship%20Queries/ListObjects", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/087ce392595f3c319ab3028b5089118ea4063452"}}