{"buggy_code": ["/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.hardware.callbacks;\n\nimport static org.eclipse.jetty.http.HttpMethod.GET;\n\nimport java.io.StringReader;\n\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.openhab.binding.avmfritz.internal.dto.DeviceListModel;\nimport org.openhab.binding.avmfritz.internal.handler.AVMFritzBaseBridgeHandler;\nimport org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface;\nimport org.openhab.binding.avmfritz.internal.util.JAXBUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Callback implementation for updating multiple numbers decoded from a xml\n * response. Supports reauthorization.\n *\n * @author Robert Bausdorf - Initial contribution\n * @author Christoph Weitkamp - Added support for groups\n */\n@NonNullByDefault\npublic class FritzAhaUpdateCallback extends FritzAhaReauthCallback {\n\n    private final Logger logger = LoggerFactory.getLogger(FritzAhaUpdateCallback.class);\n\n    private static final String WEBSERVICE_COMMAND = \"switchcmd=getdevicelistinfos\";\n\n    private final AVMFritzBaseBridgeHandler handler;\n\n    /**\n     * Constructor\n     *\n     * @param webIface Webinterface to FRITZ!Box\n     * @param handler Bridge handler that will update things.\n     */\n    public FritzAhaUpdateCallback(FritzAhaWebInterface webIface, AVMFritzBaseBridgeHandler handler) {\n        super(WEBSERVICE_PATH, WEBSERVICE_COMMAND, webIface, GET, 1);\n        this.handler = handler;\n    }\n\n    @Override\n    public void execute(int status, String response) {\n        super.execute(status, response);\n        logger.trace(\"Received State response {}\", response);\n        if (isValidRequest()) {\n            try {\n                Unmarshaller unmarshaller = JAXBUtils.JAXBCONTEXT_DEVICES.createUnmarshaller();\n                DeviceListModel model = (DeviceListModel) unmarshaller.unmarshal(new StringReader(response));\n                if (model != null) {\n                    handler.onDeviceListAdded(model.getDevicelist());\n                } else {\n                    logger.debug(\"no model in response\");\n                }\n                handler.setStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n            } catch (JAXBException e) {\n                logger.error(\"Exception creating Unmarshaller: {}\", e.getLocalizedMessage(), e);\n                handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n                        e.getLocalizedMessage());\n            }\n        } else {\n            logger.debug(\"request is invalid: {}\", status);\n            handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Request is invalid\");\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.hardware.callbacks;\n\nimport static org.eclipse.jetty.http.HttpMethod.GET;\n\nimport java.io.StringReader;\n\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.openhab.binding.avmfritz.internal.dto.templates.TemplateListModel;\nimport org.openhab.binding.avmfritz.internal.handler.AVMFritzBaseBridgeHandler;\nimport org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface;\nimport org.openhab.binding.avmfritz.internal.util.JAXBUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Callback implementation for updating templates from a xml response.\n *\n * @author Christoph Weitkamp - Initial contribution\n */\n@NonNullByDefault\npublic class FritzAhaUpdateTemplatesCallback extends FritzAhaReauthCallback {\n\n    private final Logger logger = LoggerFactory.getLogger(FritzAhaUpdateTemplatesCallback.class);\n\n    private static final String WEBSERVICE_COMMAND = \"switchcmd=gettemplatelistinfos\";\n\n    private final AVMFritzBaseBridgeHandler handler;\n\n    /**\n     * Constructor\n     *\n     * @param webInterface web interface to FRITZ!Box\n     * @param handler handler that will update things\n     */\n    public FritzAhaUpdateTemplatesCallback(FritzAhaWebInterface webInterface, AVMFritzBaseBridgeHandler handler) {\n        super(WEBSERVICE_PATH, WEBSERVICE_COMMAND, webInterface, GET, 1);\n        this.handler = handler;\n    }\n\n    @Override\n    public void execute(int status, String response) {\n        super.execute(status, response);\n        logger.trace(\"Received response '{}'\", response);\n        if (isValidRequest()) {\n            try {\n                Unmarshaller unmarshaller = JAXBUtils.JAXBCONTEXT_TEMPLATES.createUnmarshaller();\n                TemplateListModel model = (TemplateListModel) unmarshaller.unmarshal(new StringReader(response));\n                if (model != null) {\n                    handler.addTemplateList(model.getTemplates());\n                } else {\n                    logger.debug(\"no template in response\");\n                }\n            } catch (JAXBException e) {\n                logger.error(\"Exception creating Unmarshaller: {}\", e.getLocalizedMessage(), e);\n            }\n        } else {\n            logger.debug(\"request is invalid: {}\", status);\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.util;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.avmfritz.internal.dto.DeviceListModel;\nimport org.openhab.binding.avmfritz.internal.dto.templates.TemplateListModel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation for a static use of JAXBContext as singleton instance.\n *\n * @author Christoph Weitkamp - Initial contribution\n */\n@NonNullByDefault\npublic class JAXBUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(JAXBUtils.class);\n\n    public static final @Nullable JAXBContext JAXBCONTEXT_DEVICES = initJAXBContextDevices();\n    public static final @Nullable JAXBContext JAXBCONTEXT_TEMPLATES = initJAXBContextTemplates();\n\n    private static @Nullable JAXBContext initJAXBContextDevices() {\n        try {\n            return JAXBContext.newInstance(DeviceListModel.class);\n        } catch (JAXBException e) {\n            LOGGER.error(\"Exception creating JAXBContext for devices: {}\", e.getLocalizedMessage(), e);\n            return null;\n        }\n    }\n\n    private static @Nullable JAXBContext initJAXBContextTemplates() {\n        try {\n            return JAXBContext.newInstance(TemplateListModel.class);\n        } catch (JAXBException e) {\n            LOGGER.error(\"Exception creating JAXBContext for templates: {}\", e.getLocalizedMessage(), e);\n            return null;\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.bosesoundtouch.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.openhab.binding.bosesoundtouch.internal.handler.BoseSoundTouchHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link XMLResponseProcessor} class handles the XML mapping\n *\n * @author Christian Niessner - Initial contribution\n * @author Thomas Traunbauer - Initial contribution\n */\npublic class XMLResponseProcessor {\n    private BoseSoundTouchHandler handler;\n\n    private Map<XMLHandlerState, Map<String, XMLHandlerState>> stateSwitchingMap;\n\n    public XMLResponseProcessor(BoseSoundTouchHandler handler) {\n        this.handler = handler;\n        init();\n    }\n\n    public void handleMessage(String msg) throws SAXException, IOException {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(new XMLResponseHandler(handler, stateSwitchingMap));\n        reader.parse(new InputSource(new StringReader(msg)));\n    }\n\n    // initializes our XML parsing state machine\n    private void init() {\n        stateSwitchingMap = new HashMap<>();\n\n        Map<String, XMLHandlerState> msgInitMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.INIT, msgInitMap);\n        msgInitMap.put(\"msg\", XMLHandlerState.Msg);\n        msgInitMap.put(\"SoundTouchSdkInfo\", XMLHandlerState.Unprocessed);\n        msgInitMap.put(\"userActivityUpdate\", XMLHandlerState.Unprocessed); // ignored..\n\n        Map<String, XMLHandlerState> msgBodyMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.MsgBody, msgBodyMap);\n        msgBodyMap.put(\"info\", XMLHandlerState.Info);\n        msgBodyMap.put(\"volume\", XMLHandlerState.Volume);\n        msgBodyMap.put(\"presets\", XMLHandlerState.Presets);\n        msgBodyMap.put(\"key\", XMLHandlerState.Unprocessed); // only confirmation of our key presses...\n        msgBodyMap.put(\"status\", XMLHandlerState.Unprocessed); // only confirmation of commands sent to device...\n        msgBodyMap.put(\"zone\", XMLHandlerState.Zone); // only confirmation of our key presses...\n        msgBodyMap.put(\"bass\", XMLHandlerState.Bass);\n        msgBodyMap.put(\"sources\", XMLHandlerState.Sources);\n        msgBodyMap.put(\"bassCapabilities\", XMLHandlerState.BassCapabilities);\n        msgBodyMap.put(\"group\", XMLHandlerState.Group);\n\n        // info message states\n        Map<String, XMLHandlerState> infoMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Info, infoMap);\n        infoMap.put(\"components\", XMLHandlerState.Info);\n        infoMap.put(\"component\", XMLHandlerState.Info);\n        infoMap.put(\"name\", XMLHandlerState.InfoName);\n        infoMap.put(\"type\", XMLHandlerState.InfoType);\n        infoMap.put(\"componentCategory\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"softwareVersion\", XMLHandlerState.InfoFirmwareVersion);\n        infoMap.put(\"serialNumber\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"networkInfo\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"margeAccountUUID\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"margeURL\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"moduleType\", XMLHandlerState.InfoModuleType);\n        infoMap.put(\"variant\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"variantMode\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"countryCode\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"regionCode\", XMLHandlerState.Unprocessed);\n\n        Map<String, XMLHandlerState> updatesMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Updates, updatesMap);\n        updatesMap.put(\"clockDisplayUpdated\", XMLHandlerState.Unprocessed); // can we get anything useful of that?\n        updatesMap.put(\"connectionStateUpdated\", XMLHandlerState.UnprocessedNoTextExpected);\n        updatesMap.put(\"infoUpdated\", XMLHandlerState.Unprocessed);\n        updatesMap.put(\"nowPlayingUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"nowSelectionUpdated\", XMLHandlerState.Unprocessed); // TODO this seems to be quite a useful info\n                                                                            // what is currently played..\n        updatesMap.put(\"recentsUpdated\", XMLHandlerState.Unprocessed);\n        updatesMap.put(\"volumeUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"zoneUpdated\", XMLHandlerState.ZoneUpdated); // just notifies but dosn't provide details\n        updatesMap.put(\"bassUpdated\", XMLHandlerState.BassUpdated);\n        updatesMap.put(\"presetsUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"groupUpdated\", XMLHandlerState.MsgBody);\n\n        Map<String, XMLHandlerState> volume = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Volume, volume);\n        volume.put(\"targetvolume\", XMLHandlerState.VolumeTarget);\n        volume.put(\"actualvolume\", XMLHandlerState.VolumeActual);\n        volume.put(\"muteenabled\", XMLHandlerState.VolumeMuteEnabled);\n\n        Map<String, XMLHandlerState> nowPlayingMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.NowPlaying, nowPlayingMap);\n        nowPlayingMap.put(\"album\", XMLHandlerState.NowPlayingAlbum);\n        nowPlayingMap.put(\"art\", XMLHandlerState.NowPlayingArt);\n        nowPlayingMap.put(\"artist\", XMLHandlerState.NowPlayingArtist);\n        nowPlayingMap.put(\"ContentItem\", XMLHandlerState.ContentItem);\n        nowPlayingMap.put(\"description\", XMLHandlerState.NowPlayingDescription);\n        nowPlayingMap.put(\"playStatus\", XMLHandlerState.NowPlayingPlayStatus);\n        nowPlayingMap.put(\"rateEnabled\", XMLHandlerState.NowPlayingRateEnabled);\n        nowPlayingMap.put(\"skipEnabled\", XMLHandlerState.NowPlayingSkipEnabled);\n        nowPlayingMap.put(\"skipPreviousEnabled\", XMLHandlerState.NowPlayingSkipPreviousEnabled);\n        nowPlayingMap.put(\"stationLocation\", XMLHandlerState.NowPlayingStationLocation);\n        nowPlayingMap.put(\"stationName\", XMLHandlerState.NowPlayingStationName);\n        nowPlayingMap.put(\"track\", XMLHandlerState.NowPlayingTrack);\n        nowPlayingMap.put(\"connectionStatusInfo\", XMLHandlerState.Unprocessed); // TODO active when Source==Bluetooth\n        // TODO active when Source==Pandora and maybe also other sources - seems to be rating related\n        nowPlayingMap.put(\"time\", XMLHandlerState.Unprocessed);\n        nowPlayingMap.put(\"rating\", XMLHandlerState.Unprocessed);\n        nowPlayingMap.put(\"rateEnabled\", XMLHandlerState.Unprocessed);\n\n        // ContentItem specifies a resource (that also could be bookmarked in a preset)\n        Map<String, XMLHandlerState> contentItemMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.ContentItem, contentItemMap);\n        contentItemMap.put(\"itemName\", XMLHandlerState.ContentItemItemName);\n        contentItemMap.put(\"containerArt\", XMLHandlerState.ContentItemContainerArt);\n\n        Map<String, XMLHandlerState> presetMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Preset, presetMap);\n        presetMap.put(\"ContentItem\", XMLHandlerState.ContentItem);\n\n        Map<String, XMLHandlerState> zoneMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Zone, zoneMap);\n        zoneMap.put(\"member\", XMLHandlerState.ZoneMember);\n\n        Map<String, XMLHandlerState> bassMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Bass, bassMap);\n        bassMap.put(\"targetbass\", XMLHandlerState.BassTarget);\n        bassMap.put(\"actualbass\", XMLHandlerState.BassActual);\n\n        Map<String, XMLHandlerState> sourceMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Sources, sourceMap);\n\n        Map<String, XMLHandlerState> bassCapabilitiesMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.BassCapabilities, bassCapabilitiesMap);\n        bassCapabilitiesMap.put(\"bassAvailable\", XMLHandlerState.BassAvailable);\n        bassCapabilitiesMap.put(\"bassMin\", XMLHandlerState.BassMin);\n        bassCapabilitiesMap.put(\"bassMax\", XMLHandlerState.BassMax);\n        bassCapabilitiesMap.put(\"bassDefault\", XMLHandlerState.BassDefault);\n\n        Map<String, XMLHandlerState> groupsMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Group, groupsMap);\n        groupsMap.put(\"name\", XMLHandlerState.GroupName);\n        groupsMap.put(\"masterDeviceId\", XMLHandlerState.MasterDeviceId);\n        groupsMap.put(\"roles\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"senderIPAddress\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"status\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"roles\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"groupRole\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"deviceId\", XMLHandlerState.DeviceId);\n        groupsMap.put(\"role\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"ipAddress\", XMLHandlerState.DeviceIp);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.denonmarantz.internal.connector.http;\n\nimport java.beans.Introspector;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Marshaller;\nimport javax.xml.bind.UnmarshalException;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.util.StreamReaderDelegate;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.Response;\nimport org.eclipse.jetty.client.api.Result;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzState;\nimport org.openhab.binding.denonmarantz.internal.config.DenonMarantzConfiguration;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnector;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.Deviceinfo;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.Main;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.ZoneStatus;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.ZoneStatusLite;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.AppCommandRequest;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.AppCommandResponse;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.CommandRx;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.CommandTx;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class makes the connection to the receiver and manages it.\n * It is also responsible for sending commands to the receiver.\n * *\n *\n * @author Jeroen Idserda - Initial Contribution (1.x Binding)\n * @author Jan-Willem Veldhuis - Refactored for 2.x\n */\npublic class DenonMarantzHttpConnector extends DenonMarantzConnector {\n\n    private Logger logger = LoggerFactory.getLogger(DenonMarantzHttpConnector.class);\n\n    private static final int REQUEST_TIMEOUT_MS = 5000; // 5 seconds\n\n    // Main URL for the receiver\n    private static final String URL_MAIN = \"formMainZone_MainZoneXml.xml\";\n\n    // Main Zone Status URL\n    private static final String URL_ZONE_MAIN = \"formMainZone_MainZoneXmlStatus.xml\";\n\n    // Secondary zone lite status URL (contains less info)\n    private static final String URL_ZONE_SECONDARY_LITE = \"formZone%d_Zone%dXmlStatusLite.xml\";\n\n    // Device info URL\n    private static final String URL_DEVICE_INFO = \"Deviceinfo.xml\";\n\n    // URL to send app commands to\n    private static final String URL_APP_COMMAND = \"AppCommand.xml\";\n\n    private static final String CONTENT_TYPE_XML = \"application/xml\";\n\n    private final String cmdUrl;\n\n    private final String statusUrl;\n\n    private final HttpClient httpClient;\n\n    private ScheduledFuture<?> pollingJob;\n\n    public DenonMarantzHttpConnector(DenonMarantzConfiguration config, DenonMarantzState state,\n            ScheduledExecutorService scheduler, HttpClient httpClient) {\n        this.config = config;\n        this.scheduler = scheduler;\n        this.state = state;\n        this.cmdUrl = String.format(\"http://%s:%d/goform/formiPhoneAppDirect.xml?\", config.getHost(),\n                config.getHttpPort());\n        this.statusUrl = String.format(\"http://%s:%d/goform/\", config.getHost(), config.getHttpPort());\n        this.httpClient = httpClient;\n    }\n\n    public DenonMarantzState getState() {\n        return state;\n    }\n\n    /**\n     * Set up the connection to the receiver by starting to poll the HTTP API.\n     */\n    @Override\n    public void connect() {\n        if (!isPolling()) {\n            logger.debug(\"HTTP polling started.\");\n            try {\n                setConfigProperties();\n            } catch (IOException e) {\n                logger.debug(\"IO error while retrieving document:\", e);\n                state.connectionError(\"IO error while connecting to AVR: \" + e.getMessage());\n                return;\n            }\n\n            pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n                try {\n                    refreshHttpProperties();\n                } catch (IOException e) {\n                    logger.debug(\"IO error while retrieving document\", e);\n                    state.connectionError(\"IO error while connecting to AVR: \" + e.getMessage());\n                    stopPolling();\n                } catch (RuntimeException e) {\n                    /**\n                     * We need to catch this RuntimeException, as otherwise the polling stops.\n                     * Log as error as it could be a user configuration error.\n                     */\n                    StringBuilder sb = new StringBuilder();\n                    for (StackTraceElement s : e.getStackTrace()) {\n                        sb.append(s.toString()).append(\"\\n\");\n                    }\n                    logger.error(\"Error while polling Http: \\\"{}\\\". Stacktrace: \\n{}\", e.getMessage(), sb.toString());\n                }\n            }, 0, config.httpPollingInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isPolling() {\n        return pollingJob != null && !pollingJob.isCancelled();\n    }\n\n    private void stopPolling() {\n        if (isPolling()) {\n            pollingJob.cancel(true);\n            logger.debug(\"HTTP polling stopped.\");\n        }\n    }\n\n    /**\n     * Shutdown the http client\n     */\n    @Override\n    public void dispose() {\n        logger.debug(\"disposing connector\");\n\n        stopPolling();\n    }\n\n    @Override\n    protected void internalSendCommand(String command) {\n        logger.debug(\"Sending command '{}'\", command);\n        if (StringUtils.isBlank(command)) {\n            logger.warn(\"Trying to send empty command\");\n            return;\n        }\n\n        try {\n            String url = cmdUrl + URLEncoder.encode(command, Charset.defaultCharset().displayName());\n            logger.trace(\"Calling url {}\", url);\n\n            httpClient.newRequest(url).timeout(5, TimeUnit.SECONDS).send(new Response.CompleteListener() {\n                @Override\n                public void onComplete(Result result) {\n                    if (result.getResponse().getStatus() != 200) {\n                        logger.warn(\"Error {} while sending command\", result.getResponse().getReason());\n                    }\n                }\n            });\n\n        } catch (UnsupportedEncodingException e) {\n            logger.warn(\"Error sending command\", e);\n        }\n    }\n\n    private void updateMain() throws IOException {\n        String url = statusUrl + URL_MAIN;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        Main statusMain = getDocument(url, Main.class);\n        if (statusMain != null) {\n            state.setPower(statusMain.getPower().getValue());\n        }\n    }\n\n    private void updateMainZone() throws IOException {\n        String url = statusUrl + URL_ZONE_MAIN;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        ZoneStatus mainZone = getDocument(url, ZoneStatus.class);\n        if (mainZone != null) {\n            state.setInput(mainZone.getInputFuncSelect().getValue());\n            state.setMainVolume(mainZone.getMasterVolume().getValue());\n            state.setMainZonePower(mainZone.getPower().getValue());\n            state.setMute(mainZone.getMute().getValue());\n\n            if (config.inputOptions == null) {\n                config.inputOptions = mainZone.getInputFuncList();\n            }\n\n            if (mainZone.getSurrMode() == null) {\n                logger.debug(\"Unable to get the SURROUND_MODE. MainZone update may not be correct.\");\n            } else {\n                state.setSurroundProgram(mainZone.getSurrMode().getValue());\n            }\n        }\n    }\n\n    private void updateSecondaryZones() throws IOException {\n        for (int i = 2; i <= config.getZoneCount(); i++) {\n            String url = String.format(\"%s\" + URL_ZONE_SECONDARY_LITE, statusUrl, i, i);\n            logger.trace(\"Refreshing URL: {}\", url);\n            ZoneStatusLite zoneSecondary = getDocument(url, ZoneStatusLite.class);\n            if (zoneSecondary != null) {\n                switch (i) {\n                    // maximum 2 secondary zones are supported\n                    case 2:\n                        state.setZone2Power(zoneSecondary.getPower().getValue());\n                        state.setZone2Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone2Mute(zoneSecondary.getMute().getValue());\n                        state.setZone2Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                    case 3:\n                        state.setZone3Power(zoneSecondary.getPower().getValue());\n                        state.setZone3Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone3Mute(zoneSecondary.getMute().getValue());\n                        state.setZone3Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                    case 4:\n                        state.setZone4Power(zoneSecondary.getPower().getValue());\n                        state.setZone4Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone4Mute(zoneSecondary.getMute().getValue());\n                        state.setZone4Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                }\n            }\n        }\n    }\n\n    private void updateDisplayInfo() throws IOException {\n        String url = statusUrl + URL_APP_COMMAND;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        AppCommandRequest request = AppCommandRequest.of(CommandTx.CMD_NET_STATUS);\n        AppCommandResponse response = postDocument(url, AppCommandResponse.class, request);\n\n        if (response != null) {\n            CommandRx titleInfo = response.getCommands().get(0);\n            state.setNowPlayingArtist(titleInfo.getText(\"artist\"));\n            state.setNowPlayingAlbum(titleInfo.getText(\"album\"));\n            state.setNowPlayingTrack(titleInfo.getText(\"track\"));\n        }\n    }\n\n    private boolean setConfigProperties() throws IOException {\n        String url = statusUrl + URL_DEVICE_INFO;\n        logger.debug(\"Refreshing URL: {}\", url);\n\n        Deviceinfo deviceinfo = getDocument(url, Deviceinfo.class);\n        if (deviceinfo != null) {\n            config.setZoneCount(deviceinfo.getDeviceZones());\n        }\n\n        /**\n         * The maximum volume is received from the telnet connection in the\n         * form of the MVMAX property. It is not always received reliable however,\n         * so we're using a default for now.\n         */\n        config.setMainVolumeMax(DenonMarantzConfiguration.MAX_VOLUME);\n\n        // if deviceinfo is null, something went wrong (and is logged in getDocument catch blocks)\n        return (deviceinfo != null);\n    }\n\n    private void refreshHttpProperties() throws IOException {\n        logger.trace(\"Refreshing Denon status\");\n\n        updateMain();\n        updateMainZone();\n        updateSecondaryZones();\n        updateDisplayInfo();\n    }\n\n    @Nullable\n    private <T> T getDocument(String uri, Class<T> response) throws IOException {\n        try {\n            String result = HttpUtil.executeUrl(\"GET\", uri, REQUEST_TIMEOUT_MS);\n            logger.trace(\"result of getDocument for uri '{}':\\r\\n{}\", uri, result);\n\n            if (StringUtils.isNotBlank(result)) {\n                JAXBContext jc = JAXBContext.newInstance(response);\n                XMLInputFactory xif = XMLInputFactory.newInstance();\n                XMLStreamReader xsr = xif.createXMLStreamReader(IOUtils.toInputStream(result));\n                xsr = new PropertyRenamerDelegate(xsr);\n\n                @SuppressWarnings(\"unchecked\")\n                T obj = (T) jc.createUnmarshaller().unmarshal(xsr);\n\n                return obj;\n            }\n        } catch (UnmarshalException e) {\n            logger.debug(\"Failed to unmarshal xml document: {}\", e.getMessage());\n        } catch (JAXBException e) {\n            logger.debug(\"Unexpected error occurred during unmarshalling of document: {}\", e.getMessage());\n        } catch (XMLStreamException e) {\n            logger.debug(\"Communication error: {}\", e.getMessage());\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private <T, S> T postDocument(String uri, Class<T> response, S request) throws IOException {\n        try {\n            JAXBContext jaxbContext = JAXBContext.newInstance(request.getClass());\n            Marshaller jaxbMarshaller = jaxbContext.createMarshaller();\n            StringWriter sw = new StringWriter();\n            jaxbMarshaller.marshal(request, sw);\n\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(sw.toString().getBytes(StandardCharsets.UTF_8));\n            String result = HttpUtil.executeUrl(\"POST\", uri, inputStream, CONTENT_TYPE_XML, REQUEST_TIMEOUT_MS);\n\n            if (StringUtils.isNotBlank(result)) {\n                JAXBContext jcResponse = JAXBContext.newInstance(response);\n\n                @SuppressWarnings(\"unchecked\")\n                T obj = (T) jcResponse.createUnmarshaller().unmarshal(IOUtils.toInputStream(result));\n\n                return obj;\n            }\n        } catch (JAXBException e) {\n            logger.debug(\"Encoding error in post\", e);\n        }\n\n        return null;\n    }\n\n    private static class PropertyRenamerDelegate extends StreamReaderDelegate {\n\n        public PropertyRenamerDelegate(XMLStreamReader xsr) {\n            super(xsr);\n        }\n\n        @Override\n        public String getAttributeLocalName(int index) {\n            return Introspector.decapitalize(super.getAttributeLocalName(index));\n        }\n\n        @Override\n        public String getLocalName() {\n            return Introspector.decapitalize(super.getLocalName());\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.denonmarantz.internal.handler;\n\nimport static org.openhab.binding.denonmarantz.internal.DenonMarantzBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.HttpURLConnection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.thing.Channel;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\nimport org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\nimport org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzState;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzStateChangedListener;\nimport org.openhab.binding.denonmarantz.internal.UnsupportedCommandTypeException;\nimport org.openhab.binding.denonmarantz.internal.config.DenonMarantzConfiguration;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnector;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnectorFactory;\nimport org.openhab.binding.denonmarantz.internal.connector.http.DenonMarantzHttpConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link DenonMarantzHandler} is responsible for handling commands, which are\n * sent to one of the channels.\n *\n * @author Jan-Willem Veldhuis - Initial contribution\n */\npublic class DenonMarantzHandler extends BaseThingHandler implements DenonMarantzStateChangedListener {\n\n    private final Logger logger = LoggerFactory.getLogger(DenonMarantzHandler.class);\n    private static final int RETRY_TIME_SECONDS = 30;\n    private HttpClient httpClient;\n    private DenonMarantzConnector connector;\n    private DenonMarantzConfiguration config;\n    private DenonMarantzConnectorFactory connectorFactory = new DenonMarantzConnectorFactory();\n    private DenonMarantzState denonMarantzState;\n    private ScheduledFuture<?> retryJob;\n\n    public DenonMarantzHandler(Thing thing, HttpClient httpClient) {\n        super(thing);\n        this.httpClient = httpClient;\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        if (connector == null) {\n            return;\n        }\n\n        if (connector instanceof DenonMarantzHttpConnector && command instanceof RefreshType) {\n            // Refreshing individual channels isn't supported by the Http connector.\n            // The connector refreshes all channels together at the configured polling interval.\n            return;\n        }\n\n        try {\n            switch (channelUID.getId()) {\n                case CHANNEL_POWER:\n                    connector.sendPowerCommand(command, 0);\n                    break;\n                case CHANNEL_MAIN_ZONE_POWER:\n                    connector.sendPowerCommand(command, 1);\n                    break;\n                case CHANNEL_MUTE:\n                    connector.sendMuteCommand(command, 1);\n                    break;\n                case CHANNEL_MAIN_VOLUME:\n                    connector.sendVolumeCommand(command, 1);\n                    break;\n                case CHANNEL_MAIN_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 1);\n                    break;\n                case CHANNEL_INPUT:\n                    connector.sendInputCommand(command, 1);\n                    break;\n                case CHANNEL_SURROUND_PROGRAM:\n                    connector.sendSurroundProgramCommand(command);\n                    break;\n                case CHANNEL_COMMAND:\n                    connector.sendCustomCommand(command);\n                    break;\n\n                case CHANNEL_ZONE2_POWER:\n                    connector.sendPowerCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_MUTE:\n                    connector.sendMuteCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_VOLUME:\n                    connector.sendVolumeCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_INPUT:\n                    connector.sendInputCommand(command, 2);\n                    break;\n\n                case CHANNEL_ZONE3_POWER:\n                    connector.sendPowerCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_MUTE:\n                    connector.sendMuteCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_VOLUME:\n                    connector.sendVolumeCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_INPUT:\n                    connector.sendInputCommand(command, 3);\n                    break;\n\n                case CHANNEL_ZONE4_POWER:\n                    connector.sendPowerCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_MUTE:\n                    connector.sendMuteCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_VOLUME:\n                    connector.sendVolumeCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_INPUT:\n                    connector.sendInputCommand(command, 4);\n                    break;\n\n                default:\n                    throw new UnsupportedCommandTypeException();\n            }\n        } catch (UnsupportedCommandTypeException e) {\n            logger.debug(\"Unsupported command {} for channel {}\", command, channelUID.getId());\n        }\n    }\n\n    public boolean checkConfiguration() {\n        // prevent too low values for polling interval\n        if (config.httpPollingInterval < 5) {\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                    \"The polling interval should be at least 5 seconds!\");\n            return false;\n        }\n        // Check zone count is within supported range\n        if (config.getZoneCount() < 1 || config.getZoneCount() > 4) {\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                    \"This binding supports 1 to 4 zones. Please update the zone count.\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Try to auto configure the connection type (Telnet or HTTP)\n     * for Things not added through Paper UI.\n     */\n    private void autoConfigure() {\n        /*\n         * The isTelnet parameter has no default.\n         * When not set we will try to auto-detect the correct values\n         * for isTelnet and zoneCount and update the Thing accordingly.\n         */\n        if (config.isTelnet() == null) {\n            logger.debug(\"Trying to auto-detect the connection.\");\n            ContentResponse response;\n            boolean telnetEnable = true;\n            int httpPort = 80;\n            boolean httpApiUsable = false;\n\n            // try to reach the HTTP API at port 80 (most models, except Denon ...H should respond.\n            String host = config.getHost();\n            try {\n                response = httpClient.newRequest(\"http://\" + host + \"/goform/Deviceinfo.xml\")\n                        .timeout(3, TimeUnit.SECONDS).send();\n                if (response.getStatus() == HttpURLConnection.HTTP_OK) {\n                    logger.debug(\"We can access the HTTP API, disabling the Telnet mode by default.\");\n                    telnetEnable = false;\n                    httpApiUsable = true;\n                }\n            } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                logger.debug(\"Error when trying to access AVR using HTTP on port 80, reverting to Telnet mode.\", e);\n            }\n\n            if (telnetEnable) {\n                // the above attempt failed. Let's try on port 8080, as for some models a subset of the HTTP API is\n                // available\n                try {\n                    response = httpClient.newRequest(\"http://\" + host + \":8080/goform/Deviceinfo.xml\")\n                            .timeout(3, TimeUnit.SECONDS).send();\n                    if (response.getStatus() == HttpURLConnection.HTTP_OK) {\n                        logger.debug(\n                                \"This model responds to HTTP port 8080, we use this port to retrieve the number of zones.\");\n                        httpPort = 8080;\n                        httpApiUsable = true;\n                    }\n                } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                    logger.debug(\"Additionally tried to connect to port 8080, this also failed\", e);\n                }\n            }\n\n            // default zone count\n            int zoneCount = 2;\n\n            // try to determine the zone count by checking the Deviceinfo.xml file\n            if (httpApiUsable) {\n                int status = 0;\n                response = null;\n                try {\n                    response = httpClient.newRequest(\"http://\" + host + \":\" + httpPort + \"/goform/Deviceinfo.xml\")\n                            .timeout(3, TimeUnit.SECONDS).send();\n                    status = response.getStatus();\n                } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                    logger.debug(\"Failed in fetching the Deviceinfo.xml to determine zone count\", e);\n                }\n\n                if (status == HttpURLConnection.HTTP_OK && response != null) {\n                    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n                    DocumentBuilder builder;\n                    try {\n                        builder = domFactory.newDocumentBuilder();\n                        Document dDoc = builder.parse(new InputSource(new StringReader(response.getContentAsString())));\n                        XPath xPath = XPathFactory.newInstance().newXPath();\n                        Node node = (Node) xPath.evaluate(\"/Device_Info/DeviceZones/text()\", dDoc, XPathConstants.NODE);\n                        if (node != null) {\n                            String nodeValue = node.getNodeValue();\n                            logger.trace(\"/Device_Info/DeviceZones/text() = {}\", nodeValue);\n                            zoneCount = Integer.parseInt(nodeValue);\n                            logger.debug(\"Discovered number of zones: {}\", zoneCount);\n                        }\n                    } catch (ParserConfigurationException | SAXException | IOException | XPathExpressionException\n                            | NumberFormatException e) {\n                        logger.debug(\"Something went wrong with looking up the zone count in Deviceinfo.xml: {}\",\n                                e.getMessage());\n                    }\n                }\n            }\n            config.setTelnet(telnetEnable);\n            config.setZoneCount(zoneCount);\n            Configuration configuration = editConfiguration();\n            configuration.put(PARAMETER_TELNET_ENABLED, telnetEnable);\n            configuration.put(PARAMETER_ZONE_COUNT, zoneCount);\n            updateConfiguration(configuration);\n        }\n    }\n\n    @Override\n    public void initialize() {\n        cancelRetry();\n        config = getConfigAs(DenonMarantzConfiguration.class);\n\n        // Configure Connection type (Telnet/HTTP) and number of zones\n        // Note: this only happens for discovered Things\n        autoConfigure();\n\n        if (!checkConfiguration()) {\n            return;\n        }\n\n        denonMarantzState = new DenonMarantzState(this);\n        configureZoneChannels();\n        updateStatus(ThingStatus.UNKNOWN);\n        // create connection (either Telnet or HTTP)\n        // ThingStatus ONLINE/OFFLINE is set when AVR status is known.\n        createConnection();\n    }\n\n    private void createConnection() {\n        if (connector != null) {\n            connector.dispose();\n        }\n        connector = connectorFactory.getConnector(config, denonMarantzState, scheduler, httpClient);\n        connector.connect();\n    }\n\n    private void cancelRetry() {\n        ScheduledFuture<?> localRetryJob = retryJob;\n        if (localRetryJob != null && !localRetryJob.isDone()) {\n            localRetryJob.cancel(false);\n        }\n    }\n\n    private void configureZoneChannels() {\n        logger.debug(\"Configuring zone channels\");\n        Integer zoneCount = config.getZoneCount();\n        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n        boolean channelsUpdated = false;\n\n        // construct a set with the existing channel type UIDs, to quickly check\n        Set<String> currentChannels = new HashSet<>();\n        channels.forEach(channel -> currentChannels.add(channel.getUID().getId()));\n\n        Set<Entry<String, ChannelTypeUID>> channelsToRemove = new HashSet<>();\n\n        if (zoneCount > 1) {\n            List<Entry<String, ChannelTypeUID>> channelsToAdd = new ArrayList<>(ZONE2_CHANNEL_TYPES.entrySet());\n\n            if (zoneCount > 2) {\n                // add channels for zone 3\n                channelsToAdd.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n                if (zoneCount > 3) {\n                    // add channels for zone 4 (more zones currently not supported)\n                    channelsToAdd.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n                } else {\n                    channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n                }\n            } else {\n                channelsToRemove.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n                channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n            }\n\n            // filter out the already existing channels\n            channelsToAdd.removeIf(c -> currentChannels.contains(c.getKey()));\n\n            // add the channels that were not yet added\n            if (!channelsToAdd.isEmpty()) {\n                for (Entry<String, ChannelTypeUID> entry : channelsToAdd) {\n                    String itemType = CHANNEL_ITEM_TYPES.get(entry.getKey());\n                    Channel channel = ChannelBuilder\n                            .create(new ChannelUID(this.getThing().getUID(), entry.getKey()), itemType)\n                            .withType(entry.getValue()).build();\n                    channels.add(channel);\n                }\n                channelsUpdated = true;\n            } else {\n                logger.debug(\"No zone channels have been added\");\n            }\n        } else {\n            channelsToRemove.addAll(ZONE2_CHANNEL_TYPES.entrySet());\n            channelsToRemove.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n            channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n        }\n\n        // filter out the non-existing channels\n        channelsToRemove.removeIf(c -> !currentChannels.contains(c.getKey()));\n\n        // remove the channels that were not yet added\n        if (!channelsToRemove.isEmpty()) {\n            for (Entry<String, ChannelTypeUID> entry : channelsToRemove) {\n                if (channels.removeIf(c -> (entry.getKey()).equals(c.getUID().getId()))) {\n                    logger.trace(\"Removed channel {}\", entry.getKey());\n                } else {\n                    logger.trace(\"Could NOT remove channel {}\", entry.getKey());\n                }\n            }\n            channelsUpdated = true;\n        } else {\n            logger.debug(\"No zone channels have been removed\");\n        }\n\n        // update Thing if channels changed\n        if (channelsUpdated) {\n            updateThing(editThing().withChannels(channels).build());\n        }\n    }\n\n    @Override\n    public void dispose() {\n        if (connector != null) {\n            connector.dispose();\n            connector = null;\n        }\n        cancelRetry();\n        super.dispose();\n    }\n\n    @Override\n    public void channelLinked(ChannelUID channelUID) {\n        super.channelLinked(channelUID);\n        String channelID = channelUID.getId();\n        if (isLinked(channelID)) {\n            State state = denonMarantzState.getStateForChannelID(channelID);\n            if (state != null) {\n                updateState(channelID, state);\n            }\n        }\n    }\n\n    @Override\n    public void stateChanged(String channelID, State state) {\n        logger.debug(\"Received state {} for channelID {}\", state, channelID);\n\n        // Don't flood the log with thing 'updated: ONLINE' each time a single channel changed\n        if (this.getThing().getStatus() != ThingStatus.ONLINE) {\n            updateStatus(ThingStatus.ONLINE);\n        }\n        updateState(channelID, state);\n    }\n\n    @Override\n    public void connectionError(String errorMessage) {\n        if (this.getThing().getStatus() != ThingStatus.OFFLINE) {\n            // Don't flood the log with thing 'updated: OFFLINE' when already offline\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n        }\n        connector.dispose();\n        retryJob = scheduler.schedule(this::createConnection, RETRY_TIME_SECONDS, TimeUnit.SECONDS);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.dlinksmarthome.internal;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Iterator;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.soap.MessageFactory;\nimport javax.xml.soap.MimeHeader;\nimport javax.xml.soap.MimeHeaders;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.client.api.Request;\nimport org.eclipse.jetty.client.util.BytesContentProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link DLinkHNAPCommunication} is responsible for communicating with D-Link\n * Smart Home devices using the HNAP interface.\n *\n * This abstract class handles login and authentication which is common between devices.\n *\n * Reverse engineered from Login.html and soapclient.js retrieved from the device.\n *\n * @author Mike Major - Initial contribution\n */\npublic abstract class DLinkHNAPCommunication {\n\n    // SOAP actions\n    private static final String LOGIN_ACTION = \"\\\"http://purenetworks.com/HNAP1/LOGIN\\\"\";\n\n    // Strings used more than once\n    private static final String LOGIN = \"LOGIN\";\n    private static final String ACTION = \"Action\";\n    private static final String USERNAME = \"Username\";\n    private static final String LOGINPASSWORD = \"LoginPassword\";\n    private static final String CAPTCHA = \"Captcha\";\n    private static final String ADMIN = \"Admin\";\n    private static final String LOGINRESULT = \"LOGINResult\";\n    private static final String COOKIE = \"Cookie\";\n\n    /**\n     * HNAP XMLNS\n     */\n    protected static final String HNAP_XMLNS = \"http://purenetworks.com/HNAP1\";\n    /**\n     * The SOAP action HTML header\n     */\n    protected static final String SOAPACTION = \"SOAPAction\";\n    /**\n     * OK represents a successful action\n     */\n    protected static final String OK = \"OK\";\n\n    /**\n     * Use to log connection issues\n     */\n    private final Logger logger = LoggerFactory.getLogger(DLinkHNAPCommunication.class);\n\n    private URI uri;\n    private final HttpClient httpClient;\n    private final String pin;\n    private String privateKey;\n\n    private DocumentBuilder parser;\n    private SOAPMessage requestAction;\n    private SOAPMessage loginAction;\n\n    private HNAPStatus status = HNAPStatus.INITIALISED;\n\n    /**\n     * Indicates the status of the HNAP interface\n     *\n     */\n    protected enum HNAPStatus {\n        /**\n         * Ready to start communication with device\n         */\n        INITIALISED,\n        /**\n         * Successfully logged in to device\n         */\n        LOGGED_IN,\n        /**\n         * Problem communicating with device\n         */\n        COMMUNICATION_ERROR,\n        /**\n         * Internal error\n         */\n        INTERNAL_ERROR,\n        /**\n         * Error due to unsupported firmware\n         */\n        UNSUPPORTED_FIRMWARE,\n        /**\n         * Error due to invalid pin code\n         */\n        INVALID_PIN\n    }\n\n    /**\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after construction.\n     *\n     * @param ipAddress\n     * @param pin\n     */\n    public DLinkHNAPCommunication(final String ipAddress, final String pin) {\n        this.pin = pin;\n\n        httpClient = new HttpClient();\n\n        try {\n            uri = new URI(\"http://\" + ipAddress + \"/HNAP1\");\n            httpClient.start();\n\n            parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\n            final MessageFactory messageFactory = MessageFactory.newInstance();\n            requestAction = messageFactory.createMessage();\n            loginAction = messageFactory.createMessage();\n\n            buildRequestAction();\n            buildLoginAction();\n        } catch (final SOAPException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final URISyntaxException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final ParserConfigurationException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final Exception e) {\n            // Thrown by httpClient.start()\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        }\n    }\n\n    /**\n     * Stop communicating with the device\n     */\n    public void dispose() {\n        try {\n            httpClient.stop();\n        } catch (final Exception e) {\n            // Ignored\n        }\n    }\n\n    /**\n     * This is the first SOAP message used in the login process and is used to retrieve\n     * the cookie, challenge and public key used for authentication.\n     *\n     * @throws SOAPException\n     */\n    private void buildRequestAction() throws SOAPException {\n        requestAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = requestAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"request\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = requestAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n\n        requestAction.saveChanges();\n    }\n\n    /**\n     * This is the second SOAP message used in the login process and uses a password derived\n     * from the challenge, public key and the device's pin code.\n     *\n     * @throws SOAPException\n     */\n    private void buildLoginAction() throws SOAPException {\n        loginAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = loginAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"login\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = loginAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n    }\n\n    /**\n     * Sets the password for the second login message based on the data received from the\n     * first login message. Also sets the private key used to generate the authentication header.\n     *\n     * @param challenge\n     * @param cookie\n     * @param publicKey\n     * @throws SOAPException\n     * @throws InvalidKeyException\n     * @throws NoSuchAlgorithmException\n     */\n    private void setAuthenticationData(final String challenge, final String cookie, final String publicKey)\n            throws SOAPException, InvalidKeyException, NoSuchAlgorithmException {\n        final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n        loginHeaders.setHeader(COOKIE, \"uid=\" + cookie);\n\n        privateKey = hash(challenge, publicKey + pin);\n\n        final String password = hash(challenge, privateKey);\n\n        loginAction.getSOAPBody().getElementsByTagName(LOGINPASSWORD).item(0).setTextContent(password);\n        loginAction.saveChanges();\n    }\n\n    /**\n     * Used to hash the authentication data such as the login password and the authentication header\n     * for the detection message.\n     *\n     * @param data\n     * @param key\n     * @return The hashed data\n     * @throws NoSuchAlgorithmException\n     * @throws InvalidKeyException\n     */\n    private String hash(final String data, final String key) throws NoSuchAlgorithmException, InvalidKeyException {\n        final Mac mac = Mac.getInstance(\"HMACMD5\");\n        final SecretKeySpec sKey = new SecretKeySpec(key.getBytes(), \"ASCII\");\n\n        mac.init(sKey);\n        final byte[] bytes = mac.doFinal(data.getBytes());\n\n        final StringBuilder hashBuf = new StringBuilder();\n        for (int i = 0; i < bytes.length; i++) {\n            final String hex = Integer.toHexString(0xFF & bytes[i]).toUpperCase();\n            if (hex.length() == 1) {\n                hashBuf.append('0');\n            }\n            hashBuf.append(hex);\n        }\n\n        return hashBuf.toString();\n    }\n\n    /**\n     * Output unexpected responses to the debug log and sets the FIRMWARE error.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    private void unexpectedResult(final String message, final Document soapResponse) {\n        logUnexpectedResult(message, soapResponse);\n\n        // Best guess when receiving unexpected responses\n        status = HNAPStatus.UNSUPPORTED_FIRMWARE;\n    }\n\n    /**\n     * Get the status of the HNAP interface\n     *\n     * @return the HNAP status\n     */\n    protected HNAPStatus getHNAPStatus() {\n        return status;\n    }\n\n    /**\n     * Sends the two login messages and stores the private key used to generate the\n     * authentication header required for actions.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param timeout - Connection timeout in milliseconds\n     */\n    protected void login(final int timeout) {\n        if (status != HNAPStatus.INTERNAL_ERROR) {\n            try {\n                Document soapResponse = sendReceive(requestAction, timeout);\n\n                Node result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                if (result != null && OK.equals(result.getTextContent())) {\n                    final Node challengeNode = soapResponse.getElementsByTagName(\"Challenge\").item(0);\n                    final Node cookieNode = soapResponse.getElementsByTagName(COOKIE).item(0);\n                    final Node publicKeyNode = soapResponse.getElementsByTagName(\"PublicKey\").item(0);\n\n                    if (challengeNode != null && cookieNode != null && publicKeyNode != null) {\n                        setAuthenticationData(challengeNode.getTextContent(), cookieNode.getTextContent(),\n                                publicKeyNode.getTextContent());\n\n                        soapResponse = sendReceive(loginAction, timeout);\n                        result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                        if (result != null) {\n                            if (\"success\".equals(result.getTextContent())) {\n                                status = HNAPStatus.LOGGED_IN;\n                            } else {\n                                logger.debug(\"login - Check pin is correct\");\n                                // Assume pin code problem rather than a firmware change\n                                status = HNAPStatus.INVALID_PIN;\n                            }\n                        } else {\n                            unexpectedResult(\"login - Unexpected login response\", soapResponse);\n                        }\n                    } else {\n                        unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                    }\n                } else {\n                    unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                }\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final Exception e) {\n                // Assume there has been some problem trying to send one of the messages\n                if (status != HNAPStatus.COMMUNICATION_ERROR) {\n                    logger.debug(\"login - Communication error\", e);\n                    status = HNAPStatus.COMMUNICATION_ERROR;\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the authentication headers for the action message. This should only be called\n     * after a successful login.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param action - SOAP Action to add headers\n     */\n    protected void setAuthenticationHeaders(final SOAPMessage action) {\n        if (status == HNAPStatus.LOGGED_IN) {\n            try {\n                final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n                final MimeHeaders actionHeaders = action.getMimeHeaders();\n\n                actionHeaders.setHeader(COOKIE, loginHeaders.getHeader(COOKIE)[0]);\n\n                final String timeStamp = String.valueOf(System.currentTimeMillis() / 1000);\n                final String auth = hash(timeStamp + actionHeaders.getHeader(SOAPACTION)[0], privateKey) + \" \"\n                        + timeStamp;\n                actionHeaders.setHeader(\"HNAP_AUTH\", auth);\n\n                action.saveChanges();\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final SOAPException e) {\n                // No communication happening so assume system error\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            }\n        }\n    }\n\n    /**\n     * Send the SOAP message using Jetty HTTP client. Jetty is used in preference to\n     * HttpURLConnection which can result in the HNAP interface becoming unresponsive.\n     *\n     * @param action - SOAP Action to send\n     * @param timeout - Connection timeout in milliseconds\n     * @return The result\n     * @throws IOException\n     * @throws SOAPException\n     * @throws SAXException\n     * @throws ExecutionException\n     * @throws TimeoutException\n     * @throws InterruptedException\n     */\n    protected Document sendReceive(final SOAPMessage action, final int timeout) throws IOException, SOAPException,\n            SAXException, InterruptedException, TimeoutException, ExecutionException {\n        Document result;\n\n        final Request request = httpClient.POST(uri);\n        request.timeout(timeout, TimeUnit.MILLISECONDS);\n\n        final Iterator<?> it = action.getMimeHeaders().getAllHeaders();\n        while (it.hasNext()) {\n            final MimeHeader header = (MimeHeader) it.next();\n            request.header(header.getName(), header.getValue());\n        }\n\n        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n            action.writeTo(os);\n            request.content(new BytesContentProvider(os.toByteArray()));\n            final ContentResponse response = request.send();\n            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n                result = parser.parse(is);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Output unexpected responses to the debug log.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    protected void logUnexpectedResult(final String message, final Document soapResponse) {\n        // No point formatting for output if debug logging is not enabled\n        if (logger.isDebugEnabled()) {\n            try {\n                final TransformerFactory transFactory = TransformerFactory.newInstance();\n                final Transformer transformer = transFactory.newTransformer();\n                final StringWriter buffer = new StringWriter();\n                transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n                transformer.transform(new DOMSource(soapResponse), new StreamResult(buffer));\n                logger.debug(\"{} : {}\", message, buffer);\n            } catch (final TransformerException e) {\n                logger.debug(\"{}\", message);\n            }\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.enigma2.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.time.LocalDateTime;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.jetty.util.UrlEncoded;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link Enigma2Client} class is responsible for communicating with the Enigma2 device.\n * \n * @see <a href=\n *      \"https://github.com/E2OpenPlugins/e2openplugin-OpenWebif/wiki/OpenWebif-API-documentation\">OpenWebif-API-documentation</a>\n *\n * @author Guido Dolfen - Initial contribution\n */\n@NonNullByDefault\npublic class Enigma2Client {\n    private final Logger logger = LoggerFactory.getLogger(Enigma2Client.class);\n\n    static final String PATH_REMOTE_CONTROL = \"/web/remotecontrol?command=\";\n    static final String PATH_POWER = \"/web/powerstate\";\n    static final String PATH_VOLUME = \"/web/vol\";\n    static final String PATH_SET_VOLUME = \"/web/vol?set=set\";\n    static final String PATH_TOGGLE_MUTE = \"/web/vol?set=mute\";\n    static final String PATH_TOGGLE_POWER = \"/web/powerstate?newstate=0\";\n    static final String PATH_MESSAGE = \"/web/message?type=\";\n    static final String PATH_ALL_SERVICES = \"/web/getallservices\";\n    static final String PATH_ZAP = \"/web/zap?sRef=\";\n    static final String PATH_CHANNEL = \"/web/subservices\";\n    static final String PATH_EPG = \"/web/epgservicenow?sRef=\";\n    static final String PATH_ANSWER = \"/web/messageanswer?getanswer=now\";\n    static final int TYPE_QUESTION = 0;\n    static final int TYPE_INFO = 1;\n    static final int TYPE_WARNING = 2;\n    static final int TYPE_ERROR = 3;\n    private final Map<String, @Nullable String> channels = new ConcurrentHashMap<>();\n    private final String host;\n    private boolean power;\n    private String channel = \"\";\n    private String title = \"\";\n    private String description = \"\";\n    private String answer = \"\";\n    private int volume = 0;\n    private boolean mute;\n    private boolean online;\n    private boolean initialized;\n    private boolean asking;\n    private LocalDateTime lastAnswerTime = LocalDateTime.of(2020, 1, 1, 0, 0); // Date in the past\n    private final Enigma2HttpClient enigma2HttpClient;\n    private final DocumentBuilderFactory factory;\n\n    public Enigma2Client(String host, @Nullable String user, @Nullable String password, int requestTimeout) {\n        this.enigma2HttpClient = new Enigma2HttpClient(requestTimeout);\n        this.factory = DocumentBuilderFactory.newInstance();\n        if (StringUtils.isNotEmpty(user) && StringUtils.isNotEmpty(password)) {\n            this.host = \"http://\" + user + \":\" + password + \"@\" + host;\n        } else {\n            this.host = \"http://\" + host;\n        }\n    }\n\n    public boolean refresh() {\n        boolean wasOnline = online;\n        refreshPower();\n        if (!wasOnline && online) {\n            // Only refresh all services if the box changed from offline to online and power is on\n            // because it is a performance intensive action.\n            refreshAllServices();\n        }\n        refreshChannel();\n        refreshEpg();\n        refreshVolume();\n        refreshAnswer();\n        return online;\n    }\n\n    public void refreshPower() {\n        Optional<Document> document = transmitWithResult(PATH_POWER);\n        if (document.isPresent()) {\n            online = true;\n            processPowerResult(document.get());\n        } else {\n            online = false;\n            power = false;\n        }\n        initialized = true;\n    }\n\n    public void refreshAllServices() {\n        if (power || channels.isEmpty()) {\n            transmitWithResult(PATH_ALL_SERVICES).ifPresent(this::processAllServicesResult);\n        }\n    }\n\n    public void refreshChannel() {\n        if (power) {\n            transmitWithResult(PATH_CHANNEL).ifPresent(this::processChannelResult);\n        }\n    }\n\n    public void refreshAnswer() {\n        if (asking) {\n            transmitWithResult(PATH_ANSWER).ifPresent(this::processAnswerResult);\n        }\n    }\n\n    public void refreshVolume() {\n        if (power) {\n            transmitWithResult(PATH_VOLUME).ifPresent(this::processVolumeResult);\n        }\n    }\n\n    public void refreshEpg() {\n        if (power) {\n            Optional.ofNullable(channels.get(channel))\n                    .flatMap(name -> transmitWithResult(PATH_EPG + UrlEncoded.encodeString(name)))\n                    .ifPresent(this::processEpgResult);\n        }\n    }\n\n    private Optional<Document> transmitWithResult(String path) {\n        try {\n            Optional<String> xml = transmit(path);\n            if (xml.isPresent()) {\n                DocumentBuilder builder = factory.newDocumentBuilder();\n                return Optional.ofNullable(builder.parse(new InputSource(new StringReader(xml.get()))));\n            }\n            return Optional.empty();\n        } catch (IOException | SAXException | ParserConfigurationException | IllegalArgumentException e) {\n            if (online || !initialized) {\n                logger.debug(\"Error on transmit {}{}.\", host, path, e);\n            }\n            return Optional.empty();\n        }\n    }\n\n    private Optional<String> transmit(String path) {\n        String url = host + path;\n        try {\n            logger.debug(\"Transmitting {}\", url);\n            String result = getEnigma2HttpClient().get(url);\n            logger.debug(\"Transmitting result is {}\", result);\n            return Optional.ofNullable(result);\n        } catch (IOException | IllegalArgumentException e) {\n            if (online || !initialized) {\n                logger.debug(\"Error on transmit {}.\", url, e);\n            }\n            return Optional.empty();\n        }\n    }\n\n    public void setMute(boolean mute) {\n        refreshVolume();\n        if (this.mute != mute) {\n            transmitWithResult(PATH_TOGGLE_MUTE).ifPresent(this::processVolumeResult);\n        }\n    }\n\n    public void setPower(boolean power) {\n        refreshPower();\n        if (this.power != power) {\n            transmitWithResult(PATH_TOGGLE_POWER).ifPresent(this::processPowerResult);\n        }\n    }\n\n    public void setVolume(int volume) {\n        transmitWithResult(PATH_SET_VOLUME + volume).ifPresent(this::processVolumeResult);\n    }\n\n    public void setChannel(String name) {\n        if (channels.containsKey(name)) {\n            String id = channels.get(name);\n            transmitWithResult(PATH_ZAP + UrlEncoded.encodeString(id)).ifPresent(document -> channel = name);\n        } else {\n            logger.warn(\"Channel {} not found.\", name);\n        }\n    }\n\n    public void sendRcCommand(int key) {\n        transmit(PATH_REMOTE_CONTROL + key);\n    }\n\n    public void sendError(int timeout, String text) {\n        sendMessage(TYPE_ERROR, timeout, text);\n    }\n\n    public void sendWarning(int timeout, String text) {\n        sendMessage(TYPE_WARNING, timeout, text);\n    }\n\n    public void sendInfo(int timeout, String text) {\n        sendMessage(TYPE_INFO, timeout, text);\n    }\n\n    public void sendQuestion(int timeout, String text) {\n        asking = true;\n        sendMessage(TYPE_QUESTION, timeout, text);\n    }\n\n    private void sendMessage(int type, int timeout, String text) {\n        transmit(PATH_MESSAGE + type + \"&timeout=\" + timeout + \"&text=\" + UrlEncoded.encodeString(text));\n    }\n\n    private void processPowerResult(Document document) {\n        power = !getBoolean(document, \"e2instandby\");\n        if (!power) {\n            title = \"\";\n            description = \"\";\n            channel = \"\";\n        }\n    }\n\n    private void processChannelResult(Document document) {\n        channel = getString(document, \"e2servicename\");\n        // Add channel-Reference-ID if not known\n        if (!channels.containsKey(channel)) {\n            channels.put(channel, getString(document, \"e2servicereference\"));\n        }\n    }\n\n    private void processAnswerResult(Document document) {\n        if (asking) {\n            boolean state = getBoolean(document, \"e2state\");\n            if (state) {\n                String[] text = getString(document, \"e2statetext\").split(\" \");\n                answer = text[text.length - 1].replace(\"!\", \"\");\n                asking = false;\n                lastAnswerTime = LocalDateTime.now();\n            }\n        }\n    }\n\n    private void processVolumeResult(Document document) {\n        volume = getInt(document, \"e2current\");\n        mute = getBoolean(document, \"e2ismuted\");\n    }\n\n    private void processEpgResult(Document document) {\n        title = getString(document, \"e2eventtitle\");\n        description = getString(document, \"e2eventdescription\");\n    }\n\n    private void processAllServicesResult(Document document) {\n        NodeList bouquetList = document.getElementsByTagName(\"e2bouquet\");\n        channels.clear();\n        for (int i = 0; i < bouquetList.getLength(); i++) {\n            Element bouquet = (Element) bouquetList.item(i);\n            NodeList serviceList = bouquet.getElementsByTagName(\"e2service\");\n            for (int j = 0; j < serviceList.getLength(); j++) {\n                Element service = (Element) serviceList.item(j);\n                String id = service.getElementsByTagName(\"e2servicereference\").item(0).getTextContent();\n                String name = service.getElementsByTagName(\"e2servicename\").item(0).getTextContent();\n                channels.put(name, id);\n            }\n        }\n    }\n\n    private String getString(Document document, String elementId) {\n        return Optional.ofNullable(document.getElementsByTagName(elementId)).map(nodeList -> nodeList.item(0))\n                .map(Node::getTextContent).map(String::trim).orElse(\"\");\n    }\n\n    private boolean getBoolean(Document document, String elementId) {\n        return Boolean.parseBoolean(getString(document, elementId));\n    }\n\n    private int getInt(Document document, String elementId) {\n        try {\n            return Integer.parseInt(getString(document, elementId));\n        } catch (NumberFormatException e) {\n            return 0;\n        }\n    }\n\n    public int getVolume() {\n        return volume;\n    }\n\n    public boolean isMute() {\n        return mute;\n    }\n\n    public boolean isPower() {\n        return power;\n    }\n\n    public LocalDateTime getLastAnswerTime() {\n        return lastAnswerTime;\n    }\n\n    public String getChannel() {\n        return channel;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public String getAnswer() {\n        return answer;\n    }\n\n    public Collection<String> getChannels() {\n        return channels.keySet();\n    }\n\n    /**\n     * Getter for Test-Injection\n     * \n     * @return HttpGet.\n     */\n    Enigma2HttpClient getEnigma2HttpClient() {\n        return enigma2HttpClient;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.fmiweather.internal.client;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\nimport javax.xml.namespace.NamespaceContext;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.fmiweather.internal.client.FMIResponse.Builder;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIExceptionReportException;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIIOException;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIUnexpectedResponseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n *\n * Client for accessing FMI weather data\n *\n * Subject to license terms https://en.ilmatieteenlaitos.fi/open-data\n *\n *\n * All weather stations:\n * https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations&networkid=121&\n * Networkid parameter isexplained in entries of\n * https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations\n *\n * @author Sami Salonen - Initial contribution\n *\n */\n@NonNullByDefault\npublic class Client {\n\n    private final Logger logger = LoggerFactory.getLogger(Client.class);\n\n    public static final String WEATHER_STATIONS_URL = \"https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations&networkid=121&\";\n\n    private static final Map<String, String> NAMESPACES = new HashMap<>();\n    static {\n        NAMESPACES.put(\"target\", \"http://xml.fmi.fi/namespace/om/atmosphericfeatures/1.0\");\n        NAMESPACES.put(\"gml\", \"http://www.opengis.net/gml/3.2\");\n        NAMESPACES.put(\"xlink\", \"http://www.w3.org/1999/xlink\");\n        NAMESPACES.put(\"ows\", \"http://www.opengis.net/ows/1.1\");\n        NAMESPACES.put(\"gmlcov\", \"http://www.opengis.net/gmlcov/1.0\");\n        NAMESPACES.put(\"swe\", \"http://www.opengis.net/swe/2.0\");\n\n        NAMESPACES.put(\"wfs\", \"http://www.opengis.net/wfs/2.0\");\n        NAMESPACES.put(\"ef\", \"http://inspire.ec.europa.eu/schemas/ef/4.0\");\n    }\n    private static final NamespaceContext NAMESPACE_CONTEXT = new NamespaceContext() {\n        @Override\n        public String getNamespaceURI(@Nullable String prefix) {\n            return NAMESPACES.get(prefix);\n        }\n\n        @SuppressWarnings(\"rawtypes\")\n        @Override\n        public @Nullable Iterator getPrefixes(@Nullable String val) {\n            return null;\n        }\n\n        @Override\n        public @Nullable String getPrefix(@Nullable String uri) {\n            return null;\n        }\n    };\n\n    private DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n    private DocumentBuilder documentBuilder;\n\n    public Client() {\n        documentBuilderFactory.setNamespaceAware(true);\n        try {\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Query request and return the data\n     *\n     * @param request request to process\n     * @param timeoutMillis timeout for the http call\n     * @return data corresponding to the query\n     * @throws FMIIOException on all I/O errors\n     * @throws FMIUnexpectedResponseException on all unexpected content errors\n     * @throw FMIExceptionReportException on explicit error responses from the server\n     */\n    public FMIResponse query(Request request, int timeoutMillis)\n            throws FMIExceptionReportException, FMIUnexpectedResponseException, FMIIOException {\n        try {\n            String url = request.toUrl();\n            String responseText = HttpUtil.executeUrl(\"GET\", url, timeoutMillis);\n            if (responseText == null) {\n                throw new FMIIOException(String.format(\"HTTP error with %s\", request.toUrl()));\n            }\n            FMIResponse response = parseMultiPointCoverageXml(responseText);\n            logger.debug(\"Request {} translated to url {}. Response: {}\", request, url, response);\n            return response;\n        } catch (IOException e) {\n            throw new FMIIOException(e);\n        } catch (SAXException | XPathExpressionException e) {\n            throw new FMIUnexpectedResponseException(e);\n        }\n    }\n\n    /**\n     * Query all weather stations\n     *\n     * @param timeoutMillis timeout for the http call\n     * @return locations representing stations\n     * @throws FMIIOException on all I/O errors\n     * @throws FMIUnexpectedResponseException on all unexpected content errors\n     * @throw FMIExceptionReportException on explicit error responses from the server\n     */\n    public Set<Location> queryWeatherStations(int timeoutMillis)\n            throws FMIIOException, FMIUnexpectedResponseException, FMIExceptionReportException {\n        try {\n            String response = HttpUtil.executeUrl(\"GET\", WEATHER_STATIONS_URL, timeoutMillis);\n            if (response == null) {\n                throw new FMIIOException(String.format(\"HTTP error with %s\", WEATHER_STATIONS_URL));\n            }\n            return parseStations(response);\n        } catch (IOException e) {\n            throw new FMIIOException(e);\n        } catch (XPathExpressionException | SAXException e) {\n            throw new FMIUnexpectedResponseException(e);\n        }\n    }\n\n    private Set<Location> parseStations(String response) throws FMIExceptionReportException,\n            FMIUnexpectedResponseException, SAXException, IOException, XPathExpressionException {\n        Document document = documentBuilder.parse(new InputSource(new StringReader(response)));\n\n        XPath xPath = XPathFactory.newInstance().newXPath();\n        xPath.setNamespaceContext(NAMESPACE_CONTEXT);\n\n        boolean isExceptionReport = ((Node) xPath.compile(\"/ows:ExceptionReport\").evaluate(document,\n                XPathConstants.NODE)) != null;\n        if (isExceptionReport) {\n            Node exceptionCode = (Node) xPath.compile(\"/ows:ExceptionReport/ows:Exception/@exceptionCode\")\n                    .evaluate(document, XPathConstants.NODE);\n            String[] exceptionText = queryNodeValues(xPath.compile(\"//ows:ExceptionText/text()\"), document);\n            throw new FMIExceptionReportException(exceptionCode.getNodeValue(), exceptionText);\n        }\n\n        String[] fmisids = queryNodeValues(\n                xPath.compile(\n                        \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/gml:identifier/text()\"),\n                document);\n        String[] names = queryNodeValues(xPath.compile(\n                \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/gml:name[@codeSpace='http://xml.fmi.fi/namespace/locationcode/name']/text()\"),\n                document);\n        String[] representativePoints = queryNodeValues(xPath.compile(\n                \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/ef:representativePoint/gml:Point/gml:pos/text()\"),\n                document);\n\n        if (fmisids.length != names.length || fmisids.length != representativePoints.length) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Could not all properties of locations: fmisids: %d, names: %d, representativePoints: %d\",\n                    fmisids.length, names.length, representativePoints.length));\n        }\n\n        Set<Location> locations = new HashSet<>(representativePoints.length);\n        for (int i = 0; i < representativePoints.length; i++) {\n            BigDecimal[] latlon = parseLatLon(representativePoints[i]);\n            locations.add(new Location(names[i], fmisids[i], latlon[0], latlon[1]));\n        }\n        return locations;\n    }\n\n    /**\n     * Parse FMI multipointcoverage formatted xml response\n     *\n     */\n    private FMIResponse parseMultiPointCoverageXml(String response) throws FMIUnexpectedResponseException,\n            FMIExceptionReportException, SAXException, IOException, XPathExpressionException {\n        Document document = documentBuilder.parse(new InputSource(new StringReader(response)));\n\n        XPath xPath = XPathFactory.newInstance().newXPath();\n        xPath.setNamespaceContext(NAMESPACE_CONTEXT);\n\n        boolean isExceptionReport = ((Node) xPath.compile(\"/ows:ExceptionReport\").evaluate(document,\n                XPathConstants.NODE)) != null;\n        if (isExceptionReport) {\n            Node exceptionCode = (Node) xPath.compile(\"/ows:ExceptionReport/ows:Exception/@exceptionCode\")\n                    .evaluate(document, XPathConstants.NODE);\n            String[] exceptionText = queryNodeValues(xPath.compile(\"//ows:ExceptionText/text()\"), document);\n            throw new FMIExceptionReportException(exceptionCode.getNodeValue(), exceptionText);\n        }\n\n        Builder builder = new FMIResponse.Builder();\n\n        String[] parameters = queryNodeValues(xPath.compile(\"//swe:field/@name\"), document);\n        /**\n         * Observations have FMISID (FMI Station ID?), with forecasts we use lat & lon\n         */\n        String[] ids = queryNodeValues(xPath.compile(\n                \"//target:Location/gml:identifier[@codeSpace='http://xml.fmi.fi/namespace/stationcode/fmisid']/text()\"),\n                document);\n\n        String[] names = queryNodeValues(xPath.compile(\n                \"//target:Location/gml:name[@codeSpace='http://xml.fmi.fi/namespace/locationcode/name']/text()\"),\n                document);\n        String[] representativePointRefs = queryNodeValues(\n                xPath.compile(\"//target:Location/target:representativePoint/@xlink:href\"), document);\n\n        if ((ids.length > 0 && ids.length != names.length) || names.length != representativePointRefs.length) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Could not all properties of locations: ids: %d, names: %d, representativePointRefs: %d\",\n                    ids.length, names.length, representativePointRefs.length));\n        }\n\n        Location[] locations = new Location[representativePointRefs.length];\n        for (int i = 0; i < locations.length; i++) {\n            BigDecimal[] latlon = findLatLon(xPath, i, document, representativePointRefs[i]);\n            String id = ids.length == 0 ? String.format(\"%s,%s\", latlon[0].toPlainString(), latlon[1].toPlainString())\n                    : ids[i];\n            locations[i] = new Location(names[i], id, latlon[0], latlon[1]);\n        }\n\n        logger.trace(\"names ({}): {}\", names.length, names);\n        logger.trace(\"parameters ({}): {}\", parameters.length, parameters);\n        if (names.length == 0) {\n            // No data, e.g. when starttime=endtime\n            return builder.build();\n        }\n\n        String latLonTimeTripletText = takeFirstOrError(\"positions\",\n                queryNodeValues(xPath.compile(\"//gmlcov:positions/text()\"), document));\n        String[] latLonTimeTripletEntries = latLonTimeTripletText.trim().split(\"\\\\s+\");\n        logger.trace(\"latLonTimeTripletText: {}\", latLonTimeTripletText);\n        logger.trace(\"latLonTimeTripletEntries ({}): {}\", latLonTimeTripletEntries.length, latLonTimeTripletEntries);\n        int countTimestamps = latLonTimeTripletEntries.length / 3 / locations.length;\n        long[] timestampsEpoch = IntStream.range(0, latLonTimeTripletEntries.length).filter(i -> i % 3 == 0)\n                .limit(countTimestamps).mapToLong(i -> Long.parseLong(latLonTimeTripletEntries[i + 2])).toArray();\n        // Invariant\n        assert countTimestamps == timestampsEpoch.length;\n        logger.trace(\"countTimestamps ({}): {}\", countTimestamps, timestampsEpoch);\n        validatePositionEntries(locations, timestampsEpoch, latLonTimeTripletEntries);\n\n        String valuesText = takeFirstOrError(\"doubleOrNilReasonTupleList\",\n                queryNodeValues(xPath.compile(\".//gml:doubleOrNilReasonTupleList/text()\"), document));\n        String[] valuesEntries = valuesText.trim().split(\"\\\\s+\");\n        logger.trace(\"valuesText: {}\", valuesText);\n        logger.trace(\"valuesEntries ({}): {}\", valuesEntries.length, valuesEntries);\n        if (valuesEntries.length != locations.length * parameters.length * countTimestamps) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Wrong number of values (%d). Expecting %d * %d * %d = %d\", valuesEntries.length, locations.length,\n                    parameters.length, countTimestamps, countTimestamps * locations.length * parameters.length));\n        }\n        IntStream.range(0, locations.length).forEach(locationIndex -> {\n            for (int parameterIndex = 0; parameterIndex < parameters.length; parameterIndex++) {\n                for (int timestepIndex = 0; timestepIndex < countTimestamps; timestepIndex++) {\n                    BigDecimal val = toBigDecimalOrNullIfNaN(\n                            valuesEntries[locationIndex * countTimestamps * parameters.length\n                                    + timestepIndex * parameters.length + parameterIndex]);\n                    logger.trace(\"Found value {}={} @ time={} for location {}\", parameters[parameterIndex], val,\n                            timestampsEpoch[timestepIndex], locations[locationIndex].id);\n                    builder.appendLocationData(locations[locationIndex], countTimestamps, parameters[parameterIndex],\n                            timestampsEpoch[timestepIndex], val);\n                }\n            }\n        });\n\n        return builder.build();\n    }\n\n    /**\n     * Find representative latitude and longitude matching given xlink href attribute value\n     *\n     * @param xPath xpath object used for query\n     * @param entryIndex index of the location, for logging only on errors\n     * @param document document object\n     * @param href xlink href attribute value. Should start with #\n     * @return latitude and longitude values as array\n     * @throws FMIUnexpectedResponseException parsing errors or when entry is not found\n     * @throws XPathExpressionException xpath errors\n     */\n    private BigDecimal[] findLatLon(XPath xPath, int entryIndex, Document document, String href)\n            throws FMIUnexpectedResponseException, XPathExpressionException {\n        if (!href.startsWith(\"#\")) {\n            throw new FMIUnexpectedResponseException(\n                    \"Could not find valid representativePoint xlink:href, does not start with #\");\n        }\n        String pointId = href.substring(1);\n        String pointLatLon = takeFirstOrError(String.format(\"[%d]/pos\", entryIndex),\n                queryNodeValues(xPath.compile(\".//gml:Point[@gml:id='\" + pointId + \"']/gml:pos/text()\"), document));\n        return parseLatLon(pointLatLon);\n    }\n\n    /**\n     * Parse string reprsenting latitude longitude string separated by space\n     *\n     * @param pointLatLon latitude longitude string separated by space\n     * @return latitude and longitude values as array\n     * @throws FMIUnexpectedResponseException on parsing errors\n     */\n    private BigDecimal[] parseLatLon(String pointLatLon) throws FMIUnexpectedResponseException {\n        String[] latlon = pointLatLon.split(\" \");\n        BigDecimal lat, lon;\n        if (latlon.length != 2) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Invalid latitude or longitude format, expected two values separated by space, got %d values: '%s'\",\n                    latlon.length, latlon));\n        }\n        try {\n            lat = new BigDecimal(latlon[0]);\n            lon = new BigDecimal(latlon[1]);\n        } catch (NumberFormatException e) {\n            throw new FMIUnexpectedResponseException(\n                    String.format(\"Invalid latitude or longitude format: %s\", e.getMessage()));\n        }\n        return new BigDecimal[] { lat, lon };\n    }\n\n    private String[] queryNodeValues(XPathExpression expression, Object source) throws XPathExpressionException {\n        NodeList nodeList = (NodeList) expression.evaluate(source, XPathConstants.NODESET);\n        String[] values = new String[nodeList.getLength()];\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            values[i] = nodeList.item(i).getNodeValue();\n        }\n        return values;\n    }\n\n    /**\n     * Asserts that length of values is exactly 1, and returns it\n     *\n     * @param errorDescription error description for FMIResponseException\n     * @param values\n     * @return\n     * @throws FMIUnexpectedResponseException when length of values != 1\n     */\n    private String takeFirstOrError(String errorDescription, String[] values) throws FMIUnexpectedResponseException {\n        if (values.length != 1) {\n            throw new FMIUnexpectedResponseException(String.format(\"No unique match found: %s\", errorDescription));\n        }\n        return values[0];\n    }\n\n    /**\n     * Convert string to BigDecimal. \"NaN\" string is converted to null\n     *\n     * @param value\n     * @return null when value is \"NaN\". Otherwise BigDecimal representing the string\n     */\n    private @Nullable BigDecimal toBigDecimalOrNullIfNaN(String value) {\n        if (\"NaN\".equals(value)) {\n            return null;\n        } else {\n            return new BigDecimal(value);\n        }\n    }\n\n    /**\n     * Validate ordering and values of gmlcov:positions (latLonTimeTripletEntries)\n     * essentially\n     * pos1_lat, pos1_lon, time1\n     * pos1_lat, pos1_lon, time2\n     * pos1_lat, pos1_lon, time3\n     * pos2_lat, pos2_lon, time1\n     * pos2_lat, pos2_lon, time2\n     * ..etc..\n     *\n     * - lat, lon should be in correct order and match position entries (\"locations\")\n     * - time should values should be exactly same for each point (above time1, time2, ...), and match given timestamps\n     * (\"timestampsEpoch\")\n     *\n     *\n     * @param locations previously discovered locations\n     * @param timestampsEpoch expected timestamps\n     * @param latLonTimeTripletEntries flat array of strings representing the array, [row1_cell1, row1_cell2,\n     *            row2_cell1, ...]\n     * @throws FMIUnexpectedResponseException when value ordering is not matching the expected\n     */\n    private void validatePositionEntries(Location[] locations, long[] timestampsEpoch,\n            String[] latLonTimeTripletEntries) throws FMIUnexpectedResponseException {\n        int countTimestamps = timestampsEpoch.length;\n        for (int locationIndex = 0; locationIndex < locations.length; locationIndex++) {\n            String firstLat = latLonTimeTripletEntries[locationIndex * countTimestamps * 3];\n            String fistLon = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + 1];\n\n            // step through entries for this position\n            for (int timestepIndex = 0; timestepIndex < countTimestamps; timestepIndex++) {\n                String lat = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3];\n                String lon = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3 + 1];\n                String timeEpochSec = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3\n                        + 2];\n                if (!lat.equals(firstLat) || !lon.equals(fistLon)) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] lat, lon for time index [%d] was not matching expected ordering\",\n                            locationIndex, timestepIndex));\n                }\n                String expectedLat = locations[locationIndex].latitude.toPlainString();\n                String expectedLon = locations[locationIndex].longitude.toPlainString();\n                if (!lat.equals(expectedLat) || !lon.equals(expectedLon)) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] lat, lon for time index [%d] was not matching representativePoint\",\n                            locationIndex, timestepIndex));\n                }\n\n                if (Long.parseLong(timeEpochSec) != timestampsEpoch[timestepIndex]) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] time (%s) for time index [%d] was not matching expected (%d) ordering\",\n                            locationIndex, timeEpochSec, timestepIndex, timestampsEpoch[timestepIndex]));\n                }\n            }\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.fsinternetradio.internal.radio;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * This class hold the result of a request read from the radio. Upon a request the radio returns a XML document like\n * this:\n *\n * <pre>\n * <xmp>\n *   <fsapiResponse> <status>FS_OK</status> <value><u8>1</u8></value> </fsapiResponse>\n * </xmp>\n * </pre>\n *\n * This class parses this XML data and provides functions for reading and casting typical fields.\n *\n * @author Rainer Ostendorf\n * @author Patrick Koenemann\n *\n */\npublic class FrontierSiliconRadioApiResult {\n\n    /**\n     * XML structure holding the parsed response\n     */\n    final Document xmlDoc;\n\n    private final Logger logger = LoggerFactory.getLogger(FrontierSiliconRadioApiResult.class);\n\n    /**\n     * Create result object from XML that was received from the radio.\n     *\n     * @param requestResultString\n     *            The XML string received from the radio.\n     * @throws IOException in case the XML returned by the radio is invalid.\n     */\n    public FrontierSiliconRadioApiResult(String requestResultString) throws IOException {\n        Document xml = null;\n        try {\n            xml = getXmlDocFromString(requestResultString);\n        } catch (Exception e) {\n            logger.trace(\"converting to XML failed: '{}' with {}: {}\", requestResultString, e.getClass().getName(),\n                    e.getMessage());\n            logger.debug(\"converting to XML failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new IOException(e);\n        }\n        xmlDoc = xml;\n    }\n\n    /**\n     * Extract the field \"status\" from the result and return it\n     *\n     * @return result field as string.\n     */\n    private String getStatus() {\n        final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n        final Element statusNode = (Element) fsApiResult.getElementsByTagName(\"status\").item(0);\n\n        final String status = getCharacterDataFromElement(statusNode);\n        logger.trace(\"status is: {}\", status);\n\n        return status;\n    }\n\n    /**\n     * checks if the responses status code was \"FS_OK\"\n     *\n     * @return true if status is \"FS_OK\", false else\n     */\n    public boolean isStatusOk() {\n        return (\"FS_OK\").equals(getStatus());\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u8&gt; field as boolean\n     *\n     * @return value.u8 field as bool\n     */\n    public boolean getValueU8AsBoolean() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u8Node = (Element) valueNode.getElementsByTagName(\"u8\").item(0);\n\n            final String value = getCharacterDataFromElement(u8Node);\n            logger.trace(\"value is: {}\", value);\n\n            return \"1\".equals(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U8 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u8&gt; field as int\n     *\n     * @return value.u8 field as int\n     */\n    public int getValueU8AsInt() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u8Node = (Element) valueNode.getElementsByTagName(\"u8\").item(0);\n\n            final String value = getCharacterDataFromElement(u8Node);\n            logger.trace(\"value is: {}\", value);\n\n            return Integer.parseInt(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U8 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return 0;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u32&gt; field as int\n     *\n     * @return value.u32 field as int\n     */\n    public int getValueU32AsInt() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u32Node = (Element) valueNode.getElementsByTagName(\"u32\").item(0);\n\n            final String value = getCharacterDataFromElement(u32Node);\n            logger.trace(\"value is: {}\", value);\n\n            return Integer.parseInt(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U32 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return 0;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;c8_array&gt; field as String\n     *\n     * @return value.c8_array field as String\n     */\n    public String getValueC8ArrayAsString() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element c8Array = (Element) valueNode.getElementsByTagName(\"c8_array\").item(0);\n\n            final String value = getCharacterDataFromElement(c8Array);\n            logger.trace(\"value is: {}\", value);\n\n            return value;\n        } catch (Exception e) {\n            logger.error(\"getting Value.c8array failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return \"\";\n        }\n    }\n\n    /**\n     * read the &lt;sessionId&gt; field as String\n     *\n     * @return value of sessionId field\n     */\n    public String getSessionId() {\n        final NodeList sessionIdTagList = xmlDoc.getElementsByTagName(\"sessionId\");\n        final String givenSessId = getCharacterDataFromElement((Element) sessionIdTagList.item(0));\n        return givenSessId;\n    }\n\n    /**\n     * converts the string we got from the radio to a parsable XML document\n     *\n     * @param xmlString\n     *            the XML string read from the radio\n     * @return the parsed XML document\n     * @throws ParserConfigurationException\n     * @throws SAXException\n     * @throws IOException\n     */\n    private Document getXmlDocFromString(String xmlString)\n            throws ParserConfigurationException, SAXException, IOException {\n        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        final DocumentBuilder builder = factory.newDocumentBuilder();\n        final Document xmlDocument = builder.parse(new InputSource(new StringReader(xmlString)));\n        return xmlDocument;\n    }\n\n    /**\n     * convert the value of a given XML element to a string for further processing\n     *\n     * @param e\n     *            XML Element\n     * @return the elements value converted to string\n     */\n    private static String getCharacterDataFromElement(Element e) {\n        final Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            final CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"\";\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.gce.internal.model;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.gce.internal.handler.Ipx800EventListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * This class takes care of interpreting the status.xml file\n *\n * @author Ga\u00ebl L'hopital - Initial contribution\n */\n@NonNullByDefault\npublic class StatusFileInterpreter {\n    private static final String URL_TEMPLATE = \"http://%s/globalstatus.xml\";\n    private final Logger logger = LoggerFactory.getLogger(StatusFileInterpreter.class);\n    private final String hostname;\n    private @Nullable Document doc;\n    private final Ipx800EventListener listener;\n\n    public static enum StatusEntry {\n        VERSION,\n        CONFIG_MAC;\n    }\n\n    public StatusFileInterpreter(String hostname, Ipx800EventListener listener) {\n        this.hostname = hostname;\n        this.listener = listener;\n    }\n\n    public void read() {\n        try {\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            String statusPage = HttpUtil.executeUrl(\"GET\", String.format(URL_TEMPLATE, hostname), 5000);\n            InputStream inputStream = new ByteArrayInputStream(statusPage.getBytes());\n            Document document = builder.parse(inputStream);\n            document.getDocumentElement().normalize();\n            doc = document;\n            pushDatas();\n            inputStream.close();\n        } catch (IOException | SAXException | ParserConfigurationException e) {\n            logger.warn(\"Unable to read IPX800 status page : {}\", e.getMessage());\n            doc = null;\n        }\n    }\n\n    private void pushDatas() {\n        Element root = getRoot();\n        if (root != null) {\n            PortDefinition.asStream().forEach(portDefinition -> {\n                List<Node> xmlNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n                xmlNodes.forEach(xmlNode -> {\n                    String sPortNum = xmlNode.getNodeName().replace(portDefinition.getNodeName(), \"\");\n                    int portNum = Integer.parseInt(sPortNum) + 1;\n                    double value = Double.parseDouble(xmlNode.getTextContent().replace(\"dn\", \"1\").replace(\"up\", \"0\"));\n                    listener.dataReceived(String.format(\"%s%d\", portDefinition.getPortName(), portNum), value);\n                });\n            });\n        }\n    }\n\n    public String getElement(StatusEntry entry) {\n        Element root = getRoot();\n        if (root != null) {\n            return root.getElementsByTagName(entry.name().toLowerCase()).item(0).getTextContent();\n        } else {\n            return \"\";\n        }\n    }\n\n    private List<Node> getMatchingNodes(NodeList nodeList, String criteria) {\n        return IntStream.range(0, nodeList.getLength()).boxed().map(nodeList::item)\n                .filter(node -> node.getNodeName().startsWith(criteria))\n                .sorted(Comparator.comparing(o -> o.getNodeName())).collect(Collectors.toList());\n    }\n\n    public int getMaxNumberofNodeType(PortDefinition portDefinition) {\n        Element root = getRoot();\n        if (root != null) {\n            List<Node> filteredNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n            return filteredNodes.size();\n        }\n        return 0;\n    }\n\n    private @Nullable Element getRoot() {\n        if (doc == null) {\n            read();\n        }\n        if (doc != null) {\n            return doc.getDocumentElement();\n        }\n        return null;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.homematic.internal.communicator.message;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Decodes a XML-RPC message from the Homematic server.\n *\n * @author Gerhard Riegler - Initial contribution\n */\npublic class XmlRpcResponse implements RpcResponse {\n    private String methodName;\n    private Object[] responseData;\n\n    /**\n     * Decodes a XML-RPC message from the given InputStream.\n     */\n    public XmlRpcResponse(InputStream is, String encoding)\n            throws SAXException, ParserConfigurationException, IOException {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        SAXParser saxParser = factory.newSAXParser();\n        InputSource inputSource = new InputSource(is);\n        inputSource.setEncoding(encoding);\n        saxParser.parse(inputSource, new XmlRpcHandler());\n    }\n\n    @Override\n    public Object[] getResponseData() {\n        return responseData;\n    }\n\n    @Override\n    public String getMethodName() {\n        return methodName;\n    }\n\n    @Override\n    public String toString() {\n        return RpcUtils.dumpRpcMessage(methodName, responseData);\n    }\n\n    /**\n     * SAX parser implementation to decode XML-RPC.\n     *\n     * @author Gerhard Riegler\n     */\n    private class XmlRpcHandler extends DefaultHandler {\n        private List<Object> result = new ArrayList<>();\n        private LinkedList<List<Object>> currentDataObject = new LinkedList<>();\n        private StringBuilder tagValue;\n        private boolean isValueTag;\n\n        @Override\n        public void startDocument() throws SAXException {\n            currentDataObject.addLast(new ArrayList<>());\n        }\n\n        @Override\n        public void endDocument() throws SAXException {\n            result.addAll(currentDataObject.removeLast());\n            responseData = result.toArray();\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String qName, Attributes attributes)\n                throws SAXException {\n            String tag = qName.toLowerCase();\n            if (tag.equals(\"array\") || tag.equals(\"struct\")) {\n                currentDataObject.addLast(new ArrayList<>());\n            }\n            isValueTag = tag.equals(\"value\");\n            tagValue = new StringBuilder();\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            String currentTag = qName.toLowerCase();\n            String currentValue = tagValue.toString();\n            List<Object> data = currentDataObject.peekLast();\n\n            switch (currentTag) {\n                case \"boolean\":\n                    data.add(\"1\".equals(currentValue) ? Boolean.TRUE : Boolean.FALSE);\n                    break;\n                case \"int\":\n                case \"i4\":\n                    data.add(new Integer(currentValue));\n                    break;\n                case \"double\":\n                    data.add(new Double(currentValue));\n                    break;\n                case \"string\":\n                case \"name\":\n                    data.add(currentValue);\n                    break;\n                case \"value\":\n                    if (isValueTag) {\n                        data.add(currentValue);\n                        isValueTag = false;\n                    }\n                    break;\n                case \"array\":\n                    List<Object> arrayData = currentDataObject.removeLast();\n                    currentDataObject.peekLast().add(arrayData.toArray());\n                    break;\n                case \"struct\":\n                    List<Object> mapData = currentDataObject.removeLast();\n                    Map<Object, Object> resultMap = new HashMap<>();\n\n                    for (int i = 0; i < mapData.size(); i += 2) {\n                        resultMap.put(mapData.get(i), mapData.get(i + 1));\n                    }\n                    currentDataObject.peekLast().add(resultMap);\n                    break;\n                case \"base64\":\n                    data.add(Base64.getDecoder().decode(currentValue));\n                    break;\n                case \"datetime.iso8601\":\n                    try {\n                        data.add(XmlRpcRequest.xmlRpcDateFormat.parse(currentValue));\n                    } catch (ParseException ex) {\n                        throw new SAXException(ex.getMessage(), ex);\n                    }\n                    break;\n                case \"methodname\":\n                    methodName = currentValue;\n                    break;\n                case \"params\":\n                case \"param\":\n                case \"methodcall\":\n                case \"methodresponse\":\n                case \"member\":\n                case \"data\":\n                case \"fault\":\n                    break;\n                default:\n                    throw new SAXException(\"Unknown XML-RPC tag: \" + currentTag);\n            }\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            tagValue.append(new String(ch, start, length));\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.hpprinter.internal.api;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Function;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.http.HttpMethod;\nimport org.openhab.binding.hpprinter.internal.api.HPServerResult.RequestStatus;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link HPWebServerClient} is responsible for handling reading of data from the HP Embedded Web Server.\n *\n * @author Stewart Cossey - Initial contribution\n */\n@NonNullByDefault\npublic class HPWebServerClient {\n    public static final int REQUEST_TIMEOUT_SEC = 10;\n    private final Logger logger = LoggerFactory.getLogger(HPWebServerClient.class);\n\n    private final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    private final HttpClient httpClient;\n    private final String serverAddress;\n\n    /**\n     * Creates a new HP Web Server Client object.\n     * \n     * @param httpClient {HttpClient} The HttpClient to use for HTTP requests.\n     * @param address The address for the Embedded Web Server.\n     */\n    public HPWebServerClient(HttpClient httpClient, String address) {\n        this.httpClient = httpClient;\n        serverAddress = \"http://\" + address;\n\n        logger.debug(\"Create printer connection {}\", serverAddress);\n    }\n\n    /**\n     * Gets the Status information from the Embedded Web Server.\n     * \n     * @return The status information.\n     */\n    public HPServerResult<HPStatus> getStatus() {\n        return fetchData(serverAddress + HPStatus.ENDPOINT, (HPStatus::new));\n    }\n\n    public HPServerResult<HPProductUsageFeatures> getProductFeatures() {\n        return fetchData(serverAddress + HPProductUsageFeatures.ENDPOINT, (HPProductUsageFeatures::new));\n    }\n\n    public HPServerResult<HPFeatures> getProductUsageFeatures() {\n        return fetchData(serverAddress + HPFeatures.ENDPOINT, (HPFeatures::new));\n    }\n\n    public HPServerResult<HPScannerStatusFeatures> getScannerFeatures() {\n        return fetchData(serverAddress + HPScannerStatusFeatures.ENDPOINT, (HPScannerStatusFeatures::new));\n    }\n\n    /**\n     * Gets the Usage information from the Embedded Web Server.\n     * \n     * @return The usage information.\n     */\n    public HPServerResult<HPUsage> getUsage() {\n        return fetchData(serverAddress + HPUsage.ENDPOINT, (HPUsage::new));\n    }\n\n    public HPServerResult<HPScannerStatus> getScannerStatus() {\n        return fetchData(serverAddress + HPScannerStatus.ENDPOINT, (HPScannerStatus::new));\n    }\n\n    public HPServerResult<HPProperties> getProperties() {\n        return fetchData(serverAddress + HPProperties.ENDPOINT, (HPProperties::new));\n    }\n\n    private <T> HPServerResult<T> fetchData(String endpoint, Function<Document, T> function) {\n        try {\n            logger.trace(\"HTTP Client Load {}\", endpoint);\n            ContentResponse cr = httpClient.newRequest(endpoint).method(HttpMethod.GET)\n                    .timeout(REQUEST_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n\n            String contentAsString = cr.getContentAsString();\n            logger.trace(\"HTTP Client Result {} Size {}\", cr.getStatus(), contentAsString.length());\n            return new HPServerResult<>(function.apply(getDocument(contentAsString)));\n        } catch (TimeoutException ex) {\n            logger.trace(\"HTTP Client Timeout Exception {}\", ex.getMessage());\n            return new HPServerResult<>(RequestStatus.TIMEOUT, ex.getMessage());\n        } catch (InterruptedException | ExecutionException | ParserConfigurationException | SAXException\n                | IOException ex) {\n            logger.trace(\"HTTP Client Exception {}\", ex.getMessage());\n            return new HPServerResult<>(RequestStatus.ERROR, ex.getMessage());\n        }\n    }\n\n    private synchronized Document getDocument(String contentAsString)\n            throws ParserConfigurationException, SAXException, IOException {\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        InputSource source = new InputSource(new StringReader(contentAsString));\n        return builder.parse(source);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.ihc.internal.ws.projectfile;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.io.FileUtils;\nimport org.openhab.binding.ihc.internal.ws.datatypes.WSProjectInfo;\nimport org.openhab.binding.ihc.internal.ws.exeptions.IhcExecption;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Generic methods related to IHC / ELKO project file handling.\n *\n * @author Pauli Anttila - Initial contribution\n */\npublic class ProjectFileUtils {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProjectFileUtils.class);\n\n    /**\n     * Read IHC project file from local file.\n     *\n     * @param filePath File to read.\n     * @return XML document.\n     * @throws IhcExecption when file read fails.\n     */\n    public static Document readFromFile(String filePath) throws IhcExecption {\n        File fXmlFile = new File(filePath);\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(fXmlFile);\n            return doc;\n        } catch (IOException | ParserConfigurationException | SAXException e) {\n            throw new IhcExecption(e);\n        }\n    }\n\n    /**\n     * Save IHC project file to local file.\n     *\n     * @param filePath File path.\n     * @param data Data to write\n     * @throws IhcExecption when file write fails.\n     */\n    public static void saveToFile(String filePath, byte[] data) throws IhcExecption {\n        try {\n            FileUtils.writeByteArrayToFile(new File(filePath), data);\n        } catch (IOException e) {\n            throw new IhcExecption(e);\n        }\n    }\n\n    /**\n     * Convert bytes to XML document.\n     *\n     * @return XML document or null if conversion fails.\n     */\n    public static Document converteBytesToDocument(byte[] data) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        try {\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            return builder.parse(new ByteArrayInputStream(data));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            LOGGER.warn(\"Error occured when trying to convert data to XML, reason {}\", e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Compare XML document header information to project info.\n     *\n     * @return true if information is equal and false if not.\n     */\n    public static boolean projectEqualsToControllerProject(Document projectfile, WSProjectInfo projectInfo) {\n        if (projectInfo != null) {\n            try {\n                NodeList nodes = projectfile.getElementsByTagName(\"modified\");\n                if (nodes.getLength() == 1) {\n                    Element node = (Element) nodes.item(0);\n                    int year = Integer.parseInt(node.getAttribute(\"year\"));\n                    int month = Integer.parseInt(node.getAttribute(\"month\"));\n                    int day = Integer.parseInt(node.getAttribute(\"day\"));\n                    int hour = Integer.parseInt(node.getAttribute(\"hour\"));\n                    int minute = Integer.parseInt(node.getAttribute(\"minute\"));\n\n                    LOGGER.debug(\"Project file from file, date: {}.{}.{} {}:{}\", year, month, day, hour, minute);\n                    LOGGER.debug(\"Project file in controller, date: {}.{}.{} {}:{}\",\n                            projectInfo.getLastmodified().getYear(),\n                            projectInfo.getLastmodified().getMonthWithJanuaryAsOne(),\n                            projectInfo.getLastmodified().getDay(), projectInfo.getLastmodified().getHours(),\n                            projectInfo.getLastmodified().getMinutes());\n\n                    if (projectInfo.getLastmodified().getYear() == year\n                            && projectInfo.getLastmodified().getMonthWithJanuaryAsOne() == month\n                            && projectInfo.getLastmodified().getDay() == day\n                            && projectInfo.getLastmodified().getHours() == hour\n                            && projectInfo.getLastmodified().getMinutes() == minute) {\n                        return true;\n                    }\n                }\n            } catch (RuntimeException e) {\n                LOGGER.debug(\"Error occured during project file date comparasion, reason {}.\", e.getMessage(), e);\n                // There is no documentation available for XML content. This is part of inessential feature, so do\n                // nothing, but return false\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Parse all enum values from IHC project file.\n     *\n     * @param doc IHC project file in XML format.\n     * @return enum dictionary.\n     */\n    public static Map<Integer, List<IhcEnumValue>> parseEnums(Document doc) {\n        Map<Integer, List<IhcEnumValue>> enumDictionary = new HashMap<>();\n        if (doc != null) {\n            NodeList nodes = doc.getElementsByTagName(\"enum_definition\");\n\n            // iterate enum definitions from project\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Element element = (Element) nodes.item(i);\n\n                int typedefId = Integer.parseInt(element.getAttribute(\"id\").replace(\"_0x\", \"\"), 16);\n                String enumName = element.getAttribute(\"name\");\n\n                List<IhcEnumValue> enumValues = new ArrayList<>();\n\n                NodeList name = element.getElementsByTagName(\"enum_value\");\n\n                for (int j = 0; j < name.getLength(); j++) {\n                    Element val = (Element) name.item(j);\n                    int id = Integer.parseInt(val.getAttribute(\"id\").replace(\"_0x\", \"\"), 16);\n                    String n = val.getAttribute(\"name\");\n                    IhcEnumValue enumVal = new IhcEnumValue(id, n);\n                    enumValues.add(enumVal);\n                }\n\n                LOGGER.debug(\"Enum values found: typedefId={}, name={}: {}\", typedefId, enumName, enumValues);\n                enumDictionary.put(typedefId, enumValues);\n            }\n        }\n        return enumDictionary;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.device;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Reads the device types from an xml file.\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\n@SuppressWarnings(\"null\")\npublic class DeviceTypeLoader {\n    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n    private HashMap<String, DeviceType> deviceTypes = new HashMap<>();\n    private @Nullable static DeviceTypeLoader deviceTypeLoader = null;\n\n    private DeviceTypeLoader() {\n    } // private so nobody can call it\n\n    /**\n     * Finds the device type for a given product key\n     *\n     * @param aProdKey product key to search for\n     * @return the device type, or null if not found\n     */\n    public @Nullable DeviceType getDeviceType(String aProdKey) {\n        return (deviceTypes.get(aProdKey));\n    }\n\n    /**\n     * Must call loadDeviceTypesXML() before calling this function!\n     *\n     * @return currently known device types\n     */\n    public HashMap<String, DeviceType> getDeviceTypes() {\n        return (deviceTypes);\n    }\n\n    /**\n     * Reads the device types from input stream and stores them in memory for\n     * later access.\n     *\n     * @param is the input stream from which to read\n     */\n    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        Document doc = dBuilder.parse(in);\n        doc.getDocumentElement().normalize();\n        Node root = doc.getDocumentElement();\n        NodeList nodes = root.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n                processDevice((Element) node);\n            }\n        }\n    }\n\n    /**\n     * Reads the device types from file and stores them in memory for later access.\n     *\n     * @param aFileName The name of the file to read from\n     * @throws ParserConfigurationException\n     * @throws SAXException\n     * @throws IOException\n     */\n    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n        File file = new File(aFileName);\n        InputStream in = new FileInputStream(file);\n        loadDeviceTypesXML(in);\n    }\n\n    /**\n     * Process device node\n     *\n     * @param e name of the element to process\n     * @throws SAXException\n     */\n    private void processDevice(Element e) throws SAXException {\n        String productKey = e.getAttribute(\"productKey\");\n        if (productKey.equals(\"\")) {\n            throw new SAXException(\"device in device_types file has no product key!\");\n        }\n        if (deviceTypes.containsKey(productKey)) {\n            logger.warn(\"overwriting previous definition of device {}\", productKey);\n            deviceTypes.remove(productKey);\n        }\n        DeviceType devType = new DeviceType(productKey);\n\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"model\")) {\n                devType.setModel(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"description\")) {\n                devType.setDescription(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"feature\")) {\n                processFeature(devType, subElement);\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                processFeatureGroup(devType, subElement);\n            }\n            deviceTypes.put(productKey, devType);\n        }\n    }\n\n    private String processFeature(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n        }\n        if (!name.equals(name.toLowerCase())) {\n            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n        }\n        if (!devType.addFeature(name, e.getTextContent())) {\n            throw new SAXException(\"duplicate feature: \" + name);\n        }\n        return (name);\n    }\n\n    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n        }\n        String type = e.getAttribute(\"type\");\n        if (type.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n        }\n        FeatureGroup fg = new FeatureGroup(name, type);\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"feature\")) {\n                fg.addFeature(processFeature(devType, subElement));\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                fg.addFeature(processFeatureGroup(devType, subElement));\n            }\n        }\n        if (!devType.addFeatureGroup(name, fg)) {\n            throw new SAXException(\"duplicate feature group \" + name);\n        }\n        return (name);\n    }\n\n    /**\n     * Helper function for debugging\n     */\n    private void logDeviceTypes() {\n        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n            logger.debug(\"{}\", msg);\n        }\n    }\n\n    /**\n     * Singleton instance function, creates DeviceTypeLoader\n     *\n     * @return DeviceTypeLoader singleton reference\n     */\n    @Nullable\n    public static synchronized DeviceTypeLoader instance() {\n        if (deviceTypeLoader == null) {\n            deviceTypeLoader = new DeviceTypeLoader();\n            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n            try {\n                deviceTypeLoader.loadDeviceTypesXML(input);\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"parser config error when reading device types xml file: \", e);\n            } catch (SAXException e) {\n                logger.warn(\"SAX exception when reading device types xml file: \", e);\n            } catch (IOException e) {\n                logger.warn(\"I/O exception when reading device types xml file: \", e);\n            }\n            logger.debug(\"loaded {} devices: \", deviceTypeLoader.getDeviceTypes().size());\n            deviceTypeLoader.logDeviceTypes();\n        }\n        return deviceTypeLoader;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.device;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.openhab.binding.insteon.internal.utils.Utils;\nimport org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Class that loads the device feature templates from an xml stream\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\npublic class FeatureTemplateLoader {\n    public static List<FeatureTemplate> readTemplates(InputStream input) throws IOException, ParsingException {\n        List<FeatureTemplate> features = new ArrayList<>();\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Parse it!\n            Document doc = dBuilder.parse(input);\n            doc.getDocumentElement().normalize();\n\n            Element root = doc.getDocumentElement();\n\n            NodeList nodes = root.getChildNodes();\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element e = (Element) node;\n                    if (e.getTagName().equals(\"feature\")) {\n                        features.add(parseFeature(e));\n                    }\n                }\n            }\n        } catch (SAXException e) {\n            throw new ParsingException(\"Failed to parse XML!\", e);\n        } catch (ParserConfigurationException e) {\n            throw new ParsingException(\"Got parser config exception! \", e);\n        }\n        return features;\n    }\n\n    private static FeatureTemplate parseFeature(Element e) throws ParsingException {\n        String name = e.getAttribute(\"name\");\n        boolean statusFeature = e.getAttribute(\"statusFeature\").equals(\"true\");\n        FeatureTemplate feature = new FeatureTemplate(name, statusFeature, e.getAttribute(\"timeout\"));\n\n        NodeList nodes = e.getChildNodes();\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element child = (Element) node;\n                if (child.getTagName().equals(\"message-handler\")) {\n                    parseMessageHandler(child, feature);\n                } else if (child.getTagName().equals(\"command-handler\")) {\n                    parseCommandHandler(child, feature);\n                } else if (child.getTagName().equals(\"message-dispatcher\")) {\n                    parseMessageDispatcher(child, feature);\n                } else if (child.getTagName().equals(\"poll-handler\")) {\n                    parsePollHandler(child, feature);\n                }\n            }\n        }\n\n        return feature;\n    }\n\n    private static HandlerEntry makeHandlerEntry(Element e) throws ParsingException {\n        String handler = e.getTextContent();\n        if (handler == null) {\n            throw new ParsingException(\"Could not find Handler for: \" + e.getTextContent());\n        }\n\n        NamedNodeMap attributes = e.getAttributes();\n        Map<String, @Nullable String> params = new HashMap<>();\n        for (int i = 0; i < attributes.getLength(); i++) {\n            Node n = attributes.item(i);\n            params.put(n.getNodeName(), n.getNodeValue());\n        }\n        return new HandlerEntry(handler, params);\n    }\n\n    private static void parseMessageHandler(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        if (e.getAttribute(\"default\").equals(\"true\")) {\n            f.setDefaultMessageHandler(he);\n        } else {\n            String attr = e.getAttribute(\"cmd\");\n            int command = (attr == null) ? 0 : Utils.from0xHexString(attr);\n            f.addMessageHandler(command, he);\n        }\n    }\n\n    private static void parseCommandHandler(Element e, FeatureTemplate f) throws ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        if (e.getAttribute(\"default\").equals(\"true\")) {\n            f.setDefaultCommandHandler(he);\n        } else {\n            Class<? extends Command> command = parseCommandClass(e.getAttribute(\"command\"));\n            f.addCommandHandler(command, he);\n        }\n    }\n\n    private static void parseMessageDispatcher(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        f.setMessageDispatcher(he);\n    }\n\n    private static void parsePollHandler(Element e, FeatureTemplate f) throws ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        f.setPollHandler(he);\n    }\n\n    private static Class<? extends Command> parseCommandClass(String c) throws ParsingException {\n        if (c.equals(\"OnOffType\")) {\n            return OnOffType.class;\n        } else if (c.equals(\"PercentType\")) {\n            return PercentType.class;\n        } else if (c.equals(\"DecimalType\")) {\n            return DecimalType.class;\n        } else if (c.equals(\"IncreaseDecreaseType\")) {\n            return IncreaseDecreaseType.class;\n        } else {\n            throw new ParsingException(\"Unknown Command Type\");\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.message;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map.Entry;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.insteon.internal.utils.Pair;\nimport org.openhab.binding.insteon.internal.utils.Utils.DataTypeParser;\nimport org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Reads the Msg definitions from an XML file\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\n@SuppressWarnings(\"null\")\npublic class XMLMessageReader {\n    /**\n     * Reads the message definitions from an xml file\n     *\n     * @param input input stream from which to read\n     * @return what was read from file: the map between clear text string and Msg objects\n     * @throws IOException couldn't read file etc\n     * @throws ParsingException something wrong with the file format\n     * @throws FieldException something wrong with the field definition\n     */\n    public static HashMap<String, Msg> readMessageDefinitions(InputStream input)\n            throws IOException, ParsingException, FieldException {\n        HashMap<String, Msg> messageMap = new HashMap<>();\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Parse it!\n            Document doc = dBuilder.parse(input);\n            doc.getDocumentElement().normalize();\n\n            Node root = doc.getDocumentElement();\n\n            NodeList nodes = root.getChildNodes();\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    if (node.getNodeName().equals(\"msg\")) {\n                        Pair<String, Msg> msgDef = readMessageDefinition((Element) node);\n                        messageMap.put(msgDef.getKey(), msgDef.getValue());\n                    }\n                }\n            }\n        } catch (SAXException e) {\n            throw new ParsingException(\"Failed to parse XML!\", e);\n        } catch (ParserConfigurationException e) {\n            throw new ParsingException(\"Got parser config exception! \", e);\n        }\n        return messageMap;\n    }\n\n    private static Pair<String, Msg> readMessageDefinition(Element msg) throws FieldException, ParsingException {\n        int length = 0;\n        int hlength = 0;\n        LinkedHashMap<Field, Object> fieldMap = new LinkedHashMap<>();\n        String dir = msg.getAttribute(\"direction\");\n        String name = msg.getAttribute(\"name\");\n        Msg.Direction direction = Msg.Direction.getDirectionFromString(dir);\n\n        if (msg.hasAttribute(\"length\")) {\n            length = Integer.parseInt(msg.getAttribute(\"length\"));\n        }\n\n        NodeList nodes = msg.getChildNodes();\n\n        int offset = 0;\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                if (node.getNodeName().equals(\"header\")) {\n                    int o = readHeaderElement((Element) node, fieldMap);\n                    hlength = o;\n                    // Increment the offset by the header length\n                    offset += o;\n                } else {\n                    Pair<Field, Object> field = readField((Element) node, offset);\n                    fieldMap.put(field.getKey(), field.getValue());\n                    // Increment the offset\n                    offset += field.getKey().getType().getSize();\n                }\n            }\n        }\n        if (offset != length) {\n            throw new ParsingException(\n                    \"Actual msg length \" + offset + \" differs from given msg length \" + length + \"!\");\n        }\n        if (length == 0) {\n            length = offset;\n        }\n\n        return new Pair<>(name, createMsg(fieldMap, length, hlength, direction));\n    }\n\n    private static int readHeaderElement(Element header, LinkedHashMap<Field, Object> fields) throws ParsingException {\n        int offset = 0;\n        int headerLen = Integer.parseInt(header.getAttribute(\"length\"));\n\n        NodeList nodes = header.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                @Nullable\n                Pair<Field, Object> definition = readField((Element) node, offset);\n                if (definition != null) {\n                    offset += definition.getKey().getType().getSize();\n                    fields.put(definition.getKey(), definition.getValue());\n                }\n            }\n        }\n        if (headerLen != offset) {\n            throw new ParsingException(\n                    \"Actual header length \" + offset + \" differs from given length \" + headerLen + \"!\");\n        }\n        return headerLen;\n    }\n\n    private static Pair<Field, Object> readField(Element field, int offset) {\n        DataType dType = DataType.getDataType(field.getTagName());\n        // Will return blank if no name attribute\n        String name = field.getAttribute(\"name\");\n        Field f = new Field(name, dType, offset);\n        // Now we have field, only need value\n        String sVal = field.getTextContent();\n        Object val = DataTypeParser.parseDataType(dType, sVal);\n        Pair<Field, Object> pair = new Pair<>(f, val);\n        return pair;\n    }\n\n    private static Msg createMsg(HashMap<Field, Object> values, int length, int headerLength, Msg.Direction dir)\n            throws FieldException {\n        Msg msg = new Msg(headerLength, new byte[length], length, dir);\n        for (Entry<Field, Object> e : values.entrySet()) {\n            Field f = e.getKey();\n            f.set(msg.getData(), e.getValue());\n            if (f.getName() != null && !f.getName().equals(\"\")) {\n                msg.addField(f);\n            }\n        }\n        return msg;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.onkyo.internal.handler;\n\nimport static org.openhab.binding.onkyo.internal.OnkyoBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.smarthome.core.audio.AudioHTTPServer;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.NextPreviousType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.library.types.PlayPauseType;\nimport org.eclipse.smarthome.core.library.types.RawType;\nimport org.eclipse.smarthome.core.library.types.RewindFastforwardType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.Channel;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.core.types.StateOption;\nimport org.eclipse.smarthome.core.types.UnDefType;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.onkyo.internal.OnkyoAlbumArt;\nimport org.openhab.binding.onkyo.internal.OnkyoConnection;\nimport org.openhab.binding.onkyo.internal.OnkyoEventListener;\nimport org.openhab.binding.onkyo.internal.OnkyoStateDescriptionProvider;\nimport org.openhab.binding.onkyo.internal.ServiceType;\nimport org.openhab.binding.onkyo.internal.automation.modules.OnkyoThingActionsService;\nimport org.openhab.binding.onkyo.internal.config.OnkyoDeviceConfiguration;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpCommand;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link OnkyoHandler} is responsible for handling commands, which are\n * sent to one of the channels.\n *\n * @author Paul Frank - Initial contribution\n * @author Marcel Verpaalen - parsing additional commands\n * @author Pauli Anttila - lot of refactoring\n * @author Stewart Cossey - add dynamic state description provider\n */\npublic class OnkyoHandler extends UpnpAudioSinkHandler implements OnkyoEventListener {\n\n    private final Logger logger = LoggerFactory.getLogger(OnkyoHandler.class);\n\n    private OnkyoDeviceConfiguration configuration;\n\n    private OnkyoConnection connection;\n    private ScheduledFuture<?> resourceUpdaterFuture;\n    @SuppressWarnings(\"unused\")\n    private int currentInput = -1;\n    private State volumeLevelZone1 = UnDefType.UNDEF;\n    private State volumeLevelZone2 = UnDefType.UNDEF;\n    private State volumeLevelZone3 = UnDefType.UNDEF;\n    private State lastPowerState = OnOffType.OFF;\n\n    private final OnkyoStateDescriptionProvider stateDescriptionProvider;\n\n    private final OnkyoAlbumArt onkyoAlbumArt = new OnkyoAlbumArt();\n\n    private static final int NET_USB_ID = 43;\n\n    public OnkyoHandler(Thing thing, UpnpIOService upnpIOService, AudioHTTPServer audioHTTPServer, String callbackUrl,\n            OnkyoStateDescriptionProvider stateDescriptionProvider) {\n        super(thing, upnpIOService, audioHTTPServer, callbackUrl);\n        this.stateDescriptionProvider = stateDescriptionProvider;\n    }\n\n    /**\n     * Initialize the state of the receiver.\n     */\n    @Override\n    public void initialize() {\n        logger.debug(\"Initializing handler for Onkyo Receiver\");\n        configuration = getConfigAs(OnkyoDeviceConfiguration.class);\n        logger.info(\"Using configuration: {}\", configuration.toString());\n\n        connection = new OnkyoConnection(configuration.ipAddress, configuration.port);\n        connection.addEventListener(this);\n\n        scheduler.execute(() -> {\n            logger.debug(\"Open connection to Onkyo Receiver @{}\", connection.getConnectionName());\n            connection.openConnection();\n            if (connection.isConnected()) {\n                updateStatus(ThingStatus.ONLINE);\n\n                sendCommand(EiscpCommand.INFO_QUERY);\n            }\n        });\n\n        if (configuration.refreshInterval > 0) {\n            // Start resource refresh updater\n            resourceUpdaterFuture = scheduler.scheduleWithFixedDelay(() -> {\n                try {\n                    logger.debug(\"Send resource update requests to Onkyo Receiver @{}\", connection.getConnectionName());\n                    checkStatus();\n                } catch (LinkageError e) {\n                    logger.warn(\"Failed to send resource update requests to Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), e.getMessage());\n                } catch (Exception ex) {\n                    logger.warn(\"Exception in resource refresh Thread Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), ex.getMessage());\n                }\n            }, configuration.refreshInterval, configuration.refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    @Override\n    public void dispose() {\n        super.dispose();\n        if (resourceUpdaterFuture != null) {\n            resourceUpdaterFuture.cancel(true);\n        }\n        if (connection != null) {\n            connection.removeEventListener(this);\n            connection.closeConnection();\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.debug(\"handleCommand for channel {}: {}\", channelUID.getId(), command.toString());\n        switch (channelUID.getId()) {\n            /*\n             * ZONE 1\n             */\n\n            case CHANNEL_POWER:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTE:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUME:\n                handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, command);\n                break;\n            case CHANNEL_INPUT:\n                if (command instanceof DecimalType) {\n                    selectInput(((DecimalType) command).intValue());\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.SOURCE_QUERY);\n                }\n                break;\n            case CHANNEL_LISTENMODE:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 2\n             */\n\n            case CHANNEL_POWERZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE2:\n                handleVolumeSet(EiscpCommand.Zone.ZONE2, volumeLevelZone2, command);\n                break;\n            case CHANNEL_INPUTZONE2:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 3\n             */\n\n            case CHANNEL_POWERZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE3:\n                handleVolumeSet(EiscpCommand.Zone.ZONE3, volumeLevelZone3, command);\n                break;\n            case CHANNEL_INPUTZONE3:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * NET PLAYER\n             */\n\n            case CHANNEL_CONTROL:\n                if (command instanceof PlayPauseType) {\n                    if (command.equals(PlayPauseType.PLAY)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PLAY);\n                    } else if (command.equals(PlayPauseType.PAUSE)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PAUSE);\n                    }\n                } else if (command instanceof NextPreviousType) {\n                    if (command.equals(NextPreviousType.NEXT)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKUP);\n                    } else if (command.equals(NextPreviousType.PREVIOUS)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKDWN);\n                    }\n                } else if (command instanceof RewindFastforwardType) {\n                    if (command.equals(RewindFastforwardType.REWIND)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_REW);\n                    } else if (command.equals(RewindFastforwardType.FASTFORWARD)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_FF);\n                    }\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_PLAY_STATUS_QUERY);\n                }\n                break;\n            case CHANNEL_PLAY_URI:\n                handlePlayUri(command);\n                break;\n            case CHANNEL_ALBUM_ART:\n            case CHANNEL_ALBUM_ART_URL:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_ALBUM_ART_QUERY);\n                }\n                break;\n            case CHANNEL_ARTIST:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ARTIST_QUERY);\n                }\n                break;\n            case CHANNEL_ALBUM:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ALBUM_QUERY);\n                }\n                break;\n            case CHANNEL_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_TITLE_QUERY);\n                }\n                break;\n            case CHANNEL_CURRENTPLAYINGTIME:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ELAPSEDTIME_QUERY);\n                }\n                break;\n\n            /*\n             * NET MENU\n             */\n\n            case CHANNEL_NET_MENU_CONTROL:\n                if (command instanceof StringType) {\n                    final String cmdName = command.toString();\n                    handleNetMenuCommand(cmdName);\n                }\n                break;\n            case CHANNEL_NET_MENU_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n                }\n                break;\n\n            /*\n             * MISC\n             */\n\n            default:\n                logger.debug(\"Command received for an unknown channel: {}\", channelUID.getId());\n                break;\n        }\n    }\n\n    private void populateInputs(NodeList selectorlist) {\n        List<StateOption> options = new ArrayList<>();\n\n        for (int i = 0; i < selectorlist.getLength(); i++) {\n            Element selectorItem = (Element) selectorlist.item(i);\n\n            options.add(new StateOption(String.valueOf(Integer.parseInt(selectorItem.getAttribute(\"id\"), 16)),\n                    selectorItem.getAttribute(\"name\")));\n        }\n        logger.debug(\"Got Input List from Receiver {}\", options);\n\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUT), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE2), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE3), options);\n    }\n\n    private void doPowerOnCheck(State state) {\n        if (configuration.refreshInterval == 0 && lastPowerState == OnOffType.OFF && state == OnOffType.ON) {\n            sendCommand(EiscpCommand.INFO_QUERY);\n        }\n        lastPowerState = state;\n    }\n\n    @Override\n    public void statusUpdateReceived(String ip, EiscpMessage data) {\n        logger.debug(\"Received status update from Onkyo Receiver @{}: data={}\", connection.getConnectionName(), data);\n\n        updateStatus(ThingStatus.ONLINE);\n\n        try {\n            EiscpCommand receivedCommand = null;\n\n            try {\n                receivedCommand = EiscpCommand.getCommandByCommandAndValueStr(data.getCommand(), \"\");\n            } catch (IllegalArgumentException ex) {\n                logger.debug(\"Received unknown status update from Onkyo Receiver @{}: data={}\",\n                        connection.getConnectionName(), data);\n                return;\n            }\n\n            logger.debug(\"Received command {}\", receivedCommand);\n\n            switch (receivedCommand) {\n                /*\n                 * ZONE 1\n                 */\n                case POWER:\n                    State powerState = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWER, powerState);\n                    doPowerOnCheck(powerState);\n                    break;\n                case MUTE:\n                    updateState(CHANNEL_MUTE, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case VOLUME:\n                    volumeLevelZone1 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUME, volumeLevelZone1);\n                    break;\n                case SOURCE:\n                    updateState(CHANNEL_INPUT, convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n                case LISTEN_MODE:\n                    updateState(CHANNEL_LISTENMODE,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 2\n                 */\n                case ZONE2_POWER:\n                    State powerZone2State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE2, powerZone2State);\n                    doPowerOnCheck(powerZone2State);\n                    break;\n                case ZONE2_MUTE:\n                    updateState(CHANNEL_MUTEZONE2, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE2_VOLUME:\n                    volumeLevelZone2 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE2, volumeLevelZone2);\n                    break;\n                case ZONE2_SOURCE:\n                    updateState(CHANNEL_INPUTZONE2,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 3\n                 */\n                case ZONE3_POWER:\n                    State powerZone3State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE3, powerZone3State);\n                    doPowerOnCheck(powerZone3State);\n                    break;\n                case ZONE3_MUTE:\n                    updateState(CHANNEL_MUTEZONE3, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE3_VOLUME:\n                    volumeLevelZone3 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE3, volumeLevelZone3);\n                    break;\n                case ZONE3_SOURCE:\n                    updateState(CHANNEL_INPUTZONE3,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * NET PLAYER\n                 */\n\n                case NETUSB_SONG_ARTIST:\n                    updateState(CHANNEL_ARTIST, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ALBUM:\n                    updateState(CHANNEL_ALBUM, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_TITLE:\n                    updateState(CHANNEL_TITLE, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ELAPSEDTIME:\n                    updateState(CHANNEL_CURRENTPLAYINGTIME,\n                            convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_PLAY_STATUS:\n                    updateState(CHANNEL_CONTROL, convertNetUsbPlayStatus(data.getValue()));\n                    break;\n                case NETUSB_ALBUM_ART:\n                    updateAlbumArt(data.getValue());\n                    break;\n                case NETUSB_TITLE:\n                    updateNetTitle(data.getValue());\n                    break;\n                case NETUSB_MENU:\n                    updateNetMenu(data.getValue());\n                    break;\n\n                /*\n                 * MISC\n                 */\n\n                case INFO:\n                    processInfo(data.getValue());\n                    logger.debug(\"Info message: '{}'\", data.getValue());\n                    break;\n\n                default:\n                    logger.debug(\"Received unhandled status update from Onkyo Receiver @{}: data={}\",\n                            connection.getConnectionName(), data);\n\n            }\n\n        } catch (Exception ex) {\n            logger.warn(\"Exception in statusUpdateReceived for Onkyo Receiver @{}. Cause: {}, data received: {}\",\n                    connection.getConnectionName(), ex.getMessage(), data);\n        }\n    }\n\n    private void processInfo(String infoXML) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            try (StringReader sr = new StringReader(infoXML)) {\n                InputSource is = new InputSource(sr);\n                Document doc = builder.parse(is);\n\n                NodeList selectableInputs = doc.getDocumentElement().getElementsByTagName(\"selector\");\n                populateInputs(selectableInputs);\n            }\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            logger.debug(\"Error occured during Info XML parsing.\", e);\n        }\n    }\n\n    @Override\n    public void connectionError(String ip, String errorMsg) {\n        logger.debug(\"Connection error occurred to Onkyo Receiver @{}\", ip);\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\n    }\n\n    private State convertDeviceValueToOpenHabState(String data, Class<?> classToConvert) {\n        State state = UnDefType.UNDEF;\n\n        try {\n            int index;\n\n            if (data.contentEquals(\"N/A\")) {\n                state = UnDefType.UNDEF;\n\n            } else if (classToConvert == OnOffType.class) {\n                index = Integer.parseInt(data, 16);\n                state = index == 0 ? OnOffType.OFF : OnOffType.ON;\n\n            } else if (classToConvert == DecimalType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new DecimalType(index);\n\n            } else if (classToConvert == PercentType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new PercentType(index);\n\n            } else if (classToConvert == StringType.class) {\n                state = new StringType(data);\n\n            }\n        } catch (Exception e) {\n            logger.debug(\"Cannot convert value '{}' to data type {}\", data, classToConvert);\n        }\n\n        logger.debug(\"Converted data '{}' to openHAB state '{}' ({})\", data, state, classToConvert);\n        return state;\n    }\n\n    private void handleNetMenuCommand(String cmdName) {\n        if (\"Up\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_UP);\n        } else if (\"Down\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_DOWN);\n        } else if (\"Select\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_SELECT);\n        } else if (\"PageUp\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_LEFT);\n        } else if (\"PageDown\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RIGHT);\n        } else if (\"Back\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RETURN);\n        } else if (cmdName.matches(\"Select[0-9]\")) {\n            int pos = Integer.parseInt(cmdName.substring(6));\n            sendCommand(EiscpCommand.NETUSB_MENU_SELECT, new DecimalType(pos));\n        } else {\n            logger.debug(\"Received unknown menucommand {}\", cmdName);\n        }\n    }\n\n    private void selectInput(int inputId) {\n        sendCommand(EiscpCommand.SOURCE_SET, new DecimalType(inputId));\n        currentInput = inputId;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void onInputChanged(int newInput) {\n        currentInput = newInput;\n\n        if (newInput != NET_USB_ID) {\n            resetNetMenu();\n\n            updateState(CHANNEL_ARTIST, UnDefType.UNDEF);\n            updateState(CHANNEL_ALBUM, UnDefType.UNDEF);\n            updateState(CHANNEL_TITLE, UnDefType.UNDEF);\n            updateState(CHANNEL_CURRENTPLAYINGTIME, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateAlbumArt(String data) {\n        onkyoAlbumArt.addFrame(data);\n\n        if (onkyoAlbumArt.isAlbumCoverReady()) {\n            try {\n                byte[] imgData = onkyoAlbumArt.getAlbumArt();\n                if (imgData != null && imgData.length > 0) {\n                    String mimeType = onkyoAlbumArt.getAlbumArtMimeType();\n                    if (mimeType.isEmpty()) {\n                        mimeType = guessMimeTypeFromData(imgData);\n                    }\n                    updateState(CHANNEL_ALBUM_ART, new RawType(imgData, mimeType));\n                } else {\n                    updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n                }\n            } catch (IllegalArgumentException e) {\n                updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n            }\n            onkyoAlbumArt.clearAlbumArt();\n        }\n\n        if (data.startsWith(\"2-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, new StringType(data.substring(2, data.length())));\n        } else if (data.startsWith(\"n-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        } else {\n            logger.debug(\"Not supported album art URL type: {}\", data.substring(0, 2));\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateNetTitle(String data) {\n        // first 2 characters is service type\n        int type = Integer.parseInt(data.substring(0, 2), 16);\n        ServiceType service = ServiceType.getType(type);\n\n        String title = \"\";\n        if (data.length() > 21) {\n            title = data.substring(22, data.length());\n        }\n\n        updateState(CHANNEL_NET_MENU_TITLE,\n                new StringType(service.toString() + ((title.length() > 0) ? \": \" + title : \"\")));\n    }\n\n    private void updateNetMenu(String data) {\n        switch (data.charAt(0)) {\n            case 'U':\n                String itemData = data.substring(3, data.length());\n                switch (data.charAt(1)) {\n                    case '0':\n                        updateState(CHANNEL_NET_MENU0, new StringType(itemData));\n                        break;\n                    case '1':\n                        updateState(CHANNEL_NET_MENU1, new StringType(itemData));\n                        break;\n                    case '2':\n                        updateState(CHANNEL_NET_MENU2, new StringType(itemData));\n                        break;\n                    case '3':\n                        updateState(CHANNEL_NET_MENU3, new StringType(itemData));\n                        break;\n                    case '4':\n                        updateState(CHANNEL_NET_MENU4, new StringType(itemData));\n                        break;\n                    case '5':\n                        updateState(CHANNEL_NET_MENU5, new StringType(itemData));\n                        break;\n                    case '6':\n                        updateState(CHANNEL_NET_MENU6, new StringType(itemData));\n                        break;\n                    case '7':\n                        updateState(CHANNEL_NET_MENU7, new StringType(itemData));\n                        break;\n                    case '8':\n                        updateState(CHANNEL_NET_MENU8, new StringType(itemData));\n                        break;\n                    case '9':\n                        updateState(CHANNEL_NET_MENU9, new StringType(itemData));\n                        break;\n                }\n                break;\n\n            case 'C':\n                updateMenuPosition(data);\n                break;\n        }\n    }\n\n    private void updateMenuPosition(String data) {\n        char position = data.charAt(1);\n        int pos = Character.getNumericValue(position);\n\n        logger.debug(\"Updating menu position to {}\", pos);\n\n        if (pos == -1) {\n            updateState(CHANNEL_NET_MENU_SELECTION, UnDefType.UNDEF);\n        } else {\n            updateState(CHANNEL_NET_MENU_SELECTION, new DecimalType(pos));\n        }\n\n        if (data.endsWith(\"P\")) {\n            resetNetMenu();\n        }\n    }\n\n    private void resetNetMenu() {\n        logger.debug(\"Reset net menu\");\n        updateState(CHANNEL_NET_MENU0, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU1, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU2, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU3, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU4, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU5, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU6, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU7, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU8, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU9, new StringType(\"-\"));\n    }\n\n    private State convertNetUsbPlayStatus(String data) {\n        State state = UnDefType.UNDEF;\n        switch (data.charAt(0)) {\n            case 'P':\n                state = PlayPauseType.PLAY;\n                break;\n            case 'p':\n            case 'S':\n                state = PlayPauseType.PAUSE;\n                break;\n            case 'F':\n                state = RewindFastforwardType.FASTFORWARD;\n                break;\n            case 'R':\n                state = RewindFastforwardType.REWIND;\n                break;\n\n        }\n        return state;\n    }\n\n    public void sendRawCommand(String command, String value) {\n        if (connection != null) {\n            connection.send(command, value);\n        } else {\n            logger.debug(\"Cannot send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand) {\n        if (connection != null) {\n            connection.send(deviceCommand.getCommand(), deviceCommand.getValue());\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand, Command command) {\n        if (connection != null) {\n            final String cmd = deviceCommand.getCommand();\n            String valTemplate = deviceCommand.getValue();\n            String val;\n\n            if (command instanceof OnOffType) {\n                val = String.format(valTemplate, command == OnOffType.ON ? 1 : 0);\n\n            } else if (command instanceof StringType) {\n                val = String.format(valTemplate, command);\n\n            } else if (command instanceof DecimalType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n\n            } else if (command instanceof PercentType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n            } else {\n                val = valTemplate;\n            }\n\n            logger.debug(\"Sending command '{}' with value '{}' to Onkyo Receiver @{}\", cmd, val,\n                    connection.getConnectionName());\n            connection.send(cmd, val);\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    /**\n     * Check the status of the AVR.\n     *\n     * @return\n     */\n    private void checkStatus() {\n        sendCommand(EiscpCommand.POWER_QUERY);\n\n        if (connection != null && connection.isConnected()) {\n            sendCommand(EiscpCommand.VOLUME_QUERY);\n            sendCommand(EiscpCommand.SOURCE_QUERY);\n            sendCommand(EiscpCommand.MUTE_QUERY);\n            sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n            sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n            sendCommand(EiscpCommand.INFO_QUERY);\n\n            if (isChannelAvailable(CHANNEL_POWERZONE2)) {\n                sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE2_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n            }\n\n            if (isChannelAvailable(CHANNEL_POWERZONE3)) {\n                sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE3_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n            }\n        } else {\n            updateStatus(ThingStatus.OFFLINE);\n        }\n    }\n\n    private boolean isChannelAvailable(String channel) {\n        List<Channel> channels = getThing().getChannels();\n        for (Channel c : channels) {\n            if (c.getUID().getId().equals(channel)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void handleVolumeSet(EiscpCommand.Zone zone, final State currentValue, final Command command) {\n        if (command instanceof PercentType) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_SET),\n                    downScaleVolume((PercentType) command));\n        } else if (command.equals(IncreaseDecreaseType.INCREASE)) {\n            if (currentValue instanceof PercentType) {\n                if (((DecimalType) currentValue).intValue() < configuration.volumeLimit) {\n                    sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_UP));\n                } else {\n                    logger.info(\"Volume level is limited to {}, ignore volume up command.\", configuration.volumeLimit);\n                }\n            }\n        } else if (command.equals(IncreaseDecreaseType.DECREASE)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_DOWN));\n        } else if (command.equals(OnOffType.OFF)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(OnOffType.ON)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(RefreshType.REFRESH)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_QUERY));\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_QUERY));\n        }\n    }\n\n    private State handleReceivedVolume(State volume) {\n        if (volume instanceof DecimalType) {\n            return upScaleVolume(((DecimalType) volume));\n        }\n        return volume;\n    }\n\n    private PercentType upScaleVolume(DecimalType volume) {\n        PercentType newVolume = scaleVolumeFromReceiver(volume);\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = 100d / configuration.volumeLimit;\n            PercentType unLimitedVolume = newVolume;\n            newVolume = new PercentType(((Double) (newVolume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Up scaled volume level '{}' to '{}'\", unLimitedVolume, newVolume);\n        }\n\n        return newVolume;\n    }\n\n    private DecimalType downScaleVolume(PercentType volume) {\n        PercentType limitedVolume = volume;\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = configuration.volumeLimit / 100d;\n            limitedVolume = new PercentType(((Double) (volume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Limited volume level '{}' to '{}'\", volume, limitedVolume);\n        }\n\n        return scaleVolumeForReceiver(limitedVolume);\n    }\n\n    private DecimalType scaleVolumeForReceiver(PercentType volume) {\n        return new DecimalType(((Double) (volume.doubleValue() * configuration.volumeScale)).intValue());\n    }\n\n    private PercentType scaleVolumeFromReceiver(DecimalType volume) {\n        return new PercentType(((Double) (volume.intValue() / configuration.volumeScale)).intValue());\n    }\n\n    @Override\n    public PercentType getVolume() throws IOException {\n        if (volumeLevelZone1 instanceof PercentType) {\n            return (PercentType) volumeLevelZone1;\n        }\n\n        throw new IOException();\n    }\n\n    @Override\n    public void setVolume(PercentType volume) throws IOException {\n        handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, downScaleVolume(volume));\n    }\n\n    private String guessMimeTypeFromData(byte[] data) {\n        String mimeType = HttpUtil.guessContentTypeFromData(data);\n        logger.debug(\"Mime type guess from content: {}\", mimeType);\n        if (mimeType == null) {\n            mimeType = RawType.DEFAULT_MIME_TYPE;\n        }\n        logger.debug(\"Mime type: {}\", mimeType);\n        return mimeType;\n    }\n\n    @Override\n    public Collection<Class<? extends ThingHandlerService>> getServices() {\n        return Collections.singletonList(OnkyoThingActionsService.class);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.samsungtv.internal.service;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link SamsungTvUtils} provides some utilities for internal use.\n *\n * @author Pauli Anttila - Initial contribution\n */\n@NonNullByDefault\npublic class SamsungTvUtils {\n\n    /**\n     * Build {@link String} type {@link HashMap} from variable number of\n     * {@link String}s.\n     *\n     * @param data\n     *            Variable number of {@link String} parameters which will be\n     *            added to hash map.\n     */\n    public static HashMap<String, String> buildHashMap(String... data) {\n        HashMap<String, String> result = new HashMap<>();\n\n        if (data.length % 2 != 0) {\n            throw new IllegalArgumentException(\"Odd number of arguments\");\n        }\n        String key = null;\n        Integer step = -1;\n\n        for (String value : data) {\n            step++;\n            switch (step % 2) {\n                case 0:\n                    if (value == null) {\n                        throw new IllegalArgumentException(\"Null key value\");\n                    }\n                    key = value;\n                    continue;\n                case 1:\n                    if (key != null) {\n                        result.put(key, value);\n                    }\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Build {@link Document} from {@link String} which contains XML content.\n     *\n     * @param xml\n     *            {@link String} which contains XML content.\n     * @return {@link Document} or null if convert has failed.\n     */\n    public static @Nullable Document loadXMLFromString(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xml));\n            return builder.parse(is);\n\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            // Silently ignore exception and return null.\n        }\n\n        return null;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.sonos.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link SonosXMLParser} is a class of helper functions\n * to parse XML data returned by the Zone Players\n *\n * @author Karel Goderis - Initial contribution\n */\n@NonNullByDefault\npublic class SonosXMLParser {\n\n    static final Logger LOGGER = LoggerFactory.getLogger(SonosXMLParser.class);\n\n    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n                    + \"xmlns:r=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\" \"\n                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n                    + \"<upnp:class>{3}</upnp:class>\"\n                    + \"<desc id=\\\"cdudn\\\" nameSpace=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\">\" + \"{4}</desc>\"\n                    + \"</item></DIDL-Lite>\");\n\n    private enum Element {\n        TITLE,\n        CLASS,\n        ALBUM,\n        ALBUM_ART_URI,\n        CREATOR,\n        RES,\n        TRACK_NUMBER,\n        RESMD,\n        DESC\n    }\n\n    private enum CurrentElement {\n        item,\n        res,\n        streamContent,\n        albumArtURI,\n        title,\n        upnpClass,\n        creator,\n        album,\n        albumArtist,\n        desc\n    }\n\n    /**\n     * @param xml\n     * @return a list of alarms from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosAlarm> getAlarmsFromStringResult(String xml) {\n        AlarmHandler handler = new AlarmHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        }\n        return handler.getAlarms();\n    }\n\n    /**\n     * @param xml\n     * @return a list of Entries from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosEntry> getEntriesFromString(String xml) {\n        EntryHandler handler = new EntryHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        }\n\n        return handler.getArtists();\n    }\n\n    /**\n     * Returns the meta data which is needed to play Pandora\n     * (and others?) favorites\n     *\n     * @param xml\n     * @return The value of the desc xml tag\n     * @throws SAXException\n     */\n    public static @Nullable SonosResourceMetaData getResourceMetaData(String xml) throws SAXException {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        ResourceMetaDataHandler handler = new ResourceMetaDataHandler();\n        reader.setContentHandler(handler);\n        try {\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Resource MetaData from String '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Resource MetaData from string '{}'\", xml);\n        }\n        return handler.getMetaData();\n    }\n\n    /**\n     * @param controller\n     * @param xml\n     * @return zone group from the given xml\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosZoneGroup> getZoneGroupFromXML(String xml) {\n        ZoneGroupHandler handler = new ZoneGroupHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        }\n\n        return handler.getGroups();\n    }\n\n    public static List<String> getRadioTimeFromXML(String xml) {\n        OpmlHandler handler = new OpmlHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        }\n\n        return handler.getTextFields();\n    }\n\n    public static Map<String, @Nullable String> getRenderingControlFromXML(String xml) {\n        RenderingControlEventHandler handler = new RenderingControlEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static Map<String, @Nullable String> getAVTransportFromXML(String xml) {\n        AVTransportEventHandler handler = new AVTransportEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static SonosMetaData getMetaDataFromXML(String xml) {\n        MetaDataHandler handler = new MetaDataHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        }\n\n        return handler.getMetaData();\n    }\n\n    public static List<SonosMusicService> getMusicServicesFromXML(String xml) {\n        MusicServiceHandler handler = new MusicServiceHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        }\n        return handler.getServices();\n    }\n\n    private static class EntryHandler extends DefaultHandler {\n\n        // Maintain a set of elements about which it is unuseful to complain about.\n        // This list will be initialized on the first failure case\n        private static @Nullable List<String> ignore;\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder res = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder trackNumber = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n\n        private List<SonosEntry> artists = new ArrayList<>();\n\n        EntryHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    element = Element.RES;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:creator\":\n                    element = Element.CREATOR;\n                    break;\n                case \"upnp:album\":\n                    element = Element.ALBUM;\n                    break;\n                case \"upnp:albumArtURI\":\n                    element = Element.ALBUM_ART_URI;\n                    break;\n                case \"upnp:originalTrackNumber\":\n                    element = Element.TRACK_NUMBER;\n                    break;\n                case \"r:resMD\":\n                    element = Element.RESMD;\n                    break;\n                default:\n                    List<String> curIgnore = ignore;\n                    if (curIgnore == null) {\n                        curIgnore = new ArrayList<>();\n                        curIgnore.add(\"DIDL-Lite\");\n                        curIgnore.add(\"type\");\n                        curIgnore.add(\"ordinal\");\n                        curIgnore.add(\"description\");\n                        ignore = curIgnore;\n                    }\n\n                    if (!curIgnore.contains(localName)) {\n                        LOGGER.debug(\"Did not recognise element named {}\", localName);\n                    }\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case RES:\n                    res.append(ch, start, length);\n                    break;\n                case ALBUM:\n                    album.append(ch, start, length);\n                    break;\n                case ALBUM_ART_URI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case CREATOR:\n                    creator.append(ch, start, length);\n                    break;\n                case TRACK_NUMBER:\n                    trackNumber.append(ch, start, length);\n                    break;\n                case RESMD:\n                    desc.append(ch, start, length);\n                    break;\n                case DESC:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if ((\"container\".equals(qName) || \"item\".equals(qName))) {\n                element = null;\n\n                int trackNumberVal = 0;\n                try {\n                    trackNumberVal = Integer.parseInt(trackNumber.toString());\n                } catch (Exception e) {\n                }\n\n                SonosResourceMetaData md = null;\n\n                // The resource description is needed for playing favorites on pandora\n                if (!desc.toString().isEmpty()) {\n                    try {\n                        md = getResourceMetaData(desc.toString());\n                    } catch (SAXException ignore) {\n                        LOGGER.debug(\"Failed to parse embeded\", ignore);\n                    }\n                }\n\n                artists.add(new SonosEntry(id, title.toString(), parentId, album.toString(), albumArtUri.toString(),\n                        creator.toString(), upnpClass.toString(), res.toString(), trackNumberVal, md));\n                title = new StringBuilder();\n                upnpClass = new StringBuilder();\n                res = new StringBuilder();\n                album = new StringBuilder();\n                albumArtUri = new StringBuilder();\n                creator = new StringBuilder();\n                trackNumber = new StringBuilder();\n                desc = new StringBuilder();\n            }\n        }\n\n        public List<SonosEntry> getArtists() {\n            return artists;\n        }\n    }\n\n    private static class ResourceMetaDataHandler extends DefaultHandler {\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n        private @Nullable SonosResourceMetaData metaData;\n\n        ResourceMetaDataHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"desc\":\n                    element = Element.DESC;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                default:\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case DESC:\n                    desc.append(ch, start, length);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"DIDL-Lite\".equals(qName)) {\n                metaData = new SonosResourceMetaData(id, parentId, title.toString(), upnpClass.toString(),\n                        desc.toString());\n                element = null;\n                desc = new StringBuilder();\n                upnpClass = new StringBuilder();\n                title = new StringBuilder();\n            }\n        }\n\n        public @Nullable SonosResourceMetaData getMetaData() {\n            return metaData;\n        }\n    }\n\n    private static class AlarmHandler extends DefaultHandler {\n\n        private @Nullable String id;\n        private String startTime = \"\";\n        private String duration = \"\";\n        private String recurrence = \"\";\n        private @Nullable String enabled;\n        private String roomUUID = \"\";\n        private String programURI = \"\";\n        private String programMetaData = \"\";\n        private String playMode = \"\";\n        private @Nullable String volume;\n        private @Nullable String includeLinkedZones;\n\n        private List<SonosAlarm> alarms = new ArrayList<>();\n\n        AlarmHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"Alarm\".equals(qName) && attributes != null) {\n                id = attributes.getValue(\"ID\");\n                duration = attributes.getValue(\"Duration\");\n                recurrence = attributes.getValue(\"Recurrence\");\n                startTime = attributes.getValue(\"StartTime\");\n                enabled = attributes.getValue(\"Enabled\");\n                roomUUID = attributes.getValue(\"RoomUUID\");\n                programURI = attributes.getValue(\"ProgramURI\");\n                programMetaData = attributes.getValue(\"ProgramMetaData\");\n                playMode = attributes.getValue(\"PlayMode\");\n                volume = attributes.getValue(\"Volume\");\n                includeLinkedZones = attributes.getValue(\"IncludeLinkedZones\");\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"Alarm\".equals(qName)) {\n                int finalID = 0;\n                int finalVolume = 0;\n                boolean finalEnabled = !\"0\".equals(enabled);\n                boolean finalIncludeLinkedZones = !\"0\".equals(includeLinkedZones);\n\n                try {\n                    finalID = Integer.parseInt(id);\n                    finalVolume = Integer.parseInt(volume);\n                } catch (Exception e) {\n                    LOGGER.debug(\"Error parsing Integer\");\n                }\n\n                alarms.add(new SonosAlarm(finalID, startTime, duration, recurrence, finalEnabled, roomUUID, programURI,\n                        programMetaData, playMode, finalVolume, finalIncludeLinkedZones));\n            }\n        }\n\n        public List<SonosAlarm> getAlarms() {\n            return alarms;\n        }\n    }\n\n    private static class ZoneGroupHandler extends DefaultHandler {\n\n        private final List<SonosZoneGroup> groups = new ArrayList<>();\n        private final List<String> currentGroupPlayers = new ArrayList<>();\n        private final List<String> currentGroupPlayerZones = new ArrayList<>();\n        private String coordinator = \"\";\n        private String groupId = \"\";\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"ZoneGroup\".equals(qName) && attributes != null) {\n                groupId = attributes.getValue(\"ID\");\n                coordinator = attributes.getValue(\"Coordinator\");\n            } else if (\"ZoneGroupMember\".equals(qName) && attributes != null) {\n                currentGroupPlayers.add(attributes.getValue(\"UUID\"));\n                String zoneName = attributes.getValue(\"ZoneName\");\n                if (zoneName != null) {\n                    currentGroupPlayerZones.add(zoneName);\n                }\n                String htInfoSet = attributes.getValue(\"HTSatChanMapSet\");\n                if (htInfoSet != null) {\n                    currentGroupPlayers.addAll(getAllHomeTheaterMembers(htInfoSet));\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"ZoneGroup\".equals(qName)) {\n                groups.add(new SonosZoneGroup(groupId, coordinator, currentGroupPlayers, currentGroupPlayerZones));\n                currentGroupPlayers.clear();\n                currentGroupPlayerZones.clear();\n            }\n        }\n\n        public List<SonosZoneGroup> getGroups() {\n            return groups;\n        }\n\n        private Set<String> getAllHomeTheaterMembers(String homeTheaterDescription) {\n            Set<String> homeTheaterMembers = new HashSet<>();\n            Matcher matcher = Pattern.compile(\"(RINCON_\\\\w+)\").matcher(homeTheaterDescription);\n            while (matcher.find()) {\n                String member = matcher.group();\n                homeTheaterMembers.add(member);\n            }\n            return homeTheaterMembers;\n        }\n    }\n\n    private static class OpmlHandler extends DefaultHandler {\n\n        // <opml version=\"1\">\n        // <head>\n        // <status>200</status>\n        //\n        // </head>\n        // <body>\n        // <outline type=\"text\" text=\"Q-Music 103.3\" guide_id=\"s2398\" key=\"station\"\n        // image=\"http://radiotime-logos.s3.amazonaws.com/s87683q.png\" preset_id=\"s2398\"/>\n        // <outline type=\"text\" text=\"Bjorn Verhoeven\" guide_id=\"p257265\" seconds_remaining=\"2230\" duration=\"7200\"\n        // key=\"show\"/>\n        // <outline type=\"text\" text=\"Top 40-Pop\"/>\n        // <outline type=\"text\" text=\"37m remaining\"/>\n        // <outline type=\"object\" text=\"NowPlaying\">\n        // <nowplaying>\n        // <logo>http://radiotime-logos.s3.amazonaws.com/s87683.png</logo>\n        // <twitter_id />\n        // </nowplaying>\n        // </outline>\n        // </body>\n        // </opml>\n\n        private final List<String> textFields = new ArrayList<>();\n        private @Nullable String textField;\n        private @Nullable String type;\n        // private String logo;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"outline\".equals(qName)) {\n                type = attributes == null ? null : attributes.getValue(\"type\");\n                if (\"text\".equals(type)) {\n                    textField = attributes == null ? null : attributes.getValue(\"text\");\n                } else {\n                    textField = null;\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"outline\".equals(qName)) {\n                String field = textField;\n                if (field != null) {\n                    textFields.add(field);\n                }\n            }\n        }\n\n        public List<String> getTextFields() {\n            return textFields;\n        }\n    }\n\n    private static class AVTransportEventHandler extends DefaultHandler {\n\n        /*\n         * <Event xmlns=\"urn:schemas-upnp-org:metadata-1-0/AVT/\" xmlns:r=\"urn:schemas-rinconnetworks-com:metadata-1-0/\">\n         * <InstanceID val=\"0\">\n         * <TransportState val=\"PLAYING\"/>\n         * <CurrentPlayMode val=\"NORMAL\"/>\n         * <CurrentPlayMode val=\"0\"/>\n         * <NumberOfTracks val=\"29\"/>\n         * <CurrentTrack val=\"12\"/>\n         * <CurrentSection val=\"0\"/>\n         * <CurrentTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma\"\n         * />\n         * <CurrentTrackDuration val=\"0:03:02\"/>\n         * <CurrentTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:03:02&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma&lt;/res&gt;&lt;r:streamContent&gt;&lt;/r:streamContent&gt;&lt;dc:title&gt;Broken Box&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:NextTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&apos;&apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&apos;&apos;.wma\"\n         * /><r:NextTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:04:56&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&amp;apos;&amp;apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&amp;apos;&amp;apos;.wma&lt;/res&gt;&lt;dc:title&gt;&amp;apos;&amp;apos;You Got A Killer Scene There, Man...&amp;apos;&amp;apos;&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:EnqueuedTransportURI\n         * val=\"x-rincon-playlist:RINCON_000E582126EE01400#A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age\"/><r:\n         * EnqueuedTransportURIMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age&quot; parentID=&quot;A:ALBUMARTIST&quot; restricted=&quot;true&quot;&gt;&lt;dc:title&gt;Queens Of The Stone Age&lt;/dc:title&gt;&lt;upnp:class&gt;object.container&lt;/upnp:class&gt;&lt;desc id=&quot;cdudn&quot; nameSpace=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot;&gt;RINCON_AssociatedZPUDN&lt;/desc&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * />\n         * <PlaybackStorageMedium val=\"NETWORK\"/>\n         * <AVTransportURI val=\"x-rincon-queue:RINCON_000E5812BC1801400#0\"/>\n         * <AVTransportURIMetaData val=\"\"/>\n         * <CurrentTransportActions val=\"Play, Stop, Pause, Seek, Next, Previous\"/>\n         * <TransportStatus val=\"OK\"/>\n         * <r:SleepTimerGeneration val=\"0\"/>\n         * <r:AlarmRunning val=\"0\"/>\n         * <r:SnoozeRunning val=\"0\"/>\n         * <r:RestartPending val=\"0\"/>\n         * <TransportPlaySpeed val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentMediaDuration val=\"NOT_IMPLEMENTED\"/>\n         * <RecordStorageMedium val=\"NOT_IMPLEMENTED\"/>\n         * <PossiblePlaybackStorageMedia val=\"NONE, NETWORK\"/>\n         * <PossibleRecordStorageMedia val=\"NOT_IMPLEMENTED\"/>\n         * <RecordMediumWriteStatus val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentRecordQualityMode val=\"NOT_IMPLEMENTED\"/>\n         * <PossibleRecordQualityModes val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURI val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURIMetaData val=\"NOT_IMPLEMENTED\"/>\n         * </InstanceID>\n         * </Event>\n         */\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            /*\n             * The events are all of the form <qName val=\"value\"/> so we can get all\n             * the info we need from here.\n             */\n            if (localName == null) {\n                // this means that localName isn't defined in EventType, which is expected for some elements\n                LOGGER.info(\"{} is not defined in EventType. \", localName);\n            } else {\n                String val = attributes == null ? null : attributes.getValue(\"val\");\n                if (val != null) {\n                    changes.put(localName, val);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MetaDataHandler extends DefaultHandler {\n\n        private @Nullable CurrentElement currentElement;\n\n        private String id = \"-1\";\n        private String parentId = \"-1\";\n        private StringBuilder resource = new StringBuilder();\n        private StringBuilder streamContent = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtist = new StringBuilder();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = localName == null ? \"\" : localName;\n            switch (name) {\n                case \"item\":\n                    currentElement = CurrentElement.item;\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    currentElement = CurrentElement.res;\n                    break;\n                case \"streamContent\":\n                    currentElement = CurrentElement.streamContent;\n                    break;\n                case \"albumArtURI\":\n                    currentElement = CurrentElement.albumArtURI;\n                    break;\n                case \"title\":\n                    currentElement = CurrentElement.title;\n                    break;\n                case \"class\":\n                    currentElement = CurrentElement.upnpClass;\n                    break;\n                case \"creator\":\n                    currentElement = CurrentElement.creator;\n                    break;\n                case \"album\":\n                    currentElement = CurrentElement.album;\n                    break;\n                case \"albumArtist\":\n                    currentElement = CurrentElement.albumArtist;\n                    break;\n                default:\n                    // unknown element\n                    currentElement = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            CurrentElement elt = currentElement;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case item:\n                    break;\n                case res:\n                    resource.append(ch, start, length);\n                    break;\n                case streamContent:\n                    streamContent.append(ch, start, length);\n                    break;\n                case albumArtURI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case title:\n                    title.append(ch, start, length);\n                    break;\n                case upnpClass:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case creator:\n                    creator.append(ch, start, length);\n                    break;\n                case album:\n                    album.append(ch, start, length);\n                    break;\n                case albumArtist:\n                    albumArtist.append(ch, start, length);\n                    break;\n                case desc:\n                    break;\n            }\n        }\n\n        public SonosMetaData getMetaData() {\n            return new SonosMetaData(id, parentId, resource.toString(), streamContent.toString(),\n                    albumArtUri.toString(), title.toString(), upnpClass.toString(), creator.toString(),\n                    album.toString(), albumArtist.toString());\n        }\n    }\n\n    private static class RenderingControlEventHandler extends DefaultHandler {\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        private boolean getPresetName = false;\n        private @Nullable String presetName;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (qName == null) {\n                return;\n            }\n            String channel;\n            String val;\n            switch (qName) {\n                case \"Volume\":\n                case \"Mute\":\n                case \"Loudness\":\n                    channel = attributes == null ? null : attributes.getValue(\"channel\");\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (channel != null && val != null) {\n                        changes.put(qName + channel, val);\n                    }\n                    break;\n                case \"Bass\":\n                case \"Treble\":\n                case \"OutputFixed\":\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (val != null) {\n                        changes.put(qName, val);\n                    }\n                    break;\n                case \"PresetNameList\":\n                    getPresetName = true;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (getPresetName) {\n                presetName = new String(ch, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (getPresetName) {\n                getPresetName = false;\n                String preset = presetName;\n                if (qName != null && preset != null) {\n                    changes.put(qName, preset);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MusicServiceHandler extends DefaultHandler {\n\n        private final List<SonosMusicService> services = new ArrayList<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            // All services are of the form <services Id=\"value\" Name=\"value\">...</Service>\n            if (\"Service\".equals(qName) && attributes != null && attributes.getValue(\"Id\") != null\n                    && attributes.getValue(\"Name\") != null) {\n                services.add(new SonosMusicService(attributes.getValue(\"Id\"), attributes.getValue(\"Name\")));\n            }\n        }\n\n        public List<SonosMusicService> getServices() {\n            return services;\n        }\n    }\n\n    public static @Nullable String getRoomName(String descriptorXML) {\n        RoomNameHandler roomNameHandler = new RoomNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(roomNameHandler);\n            URL url = new URL(descriptorXML);\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos room name from string '{}'\", descriptorXML);\n        }\n        return roomNameHandler.getRoomName();\n    }\n\n    private static class RoomNameHandler extends DefaultHandler {\n\n        private @Nullable String roomName;\n        private boolean roomNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"roomName\".equalsIgnoreCase(localName)) {\n                roomNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (roomNameTag) {\n                roomName = new String(ch, start, length);\n                roomNameTag = false;\n            }\n        }\n\n        public @Nullable String getRoomName() {\n            return roomName;\n        }\n    }\n\n    public static @Nullable String parseModelDescription(URL descriptorURL) {\n        ModelNameHandler modelNameHandler = new ModelNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(modelNameHandler);\n            URL url = new URL(descriptorURL.toString());\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos model name from string '{}'\", descriptorURL.toString());\n        }\n        return modelNameHandler.getModelName();\n    }\n\n    private static class ModelNameHandler extends DefaultHandler {\n\n        private @Nullable String modelName;\n        private boolean modelNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"modelName\".equalsIgnoreCase(localName)) {\n                modelNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (modelNameTag) {\n                modelName = new String(ch, start, length);\n                modelNameTag = false;\n            }\n        }\n\n        public @Nullable String getModelName() {\n            return modelName;\n        }\n    }\n\n    /**\n     * The model name provided by upnp is formated like in the example form \"Sonos PLAY:1\" or \"Sonos PLAYBAR\"\n     *\n     * @param sonosModelName Sonos model name provided via upnp device\n     * @return the extracted players model name without column (:) character used for ThingType creation\n     */\n    public static String extractModelName(String sonosModelName) {\n        String ret = sonosModelName;\n        Matcher matcher = Pattern.compile(\"\\\\s(.*)\").matcher(ret);\n        if (matcher.find()) {\n            ret = matcher.group(1);\n        }\n        if (ret.contains(\":\")) {\n            ret = ret.replace(\":\", \"\");\n        }\n        return ret;\n    }\n\n    public static String compileMetadataString(SonosEntry entry) {\n        /**\n         * If the entry contains resource meta data we will override this with\n         * that data.\n         */\n        String id = entry.getId();\n        String parentId = entry.getParentId();\n        String title = entry.getTitle();\n        String upnpClass = entry.getUpnpClass();\n\n        /**\n         * By default 'RINCON_AssociatedZPUDN' is used for most operations,\n         * however when playing a favorite entry that is associated withh a\n         * subscription like pandora we need to use the desc string asscoiated\n         * with that item.\n         */\n        String desc = entry.getDesc();\n        if (desc == null) {\n            desc = \"RINCON_AssociatedZPUDN\";\n        }\n\n        /**\n         * If resource meta data exists, use it over the parent data\n         */\n        SonosResourceMetaData resourceMetaData = entry.getResourceMetaData();\n        if (resourceMetaData != null) {\n            id = resourceMetaData.getId();\n            parentId = resourceMetaData.getParentId();\n            title = resourceMetaData.getTitle();\n            desc = resourceMetaData.getDesc();\n            upnpClass = resourceMetaData.getUpnpClass();\n        }\n\n        title = StringEscapeUtils.escapeXml(title);\n\n        String metadata = METADATA_FORMAT.format(new Object[] { id, parentId, title, upnpClass, desc });\n\n        return metadata;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.tellstick.internal.live;\n\nimport java.math.BigDecimal;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.asynchttpclient.AsyncHttpClient;\nimport org.asynchttpclient.AsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClient;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig.Builder;\nimport org.asynchttpclient.Response;\nimport org.asynchttpclient.oauth.ConsumerKey;\nimport org.asynchttpclient.oauth.OAuthSignatureCalculator;\nimport org.asynchttpclient.oauth.RequestToken;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.State;\nimport org.openhab.binding.tellstick.internal.TelldusBindingException;\nimport org.openhab.binding.tellstick.internal.handler.TelldusDeviceController;\nimport org.openhab.binding.tellstick.internal.live.xml.TelldusLiveResponse;\nimport org.openhab.binding.tellstick.internal.live.xml.TellstickNetDevice;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.tellstick.JNA;\nimport org.tellstick.device.TellstickDevice;\nimport org.tellstick.device.TellstickDeviceEvent;\nimport org.tellstick.device.TellstickException;\nimport org.tellstick.device.TellstickSensorEvent;\nimport org.tellstick.device.iface.Device;\nimport org.tellstick.device.iface.DeviceChangeListener;\nimport org.tellstick.device.iface.SensorListener;\nimport org.tellstick.device.iface.SwitchableDevice;\n\n/**\n * {@link TelldusLiveDeviceController} is the communication with Telldus Live service (Tellstick.NET and ZNET)\n * This controller uses XML based Rest API to communicate with Telldus Live.\n *\n * @author Jarle Hjortland - Initial contribution\n */\npublic class TelldusLiveDeviceController implements DeviceChangeListener, SensorListener, TelldusDeviceController {\n    private final Logger logger = LoggerFactory.getLogger(TelldusLiveDeviceController.class);\n    private long lastSend = 0;\n    public static final long DEFAULT_INTERVAL_BETWEEN_SEND = 250;\n    static final int REQUEST_TIMEOUT_MS = 5000;\n    private AsyncHttpClient client;\n    static final String HTTP_API_TELLDUS_COM_XML = \"http://api.telldus.com/xml/\";\n    static final String HTTP_TELLDUS_CLIENTS = HTTP_API_TELLDUS_COM_XML + \"clients/list\";\n    static final String HTTP_TELLDUS_DEVICES = HTTP_API_TELLDUS_COM_XML + \"devices/list?supportedMethods=19\";\n    static final String HTTP_TELLDUS_SENSORS = HTTP_API_TELLDUS_COM_XML\n            + \"sensors/list?includeValues=1&includeScale=1&includeUnit=1\";\n    static final String HTTP_TELLDUS_SENSOR_INFO = HTTP_API_TELLDUS_COM_XML + \"sensor/info\";\n    static final String HTTP_TELLDUS_DEVICE_DIM = HTTP_API_TELLDUS_COM_XML + \"device/dim?id=%d&level=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNOFF = HTTP_API_TELLDUS_COM_XML + \"device/turnOff?id=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNON = HTTP_API_TELLDUS_COM_XML + \"device/turnOn?id=%d\";\n    private static final int MAX_RETRIES = 3;\n\n    public TelldusLiveDeviceController() {\n    }\n\n    @Override\n    public void dispose() {\n        try {\n            client.close();\n        } catch (Exception e) {\n            logger.error(\"Failed to close client\", e);\n        }\n    }\n\n    void connectHttpClient(String publicKey, String privateKey, String token, String tokenSecret) {\n        ConsumerKey consumer = new ConsumerKey(publicKey, privateKey);\n        RequestToken user = new RequestToken(token, tokenSecret);\n        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);\n        this.client = new DefaultAsyncHttpClient(createAsyncHttpClientConfig());\n        try {\n            this.client.setSignatureCalculator(calc);\n            Response response = client.prepareGet(HTTP_TELLDUS_CLIENTS).execute().get();\n            logger.debug(\"Response {} statusText {}\", response.getResponseBody(), response.getStatusText());\n        } catch (InterruptedException | ExecutionException e) {\n            logger.error(\"Failed to connect\", e);\n        }\n    }\n\n    private AsyncHttpClientConfig createAsyncHttpClientConfig() {\n        Builder builder = new DefaultAsyncHttpClientConfig.Builder();\n        builder.setConnectTimeout(REQUEST_TIMEOUT_MS);\n        return builder.build();\n    }\n\n    @Override\n    public void handleSendEvent(Device device, int resendCount, boolean isdimmer, Command command)\n            throws TellstickException {\n        logger.info(\"Send {} to {}\", command, device);\n        if (device instanceof TellstickNetDevice) {\n            if (command == OnOffType.ON) {\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            } else if (command instanceof PercentType) {\n                dim(device, (PercentType) command);\n            } else if (command instanceof IncreaseDecreaseType) {\n                increaseDecrease(device, ((IncreaseDecreaseType) command));\n            }\n        } else if (device instanceof SwitchableDevice) {\n            if (command == OnOffType.ON) {\n                if (isdimmer) {\n                    logger.debug(\"Turn off first in case it is allready on\");\n                    turnOff(device);\n                }\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            }\n        } else {\n            logger.warn(\"Cannot send to {}\", device);\n        }\n    }\n\n    private void increaseDecrease(Device dev, IncreaseDecreaseType increaseDecreaseType) throws TellstickException {\n        String strValue = ((TellstickDevice) dev).getData();\n        double value = 0;\n        if (strValue != null) {\n            value = Double.valueOf(strValue);\n        }\n        int percent = (int) Math.round((value / 255) * 100);\n        if (IncreaseDecreaseType.INCREASE == increaseDecreaseType) {\n            percent = Math.min(percent + 10, 100);\n        } else if (IncreaseDecreaseType.DECREASE == increaseDecreaseType) {\n            percent = Math.max(percent - 10, 0);\n        }\n        dim(dev, new PercentType(percent));\n    }\n\n    private void dim(Device dev, PercentType command) throws TellstickException {\n        double value = command.doubleValue();\n\n        // 0 means OFF and 100 means ON\n        if (value == 0 && dev instanceof TellstickNetDevice) {\n            turnOff(dev);\n        } else if (value == 100 && dev instanceof TellstickNetDevice) {\n            turnOn(dev);\n        } else if (dev instanceof TellstickNetDevice\n                && (((TellstickNetDevice) dev).getMethods() & JNA.CLibrary.TELLSTICK_DIM) > 0) {\n            long tdVal = Math.round((value / 100) * 255);\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_DIM, dev.getId(), tdVal),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send DIM to \" + dev);\n        }\n    }\n\n    private void turnOff(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNOFF, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send OFF to \" + dev);\n        }\n    }\n\n    private void handleResponse(TellstickNetDevice device, TelldusLiveResponse response) throws TellstickException {\n        if (response == null || (response.status == null && response.error == null)) {\n            throw new TelldusBindingException(\"No response \" + response);\n        } else if (response.error != null) {\n            if (response.error.equals(\"The client for this device is currently offline\")) {\n                device.setOnline(false);\n                device.setUpdated(true);\n            }\n            throw new TelldusBindingException(\"Error \" + response.error);\n        } else if (!response.status.trim().equals(\"success\")) {\n            throw new TelldusBindingException(\"Response \" + response.status);\n        }\n    }\n\n    private void turnOn(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNON, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send ON to \" + dev);\n        }\n    }\n\n    @Override\n    public State calcState(Device dev) {\n        TellstickNetDevice device = (TellstickNetDevice) dev;\n        State st = null;\n        if (device.getOnline()) {\n            switch (device.getState()) {\n                case JNA.CLibrary.TELLSTICK_TURNON:\n                    st = OnOffType.ON;\n                    break;\n                case JNA.CLibrary.TELLSTICK_TURNOFF:\n                    st = OnOffType.OFF;\n                    break;\n                case JNA.CLibrary.TELLSTICK_DIM:\n                    BigDecimal dimValue = new BigDecimal(device.getStatevalue());\n                    if (dimValue.intValue() == 0) {\n                        st = OnOffType.OFF;\n                    } else if (dimValue.intValue() >= 255) {\n                        st = OnOffType.ON;\n                    } else {\n                        st = OnOffType.ON;\n                    }\n                    break;\n                default:\n                    logger.warn(\"Could not handle {} for {}\", device.getState(), device);\n            }\n        }\n        return st;\n    }\n\n    @Override\n    public BigDecimal calcDimValue(Device device) {\n        BigDecimal dimValue = new BigDecimal(0);\n        switch (((TellstickNetDevice) device).getState()) {\n            case JNA.CLibrary.TELLSTICK_TURNON:\n                dimValue = new BigDecimal(100);\n                break;\n            case JNA.CLibrary.TELLSTICK_TURNOFF:\n                break;\n            case JNA.CLibrary.TELLSTICK_DIM:\n                dimValue = new BigDecimal(((TellstickNetDevice) device).getStatevalue());\n                dimValue = dimValue.multiply(new BigDecimal(100));\n                dimValue = dimValue.divide(new BigDecimal(255), 0, BigDecimal.ROUND_HALF_UP);\n                break;\n            default:\n                logger.warn(\"Could not handle {} for {}\", (((TellstickNetDevice) device).getState()), device);\n        }\n        return dimValue;\n    }\n\n    public long getLastSend() {\n        return lastSend;\n    }\n\n    public void setLastSend(long currentTimeMillis) {\n        lastSend = currentTimeMillis;\n    }\n\n    @Override\n    public void onRequest(TellstickSensorEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    @Override\n    public void onRequest(TellstickDeviceEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    <T> T callRestMethod(String uri, Class<T> response) throws TelldusLiveException {\n        T resultObj = null;\n        try {\n            for (int i = 0; i < MAX_RETRIES; i++) {\n                try {\n                    resultObj = innerCallRest(uri, response);\n                    break;\n                } catch (TimeoutException e) {\n                    logger.warn(\"TimeoutException error in get\", e);\n                } catch (InterruptedException e) {\n                    logger.warn(\"InterruptedException error in get\", e);\n                }\n            }\n        } catch (JAXBException e) {\n            logger.warn(\"Encoding error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (XMLStreamException e) {\n            logger.warn(\"Communication error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (ExecutionException e) {\n            logger.warn(\"ExecutionException error in get\", e);\n            throw new TelldusLiveException(e);\n        }\n        return resultObj;\n    }\n\n    private <T> T innerCallRest(String uri, Class<T> response) throws InterruptedException, ExecutionException,\n            TimeoutException, JAXBException, FactoryConfigurationError, XMLStreamException {\n        Future<Response> future = client.prepareGet(uri).execute();\n        Response resp = future.get(REQUEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        // TelldusLiveHandler.logger.info(\"Devices\" + resp.getResponseBody());\n        JAXBContext jc = JAXBContext.newInstance(response);\n        XMLInputFactory xif = XMLInputFactory.newInstance();\n        XMLStreamReader xsr = xif.createXMLStreamReader(resp.getResponseBodyAsStream());\n        // xsr = new PropertyRenamerDelegate(xsr);\n\n        @SuppressWarnings(\"unchecked\")\n        T obj = (T) jc.createUnmarshaller().unmarshal(xsr);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Request [{}] Response:{}\", uri, resp.getResponseBody());\n        }\n        return obj;\n    }\n\n    private void logResponse(String uri, Exception e) {\n        if (e != null) {\n            logger.warn(\"Request [{}] Failure:{}\", uri, e.getMessage());\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.vitotronic.internal.handler;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport org.eclipse.smarthome.core.thing.Bridge;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.openhab.binding.vitotronic.internal.VitotronicBindingConfiguration;\nimport org.openhab.binding.vitotronic.internal.discovery.VitotronicDiscoveryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link VitotronicBridgeHandler} class handles the connection to the\n * optolink adapter.\n *\n * @author Stefan Andres - Initial contribution\n */\npublic class VitotronicBridgeHandler extends BaseBridgeHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(VitotronicBridgeHandler.class);\n\n    private String ipAddress;\n    private int port;\n    private int refreshInterval = 300;\n    private Socket socket;\n    private PrintStream out;\n    private InputStream inStream;\n    private boolean isConnect = false;\n    private boolean isDiscover = false;\n\n    public VitotronicBridgeHandler(Bridge bridge) {\n        super(bridge);\n    }\n\n    @Override\n    public void updateStatus(ThingStatus status) {\n        super.updateStatus(status);\n        updateThingHandlersStatus(status);\n    }\n\n    public void updateStatus() {\n        if (isConnect) {\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            updateStatus(ThingStatus.OFFLINE);\n        }\n    }\n\n    // Managing Thing Discovery Service\n\n    private VitotronicDiscoveryService discoveryService = null;\n\n    public void registerDiscoveryService(VitotronicDiscoveryService discoveryService) {\n        if (discoveryService == null) {\n            throw new IllegalArgumentException(\"It's not allowed to pass a null ThingDiscoveryListener.\");\n        } else {\n            this.discoveryService = discoveryService;\n            logger.trace(\"register Discovery Service\");\n        }\n    }\n\n    public void unregisterDiscoveryService() {\n        discoveryService = null;\n        logger.trace(\"unregister Discovery Service\");\n    }\n\n    // Handles Thing discovery\n\n    private void createThing(String thingType, String thingID) {\n        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n        if (discoveryService != null) {\n            discoveryService.addVitotronicThing(thingType, thingID);\n        }\n    }\n\n    // Managing ThingHandler\n\n    private Map<String, VitotronicThingHandler> thingHandlerMap = new HashMap<>();\n\n    public void registerVitotronicThingListener(VitotronicThingHandler thingHandler) {\n        if (thingHandler == null) {\n            throw new IllegalArgumentException(\"It's not allowed to pass a null ThingHandler.\");\n        } else {\n            String thingID = thingHandler.getThing().getUID().getId();\n            if (thingHandlerMap.get(thingID) == null) {\n                thingHandlerMap.put(thingID, thingHandler);\n                logger.trace(\"register thingHandler for thing: {}\", thingID);\n                updateThingHandlerStatus(thingHandler, this.getStatus());\n                sendSocketData(\"get \" + thingID);\n            } else {\n                logger.trace(\"thingHandler for thing: '{}' already registered\", thingID);\n            }\n        }\n    }\n\n    public void unregisterThingListener(VitotronicThingHandler thingHandler) {\n        if (thingHandler != null) {\n            String thingID = thingHandler.getThing().getUID().getId();\n            if (thingHandlerMap.remove(thingID) == null) {\n                logger.trace(\"thingHandler for thing: {} not registered\", thingID);\n            }\n        }\n    }\n\n    private void updateThingHandlerStatus(VitotronicThingHandler thingHandler, ThingStatus status) {\n        thingHandler.updateStatus(status);\n    }\n\n    private void updateThingHandlersStatus(ThingStatus status) {\n        for (Map.Entry<String, VitotronicThingHandler> entry : thingHandlerMap.entrySet()) {\n            updateThingHandlerStatus(entry.getValue(), status);\n        }\n    }\n\n    // Background Runables\n\n    private ScheduledFuture<?> pollingJob;\n\n    private Runnable pollingRunnable = () -> {\n        logger.trace(\"Polling job called\");\n        if (!isConnect) {\n            startSocketReceiver();\n            try {\n                Thread.sleep(5000); // Wait for connection .\n            } catch (InterruptedException e) {\n            }\n        }\n        if (isConnect) {\n            scanThings();\n            refreshData();\n        }\n    };\n\n    private synchronized void startAutomaticRefresh() {\n        if (pollingJob == null || pollingJob.isCancelled()) {\n            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private void refreshData() {\n        logger.trace(\"Job: refresh Data...\");\n        for (Map.Entry<String, VitotronicThingHandler> entry : thingHandlerMap.entrySet()) {\n            String channelList = entry.getValue().getActiveChannelListAsString();\n            String thingId = entry.getValue().getThing().getUID().getId();\n            if (isConnect && (channelList.length() > 0)) {\n                logger.trace(\"Get Data for '{}'\", thingId);\n                sendSocketData(\"get \" + thingId + \" \" + channelList);\n            }\n        }\n    }\n\n    // Methods for ThingHandler\n\n    public void scanThings() {\n        logger.trace(\"Job: Discover Things...\");\n        if (!isDiscover) {\n            sendSocketData(\"list\");\n            isDiscover = true;\n        }\n    }\n\n    public ThingStatus getStatus() {\n        return getThing().getStatus();\n    }\n\n    public void updateChannel(String thingId, String channelId, String value) {\n        sendSocketData(\"set \" + thingId + \":\" + channelId + \" \" + value);\n    }\n\n    // internal Methods\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        // No channels - nothing to do\n    }\n\n    @Override\n    public void initialize() {\n        logger.debug(\"Initializing Vitotronic bridge handler {}\", getThing().getUID());\n        updateStatus();\n        VitotronicBindingConfiguration configuration = getConfigAs(VitotronicBindingConfiguration.class);\n        ipAddress = configuration.ipAddress;\n        port = configuration.port;\n        refreshInterval = configuration.refreshInterval;\n\n        isDiscover = false;\n        startAutomaticRefresh();\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"Dispose Vitotronic bridge handler {}\", getThing().getUID());\n\n        if (pollingJob != null && !pollingJob.isCancelled()) {\n            pollingJob.cancel(true);\n            pollingJob = null;\n        }\n    }\n\n    // Connection to adapter\n\n    private void openSocket() {\n        logger.trace(\"Try to open connection to Optolink Adapter {}:{}\", ipAddress, port);\n\n        try {\n            socket = new Socket(ipAddress, port);\n            out = new PrintStream(socket.getOutputStream());\n            inStream = socket.getInputStream();\n        } catch (UnknownHostException e) {\n            logger.error(\"Can't find Host: {}:{}\", ipAddress, port);\n        } catch (IOException e) {\n            logger.debug(\"Error in communication to Host: {}:{}\", ipAddress, port);\n            logger.trace(\"Diagnostic: \", e);\n        }\n    }\n\n    Runnable socketReceiverRunnable = () -> {\n        logger.trace(\"Start Background Thread for recieving data from adapter\");\n        try {\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.setContentHandler(new XmlHandler());\n            logger.trace(\"Start Parser for optolink adapter\");\n            xmlReader.parse(new InputSource(inStream));\n\n        } catch (IOException e) {\n            logger.trace(\"Connection error from optolink adapter\");\n        } catch (SAXException e) {\n            logger.trace(\"XML Parser Error\");\n\n        }\n        updateStatus(ThingStatus.OFFLINE);\n        isConnect = false;\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (Exception e) {\n        }\n        logger.trace(\"Connection to optolink adapter is died ... wait for restart\");\n    };\n\n    private void startSocketReceiver() {\n        if (!isConnect) {\n            openSocket();\n\n            Thread thread = new Thread(socketReceiverRunnable);\n            thread.setName(\"VitotronicSocketThread\");\n            thread.start();\n        }\n    }\n\n    private void sendSocketData(String message) {\n        try {\n            logger.trace(\"Send Message {}\", message);\n            if (isConnect) {\n                if (message.matches(\"^set.*REFRESH$\")) {\n                    String[] msgParts = message.split(\" \");\n                    String[] thingChannel = msgParts[1].split(\":\");\n                    message = \"get \" + thingChannel[0] + \" \" + thingChannel[1];\n                }\n                out.write((message + \"\\n\").getBytes());\n            }\n        } catch (IOException e) {\n            logger.error(\"Error in sending data to optolink adapter\");\n            logger.trace(\"Diagnostic: \", e);\n        }\n    }\n\n    // Handles all data what received from optolink adapter\n\n    public class XmlHandler implements ContentHandler {\n        boolean isData;\n        boolean isDefine;\n        boolean isThing;\n        boolean isChannel;\n        boolean isDescription;\n        String thingID;\n        String thingType;\n        String channelID;\n        String description;\n        VitotronicThingHandler thingHandler;\n        Set<String> channels = new HashSet<>();\n\n        @Override\n        public void startElement(String uri, String localName, String pName, Attributes attr) throws SAXException {\n            try {\n                switch (localName) {\n                    case \"optolink\":\n                        isConnect = true;\n                        updateStatus(ThingStatus.ONLINE);\n                        break;\n                    case \"data\":\n                        isDefine = false;\n                        break;\n                    case \"define\":\n                        isDefine = true;\n                        break;\n                    case \"description\":\n                        isDescription = true;\n                        break;\n                    case \"thing\":\n                        isThing = true;\n                        if (isDefine) {\n                            thingType = attr.getValue(\"type\");\n                        }\n                        thingID = attr.getValue(\"id\");\n                        channels.clear();\n                        thingHandler = thingHandlerMap.get(thingID);\n                        break;\n                    case \"channel\":\n                        isChannel = true;\n                        channelID = attr.getValue(\"id\");\n                        if (isDefine) {\n                            channels.add(channelID);\n                        } else { // is data\n                            if (thingHandler != null) {\n                                logger.trace(\"Set Data for channel '{}' value '{}'\", channelID, attr.getValue(\"value\"));\n                                thingHandler.setChannelValue(channelID, attr.getValue(\"value\"));\n                            }\n                        }\n                        break;\n                }\n            } catch (Exception e) {\n                logger.error(\"Error in parsing data\");\n                logger.trace(\"Diagnostic: \", e);\n            }\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (isDescription) {\n                description = new String(ch, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            switch (localName) {\n                case \"description\":\n                    isDescription = false;\n                    break;\n                case \"thing\":\n                    if (isDefine) {\n                        createThing(thingType, thingID);\n                    }\n                    isThing = false;\n                    thingHandler = null;\n                    break;\n                case \"channel\":\n                    isChannel = false;\n                    break;\n            }\n        }\n\n        // Unused function of xmlReader\n        @Override\n        public void endDocument() throws SAXException {\n        }\n\n        @Override\n        public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXException {\n        }\n\n        @Override\n        public void processingInstruction(String arg0, String arg1) throws SAXException {\n        }\n\n        @Override\n        public void setDocumentLocator(Locator arg0) {\n        }\n\n        @Override\n        public void skippedEntity(String arg0) throws SAXException {\n        }\n\n        @Override\n        public void startDocument() throws SAXException {\n        }\n\n        @Override\n        public void startPrefixMapping(String arg0, String arg1) throws SAXException {\n        }\n\n        @Override\n        public void endPrefixMapping(String prefix) throws SAXException {\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.discovery;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\nimport org.eclipse.smarthome.config.discovery.DiscoveryResult;\nimport org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.thing.ThingUID;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.handler.WemoBridgeHandler;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoLinkDiscoveryService} is responsible for discovering new and\n * removed WeMo devices connected to the WeMo Link Bridge.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n *\n */\npublic class WemoLinkDiscoveryService extends AbstractDiscoveryService implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoLinkDiscoveryService.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_MZ100);\n\n    public static final String NORMALIZE_ID_REGEX = \"[^a-zA-Z0-9_]\";\n\n    /**\n     * Maximum time to search for devices in seconds.\n     */\n    private static final int SEARCH_TIME = 20;\n\n    /**\n     * Scan interval for scanning job in seconds.\n     */\n    private static final int SCAN_INTERVAL = 120;\n\n    /**\n     * The handler for WeMo Link bridge\n     */\n    private final WemoBridgeHandler wemoBridgeHandler;\n\n    /**\n     * Job which will do the background scanning\n     */\n    private final WemoLinkScan scanningRunnable;\n\n    /**\n     * Schedule for scanning\n     */\n    private ScheduledFuture<?> scanningJob;\n\n    /**\n     * The Upnp service\n     */\n    private UpnpIOService service;\n\n    private final WemoHttpCall wemoHttpCaller;\n\n    public WemoLinkDiscoveryService(WemoBridgeHandler wemoBridgeHandler, UpnpIOService upnpIOService,\n            WemoHttpCall wemoHttpCaller) {\n        super(SEARCH_TIME);\n        this.wemoBridgeHandler = wemoBridgeHandler;\n\n        this.wemoHttpCaller = wemoHttpCaller;\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n\n        this.scanningRunnable = new WemoLinkScan();\n        if (wemoBridgeHandler == null) {\n            logger.warn(\"no bridge handler for scan given\");\n        }\n        this.activate(null);\n    }\n\n    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n        return SUPPORTED_THING_TYPES;\n    }\n\n    @Override\n    public void startScan() {\n        logger.trace(\"Starting WeMoEndDevice discovery on WeMo Link {}\", wemoBridgeHandler.getThing().getUID());\n        try {\n            String devUDN = \"uuid:\" + wemoBridgeHandler.getThing().getConfiguration().get(UDN).toString();\n            logger.trace(\"devUDN = '{}'\", devUDN);\n\n            String soapHeader = \"\\\"urn:Belkin:service:bridge:1#GetEndDevices\\\"\";\n            String content = \"<?xml version=\\\"1.0\\\"?>\"\n                    + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                    + \"<s:Body>\" + \"<u:GetEndDevices xmlns:u=\\\"urn:Belkin:service:bridge:1\\\">\" + \"<DevUDN>\" + devUDN\n                    + \"</DevUDN><ReqListType>PAIRED_LIST</ReqListType>\" + \"</u:GetEndDevices>\" + \"</s:Body>\"\n                    + \"</s:Envelope>\";\n\n            URL descriptorURL = service.getDescriptorURL(this);\n\n            if (descriptorURL != null) {\n                String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n                String wemoURL = deviceURL + \"/upnp/control/bridge1\";\n\n                String endDeviceRequest = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n\n                if (endDeviceRequest != null) {\n                    logger.trace(\"endDeviceRequest answered '{}'\", endDeviceRequest);\n\n                    try {\n                        String stringParser = StringUtils.substringBetween(endDeviceRequest, \"<DeviceLists>\",\n                                \"</DeviceLists>\");\n\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        // check if there are already paired devices with WeMo Link\n                        if (\"0\".equals(stringParser)) {\n                            logger.debug(\"There are no devices connected with WeMo Link. Exit discovery\");\n                            return;\n                        }\n\n                        // Build parser for received <DeviceList>\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"DeviceInfo\");\n\n                        // iterate the devices\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"DeviceIndex\");\n                            Element line = (Element) deviceIndex.item(0);\n                            logger.trace(\"DeviceIndex: {}\", getCharacterDataFromElement(line));\n\n                            NodeList deviceID = element.getElementsByTagName(\"DeviceID\");\n                            line = (Element) deviceID.item(0);\n                            String endDeviceID = getCharacterDataFromElement(line);\n                            logger.trace(\"DeviceID: {}\", endDeviceID);\n\n                            NodeList friendlyName = element.getElementsByTagName(\"FriendlyName\");\n                            line = (Element) friendlyName.item(0);\n                            String endDeviceName = getCharacterDataFromElement(line);\n                            logger.trace(\"FriendlyName: {}\", endDeviceName);\n\n                            NodeList vendor = element.getElementsByTagName(\"Manufacturer\");\n                            line = (Element) vendor.item(0);\n                            String endDeviceVendor = getCharacterDataFromElement(line);\n                            logger.trace(\"Manufacturer: {}\", endDeviceVendor);\n\n                            NodeList model = element.getElementsByTagName(\"ModelCode\");\n                            line = (Element) model.item(0);\n                            String endDeviceModelID = getCharacterDataFromElement(line);\n                            endDeviceModelID = endDeviceModelID.replaceAll(NORMALIZE_ID_REGEX, \"_\");\n\n                            logger.trace(\"ModelCode: {}\", endDeviceModelID);\n\n                            if (SUPPORTED_THING_TYPES.contains(new ThingTypeUID(BINDING_ID, endDeviceModelID))) {\n                                logger.debug(\"Discovered a WeMo LED Light thing with ID '{}'\", endDeviceID);\n\n                                ThingUID bridgeUID = wemoBridgeHandler.getThing().getUID();\n                                ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, endDeviceModelID);\n\n                                if (thingTypeUID.equals(THING_TYPE_MZ100)) {\n                                    String thingLightId = endDeviceID;\n                                    ThingUID thingUID = new ThingUID(thingTypeUID, bridgeUID, thingLightId);\n\n                                    Map<String, Object> properties = new HashMap<>(1);\n                                    properties.put(DEVICE_ID, endDeviceID);\n\n                                    DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID)\n                                            .withProperties(properties)\n                                            .withBridge(wemoBridgeHandler.getThing().getUID()).withLabel(endDeviceName)\n                                            .build();\n\n                                    thingDiscovered(discoveryResult);\n                                }\n                            } else {\n                                logger.debug(\"Discovered an unsupported device :\");\n                                logger.debug(\"DeviceIndex : {}\", getCharacterDataFromElement(line));\n                                logger.debug(\"DeviceID    : {}\", endDeviceID);\n                                logger.debug(\"FriendlyName: {}\", endDeviceName);\n                                logger.debug(\"Manufacturer: {}\", endDeviceVendor);\n                                logger.debug(\"ModelCode   : {}\", endDeviceModelID);\n                            }\n\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse endDevices for bridge '{}'\",\n                                wemoBridgeHandler.getThing().getUID(), e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get endDevices for bridge '{}'\", wemoBridgeHandler.getThing().getUID(), e);\n        }\n    }\n\n    @Override\n    protected void startBackgroundDiscovery() {\n        logger.trace(\"Start WeMo device background discovery\");\n\n        if (scanningJob == null || scanningJob.isCancelled()) {\n            this.scanningJob = scheduler.scheduleWithFixedDelay(this.scanningRunnable,\n                    LINK_DISCOVERY_SERVICE_INITIAL_DELAY, SCAN_INTERVAL, TimeUnit.SECONDS);\n        } else {\n            logger.trace(\"scanningJob active\");\n        }\n    }\n\n    @Override\n    protected void stopBackgroundDiscovery() {\n        logger.debug(\"Stop WeMo device background discovery\");\n\n        if (scanningJob != null && !scanningJob.isCancelled()) {\n            scanningJob.cancel(true);\n            scanningJob = null;\n        }\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.wemoBridgeHandler.getThing().getConfiguration().get(UDN);\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    public class WemoLinkScan implements Runnable {\n        @Override\n        public void run() {\n            startScan();\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.DateTimeType;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoCoffeeHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n * @author Erdoan Hadzhiyusein - Adapted the class to work with the new DateTimeType\n */\n\npublic class WemoCoffeeHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoCoffeeHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_COFFEE);\n\n    private Map<String, Boolean> subscriptionState = new HashMap<>();\n\n    protected static final int SUBSCRIPTION_DURATION = 600;\n\n    private UpnpIOService service;\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private final int REFRESH_INTERVAL = 60;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                if (!isUpnpDeviceRegistered()) {\n                    logger.debug(\"WeMo UPnP device {} not yet registered\", getUDN());\n                }\n\n                updateWemoState();\n                onSubscription();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n            }\n        }\n    };\n\n    public WemoCoffeeHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemoHttpcaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemoHttpcaller;\n\n        logger.debug(\"Creating a WemoCoffeeHandler V0.4 for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoCoffeeHandler for UDN '{}'\", configuration.get(\"udn\"));\n            onSubscription();\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoCoffeeHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WeMoCoffeeHandler disposed.\");\n\n        removeSubscription();\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        if (command instanceof RefreshType) {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n            }\n        } else if (channelUID.getId().equals(CHANNEL_STATE)) {\n            if (command instanceof OnOffType) {\n                if (command.equals(OnOffType.ON)) {\n                    try {\n                        String soapHeader = \"\\\"urn:Belkin:service:deviceevent:1#SetAttributes\\\"\";\n\n                        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                                + \"<s:Body>\" + \"<u:SetAttributes xmlns:u=\\\"urn:Belkin:service:deviceevent:1\\\">\"\n                                + \"<attributeList>&lt;attribute&gt;&lt;name&gt;Brewed&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;\"\n                                + \"&lt;attribute&gt;&lt;name&gt;LastCleaned&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;\"\n                                + \"&lt;name&gt;ModeTime&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;Brewing&lt;/name&gt;\"\n                                + \"&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;TimeRemaining&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;\"\n                                + \"&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;WaterLevelReached&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;\"\n                                + \"attribute&gt;&lt;name&gt;Mode&lt;/name&gt;&lt;value&gt;4&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;CleanAdvise&lt;/name&gt;\"\n                                + \"&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;FilterAdvise&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;\"\n                                + \"&lt;attribute&gt;&lt;name&gt;Cleaning&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;</attributeList>\"\n                                + \"</u:SetAttributes>\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n                        String wemoURL = getWemoURL(\"deviceevent\");\n\n                        if (wemoURL != null) {\n                            String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                            if (wemoCallResponse != null) {\n                                updateState(CHANNEL_STATE, OnOffType.ON);\n                                State newMode = new StringType(\"Brewing\");\n                                updateState(CHANNEL_COFFEEMODE, newMode);\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to send command '{}' for device '{}': {}\", command, getThing().getUID(),\n                                e.getMessage());\n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n                    }\n                }\n                // if command.equals(OnOffType.OFF) we do nothing because WeMo Coffee Maker cannot be switched off\n                // remotely\n                updateStatus(ThingStatus.ONLINE);\n            }\n        }\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n        logger.debug(\"WeMo {}: Subscription to service {} {}\", getUDN(), service, succeeded ? \"succeeded\" : \"failed\");\n        subscriptionState.put(service, succeeded);\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n        // We can subscribe to GENA events, but there is no usefull response right now.\n    }\n\n    private synchronized void onSubscription() {\n        if (service.isRegistered(this)) {\n            logger.debug(\"Checking WeMo GENA subscription for '{}'\", this);\n\n            String subscription = \"deviceevent1\";\n            if ((subscriptionState.get(subscription) == null) || !subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"Setting up GENA subscription {}: Subscribing to service {}...\", getUDN(), subscription);\n                service.addSubscription(this, subscription, SUBSCRIPTION_DURATION);\n                subscriptionState.put(subscription, true);\n            }\n        } else {\n            logger.debug(\"Setting up WeMo GENA subscription for '{}' FAILED - service.isRegistered(this) is FALSE\",\n                    this);\n        }\n    }\n\n    private synchronized void removeSubscription() {\n        logger.debug(\"Removing WeMo GENA subscription for '{}'\", this);\n\n        if (service.isRegistered(this)) {\n            String subscription = \"deviceevent1\";\n            if ((subscriptionState.get(subscription) != null) && subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"WeMo {}: Unsubscribing from service {}...\", getUDN(), subscription);\n                service.removeSubscription(this, subscription);\n            }\n\n            subscriptionState = new HashMap<>();\n            service.unregisterParticipant(this);\n        }\n    }\n\n    private synchronized void onUpdate() {\n        if (refreshJob == null || refreshJob.isCancelled()) {\n            Configuration config = getThing().getConfiguration();\n            int refreshInterval = REFRESH_INTERVAL;\n            Object refreshConfig = config.get(\"pollingInterval\");\n            if (refreshConfig != null) {\n                refreshInterval = ((BigDecimal) refreshConfig).intValue();\n                logger.debug(\"Setting WemoCoffeeHandler refreshInterval to '{}' seconds\", refreshInterval);\n            }\n            refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isUpnpDeviceRegistered() {\n        return service.isRegistered(this);\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo CoffeeMaker.\n     */\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    try {\n                        String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                                \"</attributeList>\");\n\n                        // Due to Belkins bad response formatting, we need to run this twice.\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        logger.trace(\"CoffeeMaker response '{}' for device '{}' received\", stringParser,\n                                getThing().getUID());\n\n                        stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                        // iterate the attributes\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                            Element line = (Element) deviceIndex.item(0);\n                            String attributeName = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeName: {}\", attributeName);\n\n                            NodeList deviceID = element.getElementsByTagName(\"value\");\n                            line = (Element) deviceID.item(0);\n                            String attributeValue = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeValue: {}\", attributeValue);\n\n                            switch (attributeName) {\n                                case \"Mode\":\n                                    State newMode = new StringType(\"Brewing\");\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            updateState(CHANNEL_STATE, OnOffType.ON);\n                                            newMode = new StringType(\"Refill\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"1\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"PlaceCarafe\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"2\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"RefillWater\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"3\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"Ready\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"4\":\n                                            updateState(CHANNEL_STATE, OnOffType.ON);\n                                            newMode = new StringType(\"Brewing\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"5\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"Brewed\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"6\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"CleaningBrewing\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"7\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"CleaningSoaking\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"8\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"BrewFailCarafeRemoved\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                    }\n                                    break;\n                                case \"ModeTime\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_MODETIME, newAttributeValue);\n                                    }\n                                    break;\n                                case \"TimeRemaining\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_TIMEREMAINING, newAttributeValue);\n                                    }\n                                    break;\n                                case \"WaterLevelReached\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_WATERLEVELREACHED, newAttributeValue);\n                                    }\n                                    break;\n                                case \"CleanAdvise\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = attributeValue.equals(\"0\") ? OnOffType.OFF\n                                                : OnOffType.ON;\n                                        updateState(CHANNEL_CLEANADVISE, newAttributeValue);\n                                    }\n                                    break;\n                                case \"FilterAdvise\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = attributeValue.equals(\"0\") ? OnOffType.OFF\n                                                : OnOffType.ON;\n                                        updateState(CHANNEL_FILTERADVISE, newAttributeValue);\n                                    }\n                                    break;\n                                case \"Brewed\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = getDateTimeState(attributeValue);\n                                        if (newAttributeValue != null) {\n                                            updateState(CHANNEL_BREWED, newAttributeValue);\n                                        }\n                                    }\n                                    break;\n                                case \"LastCleaned\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = getDateTimeState(attributeValue);\n                                        if (newAttributeValue != null) {\n                                            updateState(CHANNEL_LASTCLEANED, newAttributeValue);\n                                        }\n                                    }\n                                    break;\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse attributeList for WeMo CoffeMaker '{}'\", this.getThing().getUID(),\n                                e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get attributes for device '{}'\", getThing().getUID(), e);\n        }\n    }\n\n    @SuppressWarnings(\"null\")\n    public State getDateTimeState(String attributeValue) {\n        if (attributeValue != null) {\n            long value = 0;\n            try {\n                value = Long.parseLong(attributeValue) * 1000; // convert s to ms\n            } catch (NumberFormatException e) {\n                logger.error(\"Unable to parse attributeValue '{}' for device '{}'; expected long\", attributeValue,\n                        getThing().getUID());\n                return null;\n            }\n            ZonedDateTime zoned = ZonedDateTime.ofInstant(Instant.ofEpochMilli(value),\n                    TimeZone.getDefault().toZoneId());\n            State dateTimeState = new DateTimeType(zoned);\n            if (dateTimeState != null) {\n                logger.trace(\"New attribute brewed '{}' received\", dateTimeState);\n                return dateTimeState;\n            }\n        }\n        return null;\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link WemoHolmesHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution;\n */\n\npublic class WemoHolmesHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoHolmesHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_PURIFIER);\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private static final int DEFAULT_REFRESH_INTERVAL_SECONDS = 120;\n    private static final int FILTER_LIFE_DAYS = 330;\n    private static final int FILTER_LIFE_MINS = FILTER_LIFE_DAYS * 24 * 60;\n    private final Map<String, Boolean> subscriptionState = new HashMap<>();\n    private final Map<String, String> stateMap = Collections.synchronizedMap(new HashMap<>());\n\n    private UpnpIOService service;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = () -> {\n        if (!isUpnpDeviceRegistered()) {\n            logger.debug(\"WeMo UPnP device {} not yet registered\", getUDN());\n        } else {\n            updateWemoState();\n            onSubscription();\n        }\n    };\n\n    public WemoHolmesHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemohttpCaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemohttpCaller;\n\n        logger.debug(\"Creating a WemoHolmesHandler for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoHolmesHandler for UDN '{}'\", configuration.get(\"udn\"));\n            service.registerParticipant(this);\n            onSubscription();\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoHolmesHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WemoHolmesHandler disposed.\");\n\n        removeSubscription();\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        String attribute = null;\n        String value = null;\n\n        if (command instanceof RefreshType) {\n            updateWemoState();\n        } else if (CHANNEL_PURIFIERMODE.equals(channelUID.getId())) {\n            attribute = \"Mode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"LOW\":\n                    value = \"1\";\n                    break;\n                case \"MED\":\n                    value = \"2\";\n                    break;\n                case \"HIGH\":\n                    value = \"3\";\n                    break;\n                case \"AUTO\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_IONIZER.equals(channelUID.getId())) {\n            attribute = \"Ionizer\";\n            if (OnOffType.ON.equals(command)) {\n                value = \"1\";\n            } else if (OnOffType.OFF.equals(command)) {\n                value = \"0\";\n            }\n        } else if (CHANNEL_HUMIDIFIERMODE.equals(channelUID.getId())) {\n            attribute = \"FanMode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"MIN\":\n                    value = \"1\";\n                    break;\n                case \"LOW\":\n                    value = \"2\";\n                    break;\n                case \"MED\":\n                    value = \"3\";\n                    break;\n                case \"HIGH\":\n                    value = \"4\";\n                    break;\n                case \"MAX\":\n                    value = \"5\";\n                    break;\n            }\n        } else if (CHANNEL_DESIREDHUMIDITY.equals(channelUID.getId())) {\n            attribute = \"DesiredHumidity\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"45\":\n                    value = \"0\";\n                    break;\n                case \"50\":\n                    value = \"1\";\n                    break;\n                case \"55\":\n                    value = \"2\";\n                    break;\n                case \"60\":\n                    value = \"3\";\n                    break;\n                case \"100\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_HEATERMODE.equals(channelUID.getId())) {\n            attribute = \"Mode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"FROSTPROTECT\":\n                    value = \"1\";\n                    break;\n                case \"HIGH\":\n                    value = \"2\";\n                    break;\n                case \"LOW\":\n                    value = \"3\";\n                    break;\n                case \"ECO\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_TARGETTEMP.equals(channelUID.getId())) {\n            attribute = \"SetTemperature\";\n            value = command.toString();\n        }\n        try {\n            String soapHeader = \"\\\"urn:Belkin:service:deviceevent:1#SetAttributes\\\"\";\n            String content = \"<?xml version=\\\"1.0\\\"?>\"\n                    + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                    + \"<s:Body>\" + \"<u:SetAttributes xmlns:u=\\\"urn:Belkin:service:deviceevent:1\\\">\"\n                    + \"<attributeList>&lt;attribute&gt;&lt;name&gt;\" + attribute + \"&lt;/name&gt;&lt;value&gt;\" + value\n                    + \"&lt;/value&gt;&lt;/attribute&gt;</attributeList>\" + \"</u:SetAttributes>\" + \"</s:Body>\"\n                    + \"</s:Envelope>\";\n            String wemoURL = getWemoURL(\"deviceevent\");\n\n            if (wemoURL != null) {\n                wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n            }\n        } catch (RuntimeException e) {\n            logger.debug(\"Failed to send command '{}' for device '{}':\", command, getThing().getUID(), e);\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n        }\n        updateStatus(ThingStatus.ONLINE);\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n        logger.debug(\"WeMo {}: Subscription to service {} {}\", getUDN(), service, succeeded ? \"succeeded\" : \"failed\");\n        subscriptionState.put(service, succeeded);\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n        logger.debug(\"Received pair '{}':'{}' (service '{}') for thing '{}'\", variable, value, service,\n                this.getThing().getUID());\n\n        updateStatus(ThingStatus.ONLINE);\n        this.stateMap.put(variable, value);\n    }\n\n    private synchronized void onSubscription() {\n        if (service.isRegistered(this)) {\n            logger.debug(\"Checking WeMo GENA subscription for '{}'\", this);\n\n            String subscription = \"basicevent1\";\n\n            if ((subscriptionState.get(subscription) == null) || !subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"Setting up GENA subscription {}: Subscribing to service {}...\", getUDN(), subscription);\n                service.addSubscription(this, subscription, SUBSCRIPTION_DURATION);\n                subscriptionState.put(subscription, true);\n            }\n\n        } else {\n            logger.debug(\"Setting up WeMo GENA subscription for '{}' FAILED - service.isRegistered(this) is FALSE\",\n                    this);\n        }\n    }\n\n    private synchronized void removeSubscription() {\n        logger.debug(\"Removing WeMo GENA subscription for '{}'\", this);\n\n        if (service.isRegistered(this)) {\n            String subscription = \"basicevent1\";\n\n            if ((subscriptionState.get(subscription) != null) && subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"WeMo {}: Unsubscribing from service {}...\", getUDN(), subscription);\n                service.removeSubscription(this, subscription);\n            }\n\n            subscriptionState.remove(subscription);\n            service.unregisterParticipant(this);\n        }\n    }\n\n    private synchronized void onUpdate() {\n        if (refreshJob == null || refreshJob.isCancelled()) {\n            Configuration config = getThing().getConfiguration();\n            int refreshInterval = DEFAULT_REFRESH_INTERVAL_SECONDS;\n            Object refreshConfig = config.get(\"refresh\");\n            refreshInterval = refreshConfig == null ? DEFAULT_REFRESH_INTERVAL_SECONDS\n                    : ((BigDecimal) refreshConfig).intValue();\n            refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isUpnpDeviceRegistered() {\n        return service.isRegistered(this);\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo device and\n     * calls {@link onValueReceived} to update the statemap and channels..\n     *\n     */\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    logger.trace(\"State response '{}' for device '{}' received\", wemoCallResponse, getThing().getUID());\n\n                    String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                            \"</attributeList>\");\n\n                    // Due to Belkins bad response formatting, we need to run this twice.\n                    stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                    stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                    logger.trace(\"AirPurifier response '{}' for device '{}' received\", stringParser,\n                            getThing().getUID());\n\n                    stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                    DocumentBuilder db = dbf.newDocumentBuilder();\n                    InputSource is = new InputSource();\n                    is.setCharacterStream(new StringReader(stringParser));\n\n                    Document doc = db.parse(is);\n                    NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                    // iterate the attributes\n                    for (int i = 0; i < nodes.getLength(); i++) {\n                        Element element = (Element) nodes.item(i);\n\n                        NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                        Element line = (Element) deviceIndex.item(0);\n                        String attributeName = getCharacterDataFromElement(line);\n                        logger.trace(\"attributeName: {}\", attributeName);\n\n                        NodeList deviceID = element.getElementsByTagName(\"value\");\n                        line = (Element) deviceID.item(0);\n                        String attributeValue = getCharacterDataFromElement(line);\n                        logger.trace(\"attributeValue: {}\", attributeValue);\n\n                        State newMode = new StringType();\n                        switch (attributeName) {\n                            case \"Mode\":\n                                if (\"purifier\".equals(getThing().getThingTypeUID().getId())) {\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            newMode = new StringType(\"OFF\");\n                                            break;\n                                        case \"1\":\n                                            newMode = new StringType(\"LOW\");\n                                            break;\n                                        case \"2\":\n                                            newMode = new StringType(\"MED\");\n                                            break;\n                                        case \"3\":\n                                            newMode = new StringType(\"HIGH\");\n                                            break;\n                                        case \"4\":\n                                            newMode = new StringType(\"AUTO\");\n                                            break;\n                                    }\n                                    updateState(CHANNEL_PURIFIERMODE, newMode);\n                                } else {\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            newMode = new StringType(\"OFF\");\n                                            break;\n                                        case \"1\":\n                                            newMode = new StringType(\"FROSTPROTECT\");\n                                            break;\n                                        case \"2\":\n                                            newMode = new StringType(\"HIGH\");\n                                            break;\n                                        case \"3\":\n                                            newMode = new StringType(\"LOW\");\n                                            break;\n                                        case \"4\":\n                                            newMode = new StringType(\"ECO\");\n                                            break;\n                                    }\n                                    updateState(CHANNEL_HEATERMODE, newMode);\n                                }\n                                break;\n                            case \"Ionizer\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_IONIZER, newMode);\n                                break;\n                            case \"AirQuality\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new StringType(\"POOR\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new StringType(\"MODERATE\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new StringType(\"GOOD\");\n                                        break;\n                                }\n                                updateState(CHANNEL_AIRQUALITY, newMode);\n                                break;\n                            case \"FilterLife\":\n                                int filterLife = Integer.valueOf(attributeValue);\n                                if (\"purifier\".equals(getThing().getThingTypeUID().getId())) {\n                                    filterLife = Math.round((filterLife / FILTER_LIFE_MINS) * 100);\n                                } else {\n                                    filterLife = Math.round((filterLife / 60480) * 100);\n                                }\n                                updateState(CHANNEL_FILTERLIFE, new PercentType(String.valueOf(filterLife)));\n                                break;\n                            case \"ExpiredFilterTime\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_EXPIREDFILTERTIME, newMode);\n                                break;\n                            case \"FilterPresent\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_FILTERPRESENT, newMode);\n                                break;\n                            case \"FANMode\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new StringType(\"OFF\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new StringType(\"LOW\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new StringType(\"MED\");\n                                        break;\n                                    case \"3\":\n                                        newMode = new StringType(\"HIGH\");\n                                        break;\n                                    case \"4\":\n                                        newMode = new StringType(\"AUTO\");\n                                        break;\n                                }\n                                updateState(CHANNEL_PURIFIERMODE, newMode);\n                                break;\n                            case \"DesiredHumidity\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new PercentType(\"45\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new PercentType(\"50\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new PercentType(\"55\");\n                                        break;\n                                    case \"3\":\n                                        newMode = new PercentType(\"60\");\n                                        break;\n                                    case \"4\":\n                                        newMode = new PercentType(\"100\");\n                                        break;\n                                }\n                                updateState(CHANNEL_DESIREDHUMIDITY, newMode);\n                                break;\n                            case \"CurrentHumidity\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_CURRENTHUMIDITY, newMode);\n                                break;\n                            case \"Temperature\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_CURRENTTEMP, newMode);\n                                break;\n                            case \"SetTemperature\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_TARGETTEMP, newMode);\n                                break;\n                            case \"AutoOffTime\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_AUTOOFFTIME, newMode);\n                                break;\n                            case \"TimeRemaining\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_HEATINGREMAINING, newMode);\n                                break;\n                        }\n                    }\n                }\n            }\n        } catch (RuntimeException | ParserConfigurationException | SAXException | IOException e) {\n            logger.debug(\"Failed to get actual state for device '{}':\", getThing().getUID(), e);\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n        }\n        updateStatus(ThingStatus.ONLINE);\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoMakerHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n */\n\npublic class WemoMakerHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoMakerHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_MAKER);\n\n    private UpnpIOService service;\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private final int DEFAULT_REFRESH_INTERVAL = 15;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n            }\n        }\n    };\n\n    public WemoMakerHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemoHttpcaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemoHttpcaller;\n\n        logger.debug(\"Creating a WemoMakerHandler for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoMakerHandler for UDN '{}'\", configuration.get(\"udn\"));\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoMakerHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WeMoMakerHandler disposed.\");\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        if (command instanceof RefreshType) {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n            }\n        } else if (channelUID.getId().equals(CHANNEL_RELAY)) {\n            if (command instanceof OnOffType) {\n                try {\n                    String binaryState = null;\n\n                    if (command.equals(OnOffType.ON)) {\n                        binaryState = \"1\";\n                    } else if (command.equals(OnOffType.OFF)) {\n                        binaryState = \"0\";\n                    }\n\n                    String soapHeader = \"\\\"urn:Belkin:service:basicevent:1#SetBinaryState\\\"\";\n\n                    String content = \"<?xml version=\\\"1.0\\\"?>\"\n                            + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                            + \"<s:Body>\" + \"<u:SetBinaryState xmlns:u=\\\"urn:Belkin:service:basicevent:1\\\">\"\n                            + \"<BinaryState>\" + binaryState + \"</BinaryState>\" + \"</u:SetBinaryState>\" + \"</s:Body>\"\n                            + \"</s:Envelope>\";\n\n                    String wemoURL = getWemoURL(\"basicevent\");\n\n                    if (wemoURL != null) {\n                        @SuppressWarnings(\"unused\")\n                        String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                    }\n                } catch (Exception e) {\n                    logger.error(\"Failed to send command '{}' for device '{}' \", command, getThing().getUID(), e);\n                }\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private synchronized void onSubscription() {\n    }\n\n    @SuppressWarnings(\"unused\")\n    private synchronized void removeSubscription() {\n    }\n\n    private synchronized void onUpdate() {\n        if (service.isRegistered(this)) {\n            if (refreshJob == null || refreshJob.isCancelled()) {\n                Configuration config = getThing().getConfiguration();\n                int refreshInterval = DEFAULT_REFRESH_INTERVAL;\n                Object refreshConfig = config.get(\"refresh\");\n                if (refreshConfig != null) {\n                    refreshInterval = ((BigDecimal) refreshConfig).intValue();\n                }\n                refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n            }\n        }\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo Maker.\n     */\n    @SuppressWarnings(\"null\")\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    try {\n                        String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                                \"</attributeList>\");\n\n                        // Due to Belkins bad response formatting, we need to run this twice.\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        logger.trace(\"Maker response '{}' for device '{}' received\", stringParser, getThing().getUID());\n\n                        stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                        // iterate the attributes\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                            Element line = (Element) deviceIndex.item(0);\n                            String attributeName = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeName: {}\", attributeName);\n\n                            NodeList deviceID = element.getElementsByTagName(\"value\");\n                            line = (Element) deviceID.item(0);\n                            String attributeValue = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeValue: {}\", attributeValue);\n\n                            switch (attributeName) {\n                                case \"Switch\":\n                                    State relayState = attributeValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n                                    if (relayState != null) {\n                                        logger.debug(\"New relayState '{}' for device '{}' received\", relayState,\n                                                getThing().getUID());\n                                        updateState(CHANNEL_RELAY, relayState);\n                                    }\n                                    break;\n                                case \"Sensor\":\n                                    State sensorState = attributeValue.equals(\"1\") ? OnOffType.OFF : OnOffType.ON;\n                                    if (sensorState != null) {\n                                        logger.debug(\"New sensorState '{}' for device '{}' received\", sensorState,\n                                                getThing().getUID());\n                                        updateState(CHANNEL_SENSOR, sensorState);\n                                    }\n                                    break;\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse attributeList for WeMo Maker '{}'\", this.getThing().getUID(), e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get attributes for device '{}'\", getThing().getUID(), e);\n        }\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.yamahareceiver.internal.protocol.xml;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.openhab.binding.yamahareceiver.internal.YamahaReceiverBindingConstants.Zone;\nimport org.openhab.binding.yamahareceiver.internal.protocol.ReceivedMessageParseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Utility methods for XML handling\n *\n * @author David Graeff - Initial contribution\n * @author Tomasz Maruszak - DAB support, Spotify support, refactoring, input name conversion fix, Input mapping fix\n */\npublic class XMLUtils {\n\n    private static final Logger LOG = LoggerFactory.getLogger(XMLUtils.class);\n\n    // We need a lot of xml parsing. Create a document builder beforehand.\n    static final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n    static Node getNode(Node parent, String[] nodePath, int offset) {\n        if (parent == null) {\n            return null;\n        }\n        if (offset < nodePath.length - 1) {\n            return getNode(((Element) parent).getElementsByTagName(nodePath[offset]).item(0), nodePath, offset + 1);\n        } else {\n            return ((Element) parent).getElementsByTagName(nodePath[offset]).item(0);\n        }\n    }\n\n    static Node getNode(Node root, String nodePath) {\n        String[] nodePathArr = nodePath.split(\"/\");\n        return getNode(root, nodePathArr, 0);\n    }\n\n    static Stream<Element> getChildElements(Node node) {\n        if (node == null) {\n            return Stream.empty();\n        }\n        return toStream(node.getChildNodes()).filter(x -> x.getNodeType() == Node.ELEMENT_NODE).map(x -> (Element) x);\n    }\n\n    static Stream<Node> toStream(NodeList nodeList) {\n        return IntStream.range(0, nodeList.getLength()).mapToObj(nodeList::item);\n    }\n\n    /**\n     * Retrieves the child node according to the xpath expression.\n     *\n     * @param root\n     * @param nodePath\n     * @return\n     * @throws ReceivedMessageParseException when the child node does not exist throws\n     *             {@link ReceivedMessageParseException}.\n     */\n    static Node getNodeOrFail(Node root, String nodePath) throws ReceivedMessageParseException {\n        Node node = getNode(root, nodePath);\n        if (node == null) {\n            throw new ReceivedMessageParseException(nodePath + \" child in parent node missing!\");\n        }\n        return node;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @param defaultValue\n     * @return\n     */\n    public static String getNodeContentOrDefault(Node root, String nodePath, String defaultValue) {\n        Node node = getNode(root, nodePath);\n        if (node != null) {\n            return node.getTextContent();\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path.\n     * If the node is found it's inner text is returned, otherwise the default provided value.\n     * The first path that exists is returned.\n     *\n     * @param root\n     * @param nodePaths\n     * @param defaultValue\n     * @return\n     */\n    public static String getAnyNodeContentOrDefault(Node root, String defaultValue, String... nodePaths) {\n        for (String nodePath : nodePaths) {\n            String value = getNodeContentOrDefault(root, nodePath, (String) null);\n            if (value != null) {\n                return value;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @return\n     */\n    public static String getNodeContentOrEmpty(Node root, String nodePath) {\n        return getNodeContentOrDefault(root, nodePath, \"\");\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @param defaultValue\n     * @return\n     */\n    public static Integer getNodeContentOrDefault(Node root, String nodePath, Integer defaultValue) {\n        Node node = getNode(root, nodePath);\n        if (node != null) {\n            try {\n                return Integer.valueOf(node.getTextContent());\n            } catch (NumberFormatException e) {\n                LOG.trace(\n                        \"The value '{}' of node with path {} could not been parsed to an integer. Applying default of {}\",\n                        node.getTextContent(), nodePath, defaultValue);\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Parse the given xml message into a xml document node.\n     *\n     * @param message XML formatted message.\n     * @return Return the response as xml node or throws an exception if response is not xml.\n     * @throws IOException\n     */\n    public static Document xml(String message) throws IOException, ReceivedMessageParseException {\n        // Ensure the message contains XML declaration\n        String response = message.startsWith(\"<?xml\") ? message\n                : \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + message;\n\n        try {\n            return XMLUtils.dbf.newDocumentBuilder().parse(new InputSource(new StringReader(response)));\n        } catch (SAXException | ParserConfigurationException e) {\n            throw new ReceivedMessageParseException(e);\n        }\n    }\n\n    /**\n     * Wraps the XML message with the zone tags. Example with zone=Main_Zone:\n     * <Main_Zone>message</Main_Zone>.\n     *\n     * @param message XML message\n     * @return\n     */\n    public static String wrZone(Zone zone, String message) {\n        return \"<\" + zone.name() + \">\" + message + \"</\" + zone.name() + \">\";\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.transform.xpath.internal;\n\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.core.transform.TransformationException;\nimport org.eclipse.smarthome.core.transform.TransformationService;\nimport org.osgi.service.component.annotations.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\n/**\n * <p>\n * The implementation of {@link TransformationService} which transforms the input by XPath Expressions.\n *\n * @author Thomas.Eichstaedt-Engelen\n */\n@NonNullByDefault\n@Component(immediate = true, property = { \"smarthome.transform=XPATH\" })\npublic class XPathTransformationService implements TransformationService {\n\n    private final Logger logger = LoggerFactory.getLogger(XPathTransformationService.class);\n\n    @Override\n    public @Nullable String transform(String xpathExpression, String source) throws TransformationException {\n        if (xpathExpression == null || source == null) {\n            throw new TransformationException(\"the given parameters 'xpath' and 'source' must not be null\");\n        }\n\n        logger.debug(\"about to transform '{}' by the function '{}'\", source, xpathExpression);\n\n        StringReader stringReader = null;\n\n        try {\n            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n            domFactory.setNamespaceAware(true);\n            domFactory.setValidating(false);\n            DocumentBuilder builder = domFactory.newDocumentBuilder();\n\n            stringReader = new StringReader(source);\n            InputSource inputSource = new InputSource(stringReader);\n            inputSource.setEncoding(\"UTF-8\");\n\n            Document doc = builder.parse(inputSource);\n\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            XPathExpression expr = xpath.compile(xpathExpression);\n\n            String transformationResult = (String) expr.evaluate(doc, XPathConstants.STRING);\n\n            logger.debug(\"transformation resulted in '{}'\", transformationResult);\n\n            return transformationResult;\n        } catch (Exception e) {\n            throw new TransformationException(\"transformation throws exceptions\", e);\n        } finally {\n            if (stringReader != null) {\n                stringReader.close();\n            }\n        }\n    }\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.hardware.callbacks;\n\nimport static org.eclipse.jetty.http.HttpMethod.GET;\n\nimport java.io.StringReader;\n\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.openhab.binding.avmfritz.internal.dto.DeviceListModel;\nimport org.openhab.binding.avmfritz.internal.handler.AVMFritzBaseBridgeHandler;\nimport org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface;\nimport org.openhab.binding.avmfritz.internal.util.JAXBUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Callback implementation for updating multiple numbers decoded from a xml\n * response. Supports reauthorization.\n *\n * @author Robert Bausdorf - Initial contribution\n * @author Christoph Weitkamp - Added support for groups\n */\n@NonNullByDefault\npublic class FritzAhaUpdateCallback extends FritzAhaReauthCallback {\n\n    private final Logger logger = LoggerFactory.getLogger(FritzAhaUpdateCallback.class);\n\n    private static final String WEBSERVICE_COMMAND = \"switchcmd=getdevicelistinfos\";\n\n    private final AVMFritzBaseBridgeHandler handler;\n\n    /**\n     * Constructor\n     *\n     * @param webIface Webinterface to FRITZ!Box\n     * @param handler Bridge handler that will update things.\n     */\n    public FritzAhaUpdateCallback(FritzAhaWebInterface webIface, AVMFritzBaseBridgeHandler handler) {\n        super(WEBSERVICE_PATH, WEBSERVICE_COMMAND, webIface, GET, 1);\n        this.handler = handler;\n    }\n\n    @Override\n    public void execute(int status, String response) {\n        super.execute(status, response);\n        logger.trace(\"Received State response {}\", response);\n        if (isValidRequest()) {\n            try {\n                XMLStreamReader xsr = JAXBUtils.XMLINPUTFACTORY.createXMLStreamReader(new StringReader(response));\n                Unmarshaller unmarshaller = JAXBUtils.JAXBCONTEXT_DEVICES.createUnmarshaller();\n                DeviceListModel model = (DeviceListModel) unmarshaller.unmarshal(xsr);\n                if (model != null) {\n                    handler.onDeviceListAdded(model.getDevicelist());\n                } else {\n                    logger.debug(\"no model in response\");\n                }\n                handler.setStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n            } catch (JAXBException | XMLStreamException e) {\n                logger.error(\"Exception creating Unmarshaller: {}\", e.getLocalizedMessage(), e);\n                handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n                        e.getLocalizedMessage());\n            }\n        } else {\n            logger.debug(\"request is invalid: {}\", status);\n            handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Request is invalid\");\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.hardware.callbacks;\n\nimport static org.eclipse.jetty.http.HttpMethod.GET;\n\nimport java.io.StringReader;\n\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.openhab.binding.avmfritz.internal.dto.templates.TemplateListModel;\nimport org.openhab.binding.avmfritz.internal.handler.AVMFritzBaseBridgeHandler;\nimport org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface;\nimport org.openhab.binding.avmfritz.internal.util.JAXBUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Callback implementation for updating templates from a xml response.\n *\n * @author Christoph Weitkamp - Initial contribution\n */\n@NonNullByDefault\npublic class FritzAhaUpdateTemplatesCallback extends FritzAhaReauthCallback {\n\n    private final Logger logger = LoggerFactory.getLogger(FritzAhaUpdateTemplatesCallback.class);\n\n    private static final String WEBSERVICE_COMMAND = \"switchcmd=gettemplatelistinfos\";\n\n    private final AVMFritzBaseBridgeHandler handler;\n\n    /**\n     * Constructor\n     *\n     * @param webInterface web interface to FRITZ!Box\n     * @param handler handler that will update things\n     */\n    public FritzAhaUpdateTemplatesCallback(FritzAhaWebInterface webInterface, AVMFritzBaseBridgeHandler handler) {\n        super(WEBSERVICE_PATH, WEBSERVICE_COMMAND, webInterface, GET, 1);\n        this.handler = handler;\n    }\n\n    @Override\n    public void execute(int status, String response) {\n        super.execute(status, response);\n        logger.trace(\"Received response '{}'\", response);\n        if (isValidRequest()) {\n            try {\n                XMLStreamReader xsr = JAXBUtils.XMLINPUTFACTORY.createXMLStreamReader(new StringReader(response));\n                Unmarshaller unmarshaller = JAXBUtils.JAXBCONTEXT_TEMPLATES.createUnmarshaller();\n                TemplateListModel model = (TemplateListModel) unmarshaller.unmarshal(xsr);\n                if (model != null) {\n                    handler.addTemplateList(model.getTemplates());\n                } else {\n                    logger.debug(\"no template in response\");\n                }\n            } catch (JAXBException | XMLStreamException e) {\n                logger.error(\"Exception creating Unmarshaller: {}\", e.getLocalizedMessage(), e);\n            }\n        } else {\n            logger.debug(\"request is invalid: {}\", status);\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.util;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.stream.XMLInputFactory;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.avmfritz.internal.dto.DeviceListModel;\nimport org.openhab.binding.avmfritz.internal.dto.templates.TemplateListModel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation for a static use of JAXBContext as singleton instance.\n *\n * @author Christoph Weitkamp - Initial contribution\n */\n@NonNullByDefault\npublic class JAXBUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(JAXBUtils.class);\n\n    public static final @Nullable JAXBContext JAXBCONTEXT_DEVICES = initJAXBContextDevices();\n    public static final @Nullable JAXBContext JAXBCONTEXT_TEMPLATES = initJAXBContextTemplates();\n    public static final XMLInputFactory XMLINPUTFACTORY = initXMLInputFactory();\n\n    private static @Nullable JAXBContext initJAXBContextDevices() {\n        try {\n            return JAXBContext.newInstance(DeviceListModel.class);\n        } catch (JAXBException e) {\n            LOGGER.error(\"Exception creating JAXBContext for devices: {}\", e.getLocalizedMessage(), e);\n            return null;\n        }\n    }\n\n    private static @Nullable JAXBContext initJAXBContextTemplates() {\n        try {\n            return JAXBContext.newInstance(TemplateListModel.class);\n        } catch (JAXBException e) {\n            LOGGER.error(\"Exception creating JAXBContext for templates: {}\", e.getLocalizedMessage(), e);\n            return null;\n        }\n    }\n\n    private static XMLInputFactory initXMLInputFactory() {\n        XMLInputFactory xif = XMLInputFactory.newInstance();\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        return xif;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.bosesoundtouch.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.openhab.binding.bosesoundtouch.internal.handler.BoseSoundTouchHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link XMLResponseProcessor} class handles the XML mapping\n *\n * @author Christian Niessner - Initial contribution\n * @author Thomas Traunbauer - Initial contribution\n */\npublic class XMLResponseProcessor {\n    private BoseSoundTouchHandler handler;\n\n    private Map<XMLHandlerState, Map<String, XMLHandlerState>> stateSwitchingMap;\n\n    public XMLResponseProcessor(BoseSoundTouchHandler handler) {\n        this.handler = handler;\n        init();\n    }\n\n    public void handleMessage(String msg) throws SAXException, IOException {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        reader.setContentHandler(new XMLResponseHandler(handler, stateSwitchingMap));\n        reader.parse(new InputSource(new StringReader(msg)));\n    }\n\n    // initializes our XML parsing state machine\n    private void init() {\n        stateSwitchingMap = new HashMap<>();\n\n        Map<String, XMLHandlerState> msgInitMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.INIT, msgInitMap);\n        msgInitMap.put(\"msg\", XMLHandlerState.Msg);\n        msgInitMap.put(\"SoundTouchSdkInfo\", XMLHandlerState.Unprocessed);\n        msgInitMap.put(\"userActivityUpdate\", XMLHandlerState.Unprocessed); // ignored..\n\n        Map<String, XMLHandlerState> msgBodyMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.MsgBody, msgBodyMap);\n        msgBodyMap.put(\"info\", XMLHandlerState.Info);\n        msgBodyMap.put(\"volume\", XMLHandlerState.Volume);\n        msgBodyMap.put(\"presets\", XMLHandlerState.Presets);\n        msgBodyMap.put(\"key\", XMLHandlerState.Unprocessed); // only confirmation of our key presses...\n        msgBodyMap.put(\"status\", XMLHandlerState.Unprocessed); // only confirmation of commands sent to device...\n        msgBodyMap.put(\"zone\", XMLHandlerState.Zone); // only confirmation of our key presses...\n        msgBodyMap.put(\"bass\", XMLHandlerState.Bass);\n        msgBodyMap.put(\"sources\", XMLHandlerState.Sources);\n        msgBodyMap.put(\"bassCapabilities\", XMLHandlerState.BassCapabilities);\n        msgBodyMap.put(\"group\", XMLHandlerState.Group);\n\n        // info message states\n        Map<String, XMLHandlerState> infoMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Info, infoMap);\n        infoMap.put(\"components\", XMLHandlerState.Info);\n        infoMap.put(\"component\", XMLHandlerState.Info);\n        infoMap.put(\"name\", XMLHandlerState.InfoName);\n        infoMap.put(\"type\", XMLHandlerState.InfoType);\n        infoMap.put(\"componentCategory\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"softwareVersion\", XMLHandlerState.InfoFirmwareVersion);\n        infoMap.put(\"serialNumber\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"networkInfo\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"margeAccountUUID\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"margeURL\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"moduleType\", XMLHandlerState.InfoModuleType);\n        infoMap.put(\"variant\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"variantMode\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"countryCode\", XMLHandlerState.Unprocessed);\n        infoMap.put(\"regionCode\", XMLHandlerState.Unprocessed);\n\n        Map<String, XMLHandlerState> updatesMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Updates, updatesMap);\n        updatesMap.put(\"clockDisplayUpdated\", XMLHandlerState.Unprocessed); // can we get anything useful of that?\n        updatesMap.put(\"connectionStateUpdated\", XMLHandlerState.UnprocessedNoTextExpected);\n        updatesMap.put(\"infoUpdated\", XMLHandlerState.Unprocessed);\n        updatesMap.put(\"nowPlayingUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"nowSelectionUpdated\", XMLHandlerState.Unprocessed); // TODO this seems to be quite a useful info\n                                                                            // what is currently played..\n        updatesMap.put(\"recentsUpdated\", XMLHandlerState.Unprocessed);\n        updatesMap.put(\"volumeUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"zoneUpdated\", XMLHandlerState.ZoneUpdated); // just notifies but dosn't provide details\n        updatesMap.put(\"bassUpdated\", XMLHandlerState.BassUpdated);\n        updatesMap.put(\"presetsUpdated\", XMLHandlerState.MsgBody);\n        updatesMap.put(\"groupUpdated\", XMLHandlerState.MsgBody);\n\n        Map<String, XMLHandlerState> volume = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Volume, volume);\n        volume.put(\"targetvolume\", XMLHandlerState.VolumeTarget);\n        volume.put(\"actualvolume\", XMLHandlerState.VolumeActual);\n        volume.put(\"muteenabled\", XMLHandlerState.VolumeMuteEnabled);\n\n        Map<String, XMLHandlerState> nowPlayingMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.NowPlaying, nowPlayingMap);\n        nowPlayingMap.put(\"album\", XMLHandlerState.NowPlayingAlbum);\n        nowPlayingMap.put(\"art\", XMLHandlerState.NowPlayingArt);\n        nowPlayingMap.put(\"artist\", XMLHandlerState.NowPlayingArtist);\n        nowPlayingMap.put(\"ContentItem\", XMLHandlerState.ContentItem);\n        nowPlayingMap.put(\"description\", XMLHandlerState.NowPlayingDescription);\n        nowPlayingMap.put(\"playStatus\", XMLHandlerState.NowPlayingPlayStatus);\n        nowPlayingMap.put(\"rateEnabled\", XMLHandlerState.NowPlayingRateEnabled);\n        nowPlayingMap.put(\"skipEnabled\", XMLHandlerState.NowPlayingSkipEnabled);\n        nowPlayingMap.put(\"skipPreviousEnabled\", XMLHandlerState.NowPlayingSkipPreviousEnabled);\n        nowPlayingMap.put(\"stationLocation\", XMLHandlerState.NowPlayingStationLocation);\n        nowPlayingMap.put(\"stationName\", XMLHandlerState.NowPlayingStationName);\n        nowPlayingMap.put(\"track\", XMLHandlerState.NowPlayingTrack);\n        nowPlayingMap.put(\"connectionStatusInfo\", XMLHandlerState.Unprocessed); // TODO active when Source==Bluetooth\n        // TODO active when Source==Pandora and maybe also other sources - seems to be rating related\n        nowPlayingMap.put(\"time\", XMLHandlerState.Unprocessed);\n        nowPlayingMap.put(\"rating\", XMLHandlerState.Unprocessed);\n        nowPlayingMap.put(\"rateEnabled\", XMLHandlerState.Unprocessed);\n\n        // ContentItem specifies a resource (that also could be bookmarked in a preset)\n        Map<String, XMLHandlerState> contentItemMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.ContentItem, contentItemMap);\n        contentItemMap.put(\"itemName\", XMLHandlerState.ContentItemItemName);\n        contentItemMap.put(\"containerArt\", XMLHandlerState.ContentItemContainerArt);\n\n        Map<String, XMLHandlerState> presetMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Preset, presetMap);\n        presetMap.put(\"ContentItem\", XMLHandlerState.ContentItem);\n\n        Map<String, XMLHandlerState> zoneMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Zone, zoneMap);\n        zoneMap.put(\"member\", XMLHandlerState.ZoneMember);\n\n        Map<String, XMLHandlerState> bassMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Bass, bassMap);\n        bassMap.put(\"targetbass\", XMLHandlerState.BassTarget);\n        bassMap.put(\"actualbass\", XMLHandlerState.BassActual);\n\n        Map<String, XMLHandlerState> sourceMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Sources, sourceMap);\n\n        Map<String, XMLHandlerState> bassCapabilitiesMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.BassCapabilities, bassCapabilitiesMap);\n        bassCapabilitiesMap.put(\"bassAvailable\", XMLHandlerState.BassAvailable);\n        bassCapabilitiesMap.put(\"bassMin\", XMLHandlerState.BassMin);\n        bassCapabilitiesMap.put(\"bassMax\", XMLHandlerState.BassMax);\n        bassCapabilitiesMap.put(\"bassDefault\", XMLHandlerState.BassDefault);\n\n        Map<String, XMLHandlerState> groupsMap = new HashMap<>();\n        stateSwitchingMap.put(XMLHandlerState.Group, groupsMap);\n        groupsMap.put(\"name\", XMLHandlerState.GroupName);\n        groupsMap.put(\"masterDeviceId\", XMLHandlerState.MasterDeviceId);\n        groupsMap.put(\"roles\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"senderIPAddress\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"status\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"roles\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"groupRole\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"deviceId\", XMLHandlerState.DeviceId);\n        groupsMap.put(\"role\", XMLHandlerState.Unprocessed);\n        groupsMap.put(\"ipAddress\", XMLHandlerState.DeviceIp);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.denonmarantz.internal.connector.http;\n\nimport java.beans.Introspector;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Marshaller;\nimport javax.xml.bind.UnmarshalException;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.util.StreamReaderDelegate;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.Response;\nimport org.eclipse.jetty.client.api.Result;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzState;\nimport org.openhab.binding.denonmarantz.internal.config.DenonMarantzConfiguration;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnector;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.Deviceinfo;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.Main;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.ZoneStatus;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.ZoneStatusLite;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.AppCommandRequest;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.AppCommandResponse;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.CommandRx;\nimport org.openhab.binding.denonmarantz.internal.xml.entities.commands.CommandTx;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class makes the connection to the receiver and manages it.\n * It is also responsible for sending commands to the receiver.\n * *\n *\n * @author Jeroen Idserda - Initial Contribution (1.x Binding)\n * @author Jan-Willem Veldhuis - Refactored for 2.x\n */\npublic class DenonMarantzHttpConnector extends DenonMarantzConnector {\n\n    private Logger logger = LoggerFactory.getLogger(DenonMarantzHttpConnector.class);\n\n    private static final int REQUEST_TIMEOUT_MS = 5000; // 5 seconds\n\n    // Main URL for the receiver\n    private static final String URL_MAIN = \"formMainZone_MainZoneXml.xml\";\n\n    // Main Zone Status URL\n    private static final String URL_ZONE_MAIN = \"formMainZone_MainZoneXmlStatus.xml\";\n\n    // Secondary zone lite status URL (contains less info)\n    private static final String URL_ZONE_SECONDARY_LITE = \"formZone%d_Zone%dXmlStatusLite.xml\";\n\n    // Device info URL\n    private static final String URL_DEVICE_INFO = \"Deviceinfo.xml\";\n\n    // URL to send app commands to\n    private static final String URL_APP_COMMAND = \"AppCommand.xml\";\n\n    private static final String CONTENT_TYPE_XML = \"application/xml\";\n\n    private final String cmdUrl;\n\n    private final String statusUrl;\n\n    private final HttpClient httpClient;\n\n    private ScheduledFuture<?> pollingJob;\n\n    public DenonMarantzHttpConnector(DenonMarantzConfiguration config, DenonMarantzState state,\n            ScheduledExecutorService scheduler, HttpClient httpClient) {\n        this.config = config;\n        this.scheduler = scheduler;\n        this.state = state;\n        this.cmdUrl = String.format(\"http://%s:%d/goform/formiPhoneAppDirect.xml?\", config.getHost(),\n                config.getHttpPort());\n        this.statusUrl = String.format(\"http://%s:%d/goform/\", config.getHost(), config.getHttpPort());\n        this.httpClient = httpClient;\n    }\n\n    public DenonMarantzState getState() {\n        return state;\n    }\n\n    /**\n     * Set up the connection to the receiver by starting to poll the HTTP API.\n     */\n    @Override\n    public void connect() {\n        if (!isPolling()) {\n            logger.debug(\"HTTP polling started.\");\n            try {\n                setConfigProperties();\n            } catch (IOException e) {\n                logger.debug(\"IO error while retrieving document:\", e);\n                state.connectionError(\"IO error while connecting to AVR: \" + e.getMessage());\n                return;\n            }\n\n            pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n                try {\n                    refreshHttpProperties();\n                } catch (IOException e) {\n                    logger.debug(\"IO error while retrieving document\", e);\n                    state.connectionError(\"IO error while connecting to AVR: \" + e.getMessage());\n                    stopPolling();\n                } catch (RuntimeException e) {\n                    /**\n                     * We need to catch this RuntimeException, as otherwise the polling stops.\n                     * Log as error as it could be a user configuration error.\n                     */\n                    StringBuilder sb = new StringBuilder();\n                    for (StackTraceElement s : e.getStackTrace()) {\n                        sb.append(s.toString()).append(\"\\n\");\n                    }\n                    logger.error(\"Error while polling Http: \\\"{}\\\". Stacktrace: \\n{}\", e.getMessage(), sb.toString());\n                }\n            }, 0, config.httpPollingInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isPolling() {\n        return pollingJob != null && !pollingJob.isCancelled();\n    }\n\n    private void stopPolling() {\n        if (isPolling()) {\n            pollingJob.cancel(true);\n            logger.debug(\"HTTP polling stopped.\");\n        }\n    }\n\n    /**\n     * Shutdown the http client\n     */\n    @Override\n    public void dispose() {\n        logger.debug(\"disposing connector\");\n\n        stopPolling();\n    }\n\n    @Override\n    protected void internalSendCommand(String command) {\n        logger.debug(\"Sending command '{}'\", command);\n        if (StringUtils.isBlank(command)) {\n            logger.warn(\"Trying to send empty command\");\n            return;\n        }\n\n        try {\n            String url = cmdUrl + URLEncoder.encode(command, Charset.defaultCharset().displayName());\n            logger.trace(\"Calling url {}\", url);\n\n            httpClient.newRequest(url).timeout(5, TimeUnit.SECONDS).send(new Response.CompleteListener() {\n                @Override\n                public void onComplete(Result result) {\n                    if (result.getResponse().getStatus() != 200) {\n                        logger.warn(\"Error {} while sending command\", result.getResponse().getReason());\n                    }\n                }\n            });\n\n        } catch (UnsupportedEncodingException e) {\n            logger.warn(\"Error sending command\", e);\n        }\n    }\n\n    private void updateMain() throws IOException {\n        String url = statusUrl + URL_MAIN;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        Main statusMain = getDocument(url, Main.class);\n        if (statusMain != null) {\n            state.setPower(statusMain.getPower().getValue());\n        }\n    }\n\n    private void updateMainZone() throws IOException {\n        String url = statusUrl + URL_ZONE_MAIN;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        ZoneStatus mainZone = getDocument(url, ZoneStatus.class);\n        if (mainZone != null) {\n            state.setInput(mainZone.getInputFuncSelect().getValue());\n            state.setMainVolume(mainZone.getMasterVolume().getValue());\n            state.setMainZonePower(mainZone.getPower().getValue());\n            state.setMute(mainZone.getMute().getValue());\n\n            if (config.inputOptions == null) {\n                config.inputOptions = mainZone.getInputFuncList();\n            }\n\n            if (mainZone.getSurrMode() == null) {\n                logger.debug(\"Unable to get the SURROUND_MODE. MainZone update may not be correct.\");\n            } else {\n                state.setSurroundProgram(mainZone.getSurrMode().getValue());\n            }\n        }\n    }\n\n    private void updateSecondaryZones() throws IOException {\n        for (int i = 2; i <= config.getZoneCount(); i++) {\n            String url = String.format(\"%s\" + URL_ZONE_SECONDARY_LITE, statusUrl, i, i);\n            logger.trace(\"Refreshing URL: {}\", url);\n            ZoneStatusLite zoneSecondary = getDocument(url, ZoneStatusLite.class);\n            if (zoneSecondary != null) {\n                switch (i) {\n                    // maximum 2 secondary zones are supported\n                    case 2:\n                        state.setZone2Power(zoneSecondary.getPower().getValue());\n                        state.setZone2Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone2Mute(zoneSecondary.getMute().getValue());\n                        state.setZone2Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                    case 3:\n                        state.setZone3Power(zoneSecondary.getPower().getValue());\n                        state.setZone3Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone3Mute(zoneSecondary.getMute().getValue());\n                        state.setZone3Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                    case 4:\n                        state.setZone4Power(zoneSecondary.getPower().getValue());\n                        state.setZone4Volume(zoneSecondary.getMasterVolume().getValue());\n                        state.setZone4Mute(zoneSecondary.getMute().getValue());\n                        state.setZone4Input(zoneSecondary.getInputFuncSelect().getValue());\n                        break;\n                }\n            }\n        }\n    }\n\n    private void updateDisplayInfo() throws IOException {\n        String url = statusUrl + URL_APP_COMMAND;\n        logger.trace(\"Refreshing URL: {}\", url);\n\n        AppCommandRequest request = AppCommandRequest.of(CommandTx.CMD_NET_STATUS);\n        AppCommandResponse response = postDocument(url, AppCommandResponse.class, request);\n\n        if (response != null) {\n            CommandRx titleInfo = response.getCommands().get(0);\n            state.setNowPlayingArtist(titleInfo.getText(\"artist\"));\n            state.setNowPlayingAlbum(titleInfo.getText(\"album\"));\n            state.setNowPlayingTrack(titleInfo.getText(\"track\"));\n        }\n    }\n\n    private boolean setConfigProperties() throws IOException {\n        String url = statusUrl + URL_DEVICE_INFO;\n        logger.debug(\"Refreshing URL: {}\", url);\n\n        Deviceinfo deviceinfo = getDocument(url, Deviceinfo.class);\n        if (deviceinfo != null) {\n            config.setZoneCount(deviceinfo.getDeviceZones());\n        }\n\n        /**\n         * The maximum volume is received from the telnet connection in the\n         * form of the MVMAX property. It is not always received reliable however,\n         * so we're using a default for now.\n         */\n        config.setMainVolumeMax(DenonMarantzConfiguration.MAX_VOLUME);\n\n        // if deviceinfo is null, something went wrong (and is logged in getDocument catch blocks)\n        return (deviceinfo != null);\n    }\n\n    private void refreshHttpProperties() throws IOException {\n        logger.trace(\"Refreshing Denon status\");\n\n        updateMain();\n        updateMainZone();\n        updateSecondaryZones();\n        updateDisplayInfo();\n    }\n\n    @Nullable\n    private <T> T getDocument(String uri, Class<T> response) throws IOException {\n        try {\n            String result = HttpUtil.executeUrl(\"GET\", uri, REQUEST_TIMEOUT_MS);\n            logger.trace(\"result of getDocument for uri '{}':\\r\\n{}\", uri, result);\n\n            if (StringUtils.isNotBlank(result)) {\n                JAXBContext jc = JAXBContext.newInstance(response);\n                XMLInputFactory xif = XMLInputFactory.newInstance();\n                xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n                xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n                XMLStreamReader xsr = xif.createXMLStreamReader(IOUtils.toInputStream(result));\n                xsr = new PropertyRenamerDelegate(xsr);\n\n                @SuppressWarnings(\"unchecked\")\n                T obj = (T) jc.createUnmarshaller().unmarshal(xsr);\n\n                return obj;\n            }\n        } catch (UnmarshalException e) {\n            logger.debug(\"Failed to unmarshal xml document: {}\", e.getMessage());\n        } catch (JAXBException e) {\n            logger.debug(\"Unexpected error occurred during unmarshalling of document: {}\", e.getMessage());\n        } catch (XMLStreamException e) {\n            logger.debug(\"Communication error: {}\", e.getMessage());\n        }\n\n        return null;\n    }\n\n    @Nullable\n    private <T, S> T postDocument(String uri, Class<T> response, S request) throws IOException {\n        try {\n            JAXBContext jaxbContext = JAXBContext.newInstance(request.getClass());\n            Marshaller jaxbMarshaller = jaxbContext.createMarshaller();\n            StringWriter sw = new StringWriter();\n            jaxbMarshaller.marshal(request, sw);\n\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(sw.toString().getBytes(StandardCharsets.UTF_8));\n            String result = HttpUtil.executeUrl(\"POST\", uri, inputStream, CONTENT_TYPE_XML, REQUEST_TIMEOUT_MS);\n\n            if (StringUtils.isNotBlank(result)) {\n                JAXBContext jcResponse = JAXBContext.newInstance(response);\n\n                @SuppressWarnings(\"unchecked\")\n                T obj = (T) jcResponse.createUnmarshaller().unmarshal(IOUtils.toInputStream(result));\n\n                return obj;\n            }\n        } catch (JAXBException e) {\n            logger.debug(\"Encoding error in post\", e);\n        }\n\n        return null;\n    }\n\n    private static class PropertyRenamerDelegate extends StreamReaderDelegate {\n\n        public PropertyRenamerDelegate(XMLStreamReader xsr) {\n            super(xsr);\n        }\n\n        @Override\n        public String getAttributeLocalName(int index) {\n            return Introspector.decapitalize(super.getAttributeLocalName(index));\n        }\n\n        @Override\n        public String getLocalName() {\n            return Introspector.decapitalize(super.getLocalName());\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.denonmarantz.internal.handler;\n\nimport static org.openhab.binding.denonmarantz.internal.DenonMarantzBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.HttpURLConnection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.thing.Channel;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\nimport org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\nimport org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzState;\nimport org.openhab.binding.denonmarantz.internal.DenonMarantzStateChangedListener;\nimport org.openhab.binding.denonmarantz.internal.UnsupportedCommandTypeException;\nimport org.openhab.binding.denonmarantz.internal.config.DenonMarantzConfiguration;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnector;\nimport org.openhab.binding.denonmarantz.internal.connector.DenonMarantzConnectorFactory;\nimport org.openhab.binding.denonmarantz.internal.connector.http.DenonMarantzHttpConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link DenonMarantzHandler} is responsible for handling commands, which are\n * sent to one of the channels.\n *\n * @author Jan-Willem Veldhuis - Initial contribution\n */\npublic class DenonMarantzHandler extends BaseThingHandler implements DenonMarantzStateChangedListener {\n\n    private final Logger logger = LoggerFactory.getLogger(DenonMarantzHandler.class);\n    private static final int RETRY_TIME_SECONDS = 30;\n    private HttpClient httpClient;\n    private DenonMarantzConnector connector;\n    private DenonMarantzConfiguration config;\n    private DenonMarantzConnectorFactory connectorFactory = new DenonMarantzConnectorFactory();\n    private DenonMarantzState denonMarantzState;\n    private ScheduledFuture<?> retryJob;\n\n    public DenonMarantzHandler(Thing thing, HttpClient httpClient) {\n        super(thing);\n        this.httpClient = httpClient;\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        if (connector == null) {\n            return;\n        }\n\n        if (connector instanceof DenonMarantzHttpConnector && command instanceof RefreshType) {\n            // Refreshing individual channels isn't supported by the Http connector.\n            // The connector refreshes all channels together at the configured polling interval.\n            return;\n        }\n\n        try {\n            switch (channelUID.getId()) {\n                case CHANNEL_POWER:\n                    connector.sendPowerCommand(command, 0);\n                    break;\n                case CHANNEL_MAIN_ZONE_POWER:\n                    connector.sendPowerCommand(command, 1);\n                    break;\n                case CHANNEL_MUTE:\n                    connector.sendMuteCommand(command, 1);\n                    break;\n                case CHANNEL_MAIN_VOLUME:\n                    connector.sendVolumeCommand(command, 1);\n                    break;\n                case CHANNEL_MAIN_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 1);\n                    break;\n                case CHANNEL_INPUT:\n                    connector.sendInputCommand(command, 1);\n                    break;\n                case CHANNEL_SURROUND_PROGRAM:\n                    connector.sendSurroundProgramCommand(command);\n                    break;\n                case CHANNEL_COMMAND:\n                    connector.sendCustomCommand(command);\n                    break;\n\n                case CHANNEL_ZONE2_POWER:\n                    connector.sendPowerCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_MUTE:\n                    connector.sendMuteCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_VOLUME:\n                    connector.sendVolumeCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 2);\n                    break;\n                case CHANNEL_ZONE2_INPUT:\n                    connector.sendInputCommand(command, 2);\n                    break;\n\n                case CHANNEL_ZONE3_POWER:\n                    connector.sendPowerCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_MUTE:\n                    connector.sendMuteCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_VOLUME:\n                    connector.sendVolumeCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 3);\n                    break;\n                case CHANNEL_ZONE3_INPUT:\n                    connector.sendInputCommand(command, 3);\n                    break;\n\n                case CHANNEL_ZONE4_POWER:\n                    connector.sendPowerCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_MUTE:\n                    connector.sendMuteCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_VOLUME:\n                    connector.sendVolumeCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_VOLUME_DB:\n                    connector.sendVolumeDbCommand(command, 4);\n                    break;\n                case CHANNEL_ZONE4_INPUT:\n                    connector.sendInputCommand(command, 4);\n                    break;\n\n                default:\n                    throw new UnsupportedCommandTypeException();\n            }\n        } catch (UnsupportedCommandTypeException e) {\n            logger.debug(\"Unsupported command {} for channel {}\", command, channelUID.getId());\n        }\n    }\n\n    public boolean checkConfiguration() {\n        // prevent too low values for polling interval\n        if (config.httpPollingInterval < 5) {\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                    \"The polling interval should be at least 5 seconds!\");\n            return false;\n        }\n        // Check zone count is within supported range\n        if (config.getZoneCount() < 1 || config.getZoneCount() > 4) {\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                    \"This binding supports 1 to 4 zones. Please update the zone count.\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Try to auto configure the connection type (Telnet or HTTP)\n     * for Things not added through Paper UI.\n     */\n    private void autoConfigure() {\n        /*\n         * The isTelnet parameter has no default.\n         * When not set we will try to auto-detect the correct values\n         * for isTelnet and zoneCount and update the Thing accordingly.\n         */\n        if (config.isTelnet() == null) {\n            logger.debug(\"Trying to auto-detect the connection.\");\n            ContentResponse response;\n            boolean telnetEnable = true;\n            int httpPort = 80;\n            boolean httpApiUsable = false;\n\n            // try to reach the HTTP API at port 80 (most models, except Denon ...H should respond.\n            String host = config.getHost();\n            try {\n                response = httpClient.newRequest(\"http://\" + host + \"/goform/Deviceinfo.xml\")\n                        .timeout(3, TimeUnit.SECONDS).send();\n                if (response.getStatus() == HttpURLConnection.HTTP_OK) {\n                    logger.debug(\"We can access the HTTP API, disabling the Telnet mode by default.\");\n                    telnetEnable = false;\n                    httpApiUsable = true;\n                }\n            } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                logger.debug(\"Error when trying to access AVR using HTTP on port 80, reverting to Telnet mode.\", e);\n            }\n\n            if (telnetEnable) {\n                // the above attempt failed. Let's try on port 8080, as for some models a subset of the HTTP API is\n                // available\n                try {\n                    response = httpClient.newRequest(\"http://\" + host + \":8080/goform/Deviceinfo.xml\")\n                            .timeout(3, TimeUnit.SECONDS).send();\n                    if (response.getStatus() == HttpURLConnection.HTTP_OK) {\n                        logger.debug(\n                                \"This model responds to HTTP port 8080, we use this port to retrieve the number of zones.\");\n                        httpPort = 8080;\n                        httpApiUsable = true;\n                    }\n                } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                    logger.debug(\"Additionally tried to connect to port 8080, this also failed\", e);\n                }\n            }\n\n            // default zone count\n            int zoneCount = 2;\n\n            // try to determine the zone count by checking the Deviceinfo.xml file\n            if (httpApiUsable) {\n                int status = 0;\n                response = null;\n                try {\n                    response = httpClient.newRequest(\"http://\" + host + \":\" + httpPort + \"/goform/Deviceinfo.xml\")\n                            .timeout(3, TimeUnit.SECONDS).send();\n                    status = response.getStatus();\n                } catch (InterruptedException | TimeoutException | ExecutionException e) {\n                    logger.debug(\"Failed in fetching the Deviceinfo.xml to determine zone count\", e);\n                }\n\n                if (status == HttpURLConnection.HTTP_OK && response != null) {\n                    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n                    try {\n                        // see\n                        // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n                        domFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                        domFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                        domFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n                        domFactory.setXIncludeAware(false);\n                        domFactory.setExpandEntityReferences(false);\n                        DocumentBuilder builder;\n                        builder = domFactory.newDocumentBuilder();\n                        Document dDoc = builder.parse(new InputSource(new StringReader(response.getContentAsString())));\n                        XPath xPath = XPathFactory.newInstance().newXPath();\n                        Node node = (Node) xPath.evaluate(\"/Device_Info/DeviceZones/text()\", dDoc, XPathConstants.NODE);\n                        if (node != null) {\n                            String nodeValue = node.getNodeValue();\n                            logger.trace(\"/Device_Info/DeviceZones/text() = {}\", nodeValue);\n                            zoneCount = Integer.parseInt(nodeValue);\n                            logger.debug(\"Discovered number of zones: {}\", zoneCount);\n                        }\n                    } catch (ParserConfigurationException | SAXException | IOException | XPathExpressionException\n                            | NumberFormatException e) {\n                        logger.debug(\"Something went wrong with looking up the zone count in Deviceinfo.xml: {}\",\n                                e.getMessage());\n                    }\n                }\n            }\n            config.setTelnet(telnetEnable);\n            config.setZoneCount(zoneCount);\n            Configuration configuration = editConfiguration();\n            configuration.put(PARAMETER_TELNET_ENABLED, telnetEnable);\n            configuration.put(PARAMETER_ZONE_COUNT, zoneCount);\n            updateConfiguration(configuration);\n        }\n    }\n\n    @Override\n    public void initialize() {\n        cancelRetry();\n        config = getConfigAs(DenonMarantzConfiguration.class);\n\n        // Configure Connection type (Telnet/HTTP) and number of zones\n        // Note: this only happens for discovered Things\n        autoConfigure();\n\n        if (!checkConfiguration()) {\n            return;\n        }\n\n        denonMarantzState = new DenonMarantzState(this);\n        configureZoneChannels();\n        updateStatus(ThingStatus.UNKNOWN);\n        // create connection (either Telnet or HTTP)\n        // ThingStatus ONLINE/OFFLINE is set when AVR status is known.\n        createConnection();\n    }\n\n    private void createConnection() {\n        if (connector != null) {\n            connector.dispose();\n        }\n        connector = connectorFactory.getConnector(config, denonMarantzState, scheduler, httpClient);\n        connector.connect();\n    }\n\n    private void cancelRetry() {\n        ScheduledFuture<?> localRetryJob = retryJob;\n        if (localRetryJob != null && !localRetryJob.isDone()) {\n            localRetryJob.cancel(false);\n        }\n    }\n\n    private void configureZoneChannels() {\n        logger.debug(\"Configuring zone channels\");\n        Integer zoneCount = config.getZoneCount();\n        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n        boolean channelsUpdated = false;\n\n        // construct a set with the existing channel type UIDs, to quickly check\n        Set<String> currentChannels = new HashSet<>();\n        channels.forEach(channel -> currentChannels.add(channel.getUID().getId()));\n\n        Set<Entry<String, ChannelTypeUID>> channelsToRemove = new HashSet<>();\n\n        if (zoneCount > 1) {\n            List<Entry<String, ChannelTypeUID>> channelsToAdd = new ArrayList<>(ZONE2_CHANNEL_TYPES.entrySet());\n\n            if (zoneCount > 2) {\n                // add channels for zone 3\n                channelsToAdd.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n                if (zoneCount > 3) {\n                    // add channels for zone 4 (more zones currently not supported)\n                    channelsToAdd.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n                } else {\n                    channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n                }\n            } else {\n                channelsToRemove.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n                channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n            }\n\n            // filter out the already existing channels\n            channelsToAdd.removeIf(c -> currentChannels.contains(c.getKey()));\n\n            // add the channels that were not yet added\n            if (!channelsToAdd.isEmpty()) {\n                for (Entry<String, ChannelTypeUID> entry : channelsToAdd) {\n                    String itemType = CHANNEL_ITEM_TYPES.get(entry.getKey());\n                    Channel channel = ChannelBuilder\n                            .create(new ChannelUID(this.getThing().getUID(), entry.getKey()), itemType)\n                            .withType(entry.getValue()).build();\n                    channels.add(channel);\n                }\n                channelsUpdated = true;\n            } else {\n                logger.debug(\"No zone channels have been added\");\n            }\n        } else {\n            channelsToRemove.addAll(ZONE2_CHANNEL_TYPES.entrySet());\n            channelsToRemove.addAll(ZONE3_CHANNEL_TYPES.entrySet());\n            channelsToRemove.addAll(ZONE4_CHANNEL_TYPES.entrySet());\n        }\n\n        // filter out the non-existing channels\n        channelsToRemove.removeIf(c -> !currentChannels.contains(c.getKey()));\n\n        // remove the channels that were not yet added\n        if (!channelsToRemove.isEmpty()) {\n            for (Entry<String, ChannelTypeUID> entry : channelsToRemove) {\n                if (channels.removeIf(c -> (entry.getKey()).equals(c.getUID().getId()))) {\n                    logger.trace(\"Removed channel {}\", entry.getKey());\n                } else {\n                    logger.trace(\"Could NOT remove channel {}\", entry.getKey());\n                }\n            }\n            channelsUpdated = true;\n        } else {\n            logger.debug(\"No zone channels have been removed\");\n        }\n\n        // update Thing if channels changed\n        if (channelsUpdated) {\n            updateThing(editThing().withChannels(channels).build());\n        }\n    }\n\n    @Override\n    public void dispose() {\n        if (connector != null) {\n            connector.dispose();\n            connector = null;\n        }\n        cancelRetry();\n        super.dispose();\n    }\n\n    @Override\n    public void channelLinked(ChannelUID channelUID) {\n        super.channelLinked(channelUID);\n        String channelID = channelUID.getId();\n        if (isLinked(channelID)) {\n            State state = denonMarantzState.getStateForChannelID(channelID);\n            if (state != null) {\n                updateState(channelID, state);\n            }\n        }\n    }\n\n    @Override\n    public void stateChanged(String channelID, State state) {\n        logger.debug(\"Received state {} for channelID {}\", state, channelID);\n\n        // Don't flood the log with thing 'updated: ONLINE' each time a single channel changed\n        if (this.getThing().getStatus() != ThingStatus.ONLINE) {\n            updateStatus(ThingStatus.ONLINE);\n        }\n        updateState(channelID, state);\n    }\n\n    @Override\n    public void connectionError(String errorMessage) {\n        if (this.getThing().getStatus() != ThingStatus.OFFLINE) {\n            // Don't flood the log with thing 'updated: OFFLINE' when already offline\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n        }\n        connector.dispose();\n        retryJob = scheduler.schedule(this::createConnection, RETRY_TIME_SECONDS, TimeUnit.SECONDS);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.dlinksmarthome.internal;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Iterator;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.soap.MessageFactory;\nimport javax.xml.soap.MimeHeader;\nimport javax.xml.soap.MimeHeaders;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.client.api.Request;\nimport org.eclipse.jetty.client.util.BytesContentProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link DLinkHNAPCommunication} is responsible for communicating with D-Link\n * Smart Home devices using the HNAP interface.\n *\n * This abstract class handles login and authentication which is common between devices.\n *\n * Reverse engineered from Login.html and soapclient.js retrieved from the device.\n *\n * @author Mike Major - Initial contribution\n */\npublic abstract class DLinkHNAPCommunication {\n\n    // SOAP actions\n    private static final String LOGIN_ACTION = \"\\\"http://purenetworks.com/HNAP1/LOGIN\\\"\";\n\n    // Strings used more than once\n    private static final String LOGIN = \"LOGIN\";\n    private static final String ACTION = \"Action\";\n    private static final String USERNAME = \"Username\";\n    private static final String LOGINPASSWORD = \"LoginPassword\";\n    private static final String CAPTCHA = \"Captcha\";\n    private static final String ADMIN = \"Admin\";\n    private static final String LOGINRESULT = \"LOGINResult\";\n    private static final String COOKIE = \"Cookie\";\n\n    /**\n     * HNAP XMLNS\n     */\n    protected static final String HNAP_XMLNS = \"http://purenetworks.com/HNAP1\";\n    /**\n     * The SOAP action HTML header\n     */\n    protected static final String SOAPACTION = \"SOAPAction\";\n    /**\n     * OK represents a successful action\n     */\n    protected static final String OK = \"OK\";\n\n    /**\n     * Use to log connection issues\n     */\n    private final Logger logger = LoggerFactory.getLogger(DLinkHNAPCommunication.class);\n\n    private URI uri;\n    private final HttpClient httpClient;\n    private final String pin;\n    private String privateKey;\n\n    private DocumentBuilder parser;\n    private SOAPMessage requestAction;\n    private SOAPMessage loginAction;\n\n    private HNAPStatus status = HNAPStatus.INITIALISED;\n\n    /**\n     * Indicates the status of the HNAP interface\n     *\n     */\n    protected enum HNAPStatus {\n        /**\n         * Ready to start communication with device\n         */\n        INITIALISED,\n        /**\n         * Successfully logged in to device\n         */\n        LOGGED_IN,\n        /**\n         * Problem communicating with device\n         */\n        COMMUNICATION_ERROR,\n        /**\n         * Internal error\n         */\n        INTERNAL_ERROR,\n        /**\n         * Error due to unsupported firmware\n         */\n        UNSUPPORTED_FIRMWARE,\n        /**\n         * Error due to invalid pin code\n         */\n        INVALID_PIN\n    }\n\n    /**\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after construction.\n     *\n     * @param ipAddress\n     * @param pin\n     */\n    public DLinkHNAPCommunication(final String ipAddress, final String pin) {\n        this.pin = pin;\n\n        httpClient = new HttpClient();\n\n        try {\n            uri = new URI(\"http://\" + ipAddress + \"/HNAP1\");\n            httpClient.start();\n\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            parser = dbf.newDocumentBuilder();\n\n            final MessageFactory messageFactory = MessageFactory.newInstance();\n            requestAction = messageFactory.createMessage();\n            loginAction = messageFactory.createMessage();\n\n            buildRequestAction();\n            buildLoginAction();\n        } catch (final SOAPException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final URISyntaxException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final ParserConfigurationException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final Exception e) {\n            // Thrown by httpClient.start()\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        }\n    }\n\n    /**\n     * Stop communicating with the device\n     */\n    public void dispose() {\n        try {\n            httpClient.stop();\n        } catch (final Exception e) {\n            // Ignored\n        }\n    }\n\n    /**\n     * This is the first SOAP message used in the login process and is used to retrieve\n     * the cookie, challenge and public key used for authentication.\n     *\n     * @throws SOAPException\n     */\n    private void buildRequestAction() throws SOAPException {\n        requestAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = requestAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"request\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = requestAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n\n        requestAction.saveChanges();\n    }\n\n    /**\n     * This is the second SOAP message used in the login process and uses a password derived\n     * from the challenge, public key and the device's pin code.\n     *\n     * @throws SOAPException\n     */\n    private void buildLoginAction() throws SOAPException {\n        loginAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = loginAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"login\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = loginAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n    }\n\n    /**\n     * Sets the password for the second login message based on the data received from the\n     * first login message. Also sets the private key used to generate the authentication header.\n     *\n     * @param challenge\n     * @param cookie\n     * @param publicKey\n     * @throws SOAPException\n     * @throws InvalidKeyException\n     * @throws NoSuchAlgorithmException\n     */\n    private void setAuthenticationData(final String challenge, final String cookie, final String publicKey)\n            throws SOAPException, InvalidKeyException, NoSuchAlgorithmException {\n        final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n        loginHeaders.setHeader(COOKIE, \"uid=\" + cookie);\n\n        privateKey = hash(challenge, publicKey + pin);\n\n        final String password = hash(challenge, privateKey);\n\n        loginAction.getSOAPBody().getElementsByTagName(LOGINPASSWORD).item(0).setTextContent(password);\n        loginAction.saveChanges();\n    }\n\n    /**\n     * Used to hash the authentication data such as the login password and the authentication header\n     * for the detection message.\n     *\n     * @param data\n     * @param key\n     * @return The hashed data\n     * @throws NoSuchAlgorithmException\n     * @throws InvalidKeyException\n     */\n    private String hash(final String data, final String key) throws NoSuchAlgorithmException, InvalidKeyException {\n        final Mac mac = Mac.getInstance(\"HMACMD5\");\n        final SecretKeySpec sKey = new SecretKeySpec(key.getBytes(), \"ASCII\");\n\n        mac.init(sKey);\n        final byte[] bytes = mac.doFinal(data.getBytes());\n\n        final StringBuilder hashBuf = new StringBuilder();\n        for (int i = 0; i < bytes.length; i++) {\n            final String hex = Integer.toHexString(0xFF & bytes[i]).toUpperCase();\n            if (hex.length() == 1) {\n                hashBuf.append('0');\n            }\n            hashBuf.append(hex);\n        }\n\n        return hashBuf.toString();\n    }\n\n    /**\n     * Output unexpected responses to the debug log and sets the FIRMWARE error.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    private void unexpectedResult(final String message, final Document soapResponse) {\n        logUnexpectedResult(message, soapResponse);\n\n        // Best guess when receiving unexpected responses\n        status = HNAPStatus.UNSUPPORTED_FIRMWARE;\n    }\n\n    /**\n     * Get the status of the HNAP interface\n     *\n     * @return the HNAP status\n     */\n    protected HNAPStatus getHNAPStatus() {\n        return status;\n    }\n\n    /**\n     * Sends the two login messages and stores the private key used to generate the\n     * authentication header required for actions.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param timeout - Connection timeout in milliseconds\n     */\n    protected void login(final int timeout) {\n        if (status != HNAPStatus.INTERNAL_ERROR) {\n            try {\n                Document soapResponse = sendReceive(requestAction, timeout);\n\n                Node result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                if (result != null && OK.equals(result.getTextContent())) {\n                    final Node challengeNode = soapResponse.getElementsByTagName(\"Challenge\").item(0);\n                    final Node cookieNode = soapResponse.getElementsByTagName(COOKIE).item(0);\n                    final Node publicKeyNode = soapResponse.getElementsByTagName(\"PublicKey\").item(0);\n\n                    if (challengeNode != null && cookieNode != null && publicKeyNode != null) {\n                        setAuthenticationData(challengeNode.getTextContent(), cookieNode.getTextContent(),\n                                publicKeyNode.getTextContent());\n\n                        soapResponse = sendReceive(loginAction, timeout);\n                        result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                        if (result != null) {\n                            if (\"success\".equals(result.getTextContent())) {\n                                status = HNAPStatus.LOGGED_IN;\n                            } else {\n                                logger.debug(\"login - Check pin is correct\");\n                                // Assume pin code problem rather than a firmware change\n                                status = HNAPStatus.INVALID_PIN;\n                            }\n                        } else {\n                            unexpectedResult(\"login - Unexpected login response\", soapResponse);\n                        }\n                    } else {\n                        unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                    }\n                } else {\n                    unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                }\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final Exception e) {\n                // Assume there has been some problem trying to send one of the messages\n                if (status != HNAPStatus.COMMUNICATION_ERROR) {\n                    logger.debug(\"login - Communication error\", e);\n                    status = HNAPStatus.COMMUNICATION_ERROR;\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the authentication headers for the action message. This should only be called\n     * after a successful login.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param action - SOAP Action to add headers\n     */\n    protected void setAuthenticationHeaders(final SOAPMessage action) {\n        if (status == HNAPStatus.LOGGED_IN) {\n            try {\n                final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n                final MimeHeaders actionHeaders = action.getMimeHeaders();\n\n                actionHeaders.setHeader(COOKIE, loginHeaders.getHeader(COOKIE)[0]);\n\n                final String timeStamp = String.valueOf(System.currentTimeMillis() / 1000);\n                final String auth = hash(timeStamp + actionHeaders.getHeader(SOAPACTION)[0], privateKey) + \" \"\n                        + timeStamp;\n                actionHeaders.setHeader(\"HNAP_AUTH\", auth);\n\n                action.saveChanges();\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final SOAPException e) {\n                // No communication happening so assume system error\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            }\n        }\n    }\n\n    /**\n     * Send the SOAP message using Jetty HTTP client. Jetty is used in preference to\n     * HttpURLConnection which can result in the HNAP interface becoming unresponsive.\n     *\n     * @param action - SOAP Action to send\n     * @param timeout - Connection timeout in milliseconds\n     * @return The result\n     * @throws IOException\n     * @throws SOAPException\n     * @throws SAXException\n     * @throws ExecutionException\n     * @throws TimeoutException\n     * @throws InterruptedException\n     */\n    protected Document sendReceive(final SOAPMessage action, final int timeout) throws IOException, SOAPException,\n            SAXException, InterruptedException, TimeoutException, ExecutionException {\n        Document result;\n\n        final Request request = httpClient.POST(uri);\n        request.timeout(timeout, TimeUnit.MILLISECONDS);\n\n        final Iterator<?> it = action.getMimeHeaders().getAllHeaders();\n        while (it.hasNext()) {\n            final MimeHeader header = (MimeHeader) it.next();\n            request.header(header.getName(), header.getValue());\n        }\n\n        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n            action.writeTo(os);\n            request.content(new BytesContentProvider(os.toByteArray()));\n            final ContentResponse response = request.send();\n            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n                result = parser.parse(is);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Output unexpected responses to the debug log.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    protected void logUnexpectedResult(final String message, final Document soapResponse) {\n        // No point formatting for output if debug logging is not enabled\n        if (logger.isDebugEnabled()) {\n            try {\n                final TransformerFactory transFactory = TransformerFactory.newInstance();\n                final Transformer transformer = transFactory.newTransformer();\n                final StringWriter buffer = new StringWriter();\n                transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n                transformer.transform(new DOMSource(soapResponse), new StreamResult(buffer));\n                logger.debug(\"{} : {}\", message, buffer);\n            } catch (final TransformerException e) {\n                logger.debug(\"{}\", message);\n            }\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.enigma2.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.time.LocalDateTime;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.jetty.util.UrlEncoded;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link Enigma2Client} class is responsible for communicating with the Enigma2 device.\n * \n * @see <a href=\n *      \"https://github.com/E2OpenPlugins/e2openplugin-OpenWebif/wiki/OpenWebif-API-documentation\">OpenWebif-API-documentation</a>\n *\n * @author Guido Dolfen - Initial contribution\n */\n@NonNullByDefault\npublic class Enigma2Client {\n    private final Logger logger = LoggerFactory.getLogger(Enigma2Client.class);\n\n    static final String PATH_REMOTE_CONTROL = \"/web/remotecontrol?command=\";\n    static final String PATH_POWER = \"/web/powerstate\";\n    static final String PATH_VOLUME = \"/web/vol\";\n    static final String PATH_SET_VOLUME = \"/web/vol?set=set\";\n    static final String PATH_TOGGLE_MUTE = \"/web/vol?set=mute\";\n    static final String PATH_TOGGLE_POWER = \"/web/powerstate?newstate=0\";\n    static final String PATH_MESSAGE = \"/web/message?type=\";\n    static final String PATH_ALL_SERVICES = \"/web/getallservices\";\n    static final String PATH_ZAP = \"/web/zap?sRef=\";\n    static final String PATH_CHANNEL = \"/web/subservices\";\n    static final String PATH_EPG = \"/web/epgservicenow?sRef=\";\n    static final String PATH_ANSWER = \"/web/messageanswer?getanswer=now\";\n    static final int TYPE_QUESTION = 0;\n    static final int TYPE_INFO = 1;\n    static final int TYPE_WARNING = 2;\n    static final int TYPE_ERROR = 3;\n    private final Map<String, @Nullable String> channels = new ConcurrentHashMap<>();\n    private final String host;\n    private boolean power;\n    private String channel = \"\";\n    private String title = \"\";\n    private String description = \"\";\n    private String answer = \"\";\n    private int volume = 0;\n    private boolean mute;\n    private boolean online;\n    private boolean initialized;\n    private boolean asking;\n    private LocalDateTime lastAnswerTime = LocalDateTime.of(2020, 1, 1, 0, 0); // Date in the past\n    private final Enigma2HttpClient enigma2HttpClient;\n    private final DocumentBuilderFactory factory;\n\n    public Enigma2Client(String host, @Nullable String user, @Nullable String password, int requestTimeout) {\n        enigma2HttpClient = new Enigma2HttpClient(requestTimeout);\n        factory = DocumentBuilderFactory.newInstance();\n        // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n        try {\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n        } catch (ParserConfigurationException e) {\n            logger.warn(\"Failed setting parser features against XXE attacks!\", e);\n        }\n        if (StringUtils.isNotEmpty(user) && StringUtils.isNotEmpty(password)) {\n            this.host = \"http://\" + user + \":\" + password + \"@\" + host;\n        } else {\n            this.host = \"http://\" + host;\n        }\n    }\n\n    public boolean refresh() {\n        boolean wasOnline = online;\n        refreshPower();\n        if (!wasOnline && online) {\n            // Only refresh all services if the box changed from offline to online and power is on\n            // because it is a performance intensive action.\n            refreshAllServices();\n        }\n        refreshChannel();\n        refreshEpg();\n        refreshVolume();\n        refreshAnswer();\n        return online;\n    }\n\n    public void refreshPower() {\n        Optional<Document> document = transmitWithResult(PATH_POWER);\n        if (document.isPresent()) {\n            online = true;\n            processPowerResult(document.get());\n        } else {\n            online = false;\n            power = false;\n        }\n        initialized = true;\n    }\n\n    public void refreshAllServices() {\n        if (power || channels.isEmpty()) {\n            transmitWithResult(PATH_ALL_SERVICES).ifPresent(this::processAllServicesResult);\n        }\n    }\n\n    public void refreshChannel() {\n        if (power) {\n            transmitWithResult(PATH_CHANNEL).ifPresent(this::processChannelResult);\n        }\n    }\n\n    public void refreshAnswer() {\n        if (asking) {\n            transmitWithResult(PATH_ANSWER).ifPresent(this::processAnswerResult);\n        }\n    }\n\n    public void refreshVolume() {\n        if (power) {\n            transmitWithResult(PATH_VOLUME).ifPresent(this::processVolumeResult);\n        }\n    }\n\n    public void refreshEpg() {\n        if (power) {\n            Optional.ofNullable(channels.get(channel))\n                    .flatMap(name -> transmitWithResult(PATH_EPG + UrlEncoded.encodeString(name)))\n                    .ifPresent(this::processEpgResult);\n        }\n    }\n\n    private Optional<Document> transmitWithResult(String path) {\n        try {\n            Optional<String> xml = transmit(path);\n            if (xml.isPresent()) {\n                DocumentBuilder builder = factory.newDocumentBuilder();\n                return Optional.ofNullable(builder.parse(new InputSource(new StringReader(xml.get()))));\n            }\n            return Optional.empty();\n        } catch (IOException | SAXException | ParserConfigurationException | IllegalArgumentException e) {\n            if (online || !initialized) {\n                logger.debug(\"Error on transmit {}{}.\", host, path, e);\n            }\n            return Optional.empty();\n        }\n    }\n\n    private Optional<String> transmit(String path) {\n        String url = host + path;\n        try {\n            logger.debug(\"Transmitting {}\", url);\n            String result = getEnigma2HttpClient().get(url);\n            logger.debug(\"Transmitting result is {}\", result);\n            return Optional.ofNullable(result);\n        } catch (IOException | IllegalArgumentException e) {\n            if (online || !initialized) {\n                logger.debug(\"Error on transmit {}.\", url, e);\n            }\n            return Optional.empty();\n        }\n    }\n\n    public void setMute(boolean mute) {\n        refreshVolume();\n        if (this.mute != mute) {\n            transmitWithResult(PATH_TOGGLE_MUTE).ifPresent(this::processVolumeResult);\n        }\n    }\n\n    public void setPower(boolean power) {\n        refreshPower();\n        if (this.power != power) {\n            transmitWithResult(PATH_TOGGLE_POWER).ifPresent(this::processPowerResult);\n        }\n    }\n\n    public void setVolume(int volume) {\n        transmitWithResult(PATH_SET_VOLUME + volume).ifPresent(this::processVolumeResult);\n    }\n\n    public void setChannel(String name) {\n        if (channels.containsKey(name)) {\n            String id = channels.get(name);\n            transmitWithResult(PATH_ZAP + UrlEncoded.encodeString(id)).ifPresent(document -> channel = name);\n        } else {\n            logger.warn(\"Channel {} not found.\", name);\n        }\n    }\n\n    public void sendRcCommand(int key) {\n        transmit(PATH_REMOTE_CONTROL + key);\n    }\n\n    public void sendError(int timeout, String text) {\n        sendMessage(TYPE_ERROR, timeout, text);\n    }\n\n    public void sendWarning(int timeout, String text) {\n        sendMessage(TYPE_WARNING, timeout, text);\n    }\n\n    public void sendInfo(int timeout, String text) {\n        sendMessage(TYPE_INFO, timeout, text);\n    }\n\n    public void sendQuestion(int timeout, String text) {\n        asking = true;\n        sendMessage(TYPE_QUESTION, timeout, text);\n    }\n\n    private void sendMessage(int type, int timeout, String text) {\n        transmit(PATH_MESSAGE + type + \"&timeout=\" + timeout + \"&text=\" + UrlEncoded.encodeString(text));\n    }\n\n    private void processPowerResult(Document document) {\n        power = !getBoolean(document, \"e2instandby\");\n        if (!power) {\n            title = \"\";\n            description = \"\";\n            channel = \"\";\n        }\n    }\n\n    private void processChannelResult(Document document) {\n        channel = getString(document, \"e2servicename\");\n        // Add channel-Reference-ID if not known\n        if (!channels.containsKey(channel)) {\n            channels.put(channel, getString(document, \"e2servicereference\"));\n        }\n    }\n\n    private void processAnswerResult(Document document) {\n        if (asking) {\n            boolean state = getBoolean(document, \"e2state\");\n            if (state) {\n                String[] text = getString(document, \"e2statetext\").split(\" \");\n                answer = text[text.length - 1].replace(\"!\", \"\");\n                asking = false;\n                lastAnswerTime = LocalDateTime.now();\n            }\n        }\n    }\n\n    private void processVolumeResult(Document document) {\n        volume = getInt(document, \"e2current\");\n        mute = getBoolean(document, \"e2ismuted\");\n    }\n\n    private void processEpgResult(Document document) {\n        title = getString(document, \"e2eventtitle\");\n        description = getString(document, \"e2eventdescription\");\n    }\n\n    private void processAllServicesResult(Document document) {\n        NodeList bouquetList = document.getElementsByTagName(\"e2bouquet\");\n        channels.clear();\n        for (int i = 0; i < bouquetList.getLength(); i++) {\n            Element bouquet = (Element) bouquetList.item(i);\n            NodeList serviceList = bouquet.getElementsByTagName(\"e2service\");\n            for (int j = 0; j < serviceList.getLength(); j++) {\n                Element service = (Element) serviceList.item(j);\n                String id = service.getElementsByTagName(\"e2servicereference\").item(0).getTextContent();\n                String name = service.getElementsByTagName(\"e2servicename\").item(0).getTextContent();\n                channels.put(name, id);\n            }\n        }\n    }\n\n    private String getString(Document document, String elementId) {\n        return Optional.ofNullable(document.getElementsByTagName(elementId)).map(nodeList -> nodeList.item(0))\n                .map(Node::getTextContent).map(String::trim).orElse(\"\");\n    }\n\n    private boolean getBoolean(Document document, String elementId) {\n        return Boolean.parseBoolean(getString(document, elementId));\n    }\n\n    private int getInt(Document document, String elementId) {\n        try {\n            return Integer.parseInt(getString(document, elementId));\n        } catch (NumberFormatException e) {\n            return 0;\n        }\n    }\n\n    public int getVolume() {\n        return volume;\n    }\n\n    public boolean isMute() {\n        return mute;\n    }\n\n    public boolean isPower() {\n        return power;\n    }\n\n    public LocalDateTime getLastAnswerTime() {\n        return lastAnswerTime;\n    }\n\n    public String getChannel() {\n        return channel;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public String getAnswer() {\n        return answer;\n    }\n\n    public Collection<String> getChannels() {\n        return channels.keySet();\n    }\n\n    /**\n     * Getter for Test-Injection\n     * \n     * @return HttpGet.\n     */\n    Enigma2HttpClient getEnigma2HttpClient() {\n        return enigma2HttpClient;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.fmiweather.internal.client;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\nimport javax.xml.namespace.NamespaceContext;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.fmiweather.internal.client.FMIResponse.Builder;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIExceptionReportException;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIIOException;\nimport org.openhab.binding.fmiweather.internal.client.exception.FMIUnexpectedResponseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n *\n * Client for accessing FMI weather data\n *\n * Subject to license terms https://en.ilmatieteenlaitos.fi/open-data\n *\n *\n * All weather stations:\n * https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations&networkid=121&\n * Networkid parameter isexplained in entries of\n * https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations\n *\n * @author Sami Salonen - Initial contribution\n *\n */\n@NonNullByDefault\npublic class Client {\n\n    private final Logger logger = LoggerFactory.getLogger(Client.class);\n\n    public static final String WEATHER_STATIONS_URL = \"https://opendata.fmi.fi/wfs/fin?service=WFS&version=2.0.0&request=GetFeature&storedquery_id=fmi::ef::stations&networkid=121&\";\n\n    private static final Map<String, String> NAMESPACES = new HashMap<>();\n    static {\n        NAMESPACES.put(\"target\", \"http://xml.fmi.fi/namespace/om/atmosphericfeatures/1.0\");\n        NAMESPACES.put(\"gml\", \"http://www.opengis.net/gml/3.2\");\n        NAMESPACES.put(\"xlink\", \"http://www.w3.org/1999/xlink\");\n        NAMESPACES.put(\"ows\", \"http://www.opengis.net/ows/1.1\");\n        NAMESPACES.put(\"gmlcov\", \"http://www.opengis.net/gmlcov/1.0\");\n        NAMESPACES.put(\"swe\", \"http://www.opengis.net/swe/2.0\");\n\n        NAMESPACES.put(\"wfs\", \"http://www.opengis.net/wfs/2.0\");\n        NAMESPACES.put(\"ef\", \"http://inspire.ec.europa.eu/schemas/ef/4.0\");\n    }\n    private static final NamespaceContext NAMESPACE_CONTEXT = new NamespaceContext() {\n        @Override\n        public String getNamespaceURI(@Nullable String prefix) {\n            return NAMESPACES.get(prefix);\n        }\n\n        @SuppressWarnings(\"rawtypes\")\n        @Override\n        public @Nullable Iterator getPrefixes(@Nullable String val) {\n            return null;\n        }\n\n        @Override\n        public @Nullable String getPrefix(@Nullable String uri) {\n            return null;\n        }\n    };\n\n    private DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n    private DocumentBuilder documentBuilder;\n\n    public Client() {\n        documentBuilderFactory.setNamespaceAware(true);\n        try {\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            documentBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            documentBuilderFactory.setXIncludeAware(false);\n            documentBuilderFactory.setExpandEntityReferences(false);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Query request and return the data\n     *\n     * @param request request to process\n     * @param timeoutMillis timeout for the http call\n     * @return data corresponding to the query\n     * @throws FMIIOException on all I/O errors\n     * @throws FMIUnexpectedResponseException on all unexpected content errors\n     * @throw FMIExceptionReportException on explicit error responses from the server\n     */\n    public FMIResponse query(Request request, int timeoutMillis)\n            throws FMIExceptionReportException, FMIUnexpectedResponseException, FMIIOException {\n        try {\n            String url = request.toUrl();\n            String responseText = HttpUtil.executeUrl(\"GET\", url, timeoutMillis);\n            if (responseText == null) {\n                throw new FMIIOException(String.format(\"HTTP error with %s\", request.toUrl()));\n            }\n            FMIResponse response = parseMultiPointCoverageXml(responseText);\n            logger.debug(\"Request {} translated to url {}. Response: {}\", request, url, response);\n            return response;\n        } catch (IOException e) {\n            throw new FMIIOException(e);\n        } catch (SAXException | XPathExpressionException e) {\n            throw new FMIUnexpectedResponseException(e);\n        }\n    }\n\n    /**\n     * Query all weather stations\n     *\n     * @param timeoutMillis timeout for the http call\n     * @return locations representing stations\n     * @throws FMIIOException on all I/O errors\n     * @throws FMIUnexpectedResponseException on all unexpected content errors\n     * @throw FMIExceptionReportException on explicit error responses from the server\n     */\n    public Set<Location> queryWeatherStations(int timeoutMillis)\n            throws FMIIOException, FMIUnexpectedResponseException, FMIExceptionReportException {\n        try {\n            String response = HttpUtil.executeUrl(\"GET\", WEATHER_STATIONS_URL, timeoutMillis);\n            if (response == null) {\n                throw new FMIIOException(String.format(\"HTTP error with %s\", WEATHER_STATIONS_URL));\n            }\n            return parseStations(response);\n        } catch (IOException e) {\n            throw new FMIIOException(e);\n        } catch (XPathExpressionException | SAXException e) {\n            throw new FMIUnexpectedResponseException(e);\n        }\n    }\n\n    private Set<Location> parseStations(String response) throws FMIExceptionReportException,\n            FMIUnexpectedResponseException, SAXException, IOException, XPathExpressionException {\n        Document document = documentBuilder.parse(new InputSource(new StringReader(response)));\n\n        XPath xPath = XPathFactory.newInstance().newXPath();\n        xPath.setNamespaceContext(NAMESPACE_CONTEXT);\n\n        boolean isExceptionReport = ((Node) xPath.compile(\"/ows:ExceptionReport\").evaluate(document,\n                XPathConstants.NODE)) != null;\n        if (isExceptionReport) {\n            Node exceptionCode = (Node) xPath.compile(\"/ows:ExceptionReport/ows:Exception/@exceptionCode\")\n                    .evaluate(document, XPathConstants.NODE);\n            String[] exceptionText = queryNodeValues(xPath.compile(\"//ows:ExceptionText/text()\"), document);\n            throw new FMIExceptionReportException(exceptionCode.getNodeValue(), exceptionText);\n        }\n\n        String[] fmisids = queryNodeValues(\n                xPath.compile(\n                        \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/gml:identifier/text()\"),\n                document);\n        String[] names = queryNodeValues(xPath.compile(\n                \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/gml:name[@codeSpace='http://xml.fmi.fi/namespace/locationcode/name']/text()\"),\n                document);\n        String[] representativePoints = queryNodeValues(xPath.compile(\n                \"/wfs:FeatureCollection/wfs:member/ef:EnvironmentalMonitoringFacility/ef:representativePoint/gml:Point/gml:pos/text()\"),\n                document);\n\n        if (fmisids.length != names.length || fmisids.length != representativePoints.length) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Could not all properties of locations: fmisids: %d, names: %d, representativePoints: %d\",\n                    fmisids.length, names.length, representativePoints.length));\n        }\n\n        Set<Location> locations = new HashSet<>(representativePoints.length);\n        for (int i = 0; i < representativePoints.length; i++) {\n            BigDecimal[] latlon = parseLatLon(representativePoints[i]);\n            locations.add(new Location(names[i], fmisids[i], latlon[0], latlon[1]));\n        }\n        return locations;\n    }\n\n    /**\n     * Parse FMI multipointcoverage formatted xml response\n     *\n     */\n    private FMIResponse parseMultiPointCoverageXml(String response) throws FMIUnexpectedResponseException,\n            FMIExceptionReportException, SAXException, IOException, XPathExpressionException {\n        Document document = documentBuilder.parse(new InputSource(new StringReader(response)));\n\n        XPath xPath = XPathFactory.newInstance().newXPath();\n        xPath.setNamespaceContext(NAMESPACE_CONTEXT);\n\n        boolean isExceptionReport = ((Node) xPath.compile(\"/ows:ExceptionReport\").evaluate(document,\n                XPathConstants.NODE)) != null;\n        if (isExceptionReport) {\n            Node exceptionCode = (Node) xPath.compile(\"/ows:ExceptionReport/ows:Exception/@exceptionCode\")\n                    .evaluate(document, XPathConstants.NODE);\n            String[] exceptionText = queryNodeValues(xPath.compile(\"//ows:ExceptionText/text()\"), document);\n            throw new FMIExceptionReportException(exceptionCode.getNodeValue(), exceptionText);\n        }\n\n        Builder builder = new FMIResponse.Builder();\n\n        String[] parameters = queryNodeValues(xPath.compile(\"//swe:field/@name\"), document);\n        /**\n         * Observations have FMISID (FMI Station ID?), with forecasts we use lat & lon\n         */\n        String[] ids = queryNodeValues(xPath.compile(\n                \"//target:Location/gml:identifier[@codeSpace='http://xml.fmi.fi/namespace/stationcode/fmisid']/text()\"),\n                document);\n\n        String[] names = queryNodeValues(xPath.compile(\n                \"//target:Location/gml:name[@codeSpace='http://xml.fmi.fi/namespace/locationcode/name']/text()\"),\n                document);\n        String[] representativePointRefs = queryNodeValues(\n                xPath.compile(\"//target:Location/target:representativePoint/@xlink:href\"), document);\n\n        if ((ids.length > 0 && ids.length != names.length) || names.length != representativePointRefs.length) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Could not all properties of locations: ids: %d, names: %d, representativePointRefs: %d\",\n                    ids.length, names.length, representativePointRefs.length));\n        }\n\n        Location[] locations = new Location[representativePointRefs.length];\n        for (int i = 0; i < locations.length; i++) {\n            BigDecimal[] latlon = findLatLon(xPath, i, document, representativePointRefs[i]);\n            String id = ids.length == 0 ? String.format(\"%s,%s\", latlon[0].toPlainString(), latlon[1].toPlainString())\n                    : ids[i];\n            locations[i] = new Location(names[i], id, latlon[0], latlon[1]);\n        }\n\n        logger.trace(\"names ({}): {}\", names.length, names);\n        logger.trace(\"parameters ({}): {}\", parameters.length, parameters);\n        if (names.length == 0) {\n            // No data, e.g. when starttime=endtime\n            return builder.build();\n        }\n\n        String latLonTimeTripletText = takeFirstOrError(\"positions\",\n                queryNodeValues(xPath.compile(\"//gmlcov:positions/text()\"), document));\n        String[] latLonTimeTripletEntries = latLonTimeTripletText.trim().split(\"\\\\s+\");\n        logger.trace(\"latLonTimeTripletText: {}\", latLonTimeTripletText);\n        logger.trace(\"latLonTimeTripletEntries ({}): {}\", latLonTimeTripletEntries.length, latLonTimeTripletEntries);\n        int countTimestamps = latLonTimeTripletEntries.length / 3 / locations.length;\n        long[] timestampsEpoch = IntStream.range(0, latLonTimeTripletEntries.length).filter(i -> i % 3 == 0)\n                .limit(countTimestamps).mapToLong(i -> Long.parseLong(latLonTimeTripletEntries[i + 2])).toArray();\n        // Invariant\n        assert countTimestamps == timestampsEpoch.length;\n        logger.trace(\"countTimestamps ({}): {}\", countTimestamps, timestampsEpoch);\n        validatePositionEntries(locations, timestampsEpoch, latLonTimeTripletEntries);\n\n        String valuesText = takeFirstOrError(\"doubleOrNilReasonTupleList\",\n                queryNodeValues(xPath.compile(\".//gml:doubleOrNilReasonTupleList/text()\"), document));\n        String[] valuesEntries = valuesText.trim().split(\"\\\\s+\");\n        logger.trace(\"valuesText: {}\", valuesText);\n        logger.trace(\"valuesEntries ({}): {}\", valuesEntries.length, valuesEntries);\n        if (valuesEntries.length != locations.length * parameters.length * countTimestamps) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Wrong number of values (%d). Expecting %d * %d * %d = %d\", valuesEntries.length, locations.length,\n                    parameters.length, countTimestamps, countTimestamps * locations.length * parameters.length));\n        }\n        IntStream.range(0, locations.length).forEach(locationIndex -> {\n            for (int parameterIndex = 0; parameterIndex < parameters.length; parameterIndex++) {\n                for (int timestepIndex = 0; timestepIndex < countTimestamps; timestepIndex++) {\n                    BigDecimal val = toBigDecimalOrNullIfNaN(\n                            valuesEntries[locationIndex * countTimestamps * parameters.length\n                                    + timestepIndex * parameters.length + parameterIndex]);\n                    logger.trace(\"Found value {}={} @ time={} for location {}\", parameters[parameterIndex], val,\n                            timestampsEpoch[timestepIndex], locations[locationIndex].id);\n                    builder.appendLocationData(locations[locationIndex], countTimestamps, parameters[parameterIndex],\n                            timestampsEpoch[timestepIndex], val);\n                }\n            }\n        });\n\n        return builder.build();\n    }\n\n    /**\n     * Find representative latitude and longitude matching given xlink href attribute value\n     *\n     * @param xPath xpath object used for query\n     * @param entryIndex index of the location, for logging only on errors\n     * @param document document object\n     * @param href xlink href attribute value. Should start with #\n     * @return latitude and longitude values as array\n     * @throws FMIUnexpectedResponseException parsing errors or when entry is not found\n     * @throws XPathExpressionException xpath errors\n     */\n    private BigDecimal[] findLatLon(XPath xPath, int entryIndex, Document document, String href)\n            throws FMIUnexpectedResponseException, XPathExpressionException {\n        if (!href.startsWith(\"#\")) {\n            throw new FMIUnexpectedResponseException(\n                    \"Could not find valid representativePoint xlink:href, does not start with #\");\n        }\n        String pointId = href.substring(1);\n        String pointLatLon = takeFirstOrError(String.format(\"[%d]/pos\", entryIndex),\n                queryNodeValues(xPath.compile(\".//gml:Point[@gml:id='\" + pointId + \"']/gml:pos/text()\"), document));\n        return parseLatLon(pointLatLon);\n    }\n\n    /**\n     * Parse string reprsenting latitude longitude string separated by space\n     *\n     * @param pointLatLon latitude longitude string separated by space\n     * @return latitude and longitude values as array\n     * @throws FMIUnexpectedResponseException on parsing errors\n     */\n    private BigDecimal[] parseLatLon(String pointLatLon) throws FMIUnexpectedResponseException {\n        String[] latlon = pointLatLon.split(\" \");\n        BigDecimal lat, lon;\n        if (latlon.length != 2) {\n            throw new FMIUnexpectedResponseException(String.format(\n                    \"Invalid latitude or longitude format, expected two values separated by space, got %d values: '%s'\",\n                    latlon.length, latlon));\n        }\n        try {\n            lat = new BigDecimal(latlon[0]);\n            lon = new BigDecimal(latlon[1]);\n        } catch (NumberFormatException e) {\n            throw new FMIUnexpectedResponseException(\n                    String.format(\"Invalid latitude or longitude format: %s\", e.getMessage()));\n        }\n        return new BigDecimal[] { lat, lon };\n    }\n\n    private String[] queryNodeValues(XPathExpression expression, Object source) throws XPathExpressionException {\n        NodeList nodeList = (NodeList) expression.evaluate(source, XPathConstants.NODESET);\n        String[] values = new String[nodeList.getLength()];\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            values[i] = nodeList.item(i).getNodeValue();\n        }\n        return values;\n    }\n\n    /**\n     * Asserts that length of values is exactly 1, and returns it\n     *\n     * @param errorDescription error description for FMIResponseException\n     * @param values\n     * @return\n     * @throws FMIUnexpectedResponseException when length of values != 1\n     */\n    private String takeFirstOrError(String errorDescription, String[] values) throws FMIUnexpectedResponseException {\n        if (values.length != 1) {\n            throw new FMIUnexpectedResponseException(String.format(\"No unique match found: %s\", errorDescription));\n        }\n        return values[0];\n    }\n\n    /**\n     * Convert string to BigDecimal. \"NaN\" string is converted to null\n     *\n     * @param value\n     * @return null when value is \"NaN\". Otherwise BigDecimal representing the string\n     */\n    private @Nullable BigDecimal toBigDecimalOrNullIfNaN(String value) {\n        if (\"NaN\".equals(value)) {\n            return null;\n        } else {\n            return new BigDecimal(value);\n        }\n    }\n\n    /**\n     * Validate ordering and values of gmlcov:positions (latLonTimeTripletEntries)\n     * essentially\n     * pos1_lat, pos1_lon, time1\n     * pos1_lat, pos1_lon, time2\n     * pos1_lat, pos1_lon, time3\n     * pos2_lat, pos2_lon, time1\n     * pos2_lat, pos2_lon, time2\n     * ..etc..\n     *\n     * - lat, lon should be in correct order and match position entries (\"locations\")\n     * - time should values should be exactly same for each point (above time1, time2, ...), and match given timestamps\n     * (\"timestampsEpoch\")\n     *\n     *\n     * @param locations previously discovered locations\n     * @param timestampsEpoch expected timestamps\n     * @param latLonTimeTripletEntries flat array of strings representing the array, [row1_cell1, row1_cell2,\n     *            row2_cell1, ...]\n     * @throws FMIUnexpectedResponseException when value ordering is not matching the expected\n     */\n    private void validatePositionEntries(Location[] locations, long[] timestampsEpoch,\n            String[] latLonTimeTripletEntries) throws FMIUnexpectedResponseException {\n        int countTimestamps = timestampsEpoch.length;\n        for (int locationIndex = 0; locationIndex < locations.length; locationIndex++) {\n            String firstLat = latLonTimeTripletEntries[locationIndex * countTimestamps * 3];\n            String fistLon = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + 1];\n\n            // step through entries for this position\n            for (int timestepIndex = 0; timestepIndex < countTimestamps; timestepIndex++) {\n                String lat = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3];\n                String lon = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3 + 1];\n                String timeEpochSec = latLonTimeTripletEntries[locationIndex * countTimestamps * 3 + timestepIndex * 3\n                        + 2];\n                if (!lat.equals(firstLat) || !lon.equals(fistLon)) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] lat, lon for time index [%d] was not matching expected ordering\",\n                            locationIndex, timestepIndex));\n                }\n                String expectedLat = locations[locationIndex].latitude.toPlainString();\n                String expectedLon = locations[locationIndex].longitude.toPlainString();\n                if (!lat.equals(expectedLat) || !lon.equals(expectedLon)) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] lat, lon for time index [%d] was not matching representativePoint\",\n                            locationIndex, timestepIndex));\n                }\n\n                if (Long.parseLong(timeEpochSec) != timestampsEpoch[timestepIndex]) {\n                    throw new FMIUnexpectedResponseException(String.format(\n                            \"positions[%d] time (%s) for time index [%d] was not matching expected (%d) ordering\",\n                            locationIndex, timeEpochSec, timestepIndex, timestampsEpoch[timestepIndex]));\n                }\n            }\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.fsinternetradio.internal.radio;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * This class hold the result of a request read from the radio. Upon a request the radio returns a XML document like\n * this:\n *\n * <pre>\n * <xmp>\n *   <fsapiResponse> <status>FS_OK</status> <value><u8>1</u8></value> </fsapiResponse>\n * </xmp>\n * </pre>\n *\n * This class parses this XML data and provides functions for reading and casting typical fields.\n *\n * @author Rainer Ostendorf\n * @author Patrick Koenemann\n *\n */\npublic class FrontierSiliconRadioApiResult {\n\n    /**\n     * XML structure holding the parsed response\n     */\n    final Document xmlDoc;\n\n    private final Logger logger = LoggerFactory.getLogger(FrontierSiliconRadioApiResult.class);\n\n    /**\n     * Create result object from XML that was received from the radio.\n     *\n     * @param requestResultString\n     *            The XML string received from the radio.\n     * @throws IOException in case the XML returned by the radio is invalid.\n     */\n    public FrontierSiliconRadioApiResult(String requestResultString) throws IOException {\n        Document xml = null;\n        try {\n            xml = getXmlDocFromString(requestResultString);\n        } catch (Exception e) {\n            logger.trace(\"converting to XML failed: '{}' with {}: {}\", requestResultString, e.getClass().getName(),\n                    e.getMessage());\n            logger.debug(\"converting to XML failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new IOException(e);\n        }\n        xmlDoc = xml;\n    }\n\n    /**\n     * Extract the field \"status\" from the result and return it\n     *\n     * @return result field as string.\n     */\n    private String getStatus() {\n        final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n        final Element statusNode = (Element) fsApiResult.getElementsByTagName(\"status\").item(0);\n\n        final String status = getCharacterDataFromElement(statusNode);\n        logger.trace(\"status is: {}\", status);\n\n        return status;\n    }\n\n    /**\n     * checks if the responses status code was \"FS_OK\"\n     *\n     * @return true if status is \"FS_OK\", false else\n     */\n    public boolean isStatusOk() {\n        return (\"FS_OK\").equals(getStatus());\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u8&gt; field as boolean\n     *\n     * @return value.u8 field as bool\n     */\n    public boolean getValueU8AsBoolean() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u8Node = (Element) valueNode.getElementsByTagName(\"u8\").item(0);\n\n            final String value = getCharacterDataFromElement(u8Node);\n            logger.trace(\"value is: {}\", value);\n\n            return \"1\".equals(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U8 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u8&gt; field as int\n     *\n     * @return value.u8 field as int\n     */\n    public int getValueU8AsInt() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u8Node = (Element) valueNode.getElementsByTagName(\"u8\").item(0);\n\n            final String value = getCharacterDataFromElement(u8Node);\n            logger.trace(\"value is: {}\", value);\n\n            return Integer.parseInt(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U8 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return 0;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;u32&gt; field as int\n     *\n     * @return value.u32 field as int\n     */\n    public int getValueU32AsInt() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element u32Node = (Element) valueNode.getElementsByTagName(\"u32\").item(0);\n\n            final String value = getCharacterDataFromElement(u32Node);\n            logger.trace(\"value is: {}\", value);\n\n            return Integer.parseInt(value);\n        } catch (Exception e) {\n            logger.error(\"getting Value.U32 failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return 0;\n        }\n    }\n\n    /**\n     * read the &lt;value&gt;&lt;c8_array&gt; field as String\n     *\n     * @return value.c8_array field as String\n     */\n    public String getValueC8ArrayAsString() {\n        try {\n            final Element fsApiResult = (Element) xmlDoc.getElementsByTagName(\"fsapiResponse\").item(0);\n            final Element valueNode = (Element) fsApiResult.getElementsByTagName(\"value\").item(0);\n            final Element c8Array = (Element) valueNode.getElementsByTagName(\"c8_array\").item(0);\n\n            final String value = getCharacterDataFromElement(c8Array);\n            logger.trace(\"value is: {}\", value);\n\n            return value;\n        } catch (Exception e) {\n            logger.error(\"getting Value.c8array failed with {}: {}\", e.getClass().getName(), e.getMessage());\n            return \"\";\n        }\n    }\n\n    /**\n     * read the &lt;sessionId&gt; field as String\n     *\n     * @return value of sessionId field\n     */\n    public String getSessionId() {\n        final NodeList sessionIdTagList = xmlDoc.getElementsByTagName(\"sessionId\");\n        final String givenSessId = getCharacterDataFromElement((Element) sessionIdTagList.item(0));\n        return givenSessId;\n    }\n\n    /**\n     * converts the string we got from the radio to a parsable XML document\n     *\n     * @param xmlString\n     *            the XML string read from the radio\n     * @return the parsed XML document\n     * @throws ParserConfigurationException\n     * @throws SAXException\n     * @throws IOException\n     */\n    private Document getXmlDocFromString(String xmlString)\n            throws ParserConfigurationException, SAXException, IOException {\n        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n        final DocumentBuilder builder = factory.newDocumentBuilder();\n        final Document xmlDocument = builder.parse(new InputSource(new StringReader(xmlString)));\n        return xmlDocument;\n    }\n\n    /**\n     * convert the value of a given XML element to a string for further processing\n     *\n     * @param e\n     *            XML Element\n     * @return the elements value converted to string\n     */\n    private static String getCharacterDataFromElement(Element e) {\n        final Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            final CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"\";\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.gce.internal.model;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.gce.internal.handler.Ipx800EventListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * This class takes care of interpreting the status.xml file\n *\n * @author Ga\u00ebl L'hopital - Initial contribution\n */\n@NonNullByDefault\npublic class StatusFileInterpreter {\n    private static final String URL_TEMPLATE = \"http://%s/globalstatus.xml\";\n    private final Logger logger = LoggerFactory.getLogger(StatusFileInterpreter.class);\n    private final String hostname;\n    private @Nullable Document doc;\n    private final Ipx800EventListener listener;\n\n    public static enum StatusEntry {\n        VERSION,\n        CONFIG_MAC;\n    }\n\n    public StatusFileInterpreter(String hostname, Ipx800EventListener listener) {\n        this.hostname = hostname;\n        this.listener = listener;\n    }\n\n    public void read() {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            String statusPage = HttpUtil.executeUrl(\"GET\", String.format(URL_TEMPLATE, hostname), 5000);\n            InputStream inputStream = new ByteArrayInputStream(statusPage.getBytes());\n            Document document = builder.parse(inputStream);\n            document.getDocumentElement().normalize();\n            doc = document;\n            pushDatas();\n            inputStream.close();\n        } catch (IOException | SAXException | ParserConfigurationException e) {\n            logger.warn(\"Unable to read IPX800 status page : {}\", e.getMessage());\n            doc = null;\n        }\n    }\n\n    private void pushDatas() {\n        Element root = getRoot();\n        if (root != null) {\n            PortDefinition.asStream().forEach(portDefinition -> {\n                List<Node> xmlNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n                xmlNodes.forEach(xmlNode -> {\n                    String sPortNum = xmlNode.getNodeName().replace(portDefinition.getNodeName(), \"\");\n                    int portNum = Integer.parseInt(sPortNum) + 1;\n                    double value = Double.parseDouble(xmlNode.getTextContent().replace(\"dn\", \"1\").replace(\"up\", \"0\"));\n                    listener.dataReceived(String.format(\"%s%d\", portDefinition.getPortName(), portNum), value);\n                });\n            });\n        }\n    }\n\n    public String getElement(StatusEntry entry) {\n        Element root = getRoot();\n        if (root != null) {\n            return root.getElementsByTagName(entry.name().toLowerCase()).item(0).getTextContent();\n        } else {\n            return \"\";\n        }\n    }\n\n    private List<Node> getMatchingNodes(NodeList nodeList, String criteria) {\n        return IntStream.range(0, nodeList.getLength()).boxed().map(nodeList::item)\n                .filter(node -> node.getNodeName().startsWith(criteria))\n                .sorted(Comparator.comparing(o -> o.getNodeName())).collect(Collectors.toList());\n    }\n\n    public int getMaxNumberofNodeType(PortDefinition portDefinition) {\n        Element root = getRoot();\n        if (root != null) {\n            List<Node> filteredNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n            return filteredNodes.size();\n        }\n        return 0;\n    }\n\n    private @Nullable Element getRoot() {\n        if (doc == null) {\n            read();\n        }\n        if (doc != null) {\n            return doc.getDocumentElement();\n        }\n        return null;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.homematic.internal.communicator.message;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Decodes a XML-RPC message from the Homematic server.\n *\n * @author Gerhard Riegler - Initial contribution\n */\npublic class XmlRpcResponse implements RpcResponse {\n    private String methodName;\n    private Object[] responseData;\n\n    /**\n     * Decodes a XML-RPC message from the given InputStream.\n     */\n    public XmlRpcResponse(InputStream is, String encoding)\n            throws SAXException, ParserConfigurationException, IOException {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        SAXParser saxParser = factory.newSAXParser();\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        saxParser.getXMLReader().setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        InputSource inputSource = new InputSource(is);\n        inputSource.setEncoding(encoding);\n        saxParser.parse(inputSource, new XmlRpcHandler());\n    }\n\n    @Override\n    public Object[] getResponseData() {\n        return responseData;\n    }\n\n    @Override\n    public String getMethodName() {\n        return methodName;\n    }\n\n    @Override\n    public String toString() {\n        return RpcUtils.dumpRpcMessage(methodName, responseData);\n    }\n\n    /**\n     * SAX parser implementation to decode XML-RPC.\n     *\n     * @author Gerhard Riegler\n     */\n    private class XmlRpcHandler extends DefaultHandler {\n        private List<Object> result = new ArrayList<>();\n        private LinkedList<List<Object>> currentDataObject = new LinkedList<>();\n        private StringBuilder tagValue;\n        private boolean isValueTag;\n\n        @Override\n        public void startDocument() throws SAXException {\n            currentDataObject.addLast(new ArrayList<>());\n        }\n\n        @Override\n        public void endDocument() throws SAXException {\n            result.addAll(currentDataObject.removeLast());\n            responseData = result.toArray();\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String qName, Attributes attributes)\n                throws SAXException {\n            String tag = qName.toLowerCase();\n            if (tag.equals(\"array\") || tag.equals(\"struct\")) {\n                currentDataObject.addLast(new ArrayList<>());\n            }\n            isValueTag = tag.equals(\"value\");\n            tagValue = new StringBuilder();\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            String currentTag = qName.toLowerCase();\n            String currentValue = tagValue.toString();\n            List<Object> data = currentDataObject.peekLast();\n\n            switch (currentTag) {\n                case \"boolean\":\n                    data.add(\"1\".equals(currentValue) ? Boolean.TRUE : Boolean.FALSE);\n                    break;\n                case \"int\":\n                case \"i4\":\n                    data.add(new Integer(currentValue));\n                    break;\n                case \"double\":\n                    data.add(new Double(currentValue));\n                    break;\n                case \"string\":\n                case \"name\":\n                    data.add(currentValue);\n                    break;\n                case \"value\":\n                    if (isValueTag) {\n                        data.add(currentValue);\n                        isValueTag = false;\n                    }\n                    break;\n                case \"array\":\n                    List<Object> arrayData = currentDataObject.removeLast();\n                    currentDataObject.peekLast().add(arrayData.toArray());\n                    break;\n                case \"struct\":\n                    List<Object> mapData = currentDataObject.removeLast();\n                    Map<Object, Object> resultMap = new HashMap<>();\n\n                    for (int i = 0; i < mapData.size(); i += 2) {\n                        resultMap.put(mapData.get(i), mapData.get(i + 1));\n                    }\n                    currentDataObject.peekLast().add(resultMap);\n                    break;\n                case \"base64\":\n                    data.add(Base64.getDecoder().decode(currentValue));\n                    break;\n                case \"datetime.iso8601\":\n                    try {\n                        data.add(XmlRpcRequest.xmlRpcDateFormat.parse(currentValue));\n                    } catch (ParseException ex) {\n                        throw new SAXException(ex.getMessage(), ex);\n                    }\n                    break;\n                case \"methodname\":\n                    methodName = currentValue;\n                    break;\n                case \"params\":\n                case \"param\":\n                case \"methodcall\":\n                case \"methodresponse\":\n                case \"member\":\n                case \"data\":\n                case \"fault\":\n                    break;\n                default:\n                    throw new SAXException(\"Unknown XML-RPC tag: \" + currentTag);\n            }\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            tagValue.append(new String(ch, start, length));\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.hpprinter.internal.api;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Function;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.http.HttpMethod;\nimport org.openhab.binding.hpprinter.internal.api.HPServerResult.RequestStatus;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link HPWebServerClient} is responsible for handling reading of data from the HP Embedded Web Server.\n *\n * @author Stewart Cossey - Initial contribution\n */\n@NonNullByDefault\npublic class HPWebServerClient {\n    public static final int REQUEST_TIMEOUT_SEC = 10;\n    private final Logger logger = LoggerFactory.getLogger(HPWebServerClient.class);\n\n    private final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    private final HttpClient httpClient;\n    private final String serverAddress;\n\n    /**\n     * Creates a new HP Web Server Client object.\n     *\n     * @param httpClient {HttpClient} The HttpClient to use for HTTP requests.\n     * @param address The address for the Embedded Web Server.\n     */\n    public HPWebServerClient(HttpClient httpClient, String address) {\n        this.httpClient = httpClient;\n        serverAddress = \"http://\" + address;\n\n        logger.debug(\"Create printer connection {}\", serverAddress);\n    }\n\n    /**\n     * Gets the Status information from the Embedded Web Server.\n     *\n     * @return The status information.\n     */\n    public HPServerResult<HPStatus> getStatus() {\n        return fetchData(serverAddress + HPStatus.ENDPOINT, (HPStatus::new));\n    }\n\n    public HPServerResult<HPProductUsageFeatures> getProductFeatures() {\n        return fetchData(serverAddress + HPProductUsageFeatures.ENDPOINT, (HPProductUsageFeatures::new));\n    }\n\n    public HPServerResult<HPFeatures> getProductUsageFeatures() {\n        return fetchData(serverAddress + HPFeatures.ENDPOINT, (HPFeatures::new));\n    }\n\n    public HPServerResult<HPScannerStatusFeatures> getScannerFeatures() {\n        return fetchData(serverAddress + HPScannerStatusFeatures.ENDPOINT, (HPScannerStatusFeatures::new));\n    }\n\n    /**\n     * Gets the Usage information from the Embedded Web Server.\n     *\n     * @return The usage information.\n     */\n    public HPServerResult<HPUsage> getUsage() {\n        return fetchData(serverAddress + HPUsage.ENDPOINT, (HPUsage::new));\n    }\n\n    public HPServerResult<HPScannerStatus> getScannerStatus() {\n        return fetchData(serverAddress + HPScannerStatus.ENDPOINT, (HPScannerStatus::new));\n    }\n\n    public HPServerResult<HPProperties> getProperties() {\n        return fetchData(serverAddress + HPProperties.ENDPOINT, (HPProperties::new));\n    }\n\n    private <T> HPServerResult<T> fetchData(String endpoint, Function<Document, T> function) {\n        try {\n            logger.trace(\"HTTP Client Load {}\", endpoint);\n            ContentResponse cr = httpClient.newRequest(endpoint).method(HttpMethod.GET)\n                    .timeout(REQUEST_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n\n            String contentAsString = cr.getContentAsString();\n            logger.trace(\"HTTP Client Result {} Size {}\", cr.getStatus(), contentAsString.length());\n            return new HPServerResult<>(function.apply(getDocument(contentAsString)));\n        } catch (TimeoutException ex) {\n            logger.trace(\"HTTP Client Timeout Exception {}\", ex.getMessage());\n            return new HPServerResult<>(RequestStatus.TIMEOUT, ex.getMessage());\n        } catch (InterruptedException | ExecutionException | ParserConfigurationException | SAXException\n                | IOException ex) {\n            logger.trace(\"HTTP Client Exception {}\", ex.getMessage());\n            return new HPServerResult<>(RequestStatus.ERROR, ex.getMessage());\n        }\n    }\n\n    private synchronized Document getDocument(String contentAsString)\n            throws ParserConfigurationException, SAXException, IOException {\n        // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        InputSource source = new InputSource(new StringReader(contentAsString));\n        return builder.parse(source);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.ihc.internal.ws.projectfile;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.io.FileUtils;\nimport org.openhab.binding.ihc.internal.ws.datatypes.WSProjectInfo;\nimport org.openhab.binding.ihc.internal.ws.exeptions.IhcExecption;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Generic methods related to IHC / ELKO project file handling.\n *\n * @author Pauli Anttila - Initial contribution\n */\npublic class ProjectFileUtils {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProjectFileUtils.class);\n\n    /**\n     * Read IHC project file from local file.\n     *\n     * @param filePath File to read.\n     * @return XML document.\n     * @throws IhcExecption when file read fails.\n     */\n    public static Document readFromFile(String filePath) throws IhcExecption {\n        File fXmlFile = new File(filePath);\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        try {\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(fXmlFile);\n            return doc;\n        } catch (IOException | ParserConfigurationException | SAXException e) {\n            throw new IhcExecption(e);\n        }\n    }\n\n    /**\n     * Save IHC project file to local file.\n     *\n     * @param filePath File path.\n     * @param data Data to write\n     * @throws IhcExecption when file write fails.\n     */\n    public static void saveToFile(String filePath, byte[] data) throws IhcExecption {\n        try {\n            FileUtils.writeByteArrayToFile(new File(filePath), data);\n        } catch (IOException e) {\n            throw new IhcExecption(e);\n        }\n    }\n\n    /**\n     * Convert bytes to XML document.\n     *\n     * @return XML document or null if conversion fails.\n     */\n    public static Document converteBytesToDocument(byte[] data) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        try {\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            return builder.parse(new ByteArrayInputStream(data));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            LOGGER.warn(\"Error occured when trying to convert data to XML, reason {}\", e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Compare XML document header information to project info.\n     *\n     * @return true if information is equal and false if not.\n     */\n    public static boolean projectEqualsToControllerProject(Document projectfile, WSProjectInfo projectInfo) {\n        if (projectInfo != null) {\n            try {\n                NodeList nodes = projectfile.getElementsByTagName(\"modified\");\n                if (nodes.getLength() == 1) {\n                    Element node = (Element) nodes.item(0);\n                    int year = Integer.parseInt(node.getAttribute(\"year\"));\n                    int month = Integer.parseInt(node.getAttribute(\"month\"));\n                    int day = Integer.parseInt(node.getAttribute(\"day\"));\n                    int hour = Integer.parseInt(node.getAttribute(\"hour\"));\n                    int minute = Integer.parseInt(node.getAttribute(\"minute\"));\n\n                    LOGGER.debug(\"Project file from file, date: {}.{}.{} {}:{}\", year, month, day, hour, minute);\n                    LOGGER.debug(\"Project file in controller, date: {}.{}.{} {}:{}\",\n                            projectInfo.getLastmodified().getYear(),\n                            projectInfo.getLastmodified().getMonthWithJanuaryAsOne(),\n                            projectInfo.getLastmodified().getDay(), projectInfo.getLastmodified().getHours(),\n                            projectInfo.getLastmodified().getMinutes());\n\n                    if (projectInfo.getLastmodified().getYear() == year\n                            && projectInfo.getLastmodified().getMonthWithJanuaryAsOne() == month\n                            && projectInfo.getLastmodified().getDay() == day\n                            && projectInfo.getLastmodified().getHours() == hour\n                            && projectInfo.getLastmodified().getMinutes() == minute) {\n                        return true;\n                    }\n                }\n            } catch (RuntimeException e) {\n                LOGGER.debug(\"Error occured during project file date comparasion, reason {}.\", e.getMessage(), e);\n                // There is no documentation available for XML content. This is part of inessential feature, so do\n                // nothing, but return false\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Parse all enum values from IHC project file.\n     *\n     * @param doc IHC project file in XML format.\n     * @return enum dictionary.\n     */\n    public static Map<Integer, List<IhcEnumValue>> parseEnums(Document doc) {\n        Map<Integer, List<IhcEnumValue>> enumDictionary = new HashMap<>();\n        if (doc != null) {\n            NodeList nodes = doc.getElementsByTagName(\"enum_definition\");\n\n            // iterate enum definitions from project\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Element element = (Element) nodes.item(i);\n\n                int typedefId = Integer.parseInt(element.getAttribute(\"id\").replace(\"_0x\", \"\"), 16);\n                String enumName = element.getAttribute(\"name\");\n\n                List<IhcEnumValue> enumValues = new ArrayList<>();\n\n                NodeList name = element.getElementsByTagName(\"enum_value\");\n\n                for (int j = 0; j < name.getLength(); j++) {\n                    Element val = (Element) name.item(j);\n                    int id = Integer.parseInt(val.getAttribute(\"id\").replace(\"_0x\", \"\"), 16);\n                    String n = val.getAttribute(\"name\");\n                    IhcEnumValue enumVal = new IhcEnumValue(id, n);\n                    enumValues.add(enumVal);\n                }\n\n                LOGGER.debug(\"Enum values found: typedefId={}, name={}: {}\", typedefId, enumName, enumValues);\n                enumDictionary.put(typedefId, enumValues);\n            }\n        }\n        return enumDictionary;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.device;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Reads the device types from an xml file.\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\n@SuppressWarnings(\"null\")\npublic class DeviceTypeLoader {\n    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n    private HashMap<String, DeviceType> deviceTypes = new HashMap<>();\n    private @Nullable static DeviceTypeLoader deviceTypeLoader = null;\n\n    private DeviceTypeLoader() {\n    } // private so nobody can call it\n\n    /**\n     * Finds the device type for a given product key\n     *\n     * @param aProdKey product key to search for\n     * @return the device type, or null if not found\n     */\n    public @Nullable DeviceType getDeviceType(String aProdKey) {\n        return (deviceTypes.get(aProdKey));\n    }\n\n    /**\n     * Must call loadDeviceTypesXML() before calling this function!\n     *\n     * @return currently known device types\n     */\n    public HashMap<String, DeviceType> getDeviceTypes() {\n        return (deviceTypes);\n    }\n\n    /**\n     * Reads the device types from input stream and stores them in memory for\n     * later access.\n     *\n     * @param is the input stream from which to read\n     */\n    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n        dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        dbFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        Document doc = dBuilder.parse(in);\n        doc.getDocumentElement().normalize();\n        Node root = doc.getDocumentElement();\n        NodeList nodes = root.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n                processDevice((Element) node);\n            }\n        }\n    }\n\n    /**\n     * Reads the device types from file and stores them in memory for later access.\n     *\n     * @param aFileName The name of the file to read from\n     * @throws ParserConfigurationException\n     * @throws SAXException\n     * @throws IOException\n     */\n    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n        File file = new File(aFileName);\n        InputStream in = new FileInputStream(file);\n        loadDeviceTypesXML(in);\n    }\n\n    /**\n     * Process device node\n     *\n     * @param e name of the element to process\n     * @throws SAXException\n     */\n    private void processDevice(Element e) throws SAXException {\n        String productKey = e.getAttribute(\"productKey\");\n        if (productKey.equals(\"\")) {\n            throw new SAXException(\"device in device_types file has no product key!\");\n        }\n        if (deviceTypes.containsKey(productKey)) {\n            logger.warn(\"overwriting previous definition of device {}\", productKey);\n            deviceTypes.remove(productKey);\n        }\n        DeviceType devType = new DeviceType(productKey);\n\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"model\")) {\n                devType.setModel(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"description\")) {\n                devType.setDescription(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"feature\")) {\n                processFeature(devType, subElement);\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                processFeatureGroup(devType, subElement);\n            }\n            deviceTypes.put(productKey, devType);\n        }\n    }\n\n    private String processFeature(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n        }\n        if (!name.equals(name.toLowerCase())) {\n            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n        }\n        if (!devType.addFeature(name, e.getTextContent())) {\n            throw new SAXException(\"duplicate feature: \" + name);\n        }\n        return (name);\n    }\n\n    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n        }\n        String type = e.getAttribute(\"type\");\n        if (type.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n        }\n        FeatureGroup fg = new FeatureGroup(name, type);\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"feature\")) {\n                fg.addFeature(processFeature(devType, subElement));\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                fg.addFeature(processFeatureGroup(devType, subElement));\n            }\n        }\n        if (!devType.addFeatureGroup(name, fg)) {\n            throw new SAXException(\"duplicate feature group \" + name);\n        }\n        return (name);\n    }\n\n    /**\n     * Helper function for debugging\n     */\n    private void logDeviceTypes() {\n        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n            logger.debug(\"{}\", msg);\n        }\n    }\n\n    /**\n     * Singleton instance function, creates DeviceTypeLoader\n     *\n     * @return DeviceTypeLoader singleton reference\n     */\n    @Nullable\n    public static synchronized DeviceTypeLoader instance() {\n        if (deviceTypeLoader == null) {\n            deviceTypeLoader = new DeviceTypeLoader();\n            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n            try {\n                deviceTypeLoader.loadDeviceTypesXML(input);\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"parser config error when reading device types xml file: \", e);\n            } catch (SAXException e) {\n                logger.warn(\"SAX exception when reading device types xml file: \", e);\n            } catch (IOException e) {\n                logger.warn(\"I/O exception when reading device types xml file: \", e);\n            }\n            logger.debug(\"loaded {} devices: \", deviceTypeLoader.getDeviceTypes().size());\n            deviceTypeLoader.logDeviceTypes();\n        }\n        return deviceTypeLoader;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.device;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.openhab.binding.insteon.internal.utils.Utils;\nimport org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Class that loads the device feature templates from an xml stream\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\npublic class FeatureTemplateLoader {\n    public static List<FeatureTemplate> readTemplates(InputStream input) throws IOException, ParsingException {\n        List<FeatureTemplate> features = new ArrayList<>();\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Parse it!\n            Document doc = dBuilder.parse(input);\n            doc.getDocumentElement().normalize();\n\n            Element root = doc.getDocumentElement();\n\n            NodeList nodes = root.getChildNodes();\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element e = (Element) node;\n                    if (e.getTagName().equals(\"feature\")) {\n                        features.add(parseFeature(e));\n                    }\n                }\n            }\n        } catch (SAXException e) {\n            throw new ParsingException(\"Failed to parse XML!\", e);\n        } catch (ParserConfigurationException e) {\n            throw new ParsingException(\"Got parser config exception! \", e);\n        }\n        return features;\n    }\n\n    private static FeatureTemplate parseFeature(Element e) throws ParsingException {\n        String name = e.getAttribute(\"name\");\n        boolean statusFeature = e.getAttribute(\"statusFeature\").equals(\"true\");\n        FeatureTemplate feature = new FeatureTemplate(name, statusFeature, e.getAttribute(\"timeout\"));\n\n        NodeList nodes = e.getChildNodes();\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element child = (Element) node;\n                if (child.getTagName().equals(\"message-handler\")) {\n                    parseMessageHandler(child, feature);\n                } else if (child.getTagName().equals(\"command-handler\")) {\n                    parseCommandHandler(child, feature);\n                } else if (child.getTagName().equals(\"message-dispatcher\")) {\n                    parseMessageDispatcher(child, feature);\n                } else if (child.getTagName().equals(\"poll-handler\")) {\n                    parsePollHandler(child, feature);\n                }\n            }\n        }\n\n        return feature;\n    }\n\n    private static HandlerEntry makeHandlerEntry(Element e) throws ParsingException {\n        String handler = e.getTextContent();\n        if (handler == null) {\n            throw new ParsingException(\"Could not find Handler for: \" + e.getTextContent());\n        }\n\n        NamedNodeMap attributes = e.getAttributes();\n        Map<String, @Nullable String> params = new HashMap<>();\n        for (int i = 0; i < attributes.getLength(); i++) {\n            Node n = attributes.item(i);\n            params.put(n.getNodeName(), n.getNodeValue());\n        }\n        return new HandlerEntry(handler, params);\n    }\n\n    private static void parseMessageHandler(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        if (e.getAttribute(\"default\").equals(\"true\")) {\n            f.setDefaultMessageHandler(he);\n        } else {\n            String attr = e.getAttribute(\"cmd\");\n            int command = (attr == null) ? 0 : Utils.from0xHexString(attr);\n            f.addMessageHandler(command, he);\n        }\n    }\n\n    private static void parseCommandHandler(Element e, FeatureTemplate f) throws ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        if (e.getAttribute(\"default\").equals(\"true\")) {\n            f.setDefaultCommandHandler(he);\n        } else {\n            Class<? extends Command> command = parseCommandClass(e.getAttribute(\"command\"));\n            f.addCommandHandler(command, he);\n        }\n    }\n\n    private static void parseMessageDispatcher(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        f.setMessageDispatcher(he);\n    }\n\n    private static void parsePollHandler(Element e, FeatureTemplate f) throws ParsingException {\n        HandlerEntry he = makeHandlerEntry(e);\n        f.setPollHandler(he);\n    }\n\n    private static Class<? extends Command> parseCommandClass(String c) throws ParsingException {\n        if (c.equals(\"OnOffType\")) {\n            return OnOffType.class;\n        } else if (c.equals(\"PercentType\")) {\n            return PercentType.class;\n        } else if (c.equals(\"DecimalType\")) {\n            return DecimalType.class;\n        } else if (c.equals(\"IncreaseDecreaseType\")) {\n            return IncreaseDecreaseType.class;\n        } else {\n            throw new ParsingException(\"Unknown Command Type\");\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.message;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map.Entry;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.insteon.internal.utils.Pair;\nimport org.openhab.binding.insteon.internal.utils.Utils.DataTypeParser;\nimport org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Reads the Msg definitions from an XML file\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\n@SuppressWarnings(\"null\")\npublic class XMLMessageReader {\n    /**\n     * Reads the message definitions from an xml file\n     *\n     * @param input input stream from which to read\n     * @return what was read from file: the map between clear text string and Msg objects\n     * @throws IOException couldn't read file etc\n     * @throws ParsingException something wrong with the file format\n     * @throws FieldException something wrong with the field definition\n     */\n    public static HashMap<String, Msg> readMessageDefinitions(InputStream input)\n            throws IOException, ParsingException, FieldException {\n        HashMap<String, Msg> messageMap = new HashMap<>();\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Parse it!\n            Document doc = dBuilder.parse(input);\n            doc.getDocumentElement().normalize();\n\n            Node root = doc.getDocumentElement();\n\n            NodeList nodes = root.getChildNodes();\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    if (node.getNodeName().equals(\"msg\")) {\n                        Pair<String, Msg> msgDef = readMessageDefinition((Element) node);\n                        messageMap.put(msgDef.getKey(), msgDef.getValue());\n                    }\n                }\n            }\n        } catch (SAXException e) {\n            throw new ParsingException(\"Failed to parse XML!\", e);\n        } catch (ParserConfigurationException e) {\n            throw new ParsingException(\"Got parser config exception! \", e);\n        }\n        return messageMap;\n    }\n\n    private static Pair<String, Msg> readMessageDefinition(Element msg) throws FieldException, ParsingException {\n        int length = 0;\n        int hlength = 0;\n        LinkedHashMap<Field, Object> fieldMap = new LinkedHashMap<>();\n        String dir = msg.getAttribute(\"direction\");\n        String name = msg.getAttribute(\"name\");\n        Msg.Direction direction = Msg.Direction.getDirectionFromString(dir);\n\n        if (msg.hasAttribute(\"length\")) {\n            length = Integer.parseInt(msg.getAttribute(\"length\"));\n        }\n\n        NodeList nodes = msg.getChildNodes();\n\n        int offset = 0;\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                if (node.getNodeName().equals(\"header\")) {\n                    int o = readHeaderElement((Element) node, fieldMap);\n                    hlength = o;\n                    // Increment the offset by the header length\n                    offset += o;\n                } else {\n                    Pair<Field, Object> field = readField((Element) node, offset);\n                    fieldMap.put(field.getKey(), field.getValue());\n                    // Increment the offset\n                    offset += field.getKey().getType().getSize();\n                }\n            }\n        }\n        if (offset != length) {\n            throw new ParsingException(\n                    \"Actual msg length \" + offset + \" differs from given msg length \" + length + \"!\");\n        }\n        if (length == 0) {\n            length = offset;\n        }\n\n        return new Pair<>(name, createMsg(fieldMap, length, hlength, direction));\n    }\n\n    private static int readHeaderElement(Element header, LinkedHashMap<Field, Object> fields) throws ParsingException {\n        int offset = 0;\n        int headerLen = Integer.parseInt(header.getAttribute(\"length\"));\n\n        NodeList nodes = header.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                @Nullable\n                Pair<Field, Object> definition = readField((Element) node, offset);\n                if (definition != null) {\n                    offset += definition.getKey().getType().getSize();\n                    fields.put(definition.getKey(), definition.getValue());\n                }\n            }\n        }\n        if (headerLen != offset) {\n            throw new ParsingException(\n                    \"Actual header length \" + offset + \" differs from given length \" + headerLen + \"!\");\n        }\n        return headerLen;\n    }\n\n    private static Pair<Field, Object> readField(Element field, int offset) {\n        DataType dType = DataType.getDataType(field.getTagName());\n        // Will return blank if no name attribute\n        String name = field.getAttribute(\"name\");\n        Field f = new Field(name, dType, offset);\n        // Now we have field, only need value\n        String sVal = field.getTextContent();\n        Object val = DataTypeParser.parseDataType(dType, sVal);\n        Pair<Field, Object> pair = new Pair<>(f, val);\n        return pair;\n    }\n\n    private static Msg createMsg(HashMap<Field, Object> values, int length, int headerLength, Msg.Direction dir)\n            throws FieldException {\n        Msg msg = new Msg(headerLength, new byte[length], length, dir);\n        for (Entry<Field, Object> e : values.entrySet()) {\n            Field f = e.getKey();\n            f.set(msg.getData(), e.getValue());\n            if (f.getName() != null && !f.getName().equals(\"\")) {\n                msg.addField(f);\n            }\n        }\n        return msg;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.onkyo.internal.handler;\n\nimport static org.openhab.binding.onkyo.internal.OnkyoBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.smarthome.core.audio.AudioHTTPServer;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.NextPreviousType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.library.types.PlayPauseType;\nimport org.eclipse.smarthome.core.library.types.RawType;\nimport org.eclipse.smarthome.core.library.types.RewindFastforwardType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.Channel;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.core.types.StateOption;\nimport org.eclipse.smarthome.core.types.UnDefType;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.onkyo.internal.OnkyoAlbumArt;\nimport org.openhab.binding.onkyo.internal.OnkyoConnection;\nimport org.openhab.binding.onkyo.internal.OnkyoEventListener;\nimport org.openhab.binding.onkyo.internal.OnkyoStateDescriptionProvider;\nimport org.openhab.binding.onkyo.internal.ServiceType;\nimport org.openhab.binding.onkyo.internal.automation.modules.OnkyoThingActionsService;\nimport org.openhab.binding.onkyo.internal.config.OnkyoDeviceConfiguration;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpCommand;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link OnkyoHandler} is responsible for handling commands, which are\n * sent to one of the channels.\n *\n * @author Paul Frank - Initial contribution\n * @author Marcel Verpaalen - parsing additional commands\n * @author Pauli Anttila - lot of refactoring\n * @author Stewart Cossey - add dynamic state description provider\n */\npublic class OnkyoHandler extends UpnpAudioSinkHandler implements OnkyoEventListener {\n\n    private final Logger logger = LoggerFactory.getLogger(OnkyoHandler.class);\n\n    private OnkyoDeviceConfiguration configuration;\n\n    private OnkyoConnection connection;\n    private ScheduledFuture<?> resourceUpdaterFuture;\n    @SuppressWarnings(\"unused\")\n    private int currentInput = -1;\n    private State volumeLevelZone1 = UnDefType.UNDEF;\n    private State volumeLevelZone2 = UnDefType.UNDEF;\n    private State volumeLevelZone3 = UnDefType.UNDEF;\n    private State lastPowerState = OnOffType.OFF;\n\n    private final OnkyoStateDescriptionProvider stateDescriptionProvider;\n\n    private final OnkyoAlbumArt onkyoAlbumArt = new OnkyoAlbumArt();\n\n    private static final int NET_USB_ID = 43;\n\n    public OnkyoHandler(Thing thing, UpnpIOService upnpIOService, AudioHTTPServer audioHTTPServer, String callbackUrl,\n            OnkyoStateDescriptionProvider stateDescriptionProvider) {\n        super(thing, upnpIOService, audioHTTPServer, callbackUrl);\n        this.stateDescriptionProvider = stateDescriptionProvider;\n    }\n\n    /**\n     * Initialize the state of the receiver.\n     */\n    @Override\n    public void initialize() {\n        logger.debug(\"Initializing handler for Onkyo Receiver\");\n        configuration = getConfigAs(OnkyoDeviceConfiguration.class);\n        logger.info(\"Using configuration: {}\", configuration.toString());\n\n        connection = new OnkyoConnection(configuration.ipAddress, configuration.port);\n        connection.addEventListener(this);\n\n        scheduler.execute(() -> {\n            logger.debug(\"Open connection to Onkyo Receiver @{}\", connection.getConnectionName());\n            connection.openConnection();\n            if (connection.isConnected()) {\n                updateStatus(ThingStatus.ONLINE);\n\n                sendCommand(EiscpCommand.INFO_QUERY);\n            }\n        });\n\n        if (configuration.refreshInterval > 0) {\n            // Start resource refresh updater\n            resourceUpdaterFuture = scheduler.scheduleWithFixedDelay(() -> {\n                try {\n                    logger.debug(\"Send resource update requests to Onkyo Receiver @{}\", connection.getConnectionName());\n                    checkStatus();\n                } catch (LinkageError e) {\n                    logger.warn(\"Failed to send resource update requests to Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), e.getMessage());\n                } catch (Exception ex) {\n                    logger.warn(\"Exception in resource refresh Thread Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), ex.getMessage());\n                }\n            }, configuration.refreshInterval, configuration.refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    @Override\n    public void dispose() {\n        super.dispose();\n        if (resourceUpdaterFuture != null) {\n            resourceUpdaterFuture.cancel(true);\n        }\n        if (connection != null) {\n            connection.removeEventListener(this);\n            connection.closeConnection();\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.debug(\"handleCommand for channel {}: {}\", channelUID.getId(), command.toString());\n        switch (channelUID.getId()) {\n            /*\n             * ZONE 1\n             */\n\n            case CHANNEL_POWER:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTE:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUME:\n                handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, command);\n                break;\n            case CHANNEL_INPUT:\n                if (command instanceof DecimalType) {\n                    selectInput(((DecimalType) command).intValue());\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.SOURCE_QUERY);\n                }\n                break;\n            case CHANNEL_LISTENMODE:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 2\n             */\n\n            case CHANNEL_POWERZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE2:\n                handleVolumeSet(EiscpCommand.Zone.ZONE2, volumeLevelZone2, command);\n                break;\n            case CHANNEL_INPUTZONE2:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 3\n             */\n\n            case CHANNEL_POWERZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE3:\n                handleVolumeSet(EiscpCommand.Zone.ZONE3, volumeLevelZone3, command);\n                break;\n            case CHANNEL_INPUTZONE3:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * NET PLAYER\n             */\n\n            case CHANNEL_CONTROL:\n                if (command instanceof PlayPauseType) {\n                    if (command.equals(PlayPauseType.PLAY)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PLAY);\n                    } else if (command.equals(PlayPauseType.PAUSE)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PAUSE);\n                    }\n                } else if (command instanceof NextPreviousType) {\n                    if (command.equals(NextPreviousType.NEXT)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKUP);\n                    } else if (command.equals(NextPreviousType.PREVIOUS)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKDWN);\n                    }\n                } else if (command instanceof RewindFastforwardType) {\n                    if (command.equals(RewindFastforwardType.REWIND)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_REW);\n                    } else if (command.equals(RewindFastforwardType.FASTFORWARD)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_FF);\n                    }\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_PLAY_STATUS_QUERY);\n                }\n                break;\n            case CHANNEL_PLAY_URI:\n                handlePlayUri(command);\n                break;\n            case CHANNEL_ALBUM_ART:\n            case CHANNEL_ALBUM_ART_URL:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_ALBUM_ART_QUERY);\n                }\n                break;\n            case CHANNEL_ARTIST:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ARTIST_QUERY);\n                }\n                break;\n            case CHANNEL_ALBUM:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ALBUM_QUERY);\n                }\n                break;\n            case CHANNEL_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_TITLE_QUERY);\n                }\n                break;\n            case CHANNEL_CURRENTPLAYINGTIME:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ELAPSEDTIME_QUERY);\n                }\n                break;\n\n            /*\n             * NET MENU\n             */\n\n            case CHANNEL_NET_MENU_CONTROL:\n                if (command instanceof StringType) {\n                    final String cmdName = command.toString();\n                    handleNetMenuCommand(cmdName);\n                }\n                break;\n            case CHANNEL_NET_MENU_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n                }\n                break;\n\n            /*\n             * MISC\n             */\n\n            default:\n                logger.debug(\"Command received for an unknown channel: {}\", channelUID.getId());\n                break;\n        }\n    }\n\n    private void populateInputs(NodeList selectorlist) {\n        List<StateOption> options = new ArrayList<>();\n\n        for (int i = 0; i < selectorlist.getLength(); i++) {\n            Element selectorItem = (Element) selectorlist.item(i);\n\n            options.add(new StateOption(String.valueOf(Integer.parseInt(selectorItem.getAttribute(\"id\"), 16)),\n                    selectorItem.getAttribute(\"name\")));\n        }\n        logger.debug(\"Got Input List from Receiver {}\", options);\n\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUT), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE2), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE3), options);\n    }\n\n    private void doPowerOnCheck(State state) {\n        if (configuration.refreshInterval == 0 && lastPowerState == OnOffType.OFF && state == OnOffType.ON) {\n            sendCommand(EiscpCommand.INFO_QUERY);\n        }\n        lastPowerState = state;\n    }\n\n    @Override\n    public void statusUpdateReceived(String ip, EiscpMessage data) {\n        logger.debug(\"Received status update from Onkyo Receiver @{}: data={}\", connection.getConnectionName(), data);\n\n        updateStatus(ThingStatus.ONLINE);\n\n        try {\n            EiscpCommand receivedCommand = null;\n\n            try {\n                receivedCommand = EiscpCommand.getCommandByCommandAndValueStr(data.getCommand(), \"\");\n            } catch (IllegalArgumentException ex) {\n                logger.debug(\"Received unknown status update from Onkyo Receiver @{}: data={}\",\n                        connection.getConnectionName(), data);\n                return;\n            }\n\n            logger.debug(\"Received command {}\", receivedCommand);\n\n            switch (receivedCommand) {\n                /*\n                 * ZONE 1\n                 */\n                case POWER:\n                    State powerState = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWER, powerState);\n                    doPowerOnCheck(powerState);\n                    break;\n                case MUTE:\n                    updateState(CHANNEL_MUTE, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case VOLUME:\n                    volumeLevelZone1 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUME, volumeLevelZone1);\n                    break;\n                case SOURCE:\n                    updateState(CHANNEL_INPUT, convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n                case LISTEN_MODE:\n                    updateState(CHANNEL_LISTENMODE,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 2\n                 */\n                case ZONE2_POWER:\n                    State powerZone2State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE2, powerZone2State);\n                    doPowerOnCheck(powerZone2State);\n                    break;\n                case ZONE2_MUTE:\n                    updateState(CHANNEL_MUTEZONE2, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE2_VOLUME:\n                    volumeLevelZone2 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE2, volumeLevelZone2);\n                    break;\n                case ZONE2_SOURCE:\n                    updateState(CHANNEL_INPUTZONE2,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 3\n                 */\n                case ZONE3_POWER:\n                    State powerZone3State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE3, powerZone3State);\n                    doPowerOnCheck(powerZone3State);\n                    break;\n                case ZONE3_MUTE:\n                    updateState(CHANNEL_MUTEZONE3, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE3_VOLUME:\n                    volumeLevelZone3 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE3, volumeLevelZone3);\n                    break;\n                case ZONE3_SOURCE:\n                    updateState(CHANNEL_INPUTZONE3,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * NET PLAYER\n                 */\n\n                case NETUSB_SONG_ARTIST:\n                    updateState(CHANNEL_ARTIST, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ALBUM:\n                    updateState(CHANNEL_ALBUM, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_TITLE:\n                    updateState(CHANNEL_TITLE, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ELAPSEDTIME:\n                    updateState(CHANNEL_CURRENTPLAYINGTIME,\n                            convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_PLAY_STATUS:\n                    updateState(CHANNEL_CONTROL, convertNetUsbPlayStatus(data.getValue()));\n                    break;\n                case NETUSB_ALBUM_ART:\n                    updateAlbumArt(data.getValue());\n                    break;\n                case NETUSB_TITLE:\n                    updateNetTitle(data.getValue());\n                    break;\n                case NETUSB_MENU:\n                    updateNetMenu(data.getValue());\n                    break;\n\n                /*\n                 * MISC\n                 */\n\n                case INFO:\n                    processInfo(data.getValue());\n                    logger.debug(\"Info message: '{}'\", data.getValue());\n                    break;\n\n                default:\n                    logger.debug(\"Received unhandled status update from Onkyo Receiver @{}: data={}\",\n                            connection.getConnectionName(), data);\n\n            }\n\n        } catch (Exception ex) {\n            logger.warn(\"Exception in statusUpdateReceived for Onkyo Receiver @{}. Cause: {}, data received: {}\",\n                    connection.getConnectionName(), ex.getMessage(), data);\n        }\n    }\n\n    private void processInfo(String infoXML) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            try (StringReader sr = new StringReader(infoXML)) {\n                InputSource is = new InputSource(sr);\n                Document doc = builder.parse(is);\n\n                NodeList selectableInputs = doc.getDocumentElement().getElementsByTagName(\"selector\");\n                populateInputs(selectableInputs);\n            }\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            logger.debug(\"Error occured during Info XML parsing.\", e);\n        }\n    }\n\n    @Override\n    public void connectionError(String ip, String errorMsg) {\n        logger.debug(\"Connection error occurred to Onkyo Receiver @{}\", ip);\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\n    }\n\n    private State convertDeviceValueToOpenHabState(String data, Class<?> classToConvert) {\n        State state = UnDefType.UNDEF;\n\n        try {\n            int index;\n\n            if (data.contentEquals(\"N/A\")) {\n                state = UnDefType.UNDEF;\n\n            } else if (classToConvert == OnOffType.class) {\n                index = Integer.parseInt(data, 16);\n                state = index == 0 ? OnOffType.OFF : OnOffType.ON;\n\n            } else if (classToConvert == DecimalType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new DecimalType(index);\n\n            } else if (classToConvert == PercentType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new PercentType(index);\n\n            } else if (classToConvert == StringType.class) {\n                state = new StringType(data);\n\n            }\n        } catch (Exception e) {\n            logger.debug(\"Cannot convert value '{}' to data type {}\", data, classToConvert);\n        }\n\n        logger.debug(\"Converted data '{}' to openHAB state '{}' ({})\", data, state, classToConvert);\n        return state;\n    }\n\n    private void handleNetMenuCommand(String cmdName) {\n        if (\"Up\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_UP);\n        } else if (\"Down\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_DOWN);\n        } else if (\"Select\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_SELECT);\n        } else if (\"PageUp\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_LEFT);\n        } else if (\"PageDown\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RIGHT);\n        } else if (\"Back\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RETURN);\n        } else if (cmdName.matches(\"Select[0-9]\")) {\n            int pos = Integer.parseInt(cmdName.substring(6));\n            sendCommand(EiscpCommand.NETUSB_MENU_SELECT, new DecimalType(pos));\n        } else {\n            logger.debug(\"Received unknown menucommand {}\", cmdName);\n        }\n    }\n\n    private void selectInput(int inputId) {\n        sendCommand(EiscpCommand.SOURCE_SET, new DecimalType(inputId));\n        currentInput = inputId;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void onInputChanged(int newInput) {\n        currentInput = newInput;\n\n        if (newInput != NET_USB_ID) {\n            resetNetMenu();\n\n            updateState(CHANNEL_ARTIST, UnDefType.UNDEF);\n            updateState(CHANNEL_ALBUM, UnDefType.UNDEF);\n            updateState(CHANNEL_TITLE, UnDefType.UNDEF);\n            updateState(CHANNEL_CURRENTPLAYINGTIME, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateAlbumArt(String data) {\n        onkyoAlbumArt.addFrame(data);\n\n        if (onkyoAlbumArt.isAlbumCoverReady()) {\n            try {\n                byte[] imgData = onkyoAlbumArt.getAlbumArt();\n                if (imgData != null && imgData.length > 0) {\n                    String mimeType = onkyoAlbumArt.getAlbumArtMimeType();\n                    if (mimeType.isEmpty()) {\n                        mimeType = guessMimeTypeFromData(imgData);\n                    }\n                    updateState(CHANNEL_ALBUM_ART, new RawType(imgData, mimeType));\n                } else {\n                    updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n                }\n            } catch (IllegalArgumentException e) {\n                updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n            }\n            onkyoAlbumArt.clearAlbumArt();\n        }\n\n        if (data.startsWith(\"2-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, new StringType(data.substring(2, data.length())));\n        } else if (data.startsWith(\"n-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        } else {\n            logger.debug(\"Not supported album art URL type: {}\", data.substring(0, 2));\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateNetTitle(String data) {\n        // first 2 characters is service type\n        int type = Integer.parseInt(data.substring(0, 2), 16);\n        ServiceType service = ServiceType.getType(type);\n\n        String title = \"\";\n        if (data.length() > 21) {\n            title = data.substring(22, data.length());\n        }\n\n        updateState(CHANNEL_NET_MENU_TITLE,\n                new StringType(service.toString() + ((title.length() > 0) ? \": \" + title : \"\")));\n    }\n\n    private void updateNetMenu(String data) {\n        switch (data.charAt(0)) {\n            case 'U':\n                String itemData = data.substring(3, data.length());\n                switch (data.charAt(1)) {\n                    case '0':\n                        updateState(CHANNEL_NET_MENU0, new StringType(itemData));\n                        break;\n                    case '1':\n                        updateState(CHANNEL_NET_MENU1, new StringType(itemData));\n                        break;\n                    case '2':\n                        updateState(CHANNEL_NET_MENU2, new StringType(itemData));\n                        break;\n                    case '3':\n                        updateState(CHANNEL_NET_MENU3, new StringType(itemData));\n                        break;\n                    case '4':\n                        updateState(CHANNEL_NET_MENU4, new StringType(itemData));\n                        break;\n                    case '5':\n                        updateState(CHANNEL_NET_MENU5, new StringType(itemData));\n                        break;\n                    case '6':\n                        updateState(CHANNEL_NET_MENU6, new StringType(itemData));\n                        break;\n                    case '7':\n                        updateState(CHANNEL_NET_MENU7, new StringType(itemData));\n                        break;\n                    case '8':\n                        updateState(CHANNEL_NET_MENU8, new StringType(itemData));\n                        break;\n                    case '9':\n                        updateState(CHANNEL_NET_MENU9, new StringType(itemData));\n                        break;\n                }\n                break;\n\n            case 'C':\n                updateMenuPosition(data);\n                break;\n        }\n    }\n\n    private void updateMenuPosition(String data) {\n        char position = data.charAt(1);\n        int pos = Character.getNumericValue(position);\n\n        logger.debug(\"Updating menu position to {}\", pos);\n\n        if (pos == -1) {\n            updateState(CHANNEL_NET_MENU_SELECTION, UnDefType.UNDEF);\n        } else {\n            updateState(CHANNEL_NET_MENU_SELECTION, new DecimalType(pos));\n        }\n\n        if (data.endsWith(\"P\")) {\n            resetNetMenu();\n        }\n    }\n\n    private void resetNetMenu() {\n        logger.debug(\"Reset net menu\");\n        updateState(CHANNEL_NET_MENU0, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU1, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU2, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU3, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU4, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU5, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU6, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU7, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU8, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU9, new StringType(\"-\"));\n    }\n\n    private State convertNetUsbPlayStatus(String data) {\n        State state = UnDefType.UNDEF;\n        switch (data.charAt(0)) {\n            case 'P':\n                state = PlayPauseType.PLAY;\n                break;\n            case 'p':\n            case 'S':\n                state = PlayPauseType.PAUSE;\n                break;\n            case 'F':\n                state = RewindFastforwardType.FASTFORWARD;\n                break;\n            case 'R':\n                state = RewindFastforwardType.REWIND;\n                break;\n\n        }\n        return state;\n    }\n\n    public void sendRawCommand(String command, String value) {\n        if (connection != null) {\n            connection.send(command, value);\n        } else {\n            logger.debug(\"Cannot send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand) {\n        if (connection != null) {\n            connection.send(deviceCommand.getCommand(), deviceCommand.getValue());\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand, Command command) {\n        if (connection != null) {\n            final String cmd = deviceCommand.getCommand();\n            String valTemplate = deviceCommand.getValue();\n            String val;\n\n            if (command instanceof OnOffType) {\n                val = String.format(valTemplate, command == OnOffType.ON ? 1 : 0);\n\n            } else if (command instanceof StringType) {\n                val = String.format(valTemplate, command);\n\n            } else if (command instanceof DecimalType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n\n            } else if (command instanceof PercentType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n            } else {\n                val = valTemplate;\n            }\n\n            logger.debug(\"Sending command '{}' with value '{}' to Onkyo Receiver @{}\", cmd, val,\n                    connection.getConnectionName());\n            connection.send(cmd, val);\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    /**\n     * Check the status of the AVR.\n     *\n     * @return\n     */\n    private void checkStatus() {\n        sendCommand(EiscpCommand.POWER_QUERY);\n\n        if (connection != null && connection.isConnected()) {\n            sendCommand(EiscpCommand.VOLUME_QUERY);\n            sendCommand(EiscpCommand.SOURCE_QUERY);\n            sendCommand(EiscpCommand.MUTE_QUERY);\n            sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n            sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n            sendCommand(EiscpCommand.INFO_QUERY);\n\n            if (isChannelAvailable(CHANNEL_POWERZONE2)) {\n                sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE2_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n            }\n\n            if (isChannelAvailable(CHANNEL_POWERZONE3)) {\n                sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE3_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n            }\n        } else {\n            updateStatus(ThingStatus.OFFLINE);\n        }\n    }\n\n    private boolean isChannelAvailable(String channel) {\n        List<Channel> channels = getThing().getChannels();\n        for (Channel c : channels) {\n            if (c.getUID().getId().equals(channel)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void handleVolumeSet(EiscpCommand.Zone zone, final State currentValue, final Command command) {\n        if (command instanceof PercentType) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_SET),\n                    downScaleVolume((PercentType) command));\n        } else if (command.equals(IncreaseDecreaseType.INCREASE)) {\n            if (currentValue instanceof PercentType) {\n                if (((DecimalType) currentValue).intValue() < configuration.volumeLimit) {\n                    sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_UP));\n                } else {\n                    logger.info(\"Volume level is limited to {}, ignore volume up command.\", configuration.volumeLimit);\n                }\n            }\n        } else if (command.equals(IncreaseDecreaseType.DECREASE)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_DOWN));\n        } else if (command.equals(OnOffType.OFF)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(OnOffType.ON)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(RefreshType.REFRESH)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_QUERY));\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_QUERY));\n        }\n    }\n\n    private State handleReceivedVolume(State volume) {\n        if (volume instanceof DecimalType) {\n            return upScaleVolume(((DecimalType) volume));\n        }\n        return volume;\n    }\n\n    private PercentType upScaleVolume(DecimalType volume) {\n        PercentType newVolume = scaleVolumeFromReceiver(volume);\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = 100d / configuration.volumeLimit;\n            PercentType unLimitedVolume = newVolume;\n            newVolume = new PercentType(((Double) (newVolume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Up scaled volume level '{}' to '{}'\", unLimitedVolume, newVolume);\n        }\n\n        return newVolume;\n    }\n\n    private DecimalType downScaleVolume(PercentType volume) {\n        PercentType limitedVolume = volume;\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = configuration.volumeLimit / 100d;\n            limitedVolume = new PercentType(((Double) (volume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Limited volume level '{}' to '{}'\", volume, limitedVolume);\n        }\n\n        return scaleVolumeForReceiver(limitedVolume);\n    }\n\n    private DecimalType scaleVolumeForReceiver(PercentType volume) {\n        return new DecimalType(((Double) (volume.doubleValue() * configuration.volumeScale)).intValue());\n    }\n\n    private PercentType scaleVolumeFromReceiver(DecimalType volume) {\n        return new PercentType(((Double) (volume.intValue() / configuration.volumeScale)).intValue());\n    }\n\n    @Override\n    public PercentType getVolume() throws IOException {\n        if (volumeLevelZone1 instanceof PercentType) {\n            return (PercentType) volumeLevelZone1;\n        }\n\n        throw new IOException();\n    }\n\n    @Override\n    public void setVolume(PercentType volume) throws IOException {\n        handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, downScaleVolume(volume));\n    }\n\n    private String guessMimeTypeFromData(byte[] data) {\n        String mimeType = HttpUtil.guessContentTypeFromData(data);\n        logger.debug(\"Mime type guess from content: {}\", mimeType);\n        if (mimeType == null) {\n            mimeType = RawType.DEFAULT_MIME_TYPE;\n        }\n        logger.debug(\"Mime type: {}\", mimeType);\n        return mimeType;\n    }\n\n    @Override\n    public Collection<Class<? extends ThingHandlerService>> getServices() {\n        return Collections.singletonList(OnkyoThingActionsService.class);\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.samsungtv.internal.service;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link SamsungTvUtils} provides some utilities for internal use.\n *\n * @author Pauli Anttila - Initial contribution\n */\n@NonNullByDefault\npublic class SamsungTvUtils {\n\n    /**\n     * Build {@link String} type {@link HashMap} from variable number of\n     * {@link String}s.\n     *\n     * @param data\n     *            Variable number of {@link String} parameters which will be\n     *            added to hash map.\n     */\n    public static HashMap<String, String> buildHashMap(String... data) {\n        HashMap<String, String> result = new HashMap<>();\n\n        if (data.length % 2 != 0) {\n            throw new IllegalArgumentException(\"Odd number of arguments\");\n        }\n        String key = null;\n        Integer step = -1;\n\n        for (String value : data) {\n            step++;\n            switch (step % 2) {\n                case 0:\n                    if (value == null) {\n                        throw new IllegalArgumentException(\"Null key value\");\n                    }\n                    key = value;\n                    continue;\n                case 1:\n                    if (key != null) {\n                        result.put(key, value);\n                    }\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Build {@link Document} from {@link String} which contains XML content.\n     *\n     * @param xml\n     *            {@link String} which contains XML content.\n     * @return {@link Document} or null if convert has failed.\n     */\n    public static @Nullable Document loadXMLFromString(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xml));\n            return builder.parse(is);\n\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            // Silently ignore exception and return null.\n        }\n\n        return null;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.sonos.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link SonosXMLParser} is a class of helper functions\n * to parse XML data returned by the Zone Players\n *\n * @author Karel Goderis - Initial contribution\n */\n@NonNullByDefault\npublic class SonosXMLParser {\n\n    static final Logger LOGGER = LoggerFactory.getLogger(SonosXMLParser.class);\n\n    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n                    + \"xmlns:r=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\" \"\n                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n                    + \"<upnp:class>{3}</upnp:class>\"\n                    + \"<desc id=\\\"cdudn\\\" nameSpace=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\">\" + \"{4}</desc>\"\n                    + \"</item></DIDL-Lite>\");\n\n    private enum Element {\n        TITLE,\n        CLASS,\n        ALBUM,\n        ALBUM_ART_URI,\n        CREATOR,\n        RES,\n        TRACK_NUMBER,\n        RESMD,\n        DESC\n    }\n\n    private enum CurrentElement {\n        item,\n        res,\n        streamContent,\n        albumArtURI,\n        title,\n        upnpClass,\n        creator,\n        album,\n        albumArtist,\n        desc\n    }\n\n    /**\n     * @param xml\n     * @return a list of alarms from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosAlarm> getAlarmsFromStringResult(String xml) {\n        AlarmHandler handler = new AlarmHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        }\n        return handler.getAlarms();\n    }\n\n    /**\n     * @param xml\n     * @return a list of Entries from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosEntry> getEntriesFromString(String xml) {\n        EntryHandler handler = new EntryHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        }\n\n        return handler.getArtists();\n    }\n\n    /**\n     * Returns the meta data which is needed to play Pandora\n     * (and others?) favorites\n     *\n     * @param xml\n     * @return The value of the desc xml tag\n     * @throws SAXException\n     */\n    public static @Nullable SonosResourceMetaData getResourceMetaData(String xml) throws SAXException {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        ResourceMetaDataHandler handler = new ResourceMetaDataHandler();\n        reader.setContentHandler(handler);\n        try {\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Resource MetaData from String '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Resource MetaData from string '{}'\", xml);\n        }\n        return handler.getMetaData();\n    }\n\n    /**\n     * @param controller\n     * @param xml\n     * @return zone group from the given xml\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosZoneGroup> getZoneGroupFromXML(String xml) {\n        ZoneGroupHandler handler = new ZoneGroupHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        }\n\n        return handler.getGroups();\n    }\n\n    public static List<String> getRadioTimeFromXML(String xml) {\n        OpmlHandler handler = new OpmlHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        }\n\n        return handler.getTextFields();\n    }\n\n    public static Map<String, @Nullable String> getRenderingControlFromXML(String xml) {\n        RenderingControlEventHandler handler = new RenderingControlEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static Map<String, @Nullable String> getAVTransportFromXML(String xml) {\n        AVTransportEventHandler handler = new AVTransportEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static SonosMetaData getMetaDataFromXML(String xml) {\n        MetaDataHandler handler = new MetaDataHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        }\n\n        return handler.getMetaData();\n    }\n\n    public static List<SonosMusicService> getMusicServicesFromXML(String xml) {\n        MusicServiceHandler handler = new MusicServiceHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        }\n        return handler.getServices();\n    }\n\n    private static class EntryHandler extends DefaultHandler {\n\n        // Maintain a set of elements about which it is unuseful to complain about.\n        // This list will be initialized on the first failure case\n        private static @Nullable List<String> ignore;\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder res = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder trackNumber = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n\n        private List<SonosEntry> artists = new ArrayList<>();\n\n        EntryHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    element = Element.RES;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:creator\":\n                    element = Element.CREATOR;\n                    break;\n                case \"upnp:album\":\n                    element = Element.ALBUM;\n                    break;\n                case \"upnp:albumArtURI\":\n                    element = Element.ALBUM_ART_URI;\n                    break;\n                case \"upnp:originalTrackNumber\":\n                    element = Element.TRACK_NUMBER;\n                    break;\n                case \"r:resMD\":\n                    element = Element.RESMD;\n                    break;\n                default:\n                    List<String> curIgnore = ignore;\n                    if (curIgnore == null) {\n                        curIgnore = new ArrayList<>();\n                        curIgnore.add(\"DIDL-Lite\");\n                        curIgnore.add(\"type\");\n                        curIgnore.add(\"ordinal\");\n                        curIgnore.add(\"description\");\n                        ignore = curIgnore;\n                    }\n\n                    if (!curIgnore.contains(localName)) {\n                        LOGGER.debug(\"Did not recognise element named {}\", localName);\n                    }\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case RES:\n                    res.append(ch, start, length);\n                    break;\n                case ALBUM:\n                    album.append(ch, start, length);\n                    break;\n                case ALBUM_ART_URI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case CREATOR:\n                    creator.append(ch, start, length);\n                    break;\n                case TRACK_NUMBER:\n                    trackNumber.append(ch, start, length);\n                    break;\n                case RESMD:\n                    desc.append(ch, start, length);\n                    break;\n                case DESC:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if ((\"container\".equals(qName) || \"item\".equals(qName))) {\n                element = null;\n\n                int trackNumberVal = 0;\n                try {\n                    trackNumberVal = Integer.parseInt(trackNumber.toString());\n                } catch (Exception e) {\n                }\n\n                SonosResourceMetaData md = null;\n\n                // The resource description is needed for playing favorites on pandora\n                if (!desc.toString().isEmpty()) {\n                    try {\n                        md = getResourceMetaData(desc.toString());\n                    } catch (SAXException ignore) {\n                        LOGGER.debug(\"Failed to parse embeded\", ignore);\n                    }\n                }\n\n                artists.add(new SonosEntry(id, title.toString(), parentId, album.toString(), albumArtUri.toString(),\n                        creator.toString(), upnpClass.toString(), res.toString(), trackNumberVal, md));\n                title = new StringBuilder();\n                upnpClass = new StringBuilder();\n                res = new StringBuilder();\n                album = new StringBuilder();\n                albumArtUri = new StringBuilder();\n                creator = new StringBuilder();\n                trackNumber = new StringBuilder();\n                desc = new StringBuilder();\n            }\n        }\n\n        public List<SonosEntry> getArtists() {\n            return artists;\n        }\n    }\n\n    private static class ResourceMetaDataHandler extends DefaultHandler {\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n        private @Nullable SonosResourceMetaData metaData;\n\n        ResourceMetaDataHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"desc\":\n                    element = Element.DESC;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                default:\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case DESC:\n                    desc.append(ch, start, length);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"DIDL-Lite\".equals(qName)) {\n                metaData = new SonosResourceMetaData(id, parentId, title.toString(), upnpClass.toString(),\n                        desc.toString());\n                element = null;\n                desc = new StringBuilder();\n                upnpClass = new StringBuilder();\n                title = new StringBuilder();\n            }\n        }\n\n        public @Nullable SonosResourceMetaData getMetaData() {\n            return metaData;\n        }\n    }\n\n    private static class AlarmHandler extends DefaultHandler {\n\n        private @Nullable String id;\n        private String startTime = \"\";\n        private String duration = \"\";\n        private String recurrence = \"\";\n        private @Nullable String enabled;\n        private String roomUUID = \"\";\n        private String programURI = \"\";\n        private String programMetaData = \"\";\n        private String playMode = \"\";\n        private @Nullable String volume;\n        private @Nullable String includeLinkedZones;\n\n        private List<SonosAlarm> alarms = new ArrayList<>();\n\n        AlarmHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"Alarm\".equals(qName) && attributes != null) {\n                id = attributes.getValue(\"ID\");\n                duration = attributes.getValue(\"Duration\");\n                recurrence = attributes.getValue(\"Recurrence\");\n                startTime = attributes.getValue(\"StartTime\");\n                enabled = attributes.getValue(\"Enabled\");\n                roomUUID = attributes.getValue(\"RoomUUID\");\n                programURI = attributes.getValue(\"ProgramURI\");\n                programMetaData = attributes.getValue(\"ProgramMetaData\");\n                playMode = attributes.getValue(\"PlayMode\");\n                volume = attributes.getValue(\"Volume\");\n                includeLinkedZones = attributes.getValue(\"IncludeLinkedZones\");\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"Alarm\".equals(qName)) {\n                int finalID = 0;\n                int finalVolume = 0;\n                boolean finalEnabled = !\"0\".equals(enabled);\n                boolean finalIncludeLinkedZones = !\"0\".equals(includeLinkedZones);\n\n                try {\n                    finalID = Integer.parseInt(id);\n                    finalVolume = Integer.parseInt(volume);\n                } catch (Exception e) {\n                    LOGGER.debug(\"Error parsing Integer\");\n                }\n\n                alarms.add(new SonosAlarm(finalID, startTime, duration, recurrence, finalEnabled, roomUUID, programURI,\n                        programMetaData, playMode, finalVolume, finalIncludeLinkedZones));\n            }\n        }\n\n        public List<SonosAlarm> getAlarms() {\n            return alarms;\n        }\n    }\n\n    private static class ZoneGroupHandler extends DefaultHandler {\n\n        private final List<SonosZoneGroup> groups = new ArrayList<>();\n        private final List<String> currentGroupPlayers = new ArrayList<>();\n        private final List<String> currentGroupPlayerZones = new ArrayList<>();\n        private String coordinator = \"\";\n        private String groupId = \"\";\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"ZoneGroup\".equals(qName) && attributes != null) {\n                groupId = attributes.getValue(\"ID\");\n                coordinator = attributes.getValue(\"Coordinator\");\n            } else if (\"ZoneGroupMember\".equals(qName) && attributes != null) {\n                currentGroupPlayers.add(attributes.getValue(\"UUID\"));\n                String zoneName = attributes.getValue(\"ZoneName\");\n                if (zoneName != null) {\n                    currentGroupPlayerZones.add(zoneName);\n                }\n                String htInfoSet = attributes.getValue(\"HTSatChanMapSet\");\n                if (htInfoSet != null) {\n                    currentGroupPlayers.addAll(getAllHomeTheaterMembers(htInfoSet));\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"ZoneGroup\".equals(qName)) {\n                groups.add(new SonosZoneGroup(groupId, coordinator, currentGroupPlayers, currentGroupPlayerZones));\n                currentGroupPlayers.clear();\n                currentGroupPlayerZones.clear();\n            }\n        }\n\n        public List<SonosZoneGroup> getGroups() {\n            return groups;\n        }\n\n        private Set<String> getAllHomeTheaterMembers(String homeTheaterDescription) {\n            Set<String> homeTheaterMembers = new HashSet<>();\n            Matcher matcher = Pattern.compile(\"(RINCON_\\\\w+)\").matcher(homeTheaterDescription);\n            while (matcher.find()) {\n                String member = matcher.group();\n                homeTheaterMembers.add(member);\n            }\n            return homeTheaterMembers;\n        }\n    }\n\n    private static class OpmlHandler extends DefaultHandler {\n\n        // <opml version=\"1\">\n        // <head>\n        // <status>200</status>\n        //\n        // </head>\n        // <body>\n        // <outline type=\"text\" text=\"Q-Music 103.3\" guide_id=\"s2398\" key=\"station\"\n        // image=\"http://radiotime-logos.s3.amazonaws.com/s87683q.png\" preset_id=\"s2398\"/>\n        // <outline type=\"text\" text=\"Bjorn Verhoeven\" guide_id=\"p257265\" seconds_remaining=\"2230\" duration=\"7200\"\n        // key=\"show\"/>\n        // <outline type=\"text\" text=\"Top 40-Pop\"/>\n        // <outline type=\"text\" text=\"37m remaining\"/>\n        // <outline type=\"object\" text=\"NowPlaying\">\n        // <nowplaying>\n        // <logo>http://radiotime-logos.s3.amazonaws.com/s87683.png</logo>\n        // <twitter_id />\n        // </nowplaying>\n        // </outline>\n        // </body>\n        // </opml>\n\n        private final List<String> textFields = new ArrayList<>();\n        private @Nullable String textField;\n        private @Nullable String type;\n        // private String logo;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"outline\".equals(qName)) {\n                type = attributes == null ? null : attributes.getValue(\"type\");\n                if (\"text\".equals(type)) {\n                    textField = attributes == null ? null : attributes.getValue(\"text\");\n                } else {\n                    textField = null;\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"outline\".equals(qName)) {\n                String field = textField;\n                if (field != null) {\n                    textFields.add(field);\n                }\n            }\n        }\n\n        public List<String> getTextFields() {\n            return textFields;\n        }\n    }\n\n    private static class AVTransportEventHandler extends DefaultHandler {\n\n        /*\n         * <Event xmlns=\"urn:schemas-upnp-org:metadata-1-0/AVT/\" xmlns:r=\"urn:schemas-rinconnetworks-com:metadata-1-0/\">\n         * <InstanceID val=\"0\">\n         * <TransportState val=\"PLAYING\"/>\n         * <CurrentPlayMode val=\"NORMAL\"/>\n         * <CurrentPlayMode val=\"0\"/>\n         * <NumberOfTracks val=\"29\"/>\n         * <CurrentTrack val=\"12\"/>\n         * <CurrentSection val=\"0\"/>\n         * <CurrentTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma\"\n         * />\n         * <CurrentTrackDuration val=\"0:03:02\"/>\n         * <CurrentTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:03:02&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma&lt;/res&gt;&lt;r:streamContent&gt;&lt;/r:streamContent&gt;&lt;dc:title&gt;Broken Box&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:NextTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&apos;&apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&apos;&apos;.wma\"\n         * /><r:NextTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:04:56&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&amp;apos;&amp;apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&amp;apos;&amp;apos;.wma&lt;/res&gt;&lt;dc:title&gt;&amp;apos;&amp;apos;You Got A Killer Scene There, Man...&amp;apos;&amp;apos;&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:EnqueuedTransportURI\n         * val=\"x-rincon-playlist:RINCON_000E582126EE01400#A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age\"/><r:\n         * EnqueuedTransportURIMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age&quot; parentID=&quot;A:ALBUMARTIST&quot; restricted=&quot;true&quot;&gt;&lt;dc:title&gt;Queens Of The Stone Age&lt;/dc:title&gt;&lt;upnp:class&gt;object.container&lt;/upnp:class&gt;&lt;desc id=&quot;cdudn&quot; nameSpace=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot;&gt;RINCON_AssociatedZPUDN&lt;/desc&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * />\n         * <PlaybackStorageMedium val=\"NETWORK\"/>\n         * <AVTransportURI val=\"x-rincon-queue:RINCON_000E5812BC1801400#0\"/>\n         * <AVTransportURIMetaData val=\"\"/>\n         * <CurrentTransportActions val=\"Play, Stop, Pause, Seek, Next, Previous\"/>\n         * <TransportStatus val=\"OK\"/>\n         * <r:SleepTimerGeneration val=\"0\"/>\n         * <r:AlarmRunning val=\"0\"/>\n         * <r:SnoozeRunning val=\"0\"/>\n         * <r:RestartPending val=\"0\"/>\n         * <TransportPlaySpeed val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentMediaDuration val=\"NOT_IMPLEMENTED\"/>\n         * <RecordStorageMedium val=\"NOT_IMPLEMENTED\"/>\n         * <PossiblePlaybackStorageMedia val=\"NONE, NETWORK\"/>\n         * <PossibleRecordStorageMedia val=\"NOT_IMPLEMENTED\"/>\n         * <RecordMediumWriteStatus val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentRecordQualityMode val=\"NOT_IMPLEMENTED\"/>\n         * <PossibleRecordQualityModes val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURI val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURIMetaData val=\"NOT_IMPLEMENTED\"/>\n         * </InstanceID>\n         * </Event>\n         */\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            /*\n             * The events are all of the form <qName val=\"value\"/> so we can get all\n             * the info we need from here.\n             */\n            if (localName == null) {\n                // this means that localName isn't defined in EventType, which is expected for some elements\n                LOGGER.info(\"{} is not defined in EventType. \", localName);\n            } else {\n                String val = attributes == null ? null : attributes.getValue(\"val\");\n                if (val != null) {\n                    changes.put(localName, val);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MetaDataHandler extends DefaultHandler {\n\n        private @Nullable CurrentElement currentElement;\n\n        private String id = \"-1\";\n        private String parentId = \"-1\";\n        private StringBuilder resource = new StringBuilder();\n        private StringBuilder streamContent = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtist = new StringBuilder();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = localName == null ? \"\" : localName;\n            switch (name) {\n                case \"item\":\n                    currentElement = CurrentElement.item;\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    currentElement = CurrentElement.res;\n                    break;\n                case \"streamContent\":\n                    currentElement = CurrentElement.streamContent;\n                    break;\n                case \"albumArtURI\":\n                    currentElement = CurrentElement.albumArtURI;\n                    break;\n                case \"title\":\n                    currentElement = CurrentElement.title;\n                    break;\n                case \"class\":\n                    currentElement = CurrentElement.upnpClass;\n                    break;\n                case \"creator\":\n                    currentElement = CurrentElement.creator;\n                    break;\n                case \"album\":\n                    currentElement = CurrentElement.album;\n                    break;\n                case \"albumArtist\":\n                    currentElement = CurrentElement.albumArtist;\n                    break;\n                default:\n                    // unknown element\n                    currentElement = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            CurrentElement elt = currentElement;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case item:\n                    break;\n                case res:\n                    resource.append(ch, start, length);\n                    break;\n                case streamContent:\n                    streamContent.append(ch, start, length);\n                    break;\n                case albumArtURI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case title:\n                    title.append(ch, start, length);\n                    break;\n                case upnpClass:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case creator:\n                    creator.append(ch, start, length);\n                    break;\n                case album:\n                    album.append(ch, start, length);\n                    break;\n                case albumArtist:\n                    albumArtist.append(ch, start, length);\n                    break;\n                case desc:\n                    break;\n            }\n        }\n\n        public SonosMetaData getMetaData() {\n            return new SonosMetaData(id, parentId, resource.toString(), streamContent.toString(),\n                    albumArtUri.toString(), title.toString(), upnpClass.toString(), creator.toString(),\n                    album.toString(), albumArtist.toString());\n        }\n    }\n\n    private static class RenderingControlEventHandler extends DefaultHandler {\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        private boolean getPresetName = false;\n        private @Nullable String presetName;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (qName == null) {\n                return;\n            }\n            String channel;\n            String val;\n            switch (qName) {\n                case \"Volume\":\n                case \"Mute\":\n                case \"Loudness\":\n                    channel = attributes == null ? null : attributes.getValue(\"channel\");\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (channel != null && val != null) {\n                        changes.put(qName + channel, val);\n                    }\n                    break;\n                case \"Bass\":\n                case \"Treble\":\n                case \"OutputFixed\":\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (val != null) {\n                        changes.put(qName, val);\n                    }\n                    break;\n                case \"PresetNameList\":\n                    getPresetName = true;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (getPresetName) {\n                presetName = new String(ch, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (getPresetName) {\n                getPresetName = false;\n                String preset = presetName;\n                if (qName != null && preset != null) {\n                    changes.put(qName, preset);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MusicServiceHandler extends DefaultHandler {\n\n        private final List<SonosMusicService> services = new ArrayList<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            // All services are of the form <services Id=\"value\" Name=\"value\">...</Service>\n            if (\"Service\".equals(qName) && attributes != null && attributes.getValue(\"Id\") != null\n                    && attributes.getValue(\"Name\") != null) {\n                services.add(new SonosMusicService(attributes.getValue(\"Id\"), attributes.getValue(\"Name\")));\n            }\n        }\n\n        public List<SonosMusicService> getServices() {\n            return services;\n        }\n    }\n\n    public static @Nullable String getRoomName(String descriptorXML) {\n        RoomNameHandler roomNameHandler = new RoomNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(roomNameHandler);\n            URL url = new URL(descriptorXML);\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos room name from string '{}'\", descriptorXML);\n        }\n        return roomNameHandler.getRoomName();\n    }\n\n    private static class RoomNameHandler extends DefaultHandler {\n\n        private @Nullable String roomName;\n        private boolean roomNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"roomName\".equalsIgnoreCase(localName)) {\n                roomNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (roomNameTag) {\n                roomName = new String(ch, start, length);\n                roomNameTag = false;\n            }\n        }\n\n        public @Nullable String getRoomName() {\n            return roomName;\n        }\n    }\n\n    public static @Nullable String parseModelDescription(URL descriptorURL) {\n        ModelNameHandler modelNameHandler = new ModelNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(modelNameHandler);\n            URL url = new URL(descriptorURL.toString());\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos model name from string '{}'\", descriptorURL.toString());\n        }\n        return modelNameHandler.getModelName();\n    }\n\n    private static class ModelNameHandler extends DefaultHandler {\n\n        private @Nullable String modelName;\n        private boolean modelNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"modelName\".equalsIgnoreCase(localName)) {\n                modelNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (modelNameTag) {\n                modelName = new String(ch, start, length);\n                modelNameTag = false;\n            }\n        }\n\n        public @Nullable String getModelName() {\n            return modelName;\n        }\n    }\n\n    /**\n     * The model name provided by upnp is formated like in the example form \"Sonos PLAY:1\" or \"Sonos PLAYBAR\"\n     *\n     * @param sonosModelName Sonos model name provided via upnp device\n     * @return the extracted players model name without column (:) character used for ThingType creation\n     */\n    public static String extractModelName(String sonosModelName) {\n        String ret = sonosModelName;\n        Matcher matcher = Pattern.compile(\"\\\\s(.*)\").matcher(ret);\n        if (matcher.find()) {\n            ret = matcher.group(1);\n        }\n        if (ret.contains(\":\")) {\n            ret = ret.replace(\":\", \"\");\n        }\n        return ret;\n    }\n\n    public static String compileMetadataString(SonosEntry entry) {\n        /**\n         * If the entry contains resource meta data we will override this with\n         * that data.\n         */\n        String id = entry.getId();\n        String parentId = entry.getParentId();\n        String title = entry.getTitle();\n        String upnpClass = entry.getUpnpClass();\n\n        /**\n         * By default 'RINCON_AssociatedZPUDN' is used for most operations,\n         * however when playing a favorite entry that is associated withh a\n         * subscription like pandora we need to use the desc string asscoiated\n         * with that item.\n         */\n        String desc = entry.getDesc();\n        if (desc == null) {\n            desc = \"RINCON_AssociatedZPUDN\";\n        }\n\n        /**\n         * If resource meta data exists, use it over the parent data\n         */\n        SonosResourceMetaData resourceMetaData = entry.getResourceMetaData();\n        if (resourceMetaData != null) {\n            id = resourceMetaData.getId();\n            parentId = resourceMetaData.getParentId();\n            title = resourceMetaData.getTitle();\n            desc = resourceMetaData.getDesc();\n            upnpClass = resourceMetaData.getUpnpClass();\n        }\n\n        title = StringEscapeUtils.escapeXml(title);\n\n        String metadata = METADATA_FORMAT.format(new Object[] { id, parentId, title, upnpClass, desc });\n\n        return metadata;\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.tellstick.internal.live;\n\nimport java.math.BigDecimal;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.asynchttpclient.AsyncHttpClient;\nimport org.asynchttpclient.AsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClient;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig.Builder;\nimport org.asynchttpclient.Response;\nimport org.asynchttpclient.oauth.ConsumerKey;\nimport org.asynchttpclient.oauth.OAuthSignatureCalculator;\nimport org.asynchttpclient.oauth.RequestToken;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.State;\nimport org.openhab.binding.tellstick.internal.TelldusBindingException;\nimport org.openhab.binding.tellstick.internal.handler.TelldusDeviceController;\nimport org.openhab.binding.tellstick.internal.live.xml.TelldusLiveResponse;\nimport org.openhab.binding.tellstick.internal.live.xml.TellstickNetDevice;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.tellstick.JNA;\nimport org.tellstick.device.TellstickDevice;\nimport org.tellstick.device.TellstickDeviceEvent;\nimport org.tellstick.device.TellstickException;\nimport org.tellstick.device.TellstickSensorEvent;\nimport org.tellstick.device.iface.Device;\nimport org.tellstick.device.iface.DeviceChangeListener;\nimport org.tellstick.device.iface.SensorListener;\nimport org.tellstick.device.iface.SwitchableDevice;\n\n/**\n * {@link TelldusLiveDeviceController} is the communication with Telldus Live service (Tellstick.NET and ZNET)\n * This controller uses XML based Rest API to communicate with Telldus Live.\n *\n * @author Jarle Hjortland - Initial contribution\n */\npublic class TelldusLiveDeviceController implements DeviceChangeListener, SensorListener, TelldusDeviceController {\n    private final Logger logger = LoggerFactory.getLogger(TelldusLiveDeviceController.class);\n    private long lastSend = 0;\n    public static final long DEFAULT_INTERVAL_BETWEEN_SEND = 250;\n    static final int REQUEST_TIMEOUT_MS = 5000;\n    private AsyncHttpClient client;\n    static final String HTTP_API_TELLDUS_COM_XML = \"http://api.telldus.com/xml/\";\n    static final String HTTP_TELLDUS_CLIENTS = HTTP_API_TELLDUS_COM_XML + \"clients/list\";\n    static final String HTTP_TELLDUS_DEVICES = HTTP_API_TELLDUS_COM_XML + \"devices/list?supportedMethods=19\";\n    static final String HTTP_TELLDUS_SENSORS = HTTP_API_TELLDUS_COM_XML\n            + \"sensors/list?includeValues=1&includeScale=1&includeUnit=1\";\n    static final String HTTP_TELLDUS_SENSOR_INFO = HTTP_API_TELLDUS_COM_XML + \"sensor/info\";\n    static final String HTTP_TELLDUS_DEVICE_DIM = HTTP_API_TELLDUS_COM_XML + \"device/dim?id=%d&level=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNOFF = HTTP_API_TELLDUS_COM_XML + \"device/turnOff?id=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNON = HTTP_API_TELLDUS_COM_XML + \"device/turnOn?id=%d\";\n    private static final int MAX_RETRIES = 3;\n\n    public TelldusLiveDeviceController() {\n    }\n\n    @Override\n    public void dispose() {\n        try {\n            client.close();\n        } catch (Exception e) {\n            logger.error(\"Failed to close client\", e);\n        }\n    }\n\n    void connectHttpClient(String publicKey, String privateKey, String token, String tokenSecret) {\n        ConsumerKey consumer = new ConsumerKey(publicKey, privateKey);\n        RequestToken user = new RequestToken(token, tokenSecret);\n        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);\n        this.client = new DefaultAsyncHttpClient(createAsyncHttpClientConfig());\n        try {\n            this.client.setSignatureCalculator(calc);\n            Response response = client.prepareGet(HTTP_TELLDUS_CLIENTS).execute().get();\n            logger.debug(\"Response {} statusText {}\", response.getResponseBody(), response.getStatusText());\n        } catch (InterruptedException | ExecutionException e) {\n            logger.error(\"Failed to connect\", e);\n        }\n    }\n\n    private AsyncHttpClientConfig createAsyncHttpClientConfig() {\n        Builder builder = new DefaultAsyncHttpClientConfig.Builder();\n        builder.setConnectTimeout(REQUEST_TIMEOUT_MS);\n        return builder.build();\n    }\n\n    @Override\n    public void handleSendEvent(Device device, int resendCount, boolean isdimmer, Command command)\n            throws TellstickException {\n        logger.info(\"Send {} to {}\", command, device);\n        if (device instanceof TellstickNetDevice) {\n            if (command == OnOffType.ON) {\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            } else if (command instanceof PercentType) {\n                dim(device, (PercentType) command);\n            } else if (command instanceof IncreaseDecreaseType) {\n                increaseDecrease(device, ((IncreaseDecreaseType) command));\n            }\n        } else if (device instanceof SwitchableDevice) {\n            if (command == OnOffType.ON) {\n                if (isdimmer) {\n                    logger.debug(\"Turn off first in case it is allready on\");\n                    turnOff(device);\n                }\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            }\n        } else {\n            logger.warn(\"Cannot send to {}\", device);\n        }\n    }\n\n    private void increaseDecrease(Device dev, IncreaseDecreaseType increaseDecreaseType) throws TellstickException {\n        String strValue = ((TellstickDevice) dev).getData();\n        double value = 0;\n        if (strValue != null) {\n            value = Double.valueOf(strValue);\n        }\n        int percent = (int) Math.round((value / 255) * 100);\n        if (IncreaseDecreaseType.INCREASE == increaseDecreaseType) {\n            percent = Math.min(percent + 10, 100);\n        } else if (IncreaseDecreaseType.DECREASE == increaseDecreaseType) {\n            percent = Math.max(percent - 10, 0);\n        }\n        dim(dev, new PercentType(percent));\n    }\n\n    private void dim(Device dev, PercentType command) throws TellstickException {\n        double value = command.doubleValue();\n\n        // 0 means OFF and 100 means ON\n        if (value == 0 && dev instanceof TellstickNetDevice) {\n            turnOff(dev);\n        } else if (value == 100 && dev instanceof TellstickNetDevice) {\n            turnOn(dev);\n        } else if (dev instanceof TellstickNetDevice\n                && (((TellstickNetDevice) dev).getMethods() & JNA.CLibrary.TELLSTICK_DIM) > 0) {\n            long tdVal = Math.round((value / 100) * 255);\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_DIM, dev.getId(), tdVal),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send DIM to \" + dev);\n        }\n    }\n\n    private void turnOff(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNOFF, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send OFF to \" + dev);\n        }\n    }\n\n    private void handleResponse(TellstickNetDevice device, TelldusLiveResponse response) throws TellstickException {\n        if (response == null || (response.status == null && response.error == null)) {\n            throw new TelldusBindingException(\"No response \" + response);\n        } else if (response.error != null) {\n            if (response.error.equals(\"The client for this device is currently offline\")) {\n                device.setOnline(false);\n                device.setUpdated(true);\n            }\n            throw new TelldusBindingException(\"Error \" + response.error);\n        } else if (!response.status.trim().equals(\"success\")) {\n            throw new TelldusBindingException(\"Response \" + response.status);\n        }\n    }\n\n    private void turnOn(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNON, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send ON to \" + dev);\n        }\n    }\n\n    @Override\n    public State calcState(Device dev) {\n        TellstickNetDevice device = (TellstickNetDevice) dev;\n        State st = null;\n        if (device.getOnline()) {\n            switch (device.getState()) {\n                case JNA.CLibrary.TELLSTICK_TURNON:\n                    st = OnOffType.ON;\n                    break;\n                case JNA.CLibrary.TELLSTICK_TURNOFF:\n                    st = OnOffType.OFF;\n                    break;\n                case JNA.CLibrary.TELLSTICK_DIM:\n                    BigDecimal dimValue = new BigDecimal(device.getStatevalue());\n                    if (dimValue.intValue() == 0) {\n                        st = OnOffType.OFF;\n                    } else if (dimValue.intValue() >= 255) {\n                        st = OnOffType.ON;\n                    } else {\n                        st = OnOffType.ON;\n                    }\n                    break;\n                default:\n                    logger.warn(\"Could not handle {} for {}\", device.getState(), device);\n            }\n        }\n        return st;\n    }\n\n    @Override\n    public BigDecimal calcDimValue(Device device) {\n        BigDecimal dimValue = new BigDecimal(0);\n        switch (((TellstickNetDevice) device).getState()) {\n            case JNA.CLibrary.TELLSTICK_TURNON:\n                dimValue = new BigDecimal(100);\n                break;\n            case JNA.CLibrary.TELLSTICK_TURNOFF:\n                break;\n            case JNA.CLibrary.TELLSTICK_DIM:\n                dimValue = new BigDecimal(((TellstickNetDevice) device).getStatevalue());\n                dimValue = dimValue.multiply(new BigDecimal(100));\n                dimValue = dimValue.divide(new BigDecimal(255), 0, BigDecimal.ROUND_HALF_UP);\n                break;\n            default:\n                logger.warn(\"Could not handle {} for {}\", (((TellstickNetDevice) device).getState()), device);\n        }\n        return dimValue;\n    }\n\n    public long getLastSend() {\n        return lastSend;\n    }\n\n    public void setLastSend(long currentTimeMillis) {\n        lastSend = currentTimeMillis;\n    }\n\n    @Override\n    public void onRequest(TellstickSensorEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    @Override\n    public void onRequest(TellstickDeviceEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    <T> T callRestMethod(String uri, Class<T> response) throws TelldusLiveException {\n        T resultObj = null;\n        try {\n            for (int i = 0; i < MAX_RETRIES; i++) {\n                try {\n                    resultObj = innerCallRest(uri, response);\n                    break;\n                } catch (TimeoutException e) {\n                    logger.warn(\"TimeoutException error in get\", e);\n                } catch (InterruptedException e) {\n                    logger.warn(\"InterruptedException error in get\", e);\n                }\n            }\n        } catch (JAXBException e) {\n            logger.warn(\"Encoding error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (XMLStreamException e) {\n            logger.warn(\"Communication error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (ExecutionException e) {\n            logger.warn(\"ExecutionException error in get\", e);\n            throw new TelldusLiveException(e);\n        }\n        return resultObj;\n    }\n\n    private <T> T innerCallRest(String uri, Class<T> response) throws InterruptedException, ExecutionException,\n            TimeoutException, JAXBException, FactoryConfigurationError, XMLStreamException {\n        Future<Response> future = client.prepareGet(uri).execute();\n        Response resp = future.get(REQUEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        // TelldusLiveHandler.logger.info(\"Devices\" + resp.getResponseBody());\n        JAXBContext jc = JAXBContext.newInstance(response);\n        XMLInputFactory xif = XMLInputFactory.newInstance();\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        XMLStreamReader xsr = xif.createXMLStreamReader(resp.getResponseBodyAsStream());\n        // xsr = new PropertyRenamerDelegate(xsr);\n\n        @SuppressWarnings(\"unchecked\")\n        T obj = (T) jc.createUnmarshaller().unmarshal(xsr);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Request [{}] Response:{}\", uri, resp.getResponseBody());\n        }\n        return obj;\n    }\n\n    private void logResponse(String uri, Exception e) {\n        if (e != null) {\n            logger.warn(\"Request [{}] Failure:{}\", uri, e.getMessage());\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.vitotronic.internal.handler;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport org.eclipse.smarthome.core.thing.Bridge;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.openhab.binding.vitotronic.internal.VitotronicBindingConfiguration;\nimport org.openhab.binding.vitotronic.internal.discovery.VitotronicDiscoveryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link VitotronicBridgeHandler} class handles the connection to the\n * optolink adapter.\n *\n * @author Stefan Andres - Initial contribution\n */\npublic class VitotronicBridgeHandler extends BaseBridgeHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(VitotronicBridgeHandler.class);\n\n    private String ipAddress;\n    private int port;\n    private int refreshInterval = 300;\n    private Socket socket;\n    private PrintStream out;\n    private InputStream inStream;\n    private boolean isConnect = false;\n    private boolean isDiscover = false;\n\n    public VitotronicBridgeHandler(Bridge bridge) {\n        super(bridge);\n    }\n\n    @Override\n    public void updateStatus(ThingStatus status) {\n        super.updateStatus(status);\n        updateThingHandlersStatus(status);\n    }\n\n    public void updateStatus() {\n        if (isConnect) {\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            updateStatus(ThingStatus.OFFLINE);\n        }\n    }\n\n    // Managing Thing Discovery Service\n\n    private VitotronicDiscoveryService discoveryService = null;\n\n    public void registerDiscoveryService(VitotronicDiscoveryService discoveryService) {\n        if (discoveryService == null) {\n            throw new IllegalArgumentException(\"It's not allowed to pass a null ThingDiscoveryListener.\");\n        } else {\n            this.discoveryService = discoveryService;\n            logger.trace(\"register Discovery Service\");\n        }\n    }\n\n    public void unregisterDiscoveryService() {\n        discoveryService = null;\n        logger.trace(\"unregister Discovery Service\");\n    }\n\n    // Handles Thing discovery\n\n    private void createThing(String thingType, String thingID) {\n        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n        if (discoveryService != null) {\n            discoveryService.addVitotronicThing(thingType, thingID);\n        }\n    }\n\n    // Managing ThingHandler\n\n    private Map<String, VitotronicThingHandler> thingHandlerMap = new HashMap<>();\n\n    public void registerVitotronicThingListener(VitotronicThingHandler thingHandler) {\n        if (thingHandler == null) {\n            throw new IllegalArgumentException(\"It's not allowed to pass a null ThingHandler.\");\n        } else {\n            String thingID = thingHandler.getThing().getUID().getId();\n            if (thingHandlerMap.get(thingID) == null) {\n                thingHandlerMap.put(thingID, thingHandler);\n                logger.trace(\"register thingHandler for thing: {}\", thingID);\n                updateThingHandlerStatus(thingHandler, this.getStatus());\n                sendSocketData(\"get \" + thingID);\n            } else {\n                logger.trace(\"thingHandler for thing: '{}' already registered\", thingID);\n            }\n        }\n    }\n\n    public void unregisterThingListener(VitotronicThingHandler thingHandler) {\n        if (thingHandler != null) {\n            String thingID = thingHandler.getThing().getUID().getId();\n            if (thingHandlerMap.remove(thingID) == null) {\n                logger.trace(\"thingHandler for thing: {} not registered\", thingID);\n            }\n        }\n    }\n\n    private void updateThingHandlerStatus(VitotronicThingHandler thingHandler, ThingStatus status) {\n        thingHandler.updateStatus(status);\n    }\n\n    private void updateThingHandlersStatus(ThingStatus status) {\n        for (Map.Entry<String, VitotronicThingHandler> entry : thingHandlerMap.entrySet()) {\n            updateThingHandlerStatus(entry.getValue(), status);\n        }\n    }\n\n    // Background Runables\n\n    private ScheduledFuture<?> pollingJob;\n\n    private Runnable pollingRunnable = () -> {\n        logger.trace(\"Polling job called\");\n        if (!isConnect) {\n            startSocketReceiver();\n            try {\n                Thread.sleep(5000); // Wait for connection .\n            } catch (InterruptedException e) {\n            }\n        }\n        if (isConnect) {\n            scanThings();\n            refreshData();\n        }\n    };\n\n    private synchronized void startAutomaticRefresh() {\n        if (pollingJob == null || pollingJob.isCancelled()) {\n            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private void refreshData() {\n        logger.trace(\"Job: refresh Data...\");\n        for (Map.Entry<String, VitotronicThingHandler> entry : thingHandlerMap.entrySet()) {\n            String channelList = entry.getValue().getActiveChannelListAsString();\n            String thingId = entry.getValue().getThing().getUID().getId();\n            if (isConnect && (channelList.length() > 0)) {\n                logger.trace(\"Get Data for '{}'\", thingId);\n                sendSocketData(\"get \" + thingId + \" \" + channelList);\n            }\n        }\n    }\n\n    // Methods for ThingHandler\n\n    public void scanThings() {\n        logger.trace(\"Job: Discover Things...\");\n        if (!isDiscover) {\n            sendSocketData(\"list\");\n            isDiscover = true;\n        }\n    }\n\n    public ThingStatus getStatus() {\n        return getThing().getStatus();\n    }\n\n    public void updateChannel(String thingId, String channelId, String value) {\n        sendSocketData(\"set \" + thingId + \":\" + channelId + \" \" + value);\n    }\n\n    // internal Methods\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        // No channels - nothing to do\n    }\n\n    @Override\n    public void initialize() {\n        logger.debug(\"Initializing Vitotronic bridge handler {}\", getThing().getUID());\n        updateStatus();\n        VitotronicBindingConfiguration configuration = getConfigAs(VitotronicBindingConfiguration.class);\n        ipAddress = configuration.ipAddress;\n        port = configuration.port;\n        refreshInterval = configuration.refreshInterval;\n\n        isDiscover = false;\n        startAutomaticRefresh();\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"Dispose Vitotronic bridge handler {}\", getThing().getUID());\n\n        if (pollingJob != null && !pollingJob.isCancelled()) {\n            pollingJob.cancel(true);\n            pollingJob = null;\n        }\n    }\n\n    // Connection to adapter\n\n    private void openSocket() {\n        logger.trace(\"Try to open connection to Optolink Adapter {}:{}\", ipAddress, port);\n\n        try {\n            socket = new Socket(ipAddress, port);\n            out = new PrintStream(socket.getOutputStream());\n            inStream = socket.getInputStream();\n        } catch (UnknownHostException e) {\n            logger.error(\"Can't find Host: {}:{}\", ipAddress, port);\n        } catch (IOException e) {\n            logger.debug(\"Error in communication to Host: {}:{}\", ipAddress, port);\n            logger.trace(\"Diagnostic: \", e);\n        }\n    }\n\n    Runnable socketReceiverRunnable = () -> {\n        logger.trace(\"Start Background Thread for recieving data from adapter\");\n        try {\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setContentHandler(new XmlHandler());\n            logger.trace(\"Start Parser for optolink adapter\");\n            xmlReader.parse(new InputSource(inStream));\n\n        } catch (IOException e) {\n            logger.trace(\"Connection error from optolink adapter\");\n        } catch (SAXException e) {\n            logger.trace(\"XML Parser Error\");\n\n        }\n        updateStatus(ThingStatus.OFFLINE);\n        isConnect = false;\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (Exception e) {\n        }\n        logger.trace(\"Connection to optolink adapter is died ... wait for restart\");\n    };\n\n    private void startSocketReceiver() {\n        if (!isConnect) {\n            openSocket();\n\n            Thread thread = new Thread(socketReceiverRunnable);\n            thread.setName(\"VitotronicSocketThread\");\n            thread.start();\n        }\n    }\n\n    private void sendSocketData(String message) {\n        try {\n            logger.trace(\"Send Message {}\", message);\n            if (isConnect) {\n                if (message.matches(\"^set.*REFRESH$\")) {\n                    String[] msgParts = message.split(\" \");\n                    String[] thingChannel = msgParts[1].split(\":\");\n                    message = \"get \" + thingChannel[0] + \" \" + thingChannel[1];\n                }\n                out.write((message + \"\\n\").getBytes());\n            }\n        } catch (IOException e) {\n            logger.error(\"Error in sending data to optolink adapter\");\n            logger.trace(\"Diagnostic: \", e);\n        }\n    }\n\n    // Handles all data what received from optolink adapter\n\n    public class XmlHandler implements ContentHandler {\n        boolean isData;\n        boolean isDefine;\n        boolean isThing;\n        boolean isChannel;\n        boolean isDescription;\n        String thingID;\n        String thingType;\n        String channelID;\n        String description;\n        VitotronicThingHandler thingHandler;\n        Set<String> channels = new HashSet<>();\n\n        @Override\n        public void startElement(String uri, String localName, String pName, Attributes attr) throws SAXException {\n            try {\n                switch (localName) {\n                    case \"optolink\":\n                        isConnect = true;\n                        updateStatus(ThingStatus.ONLINE);\n                        break;\n                    case \"data\":\n                        isDefine = false;\n                        break;\n                    case \"define\":\n                        isDefine = true;\n                        break;\n                    case \"description\":\n                        isDescription = true;\n                        break;\n                    case \"thing\":\n                        isThing = true;\n                        if (isDefine) {\n                            thingType = attr.getValue(\"type\");\n                        }\n                        thingID = attr.getValue(\"id\");\n                        channels.clear();\n                        thingHandler = thingHandlerMap.get(thingID);\n                        break;\n                    case \"channel\":\n                        isChannel = true;\n                        channelID = attr.getValue(\"id\");\n                        if (isDefine) {\n                            channels.add(channelID);\n                        } else { // is data\n                            if (thingHandler != null) {\n                                logger.trace(\"Set Data for channel '{}' value '{}'\", channelID, attr.getValue(\"value\"));\n                                thingHandler.setChannelValue(channelID, attr.getValue(\"value\"));\n                            }\n                        }\n                        break;\n                }\n            } catch (Exception e) {\n                logger.error(\"Error in parsing data\");\n                logger.trace(\"Diagnostic: \", e);\n            }\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (isDescription) {\n                description = new String(ch, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            switch (localName) {\n                case \"description\":\n                    isDescription = false;\n                    break;\n                case \"thing\":\n                    if (isDefine) {\n                        createThing(thingType, thingID);\n                    }\n                    isThing = false;\n                    thingHandler = null;\n                    break;\n                case \"channel\":\n                    isChannel = false;\n                    break;\n            }\n        }\n\n        // Unused function of xmlReader\n        @Override\n        public void endDocument() throws SAXException {\n        }\n\n        @Override\n        public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXException {\n        }\n\n        @Override\n        public void processingInstruction(String arg0, String arg1) throws SAXException {\n        }\n\n        @Override\n        public void setDocumentLocator(Locator arg0) {\n        }\n\n        @Override\n        public void skippedEntity(String arg0) throws SAXException {\n        }\n\n        @Override\n        public void startDocument() throws SAXException {\n        }\n\n        @Override\n        public void startPrefixMapping(String arg0, String arg1) throws SAXException {\n        }\n\n        @Override\n        public void endPrefixMapping(String prefix) throws SAXException {\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.discovery;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\nimport org.eclipse.smarthome.config.discovery.DiscoveryResult;\nimport org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.thing.ThingUID;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.handler.WemoBridgeHandler;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoLinkDiscoveryService} is responsible for discovering new and\n * removed WeMo devices connected to the WeMo Link Bridge.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n *\n */\npublic class WemoLinkDiscoveryService extends AbstractDiscoveryService implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoLinkDiscoveryService.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_MZ100);\n\n    public static final String NORMALIZE_ID_REGEX = \"[^a-zA-Z0-9_]\";\n\n    /**\n     * Maximum time to search for devices in seconds.\n     */\n    private static final int SEARCH_TIME = 20;\n\n    /**\n     * Scan interval for scanning job in seconds.\n     */\n    private static final int SCAN_INTERVAL = 120;\n\n    /**\n     * The handler for WeMo Link bridge\n     */\n    private final WemoBridgeHandler wemoBridgeHandler;\n\n    /**\n     * Job which will do the background scanning\n     */\n    private final WemoLinkScan scanningRunnable;\n\n    /**\n     * Schedule for scanning\n     */\n    private ScheduledFuture<?> scanningJob;\n\n    /**\n     * The Upnp service\n     */\n    private UpnpIOService service;\n\n    private final WemoHttpCall wemoHttpCaller;\n\n    public WemoLinkDiscoveryService(WemoBridgeHandler wemoBridgeHandler, UpnpIOService upnpIOService,\n            WemoHttpCall wemoHttpCaller) {\n        super(SEARCH_TIME);\n        this.wemoBridgeHandler = wemoBridgeHandler;\n\n        this.wemoHttpCaller = wemoHttpCaller;\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n\n        this.scanningRunnable = new WemoLinkScan();\n        if (wemoBridgeHandler == null) {\n            logger.warn(\"no bridge handler for scan given\");\n        }\n        this.activate(null);\n    }\n\n    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n        return SUPPORTED_THING_TYPES;\n    }\n\n    @Override\n    public void startScan() {\n        logger.trace(\"Starting WeMoEndDevice discovery on WeMo Link {}\", wemoBridgeHandler.getThing().getUID());\n        try {\n            String devUDN = \"uuid:\" + wemoBridgeHandler.getThing().getConfiguration().get(UDN).toString();\n            logger.trace(\"devUDN = '{}'\", devUDN);\n\n            String soapHeader = \"\\\"urn:Belkin:service:bridge:1#GetEndDevices\\\"\";\n            String content = \"<?xml version=\\\"1.0\\\"?>\"\n                    + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                    + \"<s:Body>\" + \"<u:GetEndDevices xmlns:u=\\\"urn:Belkin:service:bridge:1\\\">\" + \"<DevUDN>\" + devUDN\n                    + \"</DevUDN><ReqListType>PAIRED_LIST</ReqListType>\" + \"</u:GetEndDevices>\" + \"</s:Body>\"\n                    + \"</s:Envelope>\";\n\n            URL descriptorURL = service.getDescriptorURL(this);\n\n            if (descriptorURL != null) {\n                String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n                String wemoURL = deviceURL + \"/upnp/control/bridge1\";\n\n                String endDeviceRequest = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n\n                if (endDeviceRequest != null) {\n                    logger.trace(\"endDeviceRequest answered '{}'\", endDeviceRequest);\n\n                    try {\n                        String stringParser = StringUtils.substringBetween(endDeviceRequest, \"<DeviceLists>\",\n                                \"</DeviceLists>\");\n\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        // check if there are already paired devices with WeMo Link\n                        if (\"0\".equals(stringParser)) {\n                            logger.debug(\"There are no devices connected with WeMo Link. Exit discovery\");\n                            return;\n                        }\n\n                        // Build parser for received <DeviceList>\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        // see\n                        // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n                        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                        dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                        dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n                        dbf.setXIncludeAware(false);\n                        dbf.setExpandEntityReferences(false);\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"DeviceInfo\");\n\n                        // iterate the devices\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"DeviceIndex\");\n                            Element line = (Element) deviceIndex.item(0);\n                            logger.trace(\"DeviceIndex: {}\", getCharacterDataFromElement(line));\n\n                            NodeList deviceID = element.getElementsByTagName(\"DeviceID\");\n                            line = (Element) deviceID.item(0);\n                            String endDeviceID = getCharacterDataFromElement(line);\n                            logger.trace(\"DeviceID: {}\", endDeviceID);\n\n                            NodeList friendlyName = element.getElementsByTagName(\"FriendlyName\");\n                            line = (Element) friendlyName.item(0);\n                            String endDeviceName = getCharacterDataFromElement(line);\n                            logger.trace(\"FriendlyName: {}\", endDeviceName);\n\n                            NodeList vendor = element.getElementsByTagName(\"Manufacturer\");\n                            line = (Element) vendor.item(0);\n                            String endDeviceVendor = getCharacterDataFromElement(line);\n                            logger.trace(\"Manufacturer: {}\", endDeviceVendor);\n\n                            NodeList model = element.getElementsByTagName(\"ModelCode\");\n                            line = (Element) model.item(0);\n                            String endDeviceModelID = getCharacterDataFromElement(line);\n                            endDeviceModelID = endDeviceModelID.replaceAll(NORMALIZE_ID_REGEX, \"_\");\n\n                            logger.trace(\"ModelCode: {}\", endDeviceModelID);\n\n                            if (SUPPORTED_THING_TYPES.contains(new ThingTypeUID(BINDING_ID, endDeviceModelID))) {\n                                logger.debug(\"Discovered a WeMo LED Light thing with ID '{}'\", endDeviceID);\n\n                                ThingUID bridgeUID = wemoBridgeHandler.getThing().getUID();\n                                ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, endDeviceModelID);\n\n                                if (thingTypeUID.equals(THING_TYPE_MZ100)) {\n                                    String thingLightId = endDeviceID;\n                                    ThingUID thingUID = new ThingUID(thingTypeUID, bridgeUID, thingLightId);\n\n                                    Map<String, Object> properties = new HashMap<>(1);\n                                    properties.put(DEVICE_ID, endDeviceID);\n\n                                    DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID)\n                                            .withProperties(properties)\n                                            .withBridge(wemoBridgeHandler.getThing().getUID()).withLabel(endDeviceName)\n                                            .build();\n\n                                    thingDiscovered(discoveryResult);\n                                }\n                            } else {\n                                logger.debug(\"Discovered an unsupported device :\");\n                                logger.debug(\"DeviceIndex : {}\", getCharacterDataFromElement(line));\n                                logger.debug(\"DeviceID    : {}\", endDeviceID);\n                                logger.debug(\"FriendlyName: {}\", endDeviceName);\n                                logger.debug(\"Manufacturer: {}\", endDeviceVendor);\n                                logger.debug(\"ModelCode   : {}\", endDeviceModelID);\n                            }\n\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse endDevices for bridge '{}'\",\n                                wemoBridgeHandler.getThing().getUID(), e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get endDevices for bridge '{}'\", wemoBridgeHandler.getThing().getUID(), e);\n        }\n    }\n\n    @Override\n    protected void startBackgroundDiscovery() {\n        logger.trace(\"Start WeMo device background discovery\");\n\n        if (scanningJob == null || scanningJob.isCancelled()) {\n            this.scanningJob = scheduler.scheduleWithFixedDelay(this.scanningRunnable,\n                    LINK_DISCOVERY_SERVICE_INITIAL_DELAY, SCAN_INTERVAL, TimeUnit.SECONDS);\n        } else {\n            logger.trace(\"scanningJob active\");\n        }\n    }\n\n    @Override\n    protected void stopBackgroundDiscovery() {\n        logger.debug(\"Stop WeMo device background discovery\");\n\n        if (scanningJob != null && !scanningJob.isCancelled()) {\n            scanningJob.cancel(true);\n            scanningJob = null;\n        }\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.wemoBridgeHandler.getThing().getConfiguration().get(UDN);\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    public class WemoLinkScan implements Runnable {\n        @Override\n        public void run() {\n            startScan();\n        }\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.DateTimeType;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoCoffeeHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n * @author Erdoan Hadzhiyusein - Adapted the class to work with the new DateTimeType\n */\n\npublic class WemoCoffeeHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoCoffeeHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_COFFEE);\n\n    private Map<String, Boolean> subscriptionState = new HashMap<>();\n\n    protected static final int SUBSCRIPTION_DURATION = 600;\n\n    private UpnpIOService service;\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private final int REFRESH_INTERVAL = 60;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                if (!isUpnpDeviceRegistered()) {\n                    logger.debug(\"WeMo UPnP device {} not yet registered\", getUDN());\n                }\n\n                updateWemoState();\n                onSubscription();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n            }\n        }\n    };\n\n    public WemoCoffeeHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemoHttpcaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemoHttpcaller;\n\n        logger.debug(\"Creating a WemoCoffeeHandler V0.4 for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoCoffeeHandler for UDN '{}'\", configuration.get(\"udn\"));\n            onSubscription();\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoCoffeeHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WeMoCoffeeHandler disposed.\");\n\n        removeSubscription();\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        if (command instanceof RefreshType) {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n            }\n        } else if (channelUID.getId().equals(CHANNEL_STATE)) {\n            if (command instanceof OnOffType) {\n                if (command.equals(OnOffType.ON)) {\n                    try {\n                        String soapHeader = \"\\\"urn:Belkin:service:deviceevent:1#SetAttributes\\\"\";\n\n                        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                                + \"<s:Body>\" + \"<u:SetAttributes xmlns:u=\\\"urn:Belkin:service:deviceevent:1\\\">\"\n                                + \"<attributeList>&lt;attribute&gt;&lt;name&gt;Brewed&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;\"\n                                + \"&lt;attribute&gt;&lt;name&gt;LastCleaned&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;\"\n                                + \"&lt;name&gt;ModeTime&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;Brewing&lt;/name&gt;\"\n                                + \"&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;TimeRemaining&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;\"\n                                + \"&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;WaterLevelReached&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;\"\n                                + \"attribute&gt;&lt;name&gt;Mode&lt;/name&gt;&lt;value&gt;4&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;CleanAdvise&lt;/name&gt;\"\n                                + \"&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;&lt;attribute&gt;&lt;name&gt;FilterAdvise&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;\"\n                                + \"&lt;attribute&gt;&lt;name&gt;Cleaning&lt;/name&gt;&lt;value&gt;NULL&lt;/value&gt;&lt;/attribute&gt;</attributeList>\"\n                                + \"</u:SetAttributes>\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n                        String wemoURL = getWemoURL(\"deviceevent\");\n\n                        if (wemoURL != null) {\n                            String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                            if (wemoCallResponse != null) {\n                                updateState(CHANNEL_STATE, OnOffType.ON);\n                                State newMode = new StringType(\"Brewing\");\n                                updateState(CHANNEL_COFFEEMODE, newMode);\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to send command '{}' for device '{}': {}\", command, getThing().getUID(),\n                                e.getMessage());\n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n                    }\n                }\n                // if command.equals(OnOffType.OFF) we do nothing because WeMo Coffee Maker cannot be switched off\n                // remotely\n                updateStatus(ThingStatus.ONLINE);\n            }\n        }\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n        logger.debug(\"WeMo {}: Subscription to service {} {}\", getUDN(), service, succeeded ? \"succeeded\" : \"failed\");\n        subscriptionState.put(service, succeeded);\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n        // We can subscribe to GENA events, but there is no usefull response right now.\n    }\n\n    private synchronized void onSubscription() {\n        if (service.isRegistered(this)) {\n            logger.debug(\"Checking WeMo GENA subscription for '{}'\", this);\n\n            String subscription = \"deviceevent1\";\n            if ((subscriptionState.get(subscription) == null) || !subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"Setting up GENA subscription {}: Subscribing to service {}...\", getUDN(), subscription);\n                service.addSubscription(this, subscription, SUBSCRIPTION_DURATION);\n                subscriptionState.put(subscription, true);\n            }\n        } else {\n            logger.debug(\"Setting up WeMo GENA subscription for '{}' FAILED - service.isRegistered(this) is FALSE\",\n                    this);\n        }\n    }\n\n    private synchronized void removeSubscription() {\n        logger.debug(\"Removing WeMo GENA subscription for '{}'\", this);\n\n        if (service.isRegistered(this)) {\n            String subscription = \"deviceevent1\";\n            if ((subscriptionState.get(subscription) != null) && subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"WeMo {}: Unsubscribing from service {}...\", getUDN(), subscription);\n                service.removeSubscription(this, subscription);\n            }\n\n            subscriptionState = new HashMap<>();\n            service.unregisterParticipant(this);\n        }\n    }\n\n    private synchronized void onUpdate() {\n        if (refreshJob == null || refreshJob.isCancelled()) {\n            Configuration config = getThing().getConfiguration();\n            int refreshInterval = REFRESH_INTERVAL;\n            Object refreshConfig = config.get(\"pollingInterval\");\n            if (refreshConfig != null) {\n                refreshInterval = ((BigDecimal) refreshConfig).intValue();\n                logger.debug(\"Setting WemoCoffeeHandler refreshInterval to '{}' seconds\", refreshInterval);\n            }\n            refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isUpnpDeviceRegistered() {\n        return service.isRegistered(this);\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo CoffeeMaker.\n     */\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    try {\n                        String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                                \"</attributeList>\");\n\n                        // Due to Belkins bad response formatting, we need to run this twice.\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        logger.trace(\"CoffeeMaker response '{}' for device '{}' received\", stringParser,\n                                getThing().getUID());\n\n                        stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        // see\n                        // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n                        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                        dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                        dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n                        dbf.setXIncludeAware(false);\n                        dbf.setExpandEntityReferences(false);\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                        // iterate the attributes\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                            Element line = (Element) deviceIndex.item(0);\n                            String attributeName = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeName: {}\", attributeName);\n\n                            NodeList deviceID = element.getElementsByTagName(\"value\");\n                            line = (Element) deviceID.item(0);\n                            String attributeValue = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeValue: {}\", attributeValue);\n\n                            switch (attributeName) {\n                                case \"Mode\":\n                                    State newMode = new StringType(\"Brewing\");\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            updateState(CHANNEL_STATE, OnOffType.ON);\n                                            newMode = new StringType(\"Refill\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"1\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"PlaceCarafe\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"2\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"RefillWater\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"3\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"Ready\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"4\":\n                                            updateState(CHANNEL_STATE, OnOffType.ON);\n                                            newMode = new StringType(\"Brewing\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"5\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"Brewed\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"6\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"CleaningBrewing\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"7\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"CleaningSoaking\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                        case \"8\":\n                                            updateState(CHANNEL_STATE, OnOffType.OFF);\n                                            newMode = new StringType(\"BrewFailCarafeRemoved\");\n                                            updateState(CHANNEL_COFFEEMODE, newMode);\n                                            break;\n                                    }\n                                    break;\n                                case \"ModeTime\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_MODETIME, newAttributeValue);\n                                    }\n                                    break;\n                                case \"TimeRemaining\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_TIMEREMAINING, newAttributeValue);\n                                    }\n                                    break;\n                                case \"WaterLevelReached\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = new DecimalType(attributeValue);\n                                        updateState(CHANNEL_WATERLEVELREACHED, newAttributeValue);\n                                    }\n                                    break;\n                                case \"CleanAdvise\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = attributeValue.equals(\"0\") ? OnOffType.OFF\n                                                : OnOffType.ON;\n                                        updateState(CHANNEL_CLEANADVISE, newAttributeValue);\n                                    }\n                                    break;\n                                case \"FilterAdvise\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = attributeValue.equals(\"0\") ? OnOffType.OFF\n                                                : OnOffType.ON;\n                                        updateState(CHANNEL_FILTERADVISE, newAttributeValue);\n                                    }\n                                    break;\n                                case \"Brewed\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = getDateTimeState(attributeValue);\n                                        if (newAttributeValue != null) {\n                                            updateState(CHANNEL_BREWED, newAttributeValue);\n                                        }\n                                    }\n                                    break;\n                                case \"LastCleaned\":\n                                    if (attributeValue != null) {\n                                        State newAttributeValue = getDateTimeState(attributeValue);\n                                        if (newAttributeValue != null) {\n                                            updateState(CHANNEL_LASTCLEANED, newAttributeValue);\n                                        }\n                                    }\n                                    break;\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse attributeList for WeMo CoffeMaker '{}'\", this.getThing().getUID(),\n                                e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get attributes for device '{}'\", getThing().getUID(), e);\n        }\n    }\n\n    @SuppressWarnings(\"null\")\n    public State getDateTimeState(String attributeValue) {\n        if (attributeValue != null) {\n            long value = 0;\n            try {\n                value = Long.parseLong(attributeValue) * 1000; // convert s to ms\n            } catch (NumberFormatException e) {\n                logger.error(\"Unable to parse attributeValue '{}' for device '{}'; expected long\", attributeValue,\n                        getThing().getUID());\n                return null;\n            }\n            ZonedDateTime zoned = ZonedDateTime.ofInstant(Instant.ofEpochMilli(value),\n                    TimeZone.getDefault().toZoneId());\n            State dateTimeState = new DateTimeType(zoned);\n            if (dateTimeState != null) {\n                logger.trace(\"New attribute brewed '{}' received\", dateTimeState);\n                return dateTimeState;\n            }\n        }\n        return null;\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link WemoHolmesHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution;\n */\n\npublic class WemoHolmesHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoHolmesHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_PURIFIER);\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private static final int DEFAULT_REFRESH_INTERVAL_SECONDS = 120;\n    private static final int FILTER_LIFE_DAYS = 330;\n    private static final int FILTER_LIFE_MINS = FILTER_LIFE_DAYS * 24 * 60;\n    private final Map<String, Boolean> subscriptionState = new HashMap<>();\n    private final Map<String, String> stateMap = Collections.synchronizedMap(new HashMap<>());\n\n    private UpnpIOService service;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = () -> {\n        if (!isUpnpDeviceRegistered()) {\n            logger.debug(\"WeMo UPnP device {} not yet registered\", getUDN());\n        } else {\n            updateWemoState();\n            onSubscription();\n        }\n    };\n\n    public WemoHolmesHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemohttpCaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemohttpCaller;\n\n        logger.debug(\"Creating a WemoHolmesHandler for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoHolmesHandler for UDN '{}'\", configuration.get(\"udn\"));\n            service.registerParticipant(this);\n            onSubscription();\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoHolmesHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WemoHolmesHandler disposed.\");\n\n        removeSubscription();\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        String attribute = null;\n        String value = null;\n\n        if (command instanceof RefreshType) {\n            updateWemoState();\n        } else if (CHANNEL_PURIFIERMODE.equals(channelUID.getId())) {\n            attribute = \"Mode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"LOW\":\n                    value = \"1\";\n                    break;\n                case \"MED\":\n                    value = \"2\";\n                    break;\n                case \"HIGH\":\n                    value = \"3\";\n                    break;\n                case \"AUTO\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_IONIZER.equals(channelUID.getId())) {\n            attribute = \"Ionizer\";\n            if (OnOffType.ON.equals(command)) {\n                value = \"1\";\n            } else if (OnOffType.OFF.equals(command)) {\n                value = \"0\";\n            }\n        } else if (CHANNEL_HUMIDIFIERMODE.equals(channelUID.getId())) {\n            attribute = \"FanMode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"MIN\":\n                    value = \"1\";\n                    break;\n                case \"LOW\":\n                    value = \"2\";\n                    break;\n                case \"MED\":\n                    value = \"3\";\n                    break;\n                case \"HIGH\":\n                    value = \"4\";\n                    break;\n                case \"MAX\":\n                    value = \"5\";\n                    break;\n            }\n        } else if (CHANNEL_DESIREDHUMIDITY.equals(channelUID.getId())) {\n            attribute = \"DesiredHumidity\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"45\":\n                    value = \"0\";\n                    break;\n                case \"50\":\n                    value = \"1\";\n                    break;\n                case \"55\":\n                    value = \"2\";\n                    break;\n                case \"60\":\n                    value = \"3\";\n                    break;\n                case \"100\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_HEATERMODE.equals(channelUID.getId())) {\n            attribute = \"Mode\";\n            String commandString = command.toString();\n            switch (commandString) {\n                case \"OFF\":\n                    value = \"0\";\n                    break;\n                case \"FROSTPROTECT\":\n                    value = \"1\";\n                    break;\n                case \"HIGH\":\n                    value = \"2\";\n                    break;\n                case \"LOW\":\n                    value = \"3\";\n                    break;\n                case \"ECO\":\n                    value = \"4\";\n                    break;\n            }\n        } else if (CHANNEL_TARGETTEMP.equals(channelUID.getId())) {\n            attribute = \"SetTemperature\";\n            value = command.toString();\n        }\n        try {\n            String soapHeader = \"\\\"urn:Belkin:service:deviceevent:1#SetAttributes\\\"\";\n            String content = \"<?xml version=\\\"1.0\\\"?>\"\n                    + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                    + \"<s:Body>\" + \"<u:SetAttributes xmlns:u=\\\"urn:Belkin:service:deviceevent:1\\\">\"\n                    + \"<attributeList>&lt;attribute&gt;&lt;name&gt;\" + attribute + \"&lt;/name&gt;&lt;value&gt;\" + value\n                    + \"&lt;/value&gt;&lt;/attribute&gt;</attributeList>\" + \"</u:SetAttributes>\" + \"</s:Body>\"\n                    + \"</s:Envelope>\";\n            String wemoURL = getWemoURL(\"deviceevent\");\n\n            if (wemoURL != null) {\n                wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n            }\n        } catch (RuntimeException e) {\n            logger.debug(\"Failed to send command '{}' for device '{}':\", command, getThing().getUID(), e);\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n        }\n        updateStatus(ThingStatus.ONLINE);\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n        logger.debug(\"WeMo {}: Subscription to service {} {}\", getUDN(), service, succeeded ? \"succeeded\" : \"failed\");\n        subscriptionState.put(service, succeeded);\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n        logger.debug(\"Received pair '{}':'{}' (service '{}') for thing '{}'\", variable, value, service,\n                this.getThing().getUID());\n\n        updateStatus(ThingStatus.ONLINE);\n        this.stateMap.put(variable, value);\n    }\n\n    private synchronized void onSubscription() {\n        if (service.isRegistered(this)) {\n            logger.debug(\"Checking WeMo GENA subscription for '{}'\", this);\n\n            String subscription = \"basicevent1\";\n\n            if ((subscriptionState.get(subscription) == null) || !subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"Setting up GENA subscription {}: Subscribing to service {}...\", getUDN(), subscription);\n                service.addSubscription(this, subscription, SUBSCRIPTION_DURATION);\n                subscriptionState.put(subscription, true);\n            }\n\n        } else {\n            logger.debug(\"Setting up WeMo GENA subscription for '{}' FAILED - service.isRegistered(this) is FALSE\",\n                    this);\n        }\n    }\n\n    private synchronized void removeSubscription() {\n        logger.debug(\"Removing WeMo GENA subscription for '{}'\", this);\n\n        if (service.isRegistered(this)) {\n            String subscription = \"basicevent1\";\n\n            if ((subscriptionState.get(subscription) != null) && subscriptionState.get(subscription).booleanValue()) {\n                logger.debug(\"WeMo {}: Unsubscribing from service {}...\", getUDN(), subscription);\n                service.removeSubscription(this, subscription);\n            }\n\n            subscriptionState.remove(subscription);\n            service.unregisterParticipant(this);\n        }\n    }\n\n    private synchronized void onUpdate() {\n        if (refreshJob == null || refreshJob.isCancelled()) {\n            Configuration config = getThing().getConfiguration();\n            int refreshInterval = DEFAULT_REFRESH_INTERVAL_SECONDS;\n            Object refreshConfig = config.get(\"refresh\");\n            refreshInterval = refreshConfig == null ? DEFAULT_REFRESH_INTERVAL_SECONDS\n                    : ((BigDecimal) refreshConfig).intValue();\n            refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    private boolean isUpnpDeviceRegistered() {\n        return service.isRegistered(this);\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo device and\n     * calls {@link onValueReceived} to update the statemap and channels..\n     *\n     */\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    logger.trace(\"State response '{}' for device '{}' received\", wemoCallResponse, getThing().getUID());\n\n                    String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                            \"</attributeList>\");\n\n                    // Due to Belkins bad response formatting, we need to run this twice.\n                    stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                    stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                    logger.trace(\"AirPurifier response '{}' for device '{}' received\", stringParser,\n                            getThing().getUID());\n\n                    stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                    // see\n                    // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n                    dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                    dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                    dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n                    dbf.setXIncludeAware(false);\n                    dbf.setExpandEntityReferences(false);\n                    DocumentBuilder db = dbf.newDocumentBuilder();\n                    InputSource is = new InputSource();\n                    is.setCharacterStream(new StringReader(stringParser));\n\n                    Document doc = db.parse(is);\n                    NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                    // iterate the attributes\n                    for (int i = 0; i < nodes.getLength(); i++) {\n                        Element element = (Element) nodes.item(i);\n\n                        NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                        Element line = (Element) deviceIndex.item(0);\n                        String attributeName = getCharacterDataFromElement(line);\n                        logger.trace(\"attributeName: {}\", attributeName);\n\n                        NodeList deviceID = element.getElementsByTagName(\"value\");\n                        line = (Element) deviceID.item(0);\n                        String attributeValue = getCharacterDataFromElement(line);\n                        logger.trace(\"attributeValue: {}\", attributeValue);\n\n                        State newMode = new StringType();\n                        switch (attributeName) {\n                            case \"Mode\":\n                                if (\"purifier\".equals(getThing().getThingTypeUID().getId())) {\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            newMode = new StringType(\"OFF\");\n                                            break;\n                                        case \"1\":\n                                            newMode = new StringType(\"LOW\");\n                                            break;\n                                        case \"2\":\n                                            newMode = new StringType(\"MED\");\n                                            break;\n                                        case \"3\":\n                                            newMode = new StringType(\"HIGH\");\n                                            break;\n                                        case \"4\":\n                                            newMode = new StringType(\"AUTO\");\n                                            break;\n                                    }\n                                    updateState(CHANNEL_PURIFIERMODE, newMode);\n                                } else {\n                                    switch (attributeValue) {\n                                        case \"0\":\n                                            newMode = new StringType(\"OFF\");\n                                            break;\n                                        case \"1\":\n                                            newMode = new StringType(\"FROSTPROTECT\");\n                                            break;\n                                        case \"2\":\n                                            newMode = new StringType(\"HIGH\");\n                                            break;\n                                        case \"3\":\n                                            newMode = new StringType(\"LOW\");\n                                            break;\n                                        case \"4\":\n                                            newMode = new StringType(\"ECO\");\n                                            break;\n                                    }\n                                    updateState(CHANNEL_HEATERMODE, newMode);\n                                }\n                                break;\n                            case \"Ionizer\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_IONIZER, newMode);\n                                break;\n                            case \"AirQuality\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new StringType(\"POOR\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new StringType(\"MODERATE\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new StringType(\"GOOD\");\n                                        break;\n                                }\n                                updateState(CHANNEL_AIRQUALITY, newMode);\n                                break;\n                            case \"FilterLife\":\n                                int filterLife = Integer.valueOf(attributeValue);\n                                if (\"purifier\".equals(getThing().getThingTypeUID().getId())) {\n                                    filterLife = Math.round((filterLife / FILTER_LIFE_MINS) * 100);\n                                } else {\n                                    filterLife = Math.round((filterLife / 60480) * 100);\n                                }\n                                updateState(CHANNEL_FILTERLIFE, new PercentType(String.valueOf(filterLife)));\n                                break;\n                            case \"ExpiredFilterTime\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_EXPIREDFILTERTIME, newMode);\n                                break;\n                            case \"FilterPresent\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = OnOffType.OFF;\n                                        break;\n                                    case \"1\":\n                                        newMode = OnOffType.ON;\n                                        break;\n                                }\n                                updateState(CHANNEL_FILTERPRESENT, newMode);\n                                break;\n                            case \"FANMode\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new StringType(\"OFF\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new StringType(\"LOW\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new StringType(\"MED\");\n                                        break;\n                                    case \"3\":\n                                        newMode = new StringType(\"HIGH\");\n                                        break;\n                                    case \"4\":\n                                        newMode = new StringType(\"AUTO\");\n                                        break;\n                                }\n                                updateState(CHANNEL_PURIFIERMODE, newMode);\n                                break;\n                            case \"DesiredHumidity\":\n                                switch (attributeValue) {\n                                    case \"0\":\n                                        newMode = new PercentType(\"45\");\n                                        break;\n                                    case \"1\":\n                                        newMode = new PercentType(\"50\");\n                                        break;\n                                    case \"2\":\n                                        newMode = new PercentType(\"55\");\n                                        break;\n                                    case \"3\":\n                                        newMode = new PercentType(\"60\");\n                                        break;\n                                    case \"4\":\n                                        newMode = new PercentType(\"100\");\n                                        break;\n                                }\n                                updateState(CHANNEL_DESIREDHUMIDITY, newMode);\n                                break;\n                            case \"CurrentHumidity\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_CURRENTHUMIDITY, newMode);\n                                break;\n                            case \"Temperature\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_CURRENTTEMP, newMode);\n                                break;\n                            case \"SetTemperature\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_TARGETTEMP, newMode);\n                                break;\n                            case \"AutoOffTime\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_AUTOOFFTIME, newMode);\n                                break;\n                            case \"TimeRemaining\":\n                                newMode = new StringType(attributeValue);\n                                updateState(CHANNEL_HEATINGREMAINING, newMode);\n                                break;\n                        }\n                    }\n                }\n            }\n        } catch (RuntimeException | ParserConfigurationException | SAXException | IOException e) {\n            logger.debug(\"Failed to get actual state for device '{}':\", getThing().getUID(), e);\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n        }\n        updateStatus(ThingStatus.ONLINE);\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.wemo.internal.handler;\n\nimport static org.openhab.binding.wemo.internal.WemoBindingConstants.*;\n\nimport java.io.StringReader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.smarthome.config.core.Configuration;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.ThingTypeUID;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.wemo.internal.http.WemoHttpCall;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * The {@link WemoMakerHandler} is responsible for handling commands, which are\n * sent to one of the channels and to update their states.\n *\n * @author Hans-J\u00f6rg Merk - Initial contribution\n */\n\npublic class WemoMakerHandler extends AbstractWemoHandler implements UpnpIOParticipant {\n\n    private final Logger logger = LoggerFactory.getLogger(WemoMakerHandler.class);\n\n    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_MAKER);\n\n    private UpnpIOService service;\n\n    /**\n     * The default refresh interval in Seconds.\n     */\n    private final int DEFAULT_REFRESH_INTERVAL = 15;\n\n    private ScheduledFuture<?> refreshJob;\n\n    private final Runnable refreshRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n            }\n        }\n    };\n\n    public WemoMakerHandler(Thing thing, UpnpIOService upnpIOService, WemoHttpCall wemoHttpcaller) {\n        super(thing);\n\n        this.wemoHttpCaller = wemoHttpcaller;\n\n        logger.debug(\"Creating a WemoMakerHandler for thing '{}'\", getThing().getUID());\n\n        if (upnpIOService != null) {\n            this.service = upnpIOService;\n        } else {\n            logger.debug(\"upnpIOService not set.\");\n        }\n    }\n\n    @Override\n    public void initialize() {\n        Configuration configuration = getConfig();\n\n        if (configuration.get(\"udn\") != null) {\n            logger.debug(\"Initializing WemoMakerHandler for UDN '{}'\", configuration.get(\"udn\"));\n            onUpdate();\n            updateStatus(ThingStatus.ONLINE);\n        } else {\n            logger.debug(\"Cannot initalize WemoMakerHandler. UDN not set.\");\n        }\n    }\n\n    @Override\n    public void dispose() {\n        logger.debug(\"WeMoMakerHandler disposed.\");\n\n        if (refreshJob != null && !refreshJob.isCancelled()) {\n            refreshJob.cancel(true);\n            refreshJob = null;\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.trace(\"Command '{}' received for channel '{}'\", command, channelUID);\n\n        if (command instanceof RefreshType) {\n            try {\n                updateWemoState();\n            } catch (Exception e) {\n                logger.debug(\"Exception during poll\", e);\n            }\n        } else if (channelUID.getId().equals(CHANNEL_RELAY)) {\n            if (command instanceof OnOffType) {\n                try {\n                    String binaryState = null;\n\n                    if (command.equals(OnOffType.ON)) {\n                        binaryState = \"1\";\n                    } else if (command.equals(OnOffType.OFF)) {\n                        binaryState = \"0\";\n                    }\n\n                    String soapHeader = \"\\\"urn:Belkin:service:basicevent:1#SetBinaryState\\\"\";\n\n                    String content = \"<?xml version=\\\"1.0\\\"?>\"\n                            + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                            + \"<s:Body>\" + \"<u:SetBinaryState xmlns:u=\\\"urn:Belkin:service:basicevent:1\\\">\"\n                            + \"<BinaryState>\" + binaryState + \"</BinaryState>\" + \"</u:SetBinaryState>\" + \"</s:Body>\"\n                            + \"</s:Envelope>\";\n\n                    String wemoURL = getWemoURL(\"basicevent\");\n\n                    if (wemoURL != null) {\n                        @SuppressWarnings(\"unused\")\n                        String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                    }\n                } catch (Exception e) {\n                    logger.error(\"Failed to send command '{}' for device '{}' \", command, getThing().getUID(), e);\n                }\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private synchronized void onSubscription() {\n    }\n\n    @SuppressWarnings(\"unused\")\n    private synchronized void removeSubscription() {\n    }\n\n    private synchronized void onUpdate() {\n        if (service.isRegistered(this)) {\n            if (refreshJob == null || refreshJob.isCancelled()) {\n                Configuration config = getThing().getConfiguration();\n                int refreshInterval = DEFAULT_REFRESH_INTERVAL;\n                Object refreshConfig = config.get(\"refresh\");\n                if (refreshConfig != null) {\n                    refreshInterval = ((BigDecimal) refreshConfig).intValue();\n                }\n                refreshJob = scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n            }\n        }\n    }\n\n    @Override\n    public String getUDN() {\n        return (String) this.getThing().getConfiguration().get(UDN);\n    }\n\n    /**\n     * The {@link updateWemoState} polls the actual state of a WeMo Maker.\n     */\n    @SuppressWarnings(\"null\")\n    protected void updateWemoState() {\n        String action = \"GetAttributes\";\n        String actionService = \"deviceevent\";\n\n        String soapHeader = \"\\\"urn:Belkin:service:\" + actionService + \":1#\" + action + \"\\\"\";\n        String content = \"<?xml version=\\\"1.0\\\"?>\"\n                + \"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n                + \"<s:Body>\" + \"<u:\" + action + \" xmlns:u=\\\"urn:Belkin:service:\" + actionService + \":1\\\">\" + \"</u:\"\n                + action + \">\" + \"</s:Body>\" + \"</s:Envelope>\";\n\n        try {\n            String wemoURL = getWemoURL(actionService);\n            if (wemoURL != null) {\n                String wemoCallResponse = wemoHttpCaller.executeCall(wemoURL, soapHeader, content);\n                if (wemoCallResponse != null) {\n                    try {\n                        String stringParser = StringUtils.substringBetween(wemoCallResponse, \"<attributeList>\",\n                                \"</attributeList>\");\n\n                        // Due to Belkins bad response formatting, we need to run this twice.\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n                        stringParser = StringEscapeUtils.unescapeXml(stringParser);\n\n                        logger.trace(\"Maker response '{}' for device '{}' received\", stringParser, getThing().getUID());\n\n                        stringParser = \"<data>\" + stringParser + \"</data>\";\n\n                        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                        // see\n                        // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n                        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                        dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                        dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n                        dbf.setXIncludeAware(false);\n                        dbf.setExpandEntityReferences(false);\n                        DocumentBuilder db = dbf.newDocumentBuilder();\n                        InputSource is = new InputSource();\n                        is.setCharacterStream(new StringReader(stringParser));\n\n                        Document doc = db.parse(is);\n                        NodeList nodes = doc.getElementsByTagName(\"attribute\");\n\n                        // iterate the attributes\n                        for (int i = 0; i < nodes.getLength(); i++) {\n                            Element element = (Element) nodes.item(i);\n\n                            NodeList deviceIndex = element.getElementsByTagName(\"name\");\n                            Element line = (Element) deviceIndex.item(0);\n                            String attributeName = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeName: {}\", attributeName);\n\n                            NodeList deviceID = element.getElementsByTagName(\"value\");\n                            line = (Element) deviceID.item(0);\n                            String attributeValue = getCharacterDataFromElement(line);\n                            logger.trace(\"attributeValue: {}\", attributeValue);\n\n                            switch (attributeName) {\n                                case \"Switch\":\n                                    State relayState = attributeValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n                                    if (relayState != null) {\n                                        logger.debug(\"New relayState '{}' for device '{}' received\", relayState,\n                                                getThing().getUID());\n                                        updateState(CHANNEL_RELAY, relayState);\n                                    }\n                                    break;\n                                case \"Sensor\":\n                                    State sensorState = attributeValue.equals(\"1\") ? OnOffType.OFF : OnOffType.ON;\n                                    if (sensorState != null) {\n                                        logger.debug(\"New sensorState '{}' for device '{}' received\", sensorState,\n                                                getThing().getUID());\n                                        updateState(CHANNEL_SENSOR, sensorState);\n                                    }\n                                    break;\n                            }\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Failed to parse attributeList for WeMo Maker '{}'\", this.getThing().getUID(), e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to get attributes for device '{}'\", getThing().getUID(), e);\n        }\n    }\n\n    public String getWemoURL(String actionService) {\n        URL descriptorURL = service.getDescriptorURL(this);\n        String wemoURL = null;\n        if (descriptorURL != null) {\n            String deviceURL = StringUtils.substringBefore(descriptorURL.toString(), \"/setup.xml\");\n            wemoURL = deviceURL + \"/upnp/control/\" + actionService + \"1\";\n            return wemoURL;\n        }\n        return null;\n    }\n\n    public static String getCharacterDataFromElement(Element e) {\n        Node child = e.getFirstChild();\n        if (child instanceof CharacterData) {\n            CharacterData cd = (CharacterData) child;\n            return cd.getData();\n        }\n        return \"?\";\n    }\n\n    @Override\n    public void onStatusChanged(boolean status) {\n    }\n\n    @Override\n    public void onServiceSubscribed(String service, boolean succeeded) {\n    }\n\n    @Override\n    public void onValueReceived(String variable, String value, String service) {\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.yamahareceiver.internal.protocol.xml;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.openhab.binding.yamahareceiver.internal.YamahaReceiverBindingConstants.Zone;\nimport org.openhab.binding.yamahareceiver.internal.protocol.ReceivedMessageParseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Utility methods for XML handling\n *\n * @author David Graeff - Initial contribution\n * @author Tomasz Maruszak - DAB support, Spotify support, refactoring, input name conversion fix, Input mapping fix\n */\npublic class XMLUtils {\n\n    private static final Logger LOG = LoggerFactory.getLogger(XMLUtils.class);\n\n    // We need a lot of xml parsing. Create a document builder beforehand.\n    static final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n    static Node getNode(Node parent, String[] nodePath, int offset) {\n        if (parent == null) {\n            return null;\n        }\n        if (offset < nodePath.length - 1) {\n            return getNode(((Element) parent).getElementsByTagName(nodePath[offset]).item(0), nodePath, offset + 1);\n        } else {\n            return ((Element) parent).getElementsByTagName(nodePath[offset]).item(0);\n        }\n    }\n\n    static Node getNode(Node root, String nodePath) {\n        String[] nodePathArr = nodePath.split(\"/\");\n        return getNode(root, nodePathArr, 0);\n    }\n\n    static Stream<Element> getChildElements(Node node) {\n        if (node == null) {\n            return Stream.empty();\n        }\n        return toStream(node.getChildNodes()).filter(x -> x.getNodeType() == Node.ELEMENT_NODE).map(x -> (Element) x);\n    }\n\n    static Stream<Node> toStream(NodeList nodeList) {\n        return IntStream.range(0, nodeList.getLength()).mapToObj(nodeList::item);\n    }\n\n    /**\n     * Retrieves the child node according to the xpath expression.\n     *\n     * @param root\n     * @param nodePath\n     * @return\n     * @throws ReceivedMessageParseException when the child node does not exist throws\n     *             {@link ReceivedMessageParseException}.\n     */\n    static Node getNodeOrFail(Node root, String nodePath) throws ReceivedMessageParseException {\n        Node node = getNode(root, nodePath);\n        if (node == null) {\n            throw new ReceivedMessageParseException(nodePath + \" child in parent node missing!\");\n        }\n        return node;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @param defaultValue\n     * @return\n     */\n    public static String getNodeContentOrDefault(Node root, String nodePath, String defaultValue) {\n        Node node = getNode(root, nodePath);\n        if (node != null) {\n            return node.getTextContent();\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path.\n     * If the node is found it's inner text is returned, otherwise the default provided value.\n     * The first path that exists is returned.\n     *\n     * @param root\n     * @param nodePaths\n     * @param defaultValue\n     * @return\n     */\n    public static String getAnyNodeContentOrDefault(Node root, String defaultValue, String... nodePaths) {\n        for (String nodePath : nodePaths) {\n            String value = getNodeContentOrDefault(root, nodePath, (String) null);\n            if (value != null) {\n                return value;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @return\n     */\n    public static String getNodeContentOrEmpty(Node root, String nodePath) {\n        return getNodeContentOrDefault(root, nodePath, \"\");\n    }\n\n    /**\n     * Finds the node starting with the root and following the path. If the node is found it's inner text is returned,\n     * otherwise the default provided value.\n     *\n     * @param root\n     * @param nodePath\n     * @param defaultValue\n     * @return\n     */\n    public static Integer getNodeContentOrDefault(Node root, String nodePath, Integer defaultValue) {\n        Node node = getNode(root, nodePath);\n        if (node != null) {\n            try {\n                return Integer.valueOf(node.getTextContent());\n            } catch (NumberFormatException e) {\n                LOG.trace(\n                        \"The value '{}' of node with path {} could not been parsed to an integer. Applying default of {}\",\n                        node.getTextContent(), nodePath, defaultValue);\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Parse the given xml message into a xml document node.\n     *\n     * @param message XML formatted message.\n     * @return Return the response as xml node or throws an exception if response is not xml.\n     * @throws IOException\n     */\n    public static Document xml(String message) throws IOException, ReceivedMessageParseException {\n        // Ensure the message contains XML declaration\n        String response = message.startsWith(\"<?xml\") ? message\n                : \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + message;\n\n        try {\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            return dbf.newDocumentBuilder().parse(new InputSource(new StringReader(response)));\n        } catch (SAXException | ParserConfigurationException e) {\n            throw new ReceivedMessageParseException(e);\n        }\n    }\n\n    /**\n     * Wraps the XML message with the zone tags. Example with zone=Main_Zone:\n     * <Main_Zone>message</Main_Zone>.\n     *\n     * @param message XML message\n     * @return\n     */\n    public static String wrZone(Zone zone, String message) {\n        return \"<\" + zone.name() + \">\" + message + \"</\" + zone.name() + \">\";\n    }\n}\n", "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.transform.xpath.internal;\n\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.core.transform.TransformationException;\nimport org.eclipse.smarthome.core.transform.TransformationService;\nimport org.osgi.service.component.annotations.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\n/**\n * <p>\n * The implementation of {@link TransformationService} which transforms the input by XPath Expressions.\n *\n * @author Thomas.Eichstaedt-Engelen\n */\n@NonNullByDefault\n@Component(immediate = true, property = { \"smarthome.transform=XPATH\" })\npublic class XPathTransformationService implements TransformationService {\n\n    private final Logger logger = LoggerFactory.getLogger(XPathTransformationService.class);\n\n    @Override\n    public @Nullable String transform(String xpathExpression, String source) throws TransformationException {\n        if (xpathExpression == null || source == null) {\n            throw new TransformationException(\"the given parameters 'xpath' and 'source' must not be null\");\n        }\n\n        logger.debug(\"about to transform '{}' by the function '{}'\", source, xpathExpression);\n\n        StringReader stringReader = null;\n\n        try {\n            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            domFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            domFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            domFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            domFactory.setXIncludeAware(false);\n            domFactory.setExpandEntityReferences(false);\n            domFactory.setNamespaceAware(true);\n            domFactory.setValidating(false);\n            DocumentBuilder builder = domFactory.newDocumentBuilder();\n\n            stringReader = new StringReader(source);\n            InputSource inputSource = new InputSource(stringReader);\n            inputSource.setEncoding(\"UTF-8\");\n\n            Document doc = builder.parse(inputSource);\n\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            XPathExpression expr = xpath.compile(xpathExpression);\n\n            String transformationResult = (String) expr.evaluate(doc, XPathConstants.STRING);\n\n            logger.debug(\"transformation resulted in '{}'\", transformationResult);\n\n            return transformationResult;\n        } catch (Exception e) {\n            throw new TransformationException(\"transformation throws exceptions\", e);\n        } finally {\n            if (stringReader != null) {\n                stringReader.close();\n            }\n        }\n    }\n}\n"], "filenames": ["bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/hardware/callbacks/FritzAhaUpdateCallback.java", "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/hardware/callbacks/FritzAhaUpdateTemplatesCallback.java", "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/util/JAXBUtils.java", "bundles/org.openhab.binding.bosesoundtouch/src/main/java/org/openhab/binding/bosesoundtouch/internal/XMLResponseProcessor.java", "bundles/org.openhab.binding.denonmarantz/src/main/java/org/openhab/binding/denonmarantz/internal/connector/http/DenonMarantzHttpConnector.java", "bundles/org.openhab.binding.denonmarantz/src/main/java/org/openhab/binding/denonmarantz/internal/handler/DenonMarantzHandler.java", "bundles/org.openhab.binding.dlinksmarthome/src/main/java/org/openhab/binding/dlinksmarthome/internal/DLinkHNAPCommunication.java", "bundles/org.openhab.binding.enigma2/src/main/java/org/openhab/binding/enigma2/internal/Enigma2Client.java", "bundles/org.openhab.binding.fmiweather/src/main/java/org/openhab/binding/fmiweather/internal/client/Client.java", "bundles/org.openhab.binding.fsinternetradio/src/main/java/org/openhab/binding/fsinternetradio/internal/radio/FrontierSiliconRadioApiResult.java", "bundles/org.openhab.binding.gce/src/main/java/org/openhab/binding/gce/internal/model/StatusFileInterpreter.java", "bundles/org.openhab.binding.homematic/src/main/java/org/openhab/binding/homematic/internal/communicator/message/XmlRpcResponse.java", "bundles/org.openhab.binding.hpprinter/src/main/java/org/openhab/binding/hpprinter/internal/api/HPWebServerClient.java", "bundles/org.openhab.binding.ihc/src/main/java/org/openhab/binding/ihc/internal/ws/projectfile/ProjectFileUtils.java", "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/FeatureTemplateLoader.java", "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/XMLMessageReader.java", "bundles/org.openhab.binding.onkyo/src/main/java/org/openhab/binding/onkyo/internal/handler/OnkyoHandler.java", "bundles/org.openhab.binding.samsungtv/src/main/java/org/openhab/binding/samsungtv/internal/service/SamsungTvUtils.java", "bundles/org.openhab.binding.sonos/src/main/java/org/openhab/binding/sonos/internal/SonosXMLParser.java", "bundles/org.openhab.binding.tellstick/src/main/java/org/openhab/binding/tellstick/internal/live/TelldusLiveDeviceController.java", "bundles/org.openhab.binding.vitotronic/src/main/java/org/openhab/binding/vitotronic/internal/handler/VitotronicBridgeHandler.java", "bundles/org.openhab.binding.wemo/src/main/java/org/openhab/binding/wemo/internal/discovery/WemoLinkDiscoveryService.java", "bundles/org.openhab.binding.wemo/src/main/java/org/openhab/binding/wemo/internal/handler/WemoCoffeeHandler.java", "bundles/org.openhab.binding.wemo/src/main/java/org/openhab/binding/wemo/internal/handler/WemoHolmesHandler.java", "bundles/org.openhab.binding.wemo/src/main/java/org/openhab/binding/wemo/internal/handler/WemoMakerHandler.java", "bundles/org.openhab.binding.yamahareceiver/src/main/java/org/openhab/binding/yamahareceiver/internal/protocol/xml/XMLUtils.java", "bundles/org.openhab.transform.xpath/src/main/java/org/openhab/transform/xpath/internal/XPathTransformationService.java"], "buggy_code_start_loc": [20, 20, 16, 43, 311, 264, 158, 85, 107, 211, 64, 49, 53, 55, 80, 54, 58, 500, 83, 136, 311, 252, 158, 292, 361, 224, 176, 57], "buggy_code_end_loc": [74, 69, 54, 43, 311, 265, 159, 87, 107, 211, 65, 49, 122, 55, 80, 54, 58, 500, 83, 136, 311, 252, 158, 292, 361, 224, 177, 57], "fixing_code_start_loc": [21, 21, 17, 44, 312, 263, 158, 85, 108, 212, 64, 50, 53, 56, 81, 55, 59, 501, 84, 137, 312, 253, 159, 293, 362, 225, 176, 58], "fixing_code_end_loc": [77, 72, 64, 45, 314, 273, 166, 97, 114, 218, 72, 53, 129, 62, 87, 61, 65, 507, 90, 138, 314, 254, 166, 300, 369, 232, 183, 64], "type": "CWE-611", "message": "openHAB is a vendor and technology agnostic open source automation software for your home. In openHAB before versions 2.5.12 and 3.0.1 the XML external entity (XXE) attack allows attackers in the same network as the openHAB instance to retrieve internal information like the content of files from the file system. Responses to SSDP requests can be especially malicious. All add-ons that use SAX or JAXB parsing of externally received XML are potentially subject to this kind of attack. In openHAB, the following add-ons are potentially impacted: AvmFritz, BoseSoundtouch, DenonMarantz, DLinkSmarthome, Enigma2, FmiWeather, FSInternetRadio, Gce, Homematic, HPPrinter, IHC, Insteon, Onkyo, Roku, SamsungTV, Sonos, Roku, Tellstick, TR064, UPnPControl, Vitotronic, Wemo, YamahaReceiver and XPath Tranformation. The vulnerabilities have been fixed in versions 2.5.12 and 3.0.1 by a more strict configuration of the used XML parser.", "other": {"cve": {"id": "CVE-2021-21266", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-01T15:15:13.057", "lastModified": "2021-02-05T21:38:19.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openHAB is a vendor and technology agnostic open source automation software for your home. In openHAB before versions 2.5.12 and 3.0.1 the XML external entity (XXE) attack allows attackers in the same network as the openHAB instance to retrieve internal information like the content of files from the file system. Responses to SSDP requests can be especially malicious. All add-ons that use SAX or JAXB parsing of externally received XML are potentially subject to this kind of attack. In openHAB, the following add-ons are potentially impacted: AvmFritz, BoseSoundtouch, DenonMarantz, DLinkSmarthome, Enigma2, FmiWeather, FSInternetRadio, Gce, Homematic, HPPrinter, IHC, Insteon, Onkyo, Roku, SamsungTV, Sonos, Roku, Tellstick, TR064, UPnPControl, Vitotronic, Wemo, YamahaReceiver and XPath Tranformation. The vulnerabilities have been fixed in versions 2.5.12 and 3.0.1 by a more strict configuration of the used XML parser."}, {"lang": "es", "value": "openHAB es un proveedor y software de automatizaci\u00f3n de c\u00f3digo abierto de tecnolog\u00eda agn\u00f3stica para su hogar. &#xa0;En openHAB anterior a las versiones 2.5.12 y 3.0.1, el ataque de tipo XML external entity (XXE) permite a atacantes en la misma red que la instancia de openHAB recupere informaci\u00f3n interna como el contenido de archivos del sistema de archivos.&#xa0;Las respuestas a las peticiones SSDP pueden ser especialmente maliciosas.&#xa0;Todos los add-ons que usan el an\u00e1lisis SAX o JAXB de XML recibido externamente est\u00e1n potencialmente sujetos a este tipo de ataque.&#xa0;En openHAB, los siguientes add-ons pueden estar afectados: AvmFritz, BoseSoundtouch, DenonMarantz, DLinkSmarthome, Enigma2, FmiWeather, FSInternetRadio, Gce, Homematic, HPPrinter, IHC, Insteon, Onkyo, Roku, SamsungTV, Sonos, Roku, TR064 UPnPControl, Vitotronic, Wemo, YamahaReceiver y XPath Tranformation.&#xa0;Las vulnerabilidades han sido corregidas en las versiones 2.5.12 y 3.0.1 mediante una configuraci\u00f3n m\u00e1s estricta del analizador XML utilizado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openhab:openhab:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.12", "matchCriteriaId": "02B987FD-0707-4B06-9D05-2C4327E8042A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openhab:openhab:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "758998FA-F160-461B-8549-457F7CBC06A4"}]}]}], "references": [{"url": "https://dev.to/brianverm/configure-your-java-xml-parsers-to-prevent-xxe-213c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/openhab/openhab-addons/commit/81935b0ab126e6d9aebd2f6c3fc67d82bb7e8b86", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openhab/openhab-addons/security/advisories/GHSA-r2hc-pmr7-4c9r", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.contrastsecurity.com/security-influencers/xml-xxe-pitfalls-with-jaxb", "source": "security-advisories@github.com", "tags": ["Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openhab/openhab-addons/commit/81935b0ab126e6d9aebd2f6c3fc67d82bb7e8b86"}}