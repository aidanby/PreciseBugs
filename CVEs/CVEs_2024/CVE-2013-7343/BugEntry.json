{"buggy_code": ["/*!\n Flowplayer : The Video Player for Web\n\n Copyright (c) 2012 - 2013 Flowplayer Ltd\n http://flowplayer.org\n\n Authors: Tero Piirainen, Anssi Piirainen\n\n -----\n\n This GPL version includes Flowplayer branding\n\n http://flowplayer.org/GPL-license/#term-7\n\n Commercial versions are available\n * part of the upgrade cycle\n * support the player development\n * no Flowplayer trademark\n\n http://flowplayer.org/download/\n */\npackage {\n\nimport flash.display.DisplayObject;\nimport flash.display.Sprite;\nimport flash.display.StageAlign;\nimport flash.display.StageScaleMode;\nimport flash.events.*;\nimport flash.external.ExternalInterface;\nimport flash.media.SoundTransform;\nimport flash.media.Video;\nimport flash.net.NetConnection;\nimport flash.net.NetStream;\nimport flash.system.Security;\nimport flash.utils.Timer;\nimport flash.utils.setTimeout;\n\npublic class Flowplayer extends Sprite {\n\n   // events\n   internal static const PLAY:String = \"play\";\n   internal static const READY:String = \"ready\";\n   internal static const PAUSE:String = \"pause\";\n   internal static const RESUME:String = \"resume\";\n   internal static const SEEK:String = \"seek\";\n   internal static const STATUS:String = \"status\";\n   internal static const BUFFERED:String = \"buffered\";\n   internal static const VOLUME:String = \"volume\";\n   internal static const FINISH:String = \"finish\";\n   internal static const UNLOAD:String = \"unload\";\n   internal static const ERROR:String = \"error\";\n\n   // external interface\n   private static const INTERFACE:Array\n      = new Array(PLAY, PAUSE, RESUME, SEEK, VOLUME, UNLOAD);\n\n   // flashvars\n   private var conf:Object;\n\n   // state\n   private var preloadComplete:Boolean;\n   private var finished:Boolean;\n   private var paused:Boolean;\n   private var ready:Boolean;\n   private var volumeLevel:Number;\n\n   // clip hack properties\n   private var seekTo:Number;\n   private var clipUrl:String;\n\n   // video stream\n   private var connection:Connection;\n   private var stream:NetStream;\n   private var video:Video;\n   private var logo:DisplayObject;\n\n   private var timer:Timer;\n\n\n   /* constructor */\n   public function Flowplayer() {\n      Security.allowDomain(\"*\");\n      stage.scaleMode = StageScaleMode.NO_SCALE;\n      stage.align = StageAlign.TOP_LEFT;\n\n      if (this.loaderInfo.url.indexOf(\"callback=\") > 0) throw new Error(\"Security error\");\n      conf = this.loaderInfo.parameters;\n\n      // IE needs mouse / keyboard events\n      stage.addEventListener(MouseEvent.CLICK, function (e:MouseEvent):void {\n         fire(\"click\", null);\n      });\n\n      stage.addEventListener(KeyboardEvent.KEY_DOWN, function (e:KeyboardEvent):void {\n         fire(\"keydown\", e.keyCode);\n      });\n\n      stage.addEventListener(Event.RESIZE, arrange);\n\n      var player:Flowplayer = this;\n      this.addEventListener(Event.ADDED_TO_STAGE, function (e:Event):void {\n         // The API\n         for (var i:Number = 0; i < INTERFACE.length; i++) {\n            debug(\"creating callback \" + INTERFACE[i] + \" id == \" + ExternalInterface.objectID);\n            ExternalInterface.addCallback(\"__\" + INTERFACE[i], player[INTERFACE[i]]);\n         }\n      });\n\n      // timeupdate event\n      timer = new Timer(250);\n      timer.addEventListener(\"timer\", timeupdate);\n\n      init();\n   }\n\n   /************ Public API ************/\n\n      // switch url\n   public function play(url:String):void {\n      debug(\"play\");\n      if (ready) {\n         url = unescape(url);\n         conf.autoplay = true; // always begin playback\n         stream.close();\n         stream.play(url);\n         conf.url = url;\n         paused = ready = false;\n         startTimer();\n      }\n   }\n\n   public function pause():void {\n      debug(\"pause()\");\n      if (ready && !paused) {\n         stream.pause();\n         fire(PAUSE, null);\n         paused = true;\n      }\n   }\n\n   public function resume():void {\n      debug(\"resume()\");\n//      debug(\"resume()\", { ready: ready, preloadComplete: preloadComplete, splash: conf.splash });\n      if (!ready) return;\n      if (preloadComplete && !paused) return;\n\n      if (!conf.autoplay) {\n         volume(1, false);\n      }\n\n      try {\n         if (preloadNone() && !preloadComplete) {\n            debug(\"preload == none, starting stream.play()\");\n            conf.autoplay = true;\n            paused = false;\n            stream.play(conf.url);\n         } else {\n            if (finished) {\n               seek(0);\n            }\n            paused = false;\n            conf.autoplay = true;\n            if (stream.time == 0 && !conf.rtmp) {\n               debug(\"playing stream\");\n               stream.play(conf.url);\n            } else {\n               debug(\"resuming stream\");\n               stream.resume();\n            }\n         }\n         debug(\"firing RESUME\");\n         fire(RESUME, null);\n      } catch (e:Error) {\n         debug(\"resume(), error\", e);\n         // net stream is invalid, because of a timeout\n         conf.autoplay = true;\n         ready = true;\n         connect();\n      }\n      startTimer();\n   }\n\n   private function preloadNone():Boolean {\n      var result:Boolean = !conf.splash && conf.preload == \"none\";\n      debug(\"preload == 'none'? \" + result);\n      return result;\n   }\n\n   public function seek(seconds:Number):void {\n      if (ready) {\n         seekTo = seconds;\n         stream.seek(seconds);\n      }\n   }\n\n   public function volume(level:Number, fireEvent:Boolean = true):void {\n      debug(\"volume(), setting to \" + level + \" (was at \" + volumeLevel + \")\");\n      if (stream && volumeLevel != level) {\n         debug(\"setting volume to \" + level);\n         if (level > 1) level = 1;\n         else if (level < 0) level = 0;\n\n         stream.soundTransform = new SoundTransform(level);\n         volumeLevel = level;\n         if (fireEvent) {\n            fire(VOLUME, level);\n         }\n      }\n   }\n\n\n   public function unload():void {\n      debug(\"unload\");\n      if (ready) {\n         pause();\n         stream.close();\n         connection.close();\n         fire(UNLOAD, null);\n      }\n   }\n\n\n   /************* Private API ***********/\n\n\n      // setup video stream\n   private function init():void {\n      initVideo();\n   }\n\n   private function initVideo():void {\n      debug(\"initVideo()\", conf);\n      video = new Video();\n      video.smoothing = true;\n      this.addChild(video);\n      logo = new Logo();\n      addLogo();\n      arrange();\n\n      conf.url = unescape(conf.url);\n\n      debug(\"debug.url\", conf.url);\n\n      paused = !conf.autoplay;\n      preloadComplete = false;\n\n      if (conf.autoplay) {\n         startTimer();\n      }\n\n      connect();\n   }\n\n   private function connect():void {\n      debug(\"connect()\");\n      connection = new Connection(this, conf.rtmp);\n      connection.connect(onConnect, onDisconnect);\n   }\n\n   private function onDisconnect():void {\n      debug(\"onDisconnect()\")\n      this.ready = false;\n   }\n\n   private function onConnect(conn:NetConnection):void {\n      debug(\"Connection success\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n      stream = new NetStream(conn);\n      debug(\"setting buffer time to \" + (conf.bufferTime || 0.1));\n      stream.bufferTime = conf.bufferTime || 0.1;\n      video.attachNetStream(stream);\n\n      // set volume to zero so that we don't hear anything if stopping on first frame\n      if (!conf.autoplay) {\n         volume(0, false);\n      }\n\n      fire(\"debug-preloadComplete = \" + preloadComplete, null);\n      // start streaming\n\n      if (preloadNone() && !preloadComplete) {\n         ready = true;\n         fire(Flowplayer.READY, {\n            seekable: !!conf.rtmp,\n            bytes: stream.bytesTotal,\n            src: conf.url,\n            url: conf.url\n         });\n         fire(Flowplayer.PAUSE, null);\n\n         // we pause when metadata is received\n      } else {\n         debug(\"starting play\");\n         stream.play(conf.url);\n         if (conf.autoplay) {\n            startTimer();\n         }\n      }\n\n      // metadata\n      stream.client = {\n\n         onPlayStatus: function (info:Object):void {\n            debug(\"onPlayStatus\", info);\n            if (info.code == \"NetStream.Play.Complete\") {\n               finished = true;\n               if (conf.loop) {\n                  stream.seek(0);\n               } else if (!paused) {\n                  paused = true;\n                  fire(Flowplayer.PAUSE, null);\n                  fire(Flowplayer.FINISH, null);\n               }\n            }\n         },\n\n         onMetaData: function (info:Object):void {\n            debug(\"onMetaData()\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n            // use a real object\n            var meta:Object = { seekpoints: [] };\n            for (var key:String in info) {\n               meta[key] = info[key];\n            }\n            if (conf.debug) fire(\"debug.metadata\", meta);\n\n            var clip:Object = {\n               seekable: !!conf.rtmp,\n               bytes: stream.bytesTotal,\n               duration: meta.duration,\n               height: meta.height,\n               width: meta.width,\n               seekpoints: meta.seekpoints,\n               src: conf.url,\n               url: conf.url\n            };\n\n            if (!ready) {\n               ready = true;\n\n               fire(Flowplayer.READY, clip);\n               if (conf.autoplay) fire(Flowplayer.RESUME, null);\n\n               // stop at first frame\n               if (!conf.autoplay) {\n                   debug(\"stopping on first frame\");\n                  volume(1);\n                  stream.pause();\n                  stream.seek(0);\n               }\n            }\n\n            if (preloadNone() && !preloadComplete) {\n               preloadComplete = true;\n               fire(Flowplayer.READY, clip);\n               fire(Flowplayer.RESUME, null);\n            }\n         }\n      };\n\n      // listen for playback events\n      stream.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n         if (conf.debug) fire(\"debug.stream\", e.info.code);\n\n         switch (e.info.code) {\n\n            case \"NetStream.Play.Start\":\n\n               finished = false;\n\n               // RTMP fires start a lot\n               if (!conf.rtmp) {\n                  if (conf.autoplay) {\n                     paused = false;\n\n                     // stop at first frame\n                  }\n               }\n               break;\n\n            case \"NetStream.Seek.Notify\":\n               finished = false;\n               if (conf.autoplay) {\n                   timeupdate(true);\n                   fire(Flowplayer.SEEK, seekTo);\n               }\n               break;\n\n            case \"NetStream.Buffer.Full\":\n               fire(Flowplayer.BUFFERED, null);\n               break;\n\n            case \"NetStream.Play.StreamNotFound\":\n            case \"NetStream.Play.Failed\":\n               finished = true;\n               fire(Flowplayer.ERROR, { code: 4 });\n               break;\n\n            case \"NetStream.Play.Stop\":\n               if (!conf.rtmp && !paused) {\n                  finished = true;\n                  paused = true;\n                  stream.pause();\n                  fire(Flowplayer.PAUSE, null);\n                  fire(Flowplayer.FINISH, null);\n               }\n               break;\n\n         }\n\n      });\n   }\n\n   private function startTimer():void {\n      debug(\"starting progress timer\");\n      timer.start();\n   }\n\n\n   private function timeupdate(e:Object):void {\n      if (ready) {\n         var buffer:Number = stream.bytesLoaded,\n            delta:Number = stream.bytesTotal - buffer;\n\n         // first frame & no preload\n         if (!conf.autoplay && !conf.preload && !conf.rtmp) {\n            stream.close();\n         }\n\n         // http://www.brooksandrus.com/blog/2008/11/05/3-years-later-netstream-still-sucks/\n         if (e === true) {\n            fire(STATUS, { time: seekTo, buffer: buffer });\n            setTimeout(function ():void { seekTo = 0; }, 100);\n\n         } else if (!(paused || finished || seekTo) || delta > 0) {\n            fire(STATUS, { time: stream.time, buffer: buffer });\n         }\n      }\n   }\n\n   internal function debug(msg:String, data:Object = null):void {\n      if (!conf.debug) return;\n      fire(\"debug: \" + msg, data);\n//        ExternalInterface.call(\"console.log\", msg, data);\n   }\n\n   internal function fire(type:String, data:Object = null):void {\n      if (conf.callback) {\n         if (data) {\n            ExternalInterface.call(conf.callback, type, data);\n         } else {\n            ExternalInterface.call(conf.callback, type);\n         }\n      }\n   }\n\n   private function arrange(e:Event = null):void {\n      logo.x = 12;\n      logo.y = stage.stageHeight - 50;\n      video.width = stage.stageWidth;\n      video.height = stage.stageHeight;\n   };\n\n   private function addLogo():void {\n      var pos:int = conf.url ? conf.url.indexOf(\"://my.flowplayer.org\") : -1;\n      if (pos == 4 || pos == 5) return;\n      addChild(logo);\n   }\n\n}\n\n}\n"], "fixing_code": ["/*!\n Flowplayer : The Video Player for Web\n\n Copyright (c) 2012 - 2013 Flowplayer Ltd\n http://flowplayer.org\n\n Authors: Tero Piirainen, Anssi Piirainen\n\n -----\n\n This GPL version includes Flowplayer branding\n\n http://flowplayer.org/GPL-license/#term-7\n\n Commercial versions are available\n * part of the upgrade cycle\n * support the player development\n * no Flowplayer trademark\n\n http://flowplayer.org/download/\n */\npackage {\n\nimport flash.display.DisplayObject;\nimport flash.display.Sprite;\nimport flash.display.StageAlign;\nimport flash.display.StageScaleMode;\nimport flash.events.*;\nimport flash.external.ExternalInterface;\nimport flash.media.SoundTransform;\nimport flash.media.Video;\nimport flash.net.NetConnection;\nimport flash.net.NetStream;\nimport flash.system.Security;\nimport flash.utils.Timer;\nimport flash.utils.setTimeout;\n\npublic class Flowplayer extends Sprite {\n\n   // events\n   internal static const PLAY:String = \"play\";\n   internal static const READY:String = \"ready\";\n   internal static const PAUSE:String = \"pause\";\n   internal static const RESUME:String = \"resume\";\n   internal static const SEEK:String = \"seek\";\n   internal static const STATUS:String = \"status\";\n   internal static const BUFFERED:String = \"buffered\";\n   internal static const VOLUME:String = \"volume\";\n   internal static const FINISH:String = \"finish\";\n   internal static const UNLOAD:String = \"unload\";\n   internal static const ERROR:String = \"error\";\n\n   // external interface\n   private static const INTERFACE:Array\n      = new Array(PLAY, PAUSE, RESUME, SEEK, VOLUME, UNLOAD);\n\n   // flashvars\n   private var conf:Object;\n\n   // state\n   private var preloadComplete:Boolean;\n   private var finished:Boolean;\n   private var paused:Boolean;\n   private var ready:Boolean;\n   private var volumeLevel:Number;\n\n   // clip hack properties\n   private var seekTo:Number;\n   private var clipUrl:String;\n\n   // video stream\n   private var connection:Connection;\n   private var stream:NetStream;\n   private var video:Video;\n   private var logo:DisplayObject;\n\n   private var timer:Timer;\n\n\n   /* constructor */\n   public function Flowplayer() {\n      Security.allowDomain(\"*\");\n      stage.scaleMode = StageScaleMode.NO_SCALE;\n      stage.align = StageAlign.TOP_LEFT;\n\n      var swfUrl:String = decodeURIComponent(this.loaderInfo.url);\n      if (swfUrl.indexOf(\"callback=\") > 0) throw new Error(\"Security error\");\n      conf = this.loaderInfo.parameters;\n\n      // IE needs mouse / keyboard events\n      stage.addEventListener(MouseEvent.CLICK, function (e:MouseEvent):void {\n         fire(\"click\", null);\n      });\n\n      stage.addEventListener(KeyboardEvent.KEY_DOWN, function (e:KeyboardEvent):void {\n         fire(\"keydown\", e.keyCode);\n      });\n\n      stage.addEventListener(Event.RESIZE, arrange);\n\n      var player:Flowplayer = this;\n      this.addEventListener(Event.ADDED_TO_STAGE, function (e:Event):void {\n         // The API\n         for (var i:Number = 0; i < INTERFACE.length; i++) {\n            debug(\"creating callback \" + INTERFACE[i] + \" id == \" + ExternalInterface.objectID);\n            ExternalInterface.addCallback(\"__\" + INTERFACE[i], player[INTERFACE[i]]);\n         }\n      });\n\n      // timeupdate event\n      timer = new Timer(250);\n      timer.addEventListener(\"timer\", timeupdate);\n\n      init();\n   }\n\n   /************ Public API ************/\n\n      // switch url\n   public function play(url:String):void {\n      debug(\"play\");\n      if (ready) {\n         url = unescape(url);\n         conf.autoplay = true; // always begin playback\n         stream.close();\n         stream.play(url);\n         conf.url = url;\n         paused = ready = false;\n         startTimer();\n      }\n   }\n\n   public function pause():void {\n      debug(\"pause()\");\n      if (ready && !paused) {\n         stream.pause();\n         fire(PAUSE, null);\n         paused = true;\n      }\n   }\n\n   public function resume():void {\n      debug(\"resume()\");\n//      debug(\"resume()\", { ready: ready, preloadComplete: preloadComplete, splash: conf.splash });\n      if (!ready) return;\n      if (preloadComplete && !paused) return;\n\n      if (!conf.autoplay) {\n         volume(1, false);\n      }\n\n      try {\n         if (preloadNone() && !preloadComplete) {\n            debug(\"preload == none, starting stream.play()\");\n            conf.autoplay = true;\n            paused = false;\n            stream.play(conf.url);\n         } else {\n            if (finished) {\n               seek(0);\n            }\n            paused = false;\n            conf.autoplay = true;\n            if (stream.time == 0 && !conf.rtmp) {\n               debug(\"playing stream\");\n               stream.play(conf.url);\n            } else {\n               debug(\"resuming stream\");\n               stream.resume();\n            }\n         }\n         debug(\"firing RESUME\");\n         fire(RESUME, null);\n      } catch (e:Error) {\n         debug(\"resume(), error\", e);\n         // net stream is invalid, because of a timeout\n         conf.autoplay = true;\n         ready = true;\n         connect();\n      }\n      startTimer();\n   }\n\n   private function preloadNone():Boolean {\n      var result:Boolean = !conf.splash && conf.preload == \"none\";\n      debug(\"preload == 'none'? \" + result);\n      return result;\n   }\n\n   public function seek(seconds:Number):void {\n      if (ready) {\n         seekTo = seconds;\n         stream.seek(seconds);\n      }\n   }\n\n   public function volume(level:Number, fireEvent:Boolean = true):void {\n      debug(\"volume(), setting to \" + level + \" (was at \" + volumeLevel + \")\");\n      if (stream && volumeLevel != level) {\n         debug(\"setting volume to \" + level);\n         if (level > 1) level = 1;\n         else if (level < 0) level = 0;\n\n         stream.soundTransform = new SoundTransform(level);\n         volumeLevel = level;\n         if (fireEvent) {\n            fire(VOLUME, level);\n         }\n      }\n   }\n\n\n   public function unload():void {\n      debug(\"unload\");\n      if (ready) {\n         pause();\n         stream.close();\n         connection.close();\n         fire(UNLOAD, null);\n      }\n   }\n\n\n   /************* Private API ***********/\n\n\n      // setup video stream\n   private function init():void {\n      initVideo();\n   }\n\n   private function initVideo():void {\n      debug(\"initVideo()\", conf);\n      video = new Video();\n      video.smoothing = true;\n      this.addChild(video);\n      logo = new Logo();\n      addLogo();\n      arrange();\n\n      conf.url = unescape(conf.url);\n\n      debug(\"debug.url\", conf.url);\n\n      paused = !conf.autoplay;\n      preloadComplete = false;\n\n      if (conf.autoplay) {\n         startTimer();\n      }\n\n      connect();\n   }\n\n   private function connect():void {\n      debug(\"connect()\");\n      connection = new Connection(this, conf.rtmp);\n      connection.connect(onConnect, onDisconnect);\n   }\n\n   private function onDisconnect():void {\n      debug(\"onDisconnect()\")\n      this.ready = false;\n   }\n\n   private function onConnect(conn:NetConnection):void {\n      debug(\"Connection success\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n      stream = new NetStream(conn);\n      debug(\"setting buffer time to \" + (conf.bufferTime || 0.1));\n      stream.bufferTime = conf.bufferTime || 0.1;\n      video.attachNetStream(stream);\n\n      // set volume to zero so that we don't hear anything if stopping on first frame\n      if (!conf.autoplay) {\n         volume(0, false);\n      }\n\n      fire(\"debug-preloadComplete = \" + preloadComplete, null);\n      // start streaming\n\n      if (preloadNone() && !preloadComplete) {\n         ready = true;\n         fire(Flowplayer.READY, {\n            seekable: !!conf.rtmp,\n            bytes: stream.bytesTotal,\n            src: conf.url,\n            url: conf.url\n         });\n         fire(Flowplayer.PAUSE, null);\n\n         // we pause when metadata is received\n      } else {\n         debug(\"starting play\");\n         stream.play(conf.url);\n         if (conf.autoplay) {\n            startTimer();\n         }\n      }\n\n      // metadata\n      stream.client = {\n\n         onPlayStatus: function (info:Object):void {\n            debug(\"onPlayStatus\", info);\n            if (info.code == \"NetStream.Play.Complete\") {\n               finished = true;\n               if (conf.loop) {\n                  stream.seek(0);\n               } else if (!paused) {\n                  paused = true;\n                  fire(Flowplayer.PAUSE, null);\n                  fire(Flowplayer.FINISH, null);\n               }\n            }\n         },\n\n         onMetaData: function (info:Object):void {\n            debug(\"onMetaData()\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n            // use a real object\n            var meta:Object = { seekpoints: [] };\n            for (var key:String in info) {\n               meta[key] = info[key];\n            }\n            if (conf.debug) fire(\"debug.metadata\", meta);\n\n            var clip:Object = {\n               seekable: !!conf.rtmp,\n               bytes: stream.bytesTotal,\n               duration: meta.duration,\n               height: meta.height,\n               width: meta.width,\n               seekpoints: meta.seekpoints,\n               src: conf.url,\n               url: conf.url\n            };\n\n            if (!ready) {\n               ready = true;\n\n               fire(Flowplayer.READY, clip);\n               if (conf.autoplay) fire(Flowplayer.RESUME, null);\n\n               // stop at first frame\n               if (!conf.autoplay) {\n                   debug(\"stopping on first frame\");\n                  volume(1);\n                  stream.pause();\n                  stream.seek(0);\n               }\n            }\n\n            if (preloadNone() && !preloadComplete) {\n               preloadComplete = true;\n               fire(Flowplayer.READY, clip);\n               fire(Flowplayer.RESUME, null);\n            }\n         }\n      };\n\n      // listen for playback events\n      stream.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n         if (conf.debug) fire(\"debug.stream\", e.info.code);\n\n         switch (e.info.code) {\n\n            case \"NetStream.Play.Start\":\n\n               finished = false;\n\n               // RTMP fires start a lot\n               if (!conf.rtmp) {\n                  if (conf.autoplay) {\n                     paused = false;\n\n                     // stop at first frame\n                  }\n               }\n               break;\n\n            case \"NetStream.Seek.Notify\":\n               finished = false;\n               if (conf.autoplay) {\n                   timeupdate(true);\n                   fire(Flowplayer.SEEK, seekTo);\n               }\n               break;\n\n            case \"NetStream.Buffer.Full\":\n               fire(Flowplayer.BUFFERED, null);\n               break;\n\n            case \"NetStream.Play.StreamNotFound\":\n            case \"NetStream.Play.Failed\":\n               finished = true;\n               fire(Flowplayer.ERROR, { code: 4 });\n               break;\n\n            case \"NetStream.Play.Stop\":\n               if (!conf.rtmp && !paused) {\n                  finished = true;\n                  paused = true;\n                  stream.pause();\n                  fire(Flowplayer.PAUSE, null);\n                  fire(Flowplayer.FINISH, null);\n               }\n               break;\n\n         }\n\n      });\n   }\n\n   private function startTimer():void {\n      debug(\"starting progress timer\");\n      timer.start();\n   }\n\n\n   private function timeupdate(e:Object):void {\n      if (ready) {\n         var buffer:Number = stream.bytesLoaded,\n            delta:Number = stream.bytesTotal - buffer;\n\n         // first frame & no preload\n         if (!conf.autoplay && !conf.preload && !conf.rtmp) {\n            stream.close();\n         }\n\n         // http://www.brooksandrus.com/blog/2008/11/05/3-years-later-netstream-still-sucks/\n         if (e === true) {\n            fire(STATUS, { time: seekTo, buffer: buffer });\n            setTimeout(function ():void { seekTo = 0; }, 100);\n\n         } else if (!(paused || finished || seekTo) || delta > 0) {\n            fire(STATUS, { time: stream.time, buffer: buffer });\n         }\n      }\n   }\n\n   internal function debug(msg:String, data:Object = null):void {\n      if (!conf.debug) return;\n      fire(\"debug: \" + msg, data);\n//        ExternalInterface.call(\"console.log\", msg, data);\n   }\n\n   internal function fire(type:String, data:Object = null):void {\n      if (conf.callback) {\n         if (data) {\n            ExternalInterface.call(conf.callback, type, data);\n         } else {\n            ExternalInterface.call(conf.callback, type);\n         }\n      }\n   }\n\n   private function arrange(e:Event = null):void {\n      logo.x = 12;\n      logo.y = stage.stageHeight - 50;\n      video.width = stage.stageWidth;\n      video.height = stage.stageHeight;\n   };\n\n   private function addLogo():void {\n      var pos:int = conf.url ? conf.url.indexOf(\"://my.flowplayer.org\") : -1;\n      if (pos == 4 || pos == 5) return;\n      addChild(logo);\n   }\n\n}\n\n}\n"], "filenames": ["lib/as/Flowplayer.as"], "buggy_code_start_loc": [86], "buggy_code_end_loc": [87], "fixing_code_start_loc": [86], "fixing_code_end_loc": [88], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in flowplayer.swf in the Flash fallback feature in Flowplayer HTML5 5.4.3 allows remote attackers to inject arbitrary web script or HTML by using URL encoding within the callback parameter name.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7342.", "other": {"cve": {"id": "CVE-2013-7343", "sourceIdentifier": "cve@mitre.org", "published": "2014-03-24T14:20:39.357", "lastModified": "2014-03-24T15:16:01.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in flowplayer.swf in the Flash fallback feature in Flowplayer HTML5 5.4.3 allows remote attackers to inject arbitrary web script or HTML by using URL encoding within the callback parameter name.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7342."}, {"lang": "es", "value": "Vulnerabilidad de XSS en flowplayer.swf en la funcionalidad de reserva de Flash en Flowplayer HTML5 5.4.3 permite a atacantes remotos inyectar script Web o HTML arbitrarios mediante el uso de codificaci\u00f3n de URL dentro del nombre del par\u00e1metro callback.  NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2013-7342."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flowplayer:flowplayer_html5:5.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "043FA843-F1D3-4FE1-AAF7-4E1534D0DF1D"}]}]}], "references": [{"url": "https://github.com/flowplayer/flowplayer/commit/27e8f178276c185cbddb4f14c91d4ce7b3865db1", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/flowplayer/flowplayer/issues/381", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/flowplayer/flowplayer/commit/27e8f178276c185cbddb4f14c91d4ce7b3865db1"}}