{"buggy_code": ["/* -*- C++ -*-\n * Copyright 2019 LibRaw LLC (info@libraw.org)\n *\n LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,\n dcraw.c is copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net.\n LibRaw do not use RESTRICTED code from dcraw.c\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/dcraw_defs.h\"\n\nunsigned LibRaw::getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n         !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *LibRaw::make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *LibRaw::make_decoder(const uchar *source)\n{\n  return make_decoder_ref(&source);\n}\n\nvoid LibRaw::crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0,    1,    4,    2,    3,    1,    2,    0,    0,    0,\n       0,    0,    0,    0,    0,    0,    0x04, 0x03, 0x05, 0x06,\n       0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0,    2,    2,    3,    1,    1,    1,    1,    2,    0,\n       0,    0,    0,    0,    0,    0,    0x03, 0x02, 0x04, 0x01,\n       0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0,    0,    6,    3,    1,    1,    2,    0,    0,    0,\n       0,    0,    0,    0,    0,    0,    0x06, 0x05, 0x07, 0x04,\n       0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,\n       0,    0,    0,    139,  0x03, 0x04, 0x02, 0x05, 0x01, 0x06, 0x07, 0x08,\n       0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42,\n       0x35, 0x51, 0x36, 0x37, 0x38, 0x29, 0x79, 0x26, 0x1a, 0x39, 0x56, 0x57,\n       0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98,\n       0x47, 0x48, 0x95, 0x69, 0x99, 0x91, 0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6,\n       0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7,\n       0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7, 0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1,\n       0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba,\n       0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3, 0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4,\n       0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,\n       0,    0,    0,    140,  0x02, 0x03, 0x01, 0x04, 0x05, 0x12, 0x11, 0x06,\n       0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51,\n       0x34, 0x43, 0x52, 0x29, 0x35, 0x61, 0x39, 0x71, 0x62, 0x36, 0x53, 0x26,\n       0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9,\n       0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56, 0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99,\n       0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8,\n       0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82, 0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a,\n       0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8,\n       0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64, 0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8,\n       0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,\n       8,    10,   0,    117,  0x04, 0x05, 0x03, 0x06, 0x02, 0x07, 0x01, 0x08,\n       0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34,\n       0x35, 0x36, 0x39, 0x79, 0x57, 0x58, 0x59, 0x28, 0x56, 0x78, 0x27, 0x41,\n       0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69,\n       0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88, 0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8,\n       0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a,\n       0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a, 0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6,\n       0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5,\n       0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1, 0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3,\n       0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint LibRaw::canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid LibRaw::canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  try\n  {\n    for (row = 0; row < raw_height; row += 8)\n    {\n      checkCancel();\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n  FORC(2) free(huff[c]);\n}\n\nint LibRaw::ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide ||\n      !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid LibRaw::ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint LibRaw::ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *LibRaw::ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid LibRaw::lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n  try\n  {\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n      checkCancel();\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  ljpeg_end(&jh);\n}\n\nvoid LibRaw::canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n  int saved_w = width, saved_h = height;\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n        checkCancel();\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n          if (imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] =\n                  ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options &\n                   LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n\n  try\n  {\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281ULL ||\n        (unique_id == 0x80000218ULL && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n      checkCancel();\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n    if (!(imgdata.params.raw_processing_options &\n          LIBRAW_PROCESSING_SRAW_NO_RGB))\n      for (; rp < ip[0]; rp += 4)\n      {\n        checkCancel();\n        if (unique_id == 0x80000218ULL || unique_id == 0x80000250ULL ||\n            unique_id == 0x80000261ULL || unique_id == 0x80000281ULL ||\n            unique_id == 0x80000287ULL)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218ULL)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP15(pix[c] * sraw_mul[c] >> 10);\n      }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid LibRaw::ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {\n      0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,\n      12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28,\n      35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,\n      58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63,\n      63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid LibRaw::pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\nvoid LibRaw::nikon_read_curve()\n{\n  ushort ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, step, max;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && (ver1 == 0x20 || (ver1 == 0x40 && step > 3)) && step > 0)\n  {\n    if (ver1 == 0x40)\n    {\n      step /= 4;\n      max /= 4;\n    }\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) +\n                  curve[i - i % step + step] * (i % step)) /\n                 step;\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n}\n\nvoid LibRaw::nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0,\n       0,    0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0,\n       0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2];\n  int i, min, max, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if (ver0 == 0x44 && (ver1 == 0x20 || ver1 == 0x40))\n  {\n    if (ver1 == 0x40)\n      max /= 4;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n\n  while (max > 2 && (curve[max - 2] == curve[max - 1]))\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  try\n  {\n    for (min = row = 0; row < height; row++)\n    {\n      checkCancel();\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n  free(huff);\n}\n\nvoid LibRaw::nikon_yuv_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] =\n          curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\nvoid LibRaw::rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n  if (raw_width > 32767 || raw_height > 32767)\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n  unsigned maxpixel = raw_width * (raw_height + 7);\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n    checkCancel();\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      if (todo[i] < maxpixel)\n        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n      else\n        derror();\n  }\n  maximum = 0x3ff;\n}\n\nvoid LibRaw::nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n  try\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      checkCancel();\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid LibRaw::canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n  }\n  free(words);\n  maximum = curve[0x3ff];\n}\n\nunsigned LibRaw::pana_data(int nb, unsigned *bytes)\n{\n#ifndef LIBRAW_NOTHREADS\n#define vpos tls->pana_data.vpos\n#define buf tls->pana_data.buf\n#else\n  static uchar buf[0x4002];\n  static int vpos;\n#endif\n  int byte;\n\n  if (!nb && !bytes)\n    return vpos = 0;\n\n  if (!vpos)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n\n  if (pana_encoding == 5)\n  {\n    for (byte = 0; byte < 16; byte++)\n    {\n      bytes[byte] = buf[vpos++];\n      vpos &= 0x3FFF;\n    }\n  }\n  else\n  {\n    vpos = (vpos - nb) & 0x1ffff;\n    byte = vpos >> 3 ^ 0x3ff0;\n    return (buf[byte] | buf[byte + 1] << 8) >> (vpos & 7) & ~((~0u) << nb);\n  }\n  return 0;\n#ifndef LIBRAW_NOTHREADS\n#undef vpos\n#undef buf\n#endif\n}\n\nvoid LibRaw::panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  unsigned bytes[16];\n  ushort *raw_block_data;\n\n  pana_data(0, 0);\n\n  int enc_blck_size = pana_bpp == 12 ? 10 : 9;\n  if (pana_encoding == 5)\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      raw_block_data = raw_image + row * raw_width;\n      checkCancel();\n      for (col = 0; col < raw_width; col += enc_blck_size)\n      {\n        pana_data(0, bytes);\n\n        if (pana_bpp == 12)\n        {\n          raw_block_data[col] = ((bytes[1] & 0xF) << 8) + bytes[0];\n          raw_block_data[col + 1] = 16 * bytes[2] + (bytes[1] >> 4);\n          raw_block_data[col + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];\n          raw_block_data[col + 3] = 16 * bytes[5] + (bytes[4] >> 4);\n          raw_block_data[col + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];\n          raw_block_data[col + 5] = 16 * bytes[8] + (bytes[7] >> 4);\n          raw_block_data[col + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];\n          raw_block_data[col + 7] = 16 * bytes[11] + (bytes[10] >> 4);\n          raw_block_data[col + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];\n          raw_block_data[col + 9] = 16 * bytes[14] + (bytes[13] >> 4);\n        }\n        else if (pana_bpp == 14)\n        {\n          raw_block_data[col] = bytes[0] + ((bytes[1] & 0x3F) << 8);\n          raw_block_data[col + 1] =\n              (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);\n          raw_block_data[col + 2] =\n              (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);\n          raw_block_data[col + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);\n          raw_block_data[col + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);\n          raw_block_data[col + 5] =\n              (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);\n          raw_block_data[col + 6] =\n              (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);\n          raw_block_data[col + 7] =\n              ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);\n          raw_block_data[col + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);\n        }\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      checkCancel();\n      for (col = 0; col < raw_width; col++)\n      {\n        if ((i = col % 14) == 0)\n          pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n        if (i % 3 == 2)\n          sh = 4 >> (3 - pana_data(2, 0));\n        if (nonz[i & 1])\n        {\n          if ((j = pana_data(8, 0)))\n          {\n            if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n              pred[i & 1] &= ~((~0u) << sh);\n            pred[i & 1] += j << sh;\n          }\n        }\n        else if ((nonz[i & 1] = pana_data(8, 0)) || i > 11)\n          pred[i & 1] = nonz[i & 1] << 4 | pana_data(4, 0);\n        if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width &&\n            row < height)\n          derror();\n      }\n    }\n  }\n}\n\nvoid LibRaw::olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n    checkCancel();\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2\n                              ? pixel[col / 2 - 1] + pixel[col / 2 + 1]\n                              : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid LibRaw::quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2,\n                                  2,   8,   15,  22,  32,  44,  60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},\n                                    {-8, -2, 2, 8},   {-13, -3, 3, 13},\n                                    {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,    2,    3,   4,   5,   6,   7,   8,   9,   11,  12,  13,  14,\n      15,  16,   17,   18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,\n      29,  30,   32,   33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,\n      44,  45,   46,   47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,\n      59,  60,   61,   62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,\n      74,  75,   76,   77,  78,  79,  80,  81,  82,  83,  84,  86,  88,  90,\n      92,  94,   97,   99,  101, 103, 105, 107, 110, 112, 114, 116, 118, 120,\n      123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147, 149, 151,\n      153, 155,  158,  160, 162, 164, 166, 168, 171, 173, 175, 177, 179, 181,\n      184, 186,  188,  190, 192, 195, 197, 199, 201, 203, 205, 208, 210, 212,\n      214, 216,  218,  221, 223, 226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270,  274,  278, 283, 287, 291, 296, 300, 305, 309, 313, 318, 322,\n      326, 331,  335,  339, 344, 348, 352, 357, 361, 365, 370, 374, 379, 383,\n      387, 392,  396,  400, 405, 409, 413, 418, 422, 426, 431, 435, 440, 444,\n      448, 453,  457,  461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,\n      519, 531,  542,  553, 564, 575, 587, 598, 609, 620, 631, 643, 654, 665,\n      676, 687,  698,  710, 721, 732, 743, 754, 766, 777, 788, 799, 810, 822,\n      833, 844,  855,  866, 878, 889, 900, 911, 922, 933, 945, 956, 967, 978,\n      989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  if (width > 640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n    checkCancel();\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] +\n              pixel[row][col - 2]) >>\n             2) +\n            gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n      checkCancel();\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) +\n                ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4\n                      ? 0\n                      : val < 8\n                            ? 1\n                            : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) +\n              rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n    checkCancel();\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) +\n              pixel[row][col + 1]) >>\n             1) -\n            0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\nvoid LibRaw::sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid LibRaw::sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c,\n                                 0xa0b, 0x90a, 0x809, 0x708, 0x607, 0x506,\n                                 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n    checkCancel();\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid LibRaw::sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n  try\n  {\n    for (row = 0; row < height; row++)\n    {\n      checkCancel();\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options &\n                LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] =\n                  ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] =\n                  ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n\n        if (imgdata.params.raw_processing_options &\n            LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope =\n                pix[i] < 1001 ? 2\n                              : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) =\n                curve[pix[i] << 1] >\n                        black + imgdata.params.sony_arw2_posterization_thr\n                    ? LIM(((slope * step * 1000) /\n                           (curve[pix[i] << 1] - black)),\n                          0, 10000)\n                    : 0;\n          }\n        }\n        else\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n  free(data);\n}\n\nvoid LibRaw::samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n  if (raw_width > 32768 ||\n      raw_height > 32768) // definitely too much for old samsung\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n  unsigned maxpixels = raw_width * (raw_height + 7);\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        unsigned idest = RAWINDEX(row, col + c);\n        unsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c)\n                             : col ? RAWINDEX(row, col + (c | -2)) : 0);\n        if (idest < maxpixels &&\n            isrc <\n                maxpixels) // less than zero is handled by unsigned conversion\n          RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                              (dir ? RAW(row + (~c | -2), col + c)\n                                   : col ? RAW(row, col + (c | -2)) : 128);\n        else\n          derror();\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid LibRaw::samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403,\n                                 0x600, 0x709, 0x80a, 0x90b, 0xa0c,\n                                 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          if (i < 0)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        if (col < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if (pmode < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if (pmode != 7 && row >= 2 && (col - '4' + \"0224468\"[pmode]) < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        pred = (pmode == 7 || row < 2)\n                   ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                   : (prow[col & 1][col - '4' + \"0224468\"[pmode]] +\n                      prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >>\n                         1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\nvoid LibRaw::redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n  bool fastexitflag = false;\n  try\n  {\n    FORC4\n    {\n      checkCancel();\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] =\n              data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] =\n          img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n      checkCancel();\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] +\n             pix[-1] + pix[1]) >>\n            2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n      checkCancel();\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n"], "fixing_code": ["/* -*- C++ -*-\n * Copyright 2019 LibRaw LLC (info@libraw.org)\n *\n LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,\n dcraw.c is copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net.\n LibRaw do not use RESTRICTED code from dcraw.c\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/dcraw_defs.h\"\n\nunsigned LibRaw::getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n         !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *LibRaw::make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *LibRaw::make_decoder(const uchar *source)\n{\n  return make_decoder_ref(&source);\n}\n\nvoid LibRaw::crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0,    1,    4,    2,    3,    1,    2,    0,    0,    0,\n       0,    0,    0,    0,    0,    0,    0x04, 0x03, 0x05, 0x06,\n       0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0,    2,    2,    3,    1,    1,    1,    1,    2,    0,\n       0,    0,    0,    0,    0,    0,    0x03, 0x02, 0x04, 0x01,\n       0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0,    0,    6,    3,    1,    1,    2,    0,    0,    0,\n       0,    0,    0,    0,    0,    0,    0x06, 0x05, 0x07, 0x04,\n       0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,\n       0,    0,    0,    139,  0x03, 0x04, 0x02, 0x05, 0x01, 0x06, 0x07, 0x08,\n       0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42,\n       0x35, 0x51, 0x36, 0x37, 0x38, 0x29, 0x79, 0x26, 0x1a, 0x39, 0x56, 0x57,\n       0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98,\n       0x47, 0x48, 0x95, 0x69, 0x99, 0x91, 0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6,\n       0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7,\n       0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7, 0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1,\n       0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba,\n       0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3, 0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4,\n       0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,\n       0,    0,    0,    140,  0x02, 0x03, 0x01, 0x04, 0x05, 0x12, 0x11, 0x06,\n       0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51,\n       0x34, 0x43, 0x52, 0x29, 0x35, 0x61, 0x39, 0x71, 0x62, 0x36, 0x53, 0x26,\n       0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9,\n       0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56, 0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99,\n       0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8,\n       0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82, 0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a,\n       0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8,\n       0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64, 0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8,\n       0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,\n       8,    10,   0,    117,  0x04, 0x05, 0x03, 0x06, 0x02, 0x07, 0x01, 0x08,\n       0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34,\n       0x35, 0x36, 0x39, 0x79, 0x57, 0x58, 0x59, 0x28, 0x56, 0x78, 0x27, 0x41,\n       0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69,\n       0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88, 0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8,\n       0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a,\n       0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a, 0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6,\n       0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5,\n       0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1, 0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3,\n       0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint LibRaw::canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid LibRaw::canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  try\n  {\n    for (row = 0; row < raw_height; row += 8)\n    {\n      checkCancel();\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n  FORC(2) free(huff[c]);\n}\n\nint LibRaw::ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide ||\n      !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 16);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid LibRaw::ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint LibRaw::ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *LibRaw::ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid LibRaw::lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n  try\n  {\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n      checkCancel();\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  ljpeg_end(&jh);\n}\n\nvoid LibRaw::canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n  int saved_w = width, saved_h = height;\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n        checkCancel();\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n          if (imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] =\n                  ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options &\n                   LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n\n  try\n  {\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281ULL ||\n        (unique_id == 0x80000218ULL && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n      checkCancel();\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n    if (!(imgdata.params.raw_processing_options &\n          LIBRAW_PROCESSING_SRAW_NO_RGB))\n      for (; rp < ip[0]; rp += 4)\n      {\n        checkCancel();\n        if (unique_id == 0x80000218ULL || unique_id == 0x80000250ULL ||\n            unique_id == 0x80000261ULL || unique_id == 0x80000281ULL ||\n            unique_id == 0x80000287ULL)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218ULL)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP15(pix[c] * sraw_mul[c] >> 10);\n      }\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid LibRaw::ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {\n      0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,\n      12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28,\n      35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,\n      58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63,\n      63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid LibRaw::pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\nvoid LibRaw::nikon_read_curve()\n{\n  ushort ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, step, max;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && (ver1 == 0x20 || (ver1 == 0x40 && step > 3)) && step > 0)\n  {\n    if (ver1 == 0x40)\n    {\n      step /= 4;\n      max /= 4;\n    }\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) +\n                  curve[i - i % step + step] * (i % step)) /\n                 step;\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n}\n\nvoid LibRaw::nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0,\n       0,    0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0,\n       0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2];\n  int i, min, max, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if (ver0 == 0x44 && (ver1 == 0x20 || ver1 == 0x40))\n  {\n    if (ver1 == 0x40)\n      max /= 4;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n\n  while (max > 2 && (curve[max - 2] == curve[max - 1]))\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  try\n  {\n    for (min = row = 0; row < height; row++)\n    {\n      checkCancel();\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n  free(huff);\n}\n\nvoid LibRaw::nikon_yuv_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] =\n          curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\nvoid LibRaw::rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n  if (raw_width > 32767 || raw_height > 32767)\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n  unsigned maxpixel = raw_width * (raw_height + 7);\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n    checkCancel();\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      if (todo[i] < maxpixel)\n        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n      else\n        derror();\n  }\n  maximum = 0x3ff;\n}\n\nvoid LibRaw::nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n  try\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      checkCancel();\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid LibRaw::canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n  }\n  free(words);\n  maximum = curve[0x3ff];\n}\n\nunsigned LibRaw::pana_data(int nb, unsigned *bytes)\n{\n#ifndef LIBRAW_NOTHREADS\n#define vpos tls->pana_data.vpos\n#define buf tls->pana_data.buf\n#else\n  static uchar buf[0x4002];\n  static int vpos;\n#endif\n  int byte;\n\n  if (!nb && !bytes)\n    return vpos = 0;\n\n  if (!vpos)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n\n  if (pana_encoding == 5)\n  {\n    for (byte = 0; byte < 16; byte++)\n    {\n      bytes[byte] = buf[vpos++];\n      vpos &= 0x3FFF;\n    }\n  }\n  else\n  {\n    vpos = (vpos - nb) & 0x1ffff;\n    byte = vpos >> 3 ^ 0x3ff0;\n    return (buf[byte] | buf[byte + 1] << 8) >> (vpos & 7) & ~((~0u) << nb);\n  }\n  return 0;\n#ifndef LIBRAW_NOTHREADS\n#undef vpos\n#undef buf\n#endif\n}\n\nvoid LibRaw::panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  unsigned bytes[16];\n  ushort *raw_block_data;\n\n  pana_data(0, 0);\n\n  int enc_blck_size = pana_bpp == 12 ? 10 : 9;\n  if (pana_encoding == 5)\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      raw_block_data = raw_image + row * raw_width;\n      checkCancel();\n      for (col = 0; col < raw_width; col += enc_blck_size)\n      {\n        pana_data(0, bytes);\n\n        if (pana_bpp == 12)\n        {\n          raw_block_data[col] = ((bytes[1] & 0xF) << 8) + bytes[0];\n          raw_block_data[col + 1] = 16 * bytes[2] + (bytes[1] >> 4);\n          raw_block_data[col + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];\n          raw_block_data[col + 3] = 16 * bytes[5] + (bytes[4] >> 4);\n          raw_block_data[col + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];\n          raw_block_data[col + 5] = 16 * bytes[8] + (bytes[7] >> 4);\n          raw_block_data[col + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];\n          raw_block_data[col + 7] = 16 * bytes[11] + (bytes[10] >> 4);\n          raw_block_data[col + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];\n          raw_block_data[col + 9] = 16 * bytes[14] + (bytes[13] >> 4);\n        }\n        else if (pana_bpp == 14)\n        {\n          raw_block_data[col] = bytes[0] + ((bytes[1] & 0x3F) << 8);\n          raw_block_data[col + 1] =\n              (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);\n          raw_block_data[col + 2] =\n              (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);\n          raw_block_data[col + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);\n          raw_block_data[col + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);\n          raw_block_data[col + 5] =\n              (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);\n          raw_block_data[col + 6] =\n              (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);\n          raw_block_data[col + 7] =\n              ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);\n          raw_block_data[col + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);\n        }\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < raw_height; row++)\n    {\n      checkCancel();\n      for (col = 0; col < raw_width; col++)\n      {\n        if ((i = col % 14) == 0)\n          pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n        if (i % 3 == 2)\n          sh = 4 >> (3 - pana_data(2, 0));\n        if (nonz[i & 1])\n        {\n          if ((j = pana_data(8, 0)))\n          {\n            if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n              pred[i & 1] &= ~((~0u) << sh);\n            pred[i & 1] += j << sh;\n          }\n        }\n        else if ((nonz[i & 1] = pana_data(8, 0)) || i > 11)\n          pred[i & 1] = nonz[i & 1] << 4 | pana_data(4, 0);\n        if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width &&\n            row < height)\n          derror();\n      }\n    }\n  }\n}\n\nvoid LibRaw::olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n    checkCancel();\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2\n                              ? pixel[col / 2 - 1] + pixel[col / 2 + 1]\n                              : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid LibRaw::quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2,\n                                  2,   8,   15,  22,  32,  44,  60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},\n                                    {-8, -2, 2, 8},   {-13, -3, 3, 13},\n                                    {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,    2,    3,   4,   5,   6,   7,   8,   9,   11,  12,  13,  14,\n      15,  16,   17,   18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,\n      29,  30,   32,   33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,\n      44,  45,   46,   47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,\n      59,  60,   61,   62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,\n      74,  75,   76,   77,  78,  79,  80,  81,  82,  83,  84,  86,  88,  90,\n      92,  94,   97,   99,  101, 103, 105, 107, 110, 112, 114, 116, 118, 120,\n      123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147, 149, 151,\n      153, 155,  158,  160, 162, 164, 166, 168, 171, 173, 175, 177, 179, 181,\n      184, 186,  188,  190, 192, 195, 197, 199, 201, 203, 205, 208, 210, 212,\n      214, 216,  218,  221, 223, 226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270,  274,  278, 283, 287, 291, 296, 300, 305, 309, 313, 318, 322,\n      326, 331,  335,  339, 344, 348, 352, 357, 361, 365, 370, 374, 379, 383,\n      387, 392,  396,  400, 405, 409, 413, 418, 422, 426, 431, 435, 440, 444,\n      448, 453,  457,  461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,\n      519, 531,  542,  553, 564, 575, 587, 598, 609, 620, 631, 643, 654, 665,\n      676, 687,  698,  710, 721, 732, 743, 754, 766, 777, 788, 799, 810, 822,\n      833, 844,  855,  866, 878, 889, 900, 911, 922, 933, 945, 956, 967, 978,\n      989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  if (width > 640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n    checkCancel();\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] +\n              pixel[row][col - 2]) >>\n             2) +\n            gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n      checkCancel();\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) +\n                ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4\n                      ? 0\n                      : val < 8\n                            ? 1\n                            : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) +\n              rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n    checkCancel();\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) +\n              pixel[row][col + 1]) >>\n             1) -\n            0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\nvoid LibRaw::sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid LibRaw::sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c,\n                                 0xa0b, 0x90a, 0x809, 0x708, 0x607, 0x506,\n                                 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n    checkCancel();\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid LibRaw::sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n  try\n  {\n    for (row = 0; row < height; row++)\n    {\n      checkCancel();\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options &\n                LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] =\n                  ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] =\n                  ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options &\n                 LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n\n        if (imgdata.params.raw_processing_options &\n            LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope =\n                pix[i] < 1001 ? 2\n                              : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) =\n                curve[pix[i] << 1] >\n                        black + imgdata.params.sony_arw2_posterization_thr\n                    ? LIM(((slope * step * 1000) /\n                           (curve[pix[i] << 1] - black)),\n                          0, 10000)\n                    : 0;\n          }\n        }\n        else\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n  free(data);\n}\n\nvoid LibRaw::samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n  if (raw_width > 32768 ||\n      raw_height > 32768) // definitely too much for old samsung\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n  unsigned maxpixels = raw_width * (raw_height + 7);\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        unsigned idest = RAWINDEX(row, col + c);\n        unsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c)\n                             : col ? RAWINDEX(row, col + (c | -2)) : 0);\n        if (idest < maxpixels &&\n            isrc <\n                maxpixels) // less than zero is handled by unsigned conversion\n          RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                              (dir ? RAW(row + (~c | -2), col + c)\n                                   : col ? RAW(row, col + (c | -2)) : 128);\n        else\n          derror();\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid LibRaw::samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403,\n                                 0x600, 0x709, 0x80a, 0x90b, 0xa0c,\n                                 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n    checkCancel();\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          if (i < 0)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        if (col < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if (pmode < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        if (pmode != 7 && row >= 2 && (col - '4' + \"0224468\"[pmode]) < 0)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        pred = (pmode == 7 || row < 2)\n                   ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                   : (prow[col & 1][col - '4' + \"0224468\"[pmode]] +\n                      prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >>\n                         1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\nvoid LibRaw::redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n  bool fastexitflag = false;\n  try\n  {\n    FORC4\n    {\n      checkCancel();\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] =\n              data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] =\n          img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n      checkCancel();\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] +\n             pix[-1] + pix[1]) >>\n            2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n      checkCancel();\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n"], "filenames": ["src/decoders/decoders_dcraw.cpp"], "buggy_code_start_loc": [347], "buggy_code_end_loc": [348], "fixing_code_start_loc": [347], "fixing_code_end_loc": [348], "type": "CWE-125", "message": "In LibRaw, an out-of-bounds read vulnerability exists within the \"LibRaw::adobe_copy_pixel()\" function (libraw\\src\\decoders\\dng.cpp) when reading data from the image file.", "other": {"cve": {"id": "CVE-2020-35533", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-01T18:15:08.920", "lastModified": "2022-09-21T20:26:43.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LibRaw, an out-of-bounds read vulnerability exists within the \"LibRaw::adobe_copy_pixel()\" function (libraw\\src\\decoders\\dng.cpp) when reading data from the image file."}, {"lang": "es", "value": "En LibRaw, se presenta una vulnerabilidad de lectura fuera de l\u00edmites dentro de la funci\u00f3n \"LibRaw::adobe_copy_pixel()\" (libraw\\src\\decoders\\dng.cpp) cuando son le\u00eddos datos del archivo de imagen"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:-:*:*:*:*:*:*", "matchCriteriaId": "E00F0C8F-11AC-42B2-8D85-27028B41EBF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B4B8669B-CE7F-47D2-9111-E7787EAD6E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "8269B02E-558F-4AA5-9EEA-87226A3D1816"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "06DBABB8-8921-4E8B-B9E5-FFE6CCE79EB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.21.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "36C296E2-1899-457B-9EB2-916A33E383C2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/a6937d4046a7c4742b683a04c8564605fd9be4fb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/273", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/a6937d4046a7c4742b683a04c8564605fd9be4fb"}}