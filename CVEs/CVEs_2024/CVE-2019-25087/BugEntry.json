{"buggy_code": ["# HTTP Server\n\nRamsey Kant\nhttps://github.com/RamseyK/httpserver\n\nA high performance, single threaded, HTTP server written in C++ to serve as a kqueue socket management and HTTP protocol learning tool\n\n## Features\n* Clean, documented code\n* Efficient socket management with kqueue\n* Easy to understand HTTP protocol parser (from my ByteBuffer project)\n* Tested on FreeBSD and MacOS\n\n## License\nSee LICENSE.TXT\n", "/**\n\thttpserver\n\tHTTPServer.cpp\n\tCopyright 2011-2019 Ramsey Kant\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n#include \"HTTPServer.h\"\n\n/**\n * Server Constructor\n * Initialize state and server variables\n *\n * @param vhost_aliases List of hostnames the HTTP server will respond to\n * @param port Port the vhost listens on\n * @param diskpath Path to the folder the vhost serves up\n */\nHTTPServer::HTTPServer(std::vector<std::string> vhost_aliases, int port, std::string diskpath) {\n\tcanRun = false;\n\tlistenSocket = INVALID_SOCKET;\n\tlistenPort = port;\n\tkqfd = -1;\n\n\tstd::cout << \"Primary port: \" << port << \", disk path: \" << diskpath.c_str() << std::endl;\n\n\t// Create a resource host serving the base path ./htdocs on disk\n\tResourceHost* resHost = new ResourceHost(diskpath);\n\thostList.push_back(resHost);\n\n\t// Always serve up localhost/127.0.0.1 (which is why we only added one ResourceHost to hostList above)\n\tchar tmpstr[128];\n\tsprintf(tmpstr, \"localhost:%i\", listenPort);\n\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\tsprintf(tmpstr, \"127.0.0.1:%i\", listenPort);\n\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\n\t// Setup the resource host serving htdocs to provide for the vhost aliases\n\tfor (std::string vh : vhost_aliases) {\n\t\tif (vh.length() >= 122) {\n\t\t\tstd::cout << \"vhost \" << vh << \" too long, skipping!\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::cout << \"vhost: \" << vh << std::endl;\n\t\tsprintf(tmpstr, \"%s:%i\", vh.c_str(), listenPort);\n\t\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\t}\n}\n\n/**\n * Server Destructor\n * Removes all resources created in the constructor\n */\nHTTPServer::~HTTPServer() {\n\t// Loop through hostList and delete all ResourceHosts\n\twhile (!hostList.empty()) {\n\t\tResourceHost* resHost = hostList.back();\n\t\tdelete resHost;\n\t\thostList.pop_back();\n\t}\n\tvhosts.clear();\n}\n\n/**\n * Start Server\n * Initialize the Server Socket by requesting a socket handle, binding, and going into a listening state\n *\n * @return True if initialization succeeded. False if otherwise\n */\nbool HTTPServer::start() {\n\tcanRun = false;\n\n\t// Create a handle for the listening socket, TCP\n\tlistenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (listenSocket == INVALID_SOCKET) {\n\t\tstd::cout << \"Could not create socket!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Set socket as non blocking\n\tfcntl(listenSocket, F_SETFL, O_NONBLOCK);\n\n\t// Populate the server address structure\n\t// modify to support multiple address families (bottom): http://eradman.com/posts/kqueue-tcp.html\n\tmemset(&serverAddr, 0, sizeof(struct sockaddr_in)); // clear the struct\n\tserverAddr.sin_family = AF_INET; // Family: IP protocol\n\tserverAddr.sin_port = htons(listenPort); // Set the port (convert from host to netbyte order)\n\tserverAddr.sin_addr.s_addr = INADDR_ANY; // Let OS intelligently select the server's host address\n\n\t// Bind: Assign the address to the socket\n\tif (bind(listenSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) != 0) {\n\t\tstd::cout << \"Failed to bind to the address!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Listen: Put the socket in a listening state, ready to accept connections\n\t// Accept a backlog of the OS Maximum connections in the queue\n\tif (listen(listenSocket, SOMAXCONN) != 0) {\n\t\tstd::cout << \"Failed to put the socket in a listening state\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Setup kqueue\n\tkqfd = kqueue();\n\tif (kqfd == -1) {\n\t\tstd::cout << \"Could not create the kernel event queue!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Have kqueue watch the listen socket\n\tupdateEvent(listenSocket, EVFILT_READ, EV_ADD, 0, 0, NULL);\n\n\tcanRun = true;\n\tstd::cout << \"Server ready. Listening on port \" << listenPort << \"...\" << std::endl;\n\treturn true;\n}\n\n/**\n * Stop\n * Disconnect all clients and cleanup all server resources created in start()\n */\nvoid HTTPServer::stop() {\n\tcanRun = false;\n\n\tif (listenSocket != INVALID_SOCKET) {\n\t\t// Close all open connections and delete Client's from memory\n\t\tfor (auto& x : clientMap)\n\t\t\tdisconnectClient(x.second, false);\n\n\t\t// Clear the map\n\t\tclientMap.clear();\n\n\t\t// Remove listening socket from kqueue\n\t\tupdateEvent(listenSocket, EVFILT_READ, EV_DELETE, 0, 0, NULL);\n\n\t\t// Shudown the listening socket and release it to the OS\n\t\tshutdown(listenSocket, SHUT_RDWR);\n\t\tclose(listenSocket);\n\t\tlistenSocket = INVALID_SOCKET;\n\t}\n\n\tif (kqfd != -1) {\n\t\tclose(kqfd);\n\t\tkqfd = -1;\n\t}\n\n\tstd::cout << \"Server shutdown!\" << std::endl;\n}\n\n/**\n * Update Event\n * Update the kqueue by creating the appropriate kevent structure\n * See kqueue documentation for parameter descriptions\n */\nvoid HTTPServer::updateEvent(int ident, short filter, u_short flags, u_int fflags, int data, void *udata) {\n\tstruct kevent kev;\n\tEV_SET(&kev, ident, filter, flags, fflags, data, udata);\n\tkevent(kqfd, &kev, 1, NULL, 0, NULL);\n}\n\n/**\n * Server Process\n * Main server processing function that checks for any new connections or data to read on\n * the listening socket\n */\nvoid HTTPServer::process() {\n\tint nev = 0; // Number of changed events returned by kevent\n\tClient* cl = NULL;\n\tstruct kevent read_kev, write_kev;\n\n\twhile (canRun) {\n\t\t// Get a list of changed socket descriptors with a read event triggered in evList\n\t\t// Timeout set in the header\n\t\tnev = kevent(kqfd, NULL, 0, evList, QUEUE_SIZE, &kqTimeout);\n\n\t\tif (nev <= 0)\n\t\t\tcontinue;\n\n\t\t// Loop through only the sockets that have changed in the evList array\n\t\tfor (int i = 0; i < nev; i++) {\n\t\t\tif (evList[i].ident == (unsigned int)listenSocket) { // A client is waiting to connect\n\t\t\t\tacceptConnection();\n\t\t\t} else { // Client descriptor has triggered an event\n\t\t\t\tcl = getClient(evList[i].ident); // ident contains the clients socket descriptor\n\t\t\t\tif (cl == NULL) {\n\t\t\t\t\tstd::cout << \"Could not find client\" << std::endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Client wants to disconnect\n\t\t\t\tif (evList[i].flags & EV_EOF) {\n\t\t\t\t\tdisconnectClient(cl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Clear kevent structures\n\t\t\t\tmemset(&read_kev, 0, sizeof(struct kevent));\n\t\t\t\tmemset(&write_kev, 0, sizeof(struct kevent));\n\n\t\t\t\tif (evList[i].filter == EVFILT_READ) {\n\t\t\t\t\t//std::cout << \"read filter \" << evList[i].data << \" bytes available\" << std::endl;\n\t\t\t\t\t// Read and process any pending data on the wire\n\t\t\t\t\treadClient(cl, evList[i].data); // data contains the number of bytes waiting to be read\n\n\t\t\t\t\t// Have kqueue disable tracking of READ events and enable tracking of WRITE events\n\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_READ, EV_DISABLE, 0, 0, NULL);\n\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_WRITE, EV_ENABLE, 0, 0, NULL);\n\t\t\t\t} else if (evList[i].filter == EVFILT_WRITE) {\n\t\t\t\t\t//std::cout << \"write filter with \" << evList[i].data << \" bytes available\" << std::endl;\n\t\t\t\t\t// Write any pending data to the client - writeClient returns true if there is additional data to send in the client queue\n\t\t\t\t\tif (!writeClient(cl, evList[i].data)) { // data contains number of bytes that can be written\n\t\t\t\t\t\t//std::cout << \"switch back to read filter\" << std::endl;\n\t\t\t\t\t\t// If theres nothing more to send, Have kqueue disable tracking of WRITE events and enable tracking of READ events\n\t\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_READ, EV_ENABLE, 0, 0, NULL);\n\t\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_WRITE, EV_DISABLE, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // Event loop\n\t} // canRun\n}\n\n/**\n * Accept Connection\n * When a new connection is detected in runServer() this function is called. This attempts to accept the pending\n * connection, instance a Client object, and add to the client Map\n */\nvoid HTTPServer::acceptConnection() {\n\t// Setup new client with prelim address info\n\tsockaddr_in clientAddr;\n\tint clientAddrLen = sizeof(clientAddr);\n\tint clfd = INVALID_SOCKET;\n\n\t// Accept the pending connection and retrive the client descriptor\n\tclfd = accept(listenSocket, (sockaddr*)&clientAddr, (socklen_t*)&clientAddrLen);\n\tif (clfd == INVALID_SOCKET)\n\t\treturn;\n\n\t// Set socket as non blocking\n\tfcntl(clfd, F_SETFL, O_NONBLOCK);\n\n\t// Instance Client object\n\tClient *cl = new Client(clfd, clientAddr);\n\n\t// Add kqueue event to track the new client socket for READ and WRITE events\n\tupdateEvent(clfd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, NULL);\n\tupdateEvent(clfd, EVFILT_WRITE, EV_ADD | EV_DISABLE, 0, 0, NULL); // Disabled initially\n\n\t// Add the client object to the client map\n\tclientMap.insert(std::pair<int, Client*>(clfd, cl));\n\n\t// Print the client's IP on connect\n\tstd::cout << \"[\" << cl->getClientIP() << \"] connected\" << std::endl;\n}\n\n/**\n * Get Client\n * Lookup client based on the socket descriptor number in the clientMap\n *\n * @param clfd Client socket descriptor\n * @return Pointer to Client object if found. NULL otherwise\n */\nClient* HTTPServer::getClient(int clfd) {\n\tauto it = clientMap.find(clfd);\n\n\t// Client wasn't found\n\tif (it == clientMap.end())\n\t\treturn NULL;\n\n\t// Return a pointer to the client object\n\treturn it->second;\n}\n\n/**\n * Disconnect Client\n * Close the client's socket descriptor and release it from the FD map, client map, and memory\n *\n * @param cl Pointer to Client object\n * @param mapErase When true, remove the client from the client map. Needed if operations on the\n * client map are being performed and we don't want to remove the map entry right away\n */\nvoid HTTPServer::disconnectClient(Client *cl, bool mapErase) {\n\tif (cl == NULL)\n\t\treturn;\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] disconnected\" << std::endl;\n\n\t// Remove socket events from kqueue\n\tupdateEvent(cl->getSocket(), EVFILT_READ, EV_DELETE, 0, 0, NULL);\n\tupdateEvent(cl->getSocket(), EVFILT_WRITE, EV_DELETE, 0, 0, NULL);\n\n\t// Close the socket descriptor\n\tclose(cl->getSocket());\n\n\t// Remove the client from the clientMap\n\tif (mapErase)\n\t\tclientMap.erase(cl->getSocket());\n\n\t// Delete the client object from memory\n\tdelete cl;\n}\n\n/**\n * Read Client\n * Recieve data from a client that has indicated that it has data waiting. Pass recv'd data to handleRequest()\n * Also detect any errors in the state of the socket\n *\n * @param cl Pointer to Client that sent the data\n * @param data_len Number of bytes waiting to be read\n */\nvoid HTTPServer::readClient(Client *cl, int data_len) {\n\tif (cl == NULL)\n\t\treturn;\n\n\t// If the read filter triggered with 0 bytes of data, client may want to disconnect\n\t// Set data_len to the Ethernet max MTU by default\n\tif (data_len <= 0)\n\t\tdata_len = 1400;\n\n\tHTTPRequest* req;\n\tchar* pData = new char[data_len];\n\n\t// Receive data on the wire into pData\n\t/* TODO: Figure out what flags need to be set */\n\tint flags = 0;\n\tssize_t lenRecv = recv(cl->getSocket(), pData, data_len, flags);\n\n\t// Determine state of the client socket and act on it\n\tif (lenRecv == 0) {\n\t\t// Client closed the connection\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] has opted to close the connection\" << std::endl;\n\t\tdisconnectClient(cl);\n\t} else if (lenRecv < 0) {\n\t\t// Something went wrong with the connection\n\t\t// TODO: check perror() for the specific error message\n\t\tdisconnectClient(cl);\n\t} else {\n\t\t// Data received: Place the data in an HTTPRequest and pass it to handleRequest for processing\n\t\treq = new HTTPRequest((byte*)pData, lenRecv);\n\t\thandleRequest(cl, req);\n\t\tdelete req;\n\t}\n\n\tdelete [] pData;\n}\n\n/**\n * Write Client\n * Client has indicated it is read for writing. Write avail_bytes number of bytes to the socket if the send queue has an item\n *\n * @param cl Pointer to Client that sent the data\n * @param avail_bytes Number of bytes available for writing in the send buffer\n */\nbool HTTPServer::writeClient(Client* cl, int avail_bytes) {\n\tif (cl == NULL)\n\t\treturn false;\n\n\tint actual_sent = 0; // Actual number of bytes sent as returned by send()\n\tint attempt_sent = 0; // Bytes that we're attempting to send now\n\tint remaining = 0; // Size of data left to send for the item\n\tbool disconnect = false;\n\tbyte* pData = NULL;\n\n\t// The amount of available bytes to write, reported by the OS, cant really be trusted...\n\tif (avail_bytes > 1400) {\n\t\t// If the available amount of data is greater than the Ethernet MTU, cap it\n\t\tavail_bytes = 1400;\n\t} else if (avail_bytes == 0) {\n\t\t// Sometimes OS reports 0 when its possible to send data - attempt to trickle data\n\t\t// OS will eventually increase avail_bytes\n\t\tavail_bytes = 64;\n\t}\n\n\tSendQueueItem* item = cl->nextInSendQueue();\n\tif (item == NULL)\n\t\treturn false;\n\n\tpData = item->getData();\n\tremaining = item->getSize() - item->getOffset();\n\tdisconnect = item->getDisconnect();\n\n\tif (avail_bytes >= remaining) {\n\t\t// Send buffer is bigger than we need, rest of item can be sent\n\t\tattempt_sent = remaining;\n\t} else {\n\t\t// Send buffer is smaller than we need, send the amount thats available\n\t\tattempt_sent = avail_bytes;\n\t}\n\n\t// Send the data and increment the offset by the actual amount sent\n\tactual_sent = send(cl->getSocket(), pData + (item->getOffset()), attempt_sent, 0);\n\tif (actual_sent >= 0)\n\t\titem->setOffset(item->getOffset() + actual_sent);\n\telse\n\t\tdisconnect = true;\n\n\t//std::cout << \"[\" << cl->getClientIP() << \"] was sent \" << actual_sent << \" bytes \" << std::endl;\n\n\t// SendQueueItem isnt needed anymore. Dequeue and delete\n\tif (item->getOffset() >= item->getSize())\n\t\tcl->dequeueFromSendQueue();\n\n\tif (disconnect) {\n\t\tdisconnectClient(cl);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Handle Request\n * Process an incoming request from a Client. Send request off to appropriate handler function\n * that corresponds to an HTTP operation (GET, HEAD etc) :)\n *\n * @param cl Client object where request originated from\n * @param req HTTPRequest object filled with raw packet data\n */\nvoid HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\t// Parse the request\n\t// If there's an error, report it and send a server error in response\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\t/*std::cout << \"Headers:\" << std::endl;\n\tfor(int i = 0; i < req->getNumHeaders(); i++) {\n\t\tstd::cout << req->getHeaderStr(i) << std::endl;\n\t}\n\tstd::cout << std::endl;*/\n\n\t// Determine the appropriate vhost\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\n\t// Retrieve the host specified in the request (Required for HTTP/1.1 compliance)\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\n\t\t// All vhosts have the port appended, so need to append it to the host if it doesnt exist\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\t// Temporary: HTTP/1.0 are given the first ResouceHost in the hostList\n\t\t// TODO: Allow admin to specify a 'default resource host'\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\n\t// ResourceHost couldnt be determined or the Host specified by the client was invalid\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\n\t// Send the request to the correct handler function\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}\n\n/**\n * Handle Get or Head\n * Process a GET or HEAD request to provide the client with an appropriate response\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n * @param resHost Resource host to service the request\n */\nvoid HTTPServer::handleGet(Client* cl, HTTPRequest* req, ResourceHost* resHost) {\n\t// Check if the requested resource exists\n\tstd::string uri = req->getRequestUri();\n\tResource* r = resHost->getResource(uri);\n\n\tif (r != NULL) { // Exists\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << \"Sending file: \" << uri << std::endl;\n\n\t\tHTTPResponse* resp = new HTTPResponse();\n\t\tresp->setStatus(Status(OK));\n\t\tresp->addHeader(\"Content-Type\", r->getMimeType());\n\t\tresp->addHeader(\"Content-Length\", r->getSize());\n\n\t\t// Only send a message body if it's a GET request. Never send a body for HEAD\n\t\tif (req->getMethod() == Method(GET))\n\t\t\tresp->setData(r->getData(), r->getSize());\n\n\t\tbool dc = false;\n\n\t\t// HTTP/1.0 should close the connection by default\n\t\tif (req->getVersion().compare(HTTP_VERSION_10) == 0)\n\t\t\tdc = true;\n\n\t\t// If Connection: close is specified, the connection should be terminated after the request is serviced\n\t\tstd::string connection_val = req->getHeaderValue(\"Connection\");\n\t\tif (connection_val.compare(\"close\") == 0)\n\t\t\tdc = true;\n\n\t\tsendResponse(cl, resp, dc);\n\t\tdelete resp;\n\t\tdelete r;\n\t} else { // Not found\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << \"File not found: \" << uri << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_FOUND));\n\t}\n}\n\n/**\n * Handle Options\n * Process a OPTIONS request\n * OPTIONS: Return allowed capabilties for the server (*) or a particular resource\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n */\nvoid HTTPServer::handleOptions(Client* cl, HTTPRequest* req) {\n\t// For now, we'll always return the capabilities of the server instead of figuring it out for each resource\n\tstd::string allow = \"HEAD, GET, OPTIONS, TRACE\";\n\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(OK));\n\tresp->addHeader(\"Allow\", allow.c_str());\n\tresp->addHeader(\"Content-Length\", \"0\"); // Required\n\n\tsendResponse(cl, resp, true);\n\tdelete resp;\n}\n\n/**\n * Handle Trace\n * Process a TRACE request\n * TRACE: send back the request as received by the server verbatim\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n */\nvoid HTTPServer::handleTrace(Client* cl, HTTPRequest *req) {\n\t// Get a byte array representation of the request\n\tunsigned int len = req->size();\n\tbyte* buf = new byte[len];\n\treq->setReadPos(0); // Set the read position at the beginning since the request has already been read to the end\n\treq->getBytes(buf, len);\n\n\t// Send a response with the entire request as the body\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(OK));\n\tresp->addHeader(\"Content-Type\", \"message/http\");\n\tresp->addHeader(\"Content-Length\", len);\n\tresp->setData(buf, len);\n\tsendResponse(cl, resp, true);\n\n\tdelete resp;\n\tdelete[] buf;\n}\n\n/**\n * Send Status Response\n * Send a predefined HTTP status code response to the client consisting of\n * only the status code and required headers, then disconnect the client\n *\n * @param cl Client to send the status code to\n * @param status Status code corresponding to the enum in HTTPMessage.h\n * @param msg An additional message to append to the body text\n */\nvoid HTTPServer::sendStatusResponse(Client* cl, int status, std::string msg) {\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(status));\n\n\t// Body message: Reason string + additional msg\n\tstd::string body = resp->getReason() + \": \" + msg;\n\tunsigned int slen = body.length();\n\tchar* sdata = new char[slen];\n\tstrncpy(sdata, body.c_str(), slen);\n\n\tresp->addHeader(\"Content-Type\", \"text/plain\");\n\tresp->addHeader(\"Content-Length\", slen);\n\tresp->setData((byte*)sdata, slen);\n\n\tsendResponse(cl, resp, true);\n\n\tdelete resp;\n}\n\n/**\n * Send Response\n * Send a generic HTTPResponse packet data to a particular Client\n *\n * @param cl Client to send data to\n * @param buf ByteBuffer containing data to be sent\n * @param disconnect Should the server disconnect the client after sending (Optional, default = false)\n */\nvoid HTTPServer::sendResponse(Client* cl, HTTPResponse* resp, bool disconnect) {\n\t// Server Header\n\tresp->addHeader(\"Server\", \"httpserver/1.0\");\n\n\t// Time stamp the response with the Date header\n\tstd::string tstr;\n\tchar tbuf[36];\n\ttime_t rawtime;\n\tstruct tm* ptm;\n\ttime(&rawtime);\n\tptm = gmtime(&rawtime);\n\t// Ex: Fri, 31 Dec 1999 23:59:59 GMT\n\tstrftime(tbuf, 36, \"%a, %d %b %Y %H:%M:%S GMT\", ptm);\n\ttstr = tbuf;\n\tresp->addHeader(\"Date\", tstr);\n\n\t// Include a Connection: close header if this is the final response sent by the server\n\tif (disconnect)\n\t\tresp->addHeader(\"Connection\", \"close\");\n\n\t// Get raw data by creating the response (we are responsible for cleaning it up in process())\n\tbyte* pData = resp->create();\n\n\t// Add data to the Client's send queue\n\tcl->addToSendQueue(new SendQueueItem(pData, resp->size(), disconnect));\n}\n\n\n", "/**\n\thttpserver\n\tResourceHost.cpp\n\tCopyright 2011-2019 Ramsey Kant\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n#include \"ResourceHost.h\"\n\nResourceHost::ResourceHost(std::string base) {\n\tbaseDiskPath = base;\n\n\t// Check to see if the disk base path is a valid path\n\n}\n\nResourceHost::~ResourceHost() {\n}\n\n/**\n * Looks up a MIME type in the dictionary\n *\n * @param ext File extension to use for the lookup\n * @return MIME type as a String. If type could not be found, returns the default 'text/html'\n */\nstd::string ResourceHost::lookupMimeType(std::string ext) {\n\tstd::unordered_map<std::string, std::string>::const_iterator it = mimeMap.find(ext);\n\tif (it == mimeMap.end())\n\t\treturn \"text/html\";\n\n\treturn it->second;\n}\n\n/**\n * Read File\n * Read a file from disk and return the appropriate Resource object\n *\n * @param path Full disk path of the file\n * @param sb Filled in stat struct\n * @return Return's the resource object upon successful load\n */\nResource* ResourceHost::readFile(std::string path, struct stat sb) {\n\t// Make sure the webserver USER owns the file\n\tif (!(sb.st_mode & S_IRWXU))\n\t\treturn NULL;\n\n\tstd::ifstream file;\n\tunsigned int len = 0;\n\n\t// Open the file\n\tfile.open(path.c_str(), std::ios::binary);\n\n\t// Return null if the file failed to open\n\tif (!file.is_open())\n\t\treturn NULL;\n\n\t// Get the length of the file\n\t/*file.seekg(0, std::ios::end);\n\tlen = file.tellg();\n\tfile.seekg(0, std::ios::beg);*/\n\tlen = sb.st_size;\n\n\t// Allocate memory for contents of file and read in the contents\n\tbyte* fdata = new byte[len];\n\tfile.read((char*)fdata, len);\n\n\t// Close the file\n\tfile.close();\n\n\t// Create a new Resource object and setup it's contents\n\tResource* res = new Resource(path);\n\tres->setMimeType(lookupMimeType(res->getExtension()));\n\tres->setData(fdata, len);\n\n\treturn res;\n}\n\n/**\n * Read Directory\n * Read a directory (list or index) from disk into a Resource object\n *\n * @param path Full disk path of the file\n * @param sb Filled in stat struct\n * @return Return's the resource object upon successful load\n */\nResource* ResourceHost::readDirectory(std::string path, struct stat sb) {\n\tResource* res = NULL;\n\t// Make the path end with a / (for consistency) if it doesnt already\n\tif (path.empty() || path[path.length() - 1] != '/')\n\t\tpath += \"/\";\n\n\t// Probe for valid indexes\n\tint numIndexes = sizeof(validIndexes) / sizeof(*validIndexes);\n\tstd::string loadIndex;\n\tstruct stat sidx;\n\tfor (int i = 0; i < numIndexes; i++) {\n\t\tloadIndex = path + validIndexes[i];\n\t\t// Found a suitable index file to load and return to the client\n\t\tif (stat(loadIndex.c_str(), &sidx) != -1)\n\t\t\treturn readFile(loadIndex.c_str(), sidx);\n\t}\n\n\t// Make sure the webserver USER owns the directory\n\tif (!(sb.st_mode & S_IRWXU))\n\t\treturn NULL;\n\n\t// Generate an HTML directory listing\n\tstd::string listing = generateDirList(path);\n\n\tunsigned int slen = listing.length();\n\tchar* sdata = new char[slen];\n\tstrncpy(sdata, listing.c_str(), slen);\n\n\tres = new Resource(path, true);\n\tres->setMimeType(\"text/html\");\n\tres->setData((byte*)sdata, slen);\n\n\treturn res;\n}\n\n/**\n * Return an HTML directory listing provided by the relative path dirPath\n *\n * @param path Full disk path of the file\n * @return HTML string representation of the directory. Blank string if invalid directory\n */\nstd::string ResourceHost::generateDirList(std::string path) {\n\t// Get just the relative uri from the entire path by stripping out the baseDiskPath from the beginning\n\tsize_t uri_pos = path.find_last_of(baseDiskPath);\n\tstd::string uri = \"?\";\n\tif (uri_pos != std::string::npos)\n\t\turi = path.substr(uri_pos);\n\n\tstd::stringstream ret;\n\tret << \"<html><head><title>\" << uri << \"</title></head><body>\";\n\n\tDIR *dir;\n\tstruct dirent *ent;\n\n\tdir = opendir(path.c_str());\n\tif (dir == NULL)\n\t\treturn \"\";\n\n\t// Page title, displaying the URI of the directory being listed\n\tret << \"<h1>Index of \" << uri << \"</h1><hr /><br />\";\n\n\t// Add all files and directories to the return\n\twhile ((ent = readdir(dir)) != NULL) {\n\t\t// Skip any 'hidden' files (starting with a '.')\n\t\tif (ent->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t// Display link to object in directory:\n\t\tret << \"<a href=\\\"\" << uri << ent->d_name << \"\\\">\" << ent->d_name << \"</a><br />\";\n\t}\n\n\t// Close the directory\n\tclosedir(dir);\n\n\tret << \"</body></html>\";\n\n\treturn ret.str();\n}\n\n/**\n * Retrieve a resource from the File system\n *\n * @param uri The URI sent in the request\n * @return NULL if unable to load the resource. Resource object\n */\nResource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\n\t// Gather info about the resource with stat: determine if it's a directory or file, check if its owned by group/user, modify times\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; // File not found\n\n\t// Determine file type\n\tif (sb.st_mode & S_IFDIR) { // Directory\n\t\t// Read a directory list or index into memory from FS\n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { // Regular file\n\t\t// Attempt to load the file into memory from the FS\n\t\tres = readFile(path, sb);\n\t} else { // Something else..device, socket, symlink\n\t\treturn NULL;\n\t}\n\n\treturn res;\n}\n"], "fixing_code": ["# HTTP Server\n\nRamsey Kant\nhttps://github.com/RamseyK/httpserver\n\nA high performance, single threaded, HTTP server written in C++ to serve as a kqueue socket management and HTTP protocol learning tool on BSD systems\n\n## Features\n* Clean, documented code\n* Efficient socket management with kqueue\n* Easy to understand HTTP protocol parser (from my ByteBuffer project)\n* Tested on FreeBSD and MacOS\n\n## Compiling Notes\n* On FreeBSD, compile with gmake\n\n## License\nSee LICENSE.TXT\n", "/**\n\thttpserver\n\tHTTPServer.cpp\n\tCopyright 2011-2019 Ramsey Kant\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n#include \"HTTPServer.h\"\n\n/**\n * Server Constructor\n * Initialize state and server variables\n *\n * @param vhost_aliases List of hostnames the HTTP server will respond to\n * @param port Port the vhost listens on\n * @param diskpath Path to the folder the vhost serves up\n */\nHTTPServer::HTTPServer(std::vector<std::string> vhost_aliases, int port, std::string diskpath) {\n\tcanRun = false;\n\tlistenSocket = INVALID_SOCKET;\n\tlistenPort = port;\n\tkqfd = -1;\n\n\tstd::cout << \"Primary port: \" << port << \", disk path: \" << diskpath.c_str() << std::endl;\n\n\t// Create a resource host serving the base path ./htdocs on disk\n\tResourceHost* resHost = new ResourceHost(diskpath);\n\thostList.push_back(resHost);\n\n\t// Always serve up localhost/127.0.0.1 (which is why we only added one ResourceHost to hostList above)\n\tchar tmpstr[128];\n\tsprintf(tmpstr, \"localhost:%i\", listenPort);\n\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\tsprintf(tmpstr, \"127.0.0.1:%i\", listenPort);\n\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\n\t// Setup the resource host serving htdocs to provide for the vhost aliases\n\tfor (std::string vh : vhost_aliases) {\n\t\tif (vh.length() >= 122) {\n\t\t\tstd::cout << \"vhost \" << vh << \" too long, skipping!\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::cout << \"vhost: \" << vh << std::endl;\n\t\tsprintf(tmpstr, \"%s:%i\", vh.c_str(), listenPort);\n\t\tvhosts.insert(std::pair<std::string, ResourceHost*>(std::string(tmpstr).c_str(), resHost));\n\t}\n}\n\n/**\n * Server Destructor\n * Removes all resources created in the constructor\n */\nHTTPServer::~HTTPServer() {\n\t// Loop through hostList and delete all ResourceHosts\n\twhile (!hostList.empty()) {\n\t\tResourceHost* resHost = hostList.back();\n\t\tdelete resHost;\n\t\thostList.pop_back();\n\t}\n\tvhosts.clear();\n}\n\n/**\n * Start Server\n * Initialize the Server Socket by requesting a socket handle, binding, and going into a listening state\n *\n * @return True if initialization succeeded. False if otherwise\n */\nbool HTTPServer::start() {\n\tcanRun = false;\n\n\t// Create a handle for the listening socket, TCP\n\tlistenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (listenSocket == INVALID_SOCKET) {\n\t\tstd::cout << \"Could not create socket!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Set socket as non blocking\n\tfcntl(listenSocket, F_SETFL, O_NONBLOCK);\n\n\t// Populate the server address structure\n\t// modify to support multiple address families (bottom): http://eradman.com/posts/kqueue-tcp.html\n\tmemset(&serverAddr, 0, sizeof(struct sockaddr_in)); // clear the struct\n\tserverAddr.sin_family = AF_INET; // Family: IP protocol\n\tserverAddr.sin_port = htons(listenPort); // Set the port (convert from host to netbyte order)\n\tserverAddr.sin_addr.s_addr = INADDR_ANY; // Let OS intelligently select the server's host address\n\n\t// Bind: Assign the address to the socket\n\tif (bind(listenSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) != 0) {\n\t\tstd::cout << \"Failed to bind to the address!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Listen: Put the socket in a listening state, ready to accept connections\n\t// Accept a backlog of the OS Maximum connections in the queue\n\tif (listen(listenSocket, SOMAXCONN) != 0) {\n\t\tstd::cout << \"Failed to put the socket in a listening state\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Setup kqueue\n\tkqfd = kqueue();\n\tif (kqfd == -1) {\n\t\tstd::cout << \"Could not create the kernel event queue!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Have kqueue watch the listen socket\n\tupdateEvent(listenSocket, EVFILT_READ, EV_ADD, 0, 0, NULL);\n\n\tcanRun = true;\n\tstd::cout << \"Server ready. Listening on port \" << listenPort << \"...\" << std::endl;\n\treturn true;\n}\n\n/**\n * Stop\n * Disconnect all clients and cleanup all server resources created in start()\n */\nvoid HTTPServer::stop() {\n\tcanRun = false;\n\n\tif (listenSocket != INVALID_SOCKET) {\n\t\t// Close all open connections and delete Client's from memory\n\t\tfor (auto& x : clientMap)\n\t\t\tdisconnectClient(x.second, false);\n\n\t\t// Clear the map\n\t\tclientMap.clear();\n\n\t\t// Remove listening socket from kqueue\n\t\tupdateEvent(listenSocket, EVFILT_READ, EV_DELETE, 0, 0, NULL);\n\n\t\t// Shudown the listening socket and release it to the OS\n\t\tshutdown(listenSocket, SHUT_RDWR);\n\t\tclose(listenSocket);\n\t\tlistenSocket = INVALID_SOCKET;\n\t}\n\n\tif (kqfd != -1) {\n\t\tclose(kqfd);\n\t\tkqfd = -1;\n\t}\n\n\tstd::cout << \"Server shutdown!\" << std::endl;\n}\n\n/**\n * Update Event\n * Update the kqueue by creating the appropriate kevent structure\n * See kqueue documentation for parameter descriptions\n */\nvoid HTTPServer::updateEvent(int ident, short filter, u_short flags, u_int fflags, int data, void *udata) {\n\tstruct kevent kev;\n\tEV_SET(&kev, ident, filter, flags, fflags, data, udata);\n\tkevent(kqfd, &kev, 1, NULL, 0, NULL);\n}\n\n/**\n * Server Process\n * Main server processing function that checks for any new connections or data to read on\n * the listening socket\n */\nvoid HTTPServer::process() {\n\tint nev = 0; // Number of changed events returned by kevent\n\tClient* cl = NULL;\n\tstruct kevent read_kev, write_kev;\n\n\twhile (canRun) {\n\t\t// Get a list of changed socket descriptors with a read event triggered in evList\n\t\t// Timeout set in the header\n\t\tnev = kevent(kqfd, NULL, 0, evList, QUEUE_SIZE, &kqTimeout);\n\n\t\tif (nev <= 0)\n\t\t\tcontinue;\n\n\t\t// Loop through only the sockets that have changed in the evList array\n\t\tfor (int i = 0; i < nev; i++) {\n\t\t\tif (evList[i].ident == (unsigned int)listenSocket) { // A client is waiting to connect\n\t\t\t\tacceptConnection();\n\t\t\t} else { // Client descriptor has triggered an event\n\t\t\t\tcl = getClient(evList[i].ident); // ident contains the clients socket descriptor\n\t\t\t\tif (cl == NULL) {\n\t\t\t\t\tstd::cout << \"Could not find client\" << std::endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Client wants to disconnect\n\t\t\t\tif (evList[i].flags & EV_EOF) {\n\t\t\t\t\tdisconnectClient(cl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Clear kevent structures\n\t\t\t\tmemset(&read_kev, 0, sizeof(struct kevent));\n\t\t\t\tmemset(&write_kev, 0, sizeof(struct kevent));\n\n\t\t\t\tif (evList[i].filter == EVFILT_READ) {\n\t\t\t\t\t//std::cout << \"read filter \" << evList[i].data << \" bytes available\" << std::endl;\n\t\t\t\t\t// Read and process any pending data on the wire\n\t\t\t\t\treadClient(cl, evList[i].data); // data contains the number of bytes waiting to be read\n\n\t\t\t\t\t// Have kqueue disable tracking of READ events and enable tracking of WRITE events\n\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_READ, EV_DISABLE, 0, 0, NULL);\n\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_WRITE, EV_ENABLE, 0, 0, NULL);\n\t\t\t\t} else if (evList[i].filter == EVFILT_WRITE) {\n\t\t\t\t\t//std::cout << \"write filter with \" << evList[i].data << \" bytes available\" << std::endl;\n\t\t\t\t\t// Write any pending data to the client - writeClient returns true if there is additional data to send in the client queue\n\t\t\t\t\tif (!writeClient(cl, evList[i].data)) { // data contains number of bytes that can be written\n\t\t\t\t\t\t//std::cout << \"switch back to read filter\" << std::endl;\n\t\t\t\t\t\t// If theres nothing more to send, Have kqueue disable tracking of WRITE events and enable tracking of READ events\n\t\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_READ, EV_ENABLE, 0, 0, NULL);\n\t\t\t\t\t\tupdateEvent(evList[i].ident, EVFILT_WRITE, EV_DISABLE, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // Event loop\n\t} // canRun\n}\n\n/**\n * Accept Connection\n * When a new connection is detected in runServer() this function is called. This attempts to accept the pending\n * connection, instance a Client object, and add to the client Map\n */\nvoid HTTPServer::acceptConnection() {\n\t// Setup new client with prelim address info\n\tsockaddr_in clientAddr;\n\tint clientAddrLen = sizeof(clientAddr);\n\tint clfd = INVALID_SOCKET;\n\n\t// Accept the pending connection and retrive the client descriptor\n\tclfd = accept(listenSocket, (sockaddr*)&clientAddr, (socklen_t*)&clientAddrLen);\n\tif (clfd == INVALID_SOCKET)\n\t\treturn;\n\n\t// Set socket as non blocking\n\tfcntl(clfd, F_SETFL, O_NONBLOCK);\n\n\t// Instance Client object\n\tClient *cl = new Client(clfd, clientAddr);\n\n\t// Add kqueue event to track the new client socket for READ and WRITE events\n\tupdateEvent(clfd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, NULL);\n\tupdateEvent(clfd, EVFILT_WRITE, EV_ADD | EV_DISABLE, 0, 0, NULL); // Disabled initially\n\n\t// Add the client object to the client map\n\tclientMap.insert(std::pair<int, Client*>(clfd, cl));\n\n\t// Print the client's IP on connect\n\tstd::cout << \"[\" << cl->getClientIP() << \"] connected\" << std::endl;\n}\n\n/**\n * Get Client\n * Lookup client based on the socket descriptor number in the clientMap\n *\n * @param clfd Client socket descriptor\n * @return Pointer to Client object if found. NULL otherwise\n */\nClient* HTTPServer::getClient(int clfd) {\n\tauto it = clientMap.find(clfd);\n\n\t// Client wasn't found\n\tif (it == clientMap.end())\n\t\treturn NULL;\n\n\t// Return a pointer to the client object\n\treturn it->second;\n}\n\n/**\n * Disconnect Client\n * Close the client's socket descriptor and release it from the FD map, client map, and memory\n *\n * @param cl Pointer to Client object\n * @param mapErase When true, remove the client from the client map. Needed if operations on the\n * client map are being performed and we don't want to remove the map entry right away\n */\nvoid HTTPServer::disconnectClient(Client *cl, bool mapErase) {\n\tif (cl == NULL)\n\t\treturn;\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] disconnected\" << std::endl;\n\n\t// Remove socket events from kqueue\n\tupdateEvent(cl->getSocket(), EVFILT_READ, EV_DELETE, 0, 0, NULL);\n\tupdateEvent(cl->getSocket(), EVFILT_WRITE, EV_DELETE, 0, 0, NULL);\n\n\t// Close the socket descriptor\n\tclose(cl->getSocket());\n\n\t// Remove the client from the clientMap\n\tif (mapErase)\n\t\tclientMap.erase(cl->getSocket());\n\n\t// Delete the client object from memory\n\tdelete cl;\n}\n\n/**\n * Read Client\n * Recieve data from a client that has indicated that it has data waiting. Pass recv'd data to handleRequest()\n * Also detect any errors in the state of the socket\n *\n * @param cl Pointer to Client that sent the data\n * @param data_len Number of bytes waiting to be read\n */\nvoid HTTPServer::readClient(Client *cl, int data_len) {\n\tif (cl == NULL)\n\t\treturn;\n\n\t// If the read filter triggered with 0 bytes of data, client may want to disconnect\n\t// Set data_len to the Ethernet max MTU by default\n\tif (data_len <= 0)\n\t\tdata_len = 1400;\n\n\tHTTPRequest* req;\n\tchar* pData = new char[data_len];\n\n\t// Receive data on the wire into pData\n\t/* TODO: Figure out what flags need to be set */\n\tint flags = 0;\n\tssize_t lenRecv = recv(cl->getSocket(), pData, data_len, flags);\n\n\t// Determine state of the client socket and act on it\n\tif (lenRecv == 0) {\n\t\t// Client closed the connection\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] has opted to close the connection\" << std::endl;\n\t\tdisconnectClient(cl);\n\t} else if (lenRecv < 0) {\n\t\t// Something went wrong with the connection\n\t\t// TODO: check perror() for the specific error message\n\t\tdisconnectClient(cl);\n\t} else {\n\t\t// Data received: Place the data in an HTTPRequest and pass it to handleRequest for processing\n\t\treq = new HTTPRequest((byte*)pData, lenRecv);\n\t\thandleRequest(cl, req);\n\t\tdelete req;\n\t}\n\n\tdelete [] pData;\n}\n\n/**\n * Write Client\n * Client has indicated it is read for writing. Write avail_bytes number of bytes to the socket if the send queue has an item\n *\n * @param cl Pointer to Client that sent the data\n * @param avail_bytes Number of bytes available for writing in the send buffer\n */\nbool HTTPServer::writeClient(Client* cl, int avail_bytes) {\n\tif (cl == NULL)\n\t\treturn false;\n\n\tint actual_sent = 0; // Actual number of bytes sent as returned by send()\n\tint attempt_sent = 0; // Bytes that we're attempting to send now\n\tint remaining = 0; // Size of data left to send for the item\n\tbool disconnect = false;\n\tbyte* pData = NULL;\n\n\t// The amount of available bytes to write, reported by the OS, cant really be trusted...\n\tif (avail_bytes > 1400) {\n\t\t// If the available amount of data is greater than the Ethernet MTU, cap it\n\t\tavail_bytes = 1400;\n\t} else if (avail_bytes == 0) {\n\t\t// Sometimes OS reports 0 when its possible to send data - attempt to trickle data\n\t\t// OS will eventually increase avail_bytes\n\t\tavail_bytes = 64;\n\t}\n\n\tSendQueueItem* item = cl->nextInSendQueue();\n\tif (item == NULL)\n\t\treturn false;\n\n\tpData = item->getData();\n\tremaining = item->getSize() - item->getOffset();\n\tdisconnect = item->getDisconnect();\n\n\tif (avail_bytes >= remaining) {\n\t\t// Send buffer is bigger than we need, rest of item can be sent\n\t\tattempt_sent = remaining;\n\t} else {\n\t\t// Send buffer is smaller than we need, send the amount thats available\n\t\tattempt_sent = avail_bytes;\n\t}\n\n\t// Send the data and increment the offset by the actual amount sent\n\tactual_sent = send(cl->getSocket(), pData + (item->getOffset()), attempt_sent, 0);\n\tif (actual_sent >= 0)\n\t\titem->setOffset(item->getOffset() + actual_sent);\n\telse\n\t\tdisconnect = true;\n\n\t//std::cout << \"[\" << cl->getClientIP() << \"] was sent \" << actual_sent << \" bytes \" << std::endl;\n\n\t// SendQueueItem isnt needed anymore. Dequeue and delete\n\tif (item->getOffset() >= item->getSize())\n\t\tcl->dequeueFromSendQueue();\n\n\tif (disconnect) {\n\t\tdisconnectClient(cl);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Handle Request\n * Process an incoming request from a Client. Send request off to appropriate handler function\n * that corresponds to an HTTP operation (GET, HEAD etc) :)\n *\n * @param cl Client object where request originated from\n * @param req HTTPRequest object filled with raw packet data\n */\nvoid HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\t// Parse the request\n\t// If there's an error, report it and send a server error in response\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\t/*std::cout << \"Headers:\" << std::endl;\n\tfor(int i = 0; i < req->getNumHeaders(); i++) {\n\t\tstd::cout << \"\\t\" << req->getHeaderStr(i) << std::endl;\n\t}\n\tstd::cout << std::endl;*/\n\n\t// Determine the appropriate vhost\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\n\t// Retrieve the host specified in the request (Required for HTTP/1.1 compliance)\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\n\t\t// All vhosts have the port appended, so need to append it to the host if it doesnt exist\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\t// Temporary: HTTP/1.0 are given the first ResouceHost in the hostList\n\t\t// TODO: Allow admin to specify a 'default resource host'\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\n\t// ResourceHost couldnt be determined or the Host specified by the client was invalid\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\n\t// Send the request to the correct handler function\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}\n\n/**\n * Handle Get or Head\n * Process a GET or HEAD request to provide the client with an appropriate response\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n * @param resHost Resource host to service the request\n */\nvoid HTTPServer::handleGet(Client* cl, HTTPRequest* req, ResourceHost* resHost) {\n\t// Check if the requested resource exists\n\tstd::string uri = req->getRequestUri();\n\tResource* r = resHost->getResource(uri);\n\n\tif (r != NULL) { // Exists\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << \"Sending file: \" << uri << std::endl;\n\n\t\tHTTPResponse* resp = new HTTPResponse();\n\t\tresp->setStatus(Status(OK));\n\t\tresp->addHeader(\"Content-Type\", r->getMimeType());\n\t\tresp->addHeader(\"Content-Length\", r->getSize());\n\n\t\t// Only send a message body if it's a GET request. Never send a body for HEAD\n\t\tif (req->getMethod() == Method(GET))\n\t\t\tresp->setData(r->getData(), r->getSize());\n\n\t\tbool dc = false;\n\n\t\t// HTTP/1.0 should close the connection by default\n\t\tif (req->getVersion().compare(HTTP_VERSION_10) == 0)\n\t\t\tdc = true;\n\n\t\t// If Connection: close is specified, the connection should be terminated after the request is serviced\n\t\tstd::string connection_val = req->getHeaderValue(\"Connection\");\n\t\tif (connection_val.compare(\"close\") == 0)\n\t\t\tdc = true;\n\n\t\tsendResponse(cl, resp, dc);\n\t\tdelete resp;\n\t\tdelete r;\n\t} else { // Not found\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << \"File not found: \" << uri << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_FOUND));\n\t}\n}\n\n/**\n * Handle Options\n * Process a OPTIONS request\n * OPTIONS: Return allowed capabilties for the server (*) or a particular resource\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n */\nvoid HTTPServer::handleOptions(Client* cl, HTTPRequest* req) {\n\t// For now, we'll always return the capabilities of the server instead of figuring it out for each resource\n\tstd::string allow = \"HEAD, GET, OPTIONS, TRACE\";\n\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(OK));\n\tresp->addHeader(\"Allow\", allow.c_str());\n\tresp->addHeader(\"Content-Length\", \"0\"); // Required\n\n\tsendResponse(cl, resp, true);\n\tdelete resp;\n}\n\n/**\n * Handle Trace\n * Process a TRACE request\n * TRACE: send back the request as received by the server verbatim\n *\n * @param cl Client requesting the resource\n * @param req State of the request\n */\nvoid HTTPServer::handleTrace(Client* cl, HTTPRequest *req) {\n\t// Get a byte array representation of the request\n\tunsigned int len = req->size();\n\tbyte* buf = new byte[len];\n\treq->setReadPos(0); // Set the read position at the beginning since the request has already been read to the end\n\treq->getBytes(buf, len);\n\n\t// Send a response with the entire request as the body\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(OK));\n\tresp->addHeader(\"Content-Type\", \"message/http\");\n\tresp->addHeader(\"Content-Length\", len);\n\tresp->setData(buf, len);\n\tsendResponse(cl, resp, true);\n\n\tdelete resp;\n\tdelete[] buf;\n}\n\n/**\n * Send Status Response\n * Send a predefined HTTP status code response to the client consisting of\n * only the status code and required headers, then disconnect the client\n *\n * @param cl Client to send the status code to\n * @param status Status code corresponding to the enum in HTTPMessage.h\n * @param msg An additional message to append to the body text\n */\nvoid HTTPServer::sendStatusResponse(Client* cl, int status, std::string msg) {\n\tHTTPResponse* resp = new HTTPResponse();\n\tresp->setStatus(Status(status));\n\n\t// Body message: Reason string + additional msg\n\tstd::string body = resp->getReason() + \": \" + msg;\n\tunsigned int slen = body.length();\n\tchar* sdata = new char[slen];\n\tstrncpy(sdata, body.c_str(), slen);\n\n\tresp->addHeader(\"Content-Type\", \"text/plain\");\n\tresp->addHeader(\"Content-Length\", slen);\n\tresp->setData((byte*)sdata, slen);\n\n\tsendResponse(cl, resp, true);\n\n\tdelete resp;\n}\n\n/**\n * Send Response\n * Send a generic HTTPResponse packet data to a particular Client\n *\n * @param cl Client to send data to\n * @param buf ByteBuffer containing data to be sent\n * @param disconnect Should the server disconnect the client after sending (Optional, default = false)\n */\nvoid HTTPServer::sendResponse(Client* cl, HTTPResponse* resp, bool disconnect) {\n\t// Server Header\n\tresp->addHeader(\"Server\", \"httpserver/1.0\");\n\n\t// Time stamp the response with the Date header\n\tstd::string tstr;\n\tchar tbuf[36];\n\ttime_t rawtime;\n\tstruct tm* ptm;\n\ttime(&rawtime);\n\tptm = gmtime(&rawtime);\n\t// Ex: Fri, 31 Dec 1999 23:59:59 GMT\n\tstrftime(tbuf, 36, \"%a, %d %b %Y %H:%M:%S GMT\", ptm);\n\ttstr = tbuf;\n\tresp->addHeader(\"Date\", tstr);\n\n\t// Include a Connection: close header if this is the final response sent by the server\n\tif (disconnect)\n\t\tresp->addHeader(\"Connection\", \"close\");\n\n\t// Get raw data by creating the response (we are responsible for cleaning it up in process())\n\tbyte* pData = resp->create();\n\n\t// Add data to the Client's send queue\n\tcl->addToSendQueue(new SendQueueItem(pData, resp->size(), disconnect));\n}\n\n\n", "/**\n\thttpserver\n\tResourceHost.cpp\n\tCopyright 2011-2019 Ramsey Kant\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n#include \"ResourceHost.h\"\n\nResourceHost::ResourceHost(std::string base) {\n\tbaseDiskPath = base;\n\n\t// Check to see if the disk base path is a valid path\n\n}\n\nResourceHost::~ResourceHost() {\n}\n\n/**\n * Looks up a MIME type in the dictionary\n *\n * @param ext File extension to use for the lookup\n * @return MIME type as a String. If type could not be found, returns the default 'text/html'\n */\nstd::string ResourceHost::lookupMimeType(std::string ext) {\n\tstd::unordered_map<std::string, std::string>::const_iterator it = mimeMap.find(ext);\n\tif (it == mimeMap.end())\n\t\treturn \"text/html\";\n\n\treturn it->second;\n}\n\n/**\n * Read File\n * Read a file from disk and return the appropriate Resource object\n *\n * @param path Full disk path of the file\n * @param sb Filled in stat struct\n * @return Return's the resource object upon successful load\n */\nResource* ResourceHost::readFile(std::string path, struct stat sb) {\n\t// Make sure the webserver USER owns the file\n\tif (!(sb.st_mode & S_IRWXU))\n\t\treturn NULL;\n\n\tstd::ifstream file;\n\tunsigned int len = 0;\n\n\t// Open the file\n\tfile.open(path.c_str(), std::ios::binary);\n\n\t// Return null if the file failed to open\n\tif (!file.is_open())\n\t\treturn NULL;\n\n\t// Get the length of the file\n\t/*file.seekg(0, std::ios::end);\n\tlen = file.tellg();\n\tfile.seekg(0, std::ios::beg);*/\n\tlen = sb.st_size;\n\n\t// Allocate memory for contents of file and read in the contents\n\tbyte* fdata = new byte[len];\n\tfile.read((char*)fdata, len);\n\n\t// Close the file\n\tfile.close();\n\n\t// Create a new Resource object and setup it's contents\n\tResource* res = new Resource(path);\n\tres->setMimeType(lookupMimeType(res->getExtension()));\n\tres->setData(fdata, len);\n\n\treturn res;\n}\n\n/**\n * Read Directory\n * Read a directory (list or index) from disk into a Resource object\n *\n * @param path Full disk path of the file\n * @param sb Filled in stat struct\n * @return Return's the resource object upon successful load\n */\nResource* ResourceHost::readDirectory(std::string path, struct stat sb) {\n\tResource* res = NULL;\n\t// Make the path end with a / (for consistency) if it doesnt already\n\tif (path.empty() || path[path.length() - 1] != '/')\n\t\tpath += \"/\";\n\n\t// Probe for valid indexes\n\tint numIndexes = sizeof(validIndexes) / sizeof(*validIndexes);\n\tstd::string loadIndex;\n\tstruct stat sidx;\n\tfor (int i = 0; i < numIndexes; i++) {\n\t\tloadIndex = path + validIndexes[i];\n\t\t// Found a suitable index file to load and return to the client\n\t\tif (stat(loadIndex.c_str(), &sidx) != -1)\n\t\t\treturn readFile(loadIndex.c_str(), sidx);\n\t}\n\n\t// Make sure the webserver USER owns the directory\n\tif (!(sb.st_mode & S_IRWXU))\n\t\treturn NULL;\n\n\t// Generate an HTML directory listing\n\tstd::string listing = generateDirList(path);\n\n\tunsigned int slen = listing.length();\n\tchar* sdata = new char[slen];\n\tstrncpy(sdata, listing.c_str(), slen);\n\n\tres = new Resource(path, true);\n\tres->setMimeType(\"text/html\");\n\tres->setData((byte*)sdata, slen);\n\n\treturn res;\n}\n\n/**\n * Return an HTML directory listing provided by the relative path dirPath\n *\n * @param path Full disk path of the file\n * @return HTML string representation of the directory. Blank string if invalid directory\n */\nstd::string ResourceHost::generateDirList(std::string path) {\n\t// Get just the relative uri from the entire path by stripping out the baseDiskPath from the beginning\n\tsize_t uri_pos = path.find_last_of(baseDiskPath);\n\tstd::string uri = \"?\";\n\tif (uri_pos != std::string::npos)\n\t\turi = path.substr(uri_pos);\n\n\tstd::stringstream ret;\n\tret << \"<html><head><title>\" << uri << \"</title></head><body>\";\n\n\tDIR *dir;\n\tstruct dirent *ent;\n\n\tdir = opendir(path.c_str());\n\tif (dir == NULL)\n\t\treturn \"\";\n\n\t// Page title, displaying the URI of the directory being listed\n\tret << \"<h1>Index of \" << uri << \"</h1><hr /><br />\";\n\n\t// Add all files and directories to the return\n\twhile ((ent = readdir(dir)) != NULL) {\n\t\t// Skip any 'hidden' files (starting with a '.')\n\t\tif (ent->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t// Display link to object in directory:\n\t\tret << \"<a href=\\\"\" << uri << ent->d_name << \"\\\">\" << ent->d_name << \"</a><br />\";\n\t}\n\n\t// Close the directory\n\tclosedir(dir);\n\n\tret << \"</body></html>\";\n\n\treturn ret.str();\n}\n\n/**\n * Retrieve a resource from the File system\n *\n * @param uri The URI sent in the request\n * @return NULL if unable to load the resource. Resource object\n */\nResource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\n\t// Gather info about the resource with stat: determine if it's a directory or file, check if its owned by group/user, modify times\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; // File not found\n\n\t// Determine file type\n\tif (sb.st_mode & S_IFDIR) { // Directory\n\t\t// Read a directory list or index into memory from FS\n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { // Regular file\n\t\t// Attempt to load the file into memory from the FS\n\t\tres = readFile(path, sb);\n\t} else { // Something else..device, socket, symlink\n\t\treturn NULL;\n\t}\n\n\treturn res;\n}\n"], "filenames": ["README.md", "src/HTTPServer.cpp", "src/ResourceHost.cpp"], "buggy_code_start_loc": [6, 443, 185], "buggy_code_end_loc": [13, 444, 185], "fixing_code_start_loc": [6, 443, 186], "fixing_code_end_loc": [17, 444, 189], "type": "CWE-22", "message": "A vulnerability was found in RamseyK httpserver. It has been rated as critical. This issue affects the function ResourceHost::getResource of the file src/ResourceHost.cpp of the component URI Handler. The manipulation of the argument uri leads to path traversal: '../filedir'. The attack may be initiated remotely. The name of the patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216863.", "other": {"cve": {"id": "CVE-2019-25087", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T09:15:09.730", "lastModified": "2023-01-06T05:43:42.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in RamseyK httpserver. It has been rated as critical. This issue affects the function ResourceHost::getResource of the file src/ResourceHost.cpp of the component URI Handler. The manipulation of the argument uri leads to path traversal: '../filedir'. The attack may be initiated remotely. The name of the patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216863."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-24"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:httpserver_project:httpserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-09-08", "matchCriteriaId": "0285D36A-BEF1-4CCD-A1DB-D330CAB1EC09"}]}]}], "references": [{"url": "https://github.com/RamseyK/httpserver/commit/1a0de56e4dafff9c2f9c8f6b130a764f7a50df52", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216863", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216863", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/RamseyK/httpserver/commit/1a0de56e4dafff9c2f9c8f6b130a764f7a50df52"}}