{"buggy_code": ["/*\n * Media device\n *\n * Copyright (C) 2010 Nokia Corporation\n *\n * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\n *\t     Sakari Ailus <sakari.ailus@iki.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/ioctl.h>\n#include <linux/media.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/media-devnode.h>\n#include <media/media-entity.h>\n\n/* -----------------------------------------------------------------------------\n * Userspace API\n */\n\nstatic int media_device_open(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_close(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_get_info(struct media_device *dev,\n\t\t\t\t struct media_device_info __user *__info)\n{\n\tstruct media_device_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tstrlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver));\n\tstrlcpy(info.model, dev->model, sizeof(info.model));\n\tstrlcpy(info.serial, dev->serial, sizeof(info.serial));\n\tstrlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info));\n\n\tinfo.media_version = MEDIA_API_VERSION;\n\tinfo.hw_revision = dev->hw_revision;\n\tinfo.driver_version = dev->driver_version;\n\n\tif (copy_to_user(__info, &info, sizeof(*__info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\n{\n\tstruct media_entity *entity;\n\tint next = id & MEDIA_ENT_ID_FLAG_NEXT;\n\n\tid &= ~MEDIA_ENT_ID_FLAG_NEXT;\n\n\tspin_lock(&mdev->lock);\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif ((entity->id == id && !next) ||\n\t\t    (entity->id > id && next)) {\n\t\t\tspin_unlock(&mdev->lock);\n\t\t\treturn entity;\n\t\t}\n\t}\n\n\tspin_unlock(&mdev->lock);\n\n\treturn NULL;\n}\n\nstatic long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = kpad->entity->id;\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}\n\nstatic long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t/* Ignore backlinks. */\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long media_device_enum_links(struct media_device *mdev,\n\t\t\t\t    struct media_links_enum __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tint rval;\n\n\tif (copy_from_user(&links, ulinks, sizeof(links)))\n\t\treturn -EFAULT;\n\n\trval = __media_device_enum_links(mdev, &links);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (copy_to_user(ulinks, &links, sizeof(*ulinks)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long media_device_setup_link(struct media_device *mdev,\n\t\t\t\t    struct media_link_desc __user *_ulink)\n{\n\tstruct media_link *link = NULL;\n\tstruct media_link_desc ulink;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tint ret;\n\n\tif (copy_from_user(&ulink, _ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\t/* Find the source and sink entities and link.\n\t */\n\tsource = find_entity(mdev, ulink.source.entity);\n\tsink = find_entity(mdev, ulink.sink.entity);\n\n\tif (source == NULL || sink == NULL)\n\t\treturn -EINVAL;\n\n\tif (ulink.source.index >= source->num_pads ||\n\t    ulink.sink.index >= sink->num_pads)\n\t\treturn -EINVAL;\n\n\tlink = media_entity_find_link(&source->pads[ulink.source.index],\n\t\t\t\t      &sink->pads[ulink.sink.index]);\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\t/* Setup the link on both entities. */\n\tret = __media_entity_setup_link(link, ulink.flags);\n\n\tif (copy_to_user(_ulink, &ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\t\tret = media_device_get_info(dev,\n\t\t\t\t(struct media_device_info __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\t\tret = media_device_enum_entities(dev,\n\t\t\t\t(struct media_entity_desc __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_LINKS:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links(dev,\n\t\t\t\t(struct media_links_enum __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_setup_link(dev,\n\t\t\t\t(struct media_link_desc __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct media_links_enum32 {\n\t__u32 entity;\n\tcompat_uptr_t pads; /* struct media_pad_desc * */\n\tcompat_uptr_t links; /* struct media_link_desc * */\n\t__u32 reserved[4];\n};\n\nstatic long media_device_enum_links32(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum32 __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tcompat_uptr_t pads_ptr, links_ptr;\n\n\tmemset(&links, 0, sizeof(links));\n\n\tif (get_user(links.entity, &ulinks->entity)\n\t    || get_user(pads_ptr, &ulinks->pads)\n\t    || get_user(links_ptr, &ulinks->links))\n\t\treturn -EFAULT;\n\n\tlinks.pads = compat_ptr(pads_ptr);\n\tlinks.links = compat_ptr(links_ptr);\n\n\treturn __media_device_enum_links(mdev, &links);\n}\n\n#define MEDIA_IOC_ENUM_LINKS32\t\t_IOWR('|', 0x02, struct media_links_enum32)\n\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\treturn media_device_ioctl(filp, cmd, arg);\n\n\tcase MEDIA_IOC_ENUM_LINKS32:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links32(dev,\n\t\t\t\t(struct media_links_enum32 __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_COMPAT */\n\nstatic const struct media_file_operations media_device_fops = {\n\t.owner = THIS_MODULE,\n\t.open = media_device_open,\n\t.ioctl = media_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_device_compat_ioctl,\n#endif /* CONFIG_COMPAT */\n\t.release = media_device_close,\n};\n\n/* -----------------------------------------------------------------------------\n * sysfs\n */\n\nstatic ssize_t show_model(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct media_device *mdev = to_media_device(to_media_devnode(cd));\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(mdev->model), mdev->model);\n}\n\nstatic DEVICE_ATTR(model, S_IRUGO, show_model, NULL);\n\n/* -----------------------------------------------------------------------------\n * Registration/unregistration\n */\n\nstatic void media_device_release(struct media_devnode *mdev)\n{\n}\n\n/**\n * media_device_register - register a media device\n * @mdev:\tThe media device\n *\n * The caller is responsible for initializing the media device before\n * registration. The following fields must be set:\n *\n * - dev must point to the parent device\n * - model must be filled with the device model name\n */\nint __must_check media_device_register(struct media_device *mdev)\n{\n\tint ret;\n\n\tif (WARN_ON(mdev->dev == NULL || mdev->model[0] == 0))\n\t\treturn -EINVAL;\n\n\tmdev->entity_id = 1;\n\tINIT_LIST_HEAD(&mdev->entities);\n\tspin_lock_init(&mdev->lock);\n\tmutex_init(&mdev->graph_mutex);\n\n\t/* Register the device node. */\n\tmdev->devnode.fops = &media_device_fops;\n\tmdev->devnode.parent = mdev->dev;\n\tmdev->devnode.release = media_device_release;\n\tret = media_devnode_register(&mdev->devnode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&mdev->devnode.dev, &dev_attr_model);\n\tif (ret < 0) {\n\t\tmedia_devnode_unregister(&mdev->devnode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register);\n\n/**\n * media_device_unregister - unregister a media device\n * @mdev:\tThe media device\n *\n */\nvoid media_device_unregister(struct media_device *mdev)\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *next;\n\n\tlist_for_each_entry_safe(entity, next, &mdev->entities, list)\n\t\tmedia_device_unregister_entity(entity);\n\n\tdevice_remove_file(&mdev->devnode.dev, &dev_attr_model);\n\tmedia_devnode_unregister(&mdev->devnode);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister);\n\n/**\n * media_device_register_entity - Register an entity with a media device\n * @mdev:\tThe media device\n * @entity:\tThe entity\n */\nint __must_check media_device_register_entity(struct media_device *mdev,\n\t\t\t\t\t      struct media_entity *entity)\n{\n\t/* Warn if we apparently re-register an entity */\n\tWARN_ON(entity->parent != NULL);\n\tentity->parent = mdev;\n\n\tspin_lock(&mdev->lock);\n\tif (entity->id == 0)\n\t\tentity->id = mdev->entity_id++;\n\telse\n\t\tmdev->entity_id = max(entity->id + 1, mdev->entity_id);\n\tlist_add_tail(&entity->list, &mdev->entities);\n\tspin_unlock(&mdev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity);\n\n/**\n * media_device_unregister_entity - Unregister an entity\n * @entity:\tThe entity\n *\n * If the entity has never been registered this function will return\n * immediately.\n */\nvoid media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->parent;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tspin_lock(&mdev->lock);\n\tlist_del(&entity->list);\n\tspin_unlock(&mdev->lock);\n\tentity->parent = NULL;\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity);\n"], "fixing_code": ["/*\n * Media device\n *\n * Copyright (C) 2010 Nokia Corporation\n *\n * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\n *\t     Sakari Ailus <sakari.ailus@iki.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/ioctl.h>\n#include <linux/media.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/media-devnode.h>\n#include <media/media-entity.h>\n\n/* -----------------------------------------------------------------------------\n * Userspace API\n */\n\nstatic int media_device_open(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_close(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_get_info(struct media_device *dev,\n\t\t\t\t struct media_device_info __user *__info)\n{\n\tstruct media_device_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tstrlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver));\n\tstrlcpy(info.model, dev->model, sizeof(info.model));\n\tstrlcpy(info.serial, dev->serial, sizeof(info.serial));\n\tstrlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info));\n\n\tinfo.media_version = MEDIA_API_VERSION;\n\tinfo.hw_revision = dev->hw_revision;\n\tinfo.driver_version = dev->driver_version;\n\n\tif (copy_to_user(__info, &info, sizeof(*__info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\n{\n\tstruct media_entity *entity;\n\tint next = id & MEDIA_ENT_ID_FLAG_NEXT;\n\n\tid &= ~MEDIA_ENT_ID_FLAG_NEXT;\n\n\tspin_lock(&mdev->lock);\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif ((entity->id == id && !next) ||\n\t\t    (entity->id > id && next)) {\n\t\t\tspin_unlock(&mdev->lock);\n\t\t\treturn entity;\n\t\t}\n\t}\n\n\tspin_unlock(&mdev->lock);\n\n\treturn NULL;\n}\n\nstatic long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = kpad->entity->id;\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}\n\nstatic long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t/* Ignore backlinks. */\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long media_device_enum_links(struct media_device *mdev,\n\t\t\t\t    struct media_links_enum __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tint rval;\n\n\tif (copy_from_user(&links, ulinks, sizeof(links)))\n\t\treturn -EFAULT;\n\n\trval = __media_device_enum_links(mdev, &links);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (copy_to_user(ulinks, &links, sizeof(*ulinks)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long media_device_setup_link(struct media_device *mdev,\n\t\t\t\t    struct media_link_desc __user *_ulink)\n{\n\tstruct media_link *link = NULL;\n\tstruct media_link_desc ulink;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tint ret;\n\n\tif (copy_from_user(&ulink, _ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\t/* Find the source and sink entities and link.\n\t */\n\tsource = find_entity(mdev, ulink.source.entity);\n\tsink = find_entity(mdev, ulink.sink.entity);\n\n\tif (source == NULL || sink == NULL)\n\t\treturn -EINVAL;\n\n\tif (ulink.source.index >= source->num_pads ||\n\t    ulink.sink.index >= sink->num_pads)\n\t\treturn -EINVAL;\n\n\tlink = media_entity_find_link(&source->pads[ulink.source.index],\n\t\t\t\t      &sink->pads[ulink.sink.index]);\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\t/* Setup the link on both entities. */\n\tret = __media_entity_setup_link(link, ulink.flags);\n\n\tif (copy_to_user(_ulink, &ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\t\tret = media_device_get_info(dev,\n\t\t\t\t(struct media_device_info __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\t\tret = media_device_enum_entities(dev,\n\t\t\t\t(struct media_entity_desc __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_LINKS:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links(dev,\n\t\t\t\t(struct media_links_enum __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_setup_link(dev,\n\t\t\t\t(struct media_link_desc __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct media_links_enum32 {\n\t__u32 entity;\n\tcompat_uptr_t pads; /* struct media_pad_desc * */\n\tcompat_uptr_t links; /* struct media_link_desc * */\n\t__u32 reserved[4];\n};\n\nstatic long media_device_enum_links32(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum32 __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tcompat_uptr_t pads_ptr, links_ptr;\n\n\tmemset(&links, 0, sizeof(links));\n\n\tif (get_user(links.entity, &ulinks->entity)\n\t    || get_user(pads_ptr, &ulinks->pads)\n\t    || get_user(links_ptr, &ulinks->links))\n\t\treturn -EFAULT;\n\n\tlinks.pads = compat_ptr(pads_ptr);\n\tlinks.links = compat_ptr(links_ptr);\n\n\treturn __media_device_enum_links(mdev, &links);\n}\n\n#define MEDIA_IOC_ENUM_LINKS32\t\t_IOWR('|', 0x02, struct media_links_enum32)\n\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\treturn media_device_ioctl(filp, cmd, arg);\n\n\tcase MEDIA_IOC_ENUM_LINKS32:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links32(dev,\n\t\t\t\t(struct media_links_enum32 __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_COMPAT */\n\nstatic const struct media_file_operations media_device_fops = {\n\t.owner = THIS_MODULE,\n\t.open = media_device_open,\n\t.ioctl = media_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_device_compat_ioctl,\n#endif /* CONFIG_COMPAT */\n\t.release = media_device_close,\n};\n\n/* -----------------------------------------------------------------------------\n * sysfs\n */\n\nstatic ssize_t show_model(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct media_device *mdev = to_media_device(to_media_devnode(cd));\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(mdev->model), mdev->model);\n}\n\nstatic DEVICE_ATTR(model, S_IRUGO, show_model, NULL);\n\n/* -----------------------------------------------------------------------------\n * Registration/unregistration\n */\n\nstatic void media_device_release(struct media_devnode *mdev)\n{\n}\n\n/**\n * media_device_register - register a media device\n * @mdev:\tThe media device\n *\n * The caller is responsible for initializing the media device before\n * registration. The following fields must be set:\n *\n * - dev must point to the parent device\n * - model must be filled with the device model name\n */\nint __must_check media_device_register(struct media_device *mdev)\n{\n\tint ret;\n\n\tif (WARN_ON(mdev->dev == NULL || mdev->model[0] == 0))\n\t\treturn -EINVAL;\n\n\tmdev->entity_id = 1;\n\tINIT_LIST_HEAD(&mdev->entities);\n\tspin_lock_init(&mdev->lock);\n\tmutex_init(&mdev->graph_mutex);\n\n\t/* Register the device node. */\n\tmdev->devnode.fops = &media_device_fops;\n\tmdev->devnode.parent = mdev->dev;\n\tmdev->devnode.release = media_device_release;\n\tret = media_devnode_register(&mdev->devnode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&mdev->devnode.dev, &dev_attr_model);\n\tif (ret < 0) {\n\t\tmedia_devnode_unregister(&mdev->devnode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register);\n\n/**\n * media_device_unregister - unregister a media device\n * @mdev:\tThe media device\n *\n */\nvoid media_device_unregister(struct media_device *mdev)\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *next;\n\n\tlist_for_each_entry_safe(entity, next, &mdev->entities, list)\n\t\tmedia_device_unregister_entity(entity);\n\n\tdevice_remove_file(&mdev->devnode.dev, &dev_attr_model);\n\tmedia_devnode_unregister(&mdev->devnode);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister);\n\n/**\n * media_device_register_entity - Register an entity with a media device\n * @mdev:\tThe media device\n * @entity:\tThe entity\n */\nint __must_check media_device_register_entity(struct media_device *mdev,\n\t\t\t\t\t      struct media_entity *entity)\n{\n\t/* Warn if we apparently re-register an entity */\n\tWARN_ON(entity->parent != NULL);\n\tentity->parent = mdev;\n\n\tspin_lock(&mdev->lock);\n\tif (entity->id == 0)\n\t\tentity->id = mdev->entity_id++;\n\telse\n\t\tmdev->entity_id = max(entity->id + 1, mdev->entity_id);\n\tlist_add_tail(&entity->list, &mdev->entities);\n\tspin_unlock(&mdev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity);\n\n/**\n * media_device_unregister_entity - Unregister an entity\n * @entity:\tThe entity\n *\n * If the entity has never been registered this function will return\n * immediately.\n */\nvoid media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->parent;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tspin_lock(&mdev->lock);\n\tlist_del(&entity->list);\n\tspin_unlock(&mdev->lock);\n\tentity->parent = NULL;\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity);\n"], "filenames": ["drivers/media/media-device.c"], "buggy_code_start_loc": [95], "buggy_code_end_loc": [95], "fixing_code_start_loc": [96], "fixing_code_end_loc": [97], "type": "CWE-200", "message": "The media_device_enum_entities function in drivers/media/media-device.c in the Linux kernel before 3.14.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging /dev/media0 read access for a MEDIA_IOC_ENUM_ENTITIES ioctl call.", "other": {"cve": {"id": "CVE-2014-1739", "sourceIdentifier": "cve-coordination@google.com", "published": "2014-06-23T11:21:17.730", "lastModified": "2020-08-19T19:18:02.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The media_device_enum_entities function in drivers/media/media-device.c in the Linux kernel before 3.14.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging /dev/media0 read access for a MEDIA_IOC_ENUM_ENTITIES ioctl call."}, {"lang": "es", "value": "La funci\u00f3n media_device_enum_entities en drivers/media/media-device.c en el kernel de Linux anterior a 3.14.6 no inicializa cierta estructura de datos, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel mediante el aprovechamiento del acceso a lectura /dev/media0 para una llamada MEDIA_IOC_ENUM_ENTITIES ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14.6", "matchCriteriaId": "0C1D8BD7-2424-4032-B0E1-2F11CE2A1249"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.10:*:*:*:*:*:*:*", "matchCriteriaId": "7F61F047-129C-41A6-8A27-FFCBB8563E91"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "A3A907A3-2A3A-46D4-8D75-914649877B65"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_desktop:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "F4BC592E-17CC-4DD4-8B2C-CFD99383649C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "B2866FAF-4340-4EA7-9009-6594ADA27AF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:vmware:*:*", "matchCriteriaId": "0EA03350-8702-43D5-8605-5FB765A3F60B"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=e6a623460e5fc960ac3ee9f946d3106233fd28d8", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00006.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00007.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://speirofr.appspot.com/cve-2014-1739-kernel-infoleak-vulnerability-in-media_enum_entities.html", "source": "cve-coordination@google.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.14.6", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/15/1", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68048", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038201", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2259-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2261-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2263-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2264-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1109774", "source": "cve-coordination@google.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/e6a623460e5fc960ac3ee9f946d3106233fd28d8", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-04-01", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e6a623460e5fc960ac3ee9f946d3106233fd28d8"}}