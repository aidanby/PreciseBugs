{"buggy_code": ["<?php\n/**\n * REST API functions.\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.4.0\n */\n\n/**\n * Version number for our API.\n *\n * @var string\n */\ndefine( 'REST_API_VERSION', '2.0' );\n\n/**\n * Registers a REST API route.\n *\n * @since 4.4.0\n *\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n *\n * @param string $namespace The first URL segment after core prefix. Should be unique to your package/plugin.\n * @param string $route     The base URL for route you are adding.\n * @param array  $args      Optional. Either an array of options for the endpoint, or an array of arrays for\n *                          multiple methods. Default empty array.\n * @param bool   $override  Optional. If the route already exists, should we override it? True overrides,\n *                          false merges (with newer overriding if duplicate keys exist). Default false.\n * @return bool True on success, false on error.\n */\nfunction register_rest_route( $namespace, $route, $args = array(), $override = false ) {\n\t/** @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $namespace ) ) {\n\t\t/*\n\t\t * Non-namespaced routes are not allowed, with the exception of the main\n\t\t * and namespace indexes. If you really need to register a\n\t\t * non-namespaced route, call `WP_REST_Server::register_route` directly.\n\t\t */\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Routes must be namespaced with plugin or theme name and version.' ), '4.4.0' );\n\t\treturn false;\n\t} else if ( empty( $route ) ) {\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Route must be specified.' ), '4.4.0' );\n\t\treturn false;\n\t}\n\n\tif ( isset( $args['callback'] ) ) {\n\t\t// Upgrade a single set to multiple.\n\t\t$args = array( $args );\n\t}\n\n\t$defaults = array(\n\t\t'methods'         => 'GET',\n\t\t'callback'        => null,\n\t\t'args'            => array(),\n\t);\n\tforeach ( $args as $key => &$arg_group ) {\n\t\tif ( ! is_numeric( $arg_group ) ) {\n\t\t\t// Route option, skip here.\n\t\t\tcontinue;\n\t\t}\n\n\t\t$arg_group = array_merge( $defaults, $arg_group );\n\t}\n\n\t$full_route = '/' . trim( $namespace, '/' ) . '/' . trim( $route, '/' );\n\t$wp_rest_server->register_route( $namespace, $full_route, $args, $override );\n\treturn true;\n}\n\n/**\n * Registers a new field on an existing WordPress object type.\n *\n * @since 4.7.0\n *\n * @global array $wp_rest_additional_fields Holds registered fields, organized\n *                                          by object type.\n *\n * @param string|array $object_type Object(s) the field is being registered\n *                                  to, \"post\"|\"term\"|\"comment\" etc.\n * @param string $attribute         The attribute name.\n * @param array  $args {\n *     Optional. An array of arguments used to handle the registered field.\n *\n *     @type string|array|null $get_callback    Optional. The callback function used to retrieve the field\n *                                              value. Default is 'null', the field will not be returned in\n *                                              the response.\n *     @type string|array|null $update_callback Optional. The callback function used to set and update the\n *                                              field value. Default is 'null', the value cannot be set or\n *                                              updated.\n *     @type string|array|null $schema          Optional. The callback function used to create the schema for\n *                                              this field. Default is 'null', no schema entry will be returned.\n * }\n */\nfunction register_rest_field( $object_type, $attribute, $args = array() ) {\n\t$defaults = array(\n\t\t'get_callback'    => null,\n\t\t'update_callback' => null,\n\t\t'schema'          => null,\n\t);\n\n\t$args = wp_parse_args( $args, $defaults );\n\n\tglobal $wp_rest_additional_fields;\n\n\t$object_types = (array) $object_type;\n\n\tforeach ( $object_types as $object_type ) {\n\t\t$wp_rest_additional_fields[ $object_type ][ $attribute ] = $args;\n\t}\n}\n\n/**\n * Registers rewrite rules for the API.\n *\n * @since 4.4.0\n *\n * @see rest_api_register_rewrites()\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_init() {\n\trest_api_register_rewrites();\n\n\tglobal $wp;\n\t$wp->add_query_var( 'rest_route' );\n}\n\n/**\n * Adds REST rewrite rules.\n *\n * @since 4.4.0\n *\n * @see add_rewrite_rule()\n * @global WP_Rewrite $wp_rewrite\n */\nfunction rest_api_register_rewrites() {\n\tglobal $wp_rewrite;\n\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/?$','index.php?rest_route=/','top' );\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/(.*)?','index.php?rest_route=/$matches[1]','top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/?$','index.php?rest_route=/','top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/(.*)?','index.php?rest_route=/$matches[1]','top' );\n}\n\n/**\n * Registers the default REST API filters.\n *\n * Attached to the {@see 'rest_api_init'} action\n * to make testing and disabling these filters easier.\n *\n * @since 4.4.0\n */\nfunction rest_api_default_filters() {\n\t// Deprecated reporting.\n\tadd_action( 'deprecated_function_run', 'rest_handle_deprecated_function', 10, 3 );\n\tadd_filter( 'deprecated_function_trigger_error', '__return_false' );\n\tadd_action( 'deprecated_argument_run', 'rest_handle_deprecated_argument', 10, 3 );\n\tadd_filter( 'deprecated_argument_trigger_error', '__return_false' );\n\n\t// Default serving.\n\tadd_filter( 'rest_pre_serve_request', 'rest_send_cors_headers' );\n\tadd_filter( 'rest_post_dispatch', 'rest_send_allow_header', 10, 3 );\n\n\tadd_filter( 'rest_pre_dispatch', 'rest_handle_options_request', 10, 3 );\n}\n\n/**\n * Registers default REST API routes.\n *\n * @since 4.7.0\n */\nfunction create_initial_rest_routes() {\n\tforeach ( get_post_types( array( 'show_in_rest' => true ), 'objects' ) as $post_type ) {\n\t\t$class = ! empty( $post_type->rest_controller_class ) ? $post_type->rest_controller_class : 'WP_REST_Posts_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $post_type->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\n\t\tif ( post_type_supports( $post_type->name, 'revisions' ) ) {\n\t\t\t$revisions_controller = new WP_REST_Revisions_Controller( $post_type->name );\n\t\t\t$revisions_controller->register_routes();\n\t\t}\n\t}\n\n\t// Post types.\n\t$controller = new WP_REST_Post_Types_Controller;\n\t$controller->register_routes();\n\n\t// Post statuses.\n\t$controller = new WP_REST_Post_Statuses_Controller;\n\t$controller->register_routes();\n\n\t// Taxonomies.\n\t$controller = new WP_REST_Taxonomies_Controller;\n\t$controller->register_routes();\n\n\t// Terms.\n\tforeach ( get_taxonomies( array( 'show_in_rest' => true ), 'object' ) as $taxonomy ) {\n\t\t$class = ! empty( $taxonomy->rest_controller_class ) ? $taxonomy->rest_controller_class : 'WP_REST_Terms_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $taxonomy->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\t}\n\n\t// Users.\n\t$controller = new WP_REST_Users_Controller;\n\t$controller->register_routes();\n\n\t// Comments.\n\t$controller = new WP_REST_Comments_Controller;\n\t$controller->register_routes();\n\n\t// Settings.\n\t$controller = new WP_REST_Settings_Controller;\n\t$controller->register_routes();\n}\n\n/**\n * Loads the REST API.\n *\n * @since 4.4.0\n *\n * @global WP             $wp             Current WordPress environment instance.\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n */\nfunction rest_api_loaded() {\n\tif ( empty( $GLOBALS['wp']->query_vars['rest_route'] ) ) {\n\t\treturn;\n\t}\n\n\t/**\n\t * Whether this is a REST Request.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tdefine( 'REST_REQUEST', true );\n\n\t// Initialize the server.\n\t$server = rest_get_server();\n\n\t// Fire off the request.\n\t$route = untrailingslashit( $GLOBALS['wp']->query_vars['rest_route'] );\n\tif ( empty( $route ) ) {\n\t\t$route = '/';\n\t}\n\t$server->serve_request( $route );\n\n\t// We're done.\n\tdie();\n}\n\n/**\n * Retrieves the URL prefix for any API resource.\n *\n * @since 4.4.0\n *\n * @return string Prefix.\n */\nfunction rest_get_url_prefix() {\n\t/**\n\t * Filters the REST URL prefix.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $prefix URL prefix. Default 'wp-json'.\n\t */\n\treturn apply_filters( 'rest_url_prefix', 'wp-json' );\n}\n\n/**\n * Retrieves the URL to a REST endpoint on a site.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @todo Check if this is even necessary\n * @global WP_Rewrite $wp_rewrite\n *\n * @param int    $blog_id Optional. Blog ID. Default of null returns URL for current blog.\n * @param string $path    Optional. REST route. Default '/'.\n * @param string $scheme  Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction get_rest_url( $blog_id = null, $path = '/', $scheme = 'rest' ) {\n\tif ( empty( $path ) ) {\n\t\t$path = '/';\n\t}\n\n\tif ( is_multisite() && get_blog_option( $blog_id, 'permalink_structure' ) || get_option( 'permalink_structure' ) ) {\n\t\tglobal $wp_rewrite;\n\n\t\tif ( $wp_rewrite->using_index_permalinks() ) {\n\t\t\t$url = get_home_url( $blog_id, $wp_rewrite->index . '/' . rest_get_url_prefix(), $scheme );\n\t\t} else {\n\t\t\t$url = get_home_url( $blog_id, rest_get_url_prefix(), $scheme );\n\t\t}\n\n\t\t$url .= '/' . ltrim( $path, '/' );\n\t} else {\n\t\t$url = trailingslashit( get_home_url( $blog_id, '', $scheme ) );\n\n\t\t$path = '/' . ltrim( $path, '/' );\n\n\t\t$url = add_query_arg( 'rest_route', $path, $url );\n\t}\n\n\tif ( is_ssl() ) {\n\t\t// If the current host is the same as the REST URL host, force the REST URL scheme to HTTPS.\n\t\tif ( $_SERVER['SERVER_NAME'] === parse_url( get_home_url( $blog_id ), PHP_URL_HOST ) ) {\n\t\t\t$url = set_url_scheme( $url, 'https' );\n\t\t}\n\t}\n\n\t/**\n\t * Filters the REST URL.\n\t *\n\t * Use this filter to adjust the url returned by the get_rest_url() function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $url     REST URL.\n\t * @param string $path    REST route.\n\t * @param int    $blog_id Blog ID.\n\t * @param string $scheme  Sanitization scheme.\n\t */\n\treturn apply_filters( 'rest_url', $url, $path, $blog_id, $scheme );\n}\n\n/**\n * Retrieves the URL to a REST endpoint.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @param string $path   Optional. REST route. Default empty.\n * @param string $scheme Optional. Sanitization scheme. Default 'json'.\n * @return string Full URL to the endpoint.\n */\nfunction rest_url( $path = '', $scheme = 'json' ) {\n\treturn get_rest_url( null, $path, $scheme );\n}\n\n/**\n * Do a REST request.\n *\n * Used primarily to route internal requests through WP_REST_Server.\n *\n * @since 4.4.0\n *\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n *\n * @param WP_REST_Request|string $request Request.\n * @return WP_REST_Response REST response.\n */\nfunction rest_do_request( $request ) {\n\t$request = rest_ensure_request( $request );\n\treturn rest_get_server()->dispatch( $request );\n}\n\n/**\n * Retrieves the current REST server instance.\n *\n * Instantiates a new instance if none exists already.\n *\n * @since 4.5.0\n *\n * @global WP_REST_Server $wp_rest_server REST server instance.\n *\n * @return WP_REST_Server REST server instance.\n */\nfunction rest_get_server() {\n\t/* @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $wp_rest_server ) ) {\n\t\t/**\n\t\t * Filters the REST Server Class.\n\t\t *\n\t\t * This filter allows you to adjust the server class used by the API, using a\n\t\t * different class to handle requests.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string $class_name The name of the server class. Default 'WP_REST_Server'.\n\t\t */\n\t\t$wp_rest_server_class = apply_filters( 'wp_rest_server_class', 'WP_REST_Server' );\n\t\t$wp_rest_server = new $wp_rest_server_class;\n\n\t\t/**\n\t\t * Fires when preparing to serve an API request.\n\t\t *\n\t\t * Endpoint objects should be created and register their hooks on this action rather\n\t\t * than another action to ensure they're only loaded when needed.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param WP_REST_Server $wp_rest_server Server object.\n\t\t */\n\t\tdo_action( 'rest_api_init', $wp_rest_server );\n\t}\n\n\treturn $wp_rest_server;\n}\n\n/**\n * Ensures request arguments are a request object (for consistency).\n *\n * @since 4.4.0\n *\n * @param array|WP_REST_Request $request Request to check.\n * @return WP_REST_Request REST request instance.\n */\nfunction rest_ensure_request( $request ) {\n\tif ( $request instanceof WP_REST_Request ) {\n\t\treturn $request;\n\t}\n\n\treturn new WP_REST_Request( 'GET', '', $request );\n}\n\n/**\n * Ensures a REST response is a response object (for consistency).\n *\n * This implements WP_HTTP_Response, allowing usage of `set_status`/`header`/etc\n * without needing to double-check the object. Will also allow WP_Error to indicate error\n * responses, so users should immediately check for this value.\n *\n * @since 4.4.0\n *\n * @param WP_Error|WP_HTTP_Response|mixed $response Response to check.\n * @return WP_REST_Response|mixed If response generated an error, WP_Error, if response\n *                                is already an instance, WP_HTTP_Response, otherwise\n *                                returns a new WP_REST_Response instance.\n */\nfunction rest_ensure_response( $response ) {\n\tif ( is_wp_error( $response ) ) {\n\t\treturn $response;\n\t}\n\n\tif ( $response instanceof WP_HTTP_Response ) {\n\t\treturn $response;\n\t}\n\n\treturn new WP_REST_Response( $response );\n}\n\n/**\n * Handles _deprecated_function() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $replacement The function that should have been called.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_function( $function, $replacement, $version ) {\n\tif ( ! empty( $replacement ) ) {\n\t\t/* translators: 1: function name, 2: WordPress version number, 3: new function name */\n\t\t$string = sprintf( __( '%1$s (since %2$s; use %3$s instead)' ), $function, $version, $replacement );\n\t} else {\n\t\t/* translators: 1: function name, 2: WordPress version number */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedFunction: %s', $string ) );\n}\n\n/**\n * Handles _deprecated_argument() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $message     A message regarding the change.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_argument( $function, $message, $version ) {\n\tif ( ! empty( $message ) ) {\n\t\t/* translators: 1: function name, 2: WordPress version number, 3: error message */\n\t\t$string = sprintf( __( '%1$s (since %2$s; %3$s)' ), $function, $version, $message );\n\t} else {\n\t\t/* translators: 1: function name, 2: WordPress version number */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedParam: %s', $string ) );\n}\n\n/**\n * Sends Cross-Origin Resource Sharing headers with API requests.\n *\n * @since 4.4.0\n *\n * @param mixed $value Response data.\n * @return mixed Response data.\n */\nfunction rest_send_cors_headers( $value ) {\n\t$origin = get_http_origin();\n\n\tif ( $origin ) {\n\t\theader( 'Access-Control-Allow-Origin: ' . esc_url_raw( $origin ) );\n\t\theader( 'Access-Control-Allow-Methods: OPTIONS, GET, POST, PUT, PATCH, DELETE' );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\theader( 'Vary: Origin' );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Handles OPTIONS requests for the server.\n *\n * This is handled outside of the server code, as it doesn't obey normal route\n * mapping.\n *\n * @since 4.4.0\n *\n * @param mixed           $response Current response, either response or `null` to indicate pass-through.\n * @param WP_REST_Server  $handler  ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request $request  The request that was used to make current response.\n * @return WP_REST_Response Modified response, either response or `null` to indicate pass-through.\n */\nfunction rest_handle_options_request( $response, $handler, $request ) {\n\tif ( ! empty( $response ) || $request->get_method() !== 'OPTIONS' ) {\n\t\treturn $response;\n\t}\n\n\t$response = new WP_REST_Response();\n\t$data = array();\n\n\tforeach ( $handler->get_routes() as $route => $endpoints ) {\n\t\t$match = preg_match( '@^' . $route . '$@i', $request->get_route() );\n\n\t\tif ( ! $match ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$data = $handler->get_data_for_route( $route, $endpoints, 'help' );\n\t\t$response->set_matched_route( $route );\n\t\tbreak;\n\t}\n\n\t$response->set_data( $data );\n\treturn $response;\n}\n\n/**\n * Sends the \"Allow\" header to state all methods that can be sent to the current route.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n * @return WP_REST_Response Response to be served, with \"Allow\" header if route has allowed methods.\n */\nfunction rest_send_allow_header( $response, $server, $request ) {\n\t$matched_route = $response->get_matched_route();\n\n\tif ( ! $matched_route ) {\n\t\treturn $response;\n\t}\n\n\t$routes = $server->get_routes();\n\n\t$allowed_methods = array();\n\n\t// Get the allowed methods across the routes.\n\tforeach ( $routes[ $matched_route ] as $_handler ) {\n\t\tforeach ( $_handler['methods'] as $handler_method => $value ) {\n\n\t\t\tif ( ! empty( $_handler['permission_callback'] ) ) {\n\n\t\t\t\t$permission = call_user_func( $_handler['permission_callback'], $request );\n\n\t\t\t\t$allowed_methods[ $handler_method ] = true === $permission;\n\t\t\t} else {\n\t\t\t\t$allowed_methods[ $handler_method ] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Strip out all the methods that are not allowed (false values).\n\t$allowed_methods = array_filter( $allowed_methods );\n\n\tif ( $allowed_methods ) {\n\t\t$response->header( 'Allow', implode( ', ', array_map( 'strtoupper', array_keys( $allowed_methods ) ) ) );\n\t}\n\n\treturn $response;\n}\n\n/**\n * Adds the REST API URL to the WP RSD endpoint.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_rsd() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\t?>\n\t<api name=\"WP-API\" blogID=\"1\" preferred=\"false\" apiLink=\"<?php echo esc_url( $api_root ); ?>\" />\n\t<?php\n}\n\n/**\n * Outputs the REST API link tag into page header.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_link_wp_head() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\techo \"<link rel='https://api.w.org/' href='\" . esc_url( $api_root ) . \"' />\\n\";\n}\n\n/**\n * Sends a Link header for the REST API.\n *\n * @since 4.4.0\n */\nfunction rest_output_link_header() {\n\tif ( headers_sent() ) {\n\t\treturn;\n\t}\n\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\theader( 'Link: <' . esc_url_raw( $api_root ) . '>; rel=\"https://api.w.org/\"', false );\n}\n\n/**\n * Checks for errors when using cookie-based authentication.\n *\n * WordPress' built-in cookie authentication is always active\n * for logged in users. However, the API has to check nonces\n * for each request to ensure users are not vulnerable to CSRF.\n *\n * @since 4.4.0\n *\n * @global mixed          $wp_rest_auth_cookie\n * @global WP_REST_Server $wp_rest_server      REST server instance.\n *\n * @param WP_Error|mixed $result Error from another authentication handler,\n *                               null if we should handle it, or another value\n *                               if not.\n * @return WP_Error|mixed|bool WP_Error if the cookie is invalid, the $result, otherwise true.\n */\nfunction rest_cookie_check_errors( $result ) {\n\tif ( ! empty( $result ) ) {\n\t\treturn $result;\n\t}\n\n\tglobal $wp_rest_auth_cookie, $wp_rest_server;\n\n\t/*\n\t * Is cookie authentication being used? (If we get an auth\n\t * error, but we're still logged in, another authentication\n\t * must have been used).\n\t */\n\tif ( true !== $wp_rest_auth_cookie && is_user_logged_in() ) {\n\t\treturn $result;\n\t}\n\n\t// Determine if there is a nonce.\n\t$nonce = null;\n\n\tif ( isset( $_REQUEST['_wpnonce'] ) ) {\n\t\t$nonce = $_REQUEST['_wpnonce'];\n\t} elseif ( isset( $_SERVER['HTTP_X_WP_NONCE'] ) ) {\n\t\t$nonce = $_SERVER['HTTP_X_WP_NONCE'];\n\t}\n\n\tif ( null === $nonce ) {\n\t\t// No nonce at all, so act as if it's an unauthenticated request.\n\t\twp_set_current_user( 0 );\n\t\treturn true;\n\t}\n\n\t// Check the nonce.\n\t$result = wp_verify_nonce( $nonce, 'wp_rest' );\n\n\tif ( ! $result ) {\n\t\treturn new WP_Error( 'rest_cookie_invalid_nonce', __( 'Cookie nonce is invalid' ), array( 'status' => 403 ) );\n\t}\n\n\t// Send a refreshed nonce in header.\n\t$wp_rest_server->send_header( 'X-WP-Nonce', wp_create_nonce( 'wp_rest' ) );\n\n\treturn true;\n}\n\n/**\n * Collects cookie authentication status.\n *\n * Collects errors from wp_validate_auth_cookie for use by rest_cookie_check_errors.\n *\n * @since 4.4.0\n *\n * @see current_action()\n * @global mixed $wp_rest_auth_cookie\n */\nfunction rest_cookie_collect_status() {\n\tglobal $wp_rest_auth_cookie;\n\n\t$status_type = current_action();\n\n\tif ( 'auth_cookie_valid' !== $status_type ) {\n\t\t$wp_rest_auth_cookie = substr( $status_type, 12 );\n\t\treturn;\n\t}\n\n\t$wp_rest_auth_cookie = true;\n}\n\n/**\n * Parses an RFC3339 time into a Unix timestamp.\n *\n * @since 4.4.0\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Optional. Whether to force UTC timezone instead of using\n *                          the timestamp's timezone. Default false.\n * @return int Unix timestamp.\n */\nfunction rest_parse_date( $date, $force_utc = false ) {\n\tif ( $force_utc ) {\n\t\t$date = preg_replace( '/[+-]\\d+:?\\d+$/', '+00:00', $date );\n\t}\n\n\t$regex = '#^\\d{4}-\\d{2}-\\d{2}[Tt ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}(?::\\d{2})?)?$#';\n\n\tif ( ! preg_match( $regex, $date, $matches ) ) {\n\t\treturn false;\n\t}\n\n\treturn strtotime( $date );\n}\n\n/**\n * Retrieves a local date with its GMT equivalent, in MySQL datetime format.\n *\n * @since 4.4.0\n *\n * @see rest_parse_date()\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Whether a UTC timestamp should be forced. Default false.\n * @return array|null Local and UTC datetime strings, in MySQL datetime format (Y-m-d H:i:s),\n *                    null on failure.\n */\nfunction rest_get_date_with_gmt( $date, $force_utc = false ) {\n\t$date = rest_parse_date( $date, $force_utc );\n\n\tif ( empty( $date ) ) {\n\t\treturn null;\n\t}\n\n\t$utc = date( 'Y-m-d H:i:s', $date );\n\t$local = get_date_from_gmt( $utc );\n\n\treturn array( $local, $utc );\n}\n\n/**\n * Returns a contextual HTTP error code for authorization failure.\n *\n * @since 4.7.0\n *\n * @return integer 401 if the user is not logged in, 403 if the user is logged in.\n */\nfunction rest_authorization_required_code() {\n\treturn is_user_logged_in() ? 403 : 401;\n}\n\n/**\n * Validate a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return WP_Error|boolean\n */\nfunction rest_validate_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn true;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_validate_value_from_schema( $value, $args, $param );\n}\n\n/**\n * Sanitize a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_sanitize_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn $value;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_sanitize_value_from_schema( $value, $args );\n}\n\n/**\n * Parse a request argument based on details registered to the route.\n *\n * Runs a validation check and sanitizes the value, primarily to be used via\n * the `sanitize_callback` arguments in the endpoint args registration.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_parse_request_arg( $value, $request, $param ) {\n\t$is_valid = rest_validate_request_arg( $value, $request, $param );\n\n\tif ( is_wp_error( $is_valid ) ) {\n\t\treturn $is_valid;\n\t}\n\n\t$value = rest_sanitize_request_arg( $value, $request, $param );\n\n\treturn $value;\n}\n\n/**\n * Determines if an IP address is valid.\n *\n * Handles both IPv4 and IPv6 addresses.\n *\n * @since 4.7.0\n *\n * @param  string $ip IP address.\n * @return string|false The valid IP address, otherwise false.\n */\nfunction rest_is_ip_address( $ip ) {\n\t$ipv4_pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';\n\n\tif ( ! preg_match( $ipv4_pattern, $ip ) && ! Requests_IPv6::check_ipv6( $ip ) ) {\n\t\treturn false;\n\t}\n\n\treturn $ip;\n}\n\n/**\n * Changes a boolean-like value into the proper boolean value.\n *\n * @since 4.7.0\n *\n * @param bool|string|int $value The value being evaluated.\n * @return boolean Returns the proper associated boolean value.\n */\nfunction rest_sanitize_boolean( $value ) {\n\t// String values are translated to `true`; make sure 'false' is false.\n\tif ( is_string( $value )  ) {\n\t\t$value = strtolower( $value );\n\t\tif ( in_array( $value, array( 'false', '0' ), true ) ) {\n\t\t\t$value = false;\n\t\t}\n\t}\n\n\t// Everything else will map nicely to boolean.\n\treturn (boolean) $value;\n}\n\n/**\n * Determines if a given value is boolean-like.\n *\n * @since 4.7.0\n *\n * @param bool|string $maybe_bool The value being evaluated.\n * @return boolean True if a boolean, otherwise false.\n */\nfunction rest_is_boolean( $maybe_bool ) {\n\tif ( is_bool( $maybe_bool ) ) {\n\t\treturn true;\n\t}\n\n\tif ( is_string( $maybe_bool ) ) {\n\t\t$maybe_bool = strtolower( $maybe_bool );\n\n\t\t$valid_boolean_values = array(\n\t\t\t'false',\n\t\t\t'true',\n\t\t\t'0',\n\t\t\t'1',\n\t\t);\n\n\t\treturn in_array( $maybe_bool, $valid_boolean_values, true );\n\t}\n\n\tif ( is_int( $maybe_bool ) ) {\n\t\treturn in_array( $maybe_bool, array( 0, 1 ), true );\n\t}\n\n\treturn false;\n}\n\n/**\n * Retrieves the avatar urls in various sizes based on a given email address.\n *\n * @since 4.7.0\n *\n * @see get_avatar_url()\n *\n * @param string $email Email address.\n * @return array $urls Gravatar url for each size.\n */\nfunction rest_get_avatar_urls( $email ) {\n\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t$urls = array();\n\tforeach ( $avatar_sizes as $size ) {\n\t\t$urls[ $size ] = get_avatar_url( $email, array( 'size' => $size ) );\n\t}\n\n\treturn $urls;\n}\n\n/**\n * Retrieves the pixel sizes for avatars.\n *\n * @since 4.7.0\n *\n * @return array List of pixel sizes for avatars. Default `[ 24, 48, 96 ]`.\n */\nfunction rest_get_avatar_sizes() {\n\t/**\n\t * Filter the REST avatar sizes.\n\t *\n\t * Use this filter to adjust the array of sizes returned by the\n\t * `rest_get_avatar_sizes` function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param array $sizes An array of int values that are the pixel sizes for avatars.\n\t *                     Default `[ 24, 48, 96 ]`.\n\t */\n\treturn apply_filters( 'rest_avatar_sizes', array( 24, 48, 96 ) );\n}\n\n/**\n * Validate a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed  $value The value to validate.\n * @param array  $args  Schema array to use for validation.\n * @param string $param The parameter name, used in error messages.\n * @return true|WP_Error\n */\nfunction rest_validate_value_from_schema( $value, $args, $param = '' ) {\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t$value = preg_split( '/[\\s,]+/', $value );\n\t\t}\n\t\tif ( ! wp_is_numeric_array( $value ) ) {\n\t\t\t/* translators: 1: parameter, 2: type name */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'array' ) );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['items'], $param . '[' . $index . ']' );\n\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\treturn $is_valid;\n\t\t\t}\n\t\t}\n\t}\n\tif ( ! empty( $args['enum'] ) ) {\n\t\tif ( ! in_array( $value, $args['enum'], true ) ) {\n\t\t\t/* translators: 1: parameter, 2: list of valid values */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not one of %2$s.' ), $param, implode( ', ', $args['enum'] ) ) );\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'integer', 'number' ) ) && ! is_numeric( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, $args['type'] ) );\n\t}\n\n\tif ( 'integer' === $args['type'] && round( floatval( $value ) ) !== floatval( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'integer' ) );\n\t}\n\n\tif ( 'boolean' === $args['type'] && ! rest_is_boolean( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $value, 'boolean' ) );\n\t}\n\n\tif ( 'string' === $args['type'] && ! is_string( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'string' ) );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time' :\n\t\t\t\tif ( ! rest_parse_date( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_date', __( 'Invalid date.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'email' :\n\t\t\t\t// is_email() checks for 3 characters (a@b), but\n\t\t\t\t// wp_handle_comment_submission() requires 6 characters (a@b.co)\n\t\t\t\t//\n\t\t\t\t// https://core.trac.wordpress.org/ticket/38506\n\t\t\t\tif ( ! is_email( $value ) || strlen( $value ) < 6 ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_email', __( 'Invalid email address.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ip' :\n\t\t\t\tif ( ! rest_is_ip_address( $value ) ) {\n\t\t\t\t\t/* translators: %s: IP address */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%s is not a valid IP address.' ), $value ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'number', 'integer' ), true ) && ( isset( $args['minimum'] ) || isset( $args['maximum'] ) ) ) {\n\t\tif ( isset( $args['minimum'] ) && ! isset( $args['maximum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && $value <= $args['minimum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: minimum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than %2$d' ), $param, $args['minimum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && $value < $args['minimum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: minimum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than or equal to %2$d' ), $param, $args['minimum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && ! isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMaximum'] ) && $value >= $args['maximum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: maximum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than %2$d' ), $param, $args['maximum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMaximum'] ) && $value > $args['maximum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: maximum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than or equal to %2$d' ), $param, $args['maximum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( ! empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Sanitize a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed $value The value to sanitize.\n * @param array $args  Schema array to use for sanitization.\n * @return true|WP_Error\n */\nfunction rest_sanitize_value_from_schema( $value, $args ) {\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( empty( $args['items'] ) ) {\n\t\t\treturn (array) $value;\n\t\t}\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t$value = preg_split( '/[\\s,]+/', $value );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$value[ $index ] = rest_sanitize_value_from_schema( $v, $args['items'] );\n\t\t}\n\t\t// Normalize to numeric array so nothing unexpected\n\t\t// is in the keys.\n\t\t$value = array_values( $value );\n\t\treturn $value;\n\t}\n\tif ( 'integer' === $args['type'] ) {\n\t\treturn (int) $value;\n\t}\n\n\tif ( 'number' === $args['type'] ) {\n\t\treturn (float) $value;\n\t}\n\n\tif ( 'boolean' === $args['type'] ) {\n\t\treturn rest_sanitize_boolean( $value );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time' :\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'email' :\n\t\t\t\t/*\n\t\t\t\t * sanitize_email() validates, which would be unexpected.\n\t\t\t\t */\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'uri' :\n\t\t\t\treturn esc_url_raw( $value );\n\n\t\t\tcase 'ip' :\n\t\t\t\treturn sanitize_text_field( $value );\n\t\t}\n\t}\n\n\tif ( 'string' === $args['type'] ) {\n\t\treturn strval( $value );\n\t}\n\n\treturn $value;\n}\n", "<?php\n/**\n * REST API: WP_REST_Comments_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core controller used to access comments via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Comments_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Instance of a comment meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Comment_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'comments';\n\n\t\t$this->meta = new WP_REST_Comment_Meta_Fields();\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'   => WP_REST_Server::READABLE,\n\t\t\t\t'callback'  => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'      => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback' => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'     => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::READABLE,\n\t\t\t\t'callback' => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'context'          => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t\t'password' => array(\n\t\t\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback' => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'     => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback' => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Whether to bypass trash and force deletion.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'password' => array(\n\t\t\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read comments.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access, error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\n\t\tif ( ! empty( $request['post'] ) ) {\n\t\t\tforeach ( (array) $request['post'] as $post_id ) {\n\t\t\t\t$post = get_post( $post_id );\n\n\t\t\t\tif ( ! empty( $post_id ) && $post && ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t} elseif ( 0 === $post_id && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to read comments without a post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $request['context'] ) && 'edit' === $request['context'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit comments.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! current_user_can( 'edit_posts' ) ) {\n\t\t\t$protected_params = array( 'author', 'author_exclude', 'author_email', 'type', 'status' );\n\t\t\t$forbidden_params = array();\n\n\t\t\tforeach ( $protected_params as $param ) {\n\t\t\t\tif ( 'status' === $param ) {\n\t\t\t\t\tif ( 'approve' !== $request[ $param ] ) {\n\t\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t\t}\n\t\t\t\t} elseif ( 'type' === $param ) {\n\t\t\t\t\tif ( 'comment' !== $request[ $param ] ) {\n\t\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t\t}\n\t\t\t\t} elseif ( ! empty( $request[ $param ] ) ) {\n\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $forbidden_params ) ) {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_param', sprintf( __( 'Query parameter not permitted: %s' ), implode( ', ', $forbidden_params ) ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a list of comment items.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'author'         => 'author__in',\n\t\t\t'author_email'   => 'author_email',\n\t\t\t'author_exclude' => 'author__not_in',\n\t\t\t'exclude'        => 'comment__not_in',\n\t\t\t'include'        => 'comment__in',\n\t\t\t'offset'         => 'offset',\n\t\t\t'order'          => 'order',\n\t\t\t'parent'         => 'parent__in',\n\t\t\t'parent_exclude' => 'parent__not_in',\n\t\t\t'per_page'       => 'number',\n\t\t\t'post'           => 'post__in',\n\t\t\t'search'         => 'search',\n\t\t\t'status'         => 'status',\n\t\t\t'type'           => 'type',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\t// Ensure certain parameter values default to empty strings.\n\t\tforeach ( array( 'author_email', 'search' ) as $param ) {\n\t\t\tif ( ! isset( $prepared_args[ $param ] ) ) {\n\t\t\t\t$prepared_args[ $param ] = '';\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['orderby'] ) ) {\n\t\t\t$prepared_args['orderby'] = $this->normalize_query_param( $request['orderby'] );\n\t\t}\n\n\t\t$prepared_args['no_found_rows'] = false;\n\n\t\t$prepared_args['date_query'] = array();\n\n\t\t// Set before into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['before'], $request['before'] ) ) {\n\t\t\t$prepared_args['date_query'][0]['before'] = $request['before'];\n\t\t}\n\n\t\t// Set after into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['after'], $request['after'] ) ) {\n\t\t\t$prepared_args['date_query'][0]['after'] = $request['after'];\n\t\t}\n\n\t\tif ( isset( $registered['page'] ) && empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $prepared_args['number'] * ( absint( $request['page'] ) - 1 );\n\t\t}\n\n\t\t/**\n\t\t * Filters arguments, before passing to WP_Comment_Query, when querying comments via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_comment_query/\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments for WP_Comment_Query.\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( 'rest_comment_query', $prepared_args, $request );\n\n\t\t$query = new WP_Comment_Query;\n\t\t$query_result = $query->query( $prepared_args );\n\n\t\t$comments = array();\n\n\t\tforeach ( $query_result as $comment ) {\n\t\t\tif ( ! $this->check_read_permission( $comment, $request ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data = $this->prepare_item_for_response( $comment, $request );\n\t\t\t$comments[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$total_comments = (int) $query->found_comments;\n\t\t$max_pages      = (int) $query->max_num_pages;\n\n\t\tif ( $total_comments < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $prepared_args['number'], $prepared_args['offset'] );\n\n\t\t\t$query = new WP_Comment_Query;\n\t\t\t$prepared_args['count'] = true;\n\n\t\t\t$total_comments = $query->query( $prepared_args );\n\t\t\t$max_pages = ceil( $total_comments / $request['per_page'] );\n\t\t}\n\n\t\t$response = rest_ensure_response( $comments );\n\t\t$response->header( 'X-WP-Total', $total_comments );\n\t\t$response->header( 'X-WP-TotalPages', $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\n\t\tif ( $request['page'] > 1 ) {\n\t\t\t$prev_page = $request['page'] - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\n\t\tif ( $max_pages > $request['page'] ) {\n\t\t\t$next_page = $request['page'] + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read the comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access for the item, error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$id = (int) $request['id'];\n\n\t\t$comment = get_comment( $id );\n\n\t\tif ( ! $comment ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( ! empty( $request['context'] ) && 'edit' === $request['context'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit comments.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$post = get_post( $comment->comment_post_ID );\n\n\t\tif ( ! $this->check_read_permission( $comment, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to read this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( $post && ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$id = (int) $request['id'];\n\n\t\t$comment = get_comment( $id );\n\t\tif ( empty( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_id', __( 'Invalid comment ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( ! empty( $comment->comment_post_ID ) ) {\n\t\t\t$post = get_post( $comment->comment_post_ID );\n\t\t\tif ( empty( $post ) ) {\n\t\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\t\t}\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $comment, $request );\n\t\t$response = rest_ensure_response( $data );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to create a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to create items, error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\t\tif ( ! is_user_logged_in() ) {\n\t\t\tif ( get_option( 'comment_registration' ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_login_required', __( 'Sorry, you must be logged in to comment.' ), array( 'status' => 401 ) );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter whether comments can be created without authentication.\n\t\t\t *\n\t\t\t * Enables creating comments for anonymous users.\n\t\t\t *\n\t\t\t * @since 4.7.0\n\t\t\t *\n\t\t\t * @param bool $allow_anonymous Whether to allow anonymous comments to\n\t\t\t *                              be created. Default `false`.\n\t\t\t * @param WP_REST_Request $request Request used to generate the\n\t\t\t *                                 response.\n\t\t\t */\n\t\t\t$allow_anonymous = apply_filters( 'rest_allow_anonymous_comments', false, $request );\n\t\t\tif ( ! $allow_anonymous ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_login_required', __( 'Sorry, you must be logged in to comment.' ), array( 'status' => 401 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Limit who can set comment `author`, `author_ip` or `status` to anything other than the default.\n\t\tif ( isset( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_author',\n\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'author' ),\n\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t);\n\t\t}\n\n\t\tif ( isset( $request['author_ip'] ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\tif ( empty( $_SERVER['REMOTE_ADDR'] ) || $request['author_ip'] !== $_SERVER['REMOTE_ADDR'] ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_invalid_author_ip',\n\t\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'author_ip' ),\n\t\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $request['status'] ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_status',\n\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'status' ),\n\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t);\n\t\t}\n\n\t\tif ( empty( $request['post'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Sorry, you are not allowed to create this comment without a post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\t$post = get_post( (int) $request['post'] );\n\t\tif ( ! $post ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Sorry, you are not allowed to create this comment without a post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( 'draft' === $post->post_status ) {\n\t\t\treturn new WP_Error( 'rest_comment_draft_post', __( 'Sorry, you are not allowed to create a comment on this post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( 'trash' === $post->post_status ) {\n\t\t\treturn new WP_Error( 'rest_comment_trash_post', __( 'Sorry, you are not allowed to create a comment on this post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! comments_open( $post->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_closed', __( 'Sorry, comments are closed for this item.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_exists', __( 'Cannot create existing comment.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Do not allow comments to be created with a non-default type.\n\t\tif ( ! empty( $request['type'] ) && 'comment' !== $request['type'] ) {\n\t\t\treturn new WP_Error( 'rest_invalid_comment_type', __( 'Cannot create a comment with that type.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_comment = $this->prepare_item_for_database( $request );\n\t\tif ( is_wp_error( $prepared_comment ) ) {\n\t\t\treturn $prepared_comment;\n\t\t}\n\n\t\t$prepared_comment['comment_type'] = '';\n\n\t\t/*\n\t\t * Do not allow a comment to be created with missing or empty\n\t\t * comment_content. See wp_handle_comment_submission().\n\t\t */\n\t\tif ( empty( $prepared_comment['comment_content'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_content_invalid', __( 'Invalid comment content.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Setting remaining values before wp_insert_comment so we can use wp_allow_comment().\n\t\tif ( ! isset( $prepared_comment['comment_date_gmt'] ) ) {\n\t\t\t$prepared_comment['comment_date_gmt'] = current_time( 'mysql', true );\n\t\t}\n\n\t\t// Set author data if the user's logged in.\n\t\t$missing_author = empty( $prepared_comment['user_id'] )\n\t\t\t&& empty( $prepared_comment['comment_author'] )\n\t\t\t&& empty( $prepared_comment['comment_author_email'] )\n\t\t\t&& empty( $prepared_comment['comment_author_url'] );\n\n\t\tif ( is_user_logged_in() && $missing_author ) {\n\t\t\t$user = wp_get_current_user();\n\n\t\t\t$prepared_comment['user_id'] = $user->ID;\n\t\t\t$prepared_comment['comment_author'] = $user->display_name;\n\t\t\t$prepared_comment['comment_author_email'] = $user->user_email;\n\t\t\t$prepared_comment['comment_author_url'] = $user->user_url;\n\t\t}\n\n\t\t// Honor the discussion setting that requires a name and email address of the comment author.\n\t\tif ( get_option( 'require_name_email' ) ) {\n\t\t\tif ( empty( $prepared_comment['comment_author'] ) || empty( $prepared_comment['comment_author_email'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_author_data_required', __( 'Creating a comment requires valid author name and email values.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_author_email'] ) ) {\n\t\t\t$prepared_comment['comment_author_email'] = '';\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_author_url'] ) ) {\n\t\t\t$prepared_comment['comment_author_url'] = '';\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_agent'] ) ) {\n\t\t\t$prepared_comment['comment_agent'] = '';\n\t\t}\n\n\t\t$check_comment_lengths = wp_check_comment_data_max_lengths( $prepared_comment );\n\t\tif ( is_wp_error( $check_comment_lengths ) ) {\n\t\t\t$error_code = $check_comment_lengths->get_error_code();\n\t\t\treturn new WP_Error( $error_code, __( 'Comment field exceeds maximum length allowed.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_comment['comment_approved'] = wp_allow_comment( $prepared_comment, true );\n\n\t\tif ( is_wp_error( $prepared_comment['comment_approved'] ) ) {\n\t\t\t$error_code    = $prepared_comment['comment_approved']->get_error_code();\n\t\t\t$error_message = $prepared_comment['comment_approved']->get_error_message();\n\n\t\t\tif ( 'comment_duplicate' === $error_code ) {\n\t\t\t\treturn new WP_Error( $error_code, $error_message, array( 'status' => 409 ) );\n\t\t\t}\n\n\t\t\tif ( 'comment_flood' === $error_code ) {\n\t\t\t\treturn new WP_Error( $error_code, $error_message, array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\treturn $prepared_comment['comment_approved'];\n\t\t}\n\n\t\t/**\n\t\t * Filters a comment before it is inserted via the REST API.\n\t\t *\n\t\t * Allows modification of the comment right before it is inserted via wp_insert_comment().\n\t\t * Returning a WP_Error value from the filter will shortcircuit insertion and allow\n\t\t * skipping further processing.\n\t\t *\n\t\t * @since 4.7.0\n\t\t * @since 4.8.0 $prepared_comment can now be a WP_Error to shortcircuit insertion.\n\t\t *\n\t\t * @param array|WP_Error  $prepared_comment The prepared comment data for wp_insert_comment().\n\t\t * @param WP_REST_Request $request          Request used to insert the comment.\n\t\t */\n\t\t$prepared_comment = apply_filters( 'rest_pre_insert_comment', $prepared_comment, $request );\n\t\tif ( is_wp_error( $prepared_comment ) ) {\n\t\t\treturn $prepared_comment;\n\t\t}\n\n\t\t$comment_id = wp_insert_comment( wp_filter_comment( wp_slash( (array) $prepared_comment ) ) );\n\n\t\tif ( ! $comment_id ) {\n\t\t\treturn new WP_Error( 'rest_comment_failed_create', __( 'Creating comment failed.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\tif ( isset( $request['status'] ) ) {\n\t\t\t$this->handle_status_param( $request['status'], $comment_id );\n\t\t}\n\n\t\t$comment = get_comment( $comment_id );\n\n\t\t/**\n\t\t * Fires after a comment is created or updated via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Comment      $comment  Inserted or updated comment object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a comment, false\n\t\t *                                  when updating.\n\t\t */\n\t\tdo_action( 'rest_insert_comment', $comment, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $comment_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $comment, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$context = current_user_can( 'moderate_comments' ) ? 'edit' : 'view';\n\n\t\t$request->set_param( 'context', $context );\n\n\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment_id ) ) );\n\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given REST request has access to update a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to update the item, error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\n\t\t$id = (int) $request['id'];\n\n\t\t$comment = get_comment( $id );\n\n\t\tif ( $comment && ! $this->check_edit_permission( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$id = (int) $request['id'];\n\n\t\t$comment = get_comment( $id );\n\n\t\tif ( empty( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_id', __( 'Invalid comment ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( isset( $request['type'] ) && get_comment_type( $id ) !== $request['type'] ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_type', __( 'Sorry, you are not allowed to change the comment type.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$prepared_args = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $prepared_args ) ) {\n\t\t\treturn $prepared_args;\n\t\t}\n\n\t\tif ( ! empty( $prepared_args['comment_post_ID'] ) ) {\n\t\t\t$post = get_post( $prepared_args['comment_post_ID'] );\n\t\t\tif ( empty( $post ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Invalid post ID.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $prepared_args ) && isset( $request['status'] ) ) {\n\t\t\t// Only the comment status is being changed.\n\t\t\t$change = $this->handle_status_param( $request['status'], $id );\n\n\t\t\tif ( ! $change ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_failed_edit', __( 'Updating comment status failed.' ), array( 'status' => 500 ) );\n\t\t\t}\n\t\t} elseif ( ! empty( $prepared_args ) ) {\n\t\t\tif ( is_wp_error( $prepared_args ) ) {\n\t\t\t\treturn $prepared_args;\n\t\t\t}\n\n\t\t\tif ( isset( $prepared_args['comment_content'] ) && empty( $prepared_args['comment_content'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_content_invalid', __( 'Invalid comment content.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$prepared_args['comment_ID'] = $id;\n\n\t\t\t$check_comment_lengths = wp_check_comment_data_max_lengths( $prepared_args );\n\t\t\tif ( is_wp_error( $check_comment_lengths ) ) {\n\t\t\t\t$error_code = $check_comment_lengths->get_error_code();\n\t\t\t\treturn new WP_Error( $error_code, __( 'Comment field exceeds maximum length allowed.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$updated = wp_update_comment( wp_slash( (array) $prepared_args ) );\n\n\t\t\tif ( false === $updated ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_failed_edit', __( 'Updating comment failed.' ), array( 'status' => 500 ) );\n\t\t\t}\n\n\t\t\tif ( isset( $request['status'] ) ) {\n\t\t\t\t$this->handle_status_param( $request['status'], $id );\n\t\t\t}\n\t\t}\n\n\t\t$comment = get_comment( $id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-comments-controller.php */\n\t\tdo_action( 'rest_insert_comment', $comment, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $comment, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to delete the item, error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$id      = (int) $request['id'];\n\t\t$comment = get_comment( $id );\n\n\t\tif ( ! $comment ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_id', __( 'Invalid comment ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( ! $this->check_edit_permission( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$id    = (int) $request['id'];\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t$comment = get_comment( $id );\n\n\t\tif ( empty( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_id', __( 'Invalid comment ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters whether a comment can be trashed.\n\t\t *\n\t\t * Return false to disable trash support for the post.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param bool    $supports_trash Whether the post type support trashing.\n\t\t * @param WP_Post $comment        The comment object being considered for trashing support.\n\t\t */\n\t\t$supports_trash = apply_filters( 'rest_comment_trashable', ( EMPTY_TRASH_DAYS > 0 ), $comment );\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\tif ( $force ) {\n\t\t\t$previous = $this->prepare_item_for_response( $comment, $request );\n\t\t\t$result = wp_delete_comment( $comment->comment_ID, true );\n\t\t\t$response = new WP_REST_Response();\n\t\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\t} else {\n\t\t\t// If this type doesn't support trashing, error out.\n\t\t\tif ( ! $supports_trash ) {\n\t\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'The comment does not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t\t}\n\n\t\t\tif ( 'trash' === $comment->comment_approved ) {\n\t\t\t\treturn new WP_Error( 'rest_already_trashed', __( 'The comment has already been trashed.' ), array( 'status' => 410 ) );\n\t\t\t}\n\n\t\t\t$result = wp_trash_comment( $comment->comment_ID );\n\t\t\t$comment = get_comment( $comment->comment_ID );\n\t\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\t\t}\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The comment cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t/**\n\t\t * Fires after a comment is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Comment       $comment  The deleted comment data.\n\t\t * @param WP_REST_Response $response The response returned from the API.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_comment', $comment, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares a single comment output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Comment      $comment Comment object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $comment, $request ) {\n\t\t$data = array(\n\t\t\t'id'                 => (int) $comment->comment_ID,\n\t\t\t'post'               => (int) $comment->comment_post_ID,\n\t\t\t'parent'             => (int) $comment->comment_parent,\n\t\t\t'author'             => (int) $comment->user_id,\n\t\t\t'author_name'        => $comment->comment_author,\n\t\t\t'author_email'       => $comment->comment_author_email,\n\t\t\t'author_url'         => $comment->comment_author_url,\n\t\t\t'author_ip'          => $comment->comment_author_IP,\n\t\t\t'author_user_agent'  => $comment->comment_agent,\n\t\t\t'date'               => mysql_to_rfc3339( $comment->comment_date ),\n\t\t\t'date_gmt'           => mysql_to_rfc3339( $comment->comment_date_gmt ),\n\t\t\t'content'            => array(\n\t\t\t\t/** This filter is documented in wp-includes/comment-template.php */\n\t\t\t\t'rendered' => apply_filters( 'comment_text', $comment->comment_content, $comment ),\n\t\t\t\t'raw'      => $comment->comment_content,\n\t\t\t),\n\t\t\t'link'               => get_comment_link( $comment ),\n\t\t\t'status'             => $this->prepare_status_response( $comment->comment_approved ),\n\t\t\t'type'               => get_comment_type( $comment->comment_ID ),\n\t\t);\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['author_avatar_urls'] ) ) {\n\t\t\t$data['author_avatar_urls'] = rest_get_avatar_urls( $comment->comment_author_email );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $comment->comment_ID, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $comment ) );\n\n\t\t/**\n\t\t * Filters a comment returned from the API.\n\t\t *\n\t\t * Allows modification of the comment right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response  $response The response object.\n\t\t * @param WP_Comment        $comment  The original comment object.\n\t\t * @param WP_REST_Request   $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_comment', $response, $comment, $request );\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Comment $comment Comment object.\n\t * @return array Links for the given comment.\n\t */\n\tprotected function prepare_links( $comment ) {\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment->comment_ID ) ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t);\n\n\t\tif ( 0 !== (int) $comment->user_id ) {\n\t\t\t$links['author'] = array(\n\t\t\t\t'href'       => rest_url( 'wp/v2/users/' . $comment->user_id ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( 0 !== (int) $comment->comment_post_ID ) {\n\t\t\t$post = get_post( $comment->comment_post_ID );\n\n\t\t\tif ( ! empty( $post->ID ) ) {\n\t\t\t\t$obj = get_post_type_object( $post->post_type );\n\t\t\t\t$base = ! empty( $obj->rest_base ) ? $obj->rest_base : $obj->name;\n\n\t\t\t\t$links['up'] = array(\n\t\t\t\t\t'href'       => rest_url( 'wp/v2/' . $base . '/' . $comment->comment_post_ID ),\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t\t'post_type'  => $post->post_type,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( 0 !== (int) $comment->comment_parent ) {\n\t\t\t$links['in-reply-to'] = array(\n\t\t\t\t'href'       => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment->comment_parent ) ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\t// Only grab one comment to verify the comment has children.\n\t\t$comment_children = $comment->get_children( array(\n\t\t\t'number' => 1,\n\t\t\t'count'  => true\n\t\t) );\n\n\t\tif ( ! empty( $comment_children ) ) {\n\t\t\t$args = array(\n\t\t\t\t'parent' => $comment->comment_ID\n\t\t\t);\n\n\t\t\t$rest_url = add_query_arg( $args, rest_url( $this->namespace . '/' . $this->rest_base ) );\n\n\t\t\t$links['children'] = array(\n\t\t\t\t'href' => $rest_url,\n\t\t\t);\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Prepends internal property prefix to query parameters to match our response fields.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $query_param Query parameter.\n\t * @return string The normalized query parameter.\n\t */\n\tprotected function normalize_query_param( $query_param ) {\n\t\t$prefix = 'comment_';\n\n\t\tswitch ( $query_param ) {\n\t\t\tcase 'id':\n\t\t\t\t$normalized = $prefix . 'ID';\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\t$normalized = $prefix . 'post_ID';\n\t\t\t\tbreak;\n\t\t\tcase 'parent':\n\t\t\t\t$normalized = $prefix . 'parent';\n\t\t\t\tbreak;\n\t\t\tcase 'include':\n\t\t\t\t$normalized = 'comment__in';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$normalized = $prefix . $query_param;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $normalized;\n\t}\n\n\t/**\n\t * Checks comment_approved to set comment status for single comment output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string|int $comment_approved comment status.\n\t * @return string Comment status.\n\t */\n\tprotected function prepare_status_response( $comment_approved ) {\n\n\t\tswitch ( $comment_approved ) {\n\t\t\tcase 'hold':\n\t\t\tcase '0':\n\t\t\t\t$status = 'hold';\n\t\t\t\tbreak;\n\n\t\t\tcase 'approve':\n\t\t\tcase '1':\n\t\t\t\t$status = 'approved';\n\t\t\t\tbreak;\n\n\t\t\tcase 'spam':\n\t\t\tcase 'trash':\n\t\t\tdefault:\n\t\t\t\t$status = $comment_approved;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Prepares a single comment to be inserted into the database.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return array|WP_Error Prepared comment, otherwise WP_Error object.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_comment = array();\n\n\t\t/*\n\t\t * Allow the comment_content to be set via the 'content' or\n\t\t * the 'content.raw' properties of the Request object.\n\t\t */\n\t\tif ( isset( $request['content'] ) && is_string( $request['content'] ) ) {\n\t\t\t$prepared_comment['comment_content'] = $request['content'];\n\t\t} elseif ( isset( $request['content']['raw'] ) && is_string( $request['content']['raw'] ) ) {\n\t\t\t$prepared_comment['comment_content'] = $request['content']['raw'];\n\t\t}\n\n\t\tif ( isset( $request['post'] ) ) {\n\t\t\t$prepared_comment['comment_post_ID'] = (int) $request['post'];\n\t\t}\n\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\t$prepared_comment['comment_parent'] = $request['parent'];\n\t\t}\n\n\t\tif ( isset( $request['author'] ) ) {\n\t\t\t$user = new WP_User( $request['author'] );\n\n\t\t\tif ( $user->exists() ) {\n\t\t\t\t$prepared_comment['user_id'] = $user->ID;\n\t\t\t\t$prepared_comment['comment_author'] = $user->display_name;\n\t\t\t\t$prepared_comment['comment_author_email'] = $user->user_email;\n\t\t\t\t$prepared_comment['comment_author_url'] = $user->user_url;\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_comment_author_invalid', __( 'Invalid comment author ID.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $request['author_name'] ) ) {\n\t\t\t$prepared_comment['comment_author'] = $request['author_name'];\n\t\t}\n\n\t\tif ( isset( $request['author_email'] ) ) {\n\t\t\t$prepared_comment['comment_author_email'] = $request['author_email'];\n\t\t}\n\n\t\tif ( isset( $request['author_url'] ) ) {\n\t\t\t$prepared_comment['comment_author_url'] = $request['author_url'];\n\t\t}\n\n\t\tif ( isset( $request['author_ip'] ) && current_user_can( 'moderate_comments' ) ) {\n\t\t\t$prepared_comment['comment_author_IP'] = $request['author_ip'];\n\t\t} elseif ( ! empty( $_SERVER['REMOTE_ADDR'] ) && rest_is_ip_address( $_SERVER['REMOTE_ADDR'] ) ) {\n\t\t\t$prepared_comment['comment_author_IP'] = $_SERVER['REMOTE_ADDR'];\n\t\t} else {\n\t\t\t$prepared_comment['comment_author_IP'] = '127.0.0.1';\n\t\t}\n\n\t\tif ( ! empty( $request['author_user_agent'] ) ) {\n\t\t\t$prepared_comment['comment_agent'] = $request['author_user_agent'];\n\t\t} elseif ( $request->get_header( 'user_agent' ) ) {\n\t\t\t$prepared_comment['comment_agent'] = $request->get_header( 'user_agent' );\n\t\t}\n\n\t\tif ( ! empty( $request['date'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date'] );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_comment['comment_date'], $prepared_comment['comment_date_gmt'] ) = $date_data;\n\t\t\t}\n\t\t} elseif ( ! empty( $request['date_gmt'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date_gmt'], true );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_comment['comment_date'], $prepared_comment['comment_date_gmt'] ) = $date_data;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters a comment after it is prepared for the database.\n\t\t *\n\t\t * Allows modification of the comment right after it is prepared for the database.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array           $prepared_comment The prepared comment data for `wp_insert_comment`.\n\t\t * @param WP_REST_Request $request          The current request.\n\t\t */\n\t\treturn apply_filters( 'rest_preprocess_comment', $prepared_comment, $request );\n\t}\n\n\t/**\n\t * Retrieves the comment's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'comment',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'id'               => array(\n\t\t\t\t\t'description'  => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'author'           => array(\n\t\t\t\t\t'description'  => __( 'The ID of the user object, if author was a user.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'author_email'     => array(\n\t\t\t\t\t'description'  => __( 'Email address for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'email',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_comment_author_email' ),\n\t\t\t\t\t\t'validate_callback' => null, // skip built-in validation of 'email'.\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'author_ip'     => array(\n\t\t\t\t\t'description'  => __( 'IP address for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'ip',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'author_name'     => array(\n\t\t\t\t\t'description'  => __( 'Display name for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'author_url'       => array(\n\t\t\t\t\t'description'  => __( 'URL for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'author_user_agent'     => array(\n\t\t\t\t\t'description'  => __( 'User agent for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'content'          => array(\n\t\t\t\t\t'description'     => __( 'The content for the object.' ),\n\t\t\t\t\t'type'            => 'object',\n\t\t\t\t\t'context'         => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options'     => array(\n\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t),\n\t\t\t\t\t'properties'      => array(\n\t\t\t\t\t\t'raw'         => array(\n\t\t\t\t\t\t\t'description'     => __( 'Content for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t'type'            => 'string',\n\t\t\t\t\t\t\t'context'         => array( 'edit' ),\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'rendered'    => array(\n\t\t\t\t\t\t\t'description'     => __( 'HTML content for the object, transformed for display.' ),\n\t\t\t\t\t\t\t'type'            => 'string',\n\t\t\t\t\t\t\t'context'         => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t'readonly'        => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'date'             => array(\n\t\t\t\t\t'description'  => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'date-time',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'         => array(\n\t\t\t\t\t'description'  => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'date-time',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'             => array(\n\t\t\t\t\t'description'  => __( 'URL to the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'parent'           => array(\n\t\t\t\t\t'description'  => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'default'      => 0,\n\t\t\t\t),\n\t\t\t\t'post'             => array(\n\t\t\t\t\t'description'  => __( 'The ID of the associated post object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'default'      => 0,\n\t\t\t\t),\n\t\t\t\t'status'           => array(\n\t\t\t\t\t'description'  => __( 'State of the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'type'             => array(\n\t\t\t\t\t'description'  => __( 'Type of Comment for the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif ( get_option( 'show_avatars' ) ) {\n\t\t\t$avatar_properties = array();\n\n\t\t\t$avatar_sizes = rest_get_avatar_sizes();\n\t\t\tforeach ( $avatar_sizes as $size ) {\n\t\t\t\t$avatar_properties[ $size ] = array(\n\t\t\t\t\t/* translators: %d: avatar image size in pixels */\n\t\t\t\t\t'description' => sprintf( __( 'Avatar URL with image size of %d pixels.' ), $size ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$schema['properties']['author_avatar_urls'] = array(\n\t\t\t\t'description'   => __( 'Avatar URLs for the object author.' ),\n\t\t\t\t'type'          => 'object',\n\t\t\t\t'context'       => array( 'view', 'edit', 'embed' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'properties'    => $avatar_properties,\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Comments collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['after'] = array(\n\t\t\t'description'       => __( 'Limit response to comments published after a given ISO8601 compliant date.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'format'            => 'date-time',\n\t\t);\n\n\t\t$query_params['author'] = array(\n\t\t\t'description'       => __( 'Limit result set to comments assigned to specific user IDs. Requires authorization.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['author_exclude'] = array(\n\t\t\t'description'       => __( 'Ensure result set excludes comments assigned to specific user IDs. Requires authorization.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['author_email'] = array(\n\t\t\t'default'           => null,\n\t\t\t'description'       => __( 'Limit result set to that from a specific author email. Requires authorization.' ),\n\t\t\t'format'            => 'email',\n\t\t\t'type'              => 'string',\n\t\t);\n\n\t\t$query_params['before'] = array(\n\t\t\t'description'       => __( 'Limit response to comments published before a given ISO8601 compliant date.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'format'            => 'date-time',\n\t\t);\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order']      = array(\n\t\t\t'description'           => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'                  => 'string',\n\t\t\t'default'               => 'desc',\n\t\t\t'enum'                  => array(\n\t\t\t\t'asc',\n\t\t\t\t'desc',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['orderby']    = array(\n\t\t\t'description'           => __( 'Sort collection by object attribute.' ),\n\t\t\t'type'                  => 'string',\n\t\t\t'default'               => 'date_gmt',\n\t\t\t'enum'                  => array(\n\t\t\t\t'date',\n\t\t\t\t'date_gmt',\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'post',\n\t\t\t\t'parent',\n\t\t\t\t'type',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['parent'] = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Limit result set to comments of specific parent IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['parent_exclude'] = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Ensure result set excludes specific parent IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['post']   = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Limit result set to comments assigned to specific post IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['status'] = array(\n\t\t\t'default'           => 'approve',\n\t\t\t'description'       => __( 'Limit result set to comments assigned a specific status. Requires authorization.' ),\n\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t'type'              => 'string',\n\t\t\t'validate_callback' => 'rest_validate_request_arg',\n\t\t);\n\n\t\t$query_params['type'] = array(\n\t\t\t'default'           => 'comment',\n\t\t\t'description'       => __( 'Limit result set to comments assigned a specific type. Requires authorization.' ),\n\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t'type'              => 'string',\n\t\t\t'validate_callback' => 'rest_validate_request_arg',\n\t\t);\n\n\t\t$query_params['password'] = array(\n\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t'type'        => 'string',\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the comments controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Comment_Query parameter. Use the\n\t\t * `rest_comment_query` filter to set WP_Comment_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array $query_params JSON Schema-formatted collection parameters.\n\t\t */\n\t\treturn apply_filters( 'rest_comment_collection_params', $query_params );\n\t}\n\n\t/**\n\t * Sets the comment_status of a given comment object when creating or updating a comment.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string|int $new_status New comment status.\n\t * @param int        $comment_id Comment ID.\n\t * @return bool Whether the status was changed.\n\t */\n\tprotected function handle_status_param( $new_status, $comment_id ) {\n\t\t$old_status = wp_get_comment_status( $comment_id );\n\n\t\tif ( $new_status === $old_status ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch ( $new_status ) {\n\t\t\tcase 'approved' :\n\t\t\tcase 'approve':\n\t\t\tcase '1':\n\t\t\t\t$changed = wp_set_comment_status( $comment_id, 'approve' );\n\t\t\t\tbreak;\n\t\t\tcase 'hold':\n\t\t\tcase '0':\n\t\t\t\t$changed = wp_set_comment_status( $comment_id, 'hold' );\n\t\t\t\tbreak;\n\t\t\tcase 'spam' :\n\t\t\t\t$changed = wp_spam_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'unspam' :\n\t\t\t\t$changed = wp_unspam_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'trash' :\n\t\t\t\t$changed = wp_trash_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'untrash' :\n\t\t\t\t$changed = wp_untrash_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\t$changed = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $changed;\n\t}\n\n\t/**\n\t * Checks if the post can be read.\n\t *\n\t * Correctly handles posts with the inherit status.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post         $post    Post object.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool Whether post can be read.\n\t */\n\tprotected function check_read_post_permission( $post, $request ) {\n\t\t$posts_controller = new WP_REST_Posts_Controller( $post->post_type );\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\t$has_password_filter = false;\n\n\t\t// Only check password if a specific post was queried for or a single comment\n\t\t$requested_post = ! empty( $request['post'] ) && 1 === count( $request['post'] );\n\t\t$requested_comment = ! empty( $request['id'] );\n\t\tif ( ( $requested_post || $requested_comment ) && $posts_controller->can_access_password_content( $post, $request ) ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\n\t\t\t$has_password_filter = true;\n\t\t}\n\n\t\tif ( post_password_required( $post ) ) {\n\t\t\t$result = current_user_can( $post_type->cap->edit_post, $post->ID );\n\t\t} else {\n\t\t\t$result = $posts_controller->check_read_permission( $post );\n\t\t}\n\n\t\tif ( $has_password_filter ) {\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Checks if the comment can be read.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Comment      $comment Comment object.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool Whether the comment can be read.\n\t */\n\tprotected function check_read_permission( $comment, $request ) {\n\t\tif ( ! empty( $comment->comment_post_ID ) ) {\n\t\t\t$post = get_post( $comment->comment_post_ID );\n\t\t\tif ( $post ) {\n\t\t\t\tif ( $this->check_read_post_permission( $post, $request ) && 1 === (int) $comment->comment_approved ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( 0 === get_current_user_id() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $comment->comment_post_ID ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! empty( $comment->user_id ) && get_current_user_id() === (int) $comment->user_id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn current_user_can( 'edit_comment', $comment->comment_ID );\n\t}\n\n\t/**\n\t * Checks if a comment can be edited or deleted.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $comment Comment object.\n\t * @return bool Whether the comment can be edited or deleted.\n\t */\n\tprotected function check_edit_permission( $comment ) {\n\t\tif ( 0 === (int) get_current_user_id() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( 'edit_comment', $comment->comment_ID );\n\t}\n\n\t/**\n\t * Checks a comment author email for validity.\n\t *\n\t * Accepts either a valid email address or empty string as a valid comment\n\t * author email address. Setting the comment author email to an empty\n\t * string is allowed when a comment is being updated.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string          $value   Author email value submitted.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @param string          $param   The parameter name.\n\t * @return WP_Error|string The sanitized email address, if valid,\n\t *                         otherwise an error.\n\t */\n\tpublic function check_comment_author_email( $value, $request, $param ) {\n\t\t$email = (string) $value;\n\t\tif ( empty( $email ) ) {\n\t\t\treturn $email;\n\t\t}\n\n\t\t$check_email = rest_validate_request_arg( $email, $request, $param );\n\t\tif ( is_wp_error( $check_email ) ) {\n\t\t\treturn $check_email;\n\t\t}\n\n\t\treturn $email;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Post_Statuses_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to access post statuses via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Post_Statuses_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'statuses';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<status>[\\w-]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read post statuses.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'objects' );\n\n\t\t\tforeach ( $types as $type ) {\n\t\t\t\tif ( current_user_can( $type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all post statuses, depending on user context.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$data = array();\n\t\t$statuses = get_post_stati( array( 'internal' => false ), 'object' );\n\t\t$statuses['trash'] = get_post_status_object( 'trash' );\n\n\t\tforeach ( $statuses as $slug => $obj ) {\n\t\t\t$ret = $this->check_read_permission( $obj );\n\n\t\t\tif ( ! $ret ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$status = $this->prepare_item_for_response( $obj, $request );\n\t\t\t$data[ $obj->name ] = $this->prepare_response_for_collection( $status );\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a post status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$status = get_post_status_object( $request['status'] );\n\n\t\tif ( empty( $status ) ) {\n\t\t\treturn new WP_Error( 'rest_status_invalid', __( 'Invalid status.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$check = $this->check_read_permission( $status );\n\n\t\tif ( ! $check ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_status', __( 'Cannot view status.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether a given post status should be visible.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $status Post status.\n\t * @return bool True if the post status is visible, otherwise false.\n\t */\n\tprotected function check_read_permission( $status ) {\n\t\tif ( true === $status->public ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( false === $status->internal || 'trash' === $status->name ) {\n\t\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'objects' );\n\n\t\t\tforeach ( $types as $type ) {\n\t\t\t\tif ( current_user_can( $type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves a specific post status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$obj = get_post_status_object( $request['status'] );\n\n\t\tif ( empty( $obj ) ) {\n\t\t\treturn new WP_Error( 'rest_status_invalid', __( 'Invalid status.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $obj, $request );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a post status object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $status  Post status data.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response Post status data.\n\t */\n\tpublic function prepare_item_for_response( $status, $request ) {\n\n\t\t$data = array(\n\t\t\t'name'         => $status->label,\n\t\t\t'private'      => (bool) $status->private,\n\t\t\t'protected'    => (bool) $status->protected,\n\t\t\t'public'       => (bool) $status->public,\n\t\t\t'queryable'    => (bool) $status->publicly_queryable,\n\t\t\t'show_in_list' => (bool) $status->show_in_admin_all_list,\n\t\t\t'slug'         => $status->name,\n\t\t);\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( 'publish' === $status->name ) {\n\t\t\t$response->add_link( 'archives', rest_url( 'wp/v2/posts' ) );\n\t\t} else {\n\t\t\t$response->add_link( 'archives', add_query_arg( 'status', $status->name, rest_url( 'wp/v2/posts' ) ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters a status returned from the REST API.\n\t\t *\n\t\t * Allows modification of the status data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $status   The original status object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_status', $response, $status, $request );\n\t}\n\n\t/**\n\t * Retrieves the post status' schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'status',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the status.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'private'          => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be private.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'protected'        => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be protected.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'public'           => array(\n\t\t\t\t\t'description'  => __( 'Whether posts of this status should be shown in the front end of the site.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'queryable'        => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be publicly-queryable.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'show_in_list'     => array(\n\t\t\t\t\t'description'  => __( 'Whether to include posts in the edit listing for their post type.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the status.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Post_Types_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class to access post types via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Post_Types_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'types';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<type>[\\w-]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::READABLE,\n\t\t\t\t'callback' => array( $this, 'get_item' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read types.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|true True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tforeach ( get_post_types( array(), 'object' ) as $post_type ) {\n\t\t\t\tif ( ! empty( $post_type->show_in_rest ) && current_user_can( $post_type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all public post types.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$data = array();\n\n\t\tforeach ( get_post_types( array(), 'object' ) as $obj ) {\n\t\t\tif ( empty( $obj->show_in_rest ) || ( 'edit' === $request['context'] && ! current_user_can( $obj->cap->edit_posts ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$post_type = $this->prepare_item_for_response( $obj, $request );\n\t\t\t$data[ $obj->name ] = $this->prepare_response_for_collection( $post_type );\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Retrieves a specific post type.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$obj = get_post_type_object( $request['type'] );\n\n\t\tif ( empty( $obj ) ) {\n\t\t\treturn new WP_Error( 'rest_type_invalid', __( 'Invalid post type.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( empty( $obj->show_in_rest ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_type', __( 'Cannot view post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $obj->cap->edit_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $obj, $request );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a post type object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $post_type Post type data.\n\t * @param WP_REST_Request $request   Full details about the request.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post_type, $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $post_type->name, 'objects' ), array( 'show_in_rest' => true ) );\n\t\t$taxonomies = wp_list_pluck( $taxonomies, 'name' );\n\t\t$base = ! empty( $post_type->rest_base ) ? $post_type->rest_base : $post_type->name;\n\t\t$supports = get_all_post_type_supports( $post_type->name );\n\n\t\t$data = array(\n\t\t\t'capabilities' => $post_type->cap,\n\t\t\t'description'  => $post_type->description,\n\t\t\t'hierarchical' => $post_type->hierarchical,\n\t\t\t'labels'       => $post_type->labels,\n\t\t\t'name'         => $post_type->label,\n\t\t\t'slug'         => $post_type->name,\n\t\t\t'supports'     => $supports,\n\t\t\t'taxonomies'   => array_values( $taxonomies ),\n\t\t\t'rest_base'    => $base,\n\t\t);\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( array(\n\t\t\t'collection' => array(\n\t\t\t\t'href'   => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t\t'https://api.w.org/items' => array(\n\t\t\t\t'href' => rest_url( sprintf( 'wp/v2/%s', $base ) ),\n\t\t\t),\n\t\t) );\n\n\t\t/**\n\t\t * Filters a post type returned from the API.\n\t\t *\n\t\t * Allows modification of the post type data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $item     The original post type object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_post_type', $response, $post_type, $request );\n\t}\n\n\t/**\n\t * Retrieves the post type's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'type',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'capabilities'     => array(\n\t\t\t\t\t'description'  => __( 'All capabilities used by the post type.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description'      => array(\n\t\t\t\t\t'description'  => __( 'A human-readable description of the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'hierarchical'     => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the post type should have children.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'labels'           => array(\n\t\t\t\t\t'description'  => __( 'Human-readable labels for the post type for various contexts.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'supports'         => array(\n\t\t\t\t\t'description'  => __( 'All features, supported by the post type.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'taxonomies'       => array(\n\t\t\t\t\t'description'  => __( 'Taxonomies associated with post type.' ),\n\t\t\t\t\t'type'         => 'array',\n\t\t\t\t\t'items'        => array(\n\t\t\t\t\t\t'type' => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'rest_base'            => array(\n\t\t\t\t\t'description'  => __( 'REST base route for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Posts_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class to access posts via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Posts_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Post type.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $post_type;\n\n\t/**\n\t * Instance of a post meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Post_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $post_type Post type.\n\t */\n\tpublic function __construct( $post_type ) {\n\t\t$this->post_type = $post_type;\n\t\t$this->namespace = 'wp/v2';\n\t\t$obj = get_post_type_object( $post_type );\n\t\t$this->rest_base = ! empty( $obj->rest_base ) ? $obj->rest_base : $obj->name;\n\n\t\t$this->meta = new WP_REST_Post_Meta_Fields( $this->post_type );\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\t$schema = $this->get_item_schema();\n\t\t$get_item_args = array(\n\t\t\t'context'  => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t\tif ( isset( $schema['properties']['password'] ) ) {\n\t\t\t$get_item_args['password'] = array(\n\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t'type'        => 'string',\n\t\t\t);\n\t\t}\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => $get_item_args,\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Whether to bypass trash and force deletion.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read posts.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $post_type->cap->edit_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a collection of posts.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Ensure a search string is set in case the orderby is set to 'relevance'.\n\t\tif ( ! empty( $request['orderby'] ) && 'relevance' === $request['orderby'] && empty( $request['search'] ) ) {\n\t\t\treturn new WP_Error( 'rest_no_search_term_defined', __( 'You need to define a search term to order by relevance.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Ensure an include parameter is set in case the orderby is set to 'include'.\n\t\tif ( ! empty( $request['orderby'] ) && 'include' === $request['orderby'] && empty( $request['include'] ) ) {\n\t\t\treturn new WP_Error( 'rest_orderby_include_missing_include', sprintf( __( 'Missing parameter(s): %s' ), 'include' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\t\t$args = array();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'author'         => 'author__in',\n\t\t\t'author_exclude' => 'author__not_in',\n\t\t\t'exclude'        => 'post__not_in',\n\t\t\t'include'        => 'post__in',\n\t\t\t'menu_order'     => 'menu_order',\n\t\t\t'offset'         => 'offset',\n\t\t\t'order'          => 'order',\n\t\t\t'orderby'        => 'orderby',\n\t\t\t'page'           => 'paged',\n\t\t\t'parent'         => 'post_parent__in',\n\t\t\t'parent_exclude' => 'post_parent__not_in',\n\t\t\t'search'         => 's',\n\t\t\t'slug'           => 'post_name__in',\n\t\t\t'status'         => 'post_status',\n\t\t);\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\t// Check for & assign any parameters which require special handling or setting.\n\t\t$args['date_query'] = array();\n\n\t\t// Set before into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['before'], $request['before'] ) ) {\n\t\t\t$args['date_query'][0]['before'] = $request['before'];\n\t\t}\n\n\t\t// Set after into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['after'], $request['after'] ) ) {\n\t\t\t$args['date_query'][0]['after'] = $request['after'];\n\t\t}\n\n\t\t// Ensure our per_page parameter overrides any provided posts_per_page filter.\n\t\tif ( isset( $registered['per_page'] ) ) {\n\t\t\t$args['posts_per_page'] = $request['per_page'];\n\t\t}\n\n\t\tif ( isset( $registered['sticky'], $request['sticky'] ) ) {\n\t\t\t$sticky_posts = get_option( 'sticky_posts', array() );\n\t\t\tif ( $sticky_posts && $request['sticky'] ) {\n\t\t\t\t/*\n\t\t\t\t * As post__in will be used to only get sticky posts,\n\t\t\t\t * we have to support the case where post__in was already\n\t\t\t\t * specified.\n\t\t\t\t */\n\t\t\t\t$args['post__in'] = $args['post__in'] ? array_intersect( $sticky_posts, $args['post__in'] ) : $sticky_posts;\n\n\t\t\t\t/*\n\t\t\t\t * If we intersected, but there are no post ids in common,\n\t\t\t\t * WP_Query won't return \"no posts\" for post__in = array()\n\t\t\t\t * so we have to fake it a bit.\n\t\t\t\t */\n\t\t\t\tif ( ! $args['post__in'] ) {\n\t\t\t\t\t$args['post__in'] = array( -1 );\n\t\t\t\t}\n\t\t\t} elseif ( $sticky_posts ) {\n\t\t\t\t/*\n\t\t\t\t * As post___not_in will be used to only get posts that\n\t\t\t\t * are not sticky, we have to support the case where post__not_in\n\t\t\t\t * was already specified.\n\t\t\t\t */\n\t\t\t\t$args['post__not_in'] = array_merge( $args['post__not_in'], $sticky_posts );\n\t\t\t}\n\t\t}\n\n\t\t// Force the post_type argument, since it's not a user input variable.\n\t\t$args['post_type'] = $this->post_type;\n\n\t\t/**\n\t\t * Filters the query arguments for a request.\n\t\t *\n\t\t * Enables adding extra arguments or setting defaults for a post collection request.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_query/\n\t\t *\n\t\t * @param array           $args    Key value array of query var to query value.\n\t\t * @param WP_REST_Request $request The request used.\n\t\t */\n\t\t$args = apply_filters( \"rest_{$this->post_type}_query\", $args, $request );\n\t\t$query_args = $this->prepare_items_query( $args, $request );\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t\t$tax_exclude = $base . '_exclude';\n\n\t\t\tif ( ! empty( $request[ $base ] ) ) {\n\t\t\t\t$query_args['tax_query'][] = array(\n\t\t\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'terms'            => $request[ $base ],\n\t\t\t\t\t'include_children' => false,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $request[ $tax_exclude ] ) ) {\n\t\t\t\t$query_args['tax_query'][] = array(\n\t\t\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'terms'            => $request[ $tax_exclude ],\n\t\t\t\t\t'include_children' => false,\n\t\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$posts_query  = new WP_Query();\n\t\t$query_result = $posts_query->query( $query_args );\n\n\t\t// Allow access to all password protected posts if the context is edit.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\t$posts = array();\n\n\t\tforeach ( $query_result as $post ) {\n\t\t\tif ( ! $this->check_read_permission( $post ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data    = $this->prepare_item_for_response( $post, $request );\n\t\t\t$posts[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t// Reset filter.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\t$page = (int) $query_args['paged'];\n\t\t$total_posts = $posts_query->found_posts;\n\n\t\tif ( $total_posts < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $query_args['paged'] );\n\n\t\t\t$count_query = new WP_Query();\n\t\t\t$count_query->query( $query_args );\n\t\t\t$total_posts = $count_query->found_posts;\n\t\t}\n\n\t\t$max_pages = ceil( $total_posts / (int) $posts_query->query_vars['posts_per_page'] );\n\t\t$response  = rest_ensure_response( $posts );\n\n\t\t$response->header( 'X-WP-Total', (int) $total_posts );\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$request_params = $request->get_query_params();\n\t\t$base = add_query_arg( $request_params, rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\n\t\t$post = get_post( (int) $request['id'] );\n\n\t\tif ( 'edit' === $request['context'] && $post && ! $this->check_update_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( $post && ! empty( $request['password'] ) ) {\n\t\t\t// Check post password, and return error if invalid.\n\t\t\tif ( ! hash_equals( $post->post_password, $request['password'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_post_incorrect_password', __( 'Incorrect post password.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Allow access to all password protected posts if the context is edit.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\tif ( $post ) {\n\t\t\treturn $this->check_read_permission( $post );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the user can access password-protected content.\n\t *\n\t * This method determines whether we need to override the regular password\n\t * check in core with a filter.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post to check against.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool True if the user can access password-protected content, otherwise false.\n\t */\n\tpublic function can_access_password_content( $post, $request ) {\n\t\tif ( empty( $post->post_password ) ) {\n\t\t\t// No filter required.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Edit context always gets access to password-protected posts.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// No password, no auth.\n\t\tif ( empty( $request['password'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Double-check the request password.\n\t\treturn hash_equals( $post->post_password, $request['password'] );\n\t}\n\n\t/**\n\t * Retrieves a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$id   = (int) $request['id'];\n\t\t$post = get_post( $id );\n\n\t\tif ( empty( $id ) || empty( $post->ID ) || $this->post_type !== $post->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$data     = $this->prepare_item_for_response( $post, $request );\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( is_post_type_viewable( get_post_type_object( $post->post_type ) ) ) {\n\t\t\t$response->link_header( 'alternate',  get_permalink( $id ), array( 'type' => 'text/html' ) );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to create a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to create items, WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( ! empty( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to create posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['sticky'] ) && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! current_user_can( $post_type->cap->create_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create', __( 'Sorry, you are not allowed to create posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! $this->check_assign_terms_permission( $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_post_exists', __( 'Cannot create existing post.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_post = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $prepared_post ) ) {\n\t\t\treturn $prepared_post;\n\t\t}\n\n\t\t$prepared_post->post_type = $this->post_type;\n\n\t\t$post_id = wp_insert_post( wp_slash( (array) $prepared_post ), true );\n\n\t\tif ( is_wp_error( $post_id ) ) {\n\n\t\t\tif ( 'db_insert_error' === $post_id->get_error_code() ) {\n\t\t\t\t$post_id->add_data( array( 'status' => 500 ) );\n\t\t\t} else {\n\t\t\t\t$post_id->add_data( array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\treturn $post_id;\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\n\t\t/**\n\t\t * Fires after a single post is created or updated via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Post         $post     Inserted or updated post object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a post, false when updating.\n\t\t */\n\t\tdo_action( \"rest_insert_{$this->post_type}\", $post, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) ) {\n\t\t\tif ( ! empty( $request['sticky'] ) ) {\n\t\t\t\tstick_post( $post_id );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_id );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) && isset( $request['featured_media'] ) ) {\n\t\t\t$this->handle_featured_media( $request['featured_media'], $post_id );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['format'] ) && ! empty( $request['format'] ) ) {\n\t\t\tset_post_format( $post, $request['format'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) && isset( $request['template'] ) ) {\n\t\t\t$this->handle_template( $request['template'], $post_id );\n\t\t}\n\n\t\t$terms_update = $this->handle_terms( $post_id, $request );\n\n\t\tif ( is_wp_error( $terms_update ) ) {\n\t\t\treturn $terms_update;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $post_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $post, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $post, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $post_id ) ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\n\t\t$post = get_post( $request['id'] );\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( $post && ! $this->check_update_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['sticky'] ) && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! $this->check_assign_terms_permission( $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$id   = (int) $request['id'];\n\t\t$post = get_post( $id );\n\n\t\tif ( empty( $id ) || empty( $post->ID ) || $this->post_type !== $post->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$post = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\t// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.\n\t\t$post_id = wp_update_post( wp_slash( (array) $post ), true );\n\n\t\tif ( is_wp_error( $post_id ) ) {\n\t\t\tif ( 'db_update_error' === $post_id->get_error_code() ) {\n\t\t\t\t$post_id->add_data( array( 'status' => 500 ) );\n\t\t\t} else {\n\t\t\t\t$post_id->add_data( array( 'status' => 400 ) );\n\t\t\t}\n\t\t\treturn $post_id;\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php */\n\t\tdo_action( \"rest_insert_{$this->post_type}\", $post, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['format'] ) && ! empty( $request['format'] ) ) {\n\t\t\tset_post_format( $post, $request['format'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) && isset( $request['featured_media'] ) ) {\n\t\t\t$this->handle_featured_media( $request['featured_media'], $post_id );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) && isset( $request['sticky'] ) ) {\n\t\t\tif ( ! empty( $request['sticky'] ) ) {\n\t\t\t\tstick_post( $post_id );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_id );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) && isset( $request['template'] ) ) {\n\t\t\t$this->handle_template( $request['template'], $post->ID );\n\t\t}\n\n\t\t$terms_update = $this->handle_terms( $post->ID, $request );\n\n\t\tif ( is_wp_error( $terms_update ) ) {\n\t\t\treturn $terms_update;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $post->ID );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $post, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $post, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\n\t\t$post = get_post( $request['id'] );\n\n\t\tif ( $post && ! $this->check_delete_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$id    = (int) $request['id'];\n\t\t$force = (bool) $request['force'];\n\n\t\t$post = get_post( $id );\n\n\t\tif ( empty( $id ) || empty( $post->ID ) || $this->post_type !== $post->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$supports_trash = ( EMPTY_TRASH_DAYS > 0 );\n\n\t\tif ( 'attachment' === $post->post_type ) {\n\t\t\t$supports_trash = $supports_trash && MEDIA_TRASH;\n\t\t}\n\n\t\t/**\n\t\t * Filters whether a post is trashable.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * Pass false to disable trash support for the post.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param bool    $supports_trash Whether the post type support trashing.\n\t\t * @param WP_Post $post           The Post object being considered for trashing support.\n\t\t */\n\t\t$supports_trash = apply_filters( \"rest_{$this->post_type}_trashable\", $supports_trash, $post );\n\n\t\tif ( ! $this->check_delete_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_delete_post', __( 'Sorry, you are not allowed to delete this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\n\t\t// If we're forcing, then delete permanently.\n\t\tif ( $force ) {\n\t\t\t$previous = $this->prepare_item_for_response( $post, $request );\n\t\t\t$result = wp_delete_post( $id, true );\n\t\t\t$response = new WP_REST_Response();\n\t\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\t} else {\n\t\t\t// If we don't support trashing for this type, error out.\n\t\t\tif ( ! $supports_trash ) {\n\t\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'The post does not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t\t}\n\n\t\t\t// Otherwise, only trash if we haven't already.\n\t\t\tif ( 'trash' === $post->post_status ) {\n\t\t\t\treturn new WP_Error( 'rest_already_trashed', __( 'The post has already been deleted.' ), array( 'status' => 410 ) );\n\t\t\t}\n\n\t\t\t// (Note that internally this falls through to `wp_delete_post` if\n\t\t\t// the trash is disabled.)\n\t\t\t$result = wp_trash_post( $id );\n\t\t\t$post = get_post( $id );\n\t\t\t$response = $this->prepare_item_for_response( $post, $request );\n\t\t}\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The post cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t/**\n\t\t * Fires immediately after a single post is deleted or trashed via the REST API.\n\t\t *\n\t\t * They dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object           $post     The deleted or trashed post.\n\t\t * @param WP_REST_Response $response The response data.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( \"rest_delete_{$this->post_type}\", $post, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Determines the allowed query_vars for a get_items() response and prepares\n\t * them for WP_Query.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param array           $prepared_args Optional. Prepared WP_Query arguments. Default empty array.\n\t * @param WP_REST_Request $request       Optional. Full details about the request.\n\t * @return array Items query arguments.\n\t */\n\tprotected function prepare_items_query( $prepared_args = array(), $request = null ) {\n\t\t$query_args = array();\n\n\t\tforeach ( $prepared_args as $key => $value ) {\n\t\t\t/**\n\t\t\t * Filters the query_vars used in get_items() for the constructed query.\n\t\t\t *\n\t\t\t * The dynamic portion of the hook name, `$key`, refers to the query_var key.\n\t\t\t *\n\t\t\t * @since 4.7.0\n\t\t\t *\n\t\t\t * @param string $value The query_var value.\n\t\t\t */\n\t\t\t$query_args[ $key ] = apply_filters( \"rest_query_var-{$key}\", $value );\n\t\t}\n\n\t\tif ( 'post' !== $this->post_type || ! isset( $query_args['ignore_sticky_posts'] ) ) {\n\t\t\t$query_args['ignore_sticky_posts'] = true;\n\t\t}\n\n\t\t// Map to proper WP_Query orderby param.\n\t\tif ( isset( $query_args['orderby'] ) && isset( $request['orderby'] ) ) {\n\t\t\t$orderby_mappings = array(\n\t\t\t\t'id'      => 'ID',\n\t\t\t\t'include' => 'post__in',\n\t\t\t\t'slug'    => 'post_name',\n\t\t\t);\n\n\t\t\tif ( isset( $orderby_mappings[ $request['orderby'] ] ) ) {\n\t\t\t\t$query_args['orderby'] = $orderby_mappings[ $request['orderby'] ];\n\t\t\t}\n\t\t}\n\n\t\treturn $query_args;\n\t}\n\n\t/**\n\t * Checks the post_date_gmt or modified_gmt and prepare any post or\n\t * modified date for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string      $date_gmt GMT publication time.\n\t * @param string|null $date     Optional. Local publication time. Default null.\n\t * @return string|null ISO8601/RFC3339 formatted datetime.\n\t */\n\tprotected function prepare_date_response( $date_gmt, $date = null ) {\n\t\t// Use the date if passed.\n\t\tif ( isset( $date ) ) {\n\t\t\treturn mysql_to_rfc3339( $date );\n\t\t}\n\n\t\t// Return null if $date_gmt is empty/zeros.\n\t\tif ( '0000-00-00 00:00:00' === $date_gmt ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Return the formatted datetime.\n\t\treturn mysql_to_rfc3339( $date_gmt );\n\t}\n\n\t/**\n\t * Prepares a single post for create or update.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return stdClass|WP_Error Post object or WP_Error.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_post = new stdClass;\n\n\t\t// Post ID.\n\t\tif ( isset( $request['id'] ) ) {\n\t\t\t$prepared_post->ID = absint( $request['id'] );\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// Post title.\n\t\tif ( ! empty( $schema['properties']['title'] ) && isset( $request['title'] ) ) {\n\t\t\tif ( is_string( $request['title'] ) ) {\n\t\t\t\t$prepared_post->post_title = $request['title'];\n\t\t\t} elseif ( ! empty( $request['title']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_title = $request['title']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post content.\n\t\tif ( ! empty( $schema['properties']['content'] ) && isset( $request['content'] ) ) {\n\t\t\tif ( is_string( $request['content'] ) ) {\n\t\t\t\t$prepared_post->post_content = $request['content'];\n\t\t\t} elseif ( isset( $request['content']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_content = $request['content']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post excerpt.\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) && isset( $request['excerpt'] ) ) {\n\t\t\tif ( is_string( $request['excerpt'] ) ) {\n\t\t\t\t$prepared_post->post_excerpt = $request['excerpt'];\n\t\t\t} elseif ( isset( $request['excerpt']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_excerpt = $request['excerpt']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post type.\n\t\tif ( empty( $request['id'] ) ) {\n\t\t\t// Creating new post, use default type for the controller.\n\t\t\t$prepared_post->post_type = $this->post_type;\n\t\t} else {\n\t\t\t// Updating a post, use previous type.\n\t\t\t$prepared_post->post_type = get_post_type( $request['id'] );\n\t\t}\n\n\t\t$post_type = get_post_type_object( $prepared_post->post_type );\n\n\t\t// Post status.\n\t\tif ( ! empty( $schema['properties']['status'] ) && isset( $request['status'] ) ) {\n\t\t\t$status = $this->handle_status_param( $request['status'], $post_type );\n\n\t\t\tif ( is_wp_error( $status ) ) {\n\t\t\t\treturn $status;\n\t\t\t}\n\n\t\t\t$prepared_post->post_status = $status;\n\t\t}\n\n\t\t// Post date.\n\t\tif ( ! empty( $schema['properties']['date'] ) && ! empty( $request['date'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date'] );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_post->post_date, $prepared_post->post_date_gmt ) = $date_data;\n\t\t\t}\n\t\t} elseif ( ! empty( $schema['properties']['date_gmt'] ) && ! empty( $request['date_gmt'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date_gmt'], true );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_post->post_date, $prepared_post->post_date_gmt ) = $date_data;\n\t\t\t}\n\t\t}\n\n\t\t// Post slug.\n\t\tif ( ! empty( $schema['properties']['slug'] ) && isset( $request['slug'] ) ) {\n\t\t\t$prepared_post->post_name = $request['slug'];\n\t\t}\n\n\t\t// Author.\n\t\tif ( ! empty( $schema['properties']['author'] ) && ! empty( $request['author'] ) ) {\n\t\t\t$post_author = (int) $request['author'];\n\n\t\t\tif ( get_current_user_id() !== $post_author ) {\n\t\t\t\t$user_obj = get_userdata( $post_author );\n\n\t\t\t\tif ( ! $user_obj ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_author', __( 'Invalid author ID.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$prepared_post->post_author = $post_author;\n\t\t}\n\n\t\t// Post password.\n\t\tif ( ! empty( $schema['properties']['password'] ) && isset( $request['password'] ) ) {\n\t\t\t$prepared_post->post_password = $request['password'];\n\n\t\t\tif ( '' !== $request['password'] ) {\n\t\t\t\tif ( ! empty( $schema['properties']['sticky'] ) && ! empty( $request['sticky'] ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A post can not be sticky and have a password.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\n\t\t\t\tif ( ! empty( $prepared_post->ID ) && is_sticky( $prepared_post->ID ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A sticky post can not be password protected.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) && ! empty( $request['sticky'] ) ) {\n\t\t\tif ( ! empty( $prepared_post->ID ) && post_password_required( $prepared_post->ID ) ) {\n\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A password protected post can not be set to sticky.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Parent.\n\t\tif ( ! empty( $schema['properties']['parent'] ) && isset( $request['parent'] ) ) {\n\t\t\tif ( 0 === (int) $request['parent'] ) {\n\t\t\t\t$prepared_post->post_parent = 0;\n\t\t\t} else {\n\t\t\t\t$parent = get_post( (int) $request['parent'] );\n\t\t\t\tif ( empty( $parent ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post parent ID.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t\t$prepared_post->post_parent = (int) $parent->ID;\n\t\t\t}\n\t\t}\n\n\t\t// Menu order.\n\t\tif ( ! empty( $schema['properties']['menu_order'] ) && isset( $request['menu_order'] ) ) {\n\t\t\t$prepared_post->menu_order = (int) $request['menu_order'];\n\t\t}\n\n\t\t// Comment status.\n\t\tif ( ! empty( $schema['properties']['comment_status'] ) && ! empty( $request['comment_status'] ) ) {\n\t\t\t$prepared_post->comment_status = $request['comment_status'];\n\t\t}\n\n\t\t// Ping status.\n\t\tif ( ! empty( $schema['properties']['ping_status'] ) && ! empty( $request['ping_status'] ) ) {\n\t\t\t$prepared_post->ping_status = $request['ping_status'];\n\t\t}\n\n\t\t/**\n\t\t * Filters a post before it is inserted via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param stdClass        $prepared_post An object representing a single post prepared\n\t\t *                                       for inserting or updating the database.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_pre_insert_{$this->post_type}\", $prepared_post, $request );\n\n\t}\n\n\t/**\n\t * Determines validity and normalizes the given status parameter.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $post_status Post status.\n\t * @param object $post_type   Post type.\n\t * @return string|WP_Error Post status or WP_Error if lacking the proper permission.\n\t */\n\tprotected function handle_status_param( $post_status, $post_type ) {\n\n\t\tswitch ( $post_status ) {\n\t\t\tcase 'draft':\n\t\t\tcase 'pending':\n\t\t\t\tbreak;\n\t\t\tcase 'private':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_publish', __( 'Sorry, you are not allowed to create private posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'publish':\n\t\t\tcase 'future':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_publish', __( 'Sorry, you are not allowed to publish posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! get_post_status_object( $post_status ) ) {\n\t\t\t\t\t$post_status = 'draft';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $post_status;\n\t}\n\n\t/**\n\t * Determines the featured media based on a request param.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param int $featured_media Featured Media ID.\n\t * @param int $post_id        Post ID.\n\t * @return bool|WP_Error Whether the post thumbnail was successfully deleted, otherwise WP_Error.\n\t */\n\tprotected function handle_featured_media( $featured_media, $post_id ) {\n\n\t\t$featured_media = (int) $featured_media;\n\t\tif ( $featured_media ) {\n\t\t\t$result = set_post_thumbnail( $post_id, $featured_media );\n\t\t\tif ( $result ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_invalid_featured_media', __( 'Invalid featured media ID.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t} else {\n\t\t\treturn delete_post_thumbnail( $post_id );\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the template for a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string  $template Page template filename.\n\t * @param integer $post_id  Post ID.\n\t */\n\tpublic function handle_template( $template, $post_id ) {\n\t\tif ( in_array( $template, array_keys( wp_get_theme()->get_page_templates( get_post( $post_id ) ) ), true ) ) {\n\t\t\tupdate_post_meta( $post_id, '_wp_page_template', $template );\n\t\t} else {\n\t\t\tupdate_post_meta( $post_id, '_wp_page_template', '' );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the post's terms from a REST request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param int             $post_id The post ID to update the terms form.\n\t * @param WP_REST_Request $request The request object with post and terms data.\n\t * @return null|WP_Error WP_Error on an error assigning any of the terms, otherwise null.\n\t */\n\tprotected function handle_terms( $post_id, $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! isset( $request[ $base ] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$result = wp_set_object_terms( $post_id, $request[ $base ], $taxonomy->name );\n\n\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\treturn $result;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether current user can assign all terms sent with the current request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request The request object with post and terms data.\n\t * @return bool Whether the current user can assign the provided terms.\n\t */\n\tprotected function check_assign_terms_permission( $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! isset( $request[ $base ] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tforeach ( $request[ $base ] as $term_id ) {\n\t\t\t\t// Invalid terms will be rejected later.\n\t\t\t\tif ( ! get_term( $term_id, $taxonomy->name ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( ! current_user_can( 'assign_term', (int) $term_id ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if a given post type can be viewed or managed.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object|string $post_type Post type name or object.\n\t * @return bool Whether the post type is allowed in REST.\n\t */\n\tprotected function check_is_post_type_allowed( $post_type ) {\n\t\tif ( ! is_object( $post_type ) ) {\n\t\t\t$post_type = get_post_type_object( $post_type );\n\t\t}\n\n\t\tif ( ! empty( $post_type ) && ! empty( $post_type->show_in_rest ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if a post can be read.\n\t *\n\t * Correctly handles posts with the inherit status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be read.\n\t */\n\tpublic function check_read_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Is the post readable?\n\t\tif ( 'publish' === $post->post_status || current_user_can( $post_type->cap->read_post, $post->ID ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$post_status_obj = get_post_status_object( $post->post_status );\n\t\tif ( $post_status_obj && $post_status_obj->public ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Can we read the parent if we're inheriting?\n\t\tif ( 'inherit' === $post->post_status && $post->post_parent > 0 ) {\n\t\t\t$parent = get_post( $post->post_parent );\n\t\t\treturn $this->check_read_permission( $parent );\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a parent, but the status is set to inherit, assume\n\t\t * it's published (as per get_post_status()).\n\t\t */\n\t\tif ( 'inherit' === $post->post_status ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if a post can be edited.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be edited.\n\t */\n\tprotected function check_update_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->edit_post, $post->ID );\n\t}\n\n\t/**\n\t * Checks if a post can be created.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be created.\n\t */\n\tprotected function check_create_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->create_posts );\n\t}\n\n\t/**\n\t * Checks if a post can be deleted.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be deleted.\n\t */\n\tprotected function check_delete_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->delete_post, $post->ID );\n\t}\n\n\t/**\n\t * Prepares a single post output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post, $request ) {\n\t\t$GLOBALS['post'] = $post;\n\n\t\tsetup_postdata( $post );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// Base fields for every post.\n\t\t$data = array();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $post->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date'] ) ) {\n\t\t\t$data['date'] = $this->prepare_date_response( $post->post_date_gmt, $post->post_date );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date_gmt'] ) ) {\n\t\t\t$data['date_gmt'] = $this->prepare_date_response( $post->post_date_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['guid'] ) ) {\n\t\t\t$data['guid'] = array(\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'get_the_guid', $post->guid ),\n\t\t\t\t'raw'      => $post->guid,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified'] ) ) {\n\t\t\t$data['modified'] = $this->prepare_date_response( $post->post_modified_gmt, $post->post_modified );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified_gmt'] ) ) {\n\t\t\t$data['modified_gmt'] = $this->prepare_date_response( $post->post_modified_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['password'] ) ) {\n\t\t\t$data['password'] = $post->post_password;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $post->post_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['status'] ) ) {\n\t\t\t$data['status'] = $post->post_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['type'] ) ) {\n\t\t\t$data['type'] = $post->post_type;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_permalink( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['title'] ) ) {\n\t\t\tadd_filter( 'protected_title_format', array( $this, 'protected_title_format' ) );\n\n\t\t\t$data['title'] = array(\n\t\t\t\t'raw'      => $post->post_title,\n\t\t\t\t'rendered' => get_the_title( $post->ID ),\n\t\t\t);\n\n\t\t\tremove_filter( 'protected_title_format', array( $this, 'protected_title_format' ) );\n\t\t}\n\n\t\t$has_password_filter = false;\n\n\t\tif ( $this->can_access_password_content( $post, $request ) ) {\n\t\t\t// Allow access to the post, permissions already checked before.\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\n\t\t\t$has_password_filter = true;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['content'] ) ) {\n\t\t\t$data['content'] = array(\n\t\t\t\t'raw'       => $post->post_content,\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered'  => post_password_required( $post ) ? '' : apply_filters( 'the_content', $post->post_content ),\n\t\t\t\t'protected' => (bool) $post->post_password,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) ) {\n\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t$excerpt = apply_filters( 'the_excerpt', apply_filters( 'get_the_excerpt', $post->post_excerpt, $post ) );\n\t\t\t$data['excerpt'] = array(\n\t\t\t\t'raw'       => $post->post_excerpt,\n\t\t\t\t'rendered'  => post_password_required( $post ) ? '' : $excerpt,\n\t\t\t\t'protected' => (bool) $post->post_password,\n\t\t\t);\n\t\t}\n\n\t\tif ( $has_password_filter ) {\n\t\t\t// Reset filter.\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['author'] ) ) {\n\t\t\t$data['author'] = (int) $post->post_author;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) ) {\n\t\t\t$data['featured_media'] = (int) get_post_thumbnail_id( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $post->post_parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['menu_order'] ) ) {\n\t\t\t$data['menu_order'] = (int) $post->menu_order;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['comment_status'] ) ) {\n\t\t\t$data['comment_status'] = $post->comment_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['ping_status'] ) ) {\n\t\t\t$data['ping_status'] = $post->ping_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) ) {\n\t\t\t$data['sticky'] = is_sticky( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) ) {\n\t\t\tif ( $template = get_page_template_slug( $post->ID ) ) {\n\t\t\t\t$data['template'] = $template;\n\t\t\t} else {\n\t\t\t\t$data['template'] = '';\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['format'] ) ) {\n\t\t\t$data['format'] = get_post_format( $post->ID );\n\n\t\t\t// Fill in blank post format.\n\t\t\tif ( empty( $data['format'] ) ) {\n\t\t\t\t$data['format'] = 'standard';\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $post->ID, $request );\n\t\t}\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! empty( $schema['properties'][ $base ] ) ) {\n\t\t\t\t$terms = get_the_terms( $post, $taxonomy->name );\n\t\t\t\t$data[ $base ] = $terms ? array_values( wp_list_pluck( $terms, 'term_id' ) ) : array();\n\t\t\t}\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $post ) );\n\n\t\t/**\n\t\t * Filters the post data for a response.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param WP_Post          $post     Post object.\n\t\t * @param WP_REST_Request  $request  Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_prepare_{$this->post_type}\", $response, $post, $request );\n\t}\n\n\t/**\n\t * Overwrites the default protected title format.\n\t *\n\t * By default, WordPress will show password protected posts with a title of\n\t * \"Protected: %s\", as the REST API communicates the protected status of a post\n\t * in a machine readable format, we remove the \"Protected: \" prefix.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return string Protected title format.\n\t */\n\tpublic function protected_title_format() {\n\t\treturn '%s';\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post $post Post object.\n\t * @return array Links for the given post.\n\t */\n\tprotected function prepare_links( $post ) {\n\t\t$base = sprintf( '%s/%s', $this->namespace, $this->rest_base );\n\n\t\t// Entity meta.\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href'   => rest_url( trailingslashit( $base ) . $post->ID ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href'   => rest_url( $base ),\n\t\t\t),\n\t\t\t'about'      => array(\n\t\t\t\t'href'   => rest_url( 'wp/v2/types/' . $this->post_type ),\n\t\t\t),\n\t\t);\n\n\t\tif ( ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'author' ) )\n\t\t\t&& ! empty( $post->post_author ) ) {\n\t\t\t$links['author'] = array(\n\t\t\t\t'href'       => rest_url( 'wp/v2/users/' . $post->post_author ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'comments' ) ) {\n\t\t\t$replies_url = rest_url( 'wp/v2/comments' );\n\t\t\t$replies_url = add_query_arg( 'post', $post->ID, $replies_url );\n\n\t\t\t$links['replies'] = array(\n\t\t\t\t'href'       => $replies_url,\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'revisions' ) ) {\n\t\t\t$links['version-history'] = array(\n\t\t\t\t'href' => rest_url( trailingslashit( $base ) . $post->ID . '/revisions' ),\n\t\t\t);\n\t\t}\n\n\t\t$post_type_obj = get_post_type_object( $post->post_type );\n\n\t\tif ( $post_type_obj->hierarchical && ! empty( $post->post_parent ) ) {\n\t\t\t$links['up'] = array(\n\t\t\t\t'href'       => rest_url( trailingslashit( $base ) . (int) $post->post_parent ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\t// If we have a featured media, add that.\n\t\tif ( $featured_media = get_post_thumbnail_id( $post->ID ) ) {\n\t\t\t$image_url = rest_url( 'wp/v2/media/' . $featured_media );\n\n\t\t\t$links['https://api.w.org/featuredmedia'] = array(\n\t\t\t\t'href'       => $image_url,\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! in_array( $post->post_type, array( 'attachment', 'nav_menu_item', 'revision' ), true ) ) {\n\t\t\t$attachments_url = rest_url( 'wp/v2/media' );\n\t\t\t$attachments_url = add_query_arg( 'parent', $post->ID, $attachments_url );\n\n\t\t\t$links['https://api.w.org/attachment'] = array(\n\t\t\t\t'href' => $attachments_url,\n\t\t\t);\n\t\t}\n\n\t\t$taxonomies = get_object_taxonomies( $post->post_type );\n\n\t\tif ( ! empty( $taxonomies ) ) {\n\t\t\t$links['https://api.w.org/term'] = array();\n\n\t\t\tforeach ( $taxonomies as $tax ) {\n\t\t\t\t$taxonomy_obj = get_taxonomy( $tax );\n\n\t\t\t\t// Skip taxonomies that are not public.\n\t\t\t\tif ( empty( $taxonomy_obj->show_in_rest ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$tax_base = ! empty( $taxonomy_obj->rest_base ) ? $taxonomy_obj->rest_base : $tax;\n\n\t\t\t\t$terms_url = add_query_arg(\n\t\t\t\t\t'post',\n\t\t\t\t\t$post->ID,\n\t\t\t\t\trest_url( 'wp/v2/' . $tax_base )\n\t\t\t\t);\n\n\t\t\t\t$links['https://api.w.org/term'][] = array(\n\t\t\t\t\t'href'       => $terms_url,\n\t\t\t\t\t'taxonomy'   => $tax,\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Retrieves the post's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => $this->post_type,\n\t\t\t'type'       => 'object',\n\t\t\t// Base properties for every Post.\n\t\t\t'properties' => array(\n\t\t\t\t'date'            => array(\n\t\t\t\t\t'description' => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'        => array(\n\t\t\t\t\t'description' => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'guid'            => array(\n\t\t\t\t\t'description' => __( 'The globally unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t'raw'      => array(\n\t\t\t\t\t\t\t'description' => __( 'GUID for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t'description' => __( 'GUID for the object, transformed for display.' ),\n\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'id'              => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'link'            => array(\n\t\t\t\t\t'description' => __( 'URL to the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'modified'        => array(\n\t\t\t\t\t'description' => __( \"The date the object was last modified, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'modified_gmt'    => array(\n\t\t\t\t\t'description' => __( 'The date the object was last modified, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'slug'            => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the object unique to its type.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'status'          => array(\n\t\t\t\t\t'description' => __( 'A named status for the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'enum'        => array_keys( get_post_stati( array( 'internal' => false ) ) ),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'type'            => array(\n\t\t\t\t\t'description' => __( 'Type of Post for the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'password'        => array(\n\t\t\t\t\t'description' => __( 'A password to protect access to the content and excerpt.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$post_type_obj = get_post_type_object( $this->post_type );\n\n\t\tif ( $post_type_obj->hierarchical ) {\n\t\t\t$schema['properties']['parent'] = array(\n\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t'type'        => 'integer',\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$post_type_attributes = array(\n\t\t\t'title',\n\t\t\t'editor',\n\t\t\t'author',\n\t\t\t'excerpt',\n\t\t\t'thumbnail',\n\t\t\t'comments',\n\t\t\t'revisions',\n\t\t\t'page-attributes',\n\t\t\t'post-formats',\n\t\t\t'custom-fields',\n\t\t);\n\t\t$fixed_schemas = array(\n\t\t\t'post' => array(\n\t\t\t\t'title',\n\t\t\t\t'editor',\n\t\t\t\t'author',\n\t\t\t\t'excerpt',\n\t\t\t\t'thumbnail',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'post-formats',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t\t'page' => array(\n\t\t\t\t'title',\n\t\t\t\t'editor',\n\t\t\t\t'author',\n\t\t\t\t'excerpt',\n\t\t\t\t'thumbnail',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'page-attributes',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t\t'attachment' => array(\n\t\t\t\t'title',\n\t\t\t\t'author',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t);\n\t\tforeach ( $post_type_attributes as $attribute ) {\n\t\t\tif ( isset( $fixed_schemas[ $this->post_type ] ) && ! in_array( $attribute, $fixed_schemas[ $this->post_type ], true ) ) {\n\t\t\t\tcontinue;\n\t\t\t} elseif ( ! isset( $fixed_schemas[ $this->post_type ] ) && ! post_type_supports( $this->post_type, $attribute ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch ( $attribute ) {\n\n\t\t\t\tcase 'title':\n\t\t\t\t\t$schema['properties']['title'] = array(\n\t\t\t\t\t\t'description' => __( 'The title for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Title for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML title for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'editor':\n\t\t\t\t\t$schema['properties']['content'] = array(\n\t\t\t\t\t\t'description' => __( 'The content for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Content for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML content for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'protected'       => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Whether the content is protected with a password.' ),\n\t\t\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'author':\n\t\t\t\t\t$schema['properties']['author'] = array(\n\t\t\t\t\t\t'description' => __( 'The ID for the author of the object.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'excerpt':\n\t\t\t\t\t$schema['properties']['excerpt'] = array(\n\t\t\t\t\t\t'description' => __( 'The excerpt for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Excerpt for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML excerpt for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'protected'       => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Whether the excerpt is protected with a password.' ),\n\t\t\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'thumbnail':\n\t\t\t\t\t$schema['properties']['featured_media'] = array(\n\t\t\t\t\t\t'description' => __( 'The ID of the featured media for the object.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comments':\n\t\t\t\t\t$schema['properties']['comment_status'] = array(\n\t\t\t\t\t\t'description' => __( 'Whether or not comments are open on the object.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => array( 'open', 'closed' ),\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\t$schema['properties']['ping_status'] = array(\n\t\t\t\t\t\t'description' => __( 'Whether or not the object can be pinged.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => array( 'open', 'closed' ),\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'page-attributes':\n\t\t\t\t\t$schema['properties']['menu_order'] = array(\n\t\t\t\t\t\t'description' => __( 'The order of the object in relation to other object of its type.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post-formats':\n\t\t\t\t\t$supports_formats = get_theme_support( 'post-formats' );\n\n\t\t\t\t\t// Force to an array. Supports formats can return true even if empty in some cases.\n\t\t\t\t\t$supports_formats = is_array( $supports_formats ) ? array_values( $supports_formats[0] ) : array();\n\n\t\t\t\t\t$supported_formats = array_merge( array( 'standard' ), $supports_formats );\n\n\t\t\t\t\t$schema['properties']['format'] = array(\n\t\t\t\t\t\t'description' => __( 'The format for the object.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => $supported_formats,\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'custom-fields':\n\t\t\t\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tif ( 'post' === $this->post_type ) {\n\t\t\t$schema['properties']['sticky'] = array(\n\t\t\t\t'description' => __( 'Whether or not the object should be treated as sticky.' ),\n\t\t\t\t'type'        => 'boolean',\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['template'] = array(\n\t\t\t'description' => __( 'The theme file to use to display the object.' ),\n\t\t\t'type'        => 'string',\n\t\t\t'enum'        => array_merge( array_keys( wp_get_theme()->get_page_templates( null, $this->post_type ) ), array( '' ) ),\n\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t);\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t\t$schema['properties'][ $base ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description' => sprintf( __( 'The terms assigned to the object in the %s taxonomy.' ), $taxonomy->name ),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'items'       => array(\n\t\t\t\t\t'type'    => 'integer',\n\t\t\t\t),\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for the posts collection.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['after'] = array(\n\t\t\t'description'        => __( 'Limit response to posts published after a given ISO8601 compliant date.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'format'             => 'date-time',\n\t\t);\n\n\t\tif ( post_type_supports( $this->post_type, 'author' ) ) {\n\t\t\t$query_params['author'] = array(\n\t\t\t\t'description'         => __( 'Limit result set to posts assigned to specific authors.' ),\n\t\t\t\t'type'                => 'array',\n\t\t\t\t'items'               => array(\n\t\t\t\t\t'type'            => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'             => array(),\n\t\t\t);\n\t\t\t$query_params['author_exclude'] = array(\n\t\t\t\t'description'         => __( 'Ensure result set excludes posts assigned to specific authors.' ),\n\t\t\t\t'type'                => 'array',\n\t\t\t\t'items'               => array(\n\t\t\t\t\t'type'            => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'             => array(),\n\t\t\t);\n\t\t}\n\n\t\t$query_params['before'] = array(\n\t\t\t'description'        => __( 'Limit response to posts published before a given ISO8601 compliant date.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'format'             => 'date-time',\n\t\t);\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\tif ( 'page' === $this->post_type || post_type_supports( $this->post_type, 'page-attributes' ) ) {\n\t\t\t$query_params['menu_order'] = array(\n\t\t\t\t'description'        => __( 'Limit result set to posts with a specific menu_order value.' ),\n\t\t\t\t'type'               => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order'] = array(\n\t\t\t'description'        => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'default'            => 'desc',\n\t\t\t'enum'               => array( 'asc', 'desc' ),\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'description'        => __( 'Sort collection by object attribute.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'default'            => 'date',\n\t\t\t'enum'               => array(\n\t\t\t\t'date',\n\t\t\t\t'relevance',\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'title',\n\t\t\t\t'slug',\n\t\t\t),\n\t\t);\n\n\t\tif ( 'page' === $this->post_type || post_type_supports( $this->post_type, 'page-attributes' ) ) {\n\t\t\t$query_params['orderby']['enum'][] = 'menu_order';\n\t\t}\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( $post_type->hierarchical || 'attachment' === $this->post_type ) {\n\t\t\t$query_params['parent'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to those of particular parent IDs.' ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t\t$query_params['parent_exclude'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to all items except those of a particular parent ID.' ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t}\n\n\t\t$query_params['slug'] = array(\n\t\t\t'description'       => __( 'Limit result set to posts with one or more specific slugs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'string',\n\t\t\t),\n\t\t\t'sanitize_callback' => 'wp_parse_slug_list',\n\t\t);\n\n\t\t$query_params['status'] = array(\n\t\t\t'default'           => 'publish',\n\t\t\t'description'       => __( 'Limit result set to posts assigned one or more statuses.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'enum'          => array_merge( array_keys( get_post_stati() ), array( 'any' ) ),\n\t\t\t\t'type'          => 'string',\n\t\t\t),\n\t\t\t'sanitize_callback' => array( $this, 'sanitize_post_statuses' ),\n\t\t);\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\t$query_params[ $base ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description'       => sprintf( __( 'Limit result set to all items that have the specified term assigned in the %s taxonomy.' ), $base ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\n\t\t\t$query_params[ $base . '_exclude' ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description' => sprintf( __( 'Limit result set to all items except those that have the specified term assigned in the %s taxonomy.' ), $base ),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'items'       => array(\n\t\t\t\t\t'type'    => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t}\n\n\t\tif ( 'post' === $this->post_type ) {\n\t\t\t$query_params['sticky'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to items that are sticky.' ),\n\t\t\t\t'type'              => 'boolean',\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Filter collection parameters for the posts controller.\n\t\t *\n\t\t * The dynamic part of the filter `$this->post_type` refers to the post\n\t\t * type slug for the controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Query parameter. Use the\n\t\t * `rest_{$this->post_type}_query` filter to set WP_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array        $query_params JSON Schema-formatted collection parameters.\n\t\t * @param WP_Post_Type $post_type    Post type object.\n\t\t */\n\t\treturn apply_filters( \"rest_{$this->post_type}_collection_params\", $query_params, $post_type );\n\t}\n\n\t/**\n\t * Sanitizes and validates the list of post statuses, including whether the\n\t * user can query private statuses.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  string|array    $statuses  One or more post statuses.\n\t * @param  WP_REST_Request $request   Full details about the request.\n\t * @param  string          $parameter Additional parameter to pass to validation.\n\t * @return array|WP_Error A list of valid statuses, otherwise WP_Error object.\n\t */\n\tpublic function sanitize_post_statuses( $statuses, $request, $parameter ) {\n\t\t$statuses = wp_parse_slug_list( $statuses );\n\n\t\t// The default status is different in WP_REST_Attachments_Controller\n\t\t$attributes = $request->get_attributes();\n\t\t$default_status = $attributes['args']['status']['default'];\n\n\t\tforeach ( $statuses as $status ) {\n\t\t\tif ( $status === $default_status ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$post_type_obj = get_post_type_object( $this->post_type );\n\n\t\t\tif ( current_user_can( $post_type_obj->cap->edit_posts ) ) {\n\t\t\t\t$result = rest_validate_request_arg( $status, $request, $parameter );\n\t\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\t\treturn $result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_status', __( 'Status is forbidden.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn $statuses;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Revisions_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to access revisions via the REST API.\n *\n * @since 4.7.0\n *0\n * @see WP_REST_Controller\n */\nclass WP_REST_Revisions_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Parent post type.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var string\n\t */\n\tprivate $parent_post_type;\n\n\t/**\n\t * Parent controller.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var WP_REST_Controller\n\t */\n\tprivate $parent_controller;\n\n\t/**\n\t * The base of the parent controller's route.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var string\n\t */\n\tprivate $parent_base;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $parent_post_type Post type of the parent.\n\t */\n\tpublic function __construct( $parent_post_type ) {\n\t\t$this->parent_post_type = $parent_post_type;\n\t\t$this->parent_controller = new WP_REST_Posts_Controller( $parent_post_type );\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'revisions';\n\t\t$post_type_object = get_post_type_object( $parent_post_type );\n\t\t$this->parent_base = ! empty( $post_type_object->rest_base ) ? $post_type_object->rest_base : $post_type_object->name;\n\t}\n\n\t/**\n\t * Registers routes for revisions based on post types supporting revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->parent_base . '/(?P<parent>[\\d]+)/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->parent_base . '/(?P<parent>[\\d]+)/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as revisions do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t));\n\n\t}\n\n\t/**\n\t * Checks if a given request has access to get revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\n\t\t$parent = get_post( $request['parent'] );\n\t\tif ( ! $parent ) {\n\t\t\treturn true;\n\t\t}\n\t\t$parent_post_type_obj = get_post_type_object( $parent->post_type );\n\t\tif ( ! current_user_can( $parent_post_type_obj->cap->edit_post, $parent->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to view revisions of this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets a collection of revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$parent = get_post( $request['parent'] );\n\t\tif ( ! $request['parent'] || ! $parent || $this->parent_post_type !== $parent->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_parent', __( 'Invalid post parent ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$revisions = wp_get_post_revisions( $request['parent'] );\n\n\t\t$response = array();\n\t\tforeach ( $revisions as $revision ) {\n\t\t\t$data = $this->prepare_item_for_response( $revision, $request );\n\t\t\t$response[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to get a specific revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\treturn $this->get_items_permissions_check( $request );\n\t}\n\n\t/**\n\t * Retrieves one revision from the collection.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$parent = get_post( $request['parent'] );\n\t\tif ( ! $request['parent'] || ! $parent || $this->parent_post_type !== $parent->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_parent', __( 'Invalid post parent ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$revision = get_post( $request['id'] );\n\t\tif ( ! $revision || 'revision' !== $revision->post_type ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid revision ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$response = $this->prepare_item_for_response( $revision, $request );\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\n\t\t$response = $this->get_items_permissions_check( $request );\n\t\tif ( ! $response || is_wp_error( $response ) ) {\n\t\t\treturn $response;\n\t\t}\n\n\t\t$post = get_post( $request['id'] );\n\t\tif ( ! $post ) {\n\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid revision ID.' ), array( 'status' => 404 ) );\n\t\t}\n\t\t$post_type = get_post_type_object( 'revision' );\n\t\treturn current_user_can( $post_type->cap->delete_post, $post->ID );\n\t}\n\n\t/**\n\t * Deletes a single revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for revisions.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Revisions do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$revision = get_post( $request['id'] );\n\t\t$previous = $this->prepare_item_for_response( $revision, $request );\n\n\t\t$result = wp_delete_post( $request['id'], true );\n\n\t\t/**\n\t\t * Fires after a revision is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param (mixed) $result The revision object (if it was deleted or moved to the trash successfully)\n\t\t *                        or false (failure). If the revision was moved to to the trash, $result represents\n\t\t *                        its new state; if it was deleted, $result represents its state before deletion.\n\t\t * @param WP_REST_Request $request The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_revision', $result, $request );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The post cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares the revision for the REST response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post revision object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post, $request ) {\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t$data = array();\n\n\t\tif ( ! empty( $schema['properties']['author'] ) ) {\n\t\t\t$data['author'] = $post->post_author;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date'] ) ) {\n\t\t\t$data['date'] = $this->prepare_date_response( $post->post_date_gmt, $post->post_date );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date_gmt'] ) ) {\n\t\t\t$data['date_gmt'] = $this->prepare_date_response( $post->post_date_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $post->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified'] ) ) {\n\t\t\t$data['modified'] = $this->prepare_date_response( $post->post_modified_gmt, $post->post_modified );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified_gmt'] ) ) {\n\t\t\t$data['modified_gmt'] = $this->prepare_date_response( $post->post_modified_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $post->post_parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $post->post_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['guid'] ) ) {\n\t\t\t$data['guid'] = array(\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'get_the_guid', $post->guid ),\n\t\t\t\t'raw'      => $post->guid,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['title'] ) ) {\n\t\t\t$data['title'] = array(\n\t\t\t\t'raw'      => $post->post_title,\n\t\t\t\t'rendered' => get_the_title( $post->ID ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['content'] ) ) {\n\n\t\t\t$data['content'] = array(\n\t\t\t\t'raw'      => $post->post_content,\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'the_content', $post->post_content ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) ) {\n\t\t\t$data['excerpt'] = array(\n\t\t\t\t'raw'      => $post->post_excerpt,\n\t\t\t\t'rendered' => $this->prepare_excerpt_response( $post->post_excerpt, $post ),\n\t\t\t);\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( ! empty( $data['parent'] ) ) {\n\t\t\t$response->add_link( 'parent', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->parent_base, $data['parent'] ) ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters a revision returned from the API.\n\t\t *\n\t\t * Allows modification of the revision right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param WP_Post          $post     The original revision object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_revision', $response, $post, $request );\n\t}\n\n\t/**\n\t * Checks the post_date_gmt or modified_gmt and prepare any post or\n\t * modified date for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string      $date_gmt GMT publication time.\n\t * @param string|null $date     Optional. Local publication time. Default null.\n\t * @return string|null ISO8601/RFC3339 formatted datetime, otherwise null.\n\t */\n\tprotected function prepare_date_response( $date_gmt, $date = null ) {\n\t\tif ( '0000-00-00 00:00:00' === $date_gmt ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( isset( $date ) ) {\n\t\t\treturn mysql_to_rfc3339( $date );\n\t\t}\n\n\t\treturn mysql_to_rfc3339( $date_gmt );\n\t}\n\n\t/**\n\t * Retrieves the revision's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => \"{$this->parent_post_type}-revision\",\n\t\t\t'type'       => 'object',\n\t\t\t// Base properties for every Revision.\n\t\t\t'properties' => array(\n\t\t\t\t'author'          => array(\n\t\t\t\t\t'description' => __( 'The ID for the author of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date'            => array(\n\t\t\t\t\t'description' => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'        => array(\n\t\t\t\t\t'description' => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'guid'            => array(\n\t\t\t\t\t'description' => __( 'GUID for the object, as it exists in the database.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'id'              => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'modified'        => array(\n\t\t\t\t\t'description' => __( \"The date the object was last modified, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'modified_gmt'    => array(\n\t\t\t\t\t'description' => __( 'The date the object was last modified, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'parent'          => array(\n\t\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t),\n\t\t\t\t'slug'            => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the object unique to its type.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$parent_schema = $this->parent_controller->get_item_schema();\n\n\t\tif ( ! empty( $parent_schema['properties']['title'] ) ) {\n\t\t\t$schema['properties']['title'] = $parent_schema['properties']['title'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['content'] ) ) {\n\t\t\t$schema['properties']['content'] = $parent_schema['properties']['content'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['excerpt'] ) ) {\n\t\t\t$schema['properties']['excerpt'] = $parent_schema['properties']['excerpt'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['guid'] ) ) {\n\t\t\t$schema['properties']['guid'] = $parent_schema['properties']['guid'];\n\t\t}\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n\t/**\n\t * Checks the post excerpt and prepare it for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string  $excerpt The post excerpt.\n\t * @param WP_Post $post    Post revision object.\n\t * @return string Prepared excerpt or empty string.\n\t */\n\tprotected function prepare_excerpt_response( $excerpt, $post ) {\n\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_excerpt', $excerpt, $post );\n\n\t\tif ( empty( $excerpt ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn $excerpt;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Taxonomies_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to manage taxonomies via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Taxonomies_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'taxonomies';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'         => WP_REST_Server::READABLE,\n\t\t\t\t'callback'        => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'            => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<taxonomy>[\\w-]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'         => WP_REST_Server::READABLE,\n\t\t\t\t'callback'        => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'            => array(\n\t\t\t\t\t'context'     => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read taxonomies.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tif ( ! empty( $request['type'] ) ) {\n\t\t\t\t$taxonomies = get_object_taxonomies( $request['type'], 'objects' );\n\t\t\t} else {\n\t\t\t\t$taxonomies = get_taxonomies( '', 'objects' );\n\t\t\t}\n\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\tif ( ! empty( $taxonomy->show_in_rest ) && current_user_can( $taxonomy->cap->manage_terms ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to manage terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all public taxonomies.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\tif ( isset( $registered['type'] ) && ! empty( $request['type'] ) ) {\n\t\t\t$taxonomies = get_object_taxonomies( $request['type'], 'objects' );\n\t\t} else {\n\t\t\t$taxonomies = get_taxonomies( '', 'objects' );\n\t\t}\n\t\t$data = array();\n\t\tforeach ( $taxonomies as $tax_type => $value ) {\n\t\t\tif ( empty( $value->show_in_rest ) || ( 'edit' === $request['context'] && ! current_user_can( $value->cap->manage_terms ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$tax = $this->prepare_item_for_response( $value, $request );\n\t\t\t$tax = $this->prepare_response_for_collection( $tax );\n\t\t\t$data[ $tax_type ] = $tax;\n\t\t}\n\n\t\tif ( empty( $data ) ) {\n\t\t\t// Response should still be returned as a JSON object when it is empty.\n\t\t\t$data = (object) $data;\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Checks if a given request has access to a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access for the item, otherwise false or WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\n\t\t$tax_obj = get_taxonomy( $request['taxonomy'] );\n\n\t\tif ( $tax_obj ) {\n\t\t\tif ( empty( $tax_obj->show_in_rest ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( 'edit' === $request['context'] && ! current_user_can( $tax_obj->cap->manage_terms ) ) {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to manage terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a specific taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$tax_obj = get_taxonomy( $request['taxonomy'] );\n\t\tif ( empty( $tax_obj ) ) {\n\t\t\treturn new WP_Error( 'rest_taxonomy_invalid', __( 'Invalid taxonomy.' ), array( 'status' => 404 ) );\n\t\t}\n\t\t$data = $this->prepare_item_for_response( $tax_obj, $request );\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a taxonomy object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $taxonomy Taxonomy data.\n\t * @param WP_REST_Request $request  Full details about the request.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $taxonomy, $request ) {\n\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t$data = array(\n\t\t\t'name'         => $taxonomy->label,\n\t\t\t'slug'         => $taxonomy->name,\n\t\t\t'capabilities' => $taxonomy->cap,\n\t\t\t'description'  => $taxonomy->description,\n\t\t\t'labels'       => $taxonomy->labels,\n\t\t\t'types'        => $taxonomy->object_type,\n\t\t\t'show_cloud'   => $taxonomy->show_tagcloud,\n\t\t\t'hierarchical' => $taxonomy->hierarchical,\n\t\t\t'rest_base'    => $base,\n\t\t);\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( array(\n\t\t\t'collection'                => array(\n\t\t\t\t'href'                  => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t\t'https://api.w.org/items'   => array(\n\t\t\t\t'href'                  => rest_url( sprintf( 'wp/v2/%s', $base ) ),\n\t\t\t),\n\t\t) );\n\n\t\t/**\n\t\t * Filters a taxonomy returned from the REST API.\n\t\t *\n\t\t * Allows modification of the taxonomy data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $item     The original taxonomy object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_taxonomy', $response, $taxonomy, $request );\n\t}\n\n\t/**\n\t * Retrieves the taxonomy's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'taxonomy',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'capabilities'     => array(\n\t\t\t\t\t'description'  => __( 'All capabilities used by the taxonomy.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description'      => array(\n\t\t\t\t\t'description'  => __( 'A human-readable description of the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'hierarchical'     => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the taxonomy should have children.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'labels'           => array(\n\t\t\t\t\t'description'  => __( 'Human-readable labels for the taxonomy for various contexts.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'show_cloud'       => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the term cloud should be displayed.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'types'            => array(\n\t\t\t\t\t'description'  => __( 'Types associated with the taxonomy.' ),\n\t\t\t\t\t'type'         => 'array',\n\t\t\t\t\t'items'        => array(\n\t\t\t\t\t\t'type' => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'rest_base'            => array(\n\t\t\t\t\t'description'  => __( 'REST base route for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$new_params = array();\n\t\t$new_params['context'] = $this->get_context_param( array( 'default' => 'view' ) );\n\t\t$new_params['type'] = array(\n\t\t\t'description'  => __( 'Limit results to taxonomies associated with a specific post type.' ),\n\t\t\t'type'         => 'string',\n\t\t);\n\t\treturn $new_params;\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Terms_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to managed terms associated with a taxonomy via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Terms_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Taxonomy key.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $taxonomy;\n\n\t/**\n\t * Instance of a term meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Term_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Column to have the terms be sorted by.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $sort_column;\n\n\t/**\n\t * Number of terms that were found.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var int\n\t */\n\tprotected $total_terms;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $taxonomy Taxonomy key.\n\t */\n\tpublic function __construct( $taxonomy ) {\n\t\t$this->taxonomy = $taxonomy;\n\t\t$this->namespace = 'wp/v2';\n\t\t$tax_obj = get_taxonomy( $taxonomy );\n\t\t$this->rest_base = ! empty( $tax_obj->rest_base ) ? $tax_obj->rest_base : $tax_obj->name;\n\n\t\t$this->meta = new WP_REST_Term_Meta_Fields( $taxonomy );\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                 => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as terms do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a request has access to read terms in the specified taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access, otherwise false or WP_Error object.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\t$tax_obj = get_taxonomy( $this->taxonomy );\n\t\tif ( ! $tax_obj || ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $tax_obj->cap->edit_terms ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves terms associated with a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'exclude'    => 'exclude',\n\t\t\t'include'    => 'include',\n\t\t\t'order'      => 'order',\n\t\t\t'orderby'    => 'orderby',\n\t\t\t'post'       => 'post',\n\t\t\t'hide_empty' => 'hide_empty',\n\t\t\t'per_page'   => 'number',\n\t\t\t'search'     => 'search',\n\t\t\t'slug'       => 'slug',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['offset'] ) && ! empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $request['offset'];\n\t\t} else {\n\t\t\t$prepared_args['offset'] = ( $request['page'] - 1 ) * $prepared_args['number'];\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $this->taxonomy );\n\n\t\tif ( $taxonomy_obj->hierarchical && isset( $registered['parent'], $request['parent'] ) ) {\n\t\t\tif ( 0 === $request['parent'] ) {\n\t\t\t\t// Only query top-level terms.\n\t\t\t\t$prepared_args['parent'] = 0;\n\t\t\t} else {\n\t\t\t\tif ( $request['parent'] ) {\n\t\t\t\t\t$prepared_args['parent'] = $request['parent'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the query arguments before passing them to get_terms().\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * Enables adding extra arguments or setting defaults for a terms\n\t\t * collection request.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/functions/get_terms/\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments to be\n\t\t *                                       passed to get_terms().\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( \"rest_{$this->taxonomy}_query\", $prepared_args, $request );\n\n\t\tif ( ! empty( $prepared_args['post'] )  ) {\n\t\t\t$query_result = wp_get_object_terms( $prepared_args['post'], $this->taxonomy, $prepared_args );\n\n\t\t\t// Used when calling wp_count_terms() below.\n\t\t\t$prepared_args['object_ids'] = $prepared_args['post'];\n\t\t} else {\n\t\t\t$query_result = get_terms( $this->taxonomy, $prepared_args );\n\t\t}\n\n\t\t$count_args = $prepared_args;\n\n\t\tunset( $count_args['number'], $count_args['offset'] );\n\n\t\t$total_terms = wp_count_terms( $this->taxonomy, $count_args );\n\n\t\t// wp_count_terms can return a falsy value when the term has no children.\n\t\tif ( ! $total_terms ) {\n\t\t\t$total_terms = 0;\n\t\t}\n\n\t\t$response = array();\n\n\t\tforeach ( $query_result as $term ) {\n\t\t\t$data = $this->prepare_item_for_response( $term, $request );\n\t\t\t$response[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$response = rest_ensure_response( $response );\n\n\t\t// Store pagination values for headers.\n\t\t$per_page = (int) $prepared_args['number'];\n\t\t$page     = ceil( ( ( (int) $prepared_args['offset'] ) / $per_page ) + 1 );\n\n\t\t$response->header( 'X-WP-Total', (int) $total_terms );\n\n\t\t$max_pages = ceil( $total_terms / $per_page );\n\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( $this->namespace . '/' . $this->rest_base ) );\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a request has access to read or edit the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, otherwise false or WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$tax_obj = get_taxonomy( $this->taxonomy );\n\t\tif ( ! $tax_obj || ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'edit_term', (int) $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\tif ( ! $term || $term->taxonomy !== $this->taxonomy ) {\n\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Term does not exist.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a request has access to create a term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to create items, false or WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\n\t\tif ( ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $this->taxonomy );\n\t\tif ( ! current_user_can( $taxonomy_obj->cap->edit_terms ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create', __( 'Sorry, you are not allowed to create new terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single term in a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\tif ( ! is_taxonomy_hierarchical( $this->taxonomy ) ) {\n\t\t\t\treturn new WP_Error( 'rest_taxonomy_not_hierarchical', __( 'Can not set parent term, taxonomy is not hierarchical.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$parent = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( ! $parent ) {\n\t\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Parent term does not exist.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$prepared_term = $this->prepare_item_for_database( $request );\n\n\t\t$term = wp_insert_term( wp_slash( $prepared_term->name ), $this->taxonomy, wp_slash( (array) $prepared_term ) );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\t/*\n\t\t\t * If we're going to inform the client that the term already exists,\n\t\t\t * give them the identifier for future use.\n\t\t\t */\n\t\t\tif ( $term_id = $term->get_error_data( 'term_exists' ) ) {\n\t\t\t\t$existing_term = get_term( $term_id, $this->taxonomy );\n\t\t\t\t$term->add_data( $existing_term->term_id, 'term_exists' );\n\t\t\t}\n\n\t\t\treturn $term;\n\t\t}\n\n\t\t$term = get_term( $term['term_id'], $this->taxonomy );\n\n\t\t/**\n\t\t * Fires after a single term is created or updated via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Term         $term     Inserted or updated term object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a term, false when updating.\n\t\t */\n\t\tdo_action( \"rest_insert_{$this->taxonomy}\", $term, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], (int) $request['id'] );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $term, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( $this->namespace . '/' . $this->rest_base . '/' . $term->term_id ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a request has access to update the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to update the item, false or WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\n\t\tif ( ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\tif ( ! $term ) {\n\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Term does not exist.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( ! current_user_can( 'edit_term', $term->term_id ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_update', __( 'Sorry, you are not allowed to edit this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\tif ( ! is_taxonomy_hierarchical( $this->taxonomy ) ) {\n\t\t\t\treturn new WP_Error( 'rest_taxonomy_not_hierarchical', __( 'Can not set parent term, taxonomy is not hierarchical.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$parent = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( ! $parent ) {\n\t\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Parent term does not exist.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$prepared_term = $this->prepare_item_for_database( $request );\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\t// Only update the term if we haz something to update.\n\t\tif ( ! empty( $prepared_term ) ) {\n\t\t\t$update = wp_update_term( $term->term_id, $term->taxonomy, wp_slash( (array) $prepared_term ) );\n\n\t\t\tif ( is_wp_error( $update ) ) {\n\t\t\t\treturn $update;\n\t\t\t}\n\t\t}\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-terms-controller.php */\n\t\tdo_action( \"rest_insert_{$this->taxonomy}\", $term, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], (int) $request['id'] );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $term, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a request has access to delete the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to delete the item, otherwise false or WP_Error object.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\tif ( ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\tif ( ! $term ) {\n\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Term does not exist.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( ! current_user_can( 'delete_term', $term->term_id ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for terms.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Terms do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$term = get_term( (int) $request['id'], $this->taxonomy );\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$previous = $this->prepare_item_for_response( $term, $request );\n\n\t\t$retval = wp_delete_term( $term->term_id, $term->taxonomy );\n\n\t\tif ( ! $retval ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The term cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\n\t\t/**\n\t\t * Fires after a single term is deleted via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Term          $term     The deleted term.\n\t\t * @param WP_REST_Response $response The response data.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( \"rest_delete_{$this->taxonomy}\", $term, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares a single term for create or update.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return object $prepared_term Term object.\n\t */\n\tpublic function prepare_item_for_database( $request ) {\n\t\t$prepared_term = new stdClass;\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( isset( $request['name'] ) && ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$prepared_term->name = $request['name'];\n\t\t}\n\n\t\tif ( isset( $request['slug'] ) && ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$prepared_term->slug = $request['slug'];\n\t\t}\n\n\t\tif ( isset( $request['taxonomy'] ) && ! empty( $schema['properties']['taxonomy'] ) ) {\n\t\t\t$prepared_term->taxonomy = $request['taxonomy'];\n\t\t}\n\n\t\tif ( isset( $request['description'] ) && ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$prepared_term->description = $request['description'];\n\t\t}\n\n\t\tif ( isset( $request['parent'] ) && ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$parent_term_id = 0;\n\t\t\t$parent_term    = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( $parent_term ) {\n\t\t\t\t$parent_term_id = $parent_term->term_id;\n\t\t\t}\n\n\t\t\t$prepared_term->parent = $parent_term_id;\n\t\t}\n\n\t\t/**\n\t\t * Filters term data before inserting term via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object          $prepared_term Term object.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_pre_insert_{$this->taxonomy}\", $prepared_term, $request );\n\t}\n\n\t/**\n\t * Prepares a single term output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param obj             $item    Term object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response $response Response object.\n\t */\n\tpublic function prepare_item_for_response( $item, $request ) {\n\n\t\t$schema = $this->get_item_schema();\n\t\t$data   = array();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = (int) $item->term_id;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['count'] ) ) {\n\t\t\t$data['count'] = (int) $item->count;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$data['description'] = $item->description;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_term_link( $item );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$data['name'] = $item->name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $item->slug;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['taxonomy'] ) ) {\n\t\t\t$data['taxonomy'] = $item->taxonomy;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $item->parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $item->term_id, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $item ) );\n\n\t\t/**\n\t\t * Filters a term item returned from the API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * Allows modification of the term data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response  $response  The response object.\n\t\t * @param object            $item      The original term object.\n\t\t * @param WP_REST_Request   $request   Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( \"rest_prepare_{$this->taxonomy}\", $response, $item, $request );\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $term Term object.\n\t * @return array Links for the given term.\n\t */\n\tprotected function prepare_links( $term ) {\n\t\t$base = $this->namespace . '/' . $this->rest_base;\n\t\t$links = array(\n\t\t\t'self'       => array(\n\t\t\t\t'href' => rest_url( trailingslashit( $base ) . $term->term_id ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( $base ),\n\t\t\t),\n\t\t\t'about'      => array(\n\t\t\t\t'href' => rest_url( sprintf( 'wp/v2/taxonomies/%s', $this->taxonomy ) ),\n\t\t\t),\n\t\t);\n\n\t\tif ( $term->parent ) {\n\t\t\t$parent_term = get_term( (int) $term->parent, $term->taxonomy );\n\n\t\t\tif ( $parent_term ) {\n\t\t\t\t$links['up'] = array(\n\t\t\t\t\t'href'       => rest_url( trailingslashit( $base ) . $parent_term->term_id ),\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $term->taxonomy );\n\n\t\tif ( empty( $taxonomy_obj->object_type ) ) {\n\t\t\treturn $links;\n\t\t}\n\n\t\t$post_type_links = array();\n\n\t\tforeach ( $taxonomy_obj->object_type as $type ) {\n\t\t\t$post_type_object = get_post_type_object( $type );\n\n\t\t\tif ( empty( $post_type_object->show_in_rest ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$rest_base = ! empty( $post_type_object->rest_base ) ? $post_type_object->rest_base : $post_type_object->name;\n\t\t\t$post_type_links[] = array(\n\t\t\t\t'href' => add_query_arg( $this->rest_base, $term->term_id, rest_url( sprintf( 'wp/v2/%s', $rest_base ) ) ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $post_type_links ) ) {\n\t\t\t$links['https://api.w.org/post_type'] = $post_type_links;\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Retrieves the term's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => 'post_tag' === $this->taxonomy ? 'tag' : $this->taxonomy,\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => array(\n\t\t\t\t'id'          => array(\n\t\t\t\t\t'description'  => __( 'Unique identifier for the term.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'count'       => array(\n\t\t\t\t\t'description'  => __( 'Number of published posts for the term.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description' => array(\n\t\t\t\t\t'description'  => __( 'HTML description of the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'        => array(\n\t\t\t\t\t'description'  => __( 'URL of the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'        => array(\n\t\t\t\t\t'description'  => __( 'HTML title for the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t\t'required'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'        => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the term unique to its type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'taxonomy'    => array(\n\t\t\t\t\t'description'  => __( 'Type attribution for the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'enum'         => array_keys( get_taxonomies() ),\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$taxonomy = get_taxonomy( $this->taxonomy );\n\n\t\tif ( $taxonomy->hierarchical ) {\n\t\t\t$schema['properties']['parent'] = array(\n\t\t\t\t'description'  => __( 'The parent term ID.' ),\n\t\t\t\t'type'         => 'integer',\n\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\t\t$taxonomy = get_taxonomy( $this->taxonomy );\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'       => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t\t'default'           => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'       => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t\t'default'           => array(),\n\t\t);\n\n\t\tif ( ! $taxonomy->hierarchical ) {\n\t\t\t$query_params['offset'] = array(\n\t\t\t\t'description'       => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t\t'type'              => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['order'] = array(\n\t\t\t'description'       => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'default'           => 'asc',\n\t\t\t'enum'              => array(\n\t\t\t\t'asc',\n\t\t\t\t'desc',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'description'       => __( 'Sort collection by term attribute.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'default'           => 'name',\n\t\t\t'enum'              => array(\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'name',\n\t\t\t\t'slug',\n\t\t\t\t'term_group',\n\t\t\t\t'description',\n\t\t\t\t'count',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['hide_empty'] = array(\n\t\t\t'description'       => __( 'Whether to hide terms not assigned to any posts.' ),\n\t\t\t'type'              => 'boolean',\n\t\t\t'default'           => false,\n\t\t);\n\n\t\tif ( $taxonomy->hierarchical ) {\n\t\t\t$query_params['parent'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to terms assigned to a specific parent.' ),\n\t\t\t\t'type'              => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['post'] = array(\n\t\t\t'description'       => __( 'Limit result set to terms assigned to a specific post.' ),\n\t\t\t'type'              => 'integer',\n\t\t\t'default'           => null,\n\t\t);\n\n\t\t$query_params['slug'] = array(\n\t\t\t'description'       => __( 'Limit result set to terms with a specific slug.' ),\n\t\t\t'type'              => 'string',\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the terms controller.\n\t\t *\n\t\t * The dynamic part of the filter `$this->taxonomy` refers to the taxonomy\n\t\t * slug for the controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Term_Query parameter.  Use the\n\t\t * `rest_{$this->taxonomy}_query` filter to set WP_Term_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array       $query_params JSON Schema-formatted collection parameters.\n\t\t * @param WP_Taxonomy $taxonomy     Taxonomy object.\n\t\t */\n\t\treturn apply_filters( \"rest_{$this->taxonomy}_collection_params\", $query_params, $taxonomy );\n\t}\n\n\t/**\n\t * Checks that the taxonomy is valid.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $taxonomy Taxonomy to check.\n\t * @return bool Whether the taxonomy is allowed for REST management.\n\t */\n\tprotected function check_is_taxonomy_allowed( $taxonomy ) {\n\t\t$taxonomy_obj = get_taxonomy( $taxonomy );\n\t\tif ( $taxonomy_obj && ! empty( $taxonomy_obj->show_in_rest ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Users_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to manage users via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Users_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Instance of a user meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_User_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'users';\n\n\t\t$this->meta = new WP_REST_User_Meta_Fields();\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as users do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'reassign' => array(\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'description' => __( 'Reassign the deleted user\\'s posts and links to this user ID.' ),\n\t\t\t\t\t\t'required'    => true,\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_reassign' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/me', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_current_item' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_current_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_current_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_current_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_current_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as users do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'reassign' => array(\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'description' => __( 'Reassign the deleted user\\'s posts and links to this user ID.' ),\n\t\t\t\t\t\t'required'    => true,\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_reassign' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t));\n\t}\n\n\t/**\n\t * Checks for a valid value for the reassign parameter when deleting users.\n\t *\n\t * The value can be an integer, 'false', false, or ''.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param int|bool        $value   The value passed to the reassign parameter.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @param string          $param   The parameter that is being sanitized.\n\t *\n\t * @return int|bool|WP_Error\n\t */\n\tpublic function check_reassign( $value, $request, $param ) {\n\t\tif ( is_numeric( $value ) ) {\n\t\t\treturn $value;\n\t\t}\n\n\t\tif ( empty( $value ) || false === $value || 'false' === $value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn new WP_Error( 'rest_invalid_param', __( 'Invalid user parameter(s).' ), array( 'status' => 400 ) );\n\t}\n\n\t/**\n\t * Permissions check for getting all users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\t// Check if roles is specified in GET request and if user can list users.\n\t\tif ( ! empty( $request['roles'] ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'exclude'  => 'exclude',\n\t\t\t'include'  => 'include',\n\t\t\t'order'    => 'order',\n\t\t\t'per_page' => 'number',\n\t\t\t'search'   => 'search',\n\t\t\t'roles'    => 'role__in',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['offset'] ) && ! empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $request['offset'];\n\t\t} else {\n\t\t\t$prepared_args['offset']  = ( $request['page'] - 1 ) * $prepared_args['number'];\n\t\t}\n\n\t\tif ( isset( $registered['orderby'] ) ) {\n\t\t\t$orderby_possibles = array(\n\t\t\t\t'id'              => 'ID',\n\t\t\t\t'include'         => 'include',\n\t\t\t\t'name'            => 'display_name',\n\t\t\t\t'registered_date' => 'registered',\n\t\t\t\t'slug'            => 'user_nicename',\n\t\t\t\t'email'           => 'user_email',\n\t\t\t\t'url'             => 'user_url',\n\t\t\t);\n\t\t\t$prepared_args['orderby'] = $orderby_possibles[ $request['orderby'] ];\n\t\t}\n\n\t\tif ( ! current_user_can( 'list_users' ) ) {\n\t\t\t$prepared_args['has_published_posts'] = get_post_types( array( 'show_in_rest' => true ), 'names' );\n\t\t}\n\n\t\tif ( ! empty( $prepared_args['search'] ) ) {\n\t\t\t$prepared_args['search'] = '*' . $prepared_args['search'] . '*';\n\t\t}\n\n\t\tif ( isset( $registered['slug'] ) && ! empty( $request['slug'] ) ) {\n\t\t\t$prepared_args['search'] = $request['slug'];\n\t\t\t$prepared_args['search_columns'] = array( 'user_nicename' );\n\t\t}\n\n\t\t/**\n\t\t * Filters WP_User_Query arguments when querying users via the REST API.\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments for WP_User_Query.\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n\t\t$query = new WP_User_Query( $prepared_args );\n\n\t\t$users = array();\n\n\t\tforeach ( $query->results as $user ) {\n\t\t\t$data = $this->prepare_item_for_response( $user, $request );\n\t\t\t$users[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$response = rest_ensure_response( $users );\n\n\t\t// Store pagination values for headers then unset for count query.\n\t\t$per_page = (int) $prepared_args['number'];\n\t\t$page     = ceil( ( ( (int) $prepared_args['offset'] ) / $per_page ) + 1 );\n\n\t\t$prepared_args['fields'] = 'ID';\n\n\t\t$total_users = $query->get_total();\n\n\t\tif ( $total_users < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $prepared_args['number'], $prepared_args['offset'] );\n\t\t\t$count_query = new WP_User_Query( $prepared_args );\n\t\t\t$total_users = $count_query->get_total();\n\t\t}\n\n\t\t$response->header( 'X-WP-Total', (int) $total_users );\n\n\t\t$max_pages = ceil( $total_users / $per_page );\n\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access for the item, otherwise WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\n\t\t$id = (int) $request['id'];\n\t\t$user = get_userdata( $id );\n\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'names' );\n\n\t\tif ( empty( $id ) || empty( $user->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( get_current_user_id() === $id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t} elseif ( ! count_user_posts( $id, $types ) && ! current_user_can( 'edit_user', $id ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$id   = (int) $request['id'];\n\t\t$user = get_userdata( $id );\n\n\t\tif ( empty( $id ) || empty( $user->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$user = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $user );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Retrieves the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_current_item( $request ) {\n\t\t$current_user_id = get_current_user_id();\n\n\t\tif ( empty( $current_user_id ) ) {\n\t\t\treturn new WP_Error( 'rest_not_logged_in', __( 'You are not currently logged in.' ), array( 'status' => 401 ) );\n\t\t}\n\n\t\t$user     = wp_get_current_user();\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access create users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to create items, WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\n\t\tif ( ! current_user_can( 'create_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create_user', __( 'Sorry, you are not allowed to create new users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_user_exists', __( 'Cannot create existing user.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $request['roles'] ) && ! empty( $schema['properties']['roles'] ) ) {\n\t\t\t$check_permission = $this->check_role_update( $request['id'], $request['roles'] );\n\n\t\t\tif ( is_wp_error( $check_permission ) ) {\n\t\t\t\treturn $check_permission;\n\t\t\t}\n\t\t}\n\n\t\t$user = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_multisite() ) {\n\t\t\t$ret = wpmu_validate_user_signup( $user->user_login, $user->user_email );\n\n\t\t\tif ( is_wp_error( $ret['errors'] ) && ! empty( $ret['errors']->errors ) ) {\n\t\t\t\t$error = new WP_Error( 'rest_invalid_param', __( 'Invalid user parameter(s).' ), array( 'status' => 400 ) );\n\t\t\t\tforeach ( $ret['errors']->errors as $code => $messages ) {\n\t\t\t\t\tforeach ( $messages as $message ) {\n\t\t\t\t\t\t$error->add( $code, $message );\n\t\t\t\t\t}\n\t\t\t\t\tif ( $error_data = $error->get_error_data( $code ) ) {\n\t\t\t\t\t\t$error->add_data( $error_data, $code );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( is_multisite() ) {\n\t\t\t$user_id = wpmu_create_user( $user->user_login, $user->user_pass, $user->user_email );\n\n\t\t\tif ( ! $user_id ) {\n\t\t\t\treturn new WP_Error( 'rest_user_create', __( 'Error creating new user.' ), array( 'status' => 500 ) );\n\t\t\t}\n\n\t\t\t$user->ID = $user_id;\n\t\t\t$user_id  = wp_update_user( wp_slash( (array) $user ) );\n\n\t\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\t\treturn $user_id;\n\t\t\t}\n\n\t\t\tadd_user_to_blog( get_site()->id, $user_id, '' );\n\t\t} else {\n\t\t\t$user_id = wp_insert_user( wp_slash( (array) $user ) );\n\n\t\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\t\treturn $user_id;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\n\t\t/**\n\t\t * Fires immediately after a user is created or updated via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_User         $user     Inserted or updated user object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a user, false when updating.\n\t\t */\n\t\tdo_action( 'rest_insert_user', $user, $request, true );\n\n\t\tif ( ! empty( $request['roles'] ) && ! empty( $schema['properties']['roles'] ) ) {\n\t\t\tarray_map( array( $user, 'add_role' ), $request['roles'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $user_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $user, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $user_id ) ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\n\t\t$id = (int) $request['id'];\n\n\t\tif ( ! current_user_can( 'edit_user', $id ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) && ! current_user_can( 'edit_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_roles', __( 'Sorry, you are not allowed to edit roles of this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$id   = (int) $request['id'];\n\t\t$user = get_userdata( $id );\n\n\t\tif ( ! $user ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( email_exists( $request['email'] ) && $request['email'] !== $user->user_email ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_email', __( 'Invalid email address.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['username'] ) && $request['username'] !== $user->user_login ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_argument', __( \"Username isn't editable.\" ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['slug'] ) && $request['slug'] !== $user->user_nicename && get_user_by( 'slug', $request['slug'] ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_slug', __( 'Invalid slug.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) ) {\n\t\t\t$check_permission = $this->check_role_update( $id, $request['roles'] );\n\n\t\t\tif ( is_wp_error( $check_permission ) ) {\n\t\t\t\treturn $check_permission;\n\t\t\t}\n\t\t}\n\n\t\t$user = $this->prepare_item_for_database( $request );\n\n\t\t// Ensure we're operating on the same user we already checked.\n\t\t$user->ID = $id;\n\n\t\t$user_id = wp_update_user( wp_slash( (array) $user ) );\n\n\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\treturn $user_id;\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-users-controller.php */\n\t\tdo_action( 'rest_insert_user', $user, $request, false );\n\n\t\tif ( is_multisite() && ! is_user_member_of_blog( $id ) ) {\n\t\t\tadd_user_to_blog( get_current_blog_id(), $id, '' );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) ) {\n\t\t\tarray_map( array( $user, 'add_role' ), $request['roles'] );\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $user, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_current_item_permissions_check( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->update_item_permissions_check( $request );\n\t}\n\n\t/**\n\t * Updates the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tfunction update_current_item( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->update_item( $request );\n\t}\n\n\t/**\n\t * Checks if a given request has access delete a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\n\t\t$id = (int) $request['id'];\n\n\t\tif ( ! current_user_can( 'delete_user', $id ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_delete', __( 'Sorry, you are not allowed to delete this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t// We don't support delete requests in multisite.\n\t\tif ( is_multisite() ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The user cannot be deleted.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$id       = (int) $request['id'];\n\t\t$reassign = false === $request['reassign'] ? null : absint( $request['reassign'] );\n\t\t$force    = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for users.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Users do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$user = get_userdata( $id );\n\n\t\tif ( ! $user ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( ! empty( $reassign ) ) {\n\t\t\tif ( $reassign === $id || ! get_userdata( $reassign ) ) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_reassign', __( 'Invalid user ID for reassignment.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$previous = $this->prepare_item_for_response( $user, $request );\n\n\t\t/** Include admin user functions to get access to wp_delete_user() */\n\t\trequire_once ABSPATH . 'wp-admin/includes/user.php';\n\n\t\t$result = wp_delete_user( $id, $reassign );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The user cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\n\t\t/**\n\t\t * Fires immediately after a user is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_User          $user     The user data.\n\t\t * @param WP_REST_Response $response The response returned from the API.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_user', $user, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_current_item_permissions_check( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->delete_item_permissions_check( $request );\n\t}\n\n\t/**\n\t * Deletes the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tfunction delete_current_item( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->delete_item( $request );\n\t}\n\n\t/**\n\t * Prepares a single user output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_User         $user    User object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $user, $request ) {\n\n\t\t$data   = array();\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $user->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['username'] ) ) {\n\t\t\t$data['username'] = $user->user_login;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$data['name'] = $user->display_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['first_name'] ) ) {\n\t\t\t$data['first_name'] = $user->first_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['last_name'] ) ) {\n\t\t\t$data['last_name'] = $user->last_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['email'] ) ) {\n\t\t\t$data['email'] = $user->user_email;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['url'] ) ) {\n\t\t\t$data['url'] = $user->user_url;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$data['description'] = $user->description;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_author_posts_url( $user->ID, $user->user_nicename );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['locale'] ) ) {\n\t\t\t$data['locale'] = get_user_locale( $user );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['nickname'] ) ) {\n\t\t\t$data['nickname'] = $user->nickname;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $user->user_nicename;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['roles'] ) ) {\n\t\t\t// Defensively call array_values() to ensure an array is returned.\n\t\t\t$data['roles'] = array_values( $user->roles );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['registered_date'] ) ) {\n\t\t\t$data['registered_date'] = date( 'c', strtotime( $user->user_registered ) );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['capabilities'] ) ) {\n\t\t\t$data['capabilities'] = (object) $user->allcaps;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['extra_capabilities'] ) ) {\n\t\t\t$data['extra_capabilities'] = (object) $user->caps;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['avatar_urls'] ) ) {\n\t\t\t$data['avatar_urls'] = rest_get_avatar_urls( $user->user_email );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $user->ID, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'embed';\n\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $user ) );\n\n\t\t/**\n\t\t * Filters user data returned from the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $user     User object used to create response.\n\t\t * @param WP_REST_Request  $request  Request object.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_user', $response, $user, $request );\n\t}\n\n\t/**\n\t * Prepares links for the user request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post $user User object.\n\t * @return array Links for the given user.\n\t */\n\tprotected function prepare_links( $user ) {\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $user->ID ) ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t);\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Prepares a single user for creation or update.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return object $prepared_user User object.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_user = new stdClass;\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// required arguments.\n\t\tif ( isset( $request['email'] ) && ! empty( $schema['properties']['email'] ) ) {\n\t\t\t$prepared_user->user_email = $request['email'];\n\t\t}\n\n\t\tif ( isset( $request['username'] ) && ! empty( $schema['properties']['username'] ) ) {\n\t\t\t$prepared_user->user_login = $request['username'];\n\t\t}\n\n\t\tif ( isset( $request['password'] ) && ! empty( $schema['properties']['password'] ) ) {\n\t\t\t$prepared_user->user_pass = $request['password'];\n\t\t}\n\n\t\t// optional arguments.\n\t\tif ( isset( $request['id'] ) ) {\n\t\t\t$prepared_user->ID = absint( $request['id'] );\n\t\t}\n\n\t\tif ( isset( $request['name'] ) && ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$prepared_user->display_name = $request['name'];\n\t\t}\n\n\t\tif ( isset( $request['first_name'] ) && ! empty( $schema['properties']['first_name'] ) ) {\n\t\t\t$prepared_user->first_name = $request['first_name'];\n\t\t}\n\n\t\tif ( isset( $request['last_name'] ) && ! empty( $schema['properties']['last_name'] ) ) {\n\t\t\t$prepared_user->last_name = $request['last_name'];\n\t\t}\n\n\t\tif ( isset( $request['nickname'] ) && ! empty( $schema['properties']['nickname'] ) ) {\n\t\t\t$prepared_user->nickname = $request['nickname'];\n\t\t}\n\n\t\tif ( isset( $request['slug'] ) && ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$prepared_user->user_nicename = $request['slug'];\n\t\t}\n\n\t\tif ( isset( $request['description'] ) && ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$prepared_user->description = $request['description'];\n\t\t}\n\n\t\tif ( isset( $request['url'] ) && ! empty( $schema['properties']['url'] ) ) {\n\t\t\t$prepared_user->user_url = $request['url'];\n\t\t}\n\n\t\tif ( isset( $request['locale'] ) && ! empty( $schema['properties']['locale'] ) ) {\n\t\t\t$prepared_user->locale = $request['locale'];\n\t\t}\n\n\t\t// setting roles will be handled outside of this function.\n\t\tif ( isset( $request['roles'] ) ) {\n\t\t\t$prepared_user->role = false;\n\t\t}\n\n\t\t/**\n\t\t * Filters user data before insertion via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object          $prepared_user User object.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( 'rest_pre_insert_user', $prepared_user, $request );\n\t}\n\n\t/**\n\t * Determines if the current user is allowed to make the desired roles change.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param integer $user_id User ID.\n\t * @param array   $roles   New user roles.\n\t * @return true|WP_Error True if the current user is allowed to make the role change,\n\t *                       otherwise a WP_Error object.\n\t */\n\tprotected function check_role_update( $user_id, $roles ) {\n\t\tglobal $wp_roles;\n\n\t\tforeach ( $roles as $role ) {\n\n\t\t\tif ( ! isset( $wp_roles->role_objects[ $role ] ) ) {\n\t\t\t\t/* translators: %s: role key */\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', sprintf( __( 'The role %s does not exist.' ), $role ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$potential_role = $wp_roles->role_objects[ $role ];\n\n\t\t\t/*\n\t\t\t * Don't let anyone with 'edit_users' (admins) edit their own role to something without it.\n\t\t\t * Multisite super admins can freely edit their blog roles -- they possess all caps.\n\t\t\t */\n\t\t\tif ( ! ( is_multisite()\n\t\t\t\t&& current_user_can( 'manage_sites' ) )\n\t\t\t\t&& get_current_user_id() === $user_id\n\t\t\t\t&& ! $potential_role->has_cap( 'edit_users' )\n\t\t\t) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', __( 'Sorry, you are not allowed to give users that role.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\n\t\t\t/** Include admin functions to get access to get_editable_roles() */\n\t\t\trequire_once ABSPATH . 'wp-admin/includes/admin.php';\n\n\t\t\t// The new role must be editable by the logged-in user.\n\t\t\t$editable_roles = get_editable_roles();\n\n\t\t\tif ( empty( $editable_roles[ $role ] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', __( 'Sorry, you are not allowed to give users that role.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check a username for the REST API.\n\t *\n\t * Performs a couple of checks like edit_user() in wp-admin/includes/user.php.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  mixed            $value   The username submitted in the request.\n\t * @param  WP_REST_Request  $request Full details about the request.\n\t * @param  string           $param   The parameter name.\n\t * @return WP_Error|string The sanitized username, if valid, otherwise an error.\n\t */\n\tpublic function check_username( $value, $request, $param ) {\n\t\t$username = (string) $value;\n\n\t\tif ( ! validate_username( $username ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_username', __( 'Username contains invalid characters.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/user.php */\n\t\t$illegal_logins = (array) apply_filters( 'illegal_user_logins', array() );\n\n\t\tif ( in_array( strtolower( $username ), array_map( 'strtolower', $illegal_logins ) ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_username', __( 'Sorry, that username is not allowed.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\treturn $username;\n\t}\n\n\t/**\n\t * Check a user password for the REST API.\n\t *\n\t * Performs a couple of checks like edit_user() in wp-admin/includes/user.php.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  mixed            $value   The password submitted in the request.\n\t * @param  WP_REST_Request  $request Full details about the request.\n\t * @param  string           $param   The parameter name.\n\t * @return WP_Error|string The sanitized password, if valid, otherwise an error.\n\t */\n\tpublic function check_user_password( $value, $request, $param ) {\n\t\t$password = (string) $value;\n\n\t\tif ( empty( $password ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_password', __( 'Passwords cannot be empty.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( false !== strpos( $password, \"\\\\\" ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_password', __( 'Passwords cannot contain the \"\\\\\" character.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\treturn $password;\n\t}\n\n\t/**\n\t * Retrieves the user's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => 'user',\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => array(\n\t\t\t\t'id'          => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the user.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'username'    => array(\n\t\t\t\t\t'description' => __( 'Login name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'required'    => true,\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_username' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'name'        => array(\n\t\t\t\t\t'description' => __( 'Display name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'first_name'  => array(\n\t\t\t\t\t'description' => __( 'First name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'last_name'   => array(\n\t\t\t\t\t'description' => __( 'Last name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'email'       => array(\n\t\t\t\t\t'description' => __( 'The email address for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'email',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'required'    => true,\n\t\t\t\t),\n\t\t\t\t'url'         => array(\n\t\t\t\t\t'description' => __( 'URL of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'description' => array(\n\t\t\t\t\t'description' => __( 'Description of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'        => array(\n\t\t\t\t\t'description' => __( 'Author URL of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'locale'    => array(\n\t\t\t\t\t'description' => __( 'Locale for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'enum'        => array_merge( array( '', 'en_US' ), get_available_languages() ),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'nickname'    => array(\n\t\t\t\t\t'description' => __( 'The nickname for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'slug'        => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'registered_date' => array(\n\t\t\t\t\t'description' => __( 'Registration date for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'roles'           => array(\n\t\t\t\t\t'description' => __( 'Roles assigned to the user.' ),\n\t\t\t\t\t'type'        => 'array',\n\t\t\t\t\t'items'       => array(\n\t\t\t\t\t\t'type'    => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'password'        => array(\n\t\t\t\t\t'description' => __( 'Password for the user (never included).' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array(), // Password is never displayed.\n\t\t\t\t\t'required'    => true,\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_user_password' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'capabilities'    => array(\n\t\t\t\t\t'description' => __( 'All capabilities assigned to the user.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'extra_capabilities' => array(\n\t\t\t\t\t'description' => __( 'Any extra capabilities assigned to the user.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif ( get_option( 'show_avatars' ) ) {\n\t\t\t$avatar_properties = array();\n\n\t\t\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t\t\tforeach ( $avatar_sizes as $size ) {\n\t\t\t\t$avatar_properties[ $size ] = array(\n\t\t\t\t\t/* translators: %d: avatar image size in pixels */\n\t\t\t\t\t'description' => sprintf( __( 'Avatar URL with image size of %d pixels.' ), $size ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$schema['properties']['avatar_urls']  = array(\n\t\t\t\t'description' => __( 'Avatar URLs for the user.' ),\n\t\t\t\t'type'        => 'object',\n\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t'readonly'    => true,\n\t\t\t\t'properties'  => $avatar_properties,\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order'] = array(\n\t\t\t'default'            => 'asc',\n\t\t\t'description'        => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'enum'               => array( 'asc', 'desc' ),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'default'            => 'name',\n\t\t\t'description'        => __( 'Sort collection by object attribute.' ),\n\t\t\t'enum'               => array(\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'name',\n\t\t\t\t'registered_date',\n\t\t\t\t'slug',\n\t\t\t\t'email',\n\t\t\t\t'url',\n\t\t\t),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['slug']    = array(\n\t\t\t'description'        => __( 'Limit result set to users with a specific slug.' ),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['roles']   = array(\n\t\t\t'description'        => __( 'Limit result set to users matching at least one specific role provided. Accepts csv list or single role.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'string',\n\t\t\t),\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the users controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_User_Query parameter.  Use the\n\t\t * `rest_user_query` filter to set WP_User_Query arguments.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array $query_params JSON Schema-formatted collection parameters.\n\t\t */\n\t\treturn apply_filters( 'rest_user_collection_params', $query_params );\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39952';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * REST API functions.\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.4.0\n */\n\n/**\n * Version number for our API.\n *\n * @var string\n */\ndefine( 'REST_API_VERSION', '2.0' );\n\n/**\n * Registers a REST API route.\n *\n * @since 4.4.0\n *\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n *\n * @param string $namespace The first URL segment after core prefix. Should be unique to your package/plugin.\n * @param string $route     The base URL for route you are adding.\n * @param array  $args      Optional. Either an array of options for the endpoint, or an array of arrays for\n *                          multiple methods. Default empty array.\n * @param bool   $override  Optional. If the route already exists, should we override it? True overrides,\n *                          false merges (with newer overriding if duplicate keys exist). Default false.\n * @return bool True on success, false on error.\n */\nfunction register_rest_route( $namespace, $route, $args = array(), $override = false ) {\n\t/** @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $namespace ) ) {\n\t\t/*\n\t\t * Non-namespaced routes are not allowed, with the exception of the main\n\t\t * and namespace indexes. If you really need to register a\n\t\t * non-namespaced route, call `WP_REST_Server::register_route` directly.\n\t\t */\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Routes must be namespaced with plugin or theme name and version.' ), '4.4.0' );\n\t\treturn false;\n\t} else if ( empty( $route ) ) {\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Route must be specified.' ), '4.4.0' );\n\t\treturn false;\n\t}\n\n\tif ( isset( $args['args'] ) ) {\n\t\t$common_args = $args['args'];\n\t\tunset( $args['args'] );\n\t} else {\n\t\t$common_args = array();\n\t}\n\n\tif ( isset( $args['callback'] ) ) {\n\t\t// Upgrade a single set to multiple.\n\t\t$args = array( $args );\n\t}\n\n\t$defaults = array(\n\t\t'methods'         => 'GET',\n\t\t'callback'        => null,\n\t\t'args'            => array(),\n\t);\n\tforeach ( $args as $key => &$arg_group ) {\n\t\tif ( ! is_numeric( $key ) ) {\n\t\t\t// Route option, skip here.\n\t\t\tcontinue;\n\t\t}\n\n\t\t$arg_group = array_merge( $defaults, $arg_group );\n\t\t$arg_group['args'] = array_merge( $common_args, $arg_group['args'] );\n\t}\n\n\t$full_route = '/' . trim( $namespace, '/' ) . '/' . trim( $route, '/' );\n\t$wp_rest_server->register_route( $namespace, $full_route, $args, $override );\n\treturn true;\n}\n\n/**\n * Registers a new field on an existing WordPress object type.\n *\n * @since 4.7.0\n *\n * @global array $wp_rest_additional_fields Holds registered fields, organized\n *                                          by object type.\n *\n * @param string|array $object_type Object(s) the field is being registered\n *                                  to, \"post\"|\"term\"|\"comment\" etc.\n * @param string $attribute         The attribute name.\n * @param array  $args {\n *     Optional. An array of arguments used to handle the registered field.\n *\n *     @type string|array|null $get_callback    Optional. The callback function used to retrieve the field\n *                                              value. Default is 'null', the field will not be returned in\n *                                              the response.\n *     @type string|array|null $update_callback Optional. The callback function used to set and update the\n *                                              field value. Default is 'null', the value cannot be set or\n *                                              updated.\n *     @type string|array|null $schema          Optional. The callback function used to create the schema for\n *                                              this field. Default is 'null', no schema entry will be returned.\n * }\n */\nfunction register_rest_field( $object_type, $attribute, $args = array() ) {\n\t$defaults = array(\n\t\t'get_callback'    => null,\n\t\t'update_callback' => null,\n\t\t'schema'          => null,\n\t);\n\n\t$args = wp_parse_args( $args, $defaults );\n\n\tglobal $wp_rest_additional_fields;\n\n\t$object_types = (array) $object_type;\n\n\tforeach ( $object_types as $object_type ) {\n\t\t$wp_rest_additional_fields[ $object_type ][ $attribute ] = $args;\n\t}\n}\n\n/**\n * Registers rewrite rules for the API.\n *\n * @since 4.4.0\n *\n * @see rest_api_register_rewrites()\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_init() {\n\trest_api_register_rewrites();\n\n\tglobal $wp;\n\t$wp->add_query_var( 'rest_route' );\n}\n\n/**\n * Adds REST rewrite rules.\n *\n * @since 4.4.0\n *\n * @see add_rewrite_rule()\n * @global WP_Rewrite $wp_rewrite\n */\nfunction rest_api_register_rewrites() {\n\tglobal $wp_rewrite;\n\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/?$','index.php?rest_route=/','top' );\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/(.*)?','index.php?rest_route=/$matches[1]','top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/?$','index.php?rest_route=/','top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/(.*)?','index.php?rest_route=/$matches[1]','top' );\n}\n\n/**\n * Registers the default REST API filters.\n *\n * Attached to the {@see 'rest_api_init'} action\n * to make testing and disabling these filters easier.\n *\n * @since 4.4.0\n */\nfunction rest_api_default_filters() {\n\t// Deprecated reporting.\n\tadd_action( 'deprecated_function_run', 'rest_handle_deprecated_function', 10, 3 );\n\tadd_filter( 'deprecated_function_trigger_error', '__return_false' );\n\tadd_action( 'deprecated_argument_run', 'rest_handle_deprecated_argument', 10, 3 );\n\tadd_filter( 'deprecated_argument_trigger_error', '__return_false' );\n\n\t// Default serving.\n\tadd_filter( 'rest_pre_serve_request', 'rest_send_cors_headers' );\n\tadd_filter( 'rest_post_dispatch', 'rest_send_allow_header', 10, 3 );\n\n\tadd_filter( 'rest_pre_dispatch', 'rest_handle_options_request', 10, 3 );\n}\n\n/**\n * Registers default REST API routes.\n *\n * @since 4.7.0\n */\nfunction create_initial_rest_routes() {\n\tforeach ( get_post_types( array( 'show_in_rest' => true ), 'objects' ) as $post_type ) {\n\t\t$class = ! empty( $post_type->rest_controller_class ) ? $post_type->rest_controller_class : 'WP_REST_Posts_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $post_type->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\n\t\tif ( post_type_supports( $post_type->name, 'revisions' ) ) {\n\t\t\t$revisions_controller = new WP_REST_Revisions_Controller( $post_type->name );\n\t\t\t$revisions_controller->register_routes();\n\t\t}\n\t}\n\n\t// Post types.\n\t$controller = new WP_REST_Post_Types_Controller;\n\t$controller->register_routes();\n\n\t// Post statuses.\n\t$controller = new WP_REST_Post_Statuses_Controller;\n\t$controller->register_routes();\n\n\t// Taxonomies.\n\t$controller = new WP_REST_Taxonomies_Controller;\n\t$controller->register_routes();\n\n\t// Terms.\n\tforeach ( get_taxonomies( array( 'show_in_rest' => true ), 'object' ) as $taxonomy ) {\n\t\t$class = ! empty( $taxonomy->rest_controller_class ) ? $taxonomy->rest_controller_class : 'WP_REST_Terms_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $taxonomy->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\t}\n\n\t// Users.\n\t$controller = new WP_REST_Users_Controller;\n\t$controller->register_routes();\n\n\t// Comments.\n\t$controller = new WP_REST_Comments_Controller;\n\t$controller->register_routes();\n\n\t// Settings.\n\t$controller = new WP_REST_Settings_Controller;\n\t$controller->register_routes();\n}\n\n/**\n * Loads the REST API.\n *\n * @since 4.4.0\n *\n * @global WP             $wp             Current WordPress environment instance.\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n */\nfunction rest_api_loaded() {\n\tif ( empty( $GLOBALS['wp']->query_vars['rest_route'] ) ) {\n\t\treturn;\n\t}\n\n\t/**\n\t * Whether this is a REST Request.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tdefine( 'REST_REQUEST', true );\n\n\t// Initialize the server.\n\t$server = rest_get_server();\n\n\t// Fire off the request.\n\t$route = untrailingslashit( $GLOBALS['wp']->query_vars['rest_route'] );\n\tif ( empty( $route ) ) {\n\t\t$route = '/';\n\t}\n\t$server->serve_request( $route );\n\n\t// We're done.\n\tdie();\n}\n\n/**\n * Retrieves the URL prefix for any API resource.\n *\n * @since 4.4.0\n *\n * @return string Prefix.\n */\nfunction rest_get_url_prefix() {\n\t/**\n\t * Filters the REST URL prefix.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $prefix URL prefix. Default 'wp-json'.\n\t */\n\treturn apply_filters( 'rest_url_prefix', 'wp-json' );\n}\n\n/**\n * Retrieves the URL to a REST endpoint on a site.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @todo Check if this is even necessary\n * @global WP_Rewrite $wp_rewrite\n *\n * @param int    $blog_id Optional. Blog ID. Default of null returns URL for current blog.\n * @param string $path    Optional. REST route. Default '/'.\n * @param string $scheme  Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction get_rest_url( $blog_id = null, $path = '/', $scheme = 'rest' ) {\n\tif ( empty( $path ) ) {\n\t\t$path = '/';\n\t}\n\n\tif ( is_multisite() && get_blog_option( $blog_id, 'permalink_structure' ) || get_option( 'permalink_structure' ) ) {\n\t\tglobal $wp_rewrite;\n\n\t\tif ( $wp_rewrite->using_index_permalinks() ) {\n\t\t\t$url = get_home_url( $blog_id, $wp_rewrite->index . '/' . rest_get_url_prefix(), $scheme );\n\t\t} else {\n\t\t\t$url = get_home_url( $blog_id, rest_get_url_prefix(), $scheme );\n\t\t}\n\n\t\t$url .= '/' . ltrim( $path, '/' );\n\t} else {\n\t\t$url = trailingslashit( get_home_url( $blog_id, '', $scheme ) );\n\n\t\t$path = '/' . ltrim( $path, '/' );\n\n\t\t$url = add_query_arg( 'rest_route', $path, $url );\n\t}\n\n\tif ( is_ssl() ) {\n\t\t// If the current host is the same as the REST URL host, force the REST URL scheme to HTTPS.\n\t\tif ( $_SERVER['SERVER_NAME'] === parse_url( get_home_url( $blog_id ), PHP_URL_HOST ) ) {\n\t\t\t$url = set_url_scheme( $url, 'https' );\n\t\t}\n\t}\n\n\t/**\n\t * Filters the REST URL.\n\t *\n\t * Use this filter to adjust the url returned by the get_rest_url() function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $url     REST URL.\n\t * @param string $path    REST route.\n\t * @param int    $blog_id Blog ID.\n\t * @param string $scheme  Sanitization scheme.\n\t */\n\treturn apply_filters( 'rest_url', $url, $path, $blog_id, $scheme );\n}\n\n/**\n * Retrieves the URL to a REST endpoint.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @param string $path   Optional. REST route. Default empty.\n * @param string $scheme Optional. Sanitization scheme. Default 'json'.\n * @return string Full URL to the endpoint.\n */\nfunction rest_url( $path = '', $scheme = 'json' ) {\n\treturn get_rest_url( null, $path, $scheme );\n}\n\n/**\n * Do a REST request.\n *\n * Used primarily to route internal requests through WP_REST_Server.\n *\n * @since 4.4.0\n *\n * @global WP_REST_Server $wp_rest_server ResponseHandler instance (usually WP_REST_Server).\n *\n * @param WP_REST_Request|string $request Request.\n * @return WP_REST_Response REST response.\n */\nfunction rest_do_request( $request ) {\n\t$request = rest_ensure_request( $request );\n\treturn rest_get_server()->dispatch( $request );\n}\n\n/**\n * Retrieves the current REST server instance.\n *\n * Instantiates a new instance if none exists already.\n *\n * @since 4.5.0\n *\n * @global WP_REST_Server $wp_rest_server REST server instance.\n *\n * @return WP_REST_Server REST server instance.\n */\nfunction rest_get_server() {\n\t/* @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $wp_rest_server ) ) {\n\t\t/**\n\t\t * Filters the REST Server Class.\n\t\t *\n\t\t * This filter allows you to adjust the server class used by the API, using a\n\t\t * different class to handle requests.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string $class_name The name of the server class. Default 'WP_REST_Server'.\n\t\t */\n\t\t$wp_rest_server_class = apply_filters( 'wp_rest_server_class', 'WP_REST_Server' );\n\t\t$wp_rest_server = new $wp_rest_server_class;\n\n\t\t/**\n\t\t * Fires when preparing to serve an API request.\n\t\t *\n\t\t * Endpoint objects should be created and register their hooks on this action rather\n\t\t * than another action to ensure they're only loaded when needed.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param WP_REST_Server $wp_rest_server Server object.\n\t\t */\n\t\tdo_action( 'rest_api_init', $wp_rest_server );\n\t}\n\n\treturn $wp_rest_server;\n}\n\n/**\n * Ensures request arguments are a request object (for consistency).\n *\n * @since 4.4.0\n *\n * @param array|WP_REST_Request $request Request to check.\n * @return WP_REST_Request REST request instance.\n */\nfunction rest_ensure_request( $request ) {\n\tif ( $request instanceof WP_REST_Request ) {\n\t\treturn $request;\n\t}\n\n\treturn new WP_REST_Request( 'GET', '', $request );\n}\n\n/**\n * Ensures a REST response is a response object (for consistency).\n *\n * This implements WP_HTTP_Response, allowing usage of `set_status`/`header`/etc\n * without needing to double-check the object. Will also allow WP_Error to indicate error\n * responses, so users should immediately check for this value.\n *\n * @since 4.4.0\n *\n * @param WP_Error|WP_HTTP_Response|mixed $response Response to check.\n * @return WP_REST_Response|mixed If response generated an error, WP_Error, if response\n *                                is already an instance, WP_HTTP_Response, otherwise\n *                                returns a new WP_REST_Response instance.\n */\nfunction rest_ensure_response( $response ) {\n\tif ( is_wp_error( $response ) ) {\n\t\treturn $response;\n\t}\n\n\tif ( $response instanceof WP_HTTP_Response ) {\n\t\treturn $response;\n\t}\n\n\treturn new WP_REST_Response( $response );\n}\n\n/**\n * Handles _deprecated_function() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $replacement The function that should have been called.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_function( $function, $replacement, $version ) {\n\tif ( ! empty( $replacement ) ) {\n\t\t/* translators: 1: function name, 2: WordPress version number, 3: new function name */\n\t\t$string = sprintf( __( '%1$s (since %2$s; use %3$s instead)' ), $function, $version, $replacement );\n\t} else {\n\t\t/* translators: 1: function name, 2: WordPress version number */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedFunction: %s', $string ) );\n}\n\n/**\n * Handles _deprecated_argument() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $message     A message regarding the change.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_argument( $function, $message, $version ) {\n\tif ( ! empty( $message ) ) {\n\t\t/* translators: 1: function name, 2: WordPress version number, 3: error message */\n\t\t$string = sprintf( __( '%1$s (since %2$s; %3$s)' ), $function, $version, $message );\n\t} else {\n\t\t/* translators: 1: function name, 2: WordPress version number */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedParam: %s', $string ) );\n}\n\n/**\n * Sends Cross-Origin Resource Sharing headers with API requests.\n *\n * @since 4.4.0\n *\n * @param mixed $value Response data.\n * @return mixed Response data.\n */\nfunction rest_send_cors_headers( $value ) {\n\t$origin = get_http_origin();\n\n\tif ( $origin ) {\n\t\theader( 'Access-Control-Allow-Origin: ' . esc_url_raw( $origin ) );\n\t\theader( 'Access-Control-Allow-Methods: OPTIONS, GET, POST, PUT, PATCH, DELETE' );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\theader( 'Vary: Origin' );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Handles OPTIONS requests for the server.\n *\n * This is handled outside of the server code, as it doesn't obey normal route\n * mapping.\n *\n * @since 4.4.0\n *\n * @param mixed           $response Current response, either response or `null` to indicate pass-through.\n * @param WP_REST_Server  $handler  ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request $request  The request that was used to make current response.\n * @return WP_REST_Response Modified response, either response or `null` to indicate pass-through.\n */\nfunction rest_handle_options_request( $response, $handler, $request ) {\n\tif ( ! empty( $response ) || $request->get_method() !== 'OPTIONS' ) {\n\t\treturn $response;\n\t}\n\n\t$response = new WP_REST_Response();\n\t$data = array();\n\n\tforeach ( $handler->get_routes() as $route => $endpoints ) {\n\t\t$match = preg_match( '@^' . $route . '$@i', $request->get_route() );\n\n\t\tif ( ! $match ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$data = $handler->get_data_for_route( $route, $endpoints, 'help' );\n\t\t$response->set_matched_route( $route );\n\t\tbreak;\n\t}\n\n\t$response->set_data( $data );\n\treturn $response;\n}\n\n/**\n * Sends the \"Allow\" header to state all methods that can be sent to the current route.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n * @return WP_REST_Response Response to be served, with \"Allow\" header if route has allowed methods.\n */\nfunction rest_send_allow_header( $response, $server, $request ) {\n\t$matched_route = $response->get_matched_route();\n\n\tif ( ! $matched_route ) {\n\t\treturn $response;\n\t}\n\n\t$routes = $server->get_routes();\n\n\t$allowed_methods = array();\n\n\t// Get the allowed methods across the routes.\n\tforeach ( $routes[ $matched_route ] as $_handler ) {\n\t\tforeach ( $_handler['methods'] as $handler_method => $value ) {\n\n\t\t\tif ( ! empty( $_handler['permission_callback'] ) ) {\n\n\t\t\t\t$permission = call_user_func( $_handler['permission_callback'], $request );\n\n\t\t\t\t$allowed_methods[ $handler_method ] = true === $permission;\n\t\t\t} else {\n\t\t\t\t$allowed_methods[ $handler_method ] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Strip out all the methods that are not allowed (false values).\n\t$allowed_methods = array_filter( $allowed_methods );\n\n\tif ( $allowed_methods ) {\n\t\t$response->header( 'Allow', implode( ', ', array_map( 'strtoupper', array_keys( $allowed_methods ) ) ) );\n\t}\n\n\treturn $response;\n}\n\n/**\n * Adds the REST API URL to the WP RSD endpoint.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_rsd() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\t?>\n\t<api name=\"WP-API\" blogID=\"1\" preferred=\"false\" apiLink=\"<?php echo esc_url( $api_root ); ?>\" />\n\t<?php\n}\n\n/**\n * Outputs the REST API link tag into page header.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_link_wp_head() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\techo \"<link rel='https://api.w.org/' href='\" . esc_url( $api_root ) . \"' />\\n\";\n}\n\n/**\n * Sends a Link header for the REST API.\n *\n * @since 4.4.0\n */\nfunction rest_output_link_header() {\n\tif ( headers_sent() ) {\n\t\treturn;\n\t}\n\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\theader( 'Link: <' . esc_url_raw( $api_root ) . '>; rel=\"https://api.w.org/\"', false );\n}\n\n/**\n * Checks for errors when using cookie-based authentication.\n *\n * WordPress' built-in cookie authentication is always active\n * for logged in users. However, the API has to check nonces\n * for each request to ensure users are not vulnerable to CSRF.\n *\n * @since 4.4.0\n *\n * @global mixed          $wp_rest_auth_cookie\n * @global WP_REST_Server $wp_rest_server      REST server instance.\n *\n * @param WP_Error|mixed $result Error from another authentication handler,\n *                               null if we should handle it, or another value\n *                               if not.\n * @return WP_Error|mixed|bool WP_Error if the cookie is invalid, the $result, otherwise true.\n */\nfunction rest_cookie_check_errors( $result ) {\n\tif ( ! empty( $result ) ) {\n\t\treturn $result;\n\t}\n\n\tglobal $wp_rest_auth_cookie, $wp_rest_server;\n\n\t/*\n\t * Is cookie authentication being used? (If we get an auth\n\t * error, but we're still logged in, another authentication\n\t * must have been used).\n\t */\n\tif ( true !== $wp_rest_auth_cookie && is_user_logged_in() ) {\n\t\treturn $result;\n\t}\n\n\t// Determine if there is a nonce.\n\t$nonce = null;\n\n\tif ( isset( $_REQUEST['_wpnonce'] ) ) {\n\t\t$nonce = $_REQUEST['_wpnonce'];\n\t} elseif ( isset( $_SERVER['HTTP_X_WP_NONCE'] ) ) {\n\t\t$nonce = $_SERVER['HTTP_X_WP_NONCE'];\n\t}\n\n\tif ( null === $nonce ) {\n\t\t// No nonce at all, so act as if it's an unauthenticated request.\n\t\twp_set_current_user( 0 );\n\t\treturn true;\n\t}\n\n\t// Check the nonce.\n\t$result = wp_verify_nonce( $nonce, 'wp_rest' );\n\n\tif ( ! $result ) {\n\t\treturn new WP_Error( 'rest_cookie_invalid_nonce', __( 'Cookie nonce is invalid' ), array( 'status' => 403 ) );\n\t}\n\n\t// Send a refreshed nonce in header.\n\t$wp_rest_server->send_header( 'X-WP-Nonce', wp_create_nonce( 'wp_rest' ) );\n\n\treturn true;\n}\n\n/**\n * Collects cookie authentication status.\n *\n * Collects errors from wp_validate_auth_cookie for use by rest_cookie_check_errors.\n *\n * @since 4.4.0\n *\n * @see current_action()\n * @global mixed $wp_rest_auth_cookie\n */\nfunction rest_cookie_collect_status() {\n\tglobal $wp_rest_auth_cookie;\n\n\t$status_type = current_action();\n\n\tif ( 'auth_cookie_valid' !== $status_type ) {\n\t\t$wp_rest_auth_cookie = substr( $status_type, 12 );\n\t\treturn;\n\t}\n\n\t$wp_rest_auth_cookie = true;\n}\n\n/**\n * Parses an RFC3339 time into a Unix timestamp.\n *\n * @since 4.4.0\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Optional. Whether to force UTC timezone instead of using\n *                          the timestamp's timezone. Default false.\n * @return int Unix timestamp.\n */\nfunction rest_parse_date( $date, $force_utc = false ) {\n\tif ( $force_utc ) {\n\t\t$date = preg_replace( '/[+-]\\d+:?\\d+$/', '+00:00', $date );\n\t}\n\n\t$regex = '#^\\d{4}-\\d{2}-\\d{2}[Tt ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}(?::\\d{2})?)?$#';\n\n\tif ( ! preg_match( $regex, $date, $matches ) ) {\n\t\treturn false;\n\t}\n\n\treturn strtotime( $date );\n}\n\n/**\n * Retrieves a local date with its GMT equivalent, in MySQL datetime format.\n *\n * @since 4.4.0\n *\n * @see rest_parse_date()\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Whether a UTC timestamp should be forced. Default false.\n * @return array|null Local and UTC datetime strings, in MySQL datetime format (Y-m-d H:i:s),\n *                    null on failure.\n */\nfunction rest_get_date_with_gmt( $date, $force_utc = false ) {\n\t$date = rest_parse_date( $date, $force_utc );\n\n\tif ( empty( $date ) ) {\n\t\treturn null;\n\t}\n\n\t$utc = date( 'Y-m-d H:i:s', $date );\n\t$local = get_date_from_gmt( $utc );\n\n\treturn array( $local, $utc );\n}\n\n/**\n * Returns a contextual HTTP error code for authorization failure.\n *\n * @since 4.7.0\n *\n * @return integer 401 if the user is not logged in, 403 if the user is logged in.\n */\nfunction rest_authorization_required_code() {\n\treturn is_user_logged_in() ? 403 : 401;\n}\n\n/**\n * Validate a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return WP_Error|boolean\n */\nfunction rest_validate_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn true;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_validate_value_from_schema( $value, $args, $param );\n}\n\n/**\n * Sanitize a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_sanitize_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn $value;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_sanitize_value_from_schema( $value, $args );\n}\n\n/**\n * Parse a request argument based on details registered to the route.\n *\n * Runs a validation check and sanitizes the value, primarily to be used via\n * the `sanitize_callback` arguments in the endpoint args registration.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_parse_request_arg( $value, $request, $param ) {\n\t$is_valid = rest_validate_request_arg( $value, $request, $param );\n\n\tif ( is_wp_error( $is_valid ) ) {\n\t\treturn $is_valid;\n\t}\n\n\t$value = rest_sanitize_request_arg( $value, $request, $param );\n\n\treturn $value;\n}\n\n/**\n * Determines if an IP address is valid.\n *\n * Handles both IPv4 and IPv6 addresses.\n *\n * @since 4.7.0\n *\n * @param  string $ip IP address.\n * @return string|false The valid IP address, otherwise false.\n */\nfunction rest_is_ip_address( $ip ) {\n\t$ipv4_pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';\n\n\tif ( ! preg_match( $ipv4_pattern, $ip ) && ! Requests_IPv6::check_ipv6( $ip ) ) {\n\t\treturn false;\n\t}\n\n\treturn $ip;\n}\n\n/**\n * Changes a boolean-like value into the proper boolean value.\n *\n * @since 4.7.0\n *\n * @param bool|string|int $value The value being evaluated.\n * @return boolean Returns the proper associated boolean value.\n */\nfunction rest_sanitize_boolean( $value ) {\n\t// String values are translated to `true`; make sure 'false' is false.\n\tif ( is_string( $value )  ) {\n\t\t$value = strtolower( $value );\n\t\tif ( in_array( $value, array( 'false', '0' ), true ) ) {\n\t\t\t$value = false;\n\t\t}\n\t}\n\n\t// Everything else will map nicely to boolean.\n\treturn (boolean) $value;\n}\n\n/**\n * Determines if a given value is boolean-like.\n *\n * @since 4.7.0\n *\n * @param bool|string $maybe_bool The value being evaluated.\n * @return boolean True if a boolean, otherwise false.\n */\nfunction rest_is_boolean( $maybe_bool ) {\n\tif ( is_bool( $maybe_bool ) ) {\n\t\treturn true;\n\t}\n\n\tif ( is_string( $maybe_bool ) ) {\n\t\t$maybe_bool = strtolower( $maybe_bool );\n\n\t\t$valid_boolean_values = array(\n\t\t\t'false',\n\t\t\t'true',\n\t\t\t'0',\n\t\t\t'1',\n\t\t);\n\n\t\treturn in_array( $maybe_bool, $valid_boolean_values, true );\n\t}\n\n\tif ( is_int( $maybe_bool ) ) {\n\t\treturn in_array( $maybe_bool, array( 0, 1 ), true );\n\t}\n\n\treturn false;\n}\n\n/**\n * Retrieves the avatar urls in various sizes based on a given email address.\n *\n * @since 4.7.0\n *\n * @see get_avatar_url()\n *\n * @param string $email Email address.\n * @return array $urls Gravatar url for each size.\n */\nfunction rest_get_avatar_urls( $email ) {\n\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t$urls = array();\n\tforeach ( $avatar_sizes as $size ) {\n\t\t$urls[ $size ] = get_avatar_url( $email, array( 'size' => $size ) );\n\t}\n\n\treturn $urls;\n}\n\n/**\n * Retrieves the pixel sizes for avatars.\n *\n * @since 4.7.0\n *\n * @return array List of pixel sizes for avatars. Default `[ 24, 48, 96 ]`.\n */\nfunction rest_get_avatar_sizes() {\n\t/**\n\t * Filter the REST avatar sizes.\n\t *\n\t * Use this filter to adjust the array of sizes returned by the\n\t * `rest_get_avatar_sizes` function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param array $sizes An array of int values that are the pixel sizes for avatars.\n\t *                     Default `[ 24, 48, 96 ]`.\n\t */\n\treturn apply_filters( 'rest_avatar_sizes', array( 24, 48, 96 ) );\n}\n\n/**\n * Validate a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed  $value The value to validate.\n * @param array  $args  Schema array to use for validation.\n * @param string $param The parameter name, used in error messages.\n * @return true|WP_Error\n */\nfunction rest_validate_value_from_schema( $value, $args, $param = '' ) {\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t$value = preg_split( '/[\\s,]+/', $value );\n\t\t}\n\t\tif ( ! wp_is_numeric_array( $value ) ) {\n\t\t\t/* translators: 1: parameter, 2: type name */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'array' ) );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['items'], $param . '[' . $index . ']' );\n\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\treturn $is_valid;\n\t\t\t}\n\t\t}\n\t}\n\tif ( ! empty( $args['enum'] ) ) {\n\t\tif ( ! in_array( $value, $args['enum'], true ) ) {\n\t\t\t/* translators: 1: parameter, 2: list of valid values */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not one of %2$s.' ), $param, implode( ', ', $args['enum'] ) ) );\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'integer', 'number' ) ) && ! is_numeric( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, $args['type'] ) );\n\t}\n\n\tif ( 'integer' === $args['type'] && round( floatval( $value ) ) !== floatval( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'integer' ) );\n\t}\n\n\tif ( 'boolean' === $args['type'] && ! rest_is_boolean( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $value, 'boolean' ) );\n\t}\n\n\tif ( 'string' === $args['type'] && ! is_string( $value ) ) {\n\t\t/* translators: 1: parameter, 2: type name */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'string' ) );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time' :\n\t\t\t\tif ( ! rest_parse_date( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_date', __( 'Invalid date.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'email' :\n\t\t\t\t// is_email() checks for 3 characters (a@b), but\n\t\t\t\t// wp_handle_comment_submission() requires 6 characters (a@b.co)\n\t\t\t\t//\n\t\t\t\t// https://core.trac.wordpress.org/ticket/38506\n\t\t\t\tif ( ! is_email( $value ) || strlen( $value ) < 6 ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_email', __( 'Invalid email address.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ip' :\n\t\t\t\tif ( ! rest_is_ip_address( $value ) ) {\n\t\t\t\t\t/* translators: %s: IP address */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%s is not a valid IP address.' ), $value ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'number', 'integer' ), true ) && ( isset( $args['minimum'] ) || isset( $args['maximum'] ) ) ) {\n\t\tif ( isset( $args['minimum'] ) && ! isset( $args['maximum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && $value <= $args['minimum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: minimum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than %2$d' ), $param, $args['minimum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && $value < $args['minimum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: minimum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than or equal to %2$d' ), $param, $args['minimum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && ! isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMaximum'] ) && $value >= $args['maximum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: maximum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than %2$d' ), $param, $args['maximum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMaximum'] ) && $value > $args['maximum'] ) {\n\t\t\t\t/* translators: 1: parameter, 2: maximum number */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than or equal to %2$d' ), $param, $args['maximum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( ! empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: parameter, 2: minimum number, 3: maximum number */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Sanitize a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed $value The value to sanitize.\n * @param array $args  Schema array to use for sanitization.\n * @return true|WP_Error\n */\nfunction rest_sanitize_value_from_schema( $value, $args ) {\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( empty( $args['items'] ) ) {\n\t\t\treturn (array) $value;\n\t\t}\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t$value = preg_split( '/[\\s,]+/', $value );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$value[ $index ] = rest_sanitize_value_from_schema( $v, $args['items'] );\n\t\t}\n\t\t// Normalize to numeric array so nothing unexpected\n\t\t// is in the keys.\n\t\t$value = array_values( $value );\n\t\treturn $value;\n\t}\n\tif ( 'integer' === $args['type'] ) {\n\t\treturn (int) $value;\n\t}\n\n\tif ( 'number' === $args['type'] ) {\n\t\treturn (float) $value;\n\t}\n\n\tif ( 'boolean' === $args['type'] ) {\n\t\treturn rest_sanitize_boolean( $value );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time' :\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'email' :\n\t\t\t\t/*\n\t\t\t\t * sanitize_email() validates, which would be unexpected.\n\t\t\t\t */\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'uri' :\n\t\t\t\treturn esc_url_raw( $value );\n\n\t\t\tcase 'ip' :\n\t\t\t\treturn sanitize_text_field( $value );\n\t\t}\n\t}\n\n\tif ( 'string' === $args['type'] ) {\n\t\treturn strval( $value );\n\t}\n\n\treturn $value;\n}\n", "<?php\n/**\n * REST API: WP_REST_Comments_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core controller used to access comments via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Comments_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Instance of a comment meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Comment_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'comments';\n\n\t\t$this->meta = new WP_REST_Comment_Meta_Fields();\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'   => WP_REST_Server::READABLE,\n\t\t\t\t'callback'  => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'      => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback' => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'     => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'id' => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::READABLE,\n\t\t\t\t'callback' => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'context'          => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t\t'password' => array(\n\t\t\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback' => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'     => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback' => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Whether to bypass trash and force deletion.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'password' => array(\n\t\t\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read comments.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access, error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\n\t\tif ( ! empty( $request['post'] ) ) {\n\t\t\tforeach ( (array) $request['post'] as $post_id ) {\n\t\t\t\t$post = get_post( $post_id );\n\n\t\t\t\tif ( ! empty( $post_id ) && $post && ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t} elseif ( 0 === $post_id && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to read comments without a post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $request['context'] ) && 'edit' === $request['context'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit comments.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! current_user_can( 'edit_posts' ) ) {\n\t\t\t$protected_params = array( 'author', 'author_exclude', 'author_email', 'type', 'status' );\n\t\t\t$forbidden_params = array();\n\n\t\t\tforeach ( $protected_params as $param ) {\n\t\t\t\tif ( 'status' === $param ) {\n\t\t\t\t\tif ( 'approve' !== $request[ $param ] ) {\n\t\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t\t}\n\t\t\t\t} elseif ( 'type' === $param ) {\n\t\t\t\t\tif ( 'comment' !== $request[ $param ] ) {\n\t\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t\t}\n\t\t\t\t} elseif ( ! empty( $request[ $param ] ) ) {\n\t\t\t\t\t$forbidden_params[] = $param;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $forbidden_params ) ) {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_param', sprintf( __( 'Query parameter not permitted: %s' ), implode( ', ', $forbidden_params ) ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a list of comment items.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'author'         => 'author__in',\n\t\t\t'author_email'   => 'author_email',\n\t\t\t'author_exclude' => 'author__not_in',\n\t\t\t'exclude'        => 'comment__not_in',\n\t\t\t'include'        => 'comment__in',\n\t\t\t'offset'         => 'offset',\n\t\t\t'order'          => 'order',\n\t\t\t'parent'         => 'parent__in',\n\t\t\t'parent_exclude' => 'parent__not_in',\n\t\t\t'per_page'       => 'number',\n\t\t\t'post'           => 'post__in',\n\t\t\t'search'         => 'search',\n\t\t\t'status'         => 'status',\n\t\t\t'type'           => 'type',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\t// Ensure certain parameter values default to empty strings.\n\t\tforeach ( array( 'author_email', 'search' ) as $param ) {\n\t\t\tif ( ! isset( $prepared_args[ $param ] ) ) {\n\t\t\t\t$prepared_args[ $param ] = '';\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['orderby'] ) ) {\n\t\t\t$prepared_args['orderby'] = $this->normalize_query_param( $request['orderby'] );\n\t\t}\n\n\t\t$prepared_args['no_found_rows'] = false;\n\n\t\t$prepared_args['date_query'] = array();\n\n\t\t// Set before into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['before'], $request['before'] ) ) {\n\t\t\t$prepared_args['date_query'][0]['before'] = $request['before'];\n\t\t}\n\n\t\t// Set after into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['after'], $request['after'] ) ) {\n\t\t\t$prepared_args['date_query'][0]['after'] = $request['after'];\n\t\t}\n\n\t\tif ( isset( $registered['page'] ) && empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $prepared_args['number'] * ( absint( $request['page'] ) - 1 );\n\t\t}\n\n\t\t/**\n\t\t * Filters arguments, before passing to WP_Comment_Query, when querying comments via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_comment_query/\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments for WP_Comment_Query.\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( 'rest_comment_query', $prepared_args, $request );\n\n\t\t$query = new WP_Comment_Query;\n\t\t$query_result = $query->query( $prepared_args );\n\n\t\t$comments = array();\n\n\t\tforeach ( $query_result as $comment ) {\n\t\t\tif ( ! $this->check_read_permission( $comment, $request ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data = $this->prepare_item_for_response( $comment, $request );\n\t\t\t$comments[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$total_comments = (int) $query->found_comments;\n\t\t$max_pages      = (int) $query->max_num_pages;\n\n\t\tif ( $total_comments < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $prepared_args['number'], $prepared_args['offset'] );\n\n\t\t\t$query = new WP_Comment_Query;\n\t\t\t$prepared_args['count'] = true;\n\n\t\t\t$total_comments = $query->query( $prepared_args );\n\t\t\t$max_pages = ceil( $total_comments / $request['per_page'] );\n\t\t}\n\n\t\t$response = rest_ensure_response( $comments );\n\t\t$response->header( 'X-WP-Total', $total_comments );\n\t\t$response->header( 'X-WP-TotalPages', $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\n\t\tif ( $request['page'] > 1 ) {\n\t\t\t$prev_page = $request['page'] - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\n\t\tif ( $max_pages > $request['page'] ) {\n\t\t\t$next_page = $request['page'] + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Get the comment, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_Comment|WP_Error Comment object if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_comment( $id ) {\n\t\t$error = new WP_Error( 'rest_comment_invalid_id', __( 'Invalid comment ID.' ), array( 'status' => 404 ) );\n\t\tif ( (int) $id <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$id = (int) $id;\n\t\t$comment = get_comment( $id );\n\t\tif ( empty( $comment ) ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\tif ( ! empty( $comment->comment_post_ID ) ) {\n\t\t\t$post = get_post( (int) $comment->comment_post_ID );\n\t\t\tif ( empty( $post ) ) {\n\t\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\t\t}\n\t\t}\n\n\t\treturn $comment;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read the comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access for the item, error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\tif ( ! empty( $request['context'] ) && 'edit' === $request['context'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit comments.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$post = get_post( $comment->comment_post_ID );\n\n\t\tif ( ! $this->check_read_permission( $comment, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to read this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( $post && ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $comment, $request );\n\t\t$response = rest_ensure_response( $data );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to create a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to create items, error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\t\tif ( ! is_user_logged_in() ) {\n\t\t\tif ( get_option( 'comment_registration' ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_login_required', __( 'Sorry, you must be logged in to comment.' ), array( 'status' => 401 ) );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter whether comments can be created without authentication.\n\t\t\t *\n\t\t\t * Enables creating comments for anonymous users.\n\t\t\t *\n\t\t\t * @since 4.7.0\n\t\t\t *\n\t\t\t * @param bool $allow_anonymous Whether to allow anonymous comments to\n\t\t\t *                              be created. Default `false`.\n\t\t\t * @param WP_REST_Request $request Request used to generate the\n\t\t\t *                                 response.\n\t\t\t */\n\t\t\t$allow_anonymous = apply_filters( 'rest_allow_anonymous_comments', false, $request );\n\t\t\tif ( ! $allow_anonymous ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_login_required', __( 'Sorry, you must be logged in to comment.' ), array( 'status' => 401 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Limit who can set comment `author`, `author_ip` or `status` to anything other than the default.\n\t\tif ( isset( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_author',\n\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'author' ),\n\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t);\n\t\t}\n\n\t\tif ( isset( $request['author_ip'] ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\tif ( empty( $_SERVER['REMOTE_ADDR'] ) || $request['author_ip'] !== $_SERVER['REMOTE_ADDR'] ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_invalid_author_ip',\n\t\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'author_ip' ),\n\t\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $request['status'] ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_status',\n\t\t\t\t/* translators: %s: request parameter */\n\t\t\t\tsprintf( __( \"Sorry, you are not allowed to edit '%s' for comments.\" ), 'status' ),\n\t\t\t\tarray( 'status' => rest_authorization_required_code() )\n\t\t\t);\n\t\t}\n\n\t\tif ( empty( $request['post'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Sorry, you are not allowed to create this comment without a post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\t$post = get_post( (int) $request['post'] );\n\t\tif ( ! $post ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Sorry, you are not allowed to create this comment without a post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( 'draft' === $post->post_status ) {\n\t\t\treturn new WP_Error( 'rest_comment_draft_post', __( 'Sorry, you are not allowed to create a comment on this post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( 'trash' === $post->post_status ) {\n\t\t\treturn new WP_Error( 'rest_comment_trash_post', __( 'Sorry, you are not allowed to create a comment on this post.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\tif ( ! $this->check_read_post_permission( $post, $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_post', __( 'Sorry, you are not allowed to read the post for this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! comments_open( $post->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_closed', __( 'Sorry, comments are closed for this item.' ), array( 'status' => 403 ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_exists', __( 'Cannot create existing comment.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Do not allow comments to be created with a non-default type.\n\t\tif ( ! empty( $request['type'] ) && 'comment' !== $request['type'] ) {\n\t\t\treturn new WP_Error( 'rest_invalid_comment_type', __( 'Cannot create a comment with that type.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_comment = $this->prepare_item_for_database( $request );\n\t\tif ( is_wp_error( $prepared_comment ) ) {\n\t\t\treturn $prepared_comment;\n\t\t}\n\n\t\t$prepared_comment['comment_type'] = '';\n\n\t\t/*\n\t\t * Do not allow a comment to be created with missing or empty\n\t\t * comment_content. See wp_handle_comment_submission().\n\t\t */\n\t\tif ( empty( $prepared_comment['comment_content'] ) ) {\n\t\t\treturn new WP_Error( 'rest_comment_content_invalid', __( 'Invalid comment content.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Setting remaining values before wp_insert_comment so we can use wp_allow_comment().\n\t\tif ( ! isset( $prepared_comment['comment_date_gmt'] ) ) {\n\t\t\t$prepared_comment['comment_date_gmt'] = current_time( 'mysql', true );\n\t\t}\n\n\t\t// Set author data if the user's logged in.\n\t\t$missing_author = empty( $prepared_comment['user_id'] )\n\t\t\t&& empty( $prepared_comment['comment_author'] )\n\t\t\t&& empty( $prepared_comment['comment_author_email'] )\n\t\t\t&& empty( $prepared_comment['comment_author_url'] );\n\n\t\tif ( is_user_logged_in() && $missing_author ) {\n\t\t\t$user = wp_get_current_user();\n\n\t\t\t$prepared_comment['user_id'] = $user->ID;\n\t\t\t$prepared_comment['comment_author'] = $user->display_name;\n\t\t\t$prepared_comment['comment_author_email'] = $user->user_email;\n\t\t\t$prepared_comment['comment_author_url'] = $user->user_url;\n\t\t}\n\n\t\t// Honor the discussion setting that requires a name and email address of the comment author.\n\t\tif ( get_option( 'require_name_email' ) ) {\n\t\t\tif ( empty( $prepared_comment['comment_author'] ) || empty( $prepared_comment['comment_author_email'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_author_data_required', __( 'Creating a comment requires valid author name and email values.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_author_email'] ) ) {\n\t\t\t$prepared_comment['comment_author_email'] = '';\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_author_url'] ) ) {\n\t\t\t$prepared_comment['comment_author_url'] = '';\n\t\t}\n\n\t\tif ( ! isset( $prepared_comment['comment_agent'] ) ) {\n\t\t\t$prepared_comment['comment_agent'] = '';\n\t\t}\n\n\t\t$check_comment_lengths = wp_check_comment_data_max_lengths( $prepared_comment );\n\t\tif ( is_wp_error( $check_comment_lengths ) ) {\n\t\t\t$error_code = $check_comment_lengths->get_error_code();\n\t\t\treturn new WP_Error( $error_code, __( 'Comment field exceeds maximum length allowed.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_comment['comment_approved'] = wp_allow_comment( $prepared_comment, true );\n\n\t\tif ( is_wp_error( $prepared_comment['comment_approved'] ) ) {\n\t\t\t$error_code    = $prepared_comment['comment_approved']->get_error_code();\n\t\t\t$error_message = $prepared_comment['comment_approved']->get_error_message();\n\n\t\t\tif ( 'comment_duplicate' === $error_code ) {\n\t\t\t\treturn new WP_Error( $error_code, $error_message, array( 'status' => 409 ) );\n\t\t\t}\n\n\t\t\tif ( 'comment_flood' === $error_code ) {\n\t\t\t\treturn new WP_Error( $error_code, $error_message, array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\treturn $prepared_comment['comment_approved'];\n\t\t}\n\n\t\t/**\n\t\t * Filters a comment before it is inserted via the REST API.\n\t\t *\n\t\t * Allows modification of the comment right before it is inserted via wp_insert_comment().\n\t\t * Returning a WP_Error value from the filter will shortcircuit insertion and allow\n\t\t * skipping further processing.\n\t\t *\n\t\t * @since 4.7.0\n\t\t * @since 4.8.0 $prepared_comment can now be a WP_Error to shortcircuit insertion.\n\t\t *\n\t\t * @param array|WP_Error  $prepared_comment The prepared comment data for wp_insert_comment().\n\t\t * @param WP_REST_Request $request          Request used to insert the comment.\n\t\t */\n\t\t$prepared_comment = apply_filters( 'rest_pre_insert_comment', $prepared_comment, $request );\n\t\tif ( is_wp_error( $prepared_comment ) ) {\n\t\t\treturn $prepared_comment;\n\t\t}\n\n\t\t$comment_id = wp_insert_comment( wp_filter_comment( wp_slash( (array) $prepared_comment ) ) );\n\n\t\tif ( ! $comment_id ) {\n\t\t\treturn new WP_Error( 'rest_comment_failed_create', __( 'Creating comment failed.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\tif ( isset( $request['status'] ) ) {\n\t\t\t$this->handle_status_param( $request['status'], $comment_id );\n\t\t}\n\n\t\t$comment = get_comment( $comment_id );\n\n\t\t/**\n\t\t * Fires after a comment is created or updated via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Comment      $comment  Inserted or updated comment object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a comment, false\n\t\t *                                  when updating.\n\t\t */\n\t\tdo_action( 'rest_insert_comment', $comment, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $comment_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $comment, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$context = current_user_can( 'moderate_comments' ) ? 'edit' : 'view';\n\n\t\t$request->set_param( 'context', $context );\n\n\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment_id ) ) );\n\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given REST request has access to update a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to update the item, error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\tif ( ! $this->check_edit_permission( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\t$id = $comment->comment_ID;\n\n\t\tif ( isset( $request['type'] ) && get_comment_type( $id ) !== $request['type'] ) {\n\t\t\treturn new WP_Error( 'rest_comment_invalid_type', __( 'Sorry, you are not allowed to change the comment type.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$prepared_args = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $prepared_args ) ) {\n\t\t\treturn $prepared_args;\n\t\t}\n\n\t\tif ( ! empty( $prepared_args['comment_post_ID'] ) ) {\n\t\t\t$post = get_post( $prepared_args['comment_post_ID'] );\n\t\t\tif ( empty( $post ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_invalid_post_id', __( 'Invalid post ID.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $prepared_args ) && isset( $request['status'] ) ) {\n\t\t\t// Only the comment status is being changed.\n\t\t\t$change = $this->handle_status_param( $request['status'], $id );\n\n\t\t\tif ( ! $change ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_failed_edit', __( 'Updating comment status failed.' ), array( 'status' => 500 ) );\n\t\t\t}\n\t\t} elseif ( ! empty( $prepared_args ) ) {\n\t\t\tif ( is_wp_error( $prepared_args ) ) {\n\t\t\t\treturn $prepared_args;\n\t\t\t}\n\n\t\t\tif ( isset( $prepared_args['comment_content'] ) && empty( $prepared_args['comment_content'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_content_invalid', __( 'Invalid comment content.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$prepared_args['comment_ID'] = $id;\n\n\t\t\t$check_comment_lengths = wp_check_comment_data_max_lengths( $prepared_args );\n\t\t\tif ( is_wp_error( $check_comment_lengths ) ) {\n\t\t\t\t$error_code = $check_comment_lengths->get_error_code();\n\t\t\t\treturn new WP_Error( $error_code, __( 'Comment field exceeds maximum length allowed.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$updated = wp_update_comment( wp_slash( (array) $prepared_args ) );\n\n\t\t\tif ( false === $updated ) {\n\t\t\t\treturn new WP_Error( 'rest_comment_failed_edit', __( 'Updating comment failed.' ), array( 'status' => 500 ) );\n\t\t\t}\n\n\t\t\tif ( isset( $request['status'] ) ) {\n\t\t\t\t$this->handle_status_param( $request['status'], $id );\n\t\t\t}\n\t\t}\n\n\t\t$comment = get_comment( $id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-comments-controller.php */\n\t\tdo_action( 'rest_insert_comment', $comment, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $comment, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has access to delete the item, error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\tif ( ! $this->check_edit_permission( $comment ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this comment.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a comment.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$comment = $this->get_comment( $request['id'] );\n\t\tif ( is_wp_error( $comment ) ) {\n\t\t\treturn $comment;\n\t\t}\n\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t/**\n\t\t * Filters whether a comment can be trashed.\n\t\t *\n\t\t * Return false to disable trash support for the post.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param bool    $supports_trash Whether the post type support trashing.\n\t\t * @param WP_Post $comment        The comment object being considered for trashing support.\n\t\t */\n\t\t$supports_trash = apply_filters( 'rest_comment_trashable', ( EMPTY_TRASH_DAYS > 0 ), $comment );\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\tif ( $force ) {\n\t\t\t$previous = $this->prepare_item_for_response( $comment, $request );\n\t\t\t$result = wp_delete_comment( $comment->comment_ID, true );\n\t\t\t$response = new WP_REST_Response();\n\t\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\t} else {\n\t\t\t// If this type doesn't support trashing, error out.\n\t\t\tif ( ! $supports_trash ) {\n\t\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'The comment does not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t\t}\n\n\t\t\tif ( 'trash' === $comment->comment_approved ) {\n\t\t\t\treturn new WP_Error( 'rest_already_trashed', __( 'The comment has already been trashed.' ), array( 'status' => 410 ) );\n\t\t\t}\n\n\t\t\t$result = wp_trash_comment( $comment->comment_ID );\n\t\t\t$comment = get_comment( $comment->comment_ID );\n\t\t\t$response = $this->prepare_item_for_response( $comment, $request );\n\t\t}\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The comment cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t/**\n\t\t * Fires after a comment is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Comment       $comment  The deleted comment data.\n\t\t * @param WP_REST_Response $response The response returned from the API.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_comment', $comment, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares a single comment output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Comment      $comment Comment object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $comment, $request ) {\n\t\t$data = array(\n\t\t\t'id'                 => (int) $comment->comment_ID,\n\t\t\t'post'               => (int) $comment->comment_post_ID,\n\t\t\t'parent'             => (int) $comment->comment_parent,\n\t\t\t'author'             => (int) $comment->user_id,\n\t\t\t'author_name'        => $comment->comment_author,\n\t\t\t'author_email'       => $comment->comment_author_email,\n\t\t\t'author_url'         => $comment->comment_author_url,\n\t\t\t'author_ip'          => $comment->comment_author_IP,\n\t\t\t'author_user_agent'  => $comment->comment_agent,\n\t\t\t'date'               => mysql_to_rfc3339( $comment->comment_date ),\n\t\t\t'date_gmt'           => mysql_to_rfc3339( $comment->comment_date_gmt ),\n\t\t\t'content'            => array(\n\t\t\t\t/** This filter is documented in wp-includes/comment-template.php */\n\t\t\t\t'rendered' => apply_filters( 'comment_text', $comment->comment_content, $comment ),\n\t\t\t\t'raw'      => $comment->comment_content,\n\t\t\t),\n\t\t\t'link'               => get_comment_link( $comment ),\n\t\t\t'status'             => $this->prepare_status_response( $comment->comment_approved ),\n\t\t\t'type'               => get_comment_type( $comment->comment_ID ),\n\t\t);\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['author_avatar_urls'] ) ) {\n\t\t\t$data['author_avatar_urls'] = rest_get_avatar_urls( $comment->comment_author_email );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $comment->comment_ID, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $comment ) );\n\n\t\t/**\n\t\t * Filters a comment returned from the API.\n\t\t *\n\t\t * Allows modification of the comment right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response  $response The response object.\n\t\t * @param WP_Comment        $comment  The original comment object.\n\t\t * @param WP_REST_Request   $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_comment', $response, $comment, $request );\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Comment $comment Comment object.\n\t * @return array Links for the given comment.\n\t */\n\tprotected function prepare_links( $comment ) {\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment->comment_ID ) ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t);\n\n\t\tif ( 0 !== (int) $comment->user_id ) {\n\t\t\t$links['author'] = array(\n\t\t\t\t'href'       => rest_url( 'wp/v2/users/' . $comment->user_id ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( 0 !== (int) $comment->comment_post_ID ) {\n\t\t\t$post = get_post( $comment->comment_post_ID );\n\n\t\t\tif ( ! empty( $post->ID ) ) {\n\t\t\t\t$obj = get_post_type_object( $post->post_type );\n\t\t\t\t$base = ! empty( $obj->rest_base ) ? $obj->rest_base : $obj->name;\n\n\t\t\t\t$links['up'] = array(\n\t\t\t\t\t'href'       => rest_url( 'wp/v2/' . $base . '/' . $comment->comment_post_ID ),\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t\t'post_type'  => $post->post_type,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( 0 !== (int) $comment->comment_parent ) {\n\t\t\t$links['in-reply-to'] = array(\n\t\t\t\t'href'       => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $comment->comment_parent ) ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\t// Only grab one comment to verify the comment has children.\n\t\t$comment_children = $comment->get_children( array(\n\t\t\t'number' => 1,\n\t\t\t'count'  => true\n\t\t) );\n\n\t\tif ( ! empty( $comment_children ) ) {\n\t\t\t$args = array(\n\t\t\t\t'parent' => $comment->comment_ID\n\t\t\t);\n\n\t\t\t$rest_url = add_query_arg( $args, rest_url( $this->namespace . '/' . $this->rest_base ) );\n\n\t\t\t$links['children'] = array(\n\t\t\t\t'href' => $rest_url,\n\t\t\t);\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Prepends internal property prefix to query parameters to match our response fields.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $query_param Query parameter.\n\t * @return string The normalized query parameter.\n\t */\n\tprotected function normalize_query_param( $query_param ) {\n\t\t$prefix = 'comment_';\n\n\t\tswitch ( $query_param ) {\n\t\t\tcase 'id':\n\t\t\t\t$normalized = $prefix . 'ID';\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\t$normalized = $prefix . 'post_ID';\n\t\t\t\tbreak;\n\t\t\tcase 'parent':\n\t\t\t\t$normalized = $prefix . 'parent';\n\t\t\t\tbreak;\n\t\t\tcase 'include':\n\t\t\t\t$normalized = 'comment__in';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$normalized = $prefix . $query_param;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $normalized;\n\t}\n\n\t/**\n\t * Checks comment_approved to set comment status for single comment output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string|int $comment_approved comment status.\n\t * @return string Comment status.\n\t */\n\tprotected function prepare_status_response( $comment_approved ) {\n\n\t\tswitch ( $comment_approved ) {\n\t\t\tcase 'hold':\n\t\t\tcase '0':\n\t\t\t\t$status = 'hold';\n\t\t\t\tbreak;\n\n\t\t\tcase 'approve':\n\t\t\tcase '1':\n\t\t\t\t$status = 'approved';\n\t\t\t\tbreak;\n\n\t\t\tcase 'spam':\n\t\t\tcase 'trash':\n\t\t\tdefault:\n\t\t\t\t$status = $comment_approved;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Prepares a single comment to be inserted into the database.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return array|WP_Error Prepared comment, otherwise WP_Error object.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_comment = array();\n\n\t\t/*\n\t\t * Allow the comment_content to be set via the 'content' or\n\t\t * the 'content.raw' properties of the Request object.\n\t\t */\n\t\tif ( isset( $request['content'] ) && is_string( $request['content'] ) ) {\n\t\t\t$prepared_comment['comment_content'] = $request['content'];\n\t\t} elseif ( isset( $request['content']['raw'] ) && is_string( $request['content']['raw'] ) ) {\n\t\t\t$prepared_comment['comment_content'] = $request['content']['raw'];\n\t\t}\n\n\t\tif ( isset( $request['post'] ) ) {\n\t\t\t$prepared_comment['comment_post_ID'] = (int) $request['post'];\n\t\t}\n\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\t$prepared_comment['comment_parent'] = $request['parent'];\n\t\t}\n\n\t\tif ( isset( $request['author'] ) ) {\n\t\t\t$user = new WP_User( $request['author'] );\n\n\t\t\tif ( $user->exists() ) {\n\t\t\t\t$prepared_comment['user_id'] = $user->ID;\n\t\t\t\t$prepared_comment['comment_author'] = $user->display_name;\n\t\t\t\t$prepared_comment['comment_author_email'] = $user->user_email;\n\t\t\t\t$prepared_comment['comment_author_url'] = $user->user_url;\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_comment_author_invalid', __( 'Invalid comment author ID.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $request['author_name'] ) ) {\n\t\t\t$prepared_comment['comment_author'] = $request['author_name'];\n\t\t}\n\n\t\tif ( isset( $request['author_email'] ) ) {\n\t\t\t$prepared_comment['comment_author_email'] = $request['author_email'];\n\t\t}\n\n\t\tif ( isset( $request['author_url'] ) ) {\n\t\t\t$prepared_comment['comment_author_url'] = $request['author_url'];\n\t\t}\n\n\t\tif ( isset( $request['author_ip'] ) && current_user_can( 'moderate_comments' ) ) {\n\t\t\t$prepared_comment['comment_author_IP'] = $request['author_ip'];\n\t\t} elseif ( ! empty( $_SERVER['REMOTE_ADDR'] ) && rest_is_ip_address( $_SERVER['REMOTE_ADDR'] ) ) {\n\t\t\t$prepared_comment['comment_author_IP'] = $_SERVER['REMOTE_ADDR'];\n\t\t} else {\n\t\t\t$prepared_comment['comment_author_IP'] = '127.0.0.1';\n\t\t}\n\n\t\tif ( ! empty( $request['author_user_agent'] ) ) {\n\t\t\t$prepared_comment['comment_agent'] = $request['author_user_agent'];\n\t\t} elseif ( $request->get_header( 'user_agent' ) ) {\n\t\t\t$prepared_comment['comment_agent'] = $request->get_header( 'user_agent' );\n\t\t}\n\n\t\tif ( ! empty( $request['date'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date'] );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_comment['comment_date'], $prepared_comment['comment_date_gmt'] ) = $date_data;\n\t\t\t}\n\t\t} elseif ( ! empty( $request['date_gmt'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date_gmt'], true );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_comment['comment_date'], $prepared_comment['comment_date_gmt'] ) = $date_data;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters a comment after it is prepared for the database.\n\t\t *\n\t\t * Allows modification of the comment right after it is prepared for the database.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array           $prepared_comment The prepared comment data for `wp_insert_comment`.\n\t\t * @param WP_REST_Request $request          The current request.\n\t\t */\n\t\treturn apply_filters( 'rest_preprocess_comment', $prepared_comment, $request );\n\t}\n\n\t/**\n\t * Retrieves the comment's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'comment',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'id'               => array(\n\t\t\t\t\t'description'  => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'author'           => array(\n\t\t\t\t\t'description'  => __( 'The ID of the user object, if author was a user.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'author_email'     => array(\n\t\t\t\t\t'description'  => __( 'Email address for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'email',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_comment_author_email' ),\n\t\t\t\t\t\t'validate_callback' => null, // skip built-in validation of 'email'.\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'author_ip'     => array(\n\t\t\t\t\t'description'  => __( 'IP address for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'ip',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'author_name'     => array(\n\t\t\t\t\t'description'  => __( 'Display name for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'author_url'       => array(\n\t\t\t\t\t'description'  => __( 'URL for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'author_user_agent'     => array(\n\t\t\t\t\t'description'  => __( 'User agent for the object author.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'content'          => array(\n\t\t\t\t\t'description'     => __( 'The content for the object.' ),\n\t\t\t\t\t'type'            => 'object',\n\t\t\t\t\t'context'         => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options'     => array(\n\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t),\n\t\t\t\t\t'properties'      => array(\n\t\t\t\t\t\t'raw'         => array(\n\t\t\t\t\t\t\t'description'     => __( 'Content for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t'type'            => 'string',\n\t\t\t\t\t\t\t'context'         => array( 'edit' ),\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'rendered'    => array(\n\t\t\t\t\t\t\t'description'     => __( 'HTML content for the object, transformed for display.' ),\n\t\t\t\t\t\t\t'type'            => 'string',\n\t\t\t\t\t\t\t'context'         => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t'readonly'        => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'date'             => array(\n\t\t\t\t\t'description'  => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'date-time',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'         => array(\n\t\t\t\t\t'description'  => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'date-time',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'             => array(\n\t\t\t\t\t'description'  => __( 'URL to the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'parent'           => array(\n\t\t\t\t\t'description'  => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'default'      => 0,\n\t\t\t\t),\n\t\t\t\t'post'             => array(\n\t\t\t\t\t'description'  => __( 'The ID of the associated post object.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'default'      => 0,\n\t\t\t\t),\n\t\t\t\t'status'           => array(\n\t\t\t\t\t'description'  => __( 'State of the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'type'             => array(\n\t\t\t\t\t'description'  => __( 'Type of Comment for the object.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif ( get_option( 'show_avatars' ) ) {\n\t\t\t$avatar_properties = array();\n\n\t\t\t$avatar_sizes = rest_get_avatar_sizes();\n\t\t\tforeach ( $avatar_sizes as $size ) {\n\t\t\t\t$avatar_properties[ $size ] = array(\n\t\t\t\t\t/* translators: %d: avatar image size in pixels */\n\t\t\t\t\t'description' => sprintf( __( 'Avatar URL with image size of %d pixels.' ), $size ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$schema['properties']['author_avatar_urls'] = array(\n\t\t\t\t'description'   => __( 'Avatar URLs for the object author.' ),\n\t\t\t\t'type'          => 'object',\n\t\t\t\t'context'       => array( 'view', 'edit', 'embed' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'properties'    => $avatar_properties,\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Comments collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['after'] = array(\n\t\t\t'description'       => __( 'Limit response to comments published after a given ISO8601 compliant date.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'format'            => 'date-time',\n\t\t);\n\n\t\t$query_params['author'] = array(\n\t\t\t'description'       => __( 'Limit result set to comments assigned to specific user IDs. Requires authorization.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['author_exclude'] = array(\n\t\t\t'description'       => __( 'Ensure result set excludes comments assigned to specific user IDs. Requires authorization.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['author_email'] = array(\n\t\t\t'default'           => null,\n\t\t\t'description'       => __( 'Limit result set to that from a specific author email. Requires authorization.' ),\n\t\t\t'format'            => 'email',\n\t\t\t'type'              => 'string',\n\t\t);\n\n\t\t$query_params['before'] = array(\n\t\t\t'description'       => __( 'Limit response to comments published before a given ISO8601 compliant date.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'format'            => 'date-time',\n\t\t);\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order']      = array(\n\t\t\t'description'           => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'                  => 'string',\n\t\t\t'default'               => 'desc',\n\t\t\t'enum'                  => array(\n\t\t\t\t'asc',\n\t\t\t\t'desc',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['orderby']    = array(\n\t\t\t'description'           => __( 'Sort collection by object attribute.' ),\n\t\t\t'type'                  => 'string',\n\t\t\t'default'               => 'date_gmt',\n\t\t\t'enum'                  => array(\n\t\t\t\t'date',\n\t\t\t\t'date_gmt',\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'post',\n\t\t\t\t'parent',\n\t\t\t\t'type',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['parent'] = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Limit result set to comments of specific parent IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['parent_exclude'] = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Ensure result set excludes specific parent IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['post']   = array(\n\t\t\t'default'           => array(),\n\t\t\t'description'       => __( 'Limit result set to comments assigned to specific post IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['status'] = array(\n\t\t\t'default'           => 'approve',\n\t\t\t'description'       => __( 'Limit result set to comments assigned a specific status. Requires authorization.' ),\n\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t'type'              => 'string',\n\t\t\t'validate_callback' => 'rest_validate_request_arg',\n\t\t);\n\n\t\t$query_params['type'] = array(\n\t\t\t'default'           => 'comment',\n\t\t\t'description'       => __( 'Limit result set to comments assigned a specific type. Requires authorization.' ),\n\t\t\t'sanitize_callback' => 'sanitize_key',\n\t\t\t'type'              => 'string',\n\t\t\t'validate_callback' => 'rest_validate_request_arg',\n\t\t);\n\n\t\t$query_params['password'] = array(\n\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t'type'        => 'string',\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the comments controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Comment_Query parameter. Use the\n\t\t * `rest_comment_query` filter to set WP_Comment_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array $query_params JSON Schema-formatted collection parameters.\n\t\t */\n\t\treturn apply_filters( 'rest_comment_collection_params', $query_params );\n\t}\n\n\t/**\n\t * Sets the comment_status of a given comment object when creating or updating a comment.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string|int $new_status New comment status.\n\t * @param int        $comment_id Comment ID.\n\t * @return bool Whether the status was changed.\n\t */\n\tprotected function handle_status_param( $new_status, $comment_id ) {\n\t\t$old_status = wp_get_comment_status( $comment_id );\n\n\t\tif ( $new_status === $old_status ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch ( $new_status ) {\n\t\t\tcase 'approved' :\n\t\t\tcase 'approve':\n\t\t\tcase '1':\n\t\t\t\t$changed = wp_set_comment_status( $comment_id, 'approve' );\n\t\t\t\tbreak;\n\t\t\tcase 'hold':\n\t\t\tcase '0':\n\t\t\t\t$changed = wp_set_comment_status( $comment_id, 'hold' );\n\t\t\t\tbreak;\n\t\t\tcase 'spam' :\n\t\t\t\t$changed = wp_spam_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'unspam' :\n\t\t\t\t$changed = wp_unspam_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'trash' :\n\t\t\t\t$changed = wp_trash_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tcase 'untrash' :\n\t\t\t\t$changed = wp_untrash_comment( $comment_id );\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\t$changed = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $changed;\n\t}\n\n\t/**\n\t * Checks if the post can be read.\n\t *\n\t * Correctly handles posts with the inherit status.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post         $post    Post object.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool Whether post can be read.\n\t */\n\tprotected function check_read_post_permission( $post, $request ) {\n\t\t$posts_controller = new WP_REST_Posts_Controller( $post->post_type );\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\t$has_password_filter = false;\n\n\t\t// Only check password if a specific post was queried for or a single comment\n\t\t$requested_post = ! empty( $request['post'] ) && 1 === count( $request['post'] );\n\t\t$requested_comment = ! empty( $request['id'] );\n\t\tif ( ( $requested_post || $requested_comment ) && $posts_controller->can_access_password_content( $post, $request ) ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\n\t\t\t$has_password_filter = true;\n\t\t}\n\n\t\tif ( post_password_required( $post ) ) {\n\t\t\t$result = current_user_can( $post_type->cap->edit_post, $post->ID );\n\t\t} else {\n\t\t\t$result = $posts_controller->check_read_permission( $post );\n\t\t}\n\n\t\tif ( $has_password_filter ) {\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Checks if the comment can be read.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Comment      $comment Comment object.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool Whether the comment can be read.\n\t */\n\tprotected function check_read_permission( $comment, $request ) {\n\t\tif ( ! empty( $comment->comment_post_ID ) ) {\n\t\t\t$post = get_post( $comment->comment_post_ID );\n\t\t\tif ( $post ) {\n\t\t\t\tif ( $this->check_read_post_permission( $post, $request ) && 1 === (int) $comment->comment_approved ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( 0 === get_current_user_id() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $comment->comment_post_ID ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! empty( $comment->user_id ) && get_current_user_id() === (int) $comment->user_id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn current_user_can( 'edit_comment', $comment->comment_ID );\n\t}\n\n\t/**\n\t * Checks if a comment can be edited or deleted.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $comment Comment object.\n\t * @return bool Whether the comment can be edited or deleted.\n\t */\n\tprotected function check_edit_permission( $comment ) {\n\t\tif ( 0 === (int) get_current_user_id() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! current_user_can( 'moderate_comments' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( 'edit_comment', $comment->comment_ID );\n\t}\n\n\t/**\n\t * Checks a comment author email for validity.\n\t *\n\t * Accepts either a valid email address or empty string as a valid comment\n\t * author email address. Setting the comment author email to an empty\n\t * string is allowed when a comment is being updated.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string          $value   Author email value submitted.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @param string          $param   The parameter name.\n\t * @return WP_Error|string The sanitized email address, if valid,\n\t *                         otherwise an error.\n\t */\n\tpublic function check_comment_author_email( $value, $request, $param ) {\n\t\t$email = (string) $value;\n\t\tif ( empty( $email ) ) {\n\t\t\treturn $email;\n\t\t}\n\n\t\t$check_email = rest_validate_request_arg( $email, $request, $param );\n\t\tif ( is_wp_error( $check_email ) ) {\n\t\t\treturn $check_email;\n\t\t}\n\n\t\treturn $email;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Post_Statuses_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to access post statuses via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Post_Statuses_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'statuses';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<status>[\\w-]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'status' => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the status.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read post statuses.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'objects' );\n\n\t\t\tforeach ( $types as $type ) {\n\t\t\t\tif ( current_user_can( $type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all post statuses, depending on user context.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$data = array();\n\t\t$statuses = get_post_stati( array( 'internal' => false ), 'object' );\n\t\t$statuses['trash'] = get_post_status_object( 'trash' );\n\n\t\tforeach ( $statuses as $slug => $obj ) {\n\t\t\t$ret = $this->check_read_permission( $obj );\n\n\t\t\tif ( ! $ret ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$status = $this->prepare_item_for_response( $obj, $request );\n\t\t\t$data[ $obj->name ] = $this->prepare_response_for_collection( $status );\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a post status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|bool True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$status = get_post_status_object( $request['status'] );\n\n\t\tif ( empty( $status ) ) {\n\t\t\treturn new WP_Error( 'rest_status_invalid', __( 'Invalid status.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$check = $this->check_read_permission( $status );\n\n\t\tif ( ! $check ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_status', __( 'Cannot view status.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether a given post status should be visible.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $status Post status.\n\t * @return bool True if the post status is visible, otherwise false.\n\t */\n\tprotected function check_read_permission( $status ) {\n\t\tif ( true === $status->public ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( false === $status->internal || 'trash' === $status->name ) {\n\t\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'objects' );\n\n\t\t\tforeach ( $types as $type ) {\n\t\t\t\tif ( current_user_can( $type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves a specific post status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$obj = get_post_status_object( $request['status'] );\n\n\t\tif ( empty( $obj ) ) {\n\t\t\treturn new WP_Error( 'rest_status_invalid', __( 'Invalid status.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $obj, $request );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a post status object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $status  Post status data.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response Post status data.\n\t */\n\tpublic function prepare_item_for_response( $status, $request ) {\n\n\t\t$data = array(\n\t\t\t'name'         => $status->label,\n\t\t\t'private'      => (bool) $status->private,\n\t\t\t'protected'    => (bool) $status->protected,\n\t\t\t'public'       => (bool) $status->public,\n\t\t\t'queryable'    => (bool) $status->publicly_queryable,\n\t\t\t'show_in_list' => (bool) $status->show_in_admin_all_list,\n\t\t\t'slug'         => $status->name,\n\t\t);\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( 'publish' === $status->name ) {\n\t\t\t$response->add_link( 'archives', rest_url( 'wp/v2/posts' ) );\n\t\t} else {\n\t\t\t$response->add_link( 'archives', add_query_arg( 'status', $status->name, rest_url( 'wp/v2/posts' ) ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters a status returned from the REST API.\n\t\t *\n\t\t * Allows modification of the status data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $status   The original status object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_status', $response, $status, $request );\n\t}\n\n\t/**\n\t * Retrieves the post status' schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'status',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the status.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'private'          => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be private.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'protected'        => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be protected.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'public'           => array(\n\t\t\t\t\t'description'  => __( 'Whether posts of this status should be shown in the front end of the site.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'queryable'        => array(\n\t\t\t\t\t'description'  => __( 'Whether posts with this status should be publicly-queryable.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'show_in_list'     => array(\n\t\t\t\t\t'description'  => __( 'Whether to include posts in the edit listing for their post type.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the status.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Post_Types_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class to access post types via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Post_Types_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'types';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<type>[\\w-]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'type' => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the post type.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'  => WP_REST_Server::READABLE,\n\t\t\t\t'callback' => array( $this, 'get_item' ),\n\t\t\t\t'args'     => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read types.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|true True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tforeach ( get_post_types( array(), 'object' ) as $post_type ) {\n\t\t\t\tif ( ! empty( $post_type->show_in_rest ) && current_user_can( $post_type->cap->edit_posts ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all public post types.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$data = array();\n\n\t\tforeach ( get_post_types( array(), 'object' ) as $obj ) {\n\t\t\tif ( empty( $obj->show_in_rest ) || ( 'edit' === $request['context'] && ! current_user_can( $obj->cap->edit_posts ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$post_type = $this->prepare_item_for_response( $obj, $request );\n\t\t\t$data[ $obj->name ] = $this->prepare_response_for_collection( $post_type );\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Retrieves a specific post type.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_Error|WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$obj = get_post_type_object( $request['type'] );\n\n\t\tif ( empty( $obj ) ) {\n\t\t\treturn new WP_Error( 'rest_type_invalid', __( 'Invalid post type.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( empty( $obj->show_in_rest ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read_type', __( 'Cannot view post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $obj->cap->edit_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$data = $this->prepare_item_for_response( $obj, $request );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a post type object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $post_type Post type data.\n\t * @param WP_REST_Request $request   Full details about the request.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post_type, $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $post_type->name, 'objects' ), array( 'show_in_rest' => true ) );\n\t\t$taxonomies = wp_list_pluck( $taxonomies, 'name' );\n\t\t$base = ! empty( $post_type->rest_base ) ? $post_type->rest_base : $post_type->name;\n\t\t$supports = get_all_post_type_supports( $post_type->name );\n\n\t\t$data = array(\n\t\t\t'capabilities' => $post_type->cap,\n\t\t\t'description'  => $post_type->description,\n\t\t\t'hierarchical' => $post_type->hierarchical,\n\t\t\t'labels'       => $post_type->labels,\n\t\t\t'name'         => $post_type->label,\n\t\t\t'slug'         => $post_type->name,\n\t\t\t'supports'     => $supports,\n\t\t\t'taxonomies'   => array_values( $taxonomies ),\n\t\t\t'rest_base'    => $base,\n\t\t);\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( array(\n\t\t\t'collection' => array(\n\t\t\t\t'href'   => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t\t'https://api.w.org/items' => array(\n\t\t\t\t'href' => rest_url( sprintf( 'wp/v2/%s', $base ) ),\n\t\t\t),\n\t\t) );\n\n\t\t/**\n\t\t * Filters a post type returned from the API.\n\t\t *\n\t\t * Allows modification of the post type data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $item     The original post type object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_post_type', $response, $post_type, $request );\n\t}\n\n\t/**\n\t * Retrieves the post type's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'type',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'capabilities'     => array(\n\t\t\t\t\t'description'  => __( 'All capabilities used by the post type.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description'      => array(\n\t\t\t\t\t'description'  => __( 'A human-readable description of the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'hierarchical'     => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the post type should have children.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'labels'           => array(\n\t\t\t\t\t'description'  => __( 'Human-readable labels for the post type for various contexts.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'supports'         => array(\n\t\t\t\t\t'description'  => __( 'All features, supported by the post type.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'taxonomies'       => array(\n\t\t\t\t\t'description'  => __( 'Taxonomies associated with post type.' ),\n\t\t\t\t\t'type'         => 'array',\n\t\t\t\t\t'items'        => array(\n\t\t\t\t\t\t'type' => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'rest_base'            => array(\n\t\t\t\t\t'description'  => __( 'REST base route for the post type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Posts_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class to access posts via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Posts_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Post type.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $post_type;\n\n\t/**\n\t * Instance of a post meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Post_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $post_type Post type.\n\t */\n\tpublic function __construct( $post_type ) {\n\t\t$this->post_type = $post_type;\n\t\t$this->namespace = 'wp/v2';\n\t\t$obj = get_post_type_object( $post_type );\n\t\t$this->rest_base = ! empty( $obj->rest_base ) ? $obj->rest_base : $obj->name;\n\n\t\t$this->meta = new WP_REST_Post_Meta_Fields( $this->post_type );\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\t$schema = $this->get_item_schema();\n\t\t$get_item_args = array(\n\t\t\t'context'  => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t\tif ( isset( $schema['properties']['password'] ) ) {\n\t\t\t$get_item_args['password'] = array(\n\t\t\t\t'description' => __( 'The password for the post if it is password protected.' ),\n\t\t\t\t'type'        => 'string',\n\t\t\t);\n\t\t}\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'id' => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => $get_item_args,\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Whether to bypass trash and force deletion.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a given request has access to read posts.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $post_type->cap->edit_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a collection of posts.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Ensure a search string is set in case the orderby is set to 'relevance'.\n\t\tif ( ! empty( $request['orderby'] ) && 'relevance' === $request['orderby'] && empty( $request['search'] ) ) {\n\t\t\treturn new WP_Error( 'rest_no_search_term_defined', __( 'You need to define a search term to order by relevance.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Ensure an include parameter is set in case the orderby is set to 'include'.\n\t\tif ( ! empty( $request['orderby'] ) && 'include' === $request['orderby'] && empty( $request['include'] ) ) {\n\t\t\treturn new WP_Error( 'rest_orderby_include_missing_include', sprintf( __( 'Missing parameter(s): %s' ), 'include' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\t\t$args = array();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'author'         => 'author__in',\n\t\t\t'author_exclude' => 'author__not_in',\n\t\t\t'exclude'        => 'post__not_in',\n\t\t\t'include'        => 'post__in',\n\t\t\t'menu_order'     => 'menu_order',\n\t\t\t'offset'         => 'offset',\n\t\t\t'order'          => 'order',\n\t\t\t'orderby'        => 'orderby',\n\t\t\t'page'           => 'paged',\n\t\t\t'parent'         => 'post_parent__in',\n\t\t\t'parent_exclude' => 'post_parent__not_in',\n\t\t\t'search'         => 's',\n\t\t\t'slug'           => 'post_name__in',\n\t\t\t'status'         => 'post_status',\n\t\t);\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\t// Check for & assign any parameters which require special handling or setting.\n\t\t$args['date_query'] = array();\n\n\t\t// Set before into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['before'], $request['before'] ) ) {\n\t\t\t$args['date_query'][0]['before'] = $request['before'];\n\t\t}\n\n\t\t// Set after into date query. Date query must be specified as an array of an array.\n\t\tif ( isset( $registered['after'], $request['after'] ) ) {\n\t\t\t$args['date_query'][0]['after'] = $request['after'];\n\t\t}\n\n\t\t// Ensure our per_page parameter overrides any provided posts_per_page filter.\n\t\tif ( isset( $registered['per_page'] ) ) {\n\t\t\t$args['posts_per_page'] = $request['per_page'];\n\t\t}\n\n\t\tif ( isset( $registered['sticky'], $request['sticky'] ) ) {\n\t\t\t$sticky_posts = get_option( 'sticky_posts', array() );\n\t\t\tif ( $sticky_posts && $request['sticky'] ) {\n\t\t\t\t/*\n\t\t\t\t * As post__in will be used to only get sticky posts,\n\t\t\t\t * we have to support the case where post__in was already\n\t\t\t\t * specified.\n\t\t\t\t */\n\t\t\t\t$args['post__in'] = $args['post__in'] ? array_intersect( $sticky_posts, $args['post__in'] ) : $sticky_posts;\n\n\t\t\t\t/*\n\t\t\t\t * If we intersected, but there are no post ids in common,\n\t\t\t\t * WP_Query won't return \"no posts\" for post__in = array()\n\t\t\t\t * so we have to fake it a bit.\n\t\t\t\t */\n\t\t\t\tif ( ! $args['post__in'] ) {\n\t\t\t\t\t$args['post__in'] = array( -1 );\n\t\t\t\t}\n\t\t\t} elseif ( $sticky_posts ) {\n\t\t\t\t/*\n\t\t\t\t * As post___not_in will be used to only get posts that\n\t\t\t\t * are not sticky, we have to support the case where post__not_in\n\t\t\t\t * was already specified.\n\t\t\t\t */\n\t\t\t\t$args['post__not_in'] = array_merge( $args['post__not_in'], $sticky_posts );\n\t\t\t}\n\t\t}\n\n\t\t// Force the post_type argument, since it's not a user input variable.\n\t\t$args['post_type'] = $this->post_type;\n\n\t\t/**\n\t\t * Filters the query arguments for a request.\n\t\t *\n\t\t * Enables adding extra arguments or setting defaults for a post collection request.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_query/\n\t\t *\n\t\t * @param array           $args    Key value array of query var to query value.\n\t\t * @param WP_REST_Request $request The request used.\n\t\t */\n\t\t$args = apply_filters( \"rest_{$this->post_type}_query\", $args, $request );\n\t\t$query_args = $this->prepare_items_query( $args, $request );\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t\t$tax_exclude = $base . '_exclude';\n\n\t\t\tif ( ! empty( $request[ $base ] ) ) {\n\t\t\t\t$query_args['tax_query'][] = array(\n\t\t\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'terms'            => $request[ $base ],\n\t\t\t\t\t'include_children' => false,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $request[ $tax_exclude ] ) ) {\n\t\t\t\t$query_args['tax_query'][] = array(\n\t\t\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'terms'            => $request[ $tax_exclude ],\n\t\t\t\t\t'include_children' => false,\n\t\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$posts_query  = new WP_Query();\n\t\t$query_result = $posts_query->query( $query_args );\n\n\t\t// Allow access to all password protected posts if the context is edit.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\t$posts = array();\n\n\t\tforeach ( $query_result as $post ) {\n\t\t\tif ( ! $this->check_read_permission( $post ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data    = $this->prepare_item_for_response( $post, $request );\n\t\t\t$posts[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t// Reset filter.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\t$page = (int) $query_args['paged'];\n\t\t$total_posts = $posts_query->found_posts;\n\n\t\tif ( $total_posts < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $query_args['paged'] );\n\n\t\t\t$count_query = new WP_Query();\n\t\t\t$count_query->query( $query_args );\n\t\t\t$total_posts = $count_query->found_posts;\n\t\t}\n\n\t\t$max_pages = ceil( $total_posts / (int) $posts_query->query_vars['posts_per_page'] );\n\t\t$response  = rest_ensure_response( $posts );\n\n\t\t$response->header( 'X-WP-Total', (int) $total_posts );\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$request_params = $request->get_query_params();\n\t\t$base = add_query_arg( $request_params, rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Get the post, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_Post|WP_Error Post object if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_post( $id ) {\n\t\t$error = new WP_Error( 'rest_post_invalid_id', __( 'Invalid post ID.' ), array( 'status' => 404 ) );\n\t\tif ( (int) $id <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$post = get_post( (int) $id );\n\t\tif ( empty( $post ) || empty( $post->ID ) || $this->post_type !== $post->post_type ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\treturn $post;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$post = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && $post && ! $this->check_update_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( $post && ! empty( $request['password'] ) ) {\n\t\t\t// Check post password, and return error if invalid.\n\t\t\tif ( ! hash_equals( $post->post_password, $request['password'] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_post_incorrect_password', __( 'Incorrect post password.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Allow access to all password protected posts if the context is edit.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\tif ( $post ) {\n\t\t\treturn $this->check_read_permission( $post );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the user can access password-protected content.\n\t *\n\t * This method determines whether we need to override the regular password\n\t * check in core with a filter.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post to check against.\n\t * @param WP_REST_Request $request Request data to check.\n\t * @return bool True if the user can access password-protected content, otherwise false.\n\t */\n\tpublic function can_access_password_content( $post, $request ) {\n\t\tif ( empty( $post->post_password ) ) {\n\t\t\t// No filter required.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Edit context always gets access to password-protected posts.\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// No password, no auth.\n\t\tif ( empty( $request['password'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Double-check the request password.\n\t\treturn hash_equals( $post->post_password, $request['password'] );\n\t}\n\n\t/**\n\t * Retrieves a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$post = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\t$data     = $this->prepare_item_for_response( $post, $request );\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( is_post_type_viewable( get_post_type_object( $post->post_type ) ) ) {\n\t\t\t$response->link_header( 'alternate',  get_permalink( $post->ID ), array( 'type' => 'text/html' ) );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to create a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to create items, WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_post_exists', __( 'Cannot create existing post.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( ! empty( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to create posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['sticky'] ) && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! current_user_can( $post_type->cap->create_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create', __( 'Sorry, you are not allowed to create posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! $this->check_assign_terms_permission( $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_post_exists', __( 'Cannot create existing post.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$prepared_post = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $prepared_post ) ) {\n\t\t\treturn $prepared_post;\n\t\t}\n\n\t\t$prepared_post->post_type = $this->post_type;\n\n\t\t$post_id = wp_insert_post( wp_slash( (array) $prepared_post ), true );\n\n\t\tif ( is_wp_error( $post_id ) ) {\n\n\t\t\tif ( 'db_insert_error' === $post_id->get_error_code() ) {\n\t\t\t\t$post_id->add_data( array( 'status' => 500 ) );\n\t\t\t} else {\n\t\t\t\t$post_id->add_data( array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\treturn $post_id;\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\n\t\t/**\n\t\t * Fires after a single post is created or updated via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Post         $post     Inserted or updated post object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a post, false when updating.\n\t\t */\n\t\tdo_action( \"rest_insert_{$this->post_type}\", $post, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) ) {\n\t\t\tif ( ! empty( $request['sticky'] ) ) {\n\t\t\t\tstick_post( $post_id );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_id );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) && isset( $request['featured_media'] ) ) {\n\t\t\t$this->handle_featured_media( $request['featured_media'], $post_id );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['format'] ) && ! empty( $request['format'] ) ) {\n\t\t\tset_post_format( $post, $request['format'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) && isset( $request['template'] ) ) {\n\t\t\t$this->handle_template( $request['template'], $post_id );\n\t\t}\n\n\t\t$terms_update = $this->handle_terms( $post_id, $request );\n\n\t\tif ( is_wp_error( $terms_update ) ) {\n\t\t\treturn $terms_update;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $post_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $post, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $post, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $post_id ) ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\t\t$post = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( $post && ! $this->check_update_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['author'] ) && get_current_user_id() !== $request['author'] && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['sticky'] ) && ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! $this->check_assign_terms_permission( $request ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$valid_check = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $valid_check ) ) {\n\t\t\treturn $valid_check;\n\t\t}\n\n\t\t$post = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\t// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.\n\t\t$post_id = wp_update_post( wp_slash( (array) $post ), true );\n\n\t\tif ( is_wp_error( $post_id ) ) {\n\t\t\tif ( 'db_update_error' === $post_id->get_error_code() ) {\n\t\t\t\t$post_id->add_data( array( 'status' => 500 ) );\n\t\t\t} else {\n\t\t\t\t$post_id->add_data( array( 'status' => 400 ) );\n\t\t\t}\n\t\t\treturn $post_id;\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php */\n\t\tdo_action( \"rest_insert_{$this->post_type}\", $post, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['format'] ) && ! empty( $request['format'] ) ) {\n\t\t\tset_post_format( $post, $request['format'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) && isset( $request['featured_media'] ) ) {\n\t\t\t$this->handle_featured_media( $request['featured_media'], $post_id );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) && isset( $request['sticky'] ) ) {\n\t\t\tif ( ! empty( $request['sticky'] ) ) {\n\t\t\t\tstick_post( $post_id );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_id );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) && isset( $request['template'] ) ) {\n\t\t\t$this->handle_template( $request['template'], $post->ID );\n\t\t}\n\n\t\t$terms_update = $this->handle_terms( $post->ID, $request );\n\n\t\tif ( is_wp_error( $terms_update ) ) {\n\t\t\treturn $terms_update;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $post->ID );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$post = get_post( $post_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $post, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $post, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$post = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\tif ( $post && ! $this->check_delete_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$post = $this->get_post( $request['id'] );\n\t\tif ( is_wp_error( $post ) ) {\n\t\t\treturn $post;\n\t\t}\n\n\t\t$id    = $post->ID;\n\t\t$force = (bool) $request['force'];\n\n\t\t$supports_trash = ( EMPTY_TRASH_DAYS > 0 );\n\n\t\tif ( 'attachment' === $post->post_type ) {\n\t\t\t$supports_trash = $supports_trash && MEDIA_TRASH;\n\t\t}\n\n\t\t/**\n\t\t * Filters whether a post is trashable.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * Pass false to disable trash support for the post.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param bool    $supports_trash Whether the post type support trashing.\n\t\t * @param WP_Post $post           The Post object being considered for trashing support.\n\t\t */\n\t\t$supports_trash = apply_filters( \"rest_{$this->post_type}_trashable\", $supports_trash, $post );\n\n\t\tif ( ! $this->check_delete_permission( $post ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_delete_post', __( 'Sorry, you are not allowed to delete this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\n\t\t// If we're forcing, then delete permanently.\n\t\tif ( $force ) {\n\t\t\t$previous = $this->prepare_item_for_response( $post, $request );\n\t\t\t$result = wp_delete_post( $id, true );\n\t\t\t$response = new WP_REST_Response();\n\t\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\t} else {\n\t\t\t// If we don't support trashing for this type, error out.\n\t\t\tif ( ! $supports_trash ) {\n\t\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'The post does not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t\t}\n\n\t\t\t// Otherwise, only trash if we haven't already.\n\t\t\tif ( 'trash' === $post->post_status ) {\n\t\t\t\treturn new WP_Error( 'rest_already_trashed', __( 'The post has already been deleted.' ), array( 'status' => 410 ) );\n\t\t\t}\n\n\t\t\t// (Note that internally this falls through to `wp_delete_post` if\n\t\t\t// the trash is disabled.)\n\t\t\t$result = wp_trash_post( $id );\n\t\t\t$post = get_post( $id );\n\t\t\t$response = $this->prepare_item_for_response( $post, $request );\n\t\t}\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The post cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t/**\n\t\t * Fires immediately after a single post is deleted or trashed via the REST API.\n\t\t *\n\t\t * They dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object           $post     The deleted or trashed post.\n\t\t * @param WP_REST_Response $response The response data.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( \"rest_delete_{$this->post_type}\", $post, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Determines the allowed query_vars for a get_items() response and prepares\n\t * them for WP_Query.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param array           $prepared_args Optional. Prepared WP_Query arguments. Default empty array.\n\t * @param WP_REST_Request $request       Optional. Full details about the request.\n\t * @return array Items query arguments.\n\t */\n\tprotected function prepare_items_query( $prepared_args = array(), $request = null ) {\n\t\t$query_args = array();\n\n\t\tforeach ( $prepared_args as $key => $value ) {\n\t\t\t/**\n\t\t\t * Filters the query_vars used in get_items() for the constructed query.\n\t\t\t *\n\t\t\t * The dynamic portion of the hook name, `$key`, refers to the query_var key.\n\t\t\t *\n\t\t\t * @since 4.7.0\n\t\t\t *\n\t\t\t * @param string $value The query_var value.\n\t\t\t */\n\t\t\t$query_args[ $key ] = apply_filters( \"rest_query_var-{$key}\", $value );\n\t\t}\n\n\t\tif ( 'post' !== $this->post_type || ! isset( $query_args['ignore_sticky_posts'] ) ) {\n\t\t\t$query_args['ignore_sticky_posts'] = true;\n\t\t}\n\n\t\t// Map to proper WP_Query orderby param.\n\t\tif ( isset( $query_args['orderby'] ) && isset( $request['orderby'] ) ) {\n\t\t\t$orderby_mappings = array(\n\t\t\t\t'id'      => 'ID',\n\t\t\t\t'include' => 'post__in',\n\t\t\t\t'slug'    => 'post_name',\n\t\t\t);\n\n\t\t\tif ( isset( $orderby_mappings[ $request['orderby'] ] ) ) {\n\t\t\t\t$query_args['orderby'] = $orderby_mappings[ $request['orderby'] ];\n\t\t\t}\n\t\t}\n\n\t\treturn $query_args;\n\t}\n\n\t/**\n\t * Checks the post_date_gmt or modified_gmt and prepare any post or\n\t * modified date for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string      $date_gmt GMT publication time.\n\t * @param string|null $date     Optional. Local publication time. Default null.\n\t * @return string|null ISO8601/RFC3339 formatted datetime.\n\t */\n\tprotected function prepare_date_response( $date_gmt, $date = null ) {\n\t\t// Use the date if passed.\n\t\tif ( isset( $date ) ) {\n\t\t\treturn mysql_to_rfc3339( $date );\n\t\t}\n\n\t\t// Return null if $date_gmt is empty/zeros.\n\t\tif ( '0000-00-00 00:00:00' === $date_gmt ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Return the formatted datetime.\n\t\treturn mysql_to_rfc3339( $date_gmt );\n\t}\n\n\t/**\n\t * Prepares a single post for create or update.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return stdClass|WP_Error Post object or WP_Error.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_post = new stdClass;\n\n\t\t// Post ID.\n\t\tif ( isset( $request['id'] ) ) {\n\t\t\t$existing_post = $this->get_post( $request['id'] );\n\t\t\tif ( is_wp_error( $existing_post ) ) {\n\t\t\t\treturn $existing_post;\n\t\t\t}\n\n\t\t\t$prepared_post->ID = $existing_post->ID;\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// Post title.\n\t\tif ( ! empty( $schema['properties']['title'] ) && isset( $request['title'] ) ) {\n\t\t\tif ( is_string( $request['title'] ) ) {\n\t\t\t\t$prepared_post->post_title = $request['title'];\n\t\t\t} elseif ( ! empty( $request['title']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_title = $request['title']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post content.\n\t\tif ( ! empty( $schema['properties']['content'] ) && isset( $request['content'] ) ) {\n\t\t\tif ( is_string( $request['content'] ) ) {\n\t\t\t\t$prepared_post->post_content = $request['content'];\n\t\t\t} elseif ( isset( $request['content']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_content = $request['content']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post excerpt.\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) && isset( $request['excerpt'] ) ) {\n\t\t\tif ( is_string( $request['excerpt'] ) ) {\n\t\t\t\t$prepared_post->post_excerpt = $request['excerpt'];\n\t\t\t} elseif ( isset( $request['excerpt']['raw'] ) ) {\n\t\t\t\t$prepared_post->post_excerpt = $request['excerpt']['raw'];\n\t\t\t}\n\t\t}\n\n\t\t// Post type.\n\t\tif ( empty( $request['id'] ) ) {\n\t\t\t// Creating new post, use default type for the controller.\n\t\t\t$prepared_post->post_type = $this->post_type;\n\t\t} else {\n\t\t\t// Updating a post, use previous type.\n\t\t\t$prepared_post->post_type = get_post_type( $request['id'] );\n\t\t}\n\n\t\t$post_type = get_post_type_object( $prepared_post->post_type );\n\n\t\t// Post status.\n\t\tif ( ! empty( $schema['properties']['status'] ) && isset( $request['status'] ) ) {\n\t\t\t$status = $this->handle_status_param( $request['status'], $post_type );\n\n\t\t\tif ( is_wp_error( $status ) ) {\n\t\t\t\treturn $status;\n\t\t\t}\n\n\t\t\t$prepared_post->post_status = $status;\n\t\t}\n\n\t\t// Post date.\n\t\tif ( ! empty( $schema['properties']['date'] ) && ! empty( $request['date'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date'] );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_post->post_date, $prepared_post->post_date_gmt ) = $date_data;\n\t\t\t}\n\t\t} elseif ( ! empty( $schema['properties']['date_gmt'] ) && ! empty( $request['date_gmt'] ) ) {\n\t\t\t$date_data = rest_get_date_with_gmt( $request['date_gmt'], true );\n\n\t\t\tif ( ! empty( $date_data ) ) {\n\t\t\t\tlist( $prepared_post->post_date, $prepared_post->post_date_gmt ) = $date_data;\n\t\t\t}\n\t\t}\n\n\t\t// Post slug.\n\t\tif ( ! empty( $schema['properties']['slug'] ) && isset( $request['slug'] ) ) {\n\t\t\t$prepared_post->post_name = $request['slug'];\n\t\t}\n\n\t\t// Author.\n\t\tif ( ! empty( $schema['properties']['author'] ) && ! empty( $request['author'] ) ) {\n\t\t\t$post_author = (int) $request['author'];\n\n\t\t\tif ( get_current_user_id() !== $post_author ) {\n\t\t\t\t$user_obj = get_userdata( $post_author );\n\n\t\t\t\tif ( ! $user_obj ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_author', __( 'Invalid author ID.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$prepared_post->post_author = $post_author;\n\t\t}\n\n\t\t// Post password.\n\t\tif ( ! empty( $schema['properties']['password'] ) && isset( $request['password'] ) ) {\n\t\t\t$prepared_post->post_password = $request['password'];\n\n\t\t\tif ( '' !== $request['password'] ) {\n\t\t\t\tif ( ! empty( $schema['properties']['sticky'] ) && ! empty( $request['sticky'] ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A post can not be sticky and have a password.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\n\t\t\t\tif ( ! empty( $prepared_post->ID ) && is_sticky( $prepared_post->ID ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A sticky post can not be password protected.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) && ! empty( $request['sticky'] ) ) {\n\t\t\tif ( ! empty( $prepared_post->ID ) && post_password_required( $prepared_post->ID ) ) {\n\t\t\t\treturn new WP_Error( 'rest_invalid_field', __( 'A password protected post can not be set to sticky.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t// Parent.\n\t\tif ( ! empty( $schema['properties']['parent'] ) && isset( $request['parent'] ) ) {\n\t\t\tif ( 0 === (int) $request['parent'] ) {\n\t\t\t\t$prepared_post->post_parent = 0;\n\t\t\t} else {\n\t\t\t\t$parent = get_post( (int) $request['parent'] );\n\t\t\t\tif ( empty( $parent ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_post_invalid_id', __( 'Invalid post parent ID.' ), array( 'status' => 400 ) );\n\t\t\t\t}\n\t\t\t\t$prepared_post->post_parent = (int) $parent->ID;\n\t\t\t}\n\t\t}\n\n\t\t// Menu order.\n\t\tif ( ! empty( $schema['properties']['menu_order'] ) && isset( $request['menu_order'] ) ) {\n\t\t\t$prepared_post->menu_order = (int) $request['menu_order'];\n\t\t}\n\n\t\t// Comment status.\n\t\tif ( ! empty( $schema['properties']['comment_status'] ) && ! empty( $request['comment_status'] ) ) {\n\t\t\t$prepared_post->comment_status = $request['comment_status'];\n\t\t}\n\n\t\t// Ping status.\n\t\tif ( ! empty( $schema['properties']['ping_status'] ) && ! empty( $request['ping_status'] ) ) {\n\t\t\t$prepared_post->ping_status = $request['ping_status'];\n\t\t}\n\n\t\t/**\n\t\t * Filters a post before it is inserted via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param stdClass        $prepared_post An object representing a single post prepared\n\t\t *                                       for inserting or updating the database.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_pre_insert_{$this->post_type}\", $prepared_post, $request );\n\n\t}\n\n\t/**\n\t * Determines validity and normalizes the given status parameter.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $post_status Post status.\n\t * @param object $post_type   Post type.\n\t * @return string|WP_Error Post status or WP_Error if lacking the proper permission.\n\t */\n\tprotected function handle_status_param( $post_status, $post_type ) {\n\n\t\tswitch ( $post_status ) {\n\t\t\tcase 'draft':\n\t\t\tcase 'pending':\n\t\t\t\tbreak;\n\t\t\tcase 'private':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_publish', __( 'Sorry, you are not allowed to create private posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'publish':\n\t\t\tcase 'future':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_cannot_publish', __( 'Sorry, you are not allowed to publish posts in this post type.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! get_post_status_object( $post_status ) ) {\n\t\t\t\t\t$post_status = 'draft';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $post_status;\n\t}\n\n\t/**\n\t * Determines the featured media based on a request param.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param int $featured_media Featured Media ID.\n\t * @param int $post_id        Post ID.\n\t * @return bool|WP_Error Whether the post thumbnail was successfully deleted, otherwise WP_Error.\n\t */\n\tprotected function handle_featured_media( $featured_media, $post_id ) {\n\n\t\t$featured_media = (int) $featured_media;\n\t\tif ( $featured_media ) {\n\t\t\t$result = set_post_thumbnail( $post_id, $featured_media );\n\t\t\tif ( $result ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_invalid_featured_media', __( 'Invalid featured media ID.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t} else {\n\t\t\treturn delete_post_thumbnail( $post_id );\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the template for a post.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string  $template Page template filename.\n\t * @param integer $post_id  Post ID.\n\t */\n\tpublic function handle_template( $template, $post_id ) {\n\t\tif ( in_array( $template, array_keys( wp_get_theme()->get_page_templates( get_post( $post_id ) ) ), true ) ) {\n\t\t\tupdate_post_meta( $post_id, '_wp_page_template', $template );\n\t\t} else {\n\t\t\tupdate_post_meta( $post_id, '_wp_page_template', '' );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the post's terms from a REST request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param int             $post_id The post ID to update the terms form.\n\t * @param WP_REST_Request $request The request object with post and terms data.\n\t * @return null|WP_Error WP_Error on an error assigning any of the terms, otherwise null.\n\t */\n\tprotected function handle_terms( $post_id, $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! isset( $request[ $base ] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$result = wp_set_object_terms( $post_id, $request[ $base ], $taxonomy->name );\n\n\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\treturn $result;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether current user can assign all terms sent with the current request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request The request object with post and terms data.\n\t * @return bool Whether the current user can assign the provided terms.\n\t */\n\tprotected function check_assign_terms_permission( $request ) {\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! isset( $request[ $base ] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tforeach ( $request[ $base ] as $term_id ) {\n\t\t\t\t// Invalid terms will be rejected later.\n\t\t\t\tif ( ! get_term( $term_id, $taxonomy->name ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( ! current_user_can( 'assign_term', (int) $term_id ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if a given post type can be viewed or managed.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object|string $post_type Post type name or object.\n\t * @return bool Whether the post type is allowed in REST.\n\t */\n\tprotected function check_is_post_type_allowed( $post_type ) {\n\t\tif ( ! is_object( $post_type ) ) {\n\t\t\t$post_type = get_post_type_object( $post_type );\n\t\t}\n\n\t\tif ( ! empty( $post_type ) && ! empty( $post_type->show_in_rest ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if a post can be read.\n\t *\n\t * Correctly handles posts with the inherit status.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be read.\n\t */\n\tpublic function check_read_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Is the post readable?\n\t\tif ( 'publish' === $post->post_status || current_user_can( $post_type->cap->read_post, $post->ID ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$post_status_obj = get_post_status_object( $post->post_status );\n\t\tif ( $post_status_obj && $post_status_obj->public ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Can we read the parent if we're inheriting?\n\t\tif ( 'inherit' === $post->post_status && $post->post_parent > 0 ) {\n\t\t\t$parent = get_post( $post->post_parent );\n\t\t\treturn $this->check_read_permission( $parent );\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a parent, but the status is set to inherit, assume\n\t\t * it's published (as per get_post_status()).\n\t\t */\n\t\tif ( 'inherit' === $post->post_status ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if a post can be edited.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be edited.\n\t */\n\tprotected function check_update_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->edit_post, $post->ID );\n\t}\n\n\t/**\n\t * Checks if a post can be created.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be created.\n\t */\n\tprotected function check_create_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->create_posts );\n\t}\n\n\t/**\n\t * Checks if a post can be deleted.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $post Post object.\n\t * @return bool Whether the post can be deleted.\n\t */\n\tprotected function check_delete_permission( $post ) {\n\t\t$post_type = get_post_type_object( $post->post_type );\n\n\t\tif ( ! $this->check_is_post_type_allowed( $post_type ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current_user_can( $post_type->cap->delete_post, $post->ID );\n\t}\n\n\t/**\n\t * Prepares a single post output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post, $request ) {\n\t\t$GLOBALS['post'] = $post;\n\n\t\tsetup_postdata( $post );\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// Base fields for every post.\n\t\t$data = array();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $post->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date'] ) ) {\n\t\t\t$data['date'] = $this->prepare_date_response( $post->post_date_gmt, $post->post_date );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date_gmt'] ) ) {\n\t\t\t$data['date_gmt'] = $this->prepare_date_response( $post->post_date_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['guid'] ) ) {\n\t\t\t$data['guid'] = array(\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'get_the_guid', $post->guid ),\n\t\t\t\t'raw'      => $post->guid,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified'] ) ) {\n\t\t\t$data['modified'] = $this->prepare_date_response( $post->post_modified_gmt, $post->post_modified );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified_gmt'] ) ) {\n\t\t\t$data['modified_gmt'] = $this->prepare_date_response( $post->post_modified_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['password'] ) ) {\n\t\t\t$data['password'] = $post->post_password;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $post->post_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['status'] ) ) {\n\t\t\t$data['status'] = $post->post_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['type'] ) ) {\n\t\t\t$data['type'] = $post->post_type;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_permalink( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['title'] ) ) {\n\t\t\tadd_filter( 'protected_title_format', array( $this, 'protected_title_format' ) );\n\n\t\t\t$data['title'] = array(\n\t\t\t\t'raw'      => $post->post_title,\n\t\t\t\t'rendered' => get_the_title( $post->ID ),\n\t\t\t);\n\n\t\t\tremove_filter( 'protected_title_format', array( $this, 'protected_title_format' ) );\n\t\t}\n\n\t\t$has_password_filter = false;\n\n\t\tif ( $this->can_access_password_content( $post, $request ) ) {\n\t\t\t// Allow access to the post, permissions already checked before.\n\t\t\tadd_filter( 'post_password_required', '__return_false' );\n\n\t\t\t$has_password_filter = true;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['content'] ) ) {\n\t\t\t$data['content'] = array(\n\t\t\t\t'raw'       => $post->post_content,\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered'  => post_password_required( $post ) ? '' : apply_filters( 'the_content', $post->post_content ),\n\t\t\t\t'protected' => (bool) $post->post_password,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) ) {\n\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t$excerpt = apply_filters( 'the_excerpt', apply_filters( 'get_the_excerpt', $post->post_excerpt, $post ) );\n\t\t\t$data['excerpt'] = array(\n\t\t\t\t'raw'       => $post->post_excerpt,\n\t\t\t\t'rendered'  => post_password_required( $post ) ? '' : $excerpt,\n\t\t\t\t'protected' => (bool) $post->post_password,\n\t\t\t);\n\t\t}\n\n\t\tif ( $has_password_filter ) {\n\t\t\t// Reset filter.\n\t\t\tremove_filter( 'post_password_required', '__return_false' );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['author'] ) ) {\n\t\t\t$data['author'] = (int) $post->post_author;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['featured_media'] ) ) {\n\t\t\t$data['featured_media'] = (int) get_post_thumbnail_id( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $post->post_parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['menu_order'] ) ) {\n\t\t\t$data['menu_order'] = (int) $post->menu_order;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['comment_status'] ) ) {\n\t\t\t$data['comment_status'] = $post->comment_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['ping_status'] ) ) {\n\t\t\t$data['ping_status'] = $post->ping_status;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['sticky'] ) ) {\n\t\t\t$data['sticky'] = is_sticky( $post->ID );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['template'] ) ) {\n\t\t\tif ( $template = get_page_template_slug( $post->ID ) ) {\n\t\t\t\t$data['template'] = $template;\n\t\t\t} else {\n\t\t\t\t$data['template'] = '';\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['format'] ) ) {\n\t\t\t$data['format'] = get_post_format( $post->ID );\n\n\t\t\t// Fill in blank post format.\n\t\t\tif ( empty( $data['format'] ) ) {\n\t\t\t\t$data['format'] = 'standard';\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $post->ID, $request );\n\t\t}\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\tif ( ! empty( $schema['properties'][ $base ] ) ) {\n\t\t\t\t$terms = get_the_terms( $post, $taxonomy->name );\n\t\t\t\t$data[ $base ] = $terms ? array_values( wp_list_pluck( $terms, 'term_id' ) ) : array();\n\t\t\t}\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $post ) );\n\n\t\t/**\n\t\t * Filters the post data for a response.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->post_type`, refers to the post type slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param WP_Post          $post     Post object.\n\t\t * @param WP_REST_Request  $request  Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_prepare_{$this->post_type}\", $response, $post, $request );\n\t}\n\n\t/**\n\t * Overwrites the default protected title format.\n\t *\n\t * By default, WordPress will show password protected posts with a title of\n\t * \"Protected: %s\", as the REST API communicates the protected status of a post\n\t * in a machine readable format, we remove the \"Protected: \" prefix.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return string Protected title format.\n\t */\n\tpublic function protected_title_format() {\n\t\treturn '%s';\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post $post Post object.\n\t * @return array Links for the given post.\n\t */\n\tprotected function prepare_links( $post ) {\n\t\t$base = sprintf( '%s/%s', $this->namespace, $this->rest_base );\n\n\t\t// Entity meta.\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href'   => rest_url( trailingslashit( $base ) . $post->ID ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href'   => rest_url( $base ),\n\t\t\t),\n\t\t\t'about'      => array(\n\t\t\t\t'href'   => rest_url( 'wp/v2/types/' . $this->post_type ),\n\t\t\t),\n\t\t);\n\n\t\tif ( ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'author' ) )\n\t\t\t&& ! empty( $post->post_author ) ) {\n\t\t\t$links['author'] = array(\n\t\t\t\t'href'       => rest_url( 'wp/v2/users/' . $post->post_author ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'comments' ) ) {\n\t\t\t$replies_url = rest_url( 'wp/v2/comments' );\n\t\t\t$replies_url = add_query_arg( 'post', $post->ID, $replies_url );\n\n\t\t\t$links['replies'] = array(\n\t\t\t\t'href'       => $replies_url,\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( in_array( $post->post_type, array( 'post', 'page' ), true ) || post_type_supports( $post->post_type, 'revisions' ) ) {\n\t\t\t$links['version-history'] = array(\n\t\t\t\t'href' => rest_url( trailingslashit( $base ) . $post->ID . '/revisions' ),\n\t\t\t);\n\t\t}\n\n\t\t$post_type_obj = get_post_type_object( $post->post_type );\n\n\t\tif ( $post_type_obj->hierarchical && ! empty( $post->post_parent ) ) {\n\t\t\t$links['up'] = array(\n\t\t\t\t'href'       => rest_url( trailingslashit( $base ) . (int) $post->post_parent ),\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\t// If we have a featured media, add that.\n\t\tif ( $featured_media = get_post_thumbnail_id( $post->ID ) ) {\n\t\t\t$image_url = rest_url( 'wp/v2/media/' . $featured_media );\n\n\t\t\t$links['https://api.w.org/featuredmedia'] = array(\n\t\t\t\t'href'       => $image_url,\n\t\t\t\t'embeddable' => true,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! in_array( $post->post_type, array( 'attachment', 'nav_menu_item', 'revision' ), true ) ) {\n\t\t\t$attachments_url = rest_url( 'wp/v2/media' );\n\t\t\t$attachments_url = add_query_arg( 'parent', $post->ID, $attachments_url );\n\n\t\t\t$links['https://api.w.org/attachment'] = array(\n\t\t\t\t'href' => $attachments_url,\n\t\t\t);\n\t\t}\n\n\t\t$taxonomies = get_object_taxonomies( $post->post_type );\n\n\t\tif ( ! empty( $taxonomies ) ) {\n\t\t\t$links['https://api.w.org/term'] = array();\n\n\t\t\tforeach ( $taxonomies as $tax ) {\n\t\t\t\t$taxonomy_obj = get_taxonomy( $tax );\n\n\t\t\t\t// Skip taxonomies that are not public.\n\t\t\t\tif ( empty( $taxonomy_obj->show_in_rest ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$tax_base = ! empty( $taxonomy_obj->rest_base ) ? $taxonomy_obj->rest_base : $tax;\n\n\t\t\t\t$terms_url = add_query_arg(\n\t\t\t\t\t'post',\n\t\t\t\t\t$post->ID,\n\t\t\t\t\trest_url( 'wp/v2/' . $tax_base )\n\t\t\t\t);\n\n\t\t\t\t$links['https://api.w.org/term'][] = array(\n\t\t\t\t\t'href'       => $terms_url,\n\t\t\t\t\t'taxonomy'   => $tax,\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Retrieves the post's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => $this->post_type,\n\t\t\t'type'       => 'object',\n\t\t\t// Base properties for every Post.\n\t\t\t'properties' => array(\n\t\t\t\t'date'            => array(\n\t\t\t\t\t'description' => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'        => array(\n\t\t\t\t\t'description' => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'guid'            => array(\n\t\t\t\t\t'description' => __( 'The globally unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t'raw'      => array(\n\t\t\t\t\t\t\t'description' => __( 'GUID for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t'description' => __( 'GUID for the object, transformed for display.' ),\n\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'id'              => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'link'            => array(\n\t\t\t\t\t'description' => __( 'URL to the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'modified'        => array(\n\t\t\t\t\t'description' => __( \"The date the object was last modified, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'modified_gmt'    => array(\n\t\t\t\t\t'description' => __( 'The date the object was last modified, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'slug'            => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the object unique to its type.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'status'          => array(\n\t\t\t\t\t'description' => __( 'A named status for the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'enum'        => array_keys( get_post_stati( array( 'internal' => false ) ) ),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'type'            => array(\n\t\t\t\t\t'description' => __( 'Type of Post for the object.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'password'        => array(\n\t\t\t\t\t'description' => __( 'A password to protect access to the content and excerpt.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$post_type_obj = get_post_type_object( $this->post_type );\n\n\t\tif ( $post_type_obj->hierarchical ) {\n\t\t\t$schema['properties']['parent'] = array(\n\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t'type'        => 'integer',\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$post_type_attributes = array(\n\t\t\t'title',\n\t\t\t'editor',\n\t\t\t'author',\n\t\t\t'excerpt',\n\t\t\t'thumbnail',\n\t\t\t'comments',\n\t\t\t'revisions',\n\t\t\t'page-attributes',\n\t\t\t'post-formats',\n\t\t\t'custom-fields',\n\t\t);\n\t\t$fixed_schemas = array(\n\t\t\t'post' => array(\n\t\t\t\t'title',\n\t\t\t\t'editor',\n\t\t\t\t'author',\n\t\t\t\t'excerpt',\n\t\t\t\t'thumbnail',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'post-formats',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t\t'page' => array(\n\t\t\t\t'title',\n\t\t\t\t'editor',\n\t\t\t\t'author',\n\t\t\t\t'excerpt',\n\t\t\t\t'thumbnail',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'page-attributes',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t\t'attachment' => array(\n\t\t\t\t'title',\n\t\t\t\t'author',\n\t\t\t\t'comments',\n\t\t\t\t'revisions',\n\t\t\t\t'custom-fields',\n\t\t\t),\n\t\t);\n\t\tforeach ( $post_type_attributes as $attribute ) {\n\t\t\tif ( isset( $fixed_schemas[ $this->post_type ] ) && ! in_array( $attribute, $fixed_schemas[ $this->post_type ], true ) ) {\n\t\t\t\tcontinue;\n\t\t\t} elseif ( ! isset( $fixed_schemas[ $this->post_type ] ) && ! post_type_supports( $this->post_type, $attribute ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch ( $attribute ) {\n\n\t\t\t\tcase 'title':\n\t\t\t\t\t$schema['properties']['title'] = array(\n\t\t\t\t\t\t'description' => __( 'The title for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Title for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML title for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'editor':\n\t\t\t\t\t$schema['properties']['content'] = array(\n\t\t\t\t\t\t'description' => __( 'The content for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Content for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML content for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'protected'       => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Whether the content is protected with a password.' ),\n\t\t\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'author':\n\t\t\t\t\t$schema['properties']['author'] = array(\n\t\t\t\t\t\t'description' => __( 'The ID for the author of the object.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'excerpt':\n\t\t\t\t\t$schema['properties']['excerpt'] = array(\n\t\t\t\t\t\t'description' => __( 'The excerpt for the object.' ),\n\t\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t\t'sanitize_callback' => null, // Note: sanitization implemented in self::prepare_item_for_database()\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'properties'  => array(\n\t\t\t\t\t\t\t'raw' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Excerpt for the object, as it exists in the database.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'rendered' => array(\n\t\t\t\t\t\t\t\t'description' => __( 'HTML excerpt for the object, transformed for display.' ),\n\t\t\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t'protected'       => array(\n\t\t\t\t\t\t\t\t'description' => __( 'Whether the excerpt is protected with a password.' ),\n\t\t\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t\t\t\t'readonly'    => true,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'thumbnail':\n\t\t\t\t\t$schema['properties']['featured_media'] = array(\n\t\t\t\t\t\t'description' => __( 'The ID of the featured media for the object.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comments':\n\t\t\t\t\t$schema['properties']['comment_status'] = array(\n\t\t\t\t\t\t'description' => __( 'Whether or not comments are open on the object.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => array( 'open', 'closed' ),\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\t$schema['properties']['ping_status'] = array(\n\t\t\t\t\t\t'description' => __( 'Whether or not the object can be pinged.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => array( 'open', 'closed' ),\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'page-attributes':\n\t\t\t\t\t$schema['properties']['menu_order'] = array(\n\t\t\t\t\t\t'description' => __( 'The order of the object in relation to other object of its type.' ),\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post-formats':\n\t\t\t\t\t$supports_formats = get_theme_support( 'post-formats' );\n\n\t\t\t\t\t// Force to an array. Supports formats can return true even if empty in some cases.\n\t\t\t\t\t$supports_formats = is_array( $supports_formats ) ? array_values( $supports_formats[0] ) : array();\n\n\t\t\t\t\t$supported_formats = array_merge( array( 'standard' ), $supports_formats );\n\n\t\t\t\t\t$schema['properties']['format'] = array(\n\t\t\t\t\t\t'description' => __( 'The format for the object.' ),\n\t\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t\t'enum'        => $supported_formats,\n\t\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'custom-fields':\n\t\t\t\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tif ( 'post' === $this->post_type ) {\n\t\t\t$schema['properties']['sticky'] = array(\n\t\t\t\t'description' => __( 'Whether or not the object should be treated as sticky.' ),\n\t\t\t\t'type'        => 'boolean',\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['template'] = array(\n\t\t\t'description' => __( 'The theme file to use to display the object.' ),\n\t\t\t'type'        => 'string',\n\t\t\t'enum'        => array_merge( array_keys( wp_get_theme()->get_page_templates( null, $this->post_type ) ), array( '' ) ),\n\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t);\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t\t$schema['properties'][ $base ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description' => sprintf( __( 'The terms assigned to the object in the %s taxonomy.' ), $taxonomy->name ),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'items'       => array(\n\t\t\t\t\t'type'    => 'integer',\n\t\t\t\t),\n\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for the posts collection.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['after'] = array(\n\t\t\t'description'        => __( 'Limit response to posts published after a given ISO8601 compliant date.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'format'             => 'date-time',\n\t\t);\n\n\t\tif ( post_type_supports( $this->post_type, 'author' ) ) {\n\t\t\t$query_params['author'] = array(\n\t\t\t\t'description'         => __( 'Limit result set to posts assigned to specific authors.' ),\n\t\t\t\t'type'                => 'array',\n\t\t\t\t'items'               => array(\n\t\t\t\t\t'type'            => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'             => array(),\n\t\t\t);\n\t\t\t$query_params['author_exclude'] = array(\n\t\t\t\t'description'         => __( 'Ensure result set excludes posts assigned to specific authors.' ),\n\t\t\t\t'type'                => 'array',\n\t\t\t\t'items'               => array(\n\t\t\t\t\t'type'            => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'             => array(),\n\t\t\t);\n\t\t}\n\n\t\t$query_params['before'] = array(\n\t\t\t'description'        => __( 'Limit response to posts published before a given ISO8601 compliant date.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'format'             => 'date-time',\n\t\t);\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\tif ( 'page' === $this->post_type || post_type_supports( $this->post_type, 'page-attributes' ) ) {\n\t\t\t$query_params['menu_order'] = array(\n\t\t\t\t'description'        => __( 'Limit result set to posts with a specific menu_order value.' ),\n\t\t\t\t'type'               => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order'] = array(\n\t\t\t'description'        => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'default'            => 'desc',\n\t\t\t'enum'               => array( 'asc', 'desc' ),\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'description'        => __( 'Sort collection by object attribute.' ),\n\t\t\t'type'               => 'string',\n\t\t\t'default'            => 'date',\n\t\t\t'enum'               => array(\n\t\t\t\t'date',\n\t\t\t\t'relevance',\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'title',\n\t\t\t\t'slug',\n\t\t\t),\n\t\t);\n\n\t\tif ( 'page' === $this->post_type || post_type_supports( $this->post_type, 'page-attributes' ) ) {\n\t\t\t$query_params['orderby']['enum'][] = 'menu_order';\n\t\t}\n\n\t\t$post_type = get_post_type_object( $this->post_type );\n\n\t\tif ( $post_type->hierarchical || 'attachment' === $this->post_type ) {\n\t\t\t$query_params['parent'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to those of particular parent IDs.' ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t\t$query_params['parent_exclude'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to all items except those of a particular parent ID.' ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t}\n\n\t\t$query_params['slug'] = array(\n\t\t\t'description'       => __( 'Limit result set to posts with one or more specific slugs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'string',\n\t\t\t),\n\t\t\t'sanitize_callback' => 'wp_parse_slug_list',\n\t\t);\n\n\t\t$query_params['status'] = array(\n\t\t\t'default'           => 'publish',\n\t\t\t'description'       => __( 'Limit result set to posts assigned one or more statuses.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'enum'          => array_merge( array_keys( get_post_stati() ), array( 'any' ) ),\n\t\t\t\t'type'          => 'string',\n\t\t\t),\n\t\t\t'sanitize_callback' => array( $this, 'sanitize_post_statuses' ),\n\t\t);\n\n\t\t$taxonomies = wp_list_filter( get_object_taxonomies( $this->post_type, 'objects' ), array( 'show_in_rest' => true ) );\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\n\t\t\t$query_params[ $base ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description'       => sprintf( __( 'Limit result set to all items that have the specified term assigned in the %s taxonomy.' ), $base ),\n\t\t\t\t'type'              => 'array',\n\t\t\t\t'items'             => array(\n\t\t\t\t\t'type'          => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\n\t\t\t$query_params[ $base . '_exclude' ] = array(\n\t\t\t\t/* translators: %s: taxonomy name */\n\t\t\t\t'description' => sprintf( __( 'Limit result set to all items except those that have the specified term assigned in the %s taxonomy.' ), $base ),\n\t\t\t\t'type'        => 'array',\n\t\t\t\t'items'       => array(\n\t\t\t\t\t'type'    => 'integer',\n\t\t\t\t),\n\t\t\t\t'default'           => array(),\n\t\t\t);\n\t\t}\n\n\t\tif ( 'post' === $this->post_type ) {\n\t\t\t$query_params['sticky'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to items that are sticky.' ),\n\t\t\t\t'type'              => 'boolean',\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Filter collection parameters for the posts controller.\n\t\t *\n\t\t * The dynamic part of the filter `$this->post_type` refers to the post\n\t\t * type slug for the controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Query parameter. Use the\n\t\t * `rest_{$this->post_type}_query` filter to set WP_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array        $query_params JSON Schema-formatted collection parameters.\n\t\t * @param WP_Post_Type $post_type    Post type object.\n\t\t */\n\t\treturn apply_filters( \"rest_{$this->post_type}_collection_params\", $query_params, $post_type );\n\t}\n\n\t/**\n\t * Sanitizes and validates the list of post statuses, including whether the\n\t * user can query private statuses.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  string|array    $statuses  One or more post statuses.\n\t * @param  WP_REST_Request $request   Full details about the request.\n\t * @param  string          $parameter Additional parameter to pass to validation.\n\t * @return array|WP_Error A list of valid statuses, otherwise WP_Error object.\n\t */\n\tpublic function sanitize_post_statuses( $statuses, $request, $parameter ) {\n\t\t$statuses = wp_parse_slug_list( $statuses );\n\n\t\t// The default status is different in WP_REST_Attachments_Controller\n\t\t$attributes = $request->get_attributes();\n\t\t$default_status = $attributes['args']['status']['default'];\n\n\t\tforeach ( $statuses as $status ) {\n\t\t\tif ( $status === $default_status ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$post_type_obj = get_post_type_object( $this->post_type );\n\n\t\t\tif ( current_user_can( $post_type_obj->cap->edit_posts ) ) {\n\t\t\t\t$result = rest_validate_request_arg( $status, $request, $parameter );\n\t\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\t\treturn $result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_status', __( 'Status is forbidden.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn $statuses;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Revisions_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to access revisions via the REST API.\n *\n * @since 4.7.0\n *0\n * @see WP_REST_Controller\n */\nclass WP_REST_Revisions_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Parent post type.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var string\n\t */\n\tprivate $parent_post_type;\n\n\t/**\n\t * Parent controller.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var WP_REST_Controller\n\t */\n\tprivate $parent_controller;\n\n\t/**\n\t * The base of the parent controller's route.\n\t *\n\t * @since 4.7.0\n\t * @access private\n\t * @var string\n\t */\n\tprivate $parent_base;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $parent_post_type Post type of the parent.\n\t */\n\tpublic function __construct( $parent_post_type ) {\n\t\t$this->parent_post_type = $parent_post_type;\n\t\t$this->parent_controller = new WP_REST_Posts_Controller( $parent_post_type );\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'revisions';\n\t\t$post_type_object = get_post_type_object( $parent_post_type );\n\t\t$this->parent_base = ! empty( $post_type_object->rest_base ) ? $post_type_object->rest_base : $post_type_object->name;\n\t}\n\n\t/**\n\t * Registers routes for revisions based on post types supporting revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->parent_base . '/(?P<parent>[\\d]+)/' . $this->rest_base, array(\n\t\t\t'args' => array(\n\t\t\t\t'parent' => array(\n\t\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->parent_base . '/(?P<parent>[\\d]+)/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'parent' => array(\n\t\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t\t'id' => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as revisions do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t));\n\n\t}\n\n\t/**\n\t * Get the parent post, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_Post|WP_Error Post object if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_parent( $parent ) {\n\t\t$error = new WP_Error( 'rest_post_invalid_parent', __( 'Invalid post parent ID.' ), array( 'status' => 404 ) );\n\t\tif ( (int) $parent <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$parent = get_post( (int) $parent );\n\t\tif ( empty( $parent ) || empty( $parent->ID ) || $this->parent_post_type !== $parent->post_type ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\treturn $parent;\n\t}\n\n\t/**\n\t * Checks if a given request has access to get revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\t$parent = $this->get_parent( $request['parent'] );\n\t\tif ( is_wp_error( $parent ) ) {\n\t\t\treturn $parent;\n\t\t}\n\n\t\t$parent_post_type_obj = get_post_type_object( $parent->post_type );\n\t\tif ( ! current_user_can( $parent_post_type_obj->cap->edit_post, $parent->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_read', __( 'Sorry, you are not allowed to view revisions of this post.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get the revision, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_Post|WP_Error Revision post object if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_revision( $id ) {\n\t\t$error = new WP_Error( 'rest_post_invalid_id', __( 'Invalid revision ID.' ), array( 'status' => 404 ) );\n\t\tif ( (int) $id <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$revision = get_post( (int) $id );\n\t\tif ( empty( $revision ) || empty( $revision->ID ) || 'revision' !== $revision->post_type ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\treturn $revision;\n\t}\n\n\t/**\n\t * Gets a collection of revisions.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\t\t$parent = $this->get_parent( $request['parent'] );\n\t\tif ( is_wp_error( $parent ) ) {\n\t\t\treturn $parent;\n\t\t}\n\n\t\t$revisions = wp_get_post_revisions( $request['parent'] );\n\n\t\t$response = array();\n\t\tforeach ( $revisions as $revision ) {\n\t\t\t$data = $this->prepare_item_for_response( $revision, $request );\n\t\t\t$response[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to get a specific revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, WP_Error object otherwise.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\treturn $this->get_items_permissions_check( $request );\n\t}\n\n\t/**\n\t * Retrieves one revision from the collection.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$parent = $this->get_parent( $request['parent'] );\n\t\tif ( is_wp_error( $parent ) ) {\n\t\t\treturn $parent;\n\t\t}\n\n\t\t$revision = $this->get_revision( $request['id'] );\n\t\tif ( is_wp_error( $revision ) ) {\n\t\t\treturn $revision;\n\t\t}\n\n\t\t$response = $this->prepare_item_for_response( $revision, $request );\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete a revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$parent = $this->get_parent( $request['parent'] );\n\t\tif ( is_wp_error( $parent ) ) {\n\t\t\treturn $parent;\n\t\t}\n\n\t\t$revision = $this->get_revision( $request['id'] );\n\t\tif ( is_wp_error( $revision ) ) {\n\t\t\treturn $revision;\n\t\t}\n\n\t\t$response = $this->get_items_permissions_check( $request );\n\t\tif ( ! $response || is_wp_error( $response ) ) {\n\t\t\treturn $response;\n\t\t}\n\n\t\t$post_type = get_post_type_object( 'revision' );\n\t\treturn current_user_can( $post_type->cap->delete_post, $revision->ID );\n\t}\n\n\t/**\n\t * Deletes a single revision.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$revision = $this->get_revision( $request['id'] );\n\t\tif ( is_wp_error( $revision ) ) {\n\t\t\treturn $revision;\n\t\t}\n\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for revisions.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Revisions do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$previous = $this->prepare_item_for_response( $revision, $request );\n\n\t\t$result = wp_delete_post( $request['id'], true );\n\n\t\t/**\n\t\t * Fires after a revision is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param (mixed) $result The revision object (if it was deleted or moved to the trash successfully)\n\t\t *                        or false (failure). If the revision was moved to to the trash, $result represents\n\t\t *                        its new state; if it was deleted, $result represents its state before deletion.\n\t\t * @param WP_REST_Request $request The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_revision', $result, $request );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The post cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares the revision for the REST response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_Post         $post    Post revision object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $post, $request ) {\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t$data = array();\n\n\t\tif ( ! empty( $schema['properties']['author'] ) ) {\n\t\t\t$data['author'] = $post->post_author;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date'] ) ) {\n\t\t\t$data['date'] = $this->prepare_date_response( $post->post_date_gmt, $post->post_date );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['date_gmt'] ) ) {\n\t\t\t$data['date_gmt'] = $this->prepare_date_response( $post->post_date_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $post->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified'] ) ) {\n\t\t\t$data['modified'] = $this->prepare_date_response( $post->post_modified_gmt, $post->post_modified );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['modified_gmt'] ) ) {\n\t\t\t$data['modified_gmt'] = $this->prepare_date_response( $post->post_modified_gmt );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $post->post_parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $post->post_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['guid'] ) ) {\n\t\t\t$data['guid'] = array(\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'get_the_guid', $post->guid ),\n\t\t\t\t'raw'      => $post->guid,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['title'] ) ) {\n\t\t\t$data['title'] = array(\n\t\t\t\t'raw'      => $post->post_title,\n\t\t\t\t'rendered' => get_the_title( $post->ID ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['content'] ) ) {\n\n\t\t\t$data['content'] = array(\n\t\t\t\t'raw'      => $post->post_content,\n\t\t\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t\t\t'rendered' => apply_filters( 'the_content', $post->post_content ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['excerpt'] ) ) {\n\t\t\t$data['excerpt'] = array(\n\t\t\t\t'raw'      => $post->post_excerpt,\n\t\t\t\t'rendered' => $this->prepare_excerpt_response( $post->post_excerpt, $post ),\n\t\t\t);\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\t\t$response = rest_ensure_response( $data );\n\n\t\tif ( ! empty( $data['parent'] ) ) {\n\t\t\t$response->add_link( 'parent', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->parent_base, $data['parent'] ) ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters a revision returned from the API.\n\t\t *\n\t\t * Allows modification of the revision right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param WP_Post          $post     The original revision object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_revision', $response, $post, $request );\n\t}\n\n\t/**\n\t * Checks the post_date_gmt or modified_gmt and prepare any post or\n\t * modified date for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string      $date_gmt GMT publication time.\n\t * @param string|null $date     Optional. Local publication time. Default null.\n\t * @return string|null ISO8601/RFC3339 formatted datetime, otherwise null.\n\t */\n\tprotected function prepare_date_response( $date_gmt, $date = null ) {\n\t\tif ( '0000-00-00 00:00:00' === $date_gmt ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( isset( $date ) ) {\n\t\t\treturn mysql_to_rfc3339( $date );\n\t\t}\n\n\t\treturn mysql_to_rfc3339( $date_gmt );\n\t}\n\n\t/**\n\t * Retrieves the revision's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => \"{$this->parent_post_type}-revision\",\n\t\t\t'type'       => 'object',\n\t\t\t// Base properties for every Revision.\n\t\t\t'properties' => array(\n\t\t\t\t'author'          => array(\n\t\t\t\t\t'description' => __( 'The ID for the author of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date'            => array(\n\t\t\t\t\t'description' => __( \"The date the object was published, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'date_gmt'        => array(\n\t\t\t\t\t'description' => __( 'The date the object was published, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'guid'            => array(\n\t\t\t\t\t'description' => __( 'GUID for the object, as it exists in the database.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'id'              => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t\t'modified'        => array(\n\t\t\t\t\t'description' => __( \"The date the object was last modified, in the site's timezone.\" ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'modified_gmt'    => array(\n\t\t\t\t\t'description' => __( 'The date the object was last modified, as GMT.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'parent'          => array(\n\t\t\t\t\t'description' => __( 'The ID for the parent of the object.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t),\n\t\t\t\t'slug'            => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the object unique to its type.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'view', 'edit', 'embed' ),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$parent_schema = $this->parent_controller->get_item_schema();\n\n\t\tif ( ! empty( $parent_schema['properties']['title'] ) ) {\n\t\t\t$schema['properties']['title'] = $parent_schema['properties']['title'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['content'] ) ) {\n\t\t\t$schema['properties']['content'] = $parent_schema['properties']['content'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['excerpt'] ) ) {\n\t\t\t$schema['properties']['excerpt'] = $parent_schema['properties']['excerpt'];\n\t\t}\n\n\t\tif ( ! empty( $parent_schema['properties']['guid'] ) ) {\n\t\t\t$schema['properties']['guid'] = $parent_schema['properties']['guid'];\n\t\t}\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\treturn array(\n\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t);\n\t}\n\n\t/**\n\t * Checks the post excerpt and prepare it for single post output.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string  $excerpt The post excerpt.\n\t * @param WP_Post $post    Post revision object.\n\t * @return string Prepared excerpt or empty string.\n\t */\n\tprotected function prepare_excerpt_response( $excerpt, $post ) {\n\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_excerpt', $excerpt, $post );\n\n\t\tif ( empty( $excerpt ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn $excerpt;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Taxonomies_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to manage taxonomies via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Taxonomies_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'taxonomies';\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'         => WP_REST_Server::READABLE,\n\t\t\t\t'callback'        => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'            => $this->get_collection_params(),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<taxonomy>[\\w-]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'taxonomy' => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'         => WP_REST_Server::READABLE,\n\t\t\t\t'callback'        => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'            => array(\n\t\t\t\t\t'context'     => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether a given request has permission to read taxonomies.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\tif ( 'edit' === $request['context'] ) {\n\t\t\tif ( ! empty( $request['type'] ) ) {\n\t\t\t\t$taxonomies = get_object_taxonomies( $request['type'], 'objects' );\n\t\t\t} else {\n\t\t\t\t$taxonomies = get_taxonomies( '', 'objects' );\n\t\t\t}\n\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\tif ( ! empty( $taxonomy->show_in_rest ) && current_user_can( $taxonomy->cap->manage_terms ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new WP_Error( 'rest_cannot_view', __( 'Sorry, you are not allowed to manage terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all public taxonomies.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\tif ( isset( $registered['type'] ) && ! empty( $request['type'] ) ) {\n\t\t\t$taxonomies = get_object_taxonomies( $request['type'], 'objects' );\n\t\t} else {\n\t\t\t$taxonomies = get_taxonomies( '', 'objects' );\n\t\t}\n\t\t$data = array();\n\t\tforeach ( $taxonomies as $tax_type => $value ) {\n\t\t\tif ( empty( $value->show_in_rest ) || ( 'edit' === $request['context'] && ! current_user_can( $value->cap->manage_terms ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$tax = $this->prepare_item_for_response( $value, $request );\n\t\t\t$tax = $this->prepare_response_for_collection( $tax );\n\t\t\t$data[ $tax_type ] = $tax;\n\t\t}\n\n\t\tif ( empty( $data ) ) {\n\t\t\t// Response should still be returned as a JSON object when it is empty.\n\t\t\t$data = (object) $data;\n\t\t}\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Checks if a given request has access to a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access for the item, otherwise false or WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\n\t\t$tax_obj = get_taxonomy( $request['taxonomy'] );\n\n\t\tif ( $tax_obj ) {\n\t\t\tif ( empty( $tax_obj->show_in_rest ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( 'edit' === $request['context'] && ! current_user_can( $tax_obj->cap->manage_terms ) ) {\n\t\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to manage terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a specific taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$tax_obj = get_taxonomy( $request['taxonomy'] );\n\t\tif ( empty( $tax_obj ) ) {\n\t\t\treturn new WP_Error( 'rest_taxonomy_invalid', __( 'Invalid taxonomy.' ), array( 'status' => 404 ) );\n\t\t}\n\t\t$data = $this->prepare_item_for_response( $tax_obj, $request );\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Prepares a taxonomy object for serialization.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param stdClass        $taxonomy Taxonomy data.\n\t * @param WP_REST_Request $request  Full details about the request.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $taxonomy, $request ) {\n\t\t$base = ! empty( $taxonomy->rest_base ) ? $taxonomy->rest_base : $taxonomy->name;\n\t\t$data = array(\n\t\t\t'name'         => $taxonomy->label,\n\t\t\t'slug'         => $taxonomy->name,\n\t\t\t'capabilities' => $taxonomy->cap,\n\t\t\t'description'  => $taxonomy->description,\n\t\t\t'labels'       => $taxonomy->labels,\n\t\t\t'types'        => $taxonomy->object_type,\n\t\t\t'show_cloud'   => $taxonomy->show_tagcloud,\n\t\t\t'hierarchical' => $taxonomy->hierarchical,\n\t\t\t'rest_base'    => $base,\n\t\t);\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( array(\n\t\t\t'collection'                => array(\n\t\t\t\t'href'                  => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t\t'https://api.w.org/items'   => array(\n\t\t\t\t'href'                  => rest_url( sprintf( 'wp/v2/%s', $base ) ),\n\t\t\t),\n\t\t) );\n\n\t\t/**\n\t\t * Filters a taxonomy returned from the REST API.\n\t\t *\n\t\t * Allows modification of the taxonomy data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $item     The original taxonomy object.\n\t\t * @param WP_REST_Request  $request  Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_taxonomy', $response, $taxonomy, $request );\n\t}\n\n\t/**\n\t * Retrieves the taxonomy's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'              => 'http://json-schema.org/schema#',\n\t\t\t'title'                => 'taxonomy',\n\t\t\t'type'                 => 'object',\n\t\t\t'properties'           => array(\n\t\t\t\t'capabilities'     => array(\n\t\t\t\t\t'description'  => __( 'All capabilities used by the taxonomy.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description'      => array(\n\t\t\t\t\t'description'  => __( 'A human-readable description of the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'hierarchical'     => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the taxonomy should have children.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'labels'           => array(\n\t\t\t\t\t'description'  => __( 'Human-readable labels for the taxonomy for various contexts.' ),\n\t\t\t\t\t'type'         => 'object',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'             => array(\n\t\t\t\t\t'description'  => __( 'The title for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'             => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'show_cloud'       => array(\n\t\t\t\t\t'description'  => __( 'Whether or not the term cloud should be displayed.' ),\n\t\t\t\t\t'type'         => 'boolean',\n\t\t\t\t\t'context'      => array( 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'types'            => array(\n\t\t\t\t\t'description'  => __( 'Types associated with the taxonomy.' ),\n\t\t\t\t\t'type'         => 'array',\n\t\t\t\t\t'items'        => array(\n\t\t\t\t\t\t'type' => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'rest_base'            => array(\n\t\t\t\t\t'description'  => __( 'REST base route for the taxonomy.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit', 'embed' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$new_params = array();\n\t\t$new_params['context'] = $this->get_context_param( array( 'default' => 'view' ) );\n\t\t$new_params['type'] = array(\n\t\t\t'description'  => __( 'Limit results to taxonomies associated with a specific post type.' ),\n\t\t\t'type'         => 'string',\n\t\t);\n\t\treturn $new_params;\n\t}\n\n}\n", "<?php\n/**\n * REST API: WP_REST_Terms_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to managed terms associated with a taxonomy via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Terms_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Taxonomy key.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $taxonomy;\n\n\t/**\n\t * Instance of a term meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_Term_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Column to have the terms be sorted by.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var string\n\t */\n\tprotected $sort_column;\n\n\t/**\n\t * Number of terms that were found.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var int\n\t */\n\tprotected $total_terms;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param string $taxonomy Taxonomy key.\n\t */\n\tpublic function __construct( $taxonomy ) {\n\t\t$this->taxonomy = $taxonomy;\n\t\t$this->namespace = 'wp/v2';\n\t\t$tax_obj = get_taxonomy( $taxonomy );\n\t\t$this->rest_base = ! empty( $tax_obj->rest_base ) ? $tax_obj->rest_base : $tax_obj->name;\n\n\t\t$this->meta = new WP_REST_Term_Meta_Fields( $taxonomy );\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'id' => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the term.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force' => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as terms do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if a request has access to read terms in the specified taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access, otherwise false or WP_Error object.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\t$tax_obj = get_taxonomy( $this->taxonomy );\n\t\tif ( ! $tax_obj || ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( $tax_obj->cap->edit_terms ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit terms in this taxonomy.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves terms associated with a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'exclude'    => 'exclude',\n\t\t\t'include'    => 'include',\n\t\t\t'order'      => 'order',\n\t\t\t'orderby'    => 'orderby',\n\t\t\t'post'       => 'post',\n\t\t\t'hide_empty' => 'hide_empty',\n\t\t\t'per_page'   => 'number',\n\t\t\t'search'     => 'search',\n\t\t\t'slug'       => 'slug',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['offset'] ) && ! empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $request['offset'];\n\t\t} else {\n\t\t\t$prepared_args['offset'] = ( $request['page'] - 1 ) * $prepared_args['number'];\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $this->taxonomy );\n\n\t\tif ( $taxonomy_obj->hierarchical && isset( $registered['parent'], $request['parent'] ) ) {\n\t\t\tif ( 0 === $request['parent'] ) {\n\t\t\t\t// Only query top-level terms.\n\t\t\t\t$prepared_args['parent'] = 0;\n\t\t\t} else {\n\t\t\t\tif ( $request['parent'] ) {\n\t\t\t\t\t$prepared_args['parent'] = $request['parent'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the query arguments before passing them to get_terms().\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * Enables adding extra arguments or setting defaults for a terms\n\t\t * collection request.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/functions/get_terms/\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments to be\n\t\t *                                       passed to get_terms().\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( \"rest_{$this->taxonomy}_query\", $prepared_args, $request );\n\n\t\tif ( ! empty( $prepared_args['post'] )  ) {\n\t\t\t$query_result = wp_get_object_terms( $prepared_args['post'], $this->taxonomy, $prepared_args );\n\n\t\t\t// Used when calling wp_count_terms() below.\n\t\t\t$prepared_args['object_ids'] = $prepared_args['post'];\n\t\t} else {\n\t\t\t$query_result = get_terms( $this->taxonomy, $prepared_args );\n\t\t}\n\n\t\t$count_args = $prepared_args;\n\n\t\tunset( $count_args['number'], $count_args['offset'] );\n\n\t\t$total_terms = wp_count_terms( $this->taxonomy, $count_args );\n\n\t\t// wp_count_terms can return a falsy value when the term has no children.\n\t\tif ( ! $total_terms ) {\n\t\t\t$total_terms = 0;\n\t\t}\n\n\t\t$response = array();\n\n\t\tforeach ( $query_result as $term ) {\n\t\t\t$data = $this->prepare_item_for_response( $term, $request );\n\t\t\t$response[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$response = rest_ensure_response( $response );\n\n\t\t// Store pagination values for headers.\n\t\t$per_page = (int) $prepared_args['number'];\n\t\t$page     = ceil( ( ( (int) $prepared_args['offset'] ) / $per_page ) + 1 );\n\n\t\t$response->header( 'X-WP-Total', (int) $total_terms );\n\n\t\t$max_pages = ceil( $total_terms / $per_page );\n\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( $this->namespace . '/' . $this->rest_base ) );\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Get the term, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_Term|WP_Error Term object if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_term( $id ) {\n\t\t$error = new WP_Error( 'rest_term_invalid', __( 'Term does not exist.' ), array( 'status' => 404 ) );\n\n\t\tif ( ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\tif ( (int) $id <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$term = get_term( (int) $id, $this->taxonomy );\n\t\tif ( empty( $term ) || $term->taxonomy !== $this->taxonomy ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\treturn $term;\n\t}\n\n\t/**\n\t * Checks if a request has access to read or edit the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has read access for the item, otherwise false or WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'edit_term', $term->term_id ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to edit this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a request has access to create a term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to create items, false or WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\n\t\tif ( ! $this->check_is_taxonomy_allowed( $this->taxonomy ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $this->taxonomy );\n\t\tif ( ! current_user_can( $taxonomy_obj->cap->edit_terms ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create', __( 'Sorry, you are not allowed to create new terms.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single term in a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\tif ( ! is_taxonomy_hierarchical( $this->taxonomy ) ) {\n\t\t\t\treturn new WP_Error( 'rest_taxonomy_not_hierarchical', __( 'Can not set parent term, taxonomy is not hierarchical.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$parent = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( ! $parent ) {\n\t\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Parent term does not exist.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$prepared_term = $this->prepare_item_for_database( $request );\n\n\t\t$term = wp_insert_term( wp_slash( $prepared_term->name ), $this->taxonomy, wp_slash( (array) $prepared_term ) );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\t/*\n\t\t\t * If we're going to inform the client that the term already exists,\n\t\t\t * give them the identifier for future use.\n\t\t\t */\n\t\t\tif ( $term_id = $term->get_error_data( 'term_exists' ) ) {\n\t\t\t\t$existing_term = get_term( $term_id, $this->taxonomy );\n\t\t\t\t$term->add_data( $existing_term->term_id, 'term_exists' );\n\t\t\t}\n\n\t\t\treturn $term;\n\t\t}\n\n\t\t$term = get_term( $term['term_id'], $this->taxonomy );\n\n\t\t/**\n\t\t * Fires after a single term is created or updated via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Term         $term     Inserted or updated term object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a term, false when updating.\n\t\t */\n\t\tdo_action( \"rest_insert_{$this->taxonomy}\", $term, $request, true );\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], (int) $request['id'] );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $term, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( $this->namespace . '/' . $this->rest_base . '/' . $term->term_id ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a request has access to update the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to update the item, false or WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\tif ( ! current_user_can( 'edit_term', $term->term_id ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_update', __( 'Sorry, you are not allowed to edit this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\tif ( isset( $request['parent'] ) ) {\n\t\t\tif ( ! is_taxonomy_hierarchical( $this->taxonomy ) ) {\n\t\t\t\treturn new WP_Error( 'rest_taxonomy_not_hierarchical', __( 'Can not set parent term, taxonomy is not hierarchical.' ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$parent = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( ! $parent ) {\n\t\t\t\treturn new WP_Error( 'rest_term_invalid', __( 'Parent term does not exist.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$prepared_term = $this->prepare_item_for_database( $request );\n\n\t\t// Only update the term if we haz something to update.\n\t\tif ( ! empty( $prepared_term ) ) {\n\t\t\t$update = wp_update_term( $term->term_id, $term->taxonomy, wp_slash( (array) $prepared_term ) );\n\n\t\t\tif ( is_wp_error( $update ) ) {\n\t\t\t\treturn $update;\n\t\t\t}\n\t\t}\n\n\t\t$term = get_term( $term->term_id, $this->taxonomy );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-terms-controller.php */\n\t\tdo_action( \"rest_insert_{$this->taxonomy}\", $term, $request, false );\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $term->term_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$fields_update = $this->update_additional_fields_for_object( $term, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$response = $this->prepare_item_for_response( $term, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Checks if a request has access to delete the specified term.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return bool|WP_Error True if the request has access to delete the item, otherwise false or WP_Error object.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\tif ( ! current_user_can( 'delete_term', $term->term_id ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'Sorry, you are not allowed to delete this term.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single term from a taxonomy.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t$term = $this->get_term( $request['id'] );\n\t\tif ( is_wp_error( $term ) ) {\n\t\t\treturn $term;\n\t\t}\n\n\t\t$force = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for terms.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Terms do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\t$request->set_param( 'context', 'view' );\n\n\t\t$previous = $this->prepare_item_for_response( $term, $request );\n\n\t\t$retval = wp_delete_term( $term->term_id, $term->taxonomy );\n\n\t\tif ( ! $retval ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The term cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\n\t\t/**\n\t\t * Fires after a single term is deleted via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_Term          $term     The deleted term.\n\t\t * @param WP_REST_Response $response The response data.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( \"rest_delete_{$this->taxonomy}\", $term, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Prepares a single term for create or update.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return object $prepared_term Term object.\n\t */\n\tpublic function prepare_item_for_database( $request ) {\n\t\t$prepared_term = new stdClass;\n\n\t\t$schema = $this->get_item_schema();\n\t\tif ( isset( $request['name'] ) && ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$prepared_term->name = $request['name'];\n\t\t}\n\n\t\tif ( isset( $request['slug'] ) && ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$prepared_term->slug = $request['slug'];\n\t\t}\n\n\t\tif ( isset( $request['taxonomy'] ) && ! empty( $schema['properties']['taxonomy'] ) ) {\n\t\t\t$prepared_term->taxonomy = $request['taxonomy'];\n\t\t}\n\n\t\tif ( isset( $request['description'] ) && ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$prepared_term->description = $request['description'];\n\t\t}\n\n\t\tif ( isset( $request['parent'] ) && ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$parent_term_id = 0;\n\t\t\t$parent_term    = get_term( (int) $request['parent'], $this->taxonomy );\n\n\t\t\tif ( $parent_term ) {\n\t\t\t\t$parent_term_id = $parent_term->term_id;\n\t\t\t}\n\n\t\t\t$prepared_term->parent = $parent_term_id;\n\t\t}\n\n\t\t/**\n\t\t * Filters term data before inserting term via the REST API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object          $prepared_term Term object.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( \"rest_pre_insert_{$this->taxonomy}\", $prepared_term, $request );\n\t}\n\n\t/**\n\t * Prepares a single term output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param obj             $item    Term object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response $response Response object.\n\t */\n\tpublic function prepare_item_for_response( $item, $request ) {\n\n\t\t$schema = $this->get_item_schema();\n\t\t$data   = array();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = (int) $item->term_id;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['count'] ) ) {\n\t\t\t$data['count'] = (int) $item->count;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$data['description'] = $item->description;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_term_link( $item );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$data['name'] = $item->name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $item->slug;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['taxonomy'] ) ) {\n\t\t\t$data['taxonomy'] = $item->taxonomy;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['parent'] ) ) {\n\t\t\t$data['parent'] = (int) $item->parent;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $item->term_id, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $item ) );\n\n\t\t/**\n\t\t * Filters a term item returned from the API.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$this->taxonomy`, refers to the taxonomy slug.\n\t\t *\n\t\t * Allows modification of the term data right before it is returned.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response  $response  The response object.\n\t\t * @param object            $item      The original term object.\n\t\t * @param WP_REST_Request   $request   Request used to generate the response.\n\t\t */\n\t\treturn apply_filters( \"rest_prepare_{$this->taxonomy}\", $response, $item, $request );\n\t}\n\n\t/**\n\t * Prepares links for the request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param object $term Term object.\n\t * @return array Links for the given term.\n\t */\n\tprotected function prepare_links( $term ) {\n\t\t$base = $this->namespace . '/' . $this->rest_base;\n\t\t$links = array(\n\t\t\t'self'       => array(\n\t\t\t\t'href' => rest_url( trailingslashit( $base ) . $term->term_id ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( $base ),\n\t\t\t),\n\t\t\t'about'      => array(\n\t\t\t\t'href' => rest_url( sprintf( 'wp/v2/taxonomies/%s', $this->taxonomy ) ),\n\t\t\t),\n\t\t);\n\n\t\tif ( $term->parent ) {\n\t\t\t$parent_term = get_term( (int) $term->parent, $term->taxonomy );\n\n\t\t\tif ( $parent_term ) {\n\t\t\t\t$links['up'] = array(\n\t\t\t\t\t'href'       => rest_url( trailingslashit( $base ) . $parent_term->term_id ),\n\t\t\t\t\t'embeddable' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$taxonomy_obj = get_taxonomy( $term->taxonomy );\n\n\t\tif ( empty( $taxonomy_obj->object_type ) ) {\n\t\t\treturn $links;\n\t\t}\n\n\t\t$post_type_links = array();\n\n\t\tforeach ( $taxonomy_obj->object_type as $type ) {\n\t\t\t$post_type_object = get_post_type_object( $type );\n\n\t\t\tif ( empty( $post_type_object->show_in_rest ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$rest_base = ! empty( $post_type_object->rest_base ) ? $post_type_object->rest_base : $post_type_object->name;\n\t\t\t$post_type_links[] = array(\n\t\t\t\t'href' => add_query_arg( $this->rest_base, $term->term_id, rest_url( sprintf( 'wp/v2/%s', $rest_base ) ) ),\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $post_type_links ) ) {\n\t\t\t$links['https://api.w.org/post_type'] = $post_type_links;\n\t\t}\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Retrieves the term's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => 'post_tag' === $this->taxonomy ? 'tag' : $this->taxonomy,\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => array(\n\t\t\t\t'id'          => array(\n\t\t\t\t\t'description'  => __( 'Unique identifier for the term.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'count'       => array(\n\t\t\t\t\t'description'  => __( 'Number of published posts for the term.' ),\n\t\t\t\t\t'type'         => 'integer',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'description' => array(\n\t\t\t\t\t'description'  => __( 'HTML description of the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'        => array(\n\t\t\t\t\t'description'  => __( 'URL of the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'format'       => 'uri',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t\t'name'        => array(\n\t\t\t\t\t'description'  => __( 'HTML title for the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t\t'required'     => true,\n\t\t\t\t),\n\t\t\t\t'slug'        => array(\n\t\t\t\t\t'description'  => __( 'An alphanumeric identifier for the term unique to its type.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'arg_options'  => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'taxonomy'    => array(\n\t\t\t\t\t'description'  => __( 'Type attribution for the term.' ),\n\t\t\t\t\t'type'         => 'string',\n\t\t\t\t\t'enum'         => array_keys( get_taxonomies() ),\n\t\t\t\t\t'context'      => array( 'view', 'embed', 'edit' ),\n\t\t\t\t\t'readonly'     => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$taxonomy = get_taxonomy( $this->taxonomy );\n\n\t\tif ( $taxonomy->hierarchical ) {\n\t\t\t$schema['properties']['parent'] = array(\n\t\t\t\t'description'  => __( 'The parent term ID.' ),\n\t\t\t\t'type'         => 'integer',\n\t\t\t\t'context'      => array( 'view', 'edit' ),\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\t\t$taxonomy = get_taxonomy( $this->taxonomy );\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'       => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t\t'default'           => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'       => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'              => 'array',\n\t\t\t'items'             => array(\n\t\t\t\t'type'          => 'integer',\n\t\t\t),\n\t\t\t'default'           => array(),\n\t\t);\n\n\t\tif ( ! $taxonomy->hierarchical ) {\n\t\t\t$query_params['offset'] = array(\n\t\t\t\t'description'       => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t\t'type'              => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['order'] = array(\n\t\t\t'description'       => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'default'           => 'asc',\n\t\t\t'enum'              => array(\n\t\t\t\t'asc',\n\t\t\t\t'desc',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'description'       => __( 'Sort collection by term attribute.' ),\n\t\t\t'type'              => 'string',\n\t\t\t'default'           => 'name',\n\t\t\t'enum'              => array(\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'name',\n\t\t\t\t'slug',\n\t\t\t\t'term_group',\n\t\t\t\t'description',\n\t\t\t\t'count',\n\t\t\t),\n\t\t);\n\n\t\t$query_params['hide_empty'] = array(\n\t\t\t'description'       => __( 'Whether to hide terms not assigned to any posts.' ),\n\t\t\t'type'              => 'boolean',\n\t\t\t'default'           => false,\n\t\t);\n\n\t\tif ( $taxonomy->hierarchical ) {\n\t\t\t$query_params['parent'] = array(\n\t\t\t\t'description'       => __( 'Limit result set to terms assigned to a specific parent.' ),\n\t\t\t\t'type'              => 'integer',\n\t\t\t);\n\t\t}\n\n\t\t$query_params['post'] = array(\n\t\t\t'description'       => __( 'Limit result set to terms assigned to a specific post.' ),\n\t\t\t'type'              => 'integer',\n\t\t\t'default'           => null,\n\t\t);\n\n\t\t$query_params['slug'] = array(\n\t\t\t'description'       => __( 'Limit result set to terms with a specific slug.' ),\n\t\t\t'type'              => 'string',\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the terms controller.\n\t\t *\n\t\t * The dynamic part of the filter `$this->taxonomy` refers to the taxonomy\n\t\t * slug for the controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_Term_Query parameter.  Use the\n\t\t * `rest_{$this->taxonomy}_query` filter to set WP_Term_Query parameters.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array       $query_params JSON Schema-formatted collection parameters.\n\t\t * @param WP_Taxonomy $taxonomy     Taxonomy object.\n\t\t */\n\t\treturn apply_filters( \"rest_{$this->taxonomy}_collection_params\", $query_params, $taxonomy );\n\t}\n\n\t/**\n\t * Checks that the taxonomy is valid.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param string $taxonomy Taxonomy to check.\n\t * @return bool Whether the taxonomy is allowed for REST management.\n\t */\n\tprotected function check_is_taxonomy_allowed( $taxonomy ) {\n\t\t$taxonomy_obj = get_taxonomy( $taxonomy );\n\t\tif ( $taxonomy_obj && ! empty( $taxonomy_obj->show_in_rest ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * REST API: WP_REST_Users_Controller class\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.7.0\n */\n\n/**\n * Core class used to manage users via the REST API.\n *\n * @since 4.7.0\n *\n * @see WP_REST_Controller\n */\nclass WP_REST_Users_Controller extends WP_REST_Controller {\n\n\t/**\n\t * Instance of a user meta fields object.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t * @var WP_REST_User_Meta_Fields\n\t */\n\tprotected $meta;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t */\n\tpublic function __construct() {\n\t\t$this->namespace = 'wp/v2';\n\t\t$this->rest_base = 'users';\n\n\t\t$this->meta = new WP_REST_User_Meta_Fields();\n\t}\n\n\t/**\n\t * Registers the routes for the objects of the controller.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes() {\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base, array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_items' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_items_permissions_check' ),\n\t\t\t\t'args'                => $this->get_collection_params(),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::CREATABLE,\n\t\t\t\t'callback'            => array( $this, 'create_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'create_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/(?P<id>[\\d]+)', array(\n\t\t\t'args' => array(\n\t\t\t\t'id' => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the user.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'get_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as users do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'reassign' => array(\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'description' => __( 'Reassign the deleted user\\'s posts and links to this user ID.' ),\n\t\t\t\t\t\t'required'    => true,\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_reassign' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t) );\n\n\t\tregister_rest_route( $this->namespace, '/' . $this->rest_base . '/me', array(\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t'callback'            => array( $this, 'get_current_item' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'context' => $this->get_context_param( array( 'default' => 'view' ) ),\n\t\t\t\t),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::EDITABLE,\n\t\t\t\t'callback'            => array( $this, 'update_current_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'update_current_item_permissions_check' ),\n\t\t\t\t'args'                => $this->get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'methods'             => WP_REST_Server::DELETABLE,\n\t\t\t\t'callback'            => array( $this, 'delete_current_item' ),\n\t\t\t\t'permission_callback' => array( $this, 'delete_current_item_permissions_check' ),\n\t\t\t\t'args'                => array(\n\t\t\t\t\t'force'    => array(\n\t\t\t\t\t\t'type'        => 'boolean',\n\t\t\t\t\t\t'default'     => false,\n\t\t\t\t\t\t'description' => __( 'Required to be true, as users do not support trashing.' ),\n\t\t\t\t\t),\n\t\t\t\t\t'reassign' => array(\n\t\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t\t'description' => __( 'Reassign the deleted user\\'s posts and links to this user ID.' ),\n\t\t\t\t\t\t'required'    => true,\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_reassign' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\t'schema' => array( $this, 'get_public_item_schema' ),\n\t\t));\n\t}\n\n\t/**\n\t * Checks for a valid value for the reassign parameter when deleting users.\n\t *\n\t * The value can be an integer, 'false', false, or ''.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param int|bool        $value   The value passed to the reassign parameter.\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @param string          $param   The parameter that is being sanitized.\n\t *\n\t * @return int|bool|WP_Error\n\t */\n\tpublic function check_reassign( $value, $request, $param ) {\n\t\tif ( is_numeric( $value ) ) {\n\t\t\treturn $value;\n\t\t}\n\n\t\tif ( empty( $value ) || false === $value || 'false' === $value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn new WP_Error( 'rest_invalid_param', __( 'Invalid user parameter(s).' ), array( 'status' => 400 ) );\n\t}\n\n\t/**\n\t * Permissions check for getting all users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n\t */\n\tpublic function get_items_permissions_check( $request ) {\n\t\t// Check if roles is specified in GET request and if user can list users.\n\t\tif ( ! empty( $request['roles'] ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves all users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_items( $request ) {\n\n\t\t// Retrieve the list of registered collection query parameters.\n\t\t$registered = $this->get_collection_params();\n\n\t\t/*\n\t\t * This array defines mappings between public API query parameters whose\n\t\t * values are accepted as-passed, and their internal WP_Query parameter\n\t\t * name equivalents (some are the same). Only values which are also\n\t\t * present in $registered will be set.\n\t\t */\n\t\t$parameter_mappings = array(\n\t\t\t'exclude'  => 'exclude',\n\t\t\t'include'  => 'include',\n\t\t\t'order'    => 'order',\n\t\t\t'per_page' => 'number',\n\t\t\t'search'   => 'search',\n\t\t\t'roles'    => 'role__in',\n\t\t);\n\n\t\t$prepared_args = array();\n\n\t\t/*\n\t\t * For each known parameter which is both registered and present in the request,\n\t\t * set the parameter's value on the query $prepared_args.\n\t\t */\n\t\tforeach ( $parameter_mappings as $api_param => $wp_param ) {\n\t\t\tif ( isset( $registered[ $api_param ], $request[ $api_param ] ) ) {\n\t\t\t\t$prepared_args[ $wp_param ] = $request[ $api_param ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $registered['offset'] ) && ! empty( $request['offset'] ) ) {\n\t\t\t$prepared_args['offset'] = $request['offset'];\n\t\t} else {\n\t\t\t$prepared_args['offset']  = ( $request['page'] - 1 ) * $prepared_args['number'];\n\t\t}\n\n\t\tif ( isset( $registered['orderby'] ) ) {\n\t\t\t$orderby_possibles = array(\n\t\t\t\t'id'              => 'ID',\n\t\t\t\t'include'         => 'include',\n\t\t\t\t'name'            => 'display_name',\n\t\t\t\t'registered_date' => 'registered',\n\t\t\t\t'slug'            => 'user_nicename',\n\t\t\t\t'email'           => 'user_email',\n\t\t\t\t'url'             => 'user_url',\n\t\t\t);\n\t\t\t$prepared_args['orderby'] = $orderby_possibles[ $request['orderby'] ];\n\t\t}\n\n\t\tif ( ! current_user_can( 'list_users' ) ) {\n\t\t\t$prepared_args['has_published_posts'] = get_post_types( array( 'show_in_rest' => true ), 'names' );\n\t\t}\n\n\t\tif ( ! empty( $prepared_args['search'] ) ) {\n\t\t\t$prepared_args['search'] = '*' . $prepared_args['search'] . '*';\n\t\t}\n\n\t\tif ( isset( $registered['slug'] ) && ! empty( $request['slug'] ) ) {\n\t\t\t$prepared_args['search'] = $request['slug'];\n\t\t\t$prepared_args['search_columns'] = array( 'user_nicename' );\n\t\t}\n\n\t\t/**\n\t\t * Filters WP_User_Query arguments when querying users via the REST API.\n\t\t *\n\t\t * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array           $prepared_args Array of arguments for WP_User_Query.\n\t\t * @param WP_REST_Request $request       The current request.\n\t\t */\n\t\t$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n\t\t$query = new WP_User_Query( $prepared_args );\n\n\t\t$users = array();\n\n\t\tforeach ( $query->results as $user ) {\n\t\t\t$data = $this->prepare_item_for_response( $user, $request );\n\t\t\t$users[] = $this->prepare_response_for_collection( $data );\n\t\t}\n\n\t\t$response = rest_ensure_response( $users );\n\n\t\t// Store pagination values for headers then unset for count query.\n\t\t$per_page = (int) $prepared_args['number'];\n\t\t$page     = ceil( ( ( (int) $prepared_args['offset'] ) / $per_page ) + 1 );\n\n\t\t$prepared_args['fields'] = 'ID';\n\n\t\t$total_users = $query->get_total();\n\n\t\tif ( $total_users < 1 ) {\n\t\t\t// Out-of-bounds, run the query again without LIMIT for total count.\n\t\t\tunset( $prepared_args['number'], $prepared_args['offset'] );\n\t\t\t$count_query = new WP_User_Query( $prepared_args );\n\t\t\t$total_users = $count_query->get_total();\n\t\t}\n\n\t\t$response->header( 'X-WP-Total', (int) $total_users );\n\n\t\t$max_pages = ceil( $total_users / $per_page );\n\n\t\t$response->header( 'X-WP-TotalPages', (int) $max_pages );\n\n\t\t$base = add_query_arg( $request->get_query_params(), rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ) );\n\t\tif ( $page > 1 ) {\n\t\t\t$prev_page = $page - 1;\n\n\t\t\tif ( $prev_page > $max_pages ) {\n\t\t\t\t$prev_page = $max_pages;\n\t\t\t}\n\n\t\t\t$prev_link = add_query_arg( 'page', $prev_page, $base );\n\t\t\t$response->link_header( 'prev', $prev_link );\n\t\t}\n\t\tif ( $max_pages > $page ) {\n\t\t\t$next_page = $page + 1;\n\t\t\t$next_link = add_query_arg( 'page', $next_page, $base );\n\n\t\t\t$response->link_header( 'next', $next_link );\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Get the user, if the ID is valid.\n\t *\n\t * @since 4.7.2\n\t *\n\t * @param int $id Supplied ID.\n\t * @return WP_User|WP_Error True if ID is valid, WP_Error otherwise.\n\t */\n\tprotected function get_user( $id ) {\n\t\t$error = new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\tif ( (int) $id <= 0 ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t$user = get_userdata( (int) $id );\n\t\tif ( empty( $user ) || ! $user->exists() ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Checks if a given request has access to read a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has read access for the item, otherwise WP_Error object.\n\t */\n\tpublic function get_item_permissions_check( $request ) {\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\t$types = get_post_types( array( 'show_in_rest' => true ), 'names' );\n\n\t\tif ( get_current_user_id() === $user->ID ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( 'edit' === $request['context'] && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t} elseif ( ! count_user_posts( $user->ID, $types ) && ! current_user_can( 'edit_user', $user->ID ) && ! current_user_can( 'list_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to list users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieves a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_item( $request ) {\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\t$user = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $user );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Retrieves the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function get_current_item( $request ) {\n\t\t$current_user_id = get_current_user_id();\n\n\t\tif ( empty( $current_user_id ) ) {\n\t\t\treturn new WP_Error( 'rest_not_logged_in', __( 'You are not currently logged in.' ), array( 'status' => 401 ) );\n\t\t}\n\n\t\t$user     = wp_get_current_user();\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access create users.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to create items, WP_Error object otherwise.\n\t */\n\tpublic function create_item_permissions_check( $request ) {\n\n\t\tif ( ! current_user_can( 'create_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_create_user', __( 'Sorry, you are not allowed to create new users.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function create_item( $request ) {\n\t\tif ( ! empty( $request['id'] ) ) {\n\t\t\treturn new WP_Error( 'rest_user_exists', __( 'Cannot create existing user.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $request['roles'] ) && ! empty( $schema['properties']['roles'] ) ) {\n\t\t\t$check_permission = $this->check_role_update( $request['id'], $request['roles'] );\n\n\t\t\tif ( is_wp_error( $check_permission ) ) {\n\t\t\t\treturn $check_permission;\n\t\t\t}\n\t\t}\n\n\t\t$user = $this->prepare_item_for_database( $request );\n\n\t\tif ( is_multisite() ) {\n\t\t\t$ret = wpmu_validate_user_signup( $user->user_login, $user->user_email );\n\n\t\t\tif ( is_wp_error( $ret['errors'] ) && ! empty( $ret['errors']->errors ) ) {\n\t\t\t\t$error = new WP_Error( 'rest_invalid_param', __( 'Invalid user parameter(s).' ), array( 'status' => 400 ) );\n\t\t\t\tforeach ( $ret['errors']->errors as $code => $messages ) {\n\t\t\t\t\tforeach ( $messages as $message ) {\n\t\t\t\t\t\t$error->add( $code, $message );\n\t\t\t\t\t}\n\t\t\t\t\tif ( $error_data = $error->get_error_data( $code ) ) {\n\t\t\t\t\t\t$error->add_data( $error_data, $code );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( is_multisite() ) {\n\t\t\t$user_id = wpmu_create_user( $user->user_login, $user->user_pass, $user->user_email );\n\n\t\t\tif ( ! $user_id ) {\n\t\t\t\treturn new WP_Error( 'rest_user_create', __( 'Error creating new user.' ), array( 'status' => 500 ) );\n\t\t\t}\n\n\t\t\t$user->ID = $user_id;\n\t\t\t$user_id  = wp_update_user( wp_slash( (array) $user ) );\n\n\t\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\t\treturn $user_id;\n\t\t\t}\n\n\t\t\tadd_user_to_blog( get_site()->id, $user_id, '' );\n\t\t} else {\n\t\t\t$user_id = wp_insert_user( wp_slash( (array) $user ) );\n\n\t\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\t\treturn $user_id;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\n\t\t/**\n\t\t * Fires immediately after a user is created or updated via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_User         $user     Inserted or updated user object.\n\t\t * @param WP_REST_Request $request  Request object.\n\t\t * @param bool            $creating True when creating a user, false when updating.\n\t\t */\n\t\tdo_action( 'rest_insert_user', $user, $request, true );\n\n\t\tif ( ! empty( $request['roles'] ) && ! empty( $schema['properties']['roles'] ) ) {\n\t\t\tarray_map( array( $user, 'add_role' ), $request['roles'] );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $user_id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $user, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\t$response->set_status( 201 );\n\t\t$response->header( 'Location', rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $user_id ) ) );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_item_permissions_check( $request ) {\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) && ! current_user_can( 'edit_users' ) ) {\n\t\t\treturn new WP_Error( 'rest_cannot_edit_roles', __( 'Sorry, you are not allowed to edit roles of this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Updates a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function update_item( $request ) {\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\t$id = $user->ID;\n\n\t\tif ( ! $user ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_id', __( 'Invalid user ID.' ), array( 'status' => 404 ) );\n\t\t}\n\n\t\tif ( email_exists( $request['email'] ) && $request['email'] !== $user->user_email ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_email', __( 'Invalid email address.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['username'] ) && $request['username'] !== $user->user_login ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_argument', __( \"Username isn't editable.\" ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['slug'] ) && $request['slug'] !== $user->user_nicename && get_user_by( 'slug', $request['slug'] ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_slug', __( 'Invalid slug.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) ) {\n\t\t\t$check_permission = $this->check_role_update( $id, $request['roles'] );\n\n\t\t\tif ( is_wp_error( $check_permission ) ) {\n\t\t\t\treturn $check_permission;\n\t\t\t}\n\t\t}\n\n\t\t$user = $this->prepare_item_for_database( $request );\n\n\t\t// Ensure we're operating on the same user we already checked.\n\t\t$user->ID = $id;\n\n\t\t$user_id = wp_update_user( wp_slash( (array) $user ) );\n\n\t\tif ( is_wp_error( $user_id ) ) {\n\t\t\treturn $user_id;\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\n\t\t/** This action is documented in wp-includes/rest-api/endpoints/class-wp-rest-users-controller.php */\n\t\tdo_action( 'rest_insert_user', $user, $request, false );\n\n\t\tif ( is_multisite() && ! is_user_member_of_blog( $id ) ) {\n\t\t\tadd_user_to_blog( get_current_blog_id(), $id, '' );\n\t\t}\n\n\t\tif ( ! empty( $request['roles'] ) ) {\n\t\t\tarray_map( array( $user, 'add_role' ), $request['roles'] );\n\t\t}\n\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) && isset( $request['meta'] ) ) {\n\t\t\t$meta_update = $this->meta->update_value( $request['meta'], $id );\n\n\t\t\tif ( is_wp_error( $meta_update ) ) {\n\t\t\t\treturn $meta_update;\n\t\t\t}\n\t\t}\n\n\t\t$user = get_user_by( 'id', $user_id );\n\t\t$fields_update = $this->update_additional_fields_for_object( $user, $request );\n\n\t\tif ( is_wp_error( $fields_update ) ) {\n\t\t\treturn $fields_update;\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$response = $this->prepare_item_for_response( $user, $request );\n\t\t$response = rest_ensure_response( $response );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to update the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to update the item, WP_Error object otherwise.\n\t */\n\tpublic function update_current_item_permissions_check( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->update_item_permissions_check( $request );\n\t}\n\n\t/**\n\t * Updates the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tfunction update_current_item( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->update_item( $request );\n\t}\n\n\t/**\n\t * Checks if a given request has access delete a user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_item_permissions_check( $request ) {\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\tif ( ! current_user_can( 'delete_user', $user->ID ) ) {\n\t\t\treturn new WP_Error( 'rest_user_cannot_delete', __( 'Sorry, you are not allowed to delete this user.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Deletes a single user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function delete_item( $request ) {\n\t\t// We don't support delete requests in multisite.\n\t\tif ( is_multisite() ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The user cannot be deleted.' ), array( 'status' => 501 ) );\n\t\t}\n\t\t$user = $this->get_user( $request['id'] );\n\t\tif ( is_wp_error( $user ) ) {\n\t\t\treturn $user;\n\t\t}\n\n\t\t$id       = $user->ID;\n\t\t$reassign = false === $request['reassign'] ? null : absint( $request['reassign'] );\n\t\t$force    = isset( $request['force'] ) ? (bool) $request['force'] : false;\n\n\t\t// We don't support trashing for users.\n\t\tif ( ! $force ) {\n\t\t\treturn new WP_Error( 'rest_trash_not_supported', __( 'Users do not support trashing. Set force=true to delete.' ), array( 'status' => 501 ) );\n\t\t}\n\n\t\tif ( ! empty( $reassign ) ) {\n\t\t\tif ( $reassign === $id || ! get_userdata( $reassign ) ) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_reassign', __( 'Invalid user ID for reassignment.' ), array( 'status' => 400 ) );\n\t\t\t}\n\t\t}\n\n\t\t$request->set_param( 'context', 'edit' );\n\n\t\t$previous = $this->prepare_item_for_response( $user, $request );\n\n\t\t/** Include admin user functions to get access to wp_delete_user() */\n\t\trequire_once ABSPATH . 'wp-admin/includes/user.php';\n\n\t\t$result = wp_delete_user( $id, $reassign );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new WP_Error( 'rest_cannot_delete', __( 'The user cannot be deleted.' ), array( 'status' => 500 ) );\n\t\t}\n\n\t\t$response = new WP_REST_Response();\n\t\t$response->set_data( array( 'deleted' => true, 'previous' => $previous->get_data() ) );\n\n\t\t/**\n\t\t * Fires immediately after a user is deleted via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_User          $user     The user data.\n\t\t * @param WP_REST_Response $response The response returned from the API.\n\t\t * @param WP_REST_Request  $request  The request sent to the API.\n\t\t */\n\t\tdo_action( 'rest_delete_user', $user, $response, $request );\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * Checks if a given request has access to delete the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return true|WP_Error True if the request has access to delete the item, WP_Error object otherwise.\n\t */\n\tpublic function delete_current_item_permissions_check( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->delete_item_permissions_check( $request );\n\t}\n\n\t/**\n\t * Deletes the current user.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_REST_Request $request Full details about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tfunction delete_current_item( $request ) {\n\t\t$request['id'] = get_current_user_id();\n\n\t\treturn $this->delete_item( $request );\n\t}\n\n\t/**\n\t * Prepares a single user output for response.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param WP_User         $user    User object.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response Response object.\n\t */\n\tpublic function prepare_item_for_response( $user, $request ) {\n\n\t\t$data   = array();\n\t\t$schema = $this->get_item_schema();\n\n\t\tif ( ! empty( $schema['properties']['id'] ) ) {\n\t\t\t$data['id'] = $user->ID;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['username'] ) ) {\n\t\t\t$data['username'] = $user->user_login;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$data['name'] = $user->display_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['first_name'] ) ) {\n\t\t\t$data['first_name'] = $user->first_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['last_name'] ) ) {\n\t\t\t$data['last_name'] = $user->last_name;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['email'] ) ) {\n\t\t\t$data['email'] = $user->user_email;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['url'] ) ) {\n\t\t\t$data['url'] = $user->user_url;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$data['description'] = $user->description;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['link'] ) ) {\n\t\t\t$data['link'] = get_author_posts_url( $user->ID, $user->user_nicename );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['locale'] ) ) {\n\t\t\t$data['locale'] = get_user_locale( $user );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['nickname'] ) ) {\n\t\t\t$data['nickname'] = $user->nickname;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$data['slug'] = $user->user_nicename;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['roles'] ) ) {\n\t\t\t// Defensively call array_values() to ensure an array is returned.\n\t\t\t$data['roles'] = array_values( $user->roles );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['registered_date'] ) ) {\n\t\t\t$data['registered_date'] = date( 'c', strtotime( $user->user_registered ) );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['capabilities'] ) ) {\n\t\t\t$data['capabilities'] = (object) $user->allcaps;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['extra_capabilities'] ) ) {\n\t\t\t$data['extra_capabilities'] = (object) $user->caps;\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['avatar_urls'] ) ) {\n\t\t\t$data['avatar_urls'] = rest_get_avatar_urls( $user->user_email );\n\t\t}\n\n\t\tif ( ! empty( $schema['properties']['meta'] ) ) {\n\t\t\t$data['meta'] = $this->meta->get_value( $user->ID, $request );\n\t\t}\n\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'embed';\n\n\t\t$data = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data = $this->filter_response_by_context( $data, $context );\n\n\t\t// Wrap the data in a response object.\n\t\t$response = rest_ensure_response( $data );\n\n\t\t$response->add_links( $this->prepare_links( $user ) );\n\n\t\t/**\n\t\t * Filters user data returned from the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param WP_REST_Response $response The response object.\n\t\t * @param object           $user     User object used to create response.\n\t\t * @param WP_REST_Request  $request  Request object.\n\t\t */\n\t\treturn apply_filters( 'rest_prepare_user', $response, $user, $request );\n\t}\n\n\t/**\n\t * Prepares links for the user request.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_Post $user User object.\n\t * @return array Links for the given user.\n\t */\n\tprotected function prepare_links( $user ) {\n\t\t$links = array(\n\t\t\t'self' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s/%d', $this->namespace, $this->rest_base, $user->ID ) ),\n\t\t\t),\n\t\t\t'collection' => array(\n\t\t\t\t'href' => rest_url( sprintf( '%s/%s', $this->namespace, $this->rest_base ) ),\n\t\t\t),\n\t\t);\n\n\t\treturn $links;\n\t}\n\n\t/**\n\t * Prepares a single user for creation or update.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param WP_REST_Request $request Request object.\n\t * @return object $prepared_user User object.\n\t */\n\tprotected function prepare_item_for_database( $request ) {\n\t\t$prepared_user = new stdClass;\n\n\t\t$schema = $this->get_item_schema();\n\n\t\t// required arguments.\n\t\tif ( isset( $request['email'] ) && ! empty( $schema['properties']['email'] ) ) {\n\t\t\t$prepared_user->user_email = $request['email'];\n\t\t}\n\n\t\tif ( isset( $request['username'] ) && ! empty( $schema['properties']['username'] ) ) {\n\t\t\t$prepared_user->user_login = $request['username'];\n\t\t}\n\n\t\tif ( isset( $request['password'] ) && ! empty( $schema['properties']['password'] ) ) {\n\t\t\t$prepared_user->user_pass = $request['password'];\n\t\t}\n\n\t\t// optional arguments.\n\t\tif ( isset( $request['id'] ) ) {\n\t\t\t$prepared_user->ID = absint( $request['id'] );\n\t\t}\n\n\t\tif ( isset( $request['name'] ) && ! empty( $schema['properties']['name'] ) ) {\n\t\t\t$prepared_user->display_name = $request['name'];\n\t\t}\n\n\t\tif ( isset( $request['first_name'] ) && ! empty( $schema['properties']['first_name'] ) ) {\n\t\t\t$prepared_user->first_name = $request['first_name'];\n\t\t}\n\n\t\tif ( isset( $request['last_name'] ) && ! empty( $schema['properties']['last_name'] ) ) {\n\t\t\t$prepared_user->last_name = $request['last_name'];\n\t\t}\n\n\t\tif ( isset( $request['nickname'] ) && ! empty( $schema['properties']['nickname'] ) ) {\n\t\t\t$prepared_user->nickname = $request['nickname'];\n\t\t}\n\n\t\tif ( isset( $request['slug'] ) && ! empty( $schema['properties']['slug'] ) ) {\n\t\t\t$prepared_user->user_nicename = $request['slug'];\n\t\t}\n\n\t\tif ( isset( $request['description'] ) && ! empty( $schema['properties']['description'] ) ) {\n\t\t\t$prepared_user->description = $request['description'];\n\t\t}\n\n\t\tif ( isset( $request['url'] ) && ! empty( $schema['properties']['url'] ) ) {\n\t\t\t$prepared_user->user_url = $request['url'];\n\t\t}\n\n\t\tif ( isset( $request['locale'] ) && ! empty( $schema['properties']['locale'] ) ) {\n\t\t\t$prepared_user->locale = $request['locale'];\n\t\t}\n\n\t\t// setting roles will be handled outside of this function.\n\t\tif ( isset( $request['roles'] ) ) {\n\t\t\t$prepared_user->role = false;\n\t\t}\n\n\t\t/**\n\t\t * Filters user data before insertion via the REST API.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param object          $prepared_user User object.\n\t\t * @param WP_REST_Request $request       Request object.\n\t\t */\n\t\treturn apply_filters( 'rest_pre_insert_user', $prepared_user, $request );\n\t}\n\n\t/**\n\t * Determines if the current user is allowed to make the desired roles change.\n\t *\n\t * @since 4.7.0\n\t * @access protected\n\t *\n\t * @param integer $user_id User ID.\n\t * @param array   $roles   New user roles.\n\t * @return true|WP_Error True if the current user is allowed to make the role change,\n\t *                       otherwise a WP_Error object.\n\t */\n\tprotected function check_role_update( $user_id, $roles ) {\n\t\tglobal $wp_roles;\n\n\t\tforeach ( $roles as $role ) {\n\n\t\t\tif ( ! isset( $wp_roles->role_objects[ $role ] ) ) {\n\t\t\t\t/* translators: %s: role key */\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', sprintf( __( 'The role %s does not exist.' ), $role ), array( 'status' => 400 ) );\n\t\t\t}\n\n\t\t\t$potential_role = $wp_roles->role_objects[ $role ];\n\n\t\t\t/*\n\t\t\t * Don't let anyone with 'edit_users' (admins) edit their own role to something without it.\n\t\t\t * Multisite super admins can freely edit their blog roles -- they possess all caps.\n\t\t\t */\n\t\t\tif ( ! ( is_multisite()\n\t\t\t\t&& current_user_can( 'manage_sites' ) )\n\t\t\t\t&& get_current_user_id() === $user_id\n\t\t\t\t&& ! $potential_role->has_cap( 'edit_users' )\n\t\t\t) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', __( 'Sorry, you are not allowed to give users that role.' ), array( 'status' => rest_authorization_required_code() ) );\n\t\t\t}\n\n\t\t\t/** Include admin functions to get access to get_editable_roles() */\n\t\t\trequire_once ABSPATH . 'wp-admin/includes/admin.php';\n\n\t\t\t// The new role must be editable by the logged-in user.\n\t\t\t$editable_roles = get_editable_roles();\n\n\t\t\tif ( empty( $editable_roles[ $role ] ) ) {\n\t\t\t\treturn new WP_Error( 'rest_user_invalid_role', __( 'Sorry, you are not allowed to give users that role.' ), array( 'status' => 403 ) );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check a username for the REST API.\n\t *\n\t * Performs a couple of checks like edit_user() in wp-admin/includes/user.php.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  mixed            $value   The username submitted in the request.\n\t * @param  WP_REST_Request  $request Full details about the request.\n\t * @param  string           $param   The parameter name.\n\t * @return WP_Error|string The sanitized username, if valid, otherwise an error.\n\t */\n\tpublic function check_username( $value, $request, $param ) {\n\t\t$username = (string) $value;\n\n\t\tif ( ! validate_username( $username ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_username', __( 'Username contains invalid characters.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/user.php */\n\t\t$illegal_logins = (array) apply_filters( 'illegal_user_logins', array() );\n\n\t\tif ( in_array( strtolower( $username ), array_map( 'strtolower', $illegal_logins ) ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_username', __( 'Sorry, that username is not allowed.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\treturn $username;\n\t}\n\n\t/**\n\t * Check a user password for the REST API.\n\t *\n\t * Performs a couple of checks like edit_user() in wp-admin/includes/user.php.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @param  mixed            $value   The password submitted in the request.\n\t * @param  WP_REST_Request  $request Full details about the request.\n\t * @param  string           $param   The parameter name.\n\t * @return WP_Error|string The sanitized password, if valid, otherwise an error.\n\t */\n\tpublic function check_user_password( $value, $request, $param ) {\n\t\t$password = (string) $value;\n\n\t\tif ( empty( $password ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_password', __( 'Passwords cannot be empty.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\tif ( false !== strpos( $password, \"\\\\\" ) ) {\n\t\t\treturn new WP_Error( 'rest_user_invalid_password', __( 'Passwords cannot contain the \"\\\\\" character.' ), array( 'status' => 400 ) );\n\t\t}\n\n\t\treturn $password;\n\t}\n\n\t/**\n\t * Retrieves the user's schema, conforming to JSON Schema.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Item schema data.\n\t */\n\tpublic function get_item_schema() {\n\t\t$schema = array(\n\t\t\t'$schema'    => 'http://json-schema.org/schema#',\n\t\t\t'title'      => 'user',\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => array(\n\t\t\t\t'id'          => array(\n\t\t\t\t\t'description' => __( 'Unique identifier for the user.' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'username'    => array(\n\t\t\t\t\t'description' => __( 'Login name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'required'    => true,\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_username' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'name'        => array(\n\t\t\t\t\t'description' => __( 'Display name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'first_name'  => array(\n\t\t\t\t\t'description' => __( 'First name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'last_name'   => array(\n\t\t\t\t\t'description' => __( 'Last name for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'email'       => array(\n\t\t\t\t\t'description' => __( 'The email address for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'email',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'required'    => true,\n\t\t\t\t),\n\t\t\t\t'url'         => array(\n\t\t\t\t\t'description' => __( 'URL of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'description' => array(\n\t\t\t\t\t'description' => __( 'Description of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t),\n\t\t\t\t'link'        => array(\n\t\t\t\t\t'description' => __( 'Author URL of the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'locale'    => array(\n\t\t\t\t\t'description' => __( 'Locale for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'enum'        => array_merge( array( '', 'en_US' ), get_available_languages() ),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'nickname'    => array(\n\t\t\t\t\t'description' => __( 'The nickname for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => 'sanitize_text_field',\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'slug'        => array(\n\t\t\t\t\t'description' => __( 'An alphanumeric identifier for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'sanitize_slug' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'registered_date' => array(\n\t\t\t\t\t'description' => __( 'Registration date for the user.' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'date-time',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'roles'           => array(\n\t\t\t\t\t'description' => __( 'Roles assigned to the user.' ),\n\t\t\t\t\t'type'        => 'array',\n\t\t\t\t\t'items'       => array(\n\t\t\t\t\t\t'type'    => 'string',\n\t\t\t\t\t),\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t),\n\t\t\t\t'password'        => array(\n\t\t\t\t\t'description' => __( 'Password for the user (never included).' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => array(), // Password is never displayed.\n\t\t\t\t\t'required'    => true,\n\t\t\t\t\t'arg_options' => array(\n\t\t\t\t\t\t'sanitize_callback' => array( $this, 'check_user_password' ),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t'capabilities'    => array(\n\t\t\t\t\t'description' => __( 'All capabilities assigned to the user.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t\t'extra_capabilities' => array(\n\t\t\t\t\t'description' => __( 'Any extra capabilities assigned to the user.' ),\n\t\t\t\t\t'type'        => 'object',\n\t\t\t\t\t'context'     => array( 'edit' ),\n\t\t\t\t\t'readonly'    => true,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif ( get_option( 'show_avatars' ) ) {\n\t\t\t$avatar_properties = array();\n\n\t\t\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t\t\tforeach ( $avatar_sizes as $size ) {\n\t\t\t\t$avatar_properties[ $size ] = array(\n\t\t\t\t\t/* translators: %d: avatar image size in pixels */\n\t\t\t\t\t'description' => sprintf( __( 'Avatar URL with image size of %d pixels.' ), $size ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'format'      => 'uri',\n\t\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$schema['properties']['avatar_urls']  = array(\n\t\t\t\t'description' => __( 'Avatar URLs for the user.' ),\n\t\t\t\t'type'        => 'object',\n\t\t\t\t'context'     => array( 'embed', 'view', 'edit' ),\n\t\t\t\t'readonly'    => true,\n\t\t\t\t'properties'  => $avatar_properties,\n\t\t\t);\n\t\t}\n\n\t\t$schema['properties']['meta'] = $this->meta->get_field_schema();\n\n\t\treturn $this->add_additional_fields_schema( $schema );\n\t}\n\n\t/**\n\t * Retrieves the query params for collections.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Collection parameters.\n\t */\n\tpublic function get_collection_params() {\n\t\t$query_params = parent::get_collection_params();\n\n\t\t$query_params['context']['default'] = 'view';\n\n\t\t$query_params['exclude'] = array(\n\t\t\t'description'        => __( 'Ensure result set excludes specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['include'] = array(\n\t\t\t'description'        => __( 'Limit result set to specific IDs.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'integer',\n\t\t\t),\n\t\t\t'default'            => array(),\n\t\t);\n\n\t\t$query_params['offset'] = array(\n\t\t\t'description'        => __( 'Offset the result set by a specific number of items.' ),\n\t\t\t'type'               => 'integer',\n\t\t);\n\n\t\t$query_params['order'] = array(\n\t\t\t'default'            => 'asc',\n\t\t\t'description'        => __( 'Order sort attribute ascending or descending.' ),\n\t\t\t'enum'               => array( 'asc', 'desc' ),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['orderby'] = array(\n\t\t\t'default'            => 'name',\n\t\t\t'description'        => __( 'Sort collection by object attribute.' ),\n\t\t\t'enum'               => array(\n\t\t\t\t'id',\n\t\t\t\t'include',\n\t\t\t\t'name',\n\t\t\t\t'registered_date',\n\t\t\t\t'slug',\n\t\t\t\t'email',\n\t\t\t\t'url',\n\t\t\t),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['slug']    = array(\n\t\t\t'description'        => __( 'Limit result set to users with a specific slug.' ),\n\t\t\t'type'               => 'string',\n\t\t);\n\n\t\t$query_params['roles']   = array(\n\t\t\t'description'        => __( 'Limit result set to users matching at least one specific role provided. Accepts csv list or single role.' ),\n\t\t\t'type'               => 'array',\n\t\t\t'items'              => array(\n\t\t\t\t'type'           => 'string',\n\t\t\t),\n\t\t);\n\n\t\t/**\n\t\t * Filter collection parameters for the users controller.\n\t\t *\n\t\t * This filter registers the collection parameter, but does not map the\n\t\t * collection parameter to an internal WP_User_Query parameter.  Use the\n\t\t * `rest_user_query` filter to set WP_User_Query arguments.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param array $query_params JSON Schema-formatted collection parameters.\n\t\t */\n\t\treturn apply_filters( 'rest_user_collection_params', $query_params );\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39954';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/rest-api.php", "wp-includes/rest-api/endpoints/class-wp-rest-comments-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-post-statuses-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-post-types-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-revisions-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-taxonomies-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-terms-controller.php", "wp-includes/rest-api/endpoints/class-wp-rest-users-controller.php", "wp-includes/version.php"], "buggy_code_start_loc": [48, 65, 50, 50, 90, 73, 50, 98, 67, 7], "buggy_code_end_loc": [65, 784, 50, 50, 905, 236, 50, 574, 723, 8], "fixing_code_start_loc": [49, 66, 51, 51, 91, 74, 51, 99, 68, 7], "fixing_code_end_loc": [74, 802, 57, 57, 943, 304, 57, 595, 752, 8], "type": "NVD-CWE-noinfo", "message": "The register_routes function in wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php in the REST API in WordPress 4.7.x before 4.7.2 does not require an integer identifier, which allows remote attackers to modify arbitrary pages via a request for wp-json/wp/v2/posts followed by a numeric value and a non-numeric value, as demonstrated by the wp-json/wp/v2/posts/123?id=123helloworld URI.", "other": {"cve": {"id": "CVE-2017-1001000", "sourceIdentifier": "josh@bress.net", "published": "2017-04-03T01:59:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The register_routes function in wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php in the REST API in WordPress 4.7.x before 4.7.2 does not require an integer identifier, which allows remote attackers to modify arbitrary pages via a request for wp-json/wp/v2/posts followed by a numeric value and a non-numeric value, as demonstrated by the wp-json/wp/v2/posts/123?id=123helloworld URI."}, {"lang": "es", "value": "La funci\u00f3n register_routes en wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php en la API REST en WordPress 4.7.x en versiones anteriores a 4.7.2 no requiere un identificador de n\u00famero entero, lo que permite a atacantes remotos modificar p\u00e1ginas arbitrarias a trav\u00e9s de una solicitud para wp-json/wp/v2/posts seguida por un valor num\u00e9rico y un valor no num\u00e9rico, seg\u00fan lo demostrado mediante la URI wp-json/wp/v2/posts/123?id=123helloworld."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:4.7:*:*:*:*:*:*:*", "matchCriteriaId": "72ABC52C-7C28-4CB7-9432-38540152F3B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:4.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "5B095729-5746-4E32-B857-7BC78962561C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:4.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "8459259A-4895-42B6-A242-D0B5871BE672"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/02/10/16", "source": "josh@bress.net", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1037731", "source": "josh@bress.net"}, {"url": "https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html", "source": "josh@bress.net", "tags": ["Technical Description", "Third Party Advisory"]}, {"url": "https://blogs.akamai.com/2017/02/wordpress-web-api-vulnerability.html", "source": "josh@bress.net", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://codex.wordpress.org/Version_4.7.2", "source": "josh@bress.net", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab", "source": "josh@bress.net", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/e357195ce303017d517aff944644a7a1232926f7", "source": "josh@bress.net", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://make.wordpress.org/core/2017/02/01/disclosure-of-additional-security-fix-in-wordpress-4-7-2/", "source": "josh@bress.net", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://wordpress.org/news/2017/01/wordpress-4-7-2-security-release/", "source": "josh@bress.net", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/e357195ce303017d517aff944644a7a1232926f7"}}