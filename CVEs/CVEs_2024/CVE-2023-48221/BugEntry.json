{"buggy_code": ["/*\n* Wire\n* Copyright (C) 2020 Wire Swiss GmbH\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <re.h>\n#include <avs.h>\n\n\nstatic uint32_t g_mid = 1000;\n\nenum bundle_type {\n        BUNDLE_TYPE_AUDIO,\n        BUNDLE_TYPE_VIDEO,\n};\n\nstruct bundle {\n\tuint32_t mid;\n\tstruct mbuf *mb;\n};\n\n\nstatic struct sdp_media *find_media(struct sdp_session *sess,\n\t\t\t\t    const char *type)\n{\n\tstruct sdp_media *sdpm;\n\tconst struct list *medial;\n\tstruct le *le;\n\tbool found = false;\n\n\tif (!sess) {\n\t\treturn NULL;\n\t}\n\n\tmedial = sdp_session_medial(sess, false);\n\n\tfor (le = medial->head; le && !found; le = le->next) {\n\t\tsdpm = (struct sdp_media *)le->data;\n\t\t\n\t\tfound = streq(type, sdp_media_name(sdpm));\n\t}\n\n\treturn found ? sdpm : NULL;\n}\n\nstatic bool fmt_handler(struct sdp_format *fmt, void *arg)\n{\n\tstruct sdp_media *sdpm = (struct sdp_media *)arg;\n\n\tif (streq(sdp_media_name(sdpm), \"audio\")) {\n\t\tif (streq(fmt->name, \"opus\")) {\n\t\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t\t}\n\t}\n\telse if (streq(sdp_media_name(sdpm), \"video\")) {\n\t\tif (strcaseeq(fmt->name, \"vp8\")) {\n\t\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t\t}\n\t}\n\telse if (streq(sdp_media_name(sdpm), \"application\")) {\n\n\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t}\n\n\treturn false;\t\n}\n\n\nstatic bool media_rattr_handler(const char *name, const char *value, void *arg)\n{\n\tstruct sdp_media *sdpm = (struct sdp_media *)arg;\n\tbool should_set = false;\n\n\tshould_set = streq(name, \"fingerprint\")\n\t\t  || streq(name, \"ice-ufrag\")\n\t\t  || streq(name, \"ice-pwd\")\n\t\t  || streq(name, \"rtcp-mux\")\n\t\t  || streq(name, \"extmap\");\n\t\n\tif (should_set)\n\t\tsdp_safe_media_set_lattr(sdpm, false, name, value);\n\n\treturn false;\n}\n\n\nstatic void bundle_ssrc(enum bundle_type type, struct conf_member *cm,\n\t\t\tstruct bundle *bundle,\n\t\t\tstruct sdp_session *sess, struct sdp_media *sdpm)\n{\n\tstruct sdp_media *newm;\n\tconst char *mtype;\n\tuint32_t ssrc;\n\tuint32_t mid;\n\tbool disabled = false;\n\tint lport;\n\tint err;\n\n\tswitch (type) {\n\tcase BUNDLE_TYPE_AUDIO:\n\t\tssrc = cm->ssrca;\n\t\tmtype = sdp_media_audio;\n\t\tif (cm->mida == 0) {\n\t\t\tcm->mida = g_mid;\n\t\t\tg_mid++;\n\t\t}\n\t\tmid = cm->mida;\n\t\tbreak;\n\n\tcase BUNDLE_TYPE_VIDEO:\n\t\tssrc = cm->ssrcv;\n\t\tmtype = sdp_media_video;\n\t\tif (cm->midv == 0) {\n\t\t\tcm->midv = g_mid;\n\t\t\tg_mid++;\n\t\t}\n\t\tmid = cm->midv;\n\t\tbreak;\n\n\tdefault:\n\t\twarning(\"bundle_ssrc: unknown bundle type\\n\");\n\t\treturn;\n\t}\n\n\tdisabled = ssrc == 0 || !cm->active;\n\tlport = 9; //disabled ? 0 : 9;\n\terr = sdp_media_add(&newm, sess, mtype, lport,\n\t\t\t    sdp_media_proto(sdpm));\n\tif (err) {\n\t\twarning(\"bundle_ssrc: video add failed: %m\\n\", err);\n\t\treturn;\n\t}\n\t\n\tsdp_media_set_disabled(newm, false);\n\tsdp_media_set_laddr(newm, sdp_media_raddr(sdpm));\n\tsdp_media_set_lport(newm, lport);\n\tsdp_media_set_lattr(newm, false, \"mid\", \"%u\", mid);\n\tif (!disabled) {\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u cname:%s\",\n\t\t\t\t    ssrc, cm->cname);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u msid:%s %s\",\n\t\t\t\t    ssrc, cm->msid, cm->label);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u mslabel:%s\",\n\t\t\t\t    ssrc, cm->msid);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u label:%s\",\n\t\t\t\t    ssrc, cm->label);\n\t}\n\n\tsdp_media_format_apply(sdpm, false, NULL, -1, NULL,\n\t\t\t       -1, -1, fmt_handler, newm);\n\n\tsdp_media_rattr_apply(sdpm, NULL,\n\t\t\t      media_rattr_handler, newm);\n\n\tsdp_media_set_ldir(newm, disabled ? SDP_INACTIVE : SDP_SENDONLY);\n\tsdp_media_set_lbandwidth(newm, SDP_BANDWIDTH_AS,\n\t\t\t\t sdp_media_rbandwidth(sdpm, SDP_BANDWIDTH_AS));\n\n\tmbuf_printf(bundle->mb, \" %u\", mid);\n}\n\n\nint bundle_update(struct iflow *flow,\n\t\t  enum icall_conv_type conv_type,\n\t\t  bool include_audio,\n\t\t  const char *remote_sdp,\n\t\t  struct list *membl,\n\t\t  bundle_flow_update_h *flow_updateh)\n{\n\tstruct sdp_media *sdpa = NULL;\n\tstruct sdp_media *sdpv = NULL;\n\tchar *grpstr;\n\tint err = 0;\n\tstruct le *le;\n\tstruct sdp_session *sess;\n\tstruct bundle bundle;\n\tchar *sdpres = NULL;\n\tstruct mbuf *mbb;\n\n\tsdp_dup(&sess, conv_type, remote_sdp, false);\n\tsdpa = find_media(sess, \"audio\");\n\tsdpv = find_media(sess, \"video\");\n\t\n\tbundle.mid = 0;\n\tbundle.mb = mbuf_alloc(128);\n\tmbuf_printf(bundle.mb, sdp_session_rattr(sess, \"group\"));\n\n\tlist_flush((struct list *)sdp_session_medial(sess, true));\n\t\n\tLIST_FOREACH(membl, le) {\n\t\tstruct conf_member *cm = (struct conf_member *)le->data;\n\n\t\tif (include_audio && sdpa)\n\t\t\tbundle_ssrc(BUNDLE_TYPE_AUDIO, cm, &bundle, sess, sdpa);\n\t\tif (sdpv && cm->ssrcv)\n\t\t\tbundle_ssrc(BUNDLE_TYPE_VIDEO, cm, &bundle, sess, sdpv);\n\t}\n\n\tbundle.mb->pos = 0;\n\tmbuf_strdup(bundle.mb, &grpstr, mbuf_get_left(bundle.mb));\n\tsdp_safe_session_set_lattr(sess, true, \"group\", grpstr);\n\tmem_deref(grpstr);\n\tmem_deref(bundle.mb);\n\n\tsdp_encode(&mbb, sess, true);\n\tmbuf_strdup(mbb, &sdpres, mbb->end);\n\tmem_deref(mbb);\n\t\t\n\tif (flow_updateh) {\n\t\tflow_updateh(flow, sdpres);\n\t}\n\n\tmem_deref(sdpres);\n\tmem_deref(sess);\n\n\treturn err;\n}\n"], "fixing_code": ["/*\n* Wire\n* Copyright (C) 2020 Wire Swiss GmbH\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <re.h>\n#include <avs.h>\n\n\nstatic uint32_t g_mid = 1000;\n\nenum bundle_type {\n        BUNDLE_TYPE_AUDIO,\n        BUNDLE_TYPE_VIDEO,\n};\n\nstruct bundle {\n\tuint32_t mid;\n\tstruct mbuf *mb;\n};\n\n\nstatic struct sdp_media *find_media(struct sdp_session *sess,\n\t\t\t\t    const char *type)\n{\n\tstruct sdp_media *sdpm;\n\tconst struct list *medial;\n\tstruct le *le;\n\tbool found = false;\n\n\tif (!sess) {\n\t\treturn NULL;\n\t}\n\n\tmedial = sdp_session_medial(sess, false);\n\n\tfor (le = medial->head; le && !found; le = le->next) {\n\t\tsdpm = (struct sdp_media *)le->data;\n\t\t\n\t\tfound = streq(type, sdp_media_name(sdpm));\n\t}\n\n\treturn found ? sdpm : NULL;\n}\n\nstatic bool fmt_handler(struct sdp_format *fmt, void *arg)\n{\n\tstruct sdp_media *sdpm = (struct sdp_media *)arg;\n\n\tif (streq(sdp_media_name(sdpm), \"audio\")) {\n\t\tif (streq(fmt->name, \"opus\")) {\n\t\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t\t}\n\t}\n\telse if (streq(sdp_media_name(sdpm), \"video\")) {\n\t\tif (strcaseeq(fmt->name, \"vp8\")) {\n\t\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t\t}\n\t}\n\telse if (streq(sdp_media_name(sdpm), \"application\")) {\n\n\t\tsdp_format_add(NULL, sdpm, false,\n\t\t\t\t       fmt->id, fmt->name, fmt->srate, fmt->ch,\n\t\t\t\t       NULL, NULL, NULL, false, \"%s\", fmt->params);\n\t}\n\n\treturn false;\t\n}\n\n\nstatic bool media_rattr_handler(const char *name, const char *value, void *arg)\n{\n\tstruct sdp_media *sdpm = (struct sdp_media *)arg;\n\tbool should_set = false;\n\n\tshould_set = streq(name, \"fingerprint\")\n\t\t  || streq(name, \"ice-ufrag\")\n\t\t  || streq(name, \"ice-pwd\")\n\t\t  || streq(name, \"rtcp-mux\")\n\t\t  || streq(name, \"extmap\");\n\t\n\tif (should_set)\n\t\tsdp_safe_media_set_lattr(sdpm, false, name, value);\n\n\treturn false;\n}\n\n\nstatic void bundle_ssrc(enum bundle_type type, struct conf_member *cm,\n\t\t\tstruct bundle *bundle,\n\t\t\tstruct sdp_session *sess, struct sdp_media *sdpm)\n{\n\tstruct sdp_media *newm;\n\tconst char *mtype;\n\tuint32_t ssrc;\n\tuint32_t mid;\n\tbool disabled = false;\n\tint lport;\n\tint err;\n\n\tswitch (type) {\n\tcase BUNDLE_TYPE_AUDIO:\n\t\tssrc = cm->ssrca;\n\t\tmtype = sdp_media_audio;\n\t\tif (cm->mida == 0) {\n\t\t\tcm->mida = g_mid;\n\t\t\tg_mid++;\n\t\t}\n\t\tmid = cm->mida;\n\t\tbreak;\n\n\tcase BUNDLE_TYPE_VIDEO:\n\t\tssrc = cm->ssrcv;\n\t\tmtype = sdp_media_video;\n\t\tif (cm->midv == 0) {\n\t\t\tcm->midv = g_mid;\n\t\t\tg_mid++;\n\t\t}\n\t\tmid = cm->midv;\n\t\tbreak;\n\n\tdefault:\n\t\twarning(\"bundle_ssrc: unknown bundle type\\n\");\n\t\treturn;\n\t}\n\n\tdisabled = ssrc == 0 || !cm->active;\n\tlport = 9; //disabled ? 0 : 9;\n\terr = sdp_media_add(&newm, sess, mtype, lport,\n\t\t\t    sdp_media_proto(sdpm));\n\tif (err) {\n\t\twarning(\"bundle_ssrc: video add failed: %m\\n\", err);\n\t\treturn;\n\t}\n\t\n\tsdp_media_set_disabled(newm, false);\n\tsdp_media_set_laddr(newm, sdp_media_raddr(sdpm));\n\tsdp_media_set_lport(newm, lport);\n\tsdp_media_set_lattr(newm, false, \"mid\", \"%u\", mid);\n\tif (!disabled) {\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u cname:%s\",\n\t\t\t\t    ssrc, cm->cname);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u msid:%s %s\",\n\t\t\t\t    ssrc, cm->msid, cm->label);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u mslabel:%s\",\n\t\t\t\t    ssrc, cm->msid);\n\t\tsdp_media_set_lattr(newm, false, \"ssrc\", \"%u label:%s\",\n\t\t\t\t    ssrc, cm->label);\n\t}\n\n\tsdp_media_format_apply(sdpm, false, NULL, -1, NULL,\n\t\t\t       -1, -1, fmt_handler, newm);\n\n\tsdp_media_rattr_apply(sdpm, NULL,\n\t\t\t      media_rattr_handler, newm);\n\n\tsdp_media_set_ldir(newm, disabled ? SDP_INACTIVE : SDP_SENDONLY);\n\tsdp_media_set_lbandwidth(newm, SDP_BANDWIDTH_AS,\n\t\t\t\t sdp_media_rbandwidth(sdpm, SDP_BANDWIDTH_AS));\n\n\tmbuf_printf(bundle->mb, \" %u\", mid);\n}\n\n\nint bundle_update(struct iflow *flow,\n\t\t  enum icall_conv_type conv_type,\n\t\t  bool include_audio,\n\t\t  const char *remote_sdp,\n\t\t  struct list *membl,\n\t\t  bundle_flow_update_h *flow_updateh)\n{\n\tstruct sdp_media *sdpa = NULL;\n\tstruct sdp_media *sdpv = NULL;\n\tchar *grpstr;\n\tint err = 0;\n\tstruct le *le;\n\tstruct sdp_session *sess;\n\tstruct bundle bundle;\n\tchar *sdpres = NULL;\n\tstruct mbuf *mbb;\n\n\tsdp_dup(&sess, conv_type, remote_sdp, false);\n\tsdpa = find_media(sess, \"audio\");\n\tsdpv = find_media(sess, \"video\");\n\t\n\tbundle.mid = 0;\n\tbundle.mb = mbuf_alloc(128);\n\tmbuf_printf(bundle.mb, \"%s\", sdp_session_rattr(sess, \"group\"));\n\n\tlist_flush((struct list *)sdp_session_medial(sess, true));\n\t\n\tLIST_FOREACH(membl, le) {\n\t\tstruct conf_member *cm = (struct conf_member *)le->data;\n\n\t\tif (include_audio && sdpa)\n\t\t\tbundle_ssrc(BUNDLE_TYPE_AUDIO, cm, &bundle, sess, sdpa);\n\t\tif (sdpv && cm->ssrcv)\n\t\t\tbundle_ssrc(BUNDLE_TYPE_VIDEO, cm, &bundle, sess, sdpv);\n\t}\n\n\tbundle.mb->pos = 0;\n\tmbuf_strdup(bundle.mb, &grpstr, mbuf_get_left(bundle.mb));\n\tsdp_safe_session_set_lattr(sess, true, \"group\", grpstr);\n\tmem_deref(grpstr);\n\tmem_deref(bundle.mb);\n\n\tsdp_encode(&mbb, sess, true);\n\tmbuf_strdup(mbb, &sdpres, mbb->end);\n\tmem_deref(mbb);\n\t\t\n\tif (flow_updateh) {\n\t\tflow_updateh(flow, sdpres);\n\t}\n\n\tmem_deref(sdpres);\n\tmem_deref(sess);\n\n\treturn err;\n}\n"], "filenames": ["src/sdp/bundle.c"], "buggy_code_start_loc": [205], "buggy_code_end_loc": [206], "fixing_code_start_loc": [205], "fixing_code_end_loc": [206], "type": "CWE-134", "message": "wire-avs provides Audio, Visual, and Signaling (AVS) functionality sure the secure messaging software Wire. Prior to versions 9.2.22 and 9.3.5, a remote format string vulnerability could potentially allow an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 9.2.22 & 9.3.5 and is already included on all Wire products. No known workarounds are available.", "other": {"cve": {"id": "CVE-2023-48221", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-20T18:15:06.850", "lastModified": "2023-11-29T20:51:57.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wire-avs provides Audio, Visual, and Signaling (AVS) functionality sure the secure messaging software Wire. Prior to versions 9.2.22 and 9.3.5, a remote format string vulnerability could potentially allow an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 9.2.22 & 9.3.5 and is already included on all Wire products. No known workarounds are available."}, {"lang": "es", "value": "wire-avs proporciona funcionalidad de Audio, Visual, and Signaling (AVS) en el software de mensajer\u00eda segura Wire. Antes de las versiones 9.2.22 y 9.3.5, una vulnerabilidad de cadena de formato remoto podr\u00eda permitir a un atacante provocar una Denegaci\u00f3n de Servicio o posiblemente ejecutar c\u00f3digo arbitrario. El problema se solucion\u00f3 en wire-avs 9.2.22 y 9.3.5 y ya est\u00e1 incluido en todos los productos Wire. No hay workarounds conocidos disponibles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:audio\\,_video\\,_and_signaling:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.22", "matchCriteriaId": "0824D9AA-1F5B-4F7E-BB83-5472539AE5E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:audio\\,_video\\,_and_signaling:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndIncluding": "9.3.5", "matchCriteriaId": "30DFE66C-5656-4EDF-95C5-9405B080A6AB"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-avs/commit/364c3326a1331a84607bce2e17126306d39150cd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wireapp/wire-avs/security/advisories/GHSA-m4xg-fcr3-w3pq", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-avs/commit/364c3326a1331a84607bce2e17126306d39150cd"}}