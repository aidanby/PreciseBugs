{"buggy_code": ["/*\n *  Copyright (C) 2001,2002 Constantin Kaplinsky.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * cursor.c - code to support cursor shape updates (XCursor and\n * RichCursor preudo-encodings).\n */\n\n#include <rfb/rfbclient.h>\n\n\n#define OPER_SAVE     0\n#define OPER_RESTORE  1\n\n#define RGB24_TO_PIXEL(bpp,r,g,b)                                       \\\n   ((((uint##bpp##_t)(r) & 0xFF) * client->format.redMax + 127) / 255             \\\n    << client->format.redShift |                                              \\\n    (((uint##bpp##_t)(g) & 0xFF) * client->format.greenMax + 127) / 255           \\\n    << client->format.greenShift |                                            \\\n    (((uint##bpp##_t)(b) & 0xFF) * client->format.blueMax + 127) / 255            \\\n    << client->format.blueShift)\n\n\nrfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)\n{\n  int bytesPerPixel;\n  size_t bytesPerRow, bytesMaskData;\n  rfbXCursorColors rgb;\n  uint32_t colors[2];\n  char *buf;\n  uint8_t *ptr;\n  int x, y, b;\n\n  bytesPerPixel = client->format.bitsPerPixel / 8;\n  bytesPerRow = (width + 7) / 8;\n  bytesMaskData = bytesPerRow * height;\n\n  if (width * height == 0)\n    return TRUE;\n\n  /* Allocate memory for pixel data and temporary mask data. */\n  if(client->rcSource)\n    free(client->rcSource);\n\n  client->rcSource = malloc(width * height * bytesPerPixel);\n  if (client->rcSource == NULL)\n    return FALSE;\n\n  buf = malloc(bytesMaskData);\n  if (buf == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    return FALSE;\n  }\n\n  /* Read and decode cursor pixel data, depending on the encoding type. */\n\n  if (enc == rfbEncodingXCursor) {\n    /* Read and convert background and foreground colors. */\n    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);\n    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);\n\n    /* Read 1bpp pixel data into a temporary buffer. */\n    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n    /* Convert 1bpp data to byte-wide color indices. */\n    ptr = client->rcSource;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width / 8; x++) {\n\tfor (b = 7; b >= 0; b--) {\n\t  *ptr = buf[y * bytesPerRow + x] >> b & 1;\n\t  ptr += bytesPerPixel;\n\t}\n      }\n      for (b = 7; b > 7 - width % 8; b--) {\n\t*ptr = buf[y * bytesPerRow + x] >> b & 1;\n\tptr += bytesPerPixel;\n      }\n    }\n\n    /* Convert indices into the actual pixel values. */\n    switch (bytesPerPixel) {\n    case 1:\n      for (x = 0; x < width * height; x++)\n\tclient->rcSource[x] = (uint8_t)colors[client->rcSource[x]];\n      break;\n    case 2:\n      for (x = 0; x < width * height; x++)\n\t((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];\n      break;\n    case 4:\n      for (x = 0; x < width * height; x++)\n\t((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];\n      break;\n    }\n\n  } else {\t\t\t/* enc == rfbEncodingRichCursor */\n\n    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n  }\n\n  /* Read and decode mask data. */\n\n  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  client->rcMask = malloc(width * height);\n  if (client->rcMask == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  ptr = client->rcMask;\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width / 8; x++) {\n      for (b = 7; b >= 0; b--) {\n\t*ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n      }\n    }\n    for (b = 7; b > 7 - width % 8; b--) {\n      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n    }\n  }\n\n  if (client->GotCursorShape != NULL) {\n     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);\n  }\n\n  free(buf);\n\n  return TRUE;\n}\n\n\n"], "fixing_code": ["/*\n *  Copyright (C) 2001,2002 Constantin Kaplinsky.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * cursor.c - code to support cursor shape updates (XCursor and\n * RichCursor preudo-encodings).\n */\n\n#include <rfb/rfbclient.h>\n\n\n#define OPER_SAVE     0\n#define OPER_RESTORE  1\n\n#define MAX_CURSOR_SIZE 1024\n\n#define RGB24_TO_PIXEL(bpp,r,g,b)                                       \\\n   ((((uint##bpp##_t)(r) & 0xFF) * client->format.redMax + 127) / 255             \\\n    << client->format.redShift |                                              \\\n    (((uint##bpp##_t)(g) & 0xFF) * client->format.greenMax + 127) / 255           \\\n    << client->format.greenShift |                                            \\\n    (((uint##bpp##_t)(b) & 0xFF) * client->format.blueMax + 127) / 255            \\\n    << client->format.blueShift)\n\n\nrfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)\n{\n  int bytesPerPixel;\n  size_t bytesPerRow, bytesMaskData;\n  rfbXCursorColors rgb;\n  uint32_t colors[2];\n  char *buf;\n  uint8_t *ptr;\n  int x, y, b;\n\n  bytesPerPixel = client->format.bitsPerPixel / 8;\n  bytesPerRow = (width + 7) / 8;\n  bytesMaskData = bytesPerRow * height;\n\n  if (width * height == 0)\n    return TRUE;\n\n  if (width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE)\n    return FALSE;\n\n  /* Allocate memory for pixel data and temporary mask data. */\n  if(client->rcSource)\n    free(client->rcSource);\n\n  client->rcSource = malloc(width * height * bytesPerPixel);\n  if (client->rcSource == NULL)\n    return FALSE;\n\n  buf = malloc(bytesMaskData);\n  if (buf == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    return FALSE;\n  }\n\n  /* Read and decode cursor pixel data, depending on the encoding type. */\n\n  if (enc == rfbEncodingXCursor) {\n    /* Read and convert background and foreground colors. */\n    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);\n    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);\n\n    /* Read 1bpp pixel data into a temporary buffer. */\n    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n    /* Convert 1bpp data to byte-wide color indices. */\n    ptr = client->rcSource;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width / 8; x++) {\n\tfor (b = 7; b >= 0; b--) {\n\t  *ptr = buf[y * bytesPerRow + x] >> b & 1;\n\t  ptr += bytesPerPixel;\n\t}\n      }\n      for (b = 7; b > 7 - width % 8; b--) {\n\t*ptr = buf[y * bytesPerRow + x] >> b & 1;\n\tptr += bytesPerPixel;\n      }\n    }\n\n    /* Convert indices into the actual pixel values. */\n    switch (bytesPerPixel) {\n    case 1:\n      for (x = 0; x < width * height; x++)\n\tclient->rcSource[x] = (uint8_t)colors[client->rcSource[x]];\n      break;\n    case 2:\n      for (x = 0; x < width * height; x++)\n\t((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];\n      break;\n    case 4:\n      for (x = 0; x < width * height; x++)\n\t((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];\n      break;\n    }\n\n  } else {\t\t\t/* enc == rfbEncodingRichCursor */\n\n    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n  }\n\n  /* Read and decode mask data. */\n\n  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  client->rcMask = malloc(width * height);\n  if (client->rcMask == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  ptr = client->rcMask;\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width / 8; x++) {\n      for (b = 7; b >= 0; b--) {\n\t*ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n      }\n    }\n    for (b = 7; b > 7 - width % 8; b--) {\n      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n    }\n  }\n\n  if (client->GotCursorShape != NULL) {\n     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);\n  }\n\n  free(buf);\n\n  return TRUE;\n}\n\n\n"], "filenames": ["libvncclient/cursor.c"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [55], "fixing_code_start_loc": [31], "fixing_code_end_loc": [61], "type": "CWE-190", "message": "libvncclient/cursor.c in LibVNCServer through 0.9.12 has a HandleCursorShape integer overflow and heap-based buffer overflow via a large height or width value. NOTE: this may overlap CVE-2019-15690.", "other": {"cve": {"id": "CVE-2019-20788", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-23T19:15:12.763", "lastModified": "2022-03-10T14:54:00.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libvncclient/cursor.c in LibVNCServer through 0.9.12 has a HandleCursorShape integer overflow and heap-based buffer overflow via a large height or width value. NOTE: this may overlap CVE-2019-15690."}, {"lang": "es", "value": "En la biblioteca libvncclient/cursor.c en LibVNCServer versiones hasta 0.9.12, tiene un desbordamiento de enteros en la funci\u00f3n HandleCursorShape y un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria por medio de un valor de alto o ancho grande."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.12", "matchCriteriaId": "A03A7282-D445-4E26-98A0-6A1597838D35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/54220248886b5001fbbb9fa73c4e1a2cb9413fed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2020-064-libvnc-libvncclient", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4407-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/54220248886b5001fbbb9fa73c4e1a2cb9413fed"}}