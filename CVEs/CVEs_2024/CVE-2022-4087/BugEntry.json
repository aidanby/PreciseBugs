{"buggy_code": ["/*\n * Copyright (C) 2007 Michael Brown <mbrown@fensystems.co.uk>.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\nFILE_LICENCE ( GPL2_OR_LATER );\n\n/**\n * @file\n *\n * Transport Layer Security Protocol\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <byteswap.h>\n#include <ipxe/pending.h>\n#include <ipxe/hmac.h>\n#include <ipxe/md5.h>\n#include <ipxe/sha1.h>\n#include <ipxe/sha256.h>\n#include <ipxe/aes.h>\n#include <ipxe/rsa.h>\n#include <ipxe/iobuf.h>\n#include <ipxe/xfer.h>\n#include <ipxe/open.h>\n#include <ipxe/x509.h>\n#include <ipxe/privkey.h>\n#include <ipxe/certstore.h>\n#include <ipxe/rootcert.h>\n#include <ipxe/rbg.h>\n#include <ipxe/validator.h>\n#include <ipxe/job.h>\n#include <ipxe/dhe.h>\n#include <ipxe/tls.h>\n#include <config/crypto.h>\n\n/* Disambiguate the various error causes */\n#define EINVAL_CHANGE_CIPHER __einfo_error ( EINFO_EINVAL_CHANGE_CIPHER )\n#define EINFO_EINVAL_CHANGE_CIPHER\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x01,\t\t\t\t\\\n\t\t\t  \"Invalid Change Cipher record\" )\n#define EINVAL_ALERT __einfo_error ( EINFO_EINVAL_ALERT )\n#define EINFO_EINVAL_ALERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x02,\t\t\t\t\\\n\t\t\t  \"Invalid Alert record\" )\n#define EINVAL_HELLO __einfo_error ( EINFO_EINVAL_HELLO )\n#define EINFO_EINVAL_HELLO\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x03,\t\t\t\t\\\n\t\t\t  \"Invalid Server Hello record\" )\n#define EINVAL_CERTIFICATE __einfo_error ( EINFO_EINVAL_CERTIFICATE )\n#define EINFO_EINVAL_CERTIFICATE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x04,\t\t\t\t\\\n\t\t\t  \"Invalid Certificate\" )\n#define EINVAL_CERTIFICATES __einfo_error ( EINFO_EINVAL_CERTIFICATES )\n#define EINFO_EINVAL_CERTIFICATES\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x05,\t\t\t\t\\\n\t\t\t  \"Invalid Server Certificate record\" )\n#define EINVAL_HELLO_DONE __einfo_error ( EINFO_EINVAL_HELLO_DONE )\n#define EINFO_EINVAL_HELLO_DONE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x06,\t\t\t\t\\\n\t\t\t  \"Invalid Server Hello Done record\" )\n#define EINVAL_FINISHED __einfo_error ( EINFO_EINVAL_FINISHED )\n#define EINFO_EINVAL_FINISHED\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x07,\t\t\t\t\\\n\t\t\t  \"Invalid Server Finished record\" )\n#define EINVAL_HANDSHAKE __einfo_error ( EINFO_EINVAL_HANDSHAKE )\n#define EINFO_EINVAL_HANDSHAKE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x08,\t\t\t\t\\\n\t\t\t  \"Invalid Handshake record\" )\n#define EINVAL_IV __einfo_error ( EINFO_EINVAL_IV )\n#define EINFO_EINVAL_IV\t\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0a,\t\t\t\t\\\n\t\t\t  \"Invalid initialisation vector\" )\n#define EINVAL_PADDING __einfo_error ( EINFO_EINVAL_PADDING )\n#define EINFO_EINVAL_PADDING\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0b,\t\t\t\t\\\n\t\t\t  \"Invalid block padding\" )\n#define EINVAL_RX_STATE __einfo_error ( EINFO_EINVAL_RX_STATE )\n#define EINFO_EINVAL_RX_STATE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0c,\t\t\t\t\\\n\t\t\t  \"Invalid receive state\" )\n#define EINVAL_MAC __einfo_error ( EINFO_EINVAL_MAC )\n#define EINFO_EINVAL_MAC\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0d,\t\t\t\t\\\n\t\t\t  \"Invalid MAC\" )\n#define EINVAL_TICKET __einfo_error ( EINFO_EINVAL_TICKET )\n#define EINFO_EINVAL_TICKET\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0e,\t\t\t\t\\\n\t\t\t  \"Invalid New Session Ticket record\")\n#define EINVAL_KEY_EXCHANGE __einfo_error ( EINFO_EINVAL_KEY_EXCHANGE )\n#define EINFO_EINVAL_KEY_EXCHANGE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0f,\t\t\t\t\\\n\t\t\t  \"Invalid Server Key Exchange record\" )\n#define EIO_ALERT __einfo_error ( EINFO_EIO_ALERT )\n#define EINFO_EIO_ALERT\t\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EIO, 0x01,\t\t\t\t\\\n\t\t\t  \"Unknown alert level\" )\n#define ENOMEM_CONTEXT __einfo_error ( EINFO_ENOMEM_CONTEXT )\n#define EINFO_ENOMEM_CONTEXT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x01,\t\t\t\t\\\n\t\t\t  \"Not enough space for crypto context\" )\n#define ENOMEM_CERTIFICATE __einfo_error ( EINFO_ENOMEM_CERTIFICATE )\n#define EINFO_ENOMEM_CERTIFICATE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x02,\t\t\t\t\\\n\t\t\t  \"Not enough space for certificate\" )\n#define ENOMEM_CHAIN __einfo_error ( EINFO_ENOMEM_CHAIN )\n#define EINFO_ENOMEM_CHAIN\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x03,\t\t\t\t\\\n\t\t\t  \"Not enough space for certificate chain\" )\n#define ENOMEM_TX_PLAINTEXT __einfo_error ( EINFO_ENOMEM_TX_PLAINTEXT )\n#define EINFO_ENOMEM_TX_PLAINTEXT\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x04,\t\t\t\t\\\n\t\t\t  \"Not enough space for transmitted plaintext\" )\n#define ENOMEM_TX_CIPHERTEXT __einfo_error ( EINFO_ENOMEM_TX_CIPHERTEXT )\n#define EINFO_ENOMEM_TX_CIPHERTEXT\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x05,\t\t\t\t\\\n\t\t\t  \"Not enough space for transmitted ciphertext\" )\n#define ENOMEM_RX_DATA __einfo_error ( EINFO_ENOMEM_RX_DATA )\n#define EINFO_ENOMEM_RX_DATA\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x07,\t\t\t\t\\\n\t\t\t  \"Not enough space for received data\" )\n#define ENOMEM_RX_CONCAT __einfo_error ( EINFO_ENOMEM_RX_CONCAT )\n#define EINFO_ENOMEM_RX_CONCAT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x08,\t\t\t\t\\\n\t\t\t  \"Not enough space to concatenate received data\" )\n#define ENOTSUP_CIPHER __einfo_error ( EINFO_ENOTSUP_CIPHER )\n#define EINFO_ENOTSUP_CIPHER\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x01,\t\t\t\t\\\n\t\t\t  \"Unsupported cipher\" )\n#define ENOTSUP_NULL __einfo_error ( EINFO_ENOTSUP_NULL )\n#define EINFO_ENOTSUP_NULL\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x02,\t\t\t\t\\\n\t\t\t  \"Refusing to use null cipher\" )\n#define ENOTSUP_SIG_HASH __einfo_error ( EINFO_ENOTSUP_SIG_HASH )\n#define EINFO_ENOTSUP_SIG_HASH\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x03,\t\t\t\t\\\n\t\t\t  \"Unsupported signature and hash algorithm\" )\n#define ENOTSUP_VERSION __einfo_error ( EINFO_ENOTSUP_VERSION )\n#define EINFO_ENOTSUP_VERSION\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x04,\t\t\t\t\\\n\t\t\t  \"Unsupported protocol version\" )\n#define EPERM_ALERT __einfo_error ( EINFO_EPERM_ALERT )\n#define EINFO_EPERM_ALERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x01,\t\t\t\t\\\n\t\t\t  \"Received fatal alert\" )\n#define EPERM_VERIFY __einfo_error ( EINFO_EPERM_VERIFY )\n#define EINFO_EPERM_VERIFY\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x02,\t\t\t\t\\\n\t\t\t  \"Handshake verification failed\" )\n#define EPERM_CLIENT_CERT __einfo_error ( EINFO_EPERM_CLIENT_CERT )\n#define EINFO_EPERM_CLIENT_CERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x03,\t\t\t\t\\\n\t\t\t  \"No suitable client certificate available\" )\n#define EPERM_RENEG_INSECURE __einfo_error ( EINFO_EPERM_RENEG_INSECURE )\n#define EINFO_EPERM_RENEG_INSECURE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x04,\t\t\t\t\\\n\t\t\t  \"Secure renegotiation not supported\" )\n#define EPERM_RENEG_VERIFY __einfo_error ( EINFO_EPERM_RENEG_VERIFY )\n#define EINFO_EPERM_RENEG_VERIFY\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x05,\t\t\t\t\\\n\t\t\t  \"Secure renegotiation verification failed\" )\n#define EPERM_KEY_EXCHANGE __einfo_error ( EINFO_EPERM_KEY_EXCHANGE )\n#define EINFO_EPERM_KEY_EXCHANGE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x06,\t\t\t\t\\\n\t\t\t  \"ServerKeyExchange verification failed\" )\n#define EPROTO_VERSION __einfo_error ( EINFO_EPROTO_VERSION )\n#define EINFO_EPROTO_VERSION\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPROTO, 0x01,\t\t\t\t\\\n\t\t\t  \"Illegal protocol version upgrade\" )\n\n/** List of TLS session */\nstatic LIST_HEAD ( tls_sessions );\n\nstatic void tls_tx_resume_all ( struct tls_session *session );\nstatic int tls_send_plaintext ( struct tls_connection *tls, unsigned int type,\n\t\t\t\tconst void *data, size_t len );\nstatic void tls_clear_cipher ( struct tls_connection *tls,\n\t\t\t       struct tls_cipherspec *cipherspec );\n\n/******************************************************************************\n *\n * Utility functions\n *\n ******************************************************************************\n */\n\n/** A TLS 24-bit integer\n *\n * TLS uses 24-bit integers in several places, which are awkward to\n * parse in C.\n */\ntypedef struct {\n\t/** High byte */\n\tuint8_t high;\n\t/** Low word */\n\tuint16_t low;\n} __attribute__ (( packed )) tls24_t;\n\n/**\n * Extract 24-bit field value\n *\n * @v field24\t\t24-bit field\n * @ret value\t\tField value\n *\n */\nstatic inline __attribute__ (( always_inline )) unsigned long\ntls_uint24 ( const tls24_t *field24 ) {\n\n\treturn ( ( field24->high << 16 ) | be16_to_cpu ( field24->low ) );\n}\n\n/**\n * Set 24-bit field value\n *\n * @v field24\t\t24-bit field\n * @v value\t\tField value\n */\nstatic void tls_set_uint24 ( tls24_t *field24, unsigned long value ) {\n\n\tfield24->high = ( value >> 16 );\n\tfield24->low = cpu_to_be16 ( value );\n}\n\n/**\n * Determine if TLS connection is ready for application data\n *\n * @v tls\t\tTLS connection\n * @ret is_ready\tTLS connection is ready\n */\nstatic int tls_ready ( struct tls_connection *tls ) {\n\treturn ( ( ! is_pending ( &tls->client_negotiation ) ) &&\n\t\t ( ! is_pending ( &tls->server_negotiation ) ) );\n}\n\n/**\n * Check for TLS version\n *\n * @v tls\t\tTLS connection\n * @v version\t\tTLS version\n * @ret at_least\tTLS connection is using at least the specified version\n *\n * Check that TLS connection uses at least the specified protocol\n * version.  Optimise down to a compile-time constant true result if\n * this is already guaranteed by the minimum supported version check.\n */\nstatic inline __attribute__ (( always_inline )) int\ntls_version ( struct tls_connection *tls, unsigned int version ) {\n\treturn ( ( TLS_VERSION_MIN >= version ) ||\n\t\t ( tls->version >= version ) );\n}\n\n/******************************************************************************\n *\n * Hybrid MD5+SHA1 hash as used by TLSv1.1 and earlier\n *\n ******************************************************************************\n */\n\n/**\n * Initialise MD5+SHA1 algorithm\n *\n * @v ctx\t\tMD5+SHA1 context\n */\nstatic void md5_sha1_init ( void *ctx ) {\n\tstruct md5_sha1_context *context = ctx;\n\n\tdigest_init ( &md5_algorithm, context->md5 );\n\tdigest_init ( &sha1_algorithm, context->sha1 );\n}\n\n/**\n * Accumulate data with MD5+SHA1 algorithm\n *\n * @v ctx\t\tMD5+SHA1 context\n * @v data\t\tData\n * @v len\t\tLength of data\n */\nstatic void md5_sha1_update ( void *ctx, const void *data, size_t len ) {\n\tstruct md5_sha1_context *context = ctx;\n\n\tdigest_update ( &md5_algorithm, context->md5, data, len );\n\tdigest_update ( &sha1_algorithm, context->sha1, data, len );\n}\n\n/**\n * Generate MD5+SHA1 digest\n *\n * @v ctx\t\tMD5+SHA1 context\n * @v out\t\tOutput buffer\n */\nstatic void md5_sha1_final ( void *ctx, void *out ) {\n\tstruct md5_sha1_context *context = ctx;\n\tstruct md5_sha1_digest *digest = out;\n\n\tdigest_final ( &md5_algorithm, context->md5, digest->md5 );\n\tdigest_final ( &sha1_algorithm, context->sha1, digest->sha1 );\n}\n\n/** Hybrid MD5+SHA1 digest algorithm */\nstatic struct digest_algorithm md5_sha1_algorithm = {\n\t.name\t\t= \"md5+sha1\",\n\t.ctxsize\t= sizeof ( struct md5_sha1_context ),\n\t.blocksize\t= 0, /* Not applicable */\n\t.digestsize\t= sizeof ( struct md5_sha1_digest ),\n\t.init\t\t= md5_sha1_init,\n\t.update\t\t= md5_sha1_update,\n\t.final\t\t= md5_sha1_final,\n};\n\n/** RSA digestInfo prefix for MD5+SHA1 algorithm */\nstruct rsa_digestinfo_prefix rsa_md5_sha1_prefix __rsa_digestinfo_prefix = {\n\t.digest = &md5_sha1_algorithm,\n\t.data = NULL, /* MD5+SHA1 signatures have no digestInfo */\n\t.len = 0,\n};\n\n/******************************************************************************\n *\n * Cleanup functions\n *\n ******************************************************************************\n */\n\n/**\n * Free TLS session\n *\n * @v refcnt\t\tReference counter\n */\nstatic void free_tls_session ( struct refcnt *refcnt ) {\n\tstruct tls_session *session =\n\t\tcontainer_of ( refcnt, struct tls_session, refcnt );\n\n\t/* Sanity check */\n\tassert ( list_empty ( &session->conn ) );\n\n\t/* Remove from list of sessions */\n\tlist_del ( &session->list );\n\n\t/* Free dynamically-allocated resources */\n\tx509_root_put ( session->root );\n\tprivkey_put ( session->key );\n\tfree ( session->ticket );\n\n\t/* Free session */\n\tfree ( session );\n}\n\n/**\n * Free TLS connection\n *\n * @v refcnt\t\tReference counter\n */\nstatic void free_tls ( struct refcnt *refcnt ) {\n\tstruct tls_connection *tls =\n\t\tcontainer_of ( refcnt, struct tls_connection, refcnt );\n\tstruct tls_session *session = tls->session;\n\tstruct io_buffer *iobuf;\n\tstruct io_buffer *tmp;\n\n\t/* Free dynamically-allocated resources */\n\tfree ( tls->new_session_ticket );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec_pending );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec_pending );\n\tfree ( tls->server_key );\n\tlist_for_each_entry_safe ( iobuf, tmp, &tls->rx_data, list ) {\n\t\tlist_del ( &iobuf->list );\n\t\tfree_iob ( iobuf );\n\t}\n\tx509_chain_put ( tls->certs );\n\tx509_chain_put ( tls->chain );\n\tx509_root_put ( tls->root );\n\tprivkey_put ( tls->key );\n\n\t/* Drop reference to session */\n\tassert ( list_empty ( &tls->list ) );\n\tref_put ( &session->refcnt );\n\n\t/* Free TLS structure itself */\n\tfree ( tls );\n}\n\n/**\n * Finish with TLS connection\n *\n * @v tls\t\tTLS connection\n * @v rc\t\tStatus code\n */\nstatic void tls_close ( struct tls_connection *tls, int rc ) {\n\n\t/* Remove pending operations, if applicable */\n\tpending_put ( &tls->client_negotiation );\n\tpending_put ( &tls->server_negotiation );\n\tpending_put ( &tls->validation );\n\n\t/* Remove process */\n\tprocess_del ( &tls->process );\n\n\t/* Close all interfaces */\n\tintf_shutdown ( &tls->cipherstream, rc );\n\tintf_shutdown ( &tls->plainstream, rc );\n\tintf_shutdown ( &tls->validator, rc );\n\n\t/* Remove from session */\n\tlist_del ( &tls->list );\n\tINIT_LIST_HEAD ( &tls->list );\n\n\t/* Resume all other connections, in case we were the lead connection */\n\ttls_tx_resume_all ( tls->session );\n}\n\n/******************************************************************************\n *\n * Random number generation\n *\n ******************************************************************************\n */\n\n/**\n * Generate random data\n *\n * @v tls\t\tTLS connection\n * @v data\t\tBuffer to fill\n * @v len\t\tLength of buffer\n * @ret rc\t\tReturn status code\n */\nstatic int tls_generate_random ( struct tls_connection *tls,\n\t\t\t\t void *data, size_t len ) {\n\tint rc;\n\n\t/* Generate random bits with no additional input and without\n\t * prediction resistance\n\t */\n\tif ( ( rc = rbg_generate ( NULL, 0, 0, data, len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not generate random data: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Update HMAC with a list of ( data, len ) pairs\n *\n * @v digest\t\tHash function to use\n * @v ctx\t\tHMAC context\n * @v args\t\t( data, len ) pairs of data, terminated by NULL\n */\nstatic void tls_hmac_update_va ( struct digest_algorithm *digest,\n\t\t\t\t void *ctx, va_list args ) {\n\tvoid *data;\n\tsize_t len;\n\n\twhile ( ( data = va_arg ( args, void * ) ) ) {\n\t\tlen = va_arg ( args, size_t );\n\t\thmac_update ( digest, ctx, data, len );\n\t}\n}\n\n/**\n * Generate secure pseudo-random data using a single hash function\n *\n * @v tls\t\tTLS connection\n * @v digest\t\tHash function to use\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v seeds\t\t( data, len ) pairs of seed data, terminated by NULL\n */\nstatic void tls_p_hash_va ( struct tls_connection *tls,\n\t\t\t    struct digest_algorithm *digest,\n\t\t\t    const void *secret, size_t secret_len,\n\t\t\t    void *out, size_t out_len,\n\t\t\t    va_list seeds ) {\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\tuint8_t ctx_partial[ sizeof ( ctx ) ];\n\tuint8_t a[digest->digestsize];\n\tuint8_t out_tmp[digest->digestsize];\n\tsize_t frag_len = digest->digestsize;\n\tva_list tmp;\n\n\tDBGC2 ( tls, \"TLS %p %s secret:\\n\", tls, digest->name );\n\tDBGC2_HD ( tls, secret, secret_len );\n\n\t/* Calculate A(1) */\n\thmac_init ( digest, ctx, secret, secret_len );\n\tva_copy ( tmp, seeds );\n\ttls_hmac_update_va ( digest, ctx, tmp );\n\tva_end ( tmp );\n\thmac_final ( digest, ctx, a );\n\tDBGC2 ( tls, \"TLS %p %s A(1):\\n\", tls, digest->name );\n\tDBGC2_HD ( tls, &a, sizeof ( a ) );\n\n\t/* Generate as much data as required */\n\twhile ( out_len ) {\n\t\t/* Calculate output portion */\n\t\thmac_init ( digest, ctx, secret, secret_len );\n\t\thmac_update ( digest, ctx, a, sizeof ( a ) );\n\t\tmemcpy ( ctx_partial, ctx, sizeof ( ctx_partial ) );\n\t\tva_copy ( tmp, seeds );\n\t\ttls_hmac_update_va ( digest, ctx, tmp );\n\t\tva_end ( tmp );\n\t\thmac_final ( digest, ctx, out_tmp );\n\n\t\t/* Copy output */\n\t\tif ( frag_len > out_len )\n\t\t\tfrag_len = out_len;\n\t\tmemcpy ( out, out_tmp, frag_len );\n\t\tDBGC2 ( tls, \"TLS %p %s output:\\n\", tls, digest->name );\n\t\tDBGC2_HD ( tls, out, frag_len );\n\n\t\t/* Calculate A(i) */\n\t\thmac_final ( digest, ctx_partial, a );\n\t\tDBGC2 ( tls, \"TLS %p %s A(n):\\n\", tls, digest->name );\n\t\tDBGC2_HD ( tls, &a, sizeof ( a ) );\n\n\t\tout += frag_len;\n\t\tout_len -= frag_len;\n\t}\n}\n\n/**\n * Generate secure pseudo-random data\n *\n * @v tls\t\tTLS connection\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v ...\t\t( data, len ) pairs of seed data, terminated by NULL\n */\nstatic void tls_prf ( struct tls_connection *tls, const void *secret,\n\t\t      size_t secret_len, void *out, size_t out_len, ... ) {\n\tva_list seeds;\n\tva_list tmp;\n\tsize_t subsecret_len;\n\tconst void *md5_secret;\n\tconst void *sha1_secret;\n\tuint8_t buf[out_len];\n\tunsigned int i;\n\n\tva_start ( seeds, out_len );\n\n\tif ( tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\t/* Use P_SHA256 for TLSv1.2 and later */\n\t\ttls_p_hash_va ( tls, &sha256_algorithm, secret, secret_len,\n\t\t\t\tout, out_len, seeds );\n\t} else {\n\t\t/* Use combination of P_MD5 and P_SHA-1 for TLSv1.1\n\t\t * and earlier\n\t\t */\n\n\t\t/* Split secret into two, with an overlap of up to one byte */\n\t\tsubsecret_len = ( ( secret_len + 1 ) / 2 );\n\t\tmd5_secret = secret;\n\t\tsha1_secret = ( secret + secret_len - subsecret_len );\n\n\t\t/* Calculate MD5 portion */\n\t\tva_copy ( tmp, seeds );\n\t\ttls_p_hash_va ( tls, &md5_algorithm, md5_secret,\n\t\t\t\tsubsecret_len, out, out_len, seeds );\n\t\tva_end ( tmp );\n\n\t\t/* Calculate SHA1 portion */\n\t\tva_copy ( tmp, seeds );\n\t\ttls_p_hash_va ( tls, &sha1_algorithm, sha1_secret,\n\t\t\t\tsubsecret_len, buf, out_len, seeds );\n\t\tva_end ( tmp );\n\n\t\t/* XOR the two portions together into the final output buffer */\n\t\tfor ( i = 0 ; i < out_len ; i++ )\n\t\t\t*( ( uint8_t * ) out + i ) ^= buf[i];\n\t}\n\n\tva_end ( seeds );\n}\n\n/**\n * Generate secure pseudo-random data\n *\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v label\t\tString literal label\n * @v ...\t\t( data, len ) pairs of seed data\n */\n#define tls_prf_label( tls, secret, secret_len, out, out_len, label, ... ) \\\n\ttls_prf ( (tls), (secret), (secret_len), (out), (out_len),\t   \\\n\t\t  label, ( sizeof ( label ) - 1 ), __VA_ARGS__, NULL )\n\n/******************************************************************************\n *\n * Secret management\n *\n ******************************************************************************\n */\n\n/**\n * Generate master secret\n *\n * @v tls\t\tTLS connection\n * @v pre_master_secret\tPre-master secret\n * @v pre_master_secret_len Length of pre-master secret\n *\n * The client and server random values must already be known.\n */\nstatic void tls_generate_master_secret ( struct tls_connection *tls,\n\t\t\t\t\t const void *pre_master_secret,\n\t\t\t\t\t size_t pre_master_secret_len ) {\n\n\tDBGC ( tls, \"TLS %p pre-master-secret:\\n\", tls );\n\tDBGC_HD ( tls, pre_master_secret, pre_master_secret_len );\n\tDBGC ( tls, \"TLS %p client random bytes:\\n\", tls );\n\tDBGC_HD ( tls, &tls->client_random, sizeof ( tls->client_random ) );\n\tDBGC ( tls, \"TLS %p server random bytes:\\n\", tls );\n\tDBGC_HD ( tls, &tls->server_random, sizeof ( tls->server_random ) );\n\n\ttls_prf_label ( tls, pre_master_secret, pre_master_secret_len,\n\t\t\t&tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\t\"master secret\",\n\t\t\t&tls->client_random, sizeof ( tls->client_random ),\n\t\t\t&tls->server_random, sizeof ( tls->server_random ) );\n\n\tDBGC ( tls, \"TLS %p generated master secret:\\n\", tls );\n\tDBGC_HD ( tls, &tls->master_secret, sizeof ( tls->master_secret ) );\n}\n\n/**\n * Generate key material\n *\n * @v tls\t\tTLS connection\n *\n * The master secret must already be known.\n */\nstatic int tls_generate_keys ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *tx_cipherspec = &tls->tx_cipherspec_pending;\n\tstruct tls_cipherspec *rx_cipherspec = &tls->rx_cipherspec_pending;\n\tsize_t hash_size = tx_cipherspec->suite->mac_len;\n\tsize_t key_size = tx_cipherspec->suite->key_len;\n\tsize_t iv_size = tx_cipherspec->suite->fixed_iv_len;\n\tsize_t total = ( 2 * ( hash_size + key_size + iv_size ) );\n\tuint8_t key_block[total];\n\tuint8_t *key;\n\tint rc;\n\n\t/* Generate key block */\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\tkey_block, sizeof ( key_block ), \"key expansion\",\n\t\t\t&tls->server_random, sizeof ( tls->server_random ),\n\t\t\t&tls->client_random, sizeof ( tls->client_random ) );\n\n\t/* Split key block into portions */\n\tkey = key_block;\n\n\t/* TX MAC secret */\n\tmemcpy ( tx_cipherspec->mac_secret, key, hash_size );\n\tDBGC ( tls, \"TLS %p TX MAC secret:\\n\", tls );\n\tDBGC_HD ( tls, key, hash_size );\n\tkey += hash_size;\n\n\t/* RX MAC secret */\n\tmemcpy ( rx_cipherspec->mac_secret, key, hash_size );\n\tDBGC ( tls, \"TLS %p RX MAC secret:\\n\", tls );\n\tDBGC_HD ( tls, key, hash_size );\n\tkey += hash_size;\n\n\t/* TX key */\n\tif ( ( rc = cipher_setkey ( tx_cipherspec->suite->cipher,\n\t\t\t\t    tx_cipherspec->cipher_ctx,\n\t\t\t\t    key, key_size ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not set TX key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tDBGC ( tls, \"TLS %p TX key:\\n\", tls );\n\tDBGC_HD ( tls, key, key_size );\n\tkey += key_size;\n\n\t/* RX key */\n\tif ( ( rc = cipher_setkey ( rx_cipherspec->suite->cipher,\n\t\t\t\t    rx_cipherspec->cipher_ctx,\n\t\t\t\t    key, key_size ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not set TX key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tDBGC ( tls, \"TLS %p RX key:\\n\", tls );\n\tDBGC_HD ( tls, key, key_size );\n\tkey += key_size;\n\n\t/* TX initialisation vector */\n\tmemcpy ( tx_cipherspec->fixed_iv, key, iv_size );\n\tDBGC ( tls, \"TLS %p TX IV:\\n\", tls );\n\tDBGC_HD ( tls, key, iv_size );\n\tkey += iv_size;\n\n\t/* RX initialisation vector */\n\tmemcpy ( rx_cipherspec->fixed_iv, key, iv_size );\n\tDBGC ( tls, \"TLS %p RX IV:\\n\", tls );\n\tDBGC_HD ( tls, key, iv_size );\n\tkey += iv_size;\n\n\tassert ( ( key_block + total ) == key );\n\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Cipher suite management\n *\n ******************************************************************************\n */\n\n/** Null cipher suite */\nstruct tls_cipher_suite tls_cipher_suite_null = {\n\t.exchange = &tls_pubkey_exchange_algorithm,\n\t.pubkey = &pubkey_null,\n\t.cipher = &cipher_null,\n\t.digest = &digest_null,\n};\n\n/** Number of supported cipher suites */\n#define TLS_NUM_CIPHER_SUITES table_num_entries ( TLS_CIPHER_SUITES )\n\n/**\n * Identify cipher suite\n *\n * @v cipher_suite\tCipher suite specification\n * @ret suite\t\tCipher suite, or NULL\n */\nstatic struct tls_cipher_suite *\ntls_find_cipher_suite ( unsigned int cipher_suite ) {\n\tstruct tls_cipher_suite *suite;\n\n\t/* Identify cipher suite */\n\tfor_each_table_entry ( suite, TLS_CIPHER_SUITES ) {\n\t\tif ( suite->code == cipher_suite )\n\t\t\treturn suite;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Clear cipher suite\n *\n * @v cipherspec\tTLS cipher specification\n */\nstatic void tls_clear_cipher ( struct tls_connection *tls __unused,\n\t\t\t       struct tls_cipherspec *cipherspec ) {\n\n\tif ( cipherspec->suite ) {\n\t\tpubkey_final ( cipherspec->suite->pubkey,\n\t\t\t       cipherspec->pubkey_ctx );\n\t}\n\tfree ( cipherspec->dynamic );\n\tmemset ( cipherspec, 0, sizeof ( *cipherspec ) );\n\tcipherspec->suite = &tls_cipher_suite_null;\n}\n\n/**\n * Set cipher suite\n *\n * @v tls\t\tTLS connection\n * @v cipherspec\tTLS cipher specification\n * @v suite\t\tCipher suite\n * @ret rc\t\tReturn status code\n */\nstatic int tls_set_cipher ( struct tls_connection *tls,\n\t\t\t    struct tls_cipherspec *cipherspec,\n\t\t\t    struct tls_cipher_suite *suite ) {\n\tstruct pubkey_algorithm *pubkey = suite->pubkey;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tsize_t total;\n\tvoid *dynamic;\n\n\t/* Clear out old cipher contents, if any */\n\ttls_clear_cipher ( tls, cipherspec );\n\n\t/* Allocate dynamic storage */\n\ttotal = ( pubkey->ctxsize + cipher->ctxsize + suite->mac_len +\n\t\t  suite->fixed_iv_len );\n\tdynamic = zalloc ( total );\n\tif ( ! dynamic ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for crypto \"\n\t\t       \"context\\n\", tls, total );\n\t\treturn -ENOMEM_CONTEXT;\n\t}\n\n\t/* Assign storage */\n\tcipherspec->dynamic = dynamic;\n\tcipherspec->pubkey_ctx = dynamic;\tdynamic += pubkey->ctxsize;\n\tcipherspec->cipher_ctx = dynamic;\tdynamic += cipher->ctxsize;\n\tcipherspec->mac_secret = dynamic;\tdynamic += suite->mac_len;\n\tcipherspec->fixed_iv = dynamic;\t\tdynamic += suite->fixed_iv_len;\n\tassert ( ( cipherspec->dynamic + total ) == dynamic );\n\n\t/* Store parameters */\n\tcipherspec->suite = suite;\n\n\treturn 0;\n}\n\n/**\n * Select next cipher suite\n *\n * @v tls\t\tTLS connection\n * @v cipher_suite\tCipher suite specification\n * @ret rc\t\tReturn status code\n */\nstatic int tls_select_cipher ( struct tls_connection *tls,\n\t\t\t       unsigned int cipher_suite ) {\n\tstruct tls_cipher_suite *suite;\n\tint rc;\n\n\t/* Identify cipher suite */\n\tsuite = tls_find_cipher_suite ( cipher_suite );\n\tif ( ! suite ) {\n\t\tDBGC ( tls, \"TLS %p does not support cipher %04x\\n\",\n\t\t       tls, ntohs ( cipher_suite ) );\n\t\treturn -ENOTSUP_CIPHER;\n\t}\n\n\t/* Set ciphers */\n\tif ( ( rc = tls_set_cipher ( tls, &tls->tx_cipherspec_pending,\n\t\t\t\t     suite ) ) != 0 )\n\t\treturn rc;\n\tif ( ( rc = tls_set_cipher ( tls, &tls->rx_cipherspec_pending,\n\t\t\t\t     suite ) ) != 0 )\n\t\treturn rc;\n\n\tDBGC ( tls, \"TLS %p selected %s-%s-%s-%d-%s\\n\", tls,\n\t       suite->exchange->name, suite->pubkey->name,\n\t       suite->cipher->name, ( suite->key_len * 8 ),\n\t       suite->digest->name );\n\n\treturn 0;\n}\n\n/**\n * Activate next cipher suite\n *\n * @v tls\t\tTLS connection\n * @v pending\t\tPending cipher specification\n * @v active\t\tActive cipher specification to replace\n * @ret rc\t\tReturn status code\n */\nstatic int tls_change_cipher ( struct tls_connection *tls,\n\t\t\t       struct tls_cipherspec *pending,\n\t\t\t       struct tls_cipherspec *active ) {\n\n\t/* Sanity check */\n\tif ( pending->suite == &tls_cipher_suite_null ) {\n\t\tDBGC ( tls, \"TLS %p refusing to use null cipher\\n\", tls );\n\t\treturn -ENOTSUP_NULL;\n\t}\n\n\ttls_clear_cipher ( tls, active );\n\tmemswap ( active, pending, sizeof ( *active ) );\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Signature and hash algorithms\n *\n ******************************************************************************\n */\n\n/** Number of supported signature and hash algorithms */\n#define TLS_NUM_SIG_HASH_ALGORITHMS \\\n\ttable_num_entries ( TLS_SIG_HASH_ALGORITHMS )\n\n/**\n * Find TLS signature and hash algorithm\n *\n * @v pubkey\t\tPublic-key algorithm\n * @v digest\t\tDigest algorithm\n * @ret sig_hash\tSignature and hash algorithm, or NULL\n */\nstatic struct tls_signature_hash_algorithm *\ntls_signature_hash_algorithm ( struct pubkey_algorithm *pubkey,\n\t\t\t       struct digest_algorithm *digest ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( ( sig_hash->pubkey == pubkey ) &&\n\t\t     ( sig_hash->digest == digest ) ) {\n\t\t\treturn sig_hash;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Find TLS signature algorithm\n *\n * @v code\t\tSignature and hash algorithm identifier\n * @ret pubkey\t\tPublic key algorithm, or NULL\n */\nstatic struct pubkey_algorithm *\ntls_signature_hash_pubkey ( struct tls_signature_hash_id code ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( sig_hash->code.signature == code.signature )\n\t\t\treturn sig_hash->pubkey;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Find TLS hash algorithm\n *\n * @v code\t\tSignature and hash algorithm identifier\n * @ret digest\t\tDigest algorithm, or NULL\n */\nstatic struct digest_algorithm *\ntls_signature_hash_digest ( struct tls_signature_hash_id code ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( sig_hash->code.hash == code.hash )\n\t\t\treturn sig_hash->digest;\n\t}\n\n\treturn NULL;\n}\n\n/******************************************************************************\n *\n * Handshake verification\n *\n ******************************************************************************\n */\n\n/**\n * Add handshake record to verification hash\n *\n * @v tls\t\tTLS connection\n * @v data\t\tHandshake record\n * @v len\t\tLength of handshake record\n */\nstatic void tls_add_handshake ( struct tls_connection *tls,\n\t\t\t\tconst void *data, size_t len ) {\n\n\tdigest_update ( &md5_sha1_algorithm, tls->handshake_md5_sha1_ctx,\n\t\t\tdata, len );\n\tdigest_update ( &sha256_algorithm, tls->handshake_sha256_ctx,\n\t\t\tdata, len );\n}\n\n/**\n * Calculate handshake verification hash\n *\n * @v tls\t\tTLS connection\n * @v out\t\tOutput buffer\n *\n * Calculates the MD5+SHA1 or SHA256 digest over all handshake\n * messages seen so far.\n */\nstatic void tls_verify_handshake ( struct tls_connection *tls, void *out ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tuint8_t ctx[ digest->ctxsize ];\n\n\tmemcpy ( ctx, tls->handshake_ctx, sizeof ( ctx ) );\n\tdigest_final ( digest, ctx, out );\n}\n\n/******************************************************************************\n *\n * Record handling\n *\n ******************************************************************************\n */\n\n/**\n * Resume TX state machine\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_tx_resume ( struct tls_connection *tls ) {\n\tprocess_add ( &tls->process );\n}\n\n/**\n * Resume TX state machine for all connections within a session\n *\n * @v session\t\tTLS session\n */\nstatic void tls_tx_resume_all ( struct tls_session *session ) {\n\tstruct tls_connection *tls;\n\n\tlist_for_each_entry ( tls, &session->conn, list )\n\t\ttls_tx_resume ( tls );\n}\n\n/**\n * Restart negotiation\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_restart ( struct tls_connection *tls ) {\n\n\t/* Sanity check */\n\tassert ( ! tls->tx_pending );\n\tassert ( ! is_pending ( &tls->client_negotiation ) );\n\tassert ( ! is_pending ( &tls->server_negotiation ) );\n\tassert ( ! is_pending ( &tls->validation ) );\n\n\t/* (Re)initialise handshake context */\n\tdigest_init ( &md5_sha1_algorithm, tls->handshake_md5_sha1_ctx );\n\tdigest_init ( &sha256_algorithm, tls->handshake_sha256_ctx );\n\ttls->handshake_digest = &sha256_algorithm;\n\ttls->handshake_ctx = tls->handshake_sha256_ctx;\n\n\t/* (Re)start negotiation */\n\ttls->tx_pending = TLS_TX_CLIENT_HELLO;\n\ttls_tx_resume ( tls );\n\tpending_get ( &tls->client_negotiation );\n\tpending_get ( &tls->server_negotiation );\n}\n\n/**\n * Transmit Handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_handshake ( struct tls_connection *tls,\n\t\t\t\tvoid *data, size_t len ) {\n\n\t/* Add to handshake digest */\n\ttls_add_handshake ( tls, data, len );\n\n\t/* Send record */\n\treturn tls_send_plaintext ( tls, TLS_TYPE_HANDSHAKE, data, len );\n}\n\n/**\n * Transmit Client Hello record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_hello ( struct tls_connection *tls ) {\n\tstruct tls_session *session = tls->session;\n\tsize_t name_len = strlen ( session->name );\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint16_t version;\n\t\tuint8_t random[32];\n\t\tuint8_t session_id_len;\n\t\tuint8_t session_id[tls->session_id_len];\n\t\tuint16_t cipher_suite_len;\n\t\tuint16_t cipher_suites[TLS_NUM_CIPHER_SUITES];\n\t\tuint8_t compression_methods_len;\n\t\tuint8_t compression_methods[1];\n\t\tuint16_t extensions_len;\n\t\tstruct {\n\t\t\tuint16_t server_name_type;\n\t\t\tuint16_t server_name_len;\n\t\t\tstruct {\n\t\t\t\tuint16_t len;\n\t\t\t\tstruct {\n\t\t\t\t\tuint8_t type;\n\t\t\t\t\tuint16_t len;\n\t\t\t\t\tuint8_t name[name_len];\n\t\t\t\t} __attribute__ (( packed )) list[1];\n\t\t\t} __attribute__ (( packed )) server_name;\n\t\t\tuint16_t max_fragment_length_type;\n\t\t\tuint16_t max_fragment_length_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t max;\n\t\t\t} __attribute__ (( packed )) max_fragment_length;\n\t\t\tuint16_t signature_algorithms_type;\n\t\t\tuint16_t signature_algorithms_len;\n\t\t\tstruct {\n\t\t\t\tuint16_t len;\n\t\t\t\tstruct tls_signature_hash_id\n\t\t\t\t\tcode[TLS_NUM_SIG_HASH_ALGORITHMS];\n\t\t\t} __attribute__ (( packed )) signature_algorithms;\n\t\t\tuint16_t renegotiation_info_type;\n\t\t\tuint16_t renegotiation_info_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t len;\n\t\t\t\tuint8_t data[ tls->secure_renegotiation ?\n\t\t\t\t\t      sizeof ( tls->verify.client ) :0];\n\t\t\t} __attribute__ (( packed )) renegotiation_info;\n\t\t\tuint16_t session_ticket_type;\n\t\t\tuint16_t session_ticket_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t data[session->ticket_len];\n\t\t\t} __attribute__ (( packed )) session_ticket;\n\t\t} __attribute__ (( packed )) extensions;\n\t} __attribute__ (( packed )) hello;\n\tstruct tls_cipher_suite *suite;\n\tstruct tls_signature_hash_algorithm *sighash;\n\tunsigned int i;\n\n\t/* Construct record */\n\tmemset ( &hello, 0, sizeof ( hello ) );\n\thello.type_length = ( cpu_to_le32 ( TLS_CLIENT_HELLO ) |\n\t\t\t      htonl ( sizeof ( hello ) -\n\t\t\t\t      sizeof ( hello.type_length ) ) );\n\thello.version = htons ( tls->version );\n\tmemcpy ( &hello.random, &tls->client_random, sizeof ( hello.random ) );\n\thello.session_id_len = tls->session_id_len;\n\tmemcpy ( hello.session_id, tls->session_id,\n\t\t sizeof ( hello.session_id ) );\n\thello.cipher_suite_len = htons ( sizeof ( hello.cipher_suites ) );\n\ti = 0 ; for_each_table_entry ( suite, TLS_CIPHER_SUITES )\n\t\thello.cipher_suites[i++] = suite->code;\n\thello.compression_methods_len = sizeof ( hello.compression_methods );\n\thello.extensions_len = htons ( sizeof ( hello.extensions ) );\n\thello.extensions.server_name_type = htons ( TLS_SERVER_NAME );\n\thello.extensions.server_name_len\n\t\t= htons ( sizeof ( hello.extensions.server_name ) );\n\thello.extensions.server_name.len\n\t\t= htons ( sizeof ( hello.extensions.server_name.list ) );\n\thello.extensions.server_name.list[0].type = TLS_SERVER_NAME_HOST_NAME;\n\thello.extensions.server_name.list[0].len\n\t\t= htons ( sizeof ( hello.extensions.server_name.list[0].name ));\n\tmemcpy ( hello.extensions.server_name.list[0].name, session->name,\n\t\t sizeof ( hello.extensions.server_name.list[0].name ) );\n\thello.extensions.max_fragment_length_type\n\t\t= htons ( TLS_MAX_FRAGMENT_LENGTH );\n\thello.extensions.max_fragment_length_len\n\t\t= htons ( sizeof ( hello.extensions.max_fragment_length ) );\n\thello.extensions.max_fragment_length.max\n\t\t= TLS_MAX_FRAGMENT_LENGTH_4096;\n\thello.extensions.signature_algorithms_type\n\t\t= htons ( TLS_SIGNATURE_ALGORITHMS );\n\thello.extensions.signature_algorithms_len\n\t\t= htons ( sizeof ( hello.extensions.signature_algorithms ) );\n\thello.extensions.signature_algorithms.len\n\t\t= htons ( sizeof ( hello.extensions.signature_algorithms.code));\n\ti = 0 ; for_each_table_entry ( sighash, TLS_SIG_HASH_ALGORITHMS )\n\t\thello.extensions.signature_algorithms.code[i++] = sighash->code;\n\thello.extensions.renegotiation_info_type\n\t\t= htons ( TLS_RENEGOTIATION_INFO );\n\thello.extensions.renegotiation_info_len\n\t\t= htons ( sizeof ( hello.extensions.renegotiation_info ) );\n\thello.extensions.renegotiation_info.len\n\t\t= sizeof ( hello.extensions.renegotiation_info.data );\n\tmemcpy ( hello.extensions.renegotiation_info.data, tls->verify.client,\n\t\t sizeof ( hello.extensions.renegotiation_info.data ) );\n\thello.extensions.session_ticket_type = htons ( TLS_SESSION_TICKET );\n\thello.extensions.session_ticket_len\n\t\t= htons ( sizeof ( hello.extensions.session_ticket ) );\n\tmemcpy ( hello.extensions.session_ticket.data, session->ticket,\n\t\t sizeof ( hello.extensions.session_ticket.data ) );\n\n\treturn tls_send_handshake ( tls, &hello, sizeof ( hello ) );\n}\n\n/**\n * Transmit Certificate record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_certificate ( struct tls_connection *tls ) {\n\tstruct {\n\t\ttls24_t length;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *certificate;\n\tstruct {\n\t\tuint32_t type_length;\n\t\ttls24_t length;\n\t\ttypeof ( *certificate ) certificates[0];\n\t} __attribute__ (( packed )) *certificates;\n\tstruct x509_link *link;\n\tstruct x509_certificate *cert;\n\tsize_t len;\n\tint rc;\n\n\t/* Calculate length of client certificates */\n\tlen = 0;\n\tlist_for_each_entry ( link, &tls->certs->links, list ) {\n\t\tcert = link->cert;\n\t\tlen += ( sizeof ( *certificate ) + cert->raw.len );\n\t\tDBGC ( tls, \"TLS %p sending client certificate %s\\n\",\n\t\t       tls, x509_name ( cert ) );\n\t}\n\n\t/* Allocate storage for Certificate record (which may be too\n\t * large for the stack).\n\t */\n\tcertificates = zalloc ( sizeof ( *certificates ) + len );\n\tif ( ! certificates )\n\t\treturn -ENOMEM_CERTIFICATE;\n\n\t/* Populate record */\n\tcertificates->type_length =\n\t\t( cpu_to_le32 ( TLS_CERTIFICATE ) |\n\t\t  htonl ( sizeof ( *certificates ) + len -\n\t\t\t  sizeof ( certificates->type_length ) ) );\n\ttls_set_uint24 ( &certificates->length, len );\n\tcertificate = &certificates->certificates[0];\n\tlist_for_each_entry ( link, &tls->certs->links, list ) {\n\t\tcert = link->cert;\n\t\ttls_set_uint24 ( &certificate->length, cert->raw.len );\n\t\tmemcpy ( certificate->data, cert->raw.data, cert->raw.len );\n\t\tcertificate = ( ( ( void * ) certificate->data ) +\n\t\t\t\tcert->raw.len );\n\t}\n\n\t/* Transmit record */\n\trc = tls_send_handshake ( tls, certificates,\n\t\t\t\t  ( sizeof ( *certificates ) + len ) );\n\n\t/* Free record */\n\tfree ( certificates );\n\n\treturn rc;\n}\n\n/**\n * Transmit Client Key Exchange record using public key exchange\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange_pubkey ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey = cipherspec->suite->pubkey;\n\tsize_t max_len = pubkey_max_len ( pubkey, cipherspec->pubkey_ctx );\n\tstruct {\n\t\tuint16_t version;\n\t\tuint8_t random[46];\n\t} __attribute__ (( packed )) pre_master_secret;\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint16_t encrypted_pre_master_secret_len;\n\t\tuint8_t encrypted_pre_master_secret[max_len];\n\t} __attribute__ (( packed )) key_xchg;\n\tsize_t unused;\n\tint len;\n\tint rc;\n\n\t/* Generate pre-master secret */\n\tpre_master_secret.version = htons ( TLS_VERSION_MAX );\n\tif ( ( rc = tls_generate_random ( tls, &pre_master_secret.random,\n\t\t\t  ( sizeof ( pre_master_secret.random ) ) ) ) != 0 ) {\n\t\treturn rc;\n\t}\n\n\t/* Generate master secret */\n\ttls_generate_master_secret ( tls, &pre_master_secret,\n\t\t\t\t     sizeof ( pre_master_secret ) );\n\n\t/* Generate keys */\n\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not generate keys: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\n\t/* Encrypt pre-master secret using server's public key */\n\tmemset ( &key_xchg, 0, sizeof ( key_xchg ) );\n\tlen = pubkey_encrypt ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t       &pre_master_secret, sizeof ( pre_master_secret ),\n\t\t\t       key_xchg.encrypted_pre_master_secret );\n\tif ( len < 0 ) {\n\t\trc = len;\n\t\tDBGC ( tls, \"TLS %p could not encrypt pre-master secret: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tunused = ( max_len - len );\n\tkey_xchg.type_length =\n\t\t( cpu_to_le32 ( TLS_CLIENT_KEY_EXCHANGE ) |\n\t\t  htonl ( sizeof ( key_xchg ) -\n\t\t\t  sizeof ( key_xchg.type_length ) - unused ) );\n\tkey_xchg.encrypted_pre_master_secret_len =\n\t\thtons ( sizeof ( key_xchg.encrypted_pre_master_secret ) -\n\t\t\tunused );\n\n\treturn tls_send_handshake ( tls, &key_xchg,\n\t\t\t\t    ( sizeof ( key_xchg ) - unused ) );\n}\n\n/** Public key exchange algorithm */\nstruct tls_key_exchange_algorithm tls_pubkey_exchange_algorithm = {\n\t.name = \"pubkey\",\n\t.exchange = tls_send_client_key_exchange_pubkey,\n};\n\n/**\n * Transmit Client Key Exchange record using DHE key exchange\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange_dhe ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey;\n\tstruct digest_algorithm *digest;\n\tint use_sig_hash = tls_version ( tls, TLS_VERSION_TLS_1_2 );\n\tuint8_t private[ sizeof ( tls->client_random.random ) ];\n\tconst struct {\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *dh_val[3];\n\tconst struct {\n\t\tstruct tls_signature_hash_id sig_hash[use_sig_hash];\n\t\tuint16_t signature_len;\n\t\tuint8_t signature[0];\n\t} __attribute__ (( packed )) *sig;\n\tconst void *data;\n\tsize_t remaining;\n\tsize_t frag_len;\n\tunsigned int i;\n\tint rc;\n\n\t/* Parse ServerKeyExchange */\n\tdata = tls->server_key;\n\tremaining = tls->server_key_len;\n\tfor ( i = 0 ; i < ( sizeof ( dh_val ) / sizeof ( dh_val[0] ) ) ; i++ ){\n\t\tdh_val[i] = data;\n\t\tif ( ( sizeof ( *dh_val[i] ) > remaining ) ||\n\t\t     ( ntohs ( dh_val[i]->len ) > ( remaining -\n\t\t\t\t\t\t    sizeof ( *dh_val[i] ) ) )){\n\t\t\tDBGC ( tls, \"TLS %p received underlength \"\n\t\t\t       \"ServerKeyExchange\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->server_key,\n\t\t\t\t   tls->server_key_len );\n\t\t\trc = -EINVAL_KEY_EXCHANGE;\n\t\t\tgoto err_header;\n\t\t}\n\t\tfrag_len = ( sizeof ( *dh_val[i] ) + ntohs ( dh_val[i]->len ));\n\t\tdata += frag_len;\n\t\tremaining -= frag_len;\n\t}\n\tsig = data;\n\tif ( ( sizeof ( *sig ) > remaining ) ||\n\t     ( ntohs ( sig->signature_len ) > ( remaining -\n\t\t\t\t\t\tsizeof ( *sig ) ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength ServerKeyExchange\\n\",\n\t\t       tls );\n\t\tDBGC_HDA ( tls, 0, tls->server_key, tls->server_key_len );\n\t\trc = -EINVAL_KEY_EXCHANGE;\n\t\tgoto err_header;\n\t}\n\n\t/* Identify signature and hash algorithm */\n\tif ( use_sig_hash ) {\n\t\tpubkey = tls_signature_hash_pubkey ( sig->sig_hash[0] );\n\t\tdigest = tls_signature_hash_digest ( sig->sig_hash[0] );\n\t\tif ( ( ! pubkey ) || ( ! digest ) ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange unsupported \"\n\t\t\t       \"signature and hash algorithm\\n\", tls );\n\t\t\trc = -ENOTSUP_SIG_HASH;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t\tif ( pubkey != cipherspec->suite->pubkey ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange incorrect \"\n\t\t\t       \"signature algorithm %s (expected %s)\\n\", tls,\n\t\t\t       pubkey->name, cipherspec->suite->pubkey->name );\n\t\t\trc = -EPERM_KEY_EXCHANGE;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t} else {\n\t\tpubkey = cipherspec->suite->pubkey;\n\t\tdigest = &md5_sha1_algorithm;\n\t}\n\n\t/* Verify signature */\n\t{\n\t\tconst void *signature = sig->signature;\n\t\tsize_t signature_len = ntohs ( sig->signature_len );\n\t\tuint8_t ctx[digest->ctxsize];\n\t\tuint8_t hash[digest->digestsize];\n\n\t\t/* Calculate digest */\n\t\tdigest_init ( digest, ctx );\n\t\tdigest_update ( digest, ctx, &tls->client_random,\n\t\t\t\tsizeof ( tls->client_random ) );\n\t\tdigest_update ( digest, ctx, tls->server_random,\n\t\t\t\tsizeof ( tls->server_random ) );\n\t\tdigest_update ( digest, ctx, tls->server_key,\n\t\t\t\t( tls->server_key_len - remaining ) );\n\t\tdigest_final ( digest, ctx, hash );\n\n\t\t/* Verify signature */\n\t\tif ( ( rc = pubkey_verify ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t\t\t    digest, hash, signature,\n\t\t\t\t\t    signature_len ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange failed \"\n\t\t\t       \"verification\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->server_key,\n\t\t\t\t   tls->server_key_len );\n\t\t\trc = -EPERM_KEY_EXCHANGE;\n\t\t\tgoto err_verify;\n\t\t}\n\t}\n\n\t/* Generate Diffie-Hellman private key */\n\tif ( ( rc = tls_generate_random ( tls, private,\n\t\t\t\t\t  sizeof ( private ) ) ) != 0 ) {\n\t\tgoto err_random;\n\t}\n\n\t/* Construct pre-master secret and ClientKeyExchange record */\n\t{\n\t\ttypeof ( dh_val[0] ) dh_p = dh_val[0];\n\t\ttypeof ( dh_val[1] ) dh_g = dh_val[1];\n\t\ttypeof ( dh_val[2] ) dh_ys = dh_val[2];\n\t\tsize_t len = ntohs ( dh_p->len );\n\t\tstruct {\n\t\t\tuint32_t type_length;\n\t\t\tuint16_t dh_xs_len;\n\t\t\tuint8_t dh_xs[len];\n\t\t} __attribute__ (( packed )) *key_xchg;\n\t\tstruct {\n\t\t\tuint8_t pre_master_secret[len];\n\t\t\ttypeof ( *key_xchg ) key_xchg;\n\t\t} *dynamic;\n\t\tuint8_t *pre_master_secret;\n\n\t\t/* Allocate space */\n\t\tdynamic = malloc ( sizeof ( *dynamic ) );\n\t\tif ( ! dynamic ) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_alloc;\n\t\t}\n\t\tpre_master_secret = dynamic->pre_master_secret;\n\t\tkey_xchg = &dynamic->key_xchg;\n\t\tkey_xchg->type_length =\n\t\t\t( cpu_to_le32 ( TLS_CLIENT_KEY_EXCHANGE ) |\n\t\t\t  htonl ( sizeof ( *key_xchg ) -\n\t\t\t\t  sizeof ( key_xchg->type_length ) ) );\n\t\tkey_xchg->dh_xs_len = htons ( len );\n\n\t\t/* Calculate pre-master secret and client public value */\n\t\tif ( ( rc = dhe_key ( dh_p->data, len,\n\t\t\t\t      dh_g->data, ntohs ( dh_g->len ),\n\t\t\t\t      dh_ys->data, ntohs ( dh_ys->len ),\n\t\t\t\t      private, sizeof ( private ),\n\t\t\t\t      key_xchg->dh_xs,\n\t\t\t\t      pre_master_secret ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not calculate DHE key: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err_dhe_key;\n\t\t}\n\n\t\t/* Strip leading zeroes from pre-master secret */\n\t\twhile ( len && ( ! *pre_master_secret ) ) {\n\t\t\tpre_master_secret++;\n\t\t\tlen--;\n\t\t}\n\n\t\t/* Generate master secret */\n\t\ttls_generate_master_secret ( tls, pre_master_secret, len );\n\n\t\t/* Generate keys */\n\t\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not generate keys: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err_generate_keys;\n\t\t}\n\n\t\t/* Transmit Client Key Exchange record */\n\t\tif ( ( rc = tls_send_handshake ( tls, key_xchg,\n\t\t\t\t\t\t sizeof ( *key_xchg ) ) ) !=0){\n\t\t\tgoto err_send_handshake;\n\t\t}\n\n\terr_send_handshake:\n\terr_generate_keys:\n\terr_dhe_key:\n\t\tfree ( dynamic );\n\t}\n err_alloc:\n err_random:\n err_verify:\n err_sig_hash:\n err_header:\n\treturn rc;\n}\n\n/** Ephemeral Diffie-Hellman key exchange algorithm */\nstruct tls_key_exchange_algorithm tls_dhe_exchange_algorithm = {\n\t.name = \"dhe\",\n\t.exchange = tls_send_client_key_exchange_dhe,\n};\n\n/**\n * Transmit Client Key Exchange record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\n\t/* Transmit Client Key Exchange record via key exchange algorithm */\n\treturn suite->exchange->exchange ( tls );\n}\n\n/**\n * Transmit Certificate Verify record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_certificate_verify ( struct tls_connection *tls ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tstruct x509_certificate *cert = x509_first ( tls->certs );\n\tstruct pubkey_algorithm *pubkey = cert->signature_algorithm->pubkey;\n\tstruct asn1_cursor *key = privkey_cursor ( tls->key );\n\tuint8_t digest_out[ digest->digestsize ];\n\tuint8_t ctx[ pubkey->ctxsize ];\n\tstruct tls_signature_hash_algorithm *sig_hash = NULL;\n\tint rc;\n\n\t/* Generate digest to be signed */\n\ttls_verify_handshake ( tls, digest_out );\n\n\t/* Initialise public-key algorithm */\n\tif ( ( rc = pubkey_init ( pubkey, ctx, key->data, key->len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not initialise %s client private \"\n\t\t       \"key: %s\\n\", tls, pubkey->name, strerror ( rc ) );\n\t\tgoto err_pubkey_init;\n\t}\n\n\t/* TLSv1.2 and later use explicit algorithm identifiers */\n\tif ( tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\tsig_hash = tls_signature_hash_algorithm ( pubkey, digest );\n\t\tif ( ! sig_hash ) {\n\t\t\tDBGC ( tls, \"TLS %p could not identify (%s,%s) \"\n\t\t\t       \"signature and hash algorithm\\n\", tls,\n\t\t\t       pubkey->name, digest->name );\n\t\t\trc = -ENOTSUP_SIG_HASH;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t}\n\n\t/* Generate and transmit record */\n\t{\n\t\tsize_t max_len = pubkey_max_len ( pubkey, ctx );\n\t\tint use_sig_hash = ( ( sig_hash == NULL ) ? 0 : 1 );\n\t\tstruct {\n\t\t\tuint32_t type_length;\n\t\t\tstruct tls_signature_hash_id sig_hash[use_sig_hash];\n\t\t\tuint16_t signature_len;\n\t\t\tuint8_t signature[max_len];\n\t\t} __attribute__ (( packed )) certificate_verify;\n\t\tsize_t unused;\n\t\tint len;\n\n\t\t/* Sign digest */\n\t\tlen = pubkey_sign ( pubkey, ctx, digest, digest_out,\n\t\t\t\t    certificate_verify.signature );\n\t\tif ( len < 0 ) {\n\t\t\trc = len;\n\t\t\tDBGC ( tls, \"TLS %p could not sign %s digest using %s \"\n\t\t\t       \"client private key: %s\\n\", tls, digest->name,\n\t\t\t       pubkey->name, strerror ( rc ) );\n\t\t\tgoto err_pubkey_sign;\n\t\t}\n\t\tunused = ( max_len - len );\n\n\t\t/* Construct Certificate Verify record */\n\t\tcertificate_verify.type_length =\n\t\t\t( cpu_to_le32 ( TLS_CERTIFICATE_VERIFY ) |\n\t\t\t  htonl ( sizeof ( certificate_verify ) -\n\t\t\t\t  sizeof ( certificate_verify.type_length ) -\n\t\t\t\t  unused ) );\n\t\tif ( use_sig_hash ) {\n\t\t\tmemcpy ( &certificate_verify.sig_hash[0],\n\t\t\t\t &sig_hash->code,\n\t\t\t\t sizeof ( certificate_verify.sig_hash[0] ) );\n\t\t}\n\t\tcertificate_verify.signature_len =\n\t\t\thtons ( sizeof ( certificate_verify.signature ) -\n\t\t\t\tunused );\n\n\t\t/* Transmit record */\n\t\trc = tls_send_handshake ( tls, &certificate_verify,\n\t\t\t\t   ( sizeof ( certificate_verify ) - unused ) );\n\t}\n\n err_pubkey_sign:\n err_sig_hash:\n\tpubkey_final ( pubkey, ctx );\n err_pubkey_init:\n\treturn rc;\n}\n\n/**\n * Transmit Change Cipher record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_change_cipher ( struct tls_connection *tls ) {\n\tstatic const uint8_t change_cipher[1] = { 1 };\n\treturn tls_send_plaintext ( tls, TLS_TYPE_CHANGE_CIPHER,\n\t\t\t\t    change_cipher, sizeof ( change_cipher ) );\n}\n\n/**\n * Transmit Finished record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_finished ( struct tls_connection *tls ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint8_t verify_data[ sizeof ( tls->verify.client ) ];\n\t} __attribute__ (( packed )) finished;\n\tuint8_t digest_out[ digest->digestsize ];\n\tint rc;\n\n\t/* Construct client verification data */\n\ttls_verify_handshake ( tls, digest_out );\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\ttls->verify.client, sizeof ( tls->verify.client ),\n\t\t\t\"client finished\", digest_out, sizeof ( digest_out ) );\n\n\t/* Construct record */\n\tmemset ( &finished, 0, sizeof ( finished ) );\n\tfinished.type_length = ( cpu_to_le32 ( TLS_FINISHED ) |\n\t\t\t\t htonl ( sizeof ( finished ) -\n\t\t\t\t\t sizeof ( finished.type_length ) ) );\n\tmemcpy ( finished.verify_data, tls->verify.client,\n\t\t sizeof ( finished.verify_data ) );\n\n\t/* Transmit record */\n\tif ( ( rc = tls_send_handshake ( tls, &finished,\n\t\t\t\t\t sizeof ( finished ) ) ) != 0 )\n\t\treturn rc;\n\n\t/* Mark client as finished */\n\tpending_put ( &tls->client_negotiation );\n\n\treturn 0;\n}\n\n/**\n * Receive new Change Cipher record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_change_cipher ( struct tls_connection *tls,\n\t\t\t\t   const void *data, size_t len ) {\n\tint rc;\n\n\tif ( ( len != 1 ) || ( *( ( uint8_t * ) data ) != 1 ) ) {\n\t\tDBGC ( tls, \"TLS %p received invalid Change Cipher\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CHANGE_CIPHER;\n\t}\n\n\tif ( ( rc = tls_change_cipher ( tls, &tls->rx_cipherspec_pending,\n\t\t\t\t\t&tls->rx_cipherspec ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not activate RX cipher: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\ttls->rx_seq = ~( ( uint64_t ) 0 );\n\n\treturn 0;\n}\n\n/**\n * Receive new Alert record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_alert ( struct tls_connection *tls, const void *data,\n\t\t\t   size_t len ) {\n\tconst struct {\n\t\tuint8_t level;\n\t\tuint8_t description;\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *alert = data;\n\n\t/* Sanity check */\n\tif ( sizeof ( *alert ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Alert\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_ALERT;\n\t}\n\n\tswitch ( alert->level ) {\n\tcase TLS_ALERT_WARNING:\n\t\tDBGC ( tls, \"TLS %p received warning alert %d\\n\",\n\t\t       tls, alert->description );\n\t\treturn 0;\n\tcase TLS_ALERT_FATAL:\n\t\tDBGC ( tls, \"TLS %p received fatal alert %d\\n\",\n\t\t       tls, alert->description );\n\t\treturn -EPERM_ALERT;\n\tdefault:\n\t\tDBGC ( tls, \"TLS %p received unknown alert level %d\"\n\t\t       \"(alert %d)\\n\", tls, alert->level, alert->description );\n\t\treturn -EIO_ALERT;\n\t}\n}\n\n/**\n * Receive new Hello Request handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_hello_request ( struct tls_connection *tls,\n\t\t\t\t   const void *data __unused,\n\t\t\t\t   size_t len __unused ) {\n\n\t/* Ignore if a handshake is in progress */\n\tif ( ! tls_ready ( tls ) ) {\n\t\tDBGC ( tls, \"TLS %p ignoring Hello Request\\n\", tls );\n\t\treturn 0;\n\t}\n\n\t/* Fail unless server supports secure renegotiation */\n\tif ( ! tls->secure_renegotiation ) {\n\t\tDBGC ( tls, \"TLS %p refusing to renegotiate insecurely\\n\",\n\t\t       tls );\n\t\treturn -EPERM_RENEG_INSECURE;\n\t}\n\n\t/* Restart negotiation */\n\ttls_restart ( tls );\n\n\treturn 0;\n}\n\n/**\n * Receive new Server Hello handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_hello ( struct tls_connection *tls,\n\t\t\t\t  const void *data, size_t len ) {\n\tconst struct {\n\t\tuint16_t version;\n\t\tuint8_t random[32];\n\t\tuint8_t session_id_len;\n\t\tuint8_t session_id[0];\n\t} __attribute__ (( packed )) *hello_a = data;\n\tconst uint8_t *session_id;\n\tconst struct {\n\t\tuint16_t cipher_suite;\n\t\tuint8_t compression_method;\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *hello_b;\n\tconst struct {\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *exts;\n\tconst struct {\n\t\tuint16_t type;\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *ext;\n\tconst struct {\n\t\tuint8_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *reneg = NULL;\n\tuint16_t version;\n\tsize_t exts_len;\n\tsize_t ext_len;\n\tsize_t remaining;\n\tint rc;\n\n\t/* Parse header */\n\tif ( ( sizeof ( *hello_a ) > len ) ||\n\t     ( hello_a->session_id_len > ( len - sizeof ( *hello_a ) ) ) ||\n\t     ( sizeof ( *hello_b ) > ( len - sizeof ( *hello_a ) -\n\t\t\t\t       hello_a->session_id_len ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength Server Hello\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_HELLO;\n\t}\n\tsession_id = hello_a->session_id;\n\thello_b = ( ( void * ) ( session_id + hello_a->session_id_len ) );\n\n\t/* Parse extensions, if present */\n\tremaining = ( len - sizeof ( *hello_a ) - hello_a->session_id_len -\n\t\t      sizeof ( *hello_b ) );\n\tif ( remaining ) {\n\n\t\t/* Parse extensions length */\n\t\texts = ( ( void * ) hello_b->next );\n\t\tif ( ( sizeof ( *exts ) > remaining ) ||\n\t\t     ( ( exts_len = ntohs ( exts->len ) ) >\n\t\t       ( remaining - sizeof ( *exts ) ) ) ) {\n\t\t\tDBGC ( tls, \"TLS %p received underlength extensions\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, len );\n\t\t\treturn -EINVAL_HELLO;\n\t\t}\n\n\t\t/* Parse extensions */\n\t\tfor ( ext = ( ( void * ) exts->data ), remaining = exts_len ;\n\t\t      remaining ;\n\t\t      ext = ( ( ( void * ) ext ) + sizeof ( *ext ) + ext_len ),\n\t\t\t      remaining -= ( sizeof ( *ext ) + ext_len ) ) {\n\n\t\t\t/* Parse extension length */\n\t\t\tif ( ( sizeof ( *ext ) > remaining ) ||\n\t\t\t     ( ( ext_len = ntohs ( ext->len ) ) >\n\t\t\t       ( remaining - sizeof ( *ext ) ) ) ) {\n\t\t\t\tDBGC ( tls, \"TLS %p received underlength \"\n\t\t\t\t       \"extension\\n\", tls );\n\t\t\t\tDBGC_HD ( tls, data, len );\n\t\t\t\treturn -EINVAL_HELLO;\n\t\t\t}\n\n\t\t\t/* Record known extensions */\n\t\t\tswitch ( ext->type ) {\n\t\t\tcase htons ( TLS_RENEGOTIATION_INFO ) :\n\t\t\t\treneg = ( ( void * ) ext->data );\n\t\t\t\tif ( ( sizeof ( *reneg ) > ext_len ) ||\n\t\t\t\t     ( reneg->len >\n\t\t\t\t       ( ext_len - sizeof ( *reneg ) ) ) ) {\n\t\t\t\t\tDBGC ( tls, \"TLS %p received \"\n\t\t\t\t\t       \"underlength renegotiation \"\n\t\t\t\t\t       \"info\\n\", tls );\n\t\t\t\t\tDBGC_HD ( tls, data, len );\n\t\t\t\t\treturn -EINVAL_HELLO;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check and store protocol version */\n\tversion = ntohs ( hello_a->version );\n\tif ( version < TLS_VERSION_MIN ) {\n\t\tDBGC ( tls, \"TLS %p does not support protocol version %d.%d\\n\",\n\t\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\t\treturn -ENOTSUP_VERSION;\n\t}\n\tif ( version > tls->version ) {\n\t\tDBGC ( tls, \"TLS %p server attempted to illegally upgrade to \"\n\t\t       \"protocol version %d.%d\\n\",\n\t\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\t\treturn -EPROTO_VERSION;\n\t}\n\ttls->version = version;\n\tDBGC ( tls, \"TLS %p using protocol version %d.%d\\n\",\n\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\n\t/* Use MD5+SHA1 digest algorithm for handshake verification\n\t * for versions earlier than TLSv1.2.\n\t */\n\tif ( ! tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\ttls->handshake_digest = &md5_sha1_algorithm;\n\t\ttls->handshake_ctx = tls->handshake_md5_sha1_ctx;\n\t}\n\n\t/* Copy out server random bytes */\n\tmemcpy ( &tls->server_random, &hello_a->random,\n\t\t sizeof ( tls->server_random ) );\n\n\t/* Select cipher suite */\n\tif ( ( rc = tls_select_cipher ( tls, hello_b->cipher_suite ) ) != 0 )\n\t\treturn rc;\n\n\t/* Check session ID */\n\tif ( hello_a->session_id_len &&\n\t     ( hello_a->session_id_len == tls->session_id_len ) &&\n\t     ( memcmp ( session_id, tls->session_id,\n\t\t\ttls->session_id_len ) == 0 ) ) {\n\n\t\t/* Session ID match: reuse master secret */\n\t\tDBGC ( tls, \"TLS %p resuming session ID:\\n\", tls );\n\t\tDBGC_HDA ( tls, 0, tls->session_id, tls->session_id_len );\n\t\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 )\n\t\t\treturn rc;\n\n\t} else {\n\n\t\t/* Record new session ID, if present */\n\t\tif ( hello_a->session_id_len &&\n\t\t     ( hello_a->session_id_len <= sizeof ( tls->session_id ))){\n\t\t\ttls->session_id_len = hello_a->session_id_len;\n\t\t\tmemcpy ( tls->session_id, session_id,\n\t\t\t\t tls->session_id_len );\n\t\t\tDBGC ( tls, \"TLS %p new session ID:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->session_id,\n\t\t\t\t   tls->session_id_len );\n\t\t}\n\t}\n\n\t/* Handle secure renegotiation */\n\tif ( tls->secure_renegotiation ) {\n\n\t\t/* Secure renegotiation is expected; verify data */\n\t\tif ( ( reneg == NULL ) ||\n\t\t     ( reneg->len != sizeof ( tls->verify ) ) ||\n\t\t     ( memcmp ( reneg->data, &tls->verify,\n\t\t\t\tsizeof ( tls->verify ) ) != 0 ) ) {\n\t\t\tDBGC ( tls, \"TLS %p server failed secure \"\n\t\t\t       \"renegotiation\\n\", tls );\n\t\t\treturn -EPERM_RENEG_VERIFY;\n\t\t}\n\n\t} else if ( reneg != NULL ) {\n\n\t\t/* Secure renegotiation is being enabled */\n\t\tif ( reneg->len != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p server provided non-empty initial \"\n\t\t\t       \"renegotiation\\n\", tls );\n\t\t\treturn -EPERM_RENEG_VERIFY;\n\t\t}\n\t\ttls->secure_renegotiation = 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Receive New Session Ticket handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_session_ticket ( struct tls_connection *tls,\n\t\t\t\t    const void *data, size_t len ) {\n\tconst struct {\n\t\tuint32_t lifetime;\n\t\tuint16_t len;\n\t\tuint8_t ticket[0];\n\t} __attribute__ (( packed )) *new_session_ticket = data;\n\tsize_t ticket_len;\n\n\t/* Parse header */\n\tif ( sizeof ( *new_session_ticket ) > len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength New Session Ticket\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_TICKET;\n\t}\n\tticket_len = ntohs ( new_session_ticket->len );\n\tif ( ticket_len > ( len - sizeof ( *new_session_ticket ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received overlength New Session Ticket\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_TICKET;\n\t}\n\n\t/* Free any unapplied new session ticket */\n\tfree ( tls->new_session_ticket );\n\ttls->new_session_ticket = NULL;\n\ttls->new_session_ticket_len = 0;\n\n\t/* Record ticket */\n\ttls->new_session_ticket = malloc ( ticket_len );\n\tif ( ! tls->new_session_ticket )\n\t\treturn -ENOMEM;\n\tmemcpy ( tls->new_session_ticket, new_session_ticket->ticket,\n\t\t ticket_len );\n\ttls->new_session_ticket_len = ticket_len;\n\tDBGC ( tls, \"TLS %p new session ticket:\\n\", tls );\n\tDBGC_HDA ( tls, 0, tls->new_session_ticket,\n\t\t   tls->new_session_ticket_len );\n\n\treturn 0;\n}\n\n/**\n * Parse certificate chain\n *\n * @v tls\t\tTLS connection\n * @v data\t\tCertificate chain\n * @v len\t\tLength of certificate chain\n * @ret rc\t\tReturn status code\n */\nstatic int tls_parse_chain ( struct tls_connection *tls,\n\t\t\t     const void *data, size_t len ) {\n\tsize_t remaining = len;\n\tint rc;\n\n\t/* Free any existing certificate chain */\n\tx509_chain_put ( tls->chain );\n\ttls->chain = NULL;\n\n\t/* Create certificate chain */\n\ttls->chain = x509_alloc_chain();\n\tif ( ! tls->chain ) {\n\t\trc = -ENOMEM_CHAIN;\n\t\tgoto err_alloc_chain;\n\t}\n\n\t/* Add certificates to chain */\n\twhile ( remaining ) {\n\t\tconst struct {\n\t\t\ttls24_t length;\n\t\t\tuint8_t data[0];\n\t\t} __attribute__ (( packed )) *certificate = data;\n\t\tsize_t certificate_len;\n\t\tsize_t record_len;\n\t\tstruct x509_certificate *cert;\n\n\t\t/* Parse header */\n\t\tif ( sizeof ( *certificate ) > remaining ) {\n\t\t\tDBGC ( tls, \"TLS %p underlength certificate:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\trc = -EINVAL_CERTIFICATE;\n\t\t\tgoto err_underlength;\n\t\t}\n\t\tcertificate_len = tls_uint24 ( &certificate->length );\n\t\tif ( certificate_len > ( remaining - sizeof ( *certificate ) )){\n\t\t\tDBGC ( tls, \"TLS %p overlength certificate:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\trc = -EINVAL_CERTIFICATE;\n\t\t\tgoto err_overlength;\n\t\t}\n\t\trecord_len = ( sizeof ( *certificate ) + certificate_len );\n\n\t\t/* Add certificate to chain */\n\t\tif ( ( rc = x509_append_raw ( tls->chain, certificate->data,\n\t\t\t\t\t      certificate_len ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not append certificate: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\tgoto err_parse;\n\t\t}\n\t\tcert = x509_last ( tls->chain );\n\t\tDBGC ( tls, \"TLS %p found certificate %s\\n\",\n\t\t       tls, x509_name ( cert ) );\n\n\t\t/* Move to next certificate in list */\n\t\tdata += record_len;\n\t\tremaining -= record_len;\n\t}\n\n\treturn 0;\n\n err_parse:\n err_overlength:\n err_underlength:\n\tx509_chain_put ( tls->chain );\n\ttls->chain = NULL;\n err_alloc_chain:\n\treturn rc;\n}\n\n/**\n * Receive new Certificate handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_certificate ( struct tls_connection *tls,\n\t\t\t\t const void *data, size_t len ) {\n\tconst struct {\n\t\ttls24_t length;\n\t\tuint8_t certificates[0];\n\t} __attribute__ (( packed )) *certificate = data;\n\tsize_t certificates_len;\n\tint rc;\n\n\t/* Parse header */\n\tif ( sizeof ( *certificate ) > len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength Server Certificate\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CERTIFICATES;\n\t}\n\tcertificates_len = tls_uint24 ( &certificate->length );\n\tif ( certificates_len > ( len - sizeof ( *certificate ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Server Certificate\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CERTIFICATES;\n\t}\n\n\t/* Parse certificate chain */\n\tif ( ( rc = tls_parse_chain ( tls, certificate->certificates,\n\t\t\t\t      certificates_len ) ) != 0 )\n\t\treturn rc;\n\n\treturn 0;\n}\n\n/**\n * Receive new Server Key Exchange handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_key_exchange ( struct tls_connection *tls,\n\t\t\t\t\t const void *data, size_t len ) {\n\n\t/* Free any existing server key exchange record */\n\tfree ( tls->server_key );\n\ttls->server_key_len = 0;\n\n\t/* Allocate copy of server key exchange record */\n\ttls->server_key = malloc ( len );\n\tif ( ! tls->server_key )\n\t\treturn -ENOMEM;\n\n\t/* Store copy of server key exchange record for later\n\t * processing.  We cannot verify the signature at this point\n\t * since the certificate validation will not yet have\n\t * completed.\n\t */\n\tmemcpy ( tls->server_key, data, len );\n\ttls->server_key_len = len;\n\n\treturn 0;\n}\n\n/**\n * Receive new Certificate Request handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_certificate_request ( struct tls_connection *tls,\n\t\t\t\t\t const void *data __unused,\n\t\t\t\t\t size_t len __unused ) {\n\tstruct x509_certificate *cert;\n\tint rc;\n\n\t/* We can only send a single certificate, so there is no point\n\t * in parsing the Certificate Request.\n\t */\n\n\t/* Free any existing client certificate chain */\n\tx509_chain_put ( tls->certs );\n\ttls->certs = NULL;\n\n\t/* Determine client certificate to be sent */\n\tcert = certstore_find_key ( tls->key );\n\tif ( ! cert ) {\n\t\tDBGC ( tls, \"TLS %p could not find certificate corresponding \"\n\t\t       \"to private key\\n\", tls );\n\t\trc = -EPERM_CLIENT_CERT;\n\t\tgoto err_find;\n\t}\n\tx509_get ( cert );\n\tDBGC ( tls, \"TLS %p selected client certificate %s\\n\",\n\t       tls, x509_name ( cert ) );\n\n\t/* Create client certificate chain */\n\ttls->certs = x509_alloc_chain();\n\tif ( ! tls->certs ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\t/* Append client certificate to chain */\n\tif ( ( rc = x509_append ( tls->certs, cert ) ) != 0 )\n\t\tgoto err_append;\n\n\t/* Append any relevant issuer certificates */\n\tif ( ( rc = x509_auto_append ( tls->certs, &certstore ) ) != 0 )\n\t\tgoto err_auto_append;\n\n\t/* Drop local reference to client certificate */\n\tx509_put ( cert );\n\n\treturn 0;\n\n err_auto_append:\n err_append:\n\tx509_chain_put ( tls->certs );\n\ttls->certs = NULL;\n err_alloc:\n\tx509_put ( cert );\n err_find:\n\treturn rc;\n}\n\n/**\n * Receive new Server Hello Done handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_hello_done ( struct tls_connection *tls,\n\t\t\t\t       const void *data, size_t len ) {\n\tconst struct {\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *hello_done = data;\n\tint rc;\n\n\t/* Sanity check */\n\tif ( sizeof ( *hello_done ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Server Hello Done\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_HELLO_DONE;\n\t}\n\n\t/* Begin certificate validation */\n\tif ( ( rc = create_validator ( &tls->validator, tls->chain,\n\t\t\t\t       tls->root ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not start certificate validation: \"\n\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tpending_get ( &tls->validation );\n\n\treturn 0;\n}\n\n/**\n * Receive new Finished handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_finished ( struct tls_connection *tls,\n\t\t\t      const void *data, size_t len ) {\n\tstruct tls_session *session = tls->session;\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tconst struct {\n\t\tuint8_t verify_data[ sizeof ( tls->verify.server ) ];\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *finished = data;\n\tuint8_t digest_out[ digest->digestsize ];\n\n\t/* Sanity check */\n\tif ( sizeof ( *finished ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Finished\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_FINISHED;\n\t}\n\n\t/* Verify data */\n\ttls_verify_handshake ( tls, digest_out );\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\ttls->verify.server, sizeof ( tls->verify.server ),\n\t\t\t\"server finished\", digest_out, sizeof ( digest_out ) );\n\tif ( memcmp ( tls->verify.server, finished->verify_data,\n\t\t      sizeof ( tls->verify.server ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p verification failed\\n\", tls );\n\t\treturn -EPERM_VERIFY;\n\t}\n\n\t/* Mark server as finished */\n\tpending_put ( &tls->server_negotiation );\n\n\t/* If we are resuming a session (i.e. if the server Finished\n\t * arrives before the client Finished is sent), then schedule\n\t * transmission of Change Cipher and Finished.\n\t */\n\tif ( is_pending ( &tls->client_negotiation ) ) {\n\t\ttls->tx_pending |= ( TLS_TX_CHANGE_CIPHER | TLS_TX_FINISHED );\n\t\ttls_tx_resume ( tls );\n\t}\n\n\t/* Record session ID, ticket, and master secret, if applicable */\n\tif ( tls->session_id_len || tls->new_session_ticket_len ) {\n\t\tmemcpy ( session->master_secret, tls->master_secret,\n\t\t\t sizeof ( session->master_secret ) );\n\t}\n\tif ( tls->session_id_len ) {\n\t\tsession->id_len = tls->session_id_len;\n\t\tmemcpy ( session->id, tls->session_id, sizeof ( session->id ) );\n\t}\n\tif ( tls->new_session_ticket_len ) {\n\t\tfree ( session->ticket );\n\t\tsession->ticket = tls->new_session_ticket;\n\t\tsession->ticket_len = tls->new_session_ticket_len;\n\t\ttls->new_session_ticket = NULL;\n\t\ttls->new_session_ticket_len = 0;\n\t}\n\n\t/* Move to end of session's connection list and allow other\n\t * connections to start making progress.\n\t */\n\tlist_del ( &tls->list );\n\tlist_add_tail ( &tls->list, &session->conn );\n\ttls_tx_resume_all ( session );\n\n\t/* Send notification of a window change */\n\txfer_window_changed ( &tls->plainstream );\n\n\treturn 0;\n}\n\n/**\n * Receive new Handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_handshake ( struct tls_connection *tls,\n\t\t\t       const void *data, size_t len ) {\n\tsize_t remaining = len;\n\tint rc;\n\n\twhile ( remaining ) {\n\t\tconst struct {\n\t\t\tuint8_t type;\n\t\t\ttls24_t length;\n\t\t\tuint8_t payload[0];\n\t\t} __attribute__ (( packed )) *handshake = data;\n\t\tconst void *payload;\n\t\tsize_t payload_len;\n\t\tsize_t record_len;\n\n\t\t/* Parse header */\n\t\tif ( sizeof ( *handshake ) > remaining ) {\n\t\t\tDBGC ( tls, \"TLS %p received underlength Handshake\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, remaining );\n\t\t\treturn -EINVAL_HANDSHAKE;\n\t\t}\n\t\tpayload_len = tls_uint24 ( &handshake->length );\n\t\tif ( payload_len > ( remaining - sizeof ( *handshake ) ) ) {\n\t\t\tDBGC ( tls, \"TLS %p received overlength Handshake\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, len );\n\t\t\treturn -EINVAL_HANDSHAKE;\n\t\t}\n\t\tpayload = &handshake->payload;\n\t\trecord_len = ( sizeof ( *handshake ) + payload_len );\n\n\t\t/* Handle payload */\n\t\tswitch ( handshake->type ) {\n\t\tcase TLS_HELLO_REQUEST:\n\t\t\trc = tls_new_hello_request ( tls, payload,\n\t\t\t\t\t\t     payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_HELLO:\n\t\t\trc = tls_new_server_hello ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tcase TLS_NEW_SESSION_TICKET:\n\t\t\trc = tls_new_session_ticket ( tls, payload,\n\t\t\t\t\t\t      payload_len );\n\t\t\tbreak;\n\t\tcase TLS_CERTIFICATE:\n\t\t\trc = tls_new_certificate ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_KEY_EXCHANGE:\n\t\t\trc = tls_new_server_key_exchange ( tls, payload,\n\t\t\t\t\t\t\t   payload_len );\n\t\t\tbreak;\n\t\tcase TLS_CERTIFICATE_REQUEST:\n\t\t\trc = tls_new_certificate_request ( tls, payload,\n\t\t\t\t\t\t\t   payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_HELLO_DONE:\n\t\t\trc = tls_new_server_hello_done ( tls, payload,\n\t\t\t\t\t\t\t payload_len );\n\t\t\tbreak;\n\t\tcase TLS_FINISHED:\n\t\t\trc = tls_new_finished ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBGC ( tls, \"TLS %p ignoring handshake type %d\\n\",\n\t\t\t       tls, handshake->type );\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Add to handshake digest (except for Hello Requests,\n\t\t * which are explicitly excluded).\n\t\t */\n\t\tif ( handshake->type != TLS_HELLO_REQUEST )\n\t\t\ttls_add_handshake ( tls, data, record_len );\n\n\t\t/* Abort on failure */\n\t\tif ( rc != 0 )\n\t\t\treturn rc;\n\n\t\t/* Move to next handshake record */\n\t\tdata += record_len;\n\t\tremaining -= record_len;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Receive new record\n *\n * @v tls\t\tTLS connection\n * @v type\t\tRecord type\n * @v rx_data\t\tList of received data buffers\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_record ( struct tls_connection *tls, unsigned int type,\n\t\t\t    struct list_head *rx_data ) {\n\tstruct io_buffer *iobuf;\n\tint ( * handler ) ( struct tls_connection *tls, const void *data,\n\t\t\t    size_t len );\n\tint rc;\n\n\t/* Deliver data records to the plainstream interface */\n\tif ( type == TLS_TYPE_DATA ) {\n\n\t\t/* Fail unless we are ready to receive data */\n\t\tif ( ! tls_ready ( tls ) )\n\t\t\treturn -ENOTCONN;\n\n\t\t/* Deliver each I/O buffer in turn */\n\t\twhile ( ( iobuf = list_first_entry ( rx_data, struct io_buffer,\n\t\t\t\t\t\t     list ) ) ) {\n\t\t\tlist_del ( &iobuf->list );\n\t\t\tif ( ( rc = xfer_deliver_iob ( &tls->plainstream,\n\t\t\t\t\t\t       iobuf ) ) != 0 ) {\n\t\t\t\tDBGC ( tls, \"TLS %p could not deliver data: \"\n\t\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* For all other records, merge into a single I/O buffer */\n\tiobuf = iob_concatenate ( rx_data );\n\tif ( ! iobuf ) {\n\t\tDBGC ( tls, \"TLS %p could not concatenate non-data record \"\n\t\t       \"type %d\\n\", tls, type );\n\t\treturn -ENOMEM_RX_CONCAT;\n\t}\n\n\t/* Determine handler */\n\tswitch ( type ) {\n\tcase TLS_TYPE_CHANGE_CIPHER:\n\t\thandler = tls_new_change_cipher;\n\t\tbreak;\n\tcase TLS_TYPE_ALERT:\n\t\thandler = tls_new_alert;\n\t\tbreak;\n\tcase TLS_TYPE_HANDSHAKE:\n\t\thandler = tls_new_handshake;\n\t\tbreak;\n\tdefault:\n\t\t/* RFC4346 says that we should just ignore unknown\n\t\t * record types.\n\t\t */\n\t\thandler = NULL;\n\t\tDBGC ( tls, \"TLS %p ignoring record type %d\\n\", tls, type );\n\t\tbreak;\n\t}\n\n\t/* Handle record and free I/O buffer */\n\trc = ( handler ? handler ( tls, iobuf->data, iob_len ( iobuf ) ) : 0 );\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/******************************************************************************\n *\n * Record encryption/decryption\n *\n ******************************************************************************\n */\n\n/**\n * Initialise HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v authhdr\t\tAuthentication header\n */\nstatic void tls_hmac_init ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t    struct tls_auth_header *authhdr ) {\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct digest_algorithm *digest = suite->digest;\n\n\thmac_init ( digest, ctx, cipherspec->mac_secret, suite->mac_len );\n\thmac_update ( digest, ctx, authhdr, sizeof ( *authhdr ) );\n}\n\n/**\n * Update HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v data\t\tData\n * @v len\t\tLength of data\n */\nstatic void tls_hmac_update ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t      const void *data, size_t len ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\n\thmac_update ( digest, ctx, data, len );\n}\n\n/**\n * Finalise HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac_final ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t     void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\n\thmac_final ( digest, ctx, hmac );\n}\n\n/**\n * Calculate HMAC\n *\n * @v cipherspec\tCipher specification\n * @v authhdr\t\tAuthentication header\n * @v data\t\tData\n * @v len\t\tLength of data\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac ( struct tls_cipherspec *cipherspec,\n\t\t       struct tls_auth_header *authhdr,\n\t\t       const void *data, size_t len, void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\n\ttls_hmac_init ( cipherspec, ctx, authhdr );\n\ttls_hmac_update ( cipherspec, ctx, data, len );\n\ttls_hmac_final ( cipherspec, ctx, hmac );\n}\n\n/**\n * Calculate HMAC over list of I/O buffers\n *\n * @v cipherspec\tCipher specification\n * @v authhdr\t\tAuthentication header\n * @v list\t\tList of I/O buffers\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac_list ( struct tls_cipherspec *cipherspec,\n\t\t\t    struct tls_auth_header *authhdr,\n\t\t\t    struct list_head *list, void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\tstruct io_buffer *iobuf;\n\n\ttls_hmac_init ( cipherspec, ctx, authhdr );\n\tlist_for_each_entry ( iobuf, list, list ) {\n\t\ttls_hmac_update ( cipherspec, ctx, iobuf->data,\n\t\t\t\t  iob_len ( iobuf ) );\n\t}\n\ttls_hmac_final ( cipherspec, ctx, hmac );\n}\n\n/**\n * Send plaintext record\n *\n * @v tls\t\tTLS connection\n * @v type\t\tRecord type\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_plaintext ( struct tls_connection *tls, unsigned int type,\n\t\t\t\tconst void *data, size_t len ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tstruct digest_algorithm *digest = suite->digest;\n\tstruct {\n\t\tuint8_t fixed[suite->fixed_iv_len];\n\t\tuint8_t record[suite->record_iv_len];\n\t} __attribute__ (( packed )) iv;\n\tstruct tls_auth_header authhdr;\n\tstruct tls_header *tlshdr;\n\tvoid *plaintext = NULL;\n\tsize_t plaintext_len = len;\n\tstruct io_buffer *ciphertext = NULL;\n\tsize_t ciphertext_len;\n\tsize_t padding_len;\n\tuint8_t mac[digest->digestsize];\n\tvoid *tmp;\n\tint rc;\n\n\t/* Construct initialisation vector */\n\tmemcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );\n\ttls_generate_random ( tls, iv.record, sizeof ( iv.record ) );\n\n\t/* Construct authentication data */\n\tauthhdr.seq = cpu_to_be64 ( tls->tx_seq );\n\tauthhdr.header.type = type;\n\tauthhdr.header.version = htons ( tls->version );\n\tauthhdr.header.length = htons ( len );\n\n\t/* Calculate padding length */\n\tplaintext_len += suite->mac_len;\n\tif ( is_block_cipher ( cipher ) ) {\n\t\tpadding_len = ( ( ( cipher->blocksize - 1 ) &\n\t\t\t\t  -( plaintext_len + 1 ) ) + 1 );\n\t} else {\n\t\tpadding_len = 0;\n\t}\n\tplaintext_len += padding_len;\n\n\t/* Allocate plaintext */\n\tplaintext = malloc ( plaintext_len );\n\tif ( ! plaintext ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for \"\n\t\t       \"plaintext\\n\", tls, plaintext_len );\n\t\trc = -ENOMEM_TX_PLAINTEXT;\n\t\tgoto done;\n\t}\n\n\t/* Assemble plaintext */\n\ttmp = plaintext;\n\tmemcpy ( tmp, data, len );\n\ttmp += len;\n\tif ( suite->mac_len )\n\t\ttls_hmac ( cipherspec, &authhdr, data, len, mac );\n\tmemcpy ( tmp, mac, suite->mac_len );\n\ttmp += suite->mac_len;\n\tmemset ( tmp, ( padding_len - 1 ), padding_len );\n\ttmp += padding_len;\n\tassert ( tmp == ( plaintext + plaintext_len ) );\n\tDBGC2 ( tls, \"Sending plaintext data:\\n\" );\n\tDBGC2_HD ( tls, plaintext, plaintext_len );\n\n\t/* Set initialisation vector */\n\tcipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );\n\n\t/* Allocate ciphertext */\n\tciphertext_len = ( sizeof ( *tlshdr ) + sizeof ( iv.record ) +\n\t\t\t   plaintext_len );\n\tciphertext = xfer_alloc_iob ( &tls->cipherstream, ciphertext_len );\n\tif ( ! ciphertext ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for \"\n\t\t       \"ciphertext\\n\", tls, ciphertext_len );\n\t\trc = -ENOMEM_TX_CIPHERTEXT;\n\t\tgoto done;\n\t}\n\n\t/* Assemble ciphertext */\n\ttlshdr = iob_put ( ciphertext, sizeof ( *tlshdr ) );\n\ttlshdr->type = type;\n\ttlshdr->version = htons ( tls->version );\n\ttlshdr->length = htons ( ciphertext_len - sizeof ( *tlshdr ) );\n\tmemcpy ( iob_put ( ciphertext, sizeof ( iv.record ) ), iv.record,\n\t\t sizeof ( iv.record ) );\n\tcipher_encrypt ( cipher, cipherspec->cipher_ctx, plaintext,\n\t\t\t iob_put ( ciphertext, plaintext_len ), plaintext_len );\n\tassert ( iob_len ( ciphertext ) == ciphertext_len );\n\n\t/* Free plaintext as soon as possible to conserve memory */\n\tfree ( plaintext );\n\tplaintext = NULL;\n\n\t/* Send ciphertext */\n\tif ( ( rc = xfer_deliver_iob ( &tls->cipherstream,\n\t\t\t\t       iob_disown ( ciphertext ) ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not deliver ciphertext: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto done;\n\t}\n\n\t/* Update TX state machine to next record */\n\ttls->tx_seq += 1;\n\n done:\n\tfree ( plaintext );\n\tfree_iob ( ciphertext );\n\treturn rc;\n}\n\n/**\n * Verify block padding\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tLast received I/O buffer\n * @ret len\t\tPadding length, or negative error\n * @ret rc\t\tReturn status code\n */\nstatic int tls_verify_padding ( struct tls_connection *tls,\n\t\t\t\tstruct io_buffer *iobuf ) {\n\tuint8_t *padding;\n\tunsigned int pad;\n\tunsigned int i;\n\tsize_t len;\n\n\t/* Extract and verify padding */\n\tpadding = ( iobuf->tail - 1 );\n\tpad = *padding;\n\tlen = ( pad + 1 );\n\tif ( len > iob_len ( iobuf ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength padding\\n\", tls );\n\t\tDBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\treturn -EINVAL_PADDING;\n\t}\n\tfor ( i = 0 ; i < pad ; i++ ) {\n\t\tif ( *(--padding) != pad ) {\n\t\t\tDBGC ( tls, \"TLS %p received bad padding\\n\", tls );\n\t\t\tDBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\t\treturn -EINVAL_PADDING;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * Receive new ciphertext record\n *\n * @v tls\t\tTLS connection\n * @v tlshdr\t\tRecord header\n * @v rx_data\t\tList of received data buffers\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_ciphertext ( struct tls_connection *tls,\n\t\t\t\tstruct tls_header *tlshdr,\n\t\t\t\tstruct list_head *rx_data ) {\n\tstruct tls_cipherspec *cipherspec = &tls->rx_cipherspec;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tstruct digest_algorithm *digest = suite->digest;\n\tsize_t len = ntohs ( tlshdr->length );\n\tstruct {\n\t\tuint8_t fixed[suite->fixed_iv_len];\n\t\tuint8_t record[suite->record_iv_len];\n\t} __attribute__ (( packed )) iv;\n\tstruct tls_auth_header authhdr;\n\tuint8_t verify_mac[digest->digestsize];\n\tstruct io_buffer *first;\n\tstruct io_buffer *last;\n\tstruct io_buffer *iobuf;\n\tvoid *mac;\n\tsize_t check_len;\n\tint pad_len;\n\tint rc;\n\n\t/* Locate first and last data buffers */\n\tassert ( ! list_empty ( rx_data ) );\n\tfirst = list_first_entry ( rx_data, struct io_buffer, list );\n\tlast = list_last_entry ( rx_data, struct io_buffer, list );\n\n\t/* Extract initialisation vector */\n\tif ( iob_len ( first ) < sizeof ( iv.record ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength IV\\n\", tls );\n\t\tDBGC_HD ( tls, first->data, iob_len ( first ) );\n\t\treturn -EINVAL_IV;\n\t}\n\tmemcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );\n\tmemcpy ( iv.record, first->data, sizeof ( iv.record ) );\n\tiob_pull ( first, sizeof ( iv.record ) );\n\tlen -= sizeof ( iv.record );\n\n\t/* Construct authentication data */\n\tauthhdr.seq = cpu_to_be64 ( tls->rx_seq );\n\tauthhdr.header.type = tlshdr->type;\n\tauthhdr.header.version = tlshdr->version;\n\tauthhdr.header.length = htons ( len );\n\n\t/* Set initialisation vector */\n\tcipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );\n\n\t/* Decrypt the received data */\n\tcheck_len = 0;\n\tlist_for_each_entry ( iobuf, &tls->rx_data, list ) {\n\t\tcipher_decrypt ( cipher, cipherspec->cipher_ctx,\n\t\t\t\t iobuf->data, iobuf->data, iob_len ( iobuf ) );\n\t\tcheck_len += iob_len ( iobuf );\n\t}\n\tassert ( check_len == len );\n\n\t/* Strip block padding, if applicable */\n\tif ( is_block_cipher ( cipher ) ) {\n\t\tpad_len = tls_verify_padding ( tls, last );\n\t\tif ( pad_len < 0 ) {\n\t\t\trc = pad_len;\n\t\t\treturn rc;\n\t\t}\n\t\tiob_unput ( last, pad_len );\n\t\tlen -= pad_len;\n\t}\n\n\t/* Extract decrypted MAC */\n\tif ( iob_len ( last ) < suite->mac_len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength MAC\\n\", tls );\n\t\tDBGC_HD ( tls, last->data, iob_len ( last ) );\n\t\treturn -EINVAL_MAC;\n\t}\n\tiob_unput ( last, suite->mac_len );\n\tlen -= suite->mac_len;\n\tmac = last->tail;\n\n\t/* Dump received data */\n\tDBGC2 ( tls, \"Received plaintext data:\\n\" );\n\tcheck_len = 0;\n\tlist_for_each_entry ( iobuf, rx_data, list ) {\n\t\tDBGC2_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\tcheck_len += iob_len ( iobuf );\n\t}\n\tassert ( check_len == len );\n\n\t/* Generate MAC */\n\tauthhdr.header.length = htons ( len );\n\tif ( suite->mac_len )\n\t\ttls_hmac_list ( cipherspec, &authhdr, rx_data, verify_mac );\n\n\t/* Verify MAC */\n\tif ( memcmp ( mac, verify_mac, suite->mac_len ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p failed MAC verification\\n\", tls );\n\t\treturn -EINVAL_MAC;\n\t}\n\n\t/* Process plaintext record */\n\tif ( ( rc = tls_new_record ( tls, tlshdr->type, rx_data ) ) != 0 )\n\t\treturn rc;\n\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Plaintext stream operations\n *\n ******************************************************************************\n */\n\n/**\n * Check flow control window\n *\n * @v tls\t\tTLS connection\n * @ret len\t\tLength of window\n */\nstatic size_t tls_plainstream_window ( struct tls_connection *tls ) {\n\n\t/* Block window unless we are ready to accept data */\n\tif ( ! tls_ready ( tls ) )\n\t\treturn 0;\n\n\treturn xfer_window ( &tls->cipherstream );\n}\n\n/**\n * Deliver datagram as raw data\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tI/O buffer\n * @v meta\t\tData transfer metadata\n * @ret rc\t\tReturn status code\n */\nstatic int tls_plainstream_deliver ( struct tls_connection *tls,\n\t\t\t\t     struct io_buffer *iobuf,\n\t\t\t\t     struct xfer_metadata *meta __unused ) {\n\tint rc;\n\t\n\t/* Refuse unless we are ready to accept data */\n\tif ( ! tls_ready ( tls ) ) {\n\t\trc = -ENOTCONN;\n\t\tgoto done;\n\t}\n\n\tif ( ( rc = tls_send_plaintext ( tls, TLS_TYPE_DATA, iobuf->data,\n\t\t\t\t\t iob_len ( iobuf ) ) ) != 0 )\n\t\tgoto done;\n\n done:\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/**\n * Report job progress\n *\n * @v tls\t\tTLS connection\n * @v progress\t\tProgress report to fill in\n * @ret ongoing_rc\tOngoing job status code (if known)\n */\nstatic int tls_progress ( struct tls_connection *tls,\n\t\t\t  struct job_progress *progress ) {\n\n\t/* Return cipherstream or validator progress as applicable */\n\tif ( is_pending ( &tls->validation ) ) {\n\t\treturn job_progress ( &tls->validator, progress );\n\t} else {\n\t\treturn job_progress ( &tls->cipherstream, progress );\n\t}\n}\n\n/** TLS plaintext stream interface operations */\nstatic struct interface_operation tls_plainstream_ops[] = {\n\tINTF_OP ( xfer_deliver, struct tls_connection *,\n\t\t  tls_plainstream_deliver ),\n\tINTF_OP ( xfer_window, struct tls_connection *,\n\t\t  tls_plainstream_window ),\n\tINTF_OP ( job_progress, struct tls_connection *, tls_progress ),\n\tINTF_OP ( intf_close, struct tls_connection *, tls_close ),\n};\n\n/** TLS plaintext stream interface descriptor */\nstatic struct interface_descriptor tls_plainstream_desc =\n\tINTF_DESC_PASSTHRU ( struct tls_connection, plainstream,\n\t\t\t     tls_plainstream_ops, cipherstream );\n\n/******************************************************************************\n *\n * Ciphertext stream operations\n *\n ******************************************************************************\n */\n\n/**\n * Handle received TLS header\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturned status code\n */\nstatic int tls_newdata_process_header ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->rx_cipherspec;\n\tstruct cipher_algorithm *cipher = cipherspec->suite->cipher;\n\tsize_t iv_len = cipherspec->suite->record_iv_len;\n\tsize_t data_len = ntohs ( tls->rx_header.length );\n\tsize_t remaining = data_len;\n\tsize_t frag_len;\n\tsize_t reserve;\n\tstruct io_buffer *iobuf;\n\tstruct io_buffer *tmp;\n\tint rc;\n\n\t/* Sanity check */\n\tassert ( ( TLS_RX_BUFSIZE % cipher->alignsize ) == 0 );\n\n\t/* Calculate alignment reservation at start of first data buffer */\n\treserve = ( ( -iv_len ) & ( cipher->alignsize - 1 ) );\n\tremaining += reserve;\n\n\t/* Allocate data buffers now that we know the length */\n\tassert ( list_empty ( &tls->rx_data ) );\n\twhile ( remaining ) {\n\n\t\t/* Calculate fragment length.  Ensure that no block is\n\t\t * smaller than TLS_RX_MIN_BUFSIZE (by increasing the\n\t\t * allocation length if necessary).\n\t\t */\n\t\tfrag_len = remaining;\n\t\tif ( frag_len > TLS_RX_BUFSIZE )\n\t\t\tfrag_len = TLS_RX_BUFSIZE;\n\t\tremaining -= frag_len;\n\t\tif ( remaining < TLS_RX_MIN_BUFSIZE ) {\n\t\t\tfrag_len += remaining;\n\t\t\tremaining = 0;\n\t\t}\n\n\t\t/* Allocate buffer */\n\t\tiobuf = alloc_iob_raw ( frag_len, TLS_RX_ALIGN, 0 );\n\t\tif ( ! iobuf ) {\n\t\t\tDBGC ( tls, \"TLS %p could not allocate %zd of %zd \"\n\t\t\t       \"bytes for receive buffer\\n\", tls,\n\t\t\t       remaining, data_len );\n\t\t\trc = -ENOMEM_RX_DATA;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Ensure tailroom is exactly what we asked for.  This\n\t\t * will result in unaligned I/O buffers when the\n\t\t * fragment length is unaligned, which can happen only\n\t\t * before we switch to using a block cipher.\n\t\t */\n\t\tiob_reserve ( iobuf, ( iob_tailroom ( iobuf ) - frag_len ) );\n\n\t\t/* Ensure first buffer length will be aligned to a\n\t\t * multiple of the cipher alignment size after\n\t\t * stripping the record IV.\n\t\t */\n\t\tiob_reserve ( iobuf, reserve );\n\t\treserve = 0;\n\n\t\t/* Add I/O buffer to list */\n\t\tlist_add_tail ( &iobuf->list, &tls->rx_data );\n\t}\n\n\t/* Move to data state */\n\ttls->rx_state = TLS_RX_DATA;\n\n\treturn 0;\n\n err:\n\tlist_for_each_entry_safe ( iobuf, tmp, &tls->rx_data, list ) {\n\t\tlist_del ( &iobuf->list );\n\t\tfree_iob ( iobuf );\n\t}\n\treturn rc;\n}\n\n/**\n * Handle received TLS data payload\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturned status code\n */\nstatic int tls_newdata_process_data ( struct tls_connection *tls ) {\n\tstruct io_buffer *iobuf;\n\tint rc;\n\n\t/* Move current buffer to end of list */\n\tiobuf = list_first_entry ( &tls->rx_data, struct io_buffer, list );\n\tlist_del ( &iobuf->list );\n\tlist_add_tail ( &iobuf->list, &tls->rx_data );\n\n\t/* Continue receiving data if any space remains */\n\tiobuf = list_first_entry ( &tls->rx_data, struct io_buffer, list );\n\tif ( iob_tailroom ( iobuf ) )\n\t\treturn 0;\n\n\t/* Process record */\n\tif ( ( rc = tls_new_ciphertext ( tls, &tls->rx_header,\n\t\t\t\t\t &tls->rx_data ) ) != 0 )\n\t\treturn rc;\n\n\t/* Increment RX sequence number */\n\ttls->rx_seq += 1;\n\n\t/* Return to header state */\n\tassert ( list_empty ( &tls->rx_data ) );\n\ttls->rx_state = TLS_RX_HEADER;\n\tiob_unput ( &tls->rx_header_iobuf, sizeof ( tls->rx_header ) );\n\n\treturn 0;\n}\n\n/**\n * Check flow control window\n *\n * @v tls\t\tTLS connection\n * @ret len\t\tLength of window\n */\nstatic size_t tls_cipherstream_window ( struct tls_connection *tls ) {\n\n\t/* Open window until we are ready to accept data */\n\tif ( ! tls_ready ( tls ) )\n\t\treturn -1UL;\n\n\treturn xfer_window ( &tls->plainstream );\n}\n\n/**\n * Receive new ciphertext\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tI/O buffer\n * @v meta\t\tData transfer metadat\n * @ret rc\t\tReturn status code\n */\nstatic int tls_cipherstream_deliver ( struct tls_connection *tls,\n\t\t\t\t      struct io_buffer *iobuf,\n\t\t\t\t      struct xfer_metadata *xfer __unused ) {\n\tsize_t frag_len;\n\tint ( * process ) ( struct tls_connection *tls );\n\tstruct io_buffer *dest;\n\tint rc;\n\n\twhile ( iob_len ( iobuf ) ) {\n\n\t\t/* Select buffer according to current state */\n\t\tswitch ( tls->rx_state ) {\n\t\tcase TLS_RX_HEADER:\n\t\t\tdest = &tls->rx_header_iobuf;\n\t\t\tprocess = tls_newdata_process_header;\n\t\t\tbreak;\n\t\tcase TLS_RX_DATA:\n\t\t\tdest = list_first_entry ( &tls->rx_data,\n\t\t\t\t\t\t  struct io_buffer, list );\n\t\t\tassert ( dest != NULL );\n\t\t\tprocess = tls_newdata_process_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert ( 0 );\n\t\t\trc = -EINVAL_RX_STATE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Copy data portion to buffer */\n\t\tfrag_len = iob_len ( iobuf );\n\t\tif ( frag_len > iob_tailroom ( dest ) )\n\t\t\tfrag_len = iob_tailroom ( dest );\n\t\tmemcpy ( iob_put ( dest, frag_len ), iobuf->data, frag_len );\n\t\tiob_pull ( iobuf, frag_len );\n\n\t\t/* Process data if buffer is now full */\n\t\tif ( iob_tailroom ( dest ) == 0 ) {\n\t\t\tif ( ( rc = process ( tls ) ) != 0 ) {\n\t\t\t\ttls_close ( tls, rc );\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\n\n done:\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/** TLS ciphertext stream interface operations */\nstatic struct interface_operation tls_cipherstream_ops[] = {\n\tINTF_OP ( xfer_deliver, struct tls_connection *,\n\t\t  tls_cipherstream_deliver ),\n\tINTF_OP ( xfer_window, struct tls_connection *,\n\t\t  tls_cipherstream_window ),\n\tINTF_OP ( xfer_window_changed, struct tls_connection *,\n\t\t  tls_tx_resume ),\n\tINTF_OP ( intf_close, struct tls_connection *, tls_close ),\n};\n\n/** TLS ciphertext stream interface descriptor */\nstatic struct interface_descriptor tls_cipherstream_desc =\n\tINTF_DESC_PASSTHRU ( struct tls_connection, cipherstream,\n\t\t\t     tls_cipherstream_ops, plainstream );\n\n/******************************************************************************\n *\n * Certificate validator\n *\n ******************************************************************************\n */\n\n/**\n * Handle certificate validation completion\n *\n * @v tls\t\tTLS connection\n * @v rc\t\tReason for completion\n */\nstatic void tls_validator_done ( struct tls_connection *tls, int rc ) {\n\tstruct tls_session *session = tls->session;\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey = cipherspec->suite->pubkey;\n\tstruct x509_certificate *cert;\n\n\t/* Mark validation as complete */\n\tpending_put ( &tls->validation );\n\n\t/* Close validator interface */\n\tintf_restart ( &tls->validator, rc );\n\n\t/* Check for validation failure */\n\tif ( rc != 0 ) {\n\t\tDBGC ( tls, \"TLS %p certificate validation failed: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\tDBGC ( tls, \"TLS %p certificate validation succeeded\\n\", tls );\n\n\t/* Extract first certificate */\n\tcert = x509_first ( tls->chain );\n\tassert ( cert != NULL );\n\n\t/* Verify server name */\n\tif ( ( rc = x509_check_name ( cert, session->name ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p server certificate does not match %s: %s\\n\",\n\t\t       tls, session->name, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\n\t/* Initialise public key algorithm */\n\tif ( ( rc = pubkey_init ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t\t  cert->subject.public_key.raw.data,\n\t\t\t\t  cert->subject.public_key.raw.len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p cannot initialise public key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\n\t/* Schedule Client Key Exchange, Change Cipher, and Finished */\n\ttls->tx_pending |= ( TLS_TX_CLIENT_KEY_EXCHANGE |\n\t\t\t     TLS_TX_CHANGE_CIPHER |\n\t\t\t     TLS_TX_FINISHED );\n\tif ( tls->certs ) {\n\t\ttls->tx_pending |= ( TLS_TX_CERTIFICATE |\n\t\t\t\t     TLS_TX_CERTIFICATE_VERIFY );\n\t}\n\ttls_tx_resume ( tls );\n\n\treturn;\n\n err:\n\ttls_close ( tls, rc );\n\treturn;\n}\n\n/** TLS certificate validator interface operations */\nstatic struct interface_operation tls_validator_ops[] = {\n\tINTF_OP ( intf_close, struct tls_connection *, tls_validator_done ),\n};\n\n/** TLS certificate validator interface descriptor */\nstatic struct interface_descriptor tls_validator_desc =\n\tINTF_DESC ( struct tls_connection, validator, tls_validator_ops );\n\n/******************************************************************************\n *\n * Controlling process\n *\n ******************************************************************************\n */\n\n/**\n * TLS TX state machine\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_tx_step ( struct tls_connection *tls ) {\n\tstruct tls_session *session = tls->session;\n\tstruct tls_connection *conn;\n\tint rc;\n\n\t/* Wait for cipherstream to become ready */\n\tif ( ! xfer_window ( &tls->cipherstream ) )\n\t\treturn;\n\n\t/* Send first pending transmission */\n\tif ( tls->tx_pending & TLS_TX_CLIENT_HELLO ) {\n\t\t/* Serialise server negotiations within a session, to\n\t\t * provide a consistent view of session IDs and\n\t\t * session tickets.\n\t\t */\n\t\tlist_for_each_entry ( conn, &session->conn, list ) {\n\t\t\tif ( conn == tls )\n\t\t\t\tbreak;\n\t\t\tif ( is_pending ( &conn->server_negotiation ) )\n\t\t\t\treturn;\n\t\t}\n\t\t/* Record or generate session ID and associated master secret */\n\t\tif ( session->id_len ) {\n\t\t\t/* Attempt to resume an existing session */\n\t\t\tmemcpy ( tls->session_id, session->id,\n\t\t\t\t sizeof ( tls->session_id ) );\n\t\t\ttls->session_id_len = session->id_len;\n\t\t\tmemcpy ( tls->master_secret, session->master_secret,\n\t\t\t\t sizeof ( tls->master_secret ) );\n\t\t} else {\n\t\t\t/* No existing session: use a random session ID */\n\t\t\tassert ( sizeof ( tls->session_id ) ==\n\t\t\t\t sizeof ( tls->client_random ) );\n\t\t\tmemcpy ( tls->session_id, &tls->client_random,\n\t\t\t\t sizeof ( tls->session_id ) );\n\t\t\ttls->session_id_len = sizeof ( tls->session_id );\n\t\t}\n\t\t/* Send Client Hello */\n\t\tif ( ( rc = tls_send_client_hello ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Client Hello: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CLIENT_HELLO;\n\t} else if ( tls->tx_pending & TLS_TX_CERTIFICATE ) {\n\t\t/* Send Certificate */\n\t\tif ( ( rc = tls_send_certificate ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p cold not send Certificate: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CERTIFICATE;\n\t} else if ( tls->tx_pending & TLS_TX_CLIENT_KEY_EXCHANGE ) {\n\t\t/* Send Client Key Exchange */\n\t\tif ( ( rc = tls_send_client_key_exchange ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Client Key \"\n\t\t\t       \"Exchange: %s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CLIENT_KEY_EXCHANGE;\n\t} else if ( tls->tx_pending & TLS_TX_CERTIFICATE_VERIFY ) {\n\t\t/* Send Certificate Verify */\n\t\tif ( ( rc = tls_send_certificate_verify ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Certificate \"\n\t\t\t       \"Verify: %s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CERTIFICATE_VERIFY;\n\t} else if ( tls->tx_pending & TLS_TX_CHANGE_CIPHER ) {\n\t\t/* Send Change Cipher, and then change the cipher in use */\n\t\tif ( ( rc = tls_send_change_cipher ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Change Cipher: \"\n\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\tif ( ( rc = tls_change_cipher ( tls,\n\t\t\t\t\t\t&tls->tx_cipherspec_pending,\n\t\t\t\t\t\t&tls->tx_cipherspec )) != 0 ){\n\t\t\tDBGC ( tls, \"TLS %p could not activate TX cipher: \"\n\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_seq = 0;\n\t\ttls->tx_pending &= ~TLS_TX_CHANGE_CIPHER;\n\t} else if ( tls->tx_pending & TLS_TX_FINISHED ) {\n\t\t/* Send Finished */\n\t\tif ( ( rc = tls_send_finished ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Finished: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_FINISHED;\n\t}\n\n\t/* Reschedule process if pending transmissions remain,\n\t * otherwise send notification of a window change.\n\t */\n\tif ( tls->tx_pending ) {\n\t\ttls_tx_resume ( tls );\n\t} else {\n\t\txfer_window_changed ( &tls->plainstream );\n\t}\n\n\treturn;\n\n err:\n\ttls_close ( tls, rc );\n}\n\n/** TLS TX process descriptor */\nstatic struct process_descriptor tls_process_desc =\n\tPROC_DESC_ONCE ( struct tls_connection, process, tls_tx_step );\n\n/******************************************************************************\n *\n * Session management\n *\n ******************************************************************************\n */\n\n/**\n * Find or create session for TLS connection\n *\n * @v tls\t\tTLS connection\n * @v name\t\tServer name\n * @ret rc\t\tReturn status code\n */\nstatic int tls_session ( struct tls_connection *tls, const char *name ) {\n\tstruct tls_session *session;\n\tchar *name_copy;\n\tint rc;\n\n\t/* Find existing matching session, if any */\n\tlist_for_each_entry ( session, &tls_sessions, list ) {\n\t\tif ( ( strcmp ( name, session->name ) == 0 ) &&\n\t\t     ( tls->root == session->root ) &&\n\t\t     ( tls->key == session->key ) ) {\n\t\t\tref_get ( &session->refcnt );\n\t\t\ttls->session = session;\n\t\t\tDBGC ( tls, \"TLS %p joining session %s\\n\", tls, name );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Create new session */\n\tsession = zalloc ( sizeof ( *session ) + strlen ( name )\n\t\t\t   + 1 /* NUL */ );\n\tif ( ! session ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tref_init ( &session->refcnt, free_tls_session );\n\tname_copy = ( ( ( void * ) session ) + sizeof ( *session ) );\n\tstrcpy ( name_copy, name );\n\tsession->name = name_copy;\n\tsession->root = x509_root_get ( tls->root );\n\tsession->key = privkey_get ( tls->key );\n\tINIT_LIST_HEAD ( &session->conn );\n\tlist_add ( &session->list, &tls_sessions );\n\n\t/* Record session */\n\ttls->session = session;\n\n\tDBGC ( tls, \"TLS %p created session %s\\n\", tls, name );\n\treturn 0;\n\n\tref_put ( &session->refcnt );\n err_alloc:\n\treturn rc;\n}\n\n/******************************************************************************\n *\n * Instantiator\n *\n ******************************************************************************\n */\n\n/**\n * Add TLS on an interface\n *\n * @v xfer\t\tData transfer interface\n * @v name\t\tHost name\n * @v root\t\tRoot of trust (or NULL to use default)\n * @v key\t\tPrivate key (or NULL to use default)\n * @ret rc\t\tReturn status code\n */\nint add_tls ( struct interface *xfer, const char *name,\n\t      struct x509_root *root, struct private_key *key ) {\n\tstruct tls_connection *tls;\n\tint rc;\n\n\t/* Allocate and initialise TLS structure */\n\ttls = malloc ( sizeof ( *tls ) );\n\tif ( ! tls ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tmemset ( tls, 0, sizeof ( *tls ) );\n\tref_init ( &tls->refcnt, free_tls );\n\tINIT_LIST_HEAD ( &tls->list );\n\tintf_init ( &tls->plainstream, &tls_plainstream_desc, &tls->refcnt );\n\tintf_init ( &tls->cipherstream, &tls_cipherstream_desc, &tls->refcnt );\n\tintf_init ( &tls->validator, &tls_validator_desc, &tls->refcnt );\n\tprocess_init_stopped ( &tls->process, &tls_process_desc,\n\t\t\t       &tls->refcnt );\n\ttls->key = privkey_get ( key ? key : &private_key );\n\ttls->root = x509_root_get ( root ? root : &root_certificates );\n\ttls->version = TLS_VERSION_MAX;\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec_pending );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec_pending );\n\ttls->client_random.gmt_unix_time = time ( NULL );\n\tiob_populate ( &tls->rx_header_iobuf, &tls->rx_header, 0,\n\t\t       sizeof ( tls->rx_header ) );\n\tINIT_LIST_HEAD ( &tls->rx_data );\n\tif ( ( rc = tls_generate_random ( tls, &tls->client_random.random,\n\t\t\t  ( sizeof ( tls->client_random.random ) ) ) ) != 0 ) {\n\t\tgoto err_random;\n\t}\n\tif ( ( rc = tls_session ( tls, name ) ) != 0 )\n\t\tgoto err_session;\n\tlist_add_tail ( &tls->list, &tls->session->conn );\n\n\t/* Start negotiation */\n\ttls_restart ( tls );\n\n\t/* Attach to parent interface, mortalise self, and return */\n\tintf_insert ( xfer, &tls->plainstream, &tls->cipherstream );\n\tref_put ( &tls->refcnt );\n\treturn 0;\n\n err_session:\n err_random:\n\tref_put ( &tls->refcnt );\n err_alloc:\n\treturn rc;\n}\n\n/* Drag in objects via add_tls() */\nREQUIRING_SYMBOL ( add_tls );\n\n/* Drag in crypto configuration */\nREQUIRE_OBJECT ( config_crypto );\n"], "fixing_code": ["/*\n * Copyright (C) 2007 Michael Brown <mbrown@fensystems.co.uk>.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\nFILE_LICENCE ( GPL2_OR_LATER );\n\n/**\n * @file\n *\n * Transport Layer Security Protocol\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <byteswap.h>\n#include <ipxe/pending.h>\n#include <ipxe/hmac.h>\n#include <ipxe/md5.h>\n#include <ipxe/sha1.h>\n#include <ipxe/sha256.h>\n#include <ipxe/aes.h>\n#include <ipxe/rsa.h>\n#include <ipxe/iobuf.h>\n#include <ipxe/xfer.h>\n#include <ipxe/open.h>\n#include <ipxe/x509.h>\n#include <ipxe/privkey.h>\n#include <ipxe/certstore.h>\n#include <ipxe/rootcert.h>\n#include <ipxe/rbg.h>\n#include <ipxe/validator.h>\n#include <ipxe/job.h>\n#include <ipxe/dhe.h>\n#include <ipxe/tls.h>\n#include <config/crypto.h>\n\n/* Disambiguate the various error causes */\n#define EINVAL_CHANGE_CIPHER __einfo_error ( EINFO_EINVAL_CHANGE_CIPHER )\n#define EINFO_EINVAL_CHANGE_CIPHER\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x01,\t\t\t\t\\\n\t\t\t  \"Invalid Change Cipher record\" )\n#define EINVAL_ALERT __einfo_error ( EINFO_EINVAL_ALERT )\n#define EINFO_EINVAL_ALERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x02,\t\t\t\t\\\n\t\t\t  \"Invalid Alert record\" )\n#define EINVAL_HELLO __einfo_error ( EINFO_EINVAL_HELLO )\n#define EINFO_EINVAL_HELLO\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x03,\t\t\t\t\\\n\t\t\t  \"Invalid Server Hello record\" )\n#define EINVAL_CERTIFICATE __einfo_error ( EINFO_EINVAL_CERTIFICATE )\n#define EINFO_EINVAL_CERTIFICATE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x04,\t\t\t\t\\\n\t\t\t  \"Invalid Certificate\" )\n#define EINVAL_CERTIFICATES __einfo_error ( EINFO_EINVAL_CERTIFICATES )\n#define EINFO_EINVAL_CERTIFICATES\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x05,\t\t\t\t\\\n\t\t\t  \"Invalid Server Certificate record\" )\n#define EINVAL_HELLO_DONE __einfo_error ( EINFO_EINVAL_HELLO_DONE )\n#define EINFO_EINVAL_HELLO_DONE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x06,\t\t\t\t\\\n\t\t\t  \"Invalid Server Hello Done record\" )\n#define EINVAL_FINISHED __einfo_error ( EINFO_EINVAL_FINISHED )\n#define EINFO_EINVAL_FINISHED\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x07,\t\t\t\t\\\n\t\t\t  \"Invalid Server Finished record\" )\n#define EINVAL_HANDSHAKE __einfo_error ( EINFO_EINVAL_HANDSHAKE )\n#define EINFO_EINVAL_HANDSHAKE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x08,\t\t\t\t\\\n\t\t\t  \"Invalid Handshake record\" )\n#define EINVAL_IV __einfo_error ( EINFO_EINVAL_IV )\n#define EINFO_EINVAL_IV\t\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0a,\t\t\t\t\\\n\t\t\t  \"Invalid initialisation vector\" )\n#define EINVAL_PADDING __einfo_error ( EINFO_EINVAL_PADDING )\n#define EINFO_EINVAL_PADDING\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0b,\t\t\t\t\\\n\t\t\t  \"Invalid block padding\" )\n#define EINVAL_RX_STATE __einfo_error ( EINFO_EINVAL_RX_STATE )\n#define EINFO_EINVAL_RX_STATE\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0c,\t\t\t\t\\\n\t\t\t  \"Invalid receive state\" )\n#define EINVAL_MAC __einfo_error ( EINFO_EINVAL_MAC )\n#define EINFO_EINVAL_MAC\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0d,\t\t\t\t\\\n\t\t\t  \"Invalid MAC\" )\n#define EINVAL_TICKET __einfo_error ( EINFO_EINVAL_TICKET )\n#define EINFO_EINVAL_TICKET\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0e,\t\t\t\t\\\n\t\t\t  \"Invalid New Session Ticket record\")\n#define EINVAL_KEY_EXCHANGE __einfo_error ( EINFO_EINVAL_KEY_EXCHANGE )\n#define EINFO_EINVAL_KEY_EXCHANGE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EINVAL, 0x0f,\t\t\t\t\\\n\t\t\t  \"Invalid Server Key Exchange record\" )\n#define EIO_ALERT __einfo_error ( EINFO_EIO_ALERT )\n#define EINFO_EIO_ALERT\t\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EIO, 0x01,\t\t\t\t\\\n\t\t\t  \"Unknown alert level\" )\n#define ENOMEM_CONTEXT __einfo_error ( EINFO_ENOMEM_CONTEXT )\n#define EINFO_ENOMEM_CONTEXT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x01,\t\t\t\t\\\n\t\t\t  \"Not enough space for crypto context\" )\n#define ENOMEM_CERTIFICATE __einfo_error ( EINFO_ENOMEM_CERTIFICATE )\n#define EINFO_ENOMEM_CERTIFICATE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x02,\t\t\t\t\\\n\t\t\t  \"Not enough space for certificate\" )\n#define ENOMEM_CHAIN __einfo_error ( EINFO_ENOMEM_CHAIN )\n#define EINFO_ENOMEM_CHAIN\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x03,\t\t\t\t\\\n\t\t\t  \"Not enough space for certificate chain\" )\n#define ENOMEM_TX_PLAINTEXT __einfo_error ( EINFO_ENOMEM_TX_PLAINTEXT )\n#define EINFO_ENOMEM_TX_PLAINTEXT\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x04,\t\t\t\t\\\n\t\t\t  \"Not enough space for transmitted plaintext\" )\n#define ENOMEM_TX_CIPHERTEXT __einfo_error ( EINFO_ENOMEM_TX_CIPHERTEXT )\n#define EINFO_ENOMEM_TX_CIPHERTEXT\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x05,\t\t\t\t\\\n\t\t\t  \"Not enough space for transmitted ciphertext\" )\n#define ENOMEM_RX_DATA __einfo_error ( EINFO_ENOMEM_RX_DATA )\n#define EINFO_ENOMEM_RX_DATA\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x07,\t\t\t\t\\\n\t\t\t  \"Not enough space for received data\" )\n#define ENOMEM_RX_CONCAT __einfo_error ( EINFO_ENOMEM_RX_CONCAT )\n#define EINFO_ENOMEM_RX_CONCAT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOMEM, 0x08,\t\t\t\t\\\n\t\t\t  \"Not enough space to concatenate received data\" )\n#define ENOTSUP_CIPHER __einfo_error ( EINFO_ENOTSUP_CIPHER )\n#define EINFO_ENOTSUP_CIPHER\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x01,\t\t\t\t\\\n\t\t\t  \"Unsupported cipher\" )\n#define ENOTSUP_NULL __einfo_error ( EINFO_ENOTSUP_NULL )\n#define EINFO_ENOTSUP_NULL\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x02,\t\t\t\t\\\n\t\t\t  \"Refusing to use null cipher\" )\n#define ENOTSUP_SIG_HASH __einfo_error ( EINFO_ENOTSUP_SIG_HASH )\n#define EINFO_ENOTSUP_SIG_HASH\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x03,\t\t\t\t\\\n\t\t\t  \"Unsupported signature and hash algorithm\" )\n#define ENOTSUP_VERSION __einfo_error ( EINFO_ENOTSUP_VERSION )\n#define EINFO_ENOTSUP_VERSION\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_ENOTSUP, 0x04,\t\t\t\t\\\n\t\t\t  \"Unsupported protocol version\" )\n#define EPERM_ALERT __einfo_error ( EINFO_EPERM_ALERT )\n#define EINFO_EPERM_ALERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x01,\t\t\t\t\\\n\t\t\t  \"Received fatal alert\" )\n#define EPERM_VERIFY __einfo_error ( EINFO_EPERM_VERIFY )\n#define EINFO_EPERM_VERIFY\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x02,\t\t\t\t\\\n\t\t\t  \"Handshake verification failed\" )\n#define EPERM_CLIENT_CERT __einfo_error ( EINFO_EPERM_CLIENT_CERT )\n#define EINFO_EPERM_CLIENT_CERT\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x03,\t\t\t\t\\\n\t\t\t  \"No suitable client certificate available\" )\n#define EPERM_RENEG_INSECURE __einfo_error ( EINFO_EPERM_RENEG_INSECURE )\n#define EINFO_EPERM_RENEG_INSECURE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x04,\t\t\t\t\\\n\t\t\t  \"Secure renegotiation not supported\" )\n#define EPERM_RENEG_VERIFY __einfo_error ( EINFO_EPERM_RENEG_VERIFY )\n#define EINFO_EPERM_RENEG_VERIFY\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x05,\t\t\t\t\\\n\t\t\t  \"Secure renegotiation verification failed\" )\n#define EPERM_KEY_EXCHANGE __einfo_error ( EINFO_EPERM_KEY_EXCHANGE )\n#define EINFO_EPERM_KEY_EXCHANGE\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPERM, 0x06,\t\t\t\t\\\n\t\t\t  \"ServerKeyExchange verification failed\" )\n#define EPROTO_VERSION __einfo_error ( EINFO_EPROTO_VERSION )\n#define EINFO_EPROTO_VERSION\t\t\t\t\t\t\\\n\t__einfo_uniqify ( EINFO_EPROTO, 0x01,\t\t\t\t\\\n\t\t\t  \"Illegal protocol version upgrade\" )\n\n/** List of TLS session */\nstatic LIST_HEAD ( tls_sessions );\n\nstatic void tls_tx_resume_all ( struct tls_session *session );\nstatic int tls_send_plaintext ( struct tls_connection *tls, unsigned int type,\n\t\t\t\tconst void *data, size_t len );\nstatic void tls_clear_cipher ( struct tls_connection *tls,\n\t\t\t       struct tls_cipherspec *cipherspec );\n\n/******************************************************************************\n *\n * Utility functions\n *\n ******************************************************************************\n */\n\n/** A TLS 24-bit integer\n *\n * TLS uses 24-bit integers in several places, which are awkward to\n * parse in C.\n */\ntypedef struct {\n\t/** High byte */\n\tuint8_t high;\n\t/** Low word */\n\tuint16_t low;\n} __attribute__ (( packed )) tls24_t;\n\n/**\n * Extract 24-bit field value\n *\n * @v field24\t\t24-bit field\n * @ret value\t\tField value\n *\n */\nstatic inline __attribute__ (( always_inline )) unsigned long\ntls_uint24 ( const tls24_t *field24 ) {\n\n\treturn ( ( field24->high << 16 ) | be16_to_cpu ( field24->low ) );\n}\n\n/**\n * Set 24-bit field value\n *\n * @v field24\t\t24-bit field\n * @v value\t\tField value\n */\nstatic void tls_set_uint24 ( tls24_t *field24, unsigned long value ) {\n\n\tfield24->high = ( value >> 16 );\n\tfield24->low = cpu_to_be16 ( value );\n}\n\n/**\n * Determine if TLS connection is ready for application data\n *\n * @v tls\t\tTLS connection\n * @ret is_ready\tTLS connection is ready\n */\nstatic int tls_ready ( struct tls_connection *tls ) {\n\treturn ( ( ! is_pending ( &tls->client_negotiation ) ) &&\n\t\t ( ! is_pending ( &tls->server_negotiation ) ) );\n}\n\n/**\n * Check for TLS version\n *\n * @v tls\t\tTLS connection\n * @v version\t\tTLS version\n * @ret at_least\tTLS connection is using at least the specified version\n *\n * Check that TLS connection uses at least the specified protocol\n * version.  Optimise down to a compile-time constant true result if\n * this is already guaranteed by the minimum supported version check.\n */\nstatic inline __attribute__ (( always_inline )) int\ntls_version ( struct tls_connection *tls, unsigned int version ) {\n\treturn ( ( TLS_VERSION_MIN >= version ) ||\n\t\t ( tls->version >= version ) );\n}\n\n/******************************************************************************\n *\n * Hybrid MD5+SHA1 hash as used by TLSv1.1 and earlier\n *\n ******************************************************************************\n */\n\n/**\n * Initialise MD5+SHA1 algorithm\n *\n * @v ctx\t\tMD5+SHA1 context\n */\nstatic void md5_sha1_init ( void *ctx ) {\n\tstruct md5_sha1_context *context = ctx;\n\n\tdigest_init ( &md5_algorithm, context->md5 );\n\tdigest_init ( &sha1_algorithm, context->sha1 );\n}\n\n/**\n * Accumulate data with MD5+SHA1 algorithm\n *\n * @v ctx\t\tMD5+SHA1 context\n * @v data\t\tData\n * @v len\t\tLength of data\n */\nstatic void md5_sha1_update ( void *ctx, const void *data, size_t len ) {\n\tstruct md5_sha1_context *context = ctx;\n\n\tdigest_update ( &md5_algorithm, context->md5, data, len );\n\tdigest_update ( &sha1_algorithm, context->sha1, data, len );\n}\n\n/**\n * Generate MD5+SHA1 digest\n *\n * @v ctx\t\tMD5+SHA1 context\n * @v out\t\tOutput buffer\n */\nstatic void md5_sha1_final ( void *ctx, void *out ) {\n\tstruct md5_sha1_context *context = ctx;\n\tstruct md5_sha1_digest *digest = out;\n\n\tdigest_final ( &md5_algorithm, context->md5, digest->md5 );\n\tdigest_final ( &sha1_algorithm, context->sha1, digest->sha1 );\n}\n\n/** Hybrid MD5+SHA1 digest algorithm */\nstatic struct digest_algorithm md5_sha1_algorithm = {\n\t.name\t\t= \"md5+sha1\",\n\t.ctxsize\t= sizeof ( struct md5_sha1_context ),\n\t.blocksize\t= 0, /* Not applicable */\n\t.digestsize\t= sizeof ( struct md5_sha1_digest ),\n\t.init\t\t= md5_sha1_init,\n\t.update\t\t= md5_sha1_update,\n\t.final\t\t= md5_sha1_final,\n};\n\n/** RSA digestInfo prefix for MD5+SHA1 algorithm */\nstruct rsa_digestinfo_prefix rsa_md5_sha1_prefix __rsa_digestinfo_prefix = {\n\t.digest = &md5_sha1_algorithm,\n\t.data = NULL, /* MD5+SHA1 signatures have no digestInfo */\n\t.len = 0,\n};\n\n/******************************************************************************\n *\n * Cleanup functions\n *\n ******************************************************************************\n */\n\n/**\n * Free TLS session\n *\n * @v refcnt\t\tReference counter\n */\nstatic void free_tls_session ( struct refcnt *refcnt ) {\n\tstruct tls_session *session =\n\t\tcontainer_of ( refcnt, struct tls_session, refcnt );\n\n\t/* Sanity check */\n\tassert ( list_empty ( &session->conn ) );\n\n\t/* Remove from list of sessions */\n\tlist_del ( &session->list );\n\n\t/* Free dynamically-allocated resources */\n\tx509_root_put ( session->root );\n\tprivkey_put ( session->key );\n\tfree ( session->ticket );\n\n\t/* Free session */\n\tfree ( session );\n}\n\n/**\n * Free TLS connection\n *\n * @v refcnt\t\tReference counter\n */\nstatic void free_tls ( struct refcnt *refcnt ) {\n\tstruct tls_connection *tls =\n\t\tcontainer_of ( refcnt, struct tls_connection, refcnt );\n\tstruct tls_session *session = tls->session;\n\tstruct io_buffer *iobuf;\n\tstruct io_buffer *tmp;\n\n\t/* Free dynamically-allocated resources */\n\tfree ( tls->new_session_ticket );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec_pending );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec_pending );\n\tfree ( tls->server_key );\n\tlist_for_each_entry_safe ( iobuf, tmp, &tls->rx_data, list ) {\n\t\tlist_del ( &iobuf->list );\n\t\tfree_iob ( iobuf );\n\t}\n\tx509_chain_put ( tls->certs );\n\tx509_chain_put ( tls->chain );\n\tx509_root_put ( tls->root );\n\tprivkey_put ( tls->key );\n\n\t/* Drop reference to session */\n\tassert ( list_empty ( &tls->list ) );\n\tref_put ( &session->refcnt );\n\n\t/* Free TLS structure itself */\n\tfree ( tls );\n}\n\n/**\n * Finish with TLS connection\n *\n * @v tls\t\tTLS connection\n * @v rc\t\tStatus code\n */\nstatic void tls_close ( struct tls_connection *tls, int rc ) {\n\n\t/* Remove pending operations, if applicable */\n\tpending_put ( &tls->client_negotiation );\n\tpending_put ( &tls->server_negotiation );\n\tpending_put ( &tls->validation );\n\n\t/* Remove process */\n\tprocess_del ( &tls->process );\n\n\t/* Close all interfaces */\n\tintf_shutdown ( &tls->cipherstream, rc );\n\tintf_shutdown ( &tls->plainstream, rc );\n\tintf_shutdown ( &tls->validator, rc );\n\n\t/* Remove from session */\n\tlist_del ( &tls->list );\n\tINIT_LIST_HEAD ( &tls->list );\n\n\t/* Resume all other connections, in case we were the lead connection */\n\ttls_tx_resume_all ( tls->session );\n}\n\n/******************************************************************************\n *\n * Random number generation\n *\n ******************************************************************************\n */\n\n/**\n * Generate random data\n *\n * @v tls\t\tTLS connection\n * @v data\t\tBuffer to fill\n * @v len\t\tLength of buffer\n * @ret rc\t\tReturn status code\n */\nstatic int tls_generate_random ( struct tls_connection *tls,\n\t\t\t\t void *data, size_t len ) {\n\tint rc;\n\n\t/* Generate random bits with no additional input and without\n\t * prediction resistance\n\t */\n\tif ( ( rc = rbg_generate ( NULL, 0, 0, data, len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not generate random data: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Update HMAC with a list of ( data, len ) pairs\n *\n * @v digest\t\tHash function to use\n * @v ctx\t\tHMAC context\n * @v args\t\t( data, len ) pairs of data, terminated by NULL\n */\nstatic void tls_hmac_update_va ( struct digest_algorithm *digest,\n\t\t\t\t void *ctx, va_list args ) {\n\tvoid *data;\n\tsize_t len;\n\n\twhile ( ( data = va_arg ( args, void * ) ) ) {\n\t\tlen = va_arg ( args, size_t );\n\t\thmac_update ( digest, ctx, data, len );\n\t}\n}\n\n/**\n * Generate secure pseudo-random data using a single hash function\n *\n * @v tls\t\tTLS connection\n * @v digest\t\tHash function to use\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v seeds\t\t( data, len ) pairs of seed data, terminated by NULL\n */\nstatic void tls_p_hash_va ( struct tls_connection *tls,\n\t\t\t    struct digest_algorithm *digest,\n\t\t\t    const void *secret, size_t secret_len,\n\t\t\t    void *out, size_t out_len,\n\t\t\t    va_list seeds ) {\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\tuint8_t ctx_partial[ sizeof ( ctx ) ];\n\tuint8_t a[digest->digestsize];\n\tuint8_t out_tmp[digest->digestsize];\n\tsize_t frag_len = digest->digestsize;\n\tva_list tmp;\n\n\tDBGC2 ( tls, \"TLS %p %s secret:\\n\", tls, digest->name );\n\tDBGC2_HD ( tls, secret, secret_len );\n\n\t/* Calculate A(1) */\n\thmac_init ( digest, ctx, secret, secret_len );\n\tva_copy ( tmp, seeds );\n\ttls_hmac_update_va ( digest, ctx, tmp );\n\tva_end ( tmp );\n\thmac_final ( digest, ctx, a );\n\tDBGC2 ( tls, \"TLS %p %s A(1):\\n\", tls, digest->name );\n\tDBGC2_HD ( tls, &a, sizeof ( a ) );\n\n\t/* Generate as much data as required */\n\twhile ( out_len ) {\n\t\t/* Calculate output portion */\n\t\thmac_init ( digest, ctx, secret, secret_len );\n\t\thmac_update ( digest, ctx, a, sizeof ( a ) );\n\t\tmemcpy ( ctx_partial, ctx, sizeof ( ctx_partial ) );\n\t\tva_copy ( tmp, seeds );\n\t\ttls_hmac_update_va ( digest, ctx, tmp );\n\t\tva_end ( tmp );\n\t\thmac_final ( digest, ctx, out_tmp );\n\n\t\t/* Copy output */\n\t\tif ( frag_len > out_len )\n\t\t\tfrag_len = out_len;\n\t\tmemcpy ( out, out_tmp, frag_len );\n\t\tDBGC2 ( tls, \"TLS %p %s output:\\n\", tls, digest->name );\n\t\tDBGC2_HD ( tls, out, frag_len );\n\n\t\t/* Calculate A(i) */\n\t\thmac_final ( digest, ctx_partial, a );\n\t\tDBGC2 ( tls, \"TLS %p %s A(n):\\n\", tls, digest->name );\n\t\tDBGC2_HD ( tls, &a, sizeof ( a ) );\n\n\t\tout += frag_len;\n\t\tout_len -= frag_len;\n\t}\n}\n\n/**\n * Generate secure pseudo-random data\n *\n * @v tls\t\tTLS connection\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v ...\t\t( data, len ) pairs of seed data, terminated by NULL\n */\nstatic void tls_prf ( struct tls_connection *tls, const void *secret,\n\t\t      size_t secret_len, void *out, size_t out_len, ... ) {\n\tva_list seeds;\n\tva_list tmp;\n\tsize_t subsecret_len;\n\tconst void *md5_secret;\n\tconst void *sha1_secret;\n\tuint8_t buf[out_len];\n\tunsigned int i;\n\n\tva_start ( seeds, out_len );\n\n\tif ( tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\t/* Use P_SHA256 for TLSv1.2 and later */\n\t\ttls_p_hash_va ( tls, &sha256_algorithm, secret, secret_len,\n\t\t\t\tout, out_len, seeds );\n\t} else {\n\t\t/* Use combination of P_MD5 and P_SHA-1 for TLSv1.1\n\t\t * and earlier\n\t\t */\n\n\t\t/* Split secret into two, with an overlap of up to one byte */\n\t\tsubsecret_len = ( ( secret_len + 1 ) / 2 );\n\t\tmd5_secret = secret;\n\t\tsha1_secret = ( secret + secret_len - subsecret_len );\n\n\t\t/* Calculate MD5 portion */\n\t\tva_copy ( tmp, seeds );\n\t\ttls_p_hash_va ( tls, &md5_algorithm, md5_secret,\n\t\t\t\tsubsecret_len, out, out_len, seeds );\n\t\tva_end ( tmp );\n\n\t\t/* Calculate SHA1 portion */\n\t\tva_copy ( tmp, seeds );\n\t\ttls_p_hash_va ( tls, &sha1_algorithm, sha1_secret,\n\t\t\t\tsubsecret_len, buf, out_len, seeds );\n\t\tva_end ( tmp );\n\n\t\t/* XOR the two portions together into the final output buffer */\n\t\tfor ( i = 0 ; i < out_len ; i++ )\n\t\t\t*( ( uint8_t * ) out + i ) ^= buf[i];\n\t}\n\n\tva_end ( seeds );\n}\n\n/**\n * Generate secure pseudo-random data\n *\n * @v secret\t\tSecret\n * @v secret_len\tLength of secret\n * @v out\t\tOutput buffer\n * @v out_len\t\tLength of output buffer\n * @v label\t\tString literal label\n * @v ...\t\t( data, len ) pairs of seed data\n */\n#define tls_prf_label( tls, secret, secret_len, out, out_len, label, ... ) \\\n\ttls_prf ( (tls), (secret), (secret_len), (out), (out_len),\t   \\\n\t\t  label, ( sizeof ( label ) - 1 ), __VA_ARGS__, NULL )\n\n/******************************************************************************\n *\n * Secret management\n *\n ******************************************************************************\n */\n\n/**\n * Generate master secret\n *\n * @v tls\t\tTLS connection\n * @v pre_master_secret\tPre-master secret\n * @v pre_master_secret_len Length of pre-master secret\n *\n * The client and server random values must already be known.\n */\nstatic void tls_generate_master_secret ( struct tls_connection *tls,\n\t\t\t\t\t const void *pre_master_secret,\n\t\t\t\t\t size_t pre_master_secret_len ) {\n\n\tDBGC ( tls, \"TLS %p pre-master-secret:\\n\", tls );\n\tDBGC_HD ( tls, pre_master_secret, pre_master_secret_len );\n\tDBGC ( tls, \"TLS %p client random bytes:\\n\", tls );\n\tDBGC_HD ( tls, &tls->client_random, sizeof ( tls->client_random ) );\n\tDBGC ( tls, \"TLS %p server random bytes:\\n\", tls );\n\tDBGC_HD ( tls, &tls->server_random, sizeof ( tls->server_random ) );\n\n\ttls_prf_label ( tls, pre_master_secret, pre_master_secret_len,\n\t\t\t&tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\t\"master secret\",\n\t\t\t&tls->client_random, sizeof ( tls->client_random ),\n\t\t\t&tls->server_random, sizeof ( tls->server_random ) );\n\n\tDBGC ( tls, \"TLS %p generated master secret:\\n\", tls );\n\tDBGC_HD ( tls, &tls->master_secret, sizeof ( tls->master_secret ) );\n}\n\n/**\n * Generate key material\n *\n * @v tls\t\tTLS connection\n *\n * The master secret must already be known.\n */\nstatic int tls_generate_keys ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *tx_cipherspec = &tls->tx_cipherspec_pending;\n\tstruct tls_cipherspec *rx_cipherspec = &tls->rx_cipherspec_pending;\n\tsize_t hash_size = tx_cipherspec->suite->mac_len;\n\tsize_t key_size = tx_cipherspec->suite->key_len;\n\tsize_t iv_size = tx_cipherspec->suite->fixed_iv_len;\n\tsize_t total = ( 2 * ( hash_size + key_size + iv_size ) );\n\tuint8_t key_block[total];\n\tuint8_t *key;\n\tint rc;\n\n\t/* Generate key block */\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\tkey_block, sizeof ( key_block ), \"key expansion\",\n\t\t\t&tls->server_random, sizeof ( tls->server_random ),\n\t\t\t&tls->client_random, sizeof ( tls->client_random ) );\n\n\t/* Split key block into portions */\n\tkey = key_block;\n\n\t/* TX MAC secret */\n\tmemcpy ( tx_cipherspec->mac_secret, key, hash_size );\n\tDBGC ( tls, \"TLS %p TX MAC secret:\\n\", tls );\n\tDBGC_HD ( tls, key, hash_size );\n\tkey += hash_size;\n\n\t/* RX MAC secret */\n\tmemcpy ( rx_cipherspec->mac_secret, key, hash_size );\n\tDBGC ( tls, \"TLS %p RX MAC secret:\\n\", tls );\n\tDBGC_HD ( tls, key, hash_size );\n\tkey += hash_size;\n\n\t/* TX key */\n\tif ( ( rc = cipher_setkey ( tx_cipherspec->suite->cipher,\n\t\t\t\t    tx_cipherspec->cipher_ctx,\n\t\t\t\t    key, key_size ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not set TX key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tDBGC ( tls, \"TLS %p TX key:\\n\", tls );\n\tDBGC_HD ( tls, key, key_size );\n\tkey += key_size;\n\n\t/* RX key */\n\tif ( ( rc = cipher_setkey ( rx_cipherspec->suite->cipher,\n\t\t\t\t    rx_cipherspec->cipher_ctx,\n\t\t\t\t    key, key_size ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not set TX key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tDBGC ( tls, \"TLS %p RX key:\\n\", tls );\n\tDBGC_HD ( tls, key, key_size );\n\tkey += key_size;\n\n\t/* TX initialisation vector */\n\tmemcpy ( tx_cipherspec->fixed_iv, key, iv_size );\n\tDBGC ( tls, \"TLS %p TX IV:\\n\", tls );\n\tDBGC_HD ( tls, key, iv_size );\n\tkey += iv_size;\n\n\t/* RX initialisation vector */\n\tmemcpy ( rx_cipherspec->fixed_iv, key, iv_size );\n\tDBGC ( tls, \"TLS %p RX IV:\\n\", tls );\n\tDBGC_HD ( tls, key, iv_size );\n\tkey += iv_size;\n\n\tassert ( ( key_block + total ) == key );\n\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Cipher suite management\n *\n ******************************************************************************\n */\n\n/** Null cipher suite */\nstruct tls_cipher_suite tls_cipher_suite_null = {\n\t.exchange = &tls_pubkey_exchange_algorithm,\n\t.pubkey = &pubkey_null,\n\t.cipher = &cipher_null,\n\t.digest = &digest_null,\n};\n\n/** Number of supported cipher suites */\n#define TLS_NUM_CIPHER_SUITES table_num_entries ( TLS_CIPHER_SUITES )\n\n/**\n * Identify cipher suite\n *\n * @v cipher_suite\tCipher suite specification\n * @ret suite\t\tCipher suite, or NULL\n */\nstatic struct tls_cipher_suite *\ntls_find_cipher_suite ( unsigned int cipher_suite ) {\n\tstruct tls_cipher_suite *suite;\n\n\t/* Identify cipher suite */\n\tfor_each_table_entry ( suite, TLS_CIPHER_SUITES ) {\n\t\tif ( suite->code == cipher_suite )\n\t\t\treturn suite;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Clear cipher suite\n *\n * @v cipherspec\tTLS cipher specification\n */\nstatic void tls_clear_cipher ( struct tls_connection *tls __unused,\n\t\t\t       struct tls_cipherspec *cipherspec ) {\n\n\tif ( cipherspec->suite ) {\n\t\tpubkey_final ( cipherspec->suite->pubkey,\n\t\t\t       cipherspec->pubkey_ctx );\n\t}\n\tfree ( cipherspec->dynamic );\n\tmemset ( cipherspec, 0, sizeof ( *cipherspec ) );\n\tcipherspec->suite = &tls_cipher_suite_null;\n}\n\n/**\n * Set cipher suite\n *\n * @v tls\t\tTLS connection\n * @v cipherspec\tTLS cipher specification\n * @v suite\t\tCipher suite\n * @ret rc\t\tReturn status code\n */\nstatic int tls_set_cipher ( struct tls_connection *tls,\n\t\t\t    struct tls_cipherspec *cipherspec,\n\t\t\t    struct tls_cipher_suite *suite ) {\n\tstruct pubkey_algorithm *pubkey = suite->pubkey;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tsize_t total;\n\tvoid *dynamic;\n\n\t/* Clear out old cipher contents, if any */\n\ttls_clear_cipher ( tls, cipherspec );\n\n\t/* Allocate dynamic storage */\n\ttotal = ( pubkey->ctxsize + cipher->ctxsize + suite->mac_len +\n\t\t  suite->fixed_iv_len );\n\tdynamic = zalloc ( total );\n\tif ( ! dynamic ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for crypto \"\n\t\t       \"context\\n\", tls, total );\n\t\treturn -ENOMEM_CONTEXT;\n\t}\n\n\t/* Assign storage */\n\tcipherspec->dynamic = dynamic;\n\tcipherspec->pubkey_ctx = dynamic;\tdynamic += pubkey->ctxsize;\n\tcipherspec->cipher_ctx = dynamic;\tdynamic += cipher->ctxsize;\n\tcipherspec->mac_secret = dynamic;\tdynamic += suite->mac_len;\n\tcipherspec->fixed_iv = dynamic;\t\tdynamic += suite->fixed_iv_len;\n\tassert ( ( cipherspec->dynamic + total ) == dynamic );\n\n\t/* Store parameters */\n\tcipherspec->suite = suite;\n\n\treturn 0;\n}\n\n/**\n * Select next cipher suite\n *\n * @v tls\t\tTLS connection\n * @v cipher_suite\tCipher suite specification\n * @ret rc\t\tReturn status code\n */\nstatic int tls_select_cipher ( struct tls_connection *tls,\n\t\t\t       unsigned int cipher_suite ) {\n\tstruct tls_cipher_suite *suite;\n\tint rc;\n\n\t/* Identify cipher suite */\n\tsuite = tls_find_cipher_suite ( cipher_suite );\n\tif ( ! suite ) {\n\t\tDBGC ( tls, \"TLS %p does not support cipher %04x\\n\",\n\t\t       tls, ntohs ( cipher_suite ) );\n\t\treturn -ENOTSUP_CIPHER;\n\t}\n\n\t/* Set ciphers */\n\tif ( ( rc = tls_set_cipher ( tls, &tls->tx_cipherspec_pending,\n\t\t\t\t     suite ) ) != 0 )\n\t\treturn rc;\n\tif ( ( rc = tls_set_cipher ( tls, &tls->rx_cipherspec_pending,\n\t\t\t\t     suite ) ) != 0 )\n\t\treturn rc;\n\n\tDBGC ( tls, \"TLS %p selected %s-%s-%s-%d-%s\\n\", tls,\n\t       suite->exchange->name, suite->pubkey->name,\n\t       suite->cipher->name, ( suite->key_len * 8 ),\n\t       suite->digest->name );\n\n\treturn 0;\n}\n\n/**\n * Activate next cipher suite\n *\n * @v tls\t\tTLS connection\n * @v pending\t\tPending cipher specification\n * @v active\t\tActive cipher specification to replace\n * @ret rc\t\tReturn status code\n */\nstatic int tls_change_cipher ( struct tls_connection *tls,\n\t\t\t       struct tls_cipherspec *pending,\n\t\t\t       struct tls_cipherspec *active ) {\n\n\t/* Sanity check */\n\tif ( pending->suite == &tls_cipher_suite_null ) {\n\t\tDBGC ( tls, \"TLS %p refusing to use null cipher\\n\", tls );\n\t\treturn -ENOTSUP_NULL;\n\t}\n\n\ttls_clear_cipher ( tls, active );\n\tmemswap ( active, pending, sizeof ( *active ) );\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Signature and hash algorithms\n *\n ******************************************************************************\n */\n\n/** Number of supported signature and hash algorithms */\n#define TLS_NUM_SIG_HASH_ALGORITHMS \\\n\ttable_num_entries ( TLS_SIG_HASH_ALGORITHMS )\n\n/**\n * Find TLS signature and hash algorithm\n *\n * @v pubkey\t\tPublic-key algorithm\n * @v digest\t\tDigest algorithm\n * @ret sig_hash\tSignature and hash algorithm, or NULL\n */\nstatic struct tls_signature_hash_algorithm *\ntls_signature_hash_algorithm ( struct pubkey_algorithm *pubkey,\n\t\t\t       struct digest_algorithm *digest ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( ( sig_hash->pubkey == pubkey ) &&\n\t\t     ( sig_hash->digest == digest ) ) {\n\t\t\treturn sig_hash;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Find TLS signature algorithm\n *\n * @v code\t\tSignature and hash algorithm identifier\n * @ret pubkey\t\tPublic key algorithm, or NULL\n */\nstatic struct pubkey_algorithm *\ntls_signature_hash_pubkey ( struct tls_signature_hash_id code ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( sig_hash->code.signature == code.signature )\n\t\t\treturn sig_hash->pubkey;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Find TLS hash algorithm\n *\n * @v code\t\tSignature and hash algorithm identifier\n * @ret digest\t\tDigest algorithm, or NULL\n */\nstatic struct digest_algorithm *\ntls_signature_hash_digest ( struct tls_signature_hash_id code ) {\n\tstruct tls_signature_hash_algorithm *sig_hash;\n\n\t/* Identify signature and hash algorithm */\n\tfor_each_table_entry ( sig_hash, TLS_SIG_HASH_ALGORITHMS ) {\n\t\tif ( sig_hash->code.hash == code.hash )\n\t\t\treturn sig_hash->digest;\n\t}\n\n\treturn NULL;\n}\n\n/******************************************************************************\n *\n * Handshake verification\n *\n ******************************************************************************\n */\n\n/**\n * Add handshake record to verification hash\n *\n * @v tls\t\tTLS connection\n * @v data\t\tHandshake record\n * @v len\t\tLength of handshake record\n */\nstatic void tls_add_handshake ( struct tls_connection *tls,\n\t\t\t\tconst void *data, size_t len ) {\n\n\tdigest_update ( &md5_sha1_algorithm, tls->handshake_md5_sha1_ctx,\n\t\t\tdata, len );\n\tdigest_update ( &sha256_algorithm, tls->handshake_sha256_ctx,\n\t\t\tdata, len );\n}\n\n/**\n * Calculate handshake verification hash\n *\n * @v tls\t\tTLS connection\n * @v out\t\tOutput buffer\n *\n * Calculates the MD5+SHA1 or SHA256 digest over all handshake\n * messages seen so far.\n */\nstatic void tls_verify_handshake ( struct tls_connection *tls, void *out ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tuint8_t ctx[ digest->ctxsize ];\n\n\tmemcpy ( ctx, tls->handshake_ctx, sizeof ( ctx ) );\n\tdigest_final ( digest, ctx, out );\n}\n\n/******************************************************************************\n *\n * Record handling\n *\n ******************************************************************************\n */\n\n/**\n * Resume TX state machine\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_tx_resume ( struct tls_connection *tls ) {\n\tprocess_add ( &tls->process );\n}\n\n/**\n * Resume TX state machine for all connections within a session\n *\n * @v session\t\tTLS session\n */\nstatic void tls_tx_resume_all ( struct tls_session *session ) {\n\tstruct tls_connection *tls;\n\n\tlist_for_each_entry ( tls, &session->conn, list )\n\t\ttls_tx_resume ( tls );\n}\n\n/**\n * Restart negotiation\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_restart ( struct tls_connection *tls ) {\n\n\t/* Sanity check */\n\tassert ( ! tls->tx_pending );\n\tassert ( ! is_pending ( &tls->client_negotiation ) );\n\tassert ( ! is_pending ( &tls->server_negotiation ) );\n\tassert ( ! is_pending ( &tls->validation ) );\n\n\t/* (Re)initialise handshake context */\n\tdigest_init ( &md5_sha1_algorithm, tls->handshake_md5_sha1_ctx );\n\tdigest_init ( &sha256_algorithm, tls->handshake_sha256_ctx );\n\ttls->handshake_digest = &sha256_algorithm;\n\ttls->handshake_ctx = tls->handshake_sha256_ctx;\n\n\t/* (Re)start negotiation */\n\ttls->tx_pending = TLS_TX_CLIENT_HELLO;\n\ttls_tx_resume ( tls );\n\tpending_get ( &tls->client_negotiation );\n\tpending_get ( &tls->server_negotiation );\n}\n\n/**\n * Transmit Handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_handshake ( struct tls_connection *tls,\n\t\t\t\tvoid *data, size_t len ) {\n\n\t/* Add to handshake digest */\n\ttls_add_handshake ( tls, data, len );\n\n\t/* Send record */\n\treturn tls_send_plaintext ( tls, TLS_TYPE_HANDSHAKE, data, len );\n}\n\n/**\n * Transmit Client Hello record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_hello ( struct tls_connection *tls ) {\n\tstruct tls_session *session = tls->session;\n\tsize_t name_len = strlen ( session->name );\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint16_t version;\n\t\tuint8_t random[32];\n\t\tuint8_t session_id_len;\n\t\tuint8_t session_id[tls->session_id_len];\n\t\tuint16_t cipher_suite_len;\n\t\tuint16_t cipher_suites[TLS_NUM_CIPHER_SUITES];\n\t\tuint8_t compression_methods_len;\n\t\tuint8_t compression_methods[1];\n\t\tuint16_t extensions_len;\n\t\tstruct {\n\t\t\tuint16_t server_name_type;\n\t\t\tuint16_t server_name_len;\n\t\t\tstruct {\n\t\t\t\tuint16_t len;\n\t\t\t\tstruct {\n\t\t\t\t\tuint8_t type;\n\t\t\t\t\tuint16_t len;\n\t\t\t\t\tuint8_t name[name_len];\n\t\t\t\t} __attribute__ (( packed )) list[1];\n\t\t\t} __attribute__ (( packed )) server_name;\n\t\t\tuint16_t max_fragment_length_type;\n\t\t\tuint16_t max_fragment_length_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t max;\n\t\t\t} __attribute__ (( packed )) max_fragment_length;\n\t\t\tuint16_t signature_algorithms_type;\n\t\t\tuint16_t signature_algorithms_len;\n\t\t\tstruct {\n\t\t\t\tuint16_t len;\n\t\t\t\tstruct tls_signature_hash_id\n\t\t\t\t\tcode[TLS_NUM_SIG_HASH_ALGORITHMS];\n\t\t\t} __attribute__ (( packed )) signature_algorithms;\n\t\t\tuint16_t renegotiation_info_type;\n\t\t\tuint16_t renegotiation_info_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t len;\n\t\t\t\tuint8_t data[ tls->secure_renegotiation ?\n\t\t\t\t\t      sizeof ( tls->verify.client ) :0];\n\t\t\t} __attribute__ (( packed )) renegotiation_info;\n\t\t\tuint16_t session_ticket_type;\n\t\t\tuint16_t session_ticket_len;\n\t\t\tstruct {\n\t\t\t\tuint8_t data[session->ticket_len];\n\t\t\t} __attribute__ (( packed )) session_ticket;\n\t\t} __attribute__ (( packed )) extensions;\n\t} __attribute__ (( packed )) hello;\n\tstruct tls_cipher_suite *suite;\n\tstruct tls_signature_hash_algorithm *sighash;\n\tunsigned int i;\n\n\t/* Construct record */\n\tmemset ( &hello, 0, sizeof ( hello ) );\n\thello.type_length = ( cpu_to_le32 ( TLS_CLIENT_HELLO ) |\n\t\t\t      htonl ( sizeof ( hello ) -\n\t\t\t\t      sizeof ( hello.type_length ) ) );\n\thello.version = htons ( tls->version );\n\tmemcpy ( &hello.random, &tls->client_random, sizeof ( hello.random ) );\n\thello.session_id_len = tls->session_id_len;\n\tmemcpy ( hello.session_id, tls->session_id,\n\t\t sizeof ( hello.session_id ) );\n\thello.cipher_suite_len = htons ( sizeof ( hello.cipher_suites ) );\n\ti = 0 ; for_each_table_entry ( suite, TLS_CIPHER_SUITES )\n\t\thello.cipher_suites[i++] = suite->code;\n\thello.compression_methods_len = sizeof ( hello.compression_methods );\n\thello.extensions_len = htons ( sizeof ( hello.extensions ) );\n\thello.extensions.server_name_type = htons ( TLS_SERVER_NAME );\n\thello.extensions.server_name_len\n\t\t= htons ( sizeof ( hello.extensions.server_name ) );\n\thello.extensions.server_name.len\n\t\t= htons ( sizeof ( hello.extensions.server_name.list ) );\n\thello.extensions.server_name.list[0].type = TLS_SERVER_NAME_HOST_NAME;\n\thello.extensions.server_name.list[0].len\n\t\t= htons ( sizeof ( hello.extensions.server_name.list[0].name ));\n\tmemcpy ( hello.extensions.server_name.list[0].name, session->name,\n\t\t sizeof ( hello.extensions.server_name.list[0].name ) );\n\thello.extensions.max_fragment_length_type\n\t\t= htons ( TLS_MAX_FRAGMENT_LENGTH );\n\thello.extensions.max_fragment_length_len\n\t\t= htons ( sizeof ( hello.extensions.max_fragment_length ) );\n\thello.extensions.max_fragment_length.max\n\t\t= TLS_MAX_FRAGMENT_LENGTH_4096;\n\thello.extensions.signature_algorithms_type\n\t\t= htons ( TLS_SIGNATURE_ALGORITHMS );\n\thello.extensions.signature_algorithms_len\n\t\t= htons ( sizeof ( hello.extensions.signature_algorithms ) );\n\thello.extensions.signature_algorithms.len\n\t\t= htons ( sizeof ( hello.extensions.signature_algorithms.code));\n\ti = 0 ; for_each_table_entry ( sighash, TLS_SIG_HASH_ALGORITHMS )\n\t\thello.extensions.signature_algorithms.code[i++] = sighash->code;\n\thello.extensions.renegotiation_info_type\n\t\t= htons ( TLS_RENEGOTIATION_INFO );\n\thello.extensions.renegotiation_info_len\n\t\t= htons ( sizeof ( hello.extensions.renegotiation_info ) );\n\thello.extensions.renegotiation_info.len\n\t\t= sizeof ( hello.extensions.renegotiation_info.data );\n\tmemcpy ( hello.extensions.renegotiation_info.data, tls->verify.client,\n\t\t sizeof ( hello.extensions.renegotiation_info.data ) );\n\thello.extensions.session_ticket_type = htons ( TLS_SESSION_TICKET );\n\thello.extensions.session_ticket_len\n\t\t= htons ( sizeof ( hello.extensions.session_ticket ) );\n\tmemcpy ( hello.extensions.session_ticket.data, session->ticket,\n\t\t sizeof ( hello.extensions.session_ticket.data ) );\n\n\treturn tls_send_handshake ( tls, &hello, sizeof ( hello ) );\n}\n\n/**\n * Transmit Certificate record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_certificate ( struct tls_connection *tls ) {\n\tstruct {\n\t\ttls24_t length;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *certificate;\n\tstruct {\n\t\tuint32_t type_length;\n\t\ttls24_t length;\n\t\ttypeof ( *certificate ) certificates[0];\n\t} __attribute__ (( packed )) *certificates;\n\tstruct x509_link *link;\n\tstruct x509_certificate *cert;\n\tsize_t len;\n\tint rc;\n\n\t/* Calculate length of client certificates */\n\tlen = 0;\n\tlist_for_each_entry ( link, &tls->certs->links, list ) {\n\t\tcert = link->cert;\n\t\tlen += ( sizeof ( *certificate ) + cert->raw.len );\n\t\tDBGC ( tls, \"TLS %p sending client certificate %s\\n\",\n\t\t       tls, x509_name ( cert ) );\n\t}\n\n\t/* Allocate storage for Certificate record (which may be too\n\t * large for the stack).\n\t */\n\tcertificates = zalloc ( sizeof ( *certificates ) + len );\n\tif ( ! certificates )\n\t\treturn -ENOMEM_CERTIFICATE;\n\n\t/* Populate record */\n\tcertificates->type_length =\n\t\t( cpu_to_le32 ( TLS_CERTIFICATE ) |\n\t\t  htonl ( sizeof ( *certificates ) + len -\n\t\t\t  sizeof ( certificates->type_length ) ) );\n\ttls_set_uint24 ( &certificates->length, len );\n\tcertificate = &certificates->certificates[0];\n\tlist_for_each_entry ( link, &tls->certs->links, list ) {\n\t\tcert = link->cert;\n\t\ttls_set_uint24 ( &certificate->length, cert->raw.len );\n\t\tmemcpy ( certificate->data, cert->raw.data, cert->raw.len );\n\t\tcertificate = ( ( ( void * ) certificate->data ) +\n\t\t\t\tcert->raw.len );\n\t}\n\n\t/* Transmit record */\n\trc = tls_send_handshake ( tls, certificates,\n\t\t\t\t  ( sizeof ( *certificates ) + len ) );\n\n\t/* Free record */\n\tfree ( certificates );\n\n\treturn rc;\n}\n\n/**\n * Transmit Client Key Exchange record using public key exchange\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange_pubkey ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey = cipherspec->suite->pubkey;\n\tsize_t max_len = pubkey_max_len ( pubkey, cipherspec->pubkey_ctx );\n\tstruct {\n\t\tuint16_t version;\n\t\tuint8_t random[46];\n\t} __attribute__ (( packed )) pre_master_secret;\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint16_t encrypted_pre_master_secret_len;\n\t\tuint8_t encrypted_pre_master_secret[max_len];\n\t} __attribute__ (( packed )) key_xchg;\n\tsize_t unused;\n\tint len;\n\tint rc;\n\n\t/* Generate pre-master secret */\n\tpre_master_secret.version = htons ( TLS_VERSION_MAX );\n\tif ( ( rc = tls_generate_random ( tls, &pre_master_secret.random,\n\t\t\t  ( sizeof ( pre_master_secret.random ) ) ) ) != 0 ) {\n\t\treturn rc;\n\t}\n\n\t/* Generate master secret */\n\ttls_generate_master_secret ( tls, &pre_master_secret,\n\t\t\t\t     sizeof ( pre_master_secret ) );\n\n\t/* Generate keys */\n\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not generate keys: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\n\t/* Encrypt pre-master secret using server's public key */\n\tmemset ( &key_xchg, 0, sizeof ( key_xchg ) );\n\tlen = pubkey_encrypt ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t       &pre_master_secret, sizeof ( pre_master_secret ),\n\t\t\t       key_xchg.encrypted_pre_master_secret );\n\tif ( len < 0 ) {\n\t\trc = len;\n\t\tDBGC ( tls, \"TLS %p could not encrypt pre-master secret: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tunused = ( max_len - len );\n\tkey_xchg.type_length =\n\t\t( cpu_to_le32 ( TLS_CLIENT_KEY_EXCHANGE ) |\n\t\t  htonl ( sizeof ( key_xchg ) -\n\t\t\t  sizeof ( key_xchg.type_length ) - unused ) );\n\tkey_xchg.encrypted_pre_master_secret_len =\n\t\thtons ( sizeof ( key_xchg.encrypted_pre_master_secret ) -\n\t\t\tunused );\n\n\treturn tls_send_handshake ( tls, &key_xchg,\n\t\t\t\t    ( sizeof ( key_xchg ) - unused ) );\n}\n\n/** Public key exchange algorithm */\nstruct tls_key_exchange_algorithm tls_pubkey_exchange_algorithm = {\n\t.name = \"pubkey\",\n\t.exchange = tls_send_client_key_exchange_pubkey,\n};\n\n/**\n * Transmit Client Key Exchange record using DHE key exchange\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange_dhe ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey;\n\tstruct digest_algorithm *digest;\n\tint use_sig_hash = tls_version ( tls, TLS_VERSION_TLS_1_2 );\n\tuint8_t private[ sizeof ( tls->client_random.random ) ];\n\tconst struct {\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *dh_val[3];\n\tconst struct {\n\t\tstruct tls_signature_hash_id sig_hash[use_sig_hash];\n\t\tuint16_t signature_len;\n\t\tuint8_t signature[0];\n\t} __attribute__ (( packed )) *sig;\n\tconst void *data;\n\tsize_t remaining;\n\tsize_t frag_len;\n\tunsigned int i;\n\tint rc;\n\n\t/* Parse ServerKeyExchange */\n\tdata = tls->server_key;\n\tremaining = tls->server_key_len;\n\tfor ( i = 0 ; i < ( sizeof ( dh_val ) / sizeof ( dh_val[0] ) ) ; i++ ){\n\t\tdh_val[i] = data;\n\t\tif ( ( sizeof ( *dh_val[i] ) > remaining ) ||\n\t\t     ( ntohs ( dh_val[i]->len ) > ( remaining -\n\t\t\t\t\t\t    sizeof ( *dh_val[i] ) ) )){\n\t\t\tDBGC ( tls, \"TLS %p received underlength \"\n\t\t\t       \"ServerKeyExchange\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->server_key,\n\t\t\t\t   tls->server_key_len );\n\t\t\trc = -EINVAL_KEY_EXCHANGE;\n\t\t\tgoto err_header;\n\t\t}\n\t\tfrag_len = ( sizeof ( *dh_val[i] ) + ntohs ( dh_val[i]->len ));\n\t\tdata += frag_len;\n\t\tremaining -= frag_len;\n\t}\n\tsig = data;\n\tif ( ( sizeof ( *sig ) > remaining ) ||\n\t     ( ntohs ( sig->signature_len ) > ( remaining -\n\t\t\t\t\t\tsizeof ( *sig ) ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength ServerKeyExchange\\n\",\n\t\t       tls );\n\t\tDBGC_HDA ( tls, 0, tls->server_key, tls->server_key_len );\n\t\trc = -EINVAL_KEY_EXCHANGE;\n\t\tgoto err_header;\n\t}\n\n\t/* Identify signature and hash algorithm */\n\tif ( use_sig_hash ) {\n\t\tpubkey = tls_signature_hash_pubkey ( sig->sig_hash[0] );\n\t\tdigest = tls_signature_hash_digest ( sig->sig_hash[0] );\n\t\tif ( ( ! pubkey ) || ( ! digest ) ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange unsupported \"\n\t\t\t       \"signature and hash algorithm\\n\", tls );\n\t\t\trc = -ENOTSUP_SIG_HASH;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t\tif ( pubkey != cipherspec->suite->pubkey ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange incorrect \"\n\t\t\t       \"signature algorithm %s (expected %s)\\n\", tls,\n\t\t\t       pubkey->name, cipherspec->suite->pubkey->name );\n\t\t\trc = -EPERM_KEY_EXCHANGE;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t} else {\n\t\tpubkey = cipherspec->suite->pubkey;\n\t\tdigest = &md5_sha1_algorithm;\n\t}\n\n\t/* Verify signature */\n\t{\n\t\tconst void *signature = sig->signature;\n\t\tsize_t signature_len = ntohs ( sig->signature_len );\n\t\tuint8_t ctx[digest->ctxsize];\n\t\tuint8_t hash[digest->digestsize];\n\n\t\t/* Calculate digest */\n\t\tdigest_init ( digest, ctx );\n\t\tdigest_update ( digest, ctx, &tls->client_random,\n\t\t\t\tsizeof ( tls->client_random ) );\n\t\tdigest_update ( digest, ctx, tls->server_random,\n\t\t\t\tsizeof ( tls->server_random ) );\n\t\tdigest_update ( digest, ctx, tls->server_key,\n\t\t\t\t( tls->server_key_len - remaining ) );\n\t\tdigest_final ( digest, ctx, hash );\n\n\t\t/* Verify signature */\n\t\tif ( ( rc = pubkey_verify ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t\t\t    digest, hash, signature,\n\t\t\t\t\t    signature_len ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p ServerKeyExchange failed \"\n\t\t\t       \"verification\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->server_key,\n\t\t\t\t   tls->server_key_len );\n\t\t\trc = -EPERM_KEY_EXCHANGE;\n\t\t\tgoto err_verify;\n\t\t}\n\t}\n\n\t/* Generate Diffie-Hellman private key */\n\tif ( ( rc = tls_generate_random ( tls, private,\n\t\t\t\t\t  sizeof ( private ) ) ) != 0 ) {\n\t\tgoto err_random;\n\t}\n\n\t/* Construct pre-master secret and ClientKeyExchange record */\n\t{\n\t\ttypeof ( dh_val[0] ) dh_p = dh_val[0];\n\t\ttypeof ( dh_val[1] ) dh_g = dh_val[1];\n\t\ttypeof ( dh_val[2] ) dh_ys = dh_val[2];\n\t\tsize_t len = ntohs ( dh_p->len );\n\t\tstruct {\n\t\t\tuint32_t type_length;\n\t\t\tuint16_t dh_xs_len;\n\t\t\tuint8_t dh_xs[len];\n\t\t} __attribute__ (( packed )) *key_xchg;\n\t\tstruct {\n\t\t\tuint8_t pre_master_secret[len];\n\t\t\ttypeof ( *key_xchg ) key_xchg;\n\t\t} *dynamic;\n\t\tuint8_t *pre_master_secret;\n\n\t\t/* Allocate space */\n\t\tdynamic = malloc ( sizeof ( *dynamic ) );\n\t\tif ( ! dynamic ) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_alloc;\n\t\t}\n\t\tpre_master_secret = dynamic->pre_master_secret;\n\t\tkey_xchg = &dynamic->key_xchg;\n\t\tkey_xchg->type_length =\n\t\t\t( cpu_to_le32 ( TLS_CLIENT_KEY_EXCHANGE ) |\n\t\t\t  htonl ( sizeof ( *key_xchg ) -\n\t\t\t\t  sizeof ( key_xchg->type_length ) ) );\n\t\tkey_xchg->dh_xs_len = htons ( len );\n\n\t\t/* Calculate pre-master secret and client public value */\n\t\tif ( ( rc = dhe_key ( dh_p->data, len,\n\t\t\t\t      dh_g->data, ntohs ( dh_g->len ),\n\t\t\t\t      dh_ys->data, ntohs ( dh_ys->len ),\n\t\t\t\t      private, sizeof ( private ),\n\t\t\t\t      key_xchg->dh_xs,\n\t\t\t\t      pre_master_secret ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not calculate DHE key: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err_dhe_key;\n\t\t}\n\n\t\t/* Strip leading zeroes from pre-master secret */\n\t\twhile ( len && ( ! *pre_master_secret ) ) {\n\t\t\tpre_master_secret++;\n\t\t\tlen--;\n\t\t}\n\n\t\t/* Generate master secret */\n\t\ttls_generate_master_secret ( tls, pre_master_secret, len );\n\n\t\t/* Generate keys */\n\t\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not generate keys: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err_generate_keys;\n\t\t}\n\n\t\t/* Transmit Client Key Exchange record */\n\t\tif ( ( rc = tls_send_handshake ( tls, key_xchg,\n\t\t\t\t\t\t sizeof ( *key_xchg ) ) ) !=0){\n\t\t\tgoto err_send_handshake;\n\t\t}\n\n\terr_send_handshake:\n\terr_generate_keys:\n\terr_dhe_key:\n\t\tfree ( dynamic );\n\t}\n err_alloc:\n err_random:\n err_verify:\n err_sig_hash:\n err_header:\n\treturn rc;\n}\n\n/** Ephemeral Diffie-Hellman key exchange algorithm */\nstruct tls_key_exchange_algorithm tls_dhe_exchange_algorithm = {\n\t.name = \"dhe\",\n\t.exchange = tls_send_client_key_exchange_dhe,\n};\n\n/**\n * Transmit Client Key Exchange record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_client_key_exchange ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\n\t/* Transmit Client Key Exchange record via key exchange algorithm */\n\treturn suite->exchange->exchange ( tls );\n}\n\n/**\n * Transmit Certificate Verify record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_certificate_verify ( struct tls_connection *tls ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tstruct x509_certificate *cert = x509_first ( tls->certs );\n\tstruct pubkey_algorithm *pubkey = cert->signature_algorithm->pubkey;\n\tstruct asn1_cursor *key = privkey_cursor ( tls->key );\n\tuint8_t digest_out[ digest->digestsize ];\n\tuint8_t ctx[ pubkey->ctxsize ];\n\tstruct tls_signature_hash_algorithm *sig_hash = NULL;\n\tint rc;\n\n\t/* Generate digest to be signed */\n\ttls_verify_handshake ( tls, digest_out );\n\n\t/* Initialise public-key algorithm */\n\tif ( ( rc = pubkey_init ( pubkey, ctx, key->data, key->len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not initialise %s client private \"\n\t\t       \"key: %s\\n\", tls, pubkey->name, strerror ( rc ) );\n\t\tgoto err_pubkey_init;\n\t}\n\n\t/* TLSv1.2 and later use explicit algorithm identifiers */\n\tif ( tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\tsig_hash = tls_signature_hash_algorithm ( pubkey, digest );\n\t\tif ( ! sig_hash ) {\n\t\t\tDBGC ( tls, \"TLS %p could not identify (%s,%s) \"\n\t\t\t       \"signature and hash algorithm\\n\", tls,\n\t\t\t       pubkey->name, digest->name );\n\t\t\trc = -ENOTSUP_SIG_HASH;\n\t\t\tgoto err_sig_hash;\n\t\t}\n\t}\n\n\t/* Generate and transmit record */\n\t{\n\t\tsize_t max_len = pubkey_max_len ( pubkey, ctx );\n\t\tint use_sig_hash = ( ( sig_hash == NULL ) ? 0 : 1 );\n\t\tstruct {\n\t\t\tuint32_t type_length;\n\t\t\tstruct tls_signature_hash_id sig_hash[use_sig_hash];\n\t\t\tuint16_t signature_len;\n\t\t\tuint8_t signature[max_len];\n\t\t} __attribute__ (( packed )) certificate_verify;\n\t\tsize_t unused;\n\t\tint len;\n\n\t\t/* Sign digest */\n\t\tlen = pubkey_sign ( pubkey, ctx, digest, digest_out,\n\t\t\t\t    certificate_verify.signature );\n\t\tif ( len < 0 ) {\n\t\t\trc = len;\n\t\t\tDBGC ( tls, \"TLS %p could not sign %s digest using %s \"\n\t\t\t       \"client private key: %s\\n\", tls, digest->name,\n\t\t\t       pubkey->name, strerror ( rc ) );\n\t\t\tgoto err_pubkey_sign;\n\t\t}\n\t\tunused = ( max_len - len );\n\n\t\t/* Construct Certificate Verify record */\n\t\tcertificate_verify.type_length =\n\t\t\t( cpu_to_le32 ( TLS_CERTIFICATE_VERIFY ) |\n\t\t\t  htonl ( sizeof ( certificate_verify ) -\n\t\t\t\t  sizeof ( certificate_verify.type_length ) -\n\t\t\t\t  unused ) );\n\t\tif ( use_sig_hash ) {\n\t\t\tmemcpy ( &certificate_verify.sig_hash[0],\n\t\t\t\t &sig_hash->code,\n\t\t\t\t sizeof ( certificate_verify.sig_hash[0] ) );\n\t\t}\n\t\tcertificate_verify.signature_len =\n\t\t\thtons ( sizeof ( certificate_verify.signature ) -\n\t\t\t\tunused );\n\n\t\t/* Transmit record */\n\t\trc = tls_send_handshake ( tls, &certificate_verify,\n\t\t\t\t   ( sizeof ( certificate_verify ) - unused ) );\n\t}\n\n err_pubkey_sign:\n err_sig_hash:\n\tpubkey_final ( pubkey, ctx );\n err_pubkey_init:\n\treturn rc;\n}\n\n/**\n * Transmit Change Cipher record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_change_cipher ( struct tls_connection *tls ) {\n\tstatic const uint8_t change_cipher[1] = { 1 };\n\treturn tls_send_plaintext ( tls, TLS_TYPE_CHANGE_CIPHER,\n\t\t\t\t    change_cipher, sizeof ( change_cipher ) );\n}\n\n/**\n * Transmit Finished record\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_finished ( struct tls_connection *tls ) {\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tstruct {\n\t\tuint32_t type_length;\n\t\tuint8_t verify_data[ sizeof ( tls->verify.client ) ];\n\t} __attribute__ (( packed )) finished;\n\tuint8_t digest_out[ digest->digestsize ];\n\tint rc;\n\n\t/* Construct client verification data */\n\ttls_verify_handshake ( tls, digest_out );\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\ttls->verify.client, sizeof ( tls->verify.client ),\n\t\t\t\"client finished\", digest_out, sizeof ( digest_out ) );\n\n\t/* Construct record */\n\tmemset ( &finished, 0, sizeof ( finished ) );\n\tfinished.type_length = ( cpu_to_le32 ( TLS_FINISHED ) |\n\t\t\t\t htonl ( sizeof ( finished ) -\n\t\t\t\t\t sizeof ( finished.type_length ) ) );\n\tmemcpy ( finished.verify_data, tls->verify.client,\n\t\t sizeof ( finished.verify_data ) );\n\n\t/* Transmit record */\n\tif ( ( rc = tls_send_handshake ( tls, &finished,\n\t\t\t\t\t sizeof ( finished ) ) ) != 0 )\n\t\treturn rc;\n\n\t/* Mark client as finished */\n\tpending_put ( &tls->client_negotiation );\n\n\treturn 0;\n}\n\n/**\n * Receive new Change Cipher record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_change_cipher ( struct tls_connection *tls,\n\t\t\t\t   const void *data, size_t len ) {\n\tint rc;\n\n\tif ( ( len != 1 ) || ( *( ( uint8_t * ) data ) != 1 ) ) {\n\t\tDBGC ( tls, \"TLS %p received invalid Change Cipher\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CHANGE_CIPHER;\n\t}\n\n\tif ( ( rc = tls_change_cipher ( tls, &tls->rx_cipherspec_pending,\n\t\t\t\t\t&tls->rx_cipherspec ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not activate RX cipher: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\ttls->rx_seq = ~( ( uint64_t ) 0 );\n\n\treturn 0;\n}\n\n/**\n * Receive new Alert record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_alert ( struct tls_connection *tls, const void *data,\n\t\t\t   size_t len ) {\n\tconst struct {\n\t\tuint8_t level;\n\t\tuint8_t description;\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *alert = data;\n\n\t/* Sanity check */\n\tif ( sizeof ( *alert ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Alert\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_ALERT;\n\t}\n\n\tswitch ( alert->level ) {\n\tcase TLS_ALERT_WARNING:\n\t\tDBGC ( tls, \"TLS %p received warning alert %d\\n\",\n\t\t       tls, alert->description );\n\t\treturn 0;\n\tcase TLS_ALERT_FATAL:\n\t\tDBGC ( tls, \"TLS %p received fatal alert %d\\n\",\n\t\t       tls, alert->description );\n\t\treturn -EPERM_ALERT;\n\tdefault:\n\t\tDBGC ( tls, \"TLS %p received unknown alert level %d\"\n\t\t       \"(alert %d)\\n\", tls, alert->level, alert->description );\n\t\treturn -EIO_ALERT;\n\t}\n}\n\n/**\n * Receive new Hello Request handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_hello_request ( struct tls_connection *tls,\n\t\t\t\t   const void *data __unused,\n\t\t\t\t   size_t len __unused ) {\n\n\t/* Ignore if a handshake is in progress */\n\tif ( ! tls_ready ( tls ) ) {\n\t\tDBGC ( tls, \"TLS %p ignoring Hello Request\\n\", tls );\n\t\treturn 0;\n\t}\n\n\t/* Fail unless server supports secure renegotiation */\n\tif ( ! tls->secure_renegotiation ) {\n\t\tDBGC ( tls, \"TLS %p refusing to renegotiate insecurely\\n\",\n\t\t       tls );\n\t\treturn -EPERM_RENEG_INSECURE;\n\t}\n\n\t/* Restart negotiation */\n\ttls_restart ( tls );\n\n\treturn 0;\n}\n\n/**\n * Receive new Server Hello handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_hello ( struct tls_connection *tls,\n\t\t\t\t  const void *data, size_t len ) {\n\tconst struct {\n\t\tuint16_t version;\n\t\tuint8_t random[32];\n\t\tuint8_t session_id_len;\n\t\tuint8_t session_id[0];\n\t} __attribute__ (( packed )) *hello_a = data;\n\tconst uint8_t *session_id;\n\tconst struct {\n\t\tuint16_t cipher_suite;\n\t\tuint8_t compression_method;\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *hello_b;\n\tconst struct {\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *exts;\n\tconst struct {\n\t\tuint16_t type;\n\t\tuint16_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *ext;\n\tconst struct {\n\t\tuint8_t len;\n\t\tuint8_t data[0];\n\t} __attribute__ (( packed )) *reneg = NULL;\n\tuint16_t version;\n\tsize_t exts_len;\n\tsize_t ext_len;\n\tsize_t remaining;\n\tint rc;\n\n\t/* Parse header */\n\tif ( ( sizeof ( *hello_a ) > len ) ||\n\t     ( hello_a->session_id_len > ( len - sizeof ( *hello_a ) ) ) ||\n\t     ( sizeof ( *hello_b ) > ( len - sizeof ( *hello_a ) -\n\t\t\t\t       hello_a->session_id_len ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength Server Hello\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_HELLO;\n\t}\n\tsession_id = hello_a->session_id;\n\thello_b = ( ( void * ) ( session_id + hello_a->session_id_len ) );\n\n\t/* Parse extensions, if present */\n\tremaining = ( len - sizeof ( *hello_a ) - hello_a->session_id_len -\n\t\t      sizeof ( *hello_b ) );\n\tif ( remaining ) {\n\n\t\t/* Parse extensions length */\n\t\texts = ( ( void * ) hello_b->next );\n\t\tif ( ( sizeof ( *exts ) > remaining ) ||\n\t\t     ( ( exts_len = ntohs ( exts->len ) ) >\n\t\t       ( remaining - sizeof ( *exts ) ) ) ) {\n\t\t\tDBGC ( tls, \"TLS %p received underlength extensions\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, len );\n\t\t\treturn -EINVAL_HELLO;\n\t\t}\n\n\t\t/* Parse extensions */\n\t\tfor ( ext = ( ( void * ) exts->data ), remaining = exts_len ;\n\t\t      remaining ;\n\t\t      ext = ( ( ( void * ) ext ) + sizeof ( *ext ) + ext_len ),\n\t\t\t      remaining -= ( sizeof ( *ext ) + ext_len ) ) {\n\n\t\t\t/* Parse extension length */\n\t\t\tif ( ( sizeof ( *ext ) > remaining ) ||\n\t\t\t     ( ( ext_len = ntohs ( ext->len ) ) >\n\t\t\t       ( remaining - sizeof ( *ext ) ) ) ) {\n\t\t\t\tDBGC ( tls, \"TLS %p received underlength \"\n\t\t\t\t       \"extension\\n\", tls );\n\t\t\t\tDBGC_HD ( tls, data, len );\n\t\t\t\treturn -EINVAL_HELLO;\n\t\t\t}\n\n\t\t\t/* Record known extensions */\n\t\t\tswitch ( ext->type ) {\n\t\t\tcase htons ( TLS_RENEGOTIATION_INFO ) :\n\t\t\t\treneg = ( ( void * ) ext->data );\n\t\t\t\tif ( ( sizeof ( *reneg ) > ext_len ) ||\n\t\t\t\t     ( reneg->len >\n\t\t\t\t       ( ext_len - sizeof ( *reneg ) ) ) ) {\n\t\t\t\t\tDBGC ( tls, \"TLS %p received \"\n\t\t\t\t\t       \"underlength renegotiation \"\n\t\t\t\t\t       \"info\\n\", tls );\n\t\t\t\t\tDBGC_HD ( tls, data, len );\n\t\t\t\t\treturn -EINVAL_HELLO;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check and store protocol version */\n\tversion = ntohs ( hello_a->version );\n\tif ( version < TLS_VERSION_MIN ) {\n\t\tDBGC ( tls, \"TLS %p does not support protocol version %d.%d\\n\",\n\t\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\t\treturn -ENOTSUP_VERSION;\n\t}\n\tif ( version > tls->version ) {\n\t\tDBGC ( tls, \"TLS %p server attempted to illegally upgrade to \"\n\t\t       \"protocol version %d.%d\\n\",\n\t\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\t\treturn -EPROTO_VERSION;\n\t}\n\ttls->version = version;\n\tDBGC ( tls, \"TLS %p using protocol version %d.%d\\n\",\n\t       tls, ( version >> 8 ), ( version & 0xff ) );\n\n\t/* Use MD5+SHA1 digest algorithm for handshake verification\n\t * for versions earlier than TLSv1.2.\n\t */\n\tif ( ! tls_version ( tls, TLS_VERSION_TLS_1_2 ) ) {\n\t\ttls->handshake_digest = &md5_sha1_algorithm;\n\t\ttls->handshake_ctx = tls->handshake_md5_sha1_ctx;\n\t}\n\n\t/* Copy out server random bytes */\n\tmemcpy ( &tls->server_random, &hello_a->random,\n\t\t sizeof ( tls->server_random ) );\n\n\t/* Select cipher suite */\n\tif ( ( rc = tls_select_cipher ( tls, hello_b->cipher_suite ) ) != 0 )\n\t\treturn rc;\n\n\t/* Check session ID */\n\tif ( hello_a->session_id_len &&\n\t     ( hello_a->session_id_len == tls->session_id_len ) &&\n\t     ( memcmp ( session_id, tls->session_id,\n\t\t\ttls->session_id_len ) == 0 ) ) {\n\n\t\t/* Session ID match: reuse master secret */\n\t\tDBGC ( tls, \"TLS %p resuming session ID:\\n\", tls );\n\t\tDBGC_HDA ( tls, 0, tls->session_id, tls->session_id_len );\n\t\tif ( ( rc = tls_generate_keys ( tls ) ) != 0 )\n\t\t\treturn rc;\n\n\t} else {\n\n\t\t/* Record new session ID, if present */\n\t\tif ( hello_a->session_id_len &&\n\t\t     ( hello_a->session_id_len <= sizeof ( tls->session_id ))){\n\t\t\ttls->session_id_len = hello_a->session_id_len;\n\t\t\tmemcpy ( tls->session_id, session_id,\n\t\t\t\t tls->session_id_len );\n\t\t\tDBGC ( tls, \"TLS %p new session ID:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, tls->session_id,\n\t\t\t\t   tls->session_id_len );\n\t\t}\n\t}\n\n\t/* Handle secure renegotiation */\n\tif ( tls->secure_renegotiation ) {\n\n\t\t/* Secure renegotiation is expected; verify data */\n\t\tif ( ( reneg == NULL ) ||\n\t\t     ( reneg->len != sizeof ( tls->verify ) ) ||\n\t\t     ( memcmp ( reneg->data, &tls->verify,\n\t\t\t\tsizeof ( tls->verify ) ) != 0 ) ) {\n\t\t\tDBGC ( tls, \"TLS %p server failed secure \"\n\t\t\t       \"renegotiation\\n\", tls );\n\t\t\treturn -EPERM_RENEG_VERIFY;\n\t\t}\n\n\t} else if ( reneg != NULL ) {\n\n\t\t/* Secure renegotiation is being enabled */\n\t\tif ( reneg->len != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p server provided non-empty initial \"\n\t\t\t       \"renegotiation\\n\", tls );\n\t\t\treturn -EPERM_RENEG_VERIFY;\n\t\t}\n\t\ttls->secure_renegotiation = 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Receive New Session Ticket handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_session_ticket ( struct tls_connection *tls,\n\t\t\t\t    const void *data, size_t len ) {\n\tconst struct {\n\t\tuint32_t lifetime;\n\t\tuint16_t len;\n\t\tuint8_t ticket[0];\n\t} __attribute__ (( packed )) *new_session_ticket = data;\n\tsize_t ticket_len;\n\n\t/* Parse header */\n\tif ( sizeof ( *new_session_ticket ) > len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength New Session Ticket\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_TICKET;\n\t}\n\tticket_len = ntohs ( new_session_ticket->len );\n\tif ( ticket_len > ( len - sizeof ( *new_session_ticket ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received overlength New Session Ticket\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_TICKET;\n\t}\n\n\t/* Free any unapplied new session ticket */\n\tfree ( tls->new_session_ticket );\n\ttls->new_session_ticket = NULL;\n\ttls->new_session_ticket_len = 0;\n\n\t/* Record ticket */\n\ttls->new_session_ticket = malloc ( ticket_len );\n\tif ( ! tls->new_session_ticket )\n\t\treturn -ENOMEM;\n\tmemcpy ( tls->new_session_ticket, new_session_ticket->ticket,\n\t\t ticket_len );\n\ttls->new_session_ticket_len = ticket_len;\n\tDBGC ( tls, \"TLS %p new session ticket:\\n\", tls );\n\tDBGC_HDA ( tls, 0, tls->new_session_ticket,\n\t\t   tls->new_session_ticket_len );\n\n\treturn 0;\n}\n\n/**\n * Parse certificate chain\n *\n * @v tls\t\tTLS connection\n * @v data\t\tCertificate chain\n * @v len\t\tLength of certificate chain\n * @ret rc\t\tReturn status code\n */\nstatic int tls_parse_chain ( struct tls_connection *tls,\n\t\t\t     const void *data, size_t len ) {\n\tsize_t remaining = len;\n\tint rc;\n\n\t/* Free any existing certificate chain */\n\tx509_chain_put ( tls->chain );\n\ttls->chain = NULL;\n\n\t/* Create certificate chain */\n\ttls->chain = x509_alloc_chain();\n\tif ( ! tls->chain ) {\n\t\trc = -ENOMEM_CHAIN;\n\t\tgoto err_alloc_chain;\n\t}\n\n\t/* Add certificates to chain */\n\twhile ( remaining ) {\n\t\tconst struct {\n\t\t\ttls24_t length;\n\t\t\tuint8_t data[0];\n\t\t} __attribute__ (( packed )) *certificate = data;\n\t\tsize_t certificate_len;\n\t\tsize_t record_len;\n\t\tstruct x509_certificate *cert;\n\n\t\t/* Parse header */\n\t\tif ( sizeof ( *certificate ) > remaining ) {\n\t\t\tDBGC ( tls, \"TLS %p underlength certificate:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\trc = -EINVAL_CERTIFICATE;\n\t\t\tgoto err_underlength;\n\t\t}\n\t\tcertificate_len = tls_uint24 ( &certificate->length );\n\t\tif ( certificate_len > ( remaining - sizeof ( *certificate ) )){\n\t\t\tDBGC ( tls, \"TLS %p overlength certificate:\\n\", tls );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\trc = -EINVAL_CERTIFICATE;\n\t\t\tgoto err_overlength;\n\t\t}\n\t\trecord_len = ( sizeof ( *certificate ) + certificate_len );\n\n\t\t/* Add certificate to chain */\n\t\tif ( ( rc = x509_append_raw ( tls->chain, certificate->data,\n\t\t\t\t\t      certificate_len ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not append certificate: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tDBGC_HDA ( tls, 0, data, remaining );\n\t\t\tgoto err_parse;\n\t\t}\n\t\tcert = x509_last ( tls->chain );\n\t\tDBGC ( tls, \"TLS %p found certificate %s\\n\",\n\t\t       tls, x509_name ( cert ) );\n\n\t\t/* Move to next certificate in list */\n\t\tdata += record_len;\n\t\tremaining -= record_len;\n\t}\n\n\treturn 0;\n\n err_parse:\n err_overlength:\n err_underlength:\n\tx509_chain_put ( tls->chain );\n\ttls->chain = NULL;\n err_alloc_chain:\n\treturn rc;\n}\n\n/**\n * Receive new Certificate handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_certificate ( struct tls_connection *tls,\n\t\t\t\t const void *data, size_t len ) {\n\tconst struct {\n\t\ttls24_t length;\n\t\tuint8_t certificates[0];\n\t} __attribute__ (( packed )) *certificate = data;\n\tsize_t certificates_len;\n\tint rc;\n\n\t/* Parse header */\n\tif ( sizeof ( *certificate ) > len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength Server Certificate\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CERTIFICATES;\n\t}\n\tcertificates_len = tls_uint24 ( &certificate->length );\n\tif ( certificates_len > ( len - sizeof ( *certificate ) ) ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Server Certificate\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_CERTIFICATES;\n\t}\n\n\t/* Parse certificate chain */\n\tif ( ( rc = tls_parse_chain ( tls, certificate->certificates,\n\t\t\t\t      certificates_len ) ) != 0 )\n\t\treturn rc;\n\n\treturn 0;\n}\n\n/**\n * Receive new Server Key Exchange handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_key_exchange ( struct tls_connection *tls,\n\t\t\t\t\t const void *data, size_t len ) {\n\n\t/* Free any existing server key exchange record */\n\tfree ( tls->server_key );\n\ttls->server_key_len = 0;\n\n\t/* Allocate copy of server key exchange record */\n\ttls->server_key = malloc ( len );\n\tif ( ! tls->server_key )\n\t\treturn -ENOMEM;\n\n\t/* Store copy of server key exchange record for later\n\t * processing.  We cannot verify the signature at this point\n\t * since the certificate validation will not yet have\n\t * completed.\n\t */\n\tmemcpy ( tls->server_key, data, len );\n\ttls->server_key_len = len;\n\n\treturn 0;\n}\n\n/**\n * Receive new Certificate Request handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_certificate_request ( struct tls_connection *tls,\n\t\t\t\t\t const void *data __unused,\n\t\t\t\t\t size_t len __unused ) {\n\tstruct x509_certificate *cert;\n\tint rc;\n\n\t/* We can only send a single certificate, so there is no point\n\t * in parsing the Certificate Request.\n\t */\n\n\t/* Free any existing client certificate chain */\n\tx509_chain_put ( tls->certs );\n\ttls->certs = NULL;\n\n\t/* Determine client certificate to be sent */\n\tcert = certstore_find_key ( tls->key );\n\tif ( ! cert ) {\n\t\tDBGC ( tls, \"TLS %p could not find certificate corresponding \"\n\t\t       \"to private key\\n\", tls );\n\t\trc = -EPERM_CLIENT_CERT;\n\t\tgoto err_find;\n\t}\n\tx509_get ( cert );\n\tDBGC ( tls, \"TLS %p selected client certificate %s\\n\",\n\t       tls, x509_name ( cert ) );\n\n\t/* Create client certificate chain */\n\ttls->certs = x509_alloc_chain();\n\tif ( ! tls->certs ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\t/* Append client certificate to chain */\n\tif ( ( rc = x509_append ( tls->certs, cert ) ) != 0 )\n\t\tgoto err_append;\n\n\t/* Append any relevant issuer certificates */\n\tif ( ( rc = x509_auto_append ( tls->certs, &certstore ) ) != 0 )\n\t\tgoto err_auto_append;\n\n\t/* Drop local reference to client certificate */\n\tx509_put ( cert );\n\n\treturn 0;\n\n err_auto_append:\n err_append:\n\tx509_chain_put ( tls->certs );\n\ttls->certs = NULL;\n err_alloc:\n\tx509_put ( cert );\n err_find:\n\treturn rc;\n}\n\n/**\n * Receive new Server Hello Done handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_server_hello_done ( struct tls_connection *tls,\n\t\t\t\t       const void *data, size_t len ) {\n\tconst struct {\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *hello_done = data;\n\tint rc;\n\n\t/* Sanity check */\n\tif ( sizeof ( *hello_done ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Server Hello Done\\n\",\n\t\t       tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_HELLO_DONE;\n\t}\n\n\t/* Begin certificate validation */\n\tif ( ( rc = create_validator ( &tls->validator, tls->chain,\n\t\t\t\t       tls->root ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not start certificate validation: \"\n\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\treturn rc;\n\t}\n\tpending_get ( &tls->validation );\n\n\treturn 0;\n}\n\n/**\n * Receive new Finished handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext handshake record\n * @v len\t\tLength of plaintext handshake record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_finished ( struct tls_connection *tls,\n\t\t\t      const void *data, size_t len ) {\n\tstruct tls_session *session = tls->session;\n\tstruct digest_algorithm *digest = tls->handshake_digest;\n\tconst struct {\n\t\tuint8_t verify_data[ sizeof ( tls->verify.server ) ];\n\t\tchar next[0];\n\t} __attribute__ (( packed )) *finished = data;\n\tuint8_t digest_out[ digest->digestsize ];\n\n\t/* Sanity check */\n\tif ( sizeof ( *finished ) != len ) {\n\t\tDBGC ( tls, \"TLS %p received overlength Finished\\n\", tls );\n\t\tDBGC_HD ( tls, data, len );\n\t\treturn -EINVAL_FINISHED;\n\t}\n\n\t/* Verify data */\n\ttls_verify_handshake ( tls, digest_out );\n\ttls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),\n\t\t\ttls->verify.server, sizeof ( tls->verify.server ),\n\t\t\t\"server finished\", digest_out, sizeof ( digest_out ) );\n\tif ( memcmp ( tls->verify.server, finished->verify_data,\n\t\t      sizeof ( tls->verify.server ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p verification failed\\n\", tls );\n\t\treturn -EPERM_VERIFY;\n\t}\n\n\t/* Mark server as finished */\n\tpending_put ( &tls->server_negotiation );\n\n\t/* If we are resuming a session (i.e. if the server Finished\n\t * arrives before the client Finished is sent), then schedule\n\t * transmission of Change Cipher and Finished.\n\t */\n\tif ( is_pending ( &tls->client_negotiation ) ) {\n\t\ttls->tx_pending |= ( TLS_TX_CHANGE_CIPHER | TLS_TX_FINISHED );\n\t\ttls_tx_resume ( tls );\n\t}\n\n\t/* Record session ID, ticket, and master secret, if applicable */\n\tif ( tls->session_id_len || tls->new_session_ticket_len ) {\n\t\tmemcpy ( session->master_secret, tls->master_secret,\n\t\t\t sizeof ( session->master_secret ) );\n\t}\n\tif ( tls->session_id_len ) {\n\t\tsession->id_len = tls->session_id_len;\n\t\tmemcpy ( session->id, tls->session_id, sizeof ( session->id ) );\n\t}\n\tif ( tls->new_session_ticket_len ) {\n\t\tfree ( session->ticket );\n\t\tsession->ticket = tls->new_session_ticket;\n\t\tsession->ticket_len = tls->new_session_ticket_len;\n\t\ttls->new_session_ticket = NULL;\n\t\ttls->new_session_ticket_len = 0;\n\t}\n\n\t/* Move to end of session's connection list and allow other\n\t * connections to start making progress.\n\t */\n\tlist_del ( &tls->list );\n\tlist_add_tail ( &tls->list, &session->conn );\n\ttls_tx_resume_all ( session );\n\n\t/* Send notification of a window change */\n\txfer_window_changed ( &tls->plainstream );\n\n\treturn 0;\n}\n\n/**\n * Receive new Handshake record\n *\n * @v tls\t\tTLS connection\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_handshake ( struct tls_connection *tls,\n\t\t\t       const void *data, size_t len ) {\n\tsize_t remaining = len;\n\tint rc;\n\n\twhile ( remaining ) {\n\t\tconst struct {\n\t\t\tuint8_t type;\n\t\t\ttls24_t length;\n\t\t\tuint8_t payload[0];\n\t\t} __attribute__ (( packed )) *handshake = data;\n\t\tconst void *payload;\n\t\tsize_t payload_len;\n\t\tsize_t record_len;\n\n\t\t/* Parse header */\n\t\tif ( sizeof ( *handshake ) > remaining ) {\n\t\t\tDBGC ( tls, \"TLS %p received underlength Handshake\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, remaining );\n\t\t\treturn -EINVAL_HANDSHAKE;\n\t\t}\n\t\tpayload_len = tls_uint24 ( &handshake->length );\n\t\tif ( payload_len > ( remaining - sizeof ( *handshake ) ) ) {\n\t\t\tDBGC ( tls, \"TLS %p received overlength Handshake\\n\",\n\t\t\t       tls );\n\t\t\tDBGC_HD ( tls, data, len );\n\t\t\treturn -EINVAL_HANDSHAKE;\n\t\t}\n\t\tpayload = &handshake->payload;\n\t\trecord_len = ( sizeof ( *handshake ) + payload_len );\n\n\t\t/* Handle payload */\n\t\tswitch ( handshake->type ) {\n\t\tcase TLS_HELLO_REQUEST:\n\t\t\trc = tls_new_hello_request ( tls, payload,\n\t\t\t\t\t\t     payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_HELLO:\n\t\t\trc = tls_new_server_hello ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tcase TLS_NEW_SESSION_TICKET:\n\t\t\trc = tls_new_session_ticket ( tls, payload,\n\t\t\t\t\t\t      payload_len );\n\t\t\tbreak;\n\t\tcase TLS_CERTIFICATE:\n\t\t\trc = tls_new_certificate ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_KEY_EXCHANGE:\n\t\t\trc = tls_new_server_key_exchange ( tls, payload,\n\t\t\t\t\t\t\t   payload_len );\n\t\t\tbreak;\n\t\tcase TLS_CERTIFICATE_REQUEST:\n\t\t\trc = tls_new_certificate_request ( tls, payload,\n\t\t\t\t\t\t\t   payload_len );\n\t\t\tbreak;\n\t\tcase TLS_SERVER_HELLO_DONE:\n\t\t\trc = tls_new_server_hello_done ( tls, payload,\n\t\t\t\t\t\t\t payload_len );\n\t\t\tbreak;\n\t\tcase TLS_FINISHED:\n\t\t\trc = tls_new_finished ( tls, payload, payload_len );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBGC ( tls, \"TLS %p ignoring handshake type %d\\n\",\n\t\t\t       tls, handshake->type );\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Add to handshake digest (except for Hello Requests,\n\t\t * which are explicitly excluded).\n\t\t */\n\t\tif ( handshake->type != TLS_HELLO_REQUEST )\n\t\t\ttls_add_handshake ( tls, data, record_len );\n\n\t\t/* Abort on failure */\n\t\tif ( rc != 0 )\n\t\t\treturn rc;\n\n\t\t/* Move to next handshake record */\n\t\tdata += record_len;\n\t\tremaining -= record_len;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Receive new record\n *\n * @v tls\t\tTLS connection\n * @v type\t\tRecord type\n * @v rx_data\t\tList of received data buffers\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_record ( struct tls_connection *tls, unsigned int type,\n\t\t\t    struct list_head *rx_data ) {\n\tstruct io_buffer *iobuf;\n\tint ( * handler ) ( struct tls_connection *tls, const void *data,\n\t\t\t    size_t len );\n\tint rc;\n\n\t/* Deliver data records to the plainstream interface */\n\tif ( type == TLS_TYPE_DATA ) {\n\n\t\t/* Fail unless we are ready to receive data */\n\t\tif ( ! tls_ready ( tls ) )\n\t\t\treturn -ENOTCONN;\n\n\t\t/* Deliver each I/O buffer in turn */\n\t\twhile ( ( iobuf = list_first_entry ( rx_data, struct io_buffer,\n\t\t\t\t\t\t     list ) ) ) {\n\t\t\tlist_del ( &iobuf->list );\n\t\t\tif ( ( rc = xfer_deliver_iob ( &tls->plainstream,\n\t\t\t\t\t\t       iobuf ) ) != 0 ) {\n\t\t\t\tDBGC ( tls, \"TLS %p could not deliver data: \"\n\t\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* For all other records, merge into a single I/O buffer */\n\tiobuf = iob_concatenate ( rx_data );\n\tif ( ! iobuf ) {\n\t\tDBGC ( tls, \"TLS %p could not concatenate non-data record \"\n\t\t       \"type %d\\n\", tls, type );\n\t\treturn -ENOMEM_RX_CONCAT;\n\t}\n\n\t/* Determine handler */\n\tswitch ( type ) {\n\tcase TLS_TYPE_CHANGE_CIPHER:\n\t\thandler = tls_new_change_cipher;\n\t\tbreak;\n\tcase TLS_TYPE_ALERT:\n\t\thandler = tls_new_alert;\n\t\tbreak;\n\tcase TLS_TYPE_HANDSHAKE:\n\t\thandler = tls_new_handshake;\n\t\tbreak;\n\tdefault:\n\t\t/* RFC4346 says that we should just ignore unknown\n\t\t * record types.\n\t\t */\n\t\thandler = NULL;\n\t\tDBGC ( tls, \"TLS %p ignoring record type %d\\n\", tls, type );\n\t\tbreak;\n\t}\n\n\t/* Handle record and free I/O buffer */\n\trc = ( handler ? handler ( tls, iobuf->data, iob_len ( iobuf ) ) : 0 );\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/******************************************************************************\n *\n * Record encryption/decryption\n *\n ******************************************************************************\n */\n\n/**\n * Initialise HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v authhdr\t\tAuthentication header\n */\nstatic void tls_hmac_init ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t    struct tls_auth_header *authhdr ) {\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct digest_algorithm *digest = suite->digest;\n\n\thmac_init ( digest, ctx, cipherspec->mac_secret, suite->mac_len );\n\thmac_update ( digest, ctx, authhdr, sizeof ( *authhdr ) );\n}\n\n/**\n * Update HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v data\t\tData\n * @v len\t\tLength of data\n */\nstatic void tls_hmac_update ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t      const void *data, size_t len ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\n\thmac_update ( digest, ctx, data, len );\n}\n\n/**\n * Finalise HMAC\n *\n * @v cipherspec\tCipher specification\n * @v ctx\t\tContext\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac_final ( struct tls_cipherspec *cipherspec, void *ctx,\n\t\t\t     void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\n\thmac_final ( digest, ctx, hmac );\n}\n\n/**\n * Calculate HMAC\n *\n * @v cipherspec\tCipher specification\n * @v authhdr\t\tAuthentication header\n * @v data\t\tData\n * @v len\t\tLength of data\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac ( struct tls_cipherspec *cipherspec,\n\t\t       struct tls_auth_header *authhdr,\n\t\t       const void *data, size_t len, void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\n\ttls_hmac_init ( cipherspec, ctx, authhdr );\n\ttls_hmac_update ( cipherspec, ctx, data, len );\n\ttls_hmac_final ( cipherspec, ctx, hmac );\n}\n\n/**\n * Calculate HMAC over list of I/O buffers\n *\n * @v cipherspec\tCipher specification\n * @v authhdr\t\tAuthentication header\n * @v list\t\tList of I/O buffers\n * @v mac\t\tHMAC to fill in\n */\nstatic void tls_hmac_list ( struct tls_cipherspec *cipherspec,\n\t\t\t    struct tls_auth_header *authhdr,\n\t\t\t    struct list_head *list, void *hmac ) {\n\tstruct digest_algorithm *digest = cipherspec->suite->digest;\n\tuint8_t ctx[ hmac_ctxsize ( digest ) ];\n\tstruct io_buffer *iobuf;\n\n\ttls_hmac_init ( cipherspec, ctx, authhdr );\n\tlist_for_each_entry ( iobuf, list, list ) {\n\t\ttls_hmac_update ( cipherspec, ctx, iobuf->data,\n\t\t\t\t  iob_len ( iobuf ) );\n\t}\n\ttls_hmac_final ( cipherspec, ctx, hmac );\n}\n\n/**\n * Send plaintext record\n *\n * @v tls\t\tTLS connection\n * @v type\t\tRecord type\n * @v data\t\tPlaintext record\n * @v len\t\tLength of plaintext record\n * @ret rc\t\tReturn status code\n */\nstatic int tls_send_plaintext ( struct tls_connection *tls, unsigned int type,\n\t\t\t\tconst void *data, size_t len ) {\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tstruct digest_algorithm *digest = suite->digest;\n\tstruct {\n\t\tuint8_t fixed[suite->fixed_iv_len];\n\t\tuint8_t record[suite->record_iv_len];\n\t} __attribute__ (( packed )) iv;\n\tstruct tls_auth_header authhdr;\n\tstruct tls_header *tlshdr;\n\tvoid *plaintext = NULL;\n\tsize_t plaintext_len = len;\n\tstruct io_buffer *ciphertext = NULL;\n\tsize_t ciphertext_len;\n\tsize_t padding_len;\n\tuint8_t mac[digest->digestsize];\n\tvoid *tmp;\n\tint rc;\n\n\t/* Construct initialisation vector */\n\tmemcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );\n\ttls_generate_random ( tls, iv.record, sizeof ( iv.record ) );\n\n\t/* Construct authentication data */\n\tauthhdr.seq = cpu_to_be64 ( tls->tx_seq );\n\tauthhdr.header.type = type;\n\tauthhdr.header.version = htons ( tls->version );\n\tauthhdr.header.length = htons ( len );\n\n\t/* Calculate padding length */\n\tplaintext_len += suite->mac_len;\n\tif ( is_block_cipher ( cipher ) ) {\n\t\tpadding_len = ( ( ( cipher->blocksize - 1 ) &\n\t\t\t\t  -( plaintext_len + 1 ) ) + 1 );\n\t} else {\n\t\tpadding_len = 0;\n\t}\n\tplaintext_len += padding_len;\n\n\t/* Allocate plaintext */\n\tplaintext = malloc ( plaintext_len );\n\tif ( ! plaintext ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for \"\n\t\t       \"plaintext\\n\", tls, plaintext_len );\n\t\trc = -ENOMEM_TX_PLAINTEXT;\n\t\tgoto done;\n\t}\n\n\t/* Assemble plaintext */\n\ttmp = plaintext;\n\tmemcpy ( tmp, data, len );\n\ttmp += len;\n\tif ( suite->mac_len )\n\t\ttls_hmac ( cipherspec, &authhdr, data, len, mac );\n\tmemcpy ( tmp, mac, suite->mac_len );\n\ttmp += suite->mac_len;\n\tmemset ( tmp, ( padding_len - 1 ), padding_len );\n\ttmp += padding_len;\n\tassert ( tmp == ( plaintext + plaintext_len ) );\n\tDBGC2 ( tls, \"Sending plaintext data:\\n\" );\n\tDBGC2_HD ( tls, plaintext, plaintext_len );\n\n\t/* Set initialisation vector */\n\tcipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );\n\n\t/* Allocate ciphertext */\n\tciphertext_len = ( sizeof ( *tlshdr ) + sizeof ( iv.record ) +\n\t\t\t   plaintext_len );\n\tciphertext = xfer_alloc_iob ( &tls->cipherstream, ciphertext_len );\n\tif ( ! ciphertext ) {\n\t\tDBGC ( tls, \"TLS %p could not allocate %zd bytes for \"\n\t\t       \"ciphertext\\n\", tls, ciphertext_len );\n\t\trc = -ENOMEM_TX_CIPHERTEXT;\n\t\tgoto done;\n\t}\n\n\t/* Assemble ciphertext */\n\ttlshdr = iob_put ( ciphertext, sizeof ( *tlshdr ) );\n\ttlshdr->type = type;\n\ttlshdr->version = htons ( tls->version );\n\ttlshdr->length = htons ( ciphertext_len - sizeof ( *tlshdr ) );\n\tmemcpy ( iob_put ( ciphertext, sizeof ( iv.record ) ), iv.record,\n\t\t sizeof ( iv.record ) );\n\tcipher_encrypt ( cipher, cipherspec->cipher_ctx, plaintext,\n\t\t\t iob_put ( ciphertext, plaintext_len ), plaintext_len );\n\tassert ( iob_len ( ciphertext ) == ciphertext_len );\n\n\t/* Free plaintext as soon as possible to conserve memory */\n\tfree ( plaintext );\n\tplaintext = NULL;\n\n\t/* Send ciphertext */\n\tif ( ( rc = xfer_deliver_iob ( &tls->cipherstream,\n\t\t\t\t       iob_disown ( ciphertext ) ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p could not deliver ciphertext: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto done;\n\t}\n\n\t/* Update TX state machine to next record */\n\ttls->tx_seq += 1;\n\n done:\n\tfree ( plaintext );\n\tfree_iob ( ciphertext );\n\treturn rc;\n}\n\n/**\n * Verify block padding\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tLast received I/O buffer\n * @ret len\t\tPadding length, or negative error\n * @ret rc\t\tReturn status code\n */\nstatic int tls_verify_padding ( struct tls_connection *tls,\n\t\t\t\tstruct io_buffer *iobuf ) {\n\tuint8_t *padding;\n\tunsigned int pad;\n\tunsigned int i;\n\tsize_t len;\n\n\t/* Extract and verify padding */\n\tpadding = ( iobuf->tail - 1 );\n\tpad = *padding;\n\tlen = ( pad + 1 );\n\tif ( len > iob_len ( iobuf ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength padding\\n\", tls );\n\t\tDBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\treturn -EINVAL_PADDING;\n\t}\n\tfor ( i = 0 ; i < pad ; i++ ) {\n\t\tif ( *(--padding) != pad ) {\n\t\t\tDBGC ( tls, \"TLS %p received bad padding\\n\", tls );\n\t\t\tDBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\t\treturn -EINVAL_PADDING;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * Receive new ciphertext record\n *\n * @v tls\t\tTLS connection\n * @v tlshdr\t\tRecord header\n * @v rx_data\t\tList of received data buffers\n * @ret rc\t\tReturn status code\n */\nstatic int tls_new_ciphertext ( struct tls_connection *tls,\n\t\t\t\tstruct tls_header *tlshdr,\n\t\t\t\tstruct list_head *rx_data ) {\n\tstruct tls_cipherspec *cipherspec = &tls->rx_cipherspec;\n\tstruct tls_cipher_suite *suite = cipherspec->suite;\n\tstruct cipher_algorithm *cipher = suite->cipher;\n\tstruct digest_algorithm *digest = suite->digest;\n\tsize_t len = ntohs ( tlshdr->length );\n\tstruct {\n\t\tuint8_t fixed[suite->fixed_iv_len];\n\t\tuint8_t record[suite->record_iv_len];\n\t} __attribute__ (( packed )) iv;\n\tstruct tls_auth_header authhdr;\n\tuint8_t verify_mac[digest->digestsize];\n\tstruct io_buffer *first;\n\tstruct io_buffer *last;\n\tstruct io_buffer *iobuf;\n\tvoid *mac;\n\tsize_t check_len;\n\tint pad_len;\n\tint rc;\n\n\t/* Locate first and last data buffers */\n\tassert ( ! list_empty ( rx_data ) );\n\tfirst = list_first_entry ( rx_data, struct io_buffer, list );\n\tlast = list_last_entry ( rx_data, struct io_buffer, list );\n\n\t/* Extract initialisation vector */\n\tif ( iob_len ( first ) < sizeof ( iv.record ) ) {\n\t\tDBGC ( tls, \"TLS %p received underlength IV\\n\", tls );\n\t\tDBGC_HD ( tls, first->data, iob_len ( first ) );\n\t\treturn -EINVAL_IV;\n\t}\n\tmemcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );\n\tmemcpy ( iv.record, first->data, sizeof ( iv.record ) );\n\tiob_pull ( first, sizeof ( iv.record ) );\n\tlen -= sizeof ( iv.record );\n\n\t/* Construct authentication data */\n\tauthhdr.seq = cpu_to_be64 ( tls->rx_seq );\n\tauthhdr.header.type = tlshdr->type;\n\tauthhdr.header.version = tlshdr->version;\n\tauthhdr.header.length = htons ( len );\n\n\t/* Set initialisation vector */\n\tcipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );\n\n\t/* Decrypt the received data */\n\tcheck_len = 0;\n\tlist_for_each_entry ( iobuf, &tls->rx_data, list ) {\n\t\tcipher_decrypt ( cipher, cipherspec->cipher_ctx,\n\t\t\t\t iobuf->data, iobuf->data, iob_len ( iobuf ) );\n\t\tcheck_len += iob_len ( iobuf );\n\t}\n\tassert ( check_len == len );\n\n\t/* Strip block padding, if applicable */\n\tif ( is_block_cipher ( cipher ) ) {\n\t\tpad_len = tls_verify_padding ( tls, last );\n\t\tif ( pad_len < 0 ) {\n\t\t\t/* Assume zero padding length to avoid timing attacks */\n\t\t\tpad_len = 0;\n\t\t}\n\t\tiob_unput ( last, pad_len );\n\t\tlen -= pad_len;\n\t}\n\n\t/* Extract decrypted MAC */\n\tif ( iob_len ( last ) < suite->mac_len ) {\n\t\tDBGC ( tls, \"TLS %p received underlength MAC\\n\", tls );\n\t\tDBGC_HD ( tls, last->data, iob_len ( last ) );\n\t\treturn -EINVAL_MAC;\n\t}\n\tiob_unput ( last, suite->mac_len );\n\tlen -= suite->mac_len;\n\tmac = last->tail;\n\n\t/* Dump received data */\n\tDBGC2 ( tls, \"Received plaintext data:\\n\" );\n\tcheck_len = 0;\n\tlist_for_each_entry ( iobuf, rx_data, list ) {\n\t\tDBGC2_HD ( tls, iobuf->data, iob_len ( iobuf ) );\n\t\tcheck_len += iob_len ( iobuf );\n\t}\n\tassert ( check_len == len );\n\n\t/* Generate MAC */\n\tauthhdr.header.length = htons ( len );\n\tif ( suite->mac_len )\n\t\ttls_hmac_list ( cipherspec, &authhdr, rx_data, verify_mac );\n\n\t/* Verify MAC */\n\tif ( memcmp ( mac, verify_mac, suite->mac_len ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p failed MAC verification\\n\", tls );\n\t\treturn -EINVAL_MAC;\n\t}\n\n\t/* Process plaintext record */\n\tif ( ( rc = tls_new_record ( tls, tlshdr->type, rx_data ) ) != 0 )\n\t\treturn rc;\n\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Plaintext stream operations\n *\n ******************************************************************************\n */\n\n/**\n * Check flow control window\n *\n * @v tls\t\tTLS connection\n * @ret len\t\tLength of window\n */\nstatic size_t tls_plainstream_window ( struct tls_connection *tls ) {\n\n\t/* Block window unless we are ready to accept data */\n\tif ( ! tls_ready ( tls ) )\n\t\treturn 0;\n\n\treturn xfer_window ( &tls->cipherstream );\n}\n\n/**\n * Deliver datagram as raw data\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tI/O buffer\n * @v meta\t\tData transfer metadata\n * @ret rc\t\tReturn status code\n */\nstatic int tls_plainstream_deliver ( struct tls_connection *tls,\n\t\t\t\t     struct io_buffer *iobuf,\n\t\t\t\t     struct xfer_metadata *meta __unused ) {\n\tint rc;\n\t\n\t/* Refuse unless we are ready to accept data */\n\tif ( ! tls_ready ( tls ) ) {\n\t\trc = -ENOTCONN;\n\t\tgoto done;\n\t}\n\n\tif ( ( rc = tls_send_plaintext ( tls, TLS_TYPE_DATA, iobuf->data,\n\t\t\t\t\t iob_len ( iobuf ) ) ) != 0 )\n\t\tgoto done;\n\n done:\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/**\n * Report job progress\n *\n * @v tls\t\tTLS connection\n * @v progress\t\tProgress report to fill in\n * @ret ongoing_rc\tOngoing job status code (if known)\n */\nstatic int tls_progress ( struct tls_connection *tls,\n\t\t\t  struct job_progress *progress ) {\n\n\t/* Return cipherstream or validator progress as applicable */\n\tif ( is_pending ( &tls->validation ) ) {\n\t\treturn job_progress ( &tls->validator, progress );\n\t} else {\n\t\treturn job_progress ( &tls->cipherstream, progress );\n\t}\n}\n\n/** TLS plaintext stream interface operations */\nstatic struct interface_operation tls_plainstream_ops[] = {\n\tINTF_OP ( xfer_deliver, struct tls_connection *,\n\t\t  tls_plainstream_deliver ),\n\tINTF_OP ( xfer_window, struct tls_connection *,\n\t\t  tls_plainstream_window ),\n\tINTF_OP ( job_progress, struct tls_connection *, tls_progress ),\n\tINTF_OP ( intf_close, struct tls_connection *, tls_close ),\n};\n\n/** TLS plaintext stream interface descriptor */\nstatic struct interface_descriptor tls_plainstream_desc =\n\tINTF_DESC_PASSTHRU ( struct tls_connection, plainstream,\n\t\t\t     tls_plainstream_ops, cipherstream );\n\n/******************************************************************************\n *\n * Ciphertext stream operations\n *\n ******************************************************************************\n */\n\n/**\n * Handle received TLS header\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturned status code\n */\nstatic int tls_newdata_process_header ( struct tls_connection *tls ) {\n\tstruct tls_cipherspec *cipherspec = &tls->rx_cipherspec;\n\tstruct cipher_algorithm *cipher = cipherspec->suite->cipher;\n\tsize_t iv_len = cipherspec->suite->record_iv_len;\n\tsize_t data_len = ntohs ( tls->rx_header.length );\n\tsize_t remaining = data_len;\n\tsize_t frag_len;\n\tsize_t reserve;\n\tstruct io_buffer *iobuf;\n\tstruct io_buffer *tmp;\n\tint rc;\n\n\t/* Sanity check */\n\tassert ( ( TLS_RX_BUFSIZE % cipher->alignsize ) == 0 );\n\n\t/* Calculate alignment reservation at start of first data buffer */\n\treserve = ( ( -iv_len ) & ( cipher->alignsize - 1 ) );\n\tremaining += reserve;\n\n\t/* Allocate data buffers now that we know the length */\n\tassert ( list_empty ( &tls->rx_data ) );\n\twhile ( remaining ) {\n\n\t\t/* Calculate fragment length.  Ensure that no block is\n\t\t * smaller than TLS_RX_MIN_BUFSIZE (by increasing the\n\t\t * allocation length if necessary).\n\t\t */\n\t\tfrag_len = remaining;\n\t\tif ( frag_len > TLS_RX_BUFSIZE )\n\t\t\tfrag_len = TLS_RX_BUFSIZE;\n\t\tremaining -= frag_len;\n\t\tif ( remaining < TLS_RX_MIN_BUFSIZE ) {\n\t\t\tfrag_len += remaining;\n\t\t\tremaining = 0;\n\t\t}\n\n\t\t/* Allocate buffer */\n\t\tiobuf = alloc_iob_raw ( frag_len, TLS_RX_ALIGN, 0 );\n\t\tif ( ! iobuf ) {\n\t\t\tDBGC ( tls, \"TLS %p could not allocate %zd of %zd \"\n\t\t\t       \"bytes for receive buffer\\n\", tls,\n\t\t\t       remaining, data_len );\n\t\t\trc = -ENOMEM_RX_DATA;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Ensure tailroom is exactly what we asked for.  This\n\t\t * will result in unaligned I/O buffers when the\n\t\t * fragment length is unaligned, which can happen only\n\t\t * before we switch to using a block cipher.\n\t\t */\n\t\tiob_reserve ( iobuf, ( iob_tailroom ( iobuf ) - frag_len ) );\n\n\t\t/* Ensure first buffer length will be aligned to a\n\t\t * multiple of the cipher alignment size after\n\t\t * stripping the record IV.\n\t\t */\n\t\tiob_reserve ( iobuf, reserve );\n\t\treserve = 0;\n\n\t\t/* Add I/O buffer to list */\n\t\tlist_add_tail ( &iobuf->list, &tls->rx_data );\n\t}\n\n\t/* Move to data state */\n\ttls->rx_state = TLS_RX_DATA;\n\n\treturn 0;\n\n err:\n\tlist_for_each_entry_safe ( iobuf, tmp, &tls->rx_data, list ) {\n\t\tlist_del ( &iobuf->list );\n\t\tfree_iob ( iobuf );\n\t}\n\treturn rc;\n}\n\n/**\n * Handle received TLS data payload\n *\n * @v tls\t\tTLS connection\n * @ret rc\t\tReturned status code\n */\nstatic int tls_newdata_process_data ( struct tls_connection *tls ) {\n\tstruct io_buffer *iobuf;\n\tint rc;\n\n\t/* Move current buffer to end of list */\n\tiobuf = list_first_entry ( &tls->rx_data, struct io_buffer, list );\n\tlist_del ( &iobuf->list );\n\tlist_add_tail ( &iobuf->list, &tls->rx_data );\n\n\t/* Continue receiving data if any space remains */\n\tiobuf = list_first_entry ( &tls->rx_data, struct io_buffer, list );\n\tif ( iob_tailroom ( iobuf ) )\n\t\treturn 0;\n\n\t/* Process record */\n\tif ( ( rc = tls_new_ciphertext ( tls, &tls->rx_header,\n\t\t\t\t\t &tls->rx_data ) ) != 0 )\n\t\treturn rc;\n\n\t/* Increment RX sequence number */\n\ttls->rx_seq += 1;\n\n\t/* Return to header state */\n\tassert ( list_empty ( &tls->rx_data ) );\n\ttls->rx_state = TLS_RX_HEADER;\n\tiob_unput ( &tls->rx_header_iobuf, sizeof ( tls->rx_header ) );\n\n\treturn 0;\n}\n\n/**\n * Check flow control window\n *\n * @v tls\t\tTLS connection\n * @ret len\t\tLength of window\n */\nstatic size_t tls_cipherstream_window ( struct tls_connection *tls ) {\n\n\t/* Open window until we are ready to accept data */\n\tif ( ! tls_ready ( tls ) )\n\t\treturn -1UL;\n\n\treturn xfer_window ( &tls->plainstream );\n}\n\n/**\n * Receive new ciphertext\n *\n * @v tls\t\tTLS connection\n * @v iobuf\t\tI/O buffer\n * @v meta\t\tData transfer metadat\n * @ret rc\t\tReturn status code\n */\nstatic int tls_cipherstream_deliver ( struct tls_connection *tls,\n\t\t\t\t      struct io_buffer *iobuf,\n\t\t\t\t      struct xfer_metadata *xfer __unused ) {\n\tsize_t frag_len;\n\tint ( * process ) ( struct tls_connection *tls );\n\tstruct io_buffer *dest;\n\tint rc;\n\n\twhile ( iob_len ( iobuf ) ) {\n\n\t\t/* Select buffer according to current state */\n\t\tswitch ( tls->rx_state ) {\n\t\tcase TLS_RX_HEADER:\n\t\t\tdest = &tls->rx_header_iobuf;\n\t\t\tprocess = tls_newdata_process_header;\n\t\t\tbreak;\n\t\tcase TLS_RX_DATA:\n\t\t\tdest = list_first_entry ( &tls->rx_data,\n\t\t\t\t\t\t  struct io_buffer, list );\n\t\t\tassert ( dest != NULL );\n\t\t\tprocess = tls_newdata_process_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert ( 0 );\n\t\t\trc = -EINVAL_RX_STATE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Copy data portion to buffer */\n\t\tfrag_len = iob_len ( iobuf );\n\t\tif ( frag_len > iob_tailroom ( dest ) )\n\t\t\tfrag_len = iob_tailroom ( dest );\n\t\tmemcpy ( iob_put ( dest, frag_len ), iobuf->data, frag_len );\n\t\tiob_pull ( iobuf, frag_len );\n\n\t\t/* Process data if buffer is now full */\n\t\tif ( iob_tailroom ( dest ) == 0 ) {\n\t\t\tif ( ( rc = process ( tls ) ) != 0 ) {\n\t\t\t\ttls_close ( tls, rc );\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\n\n done:\n\tfree_iob ( iobuf );\n\treturn rc;\n}\n\n/** TLS ciphertext stream interface operations */\nstatic struct interface_operation tls_cipherstream_ops[] = {\n\tINTF_OP ( xfer_deliver, struct tls_connection *,\n\t\t  tls_cipherstream_deliver ),\n\tINTF_OP ( xfer_window, struct tls_connection *,\n\t\t  tls_cipherstream_window ),\n\tINTF_OP ( xfer_window_changed, struct tls_connection *,\n\t\t  tls_tx_resume ),\n\tINTF_OP ( intf_close, struct tls_connection *, tls_close ),\n};\n\n/** TLS ciphertext stream interface descriptor */\nstatic struct interface_descriptor tls_cipherstream_desc =\n\tINTF_DESC_PASSTHRU ( struct tls_connection, cipherstream,\n\t\t\t     tls_cipherstream_ops, plainstream );\n\n/******************************************************************************\n *\n * Certificate validator\n *\n ******************************************************************************\n */\n\n/**\n * Handle certificate validation completion\n *\n * @v tls\t\tTLS connection\n * @v rc\t\tReason for completion\n */\nstatic void tls_validator_done ( struct tls_connection *tls, int rc ) {\n\tstruct tls_session *session = tls->session;\n\tstruct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;\n\tstruct pubkey_algorithm *pubkey = cipherspec->suite->pubkey;\n\tstruct x509_certificate *cert;\n\n\t/* Mark validation as complete */\n\tpending_put ( &tls->validation );\n\n\t/* Close validator interface */\n\tintf_restart ( &tls->validator, rc );\n\n\t/* Check for validation failure */\n\tif ( rc != 0 ) {\n\t\tDBGC ( tls, \"TLS %p certificate validation failed: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\tDBGC ( tls, \"TLS %p certificate validation succeeded\\n\", tls );\n\n\t/* Extract first certificate */\n\tcert = x509_first ( tls->chain );\n\tassert ( cert != NULL );\n\n\t/* Verify server name */\n\tif ( ( rc = x509_check_name ( cert, session->name ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p server certificate does not match %s: %s\\n\",\n\t\t       tls, session->name, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\n\t/* Initialise public key algorithm */\n\tif ( ( rc = pubkey_init ( pubkey, cipherspec->pubkey_ctx,\n\t\t\t\t  cert->subject.public_key.raw.data,\n\t\t\t\t  cert->subject.public_key.raw.len ) ) != 0 ) {\n\t\tDBGC ( tls, \"TLS %p cannot initialise public key: %s\\n\",\n\t\t       tls, strerror ( rc ) );\n\t\tgoto err;\n\t}\n\n\t/* Schedule Client Key Exchange, Change Cipher, and Finished */\n\ttls->tx_pending |= ( TLS_TX_CLIENT_KEY_EXCHANGE |\n\t\t\t     TLS_TX_CHANGE_CIPHER |\n\t\t\t     TLS_TX_FINISHED );\n\tif ( tls->certs ) {\n\t\ttls->tx_pending |= ( TLS_TX_CERTIFICATE |\n\t\t\t\t     TLS_TX_CERTIFICATE_VERIFY );\n\t}\n\ttls_tx_resume ( tls );\n\n\treturn;\n\n err:\n\ttls_close ( tls, rc );\n\treturn;\n}\n\n/** TLS certificate validator interface operations */\nstatic struct interface_operation tls_validator_ops[] = {\n\tINTF_OP ( intf_close, struct tls_connection *, tls_validator_done ),\n};\n\n/** TLS certificate validator interface descriptor */\nstatic struct interface_descriptor tls_validator_desc =\n\tINTF_DESC ( struct tls_connection, validator, tls_validator_ops );\n\n/******************************************************************************\n *\n * Controlling process\n *\n ******************************************************************************\n */\n\n/**\n * TLS TX state machine\n *\n * @v tls\t\tTLS connection\n */\nstatic void tls_tx_step ( struct tls_connection *tls ) {\n\tstruct tls_session *session = tls->session;\n\tstruct tls_connection *conn;\n\tint rc;\n\n\t/* Wait for cipherstream to become ready */\n\tif ( ! xfer_window ( &tls->cipherstream ) )\n\t\treturn;\n\n\t/* Send first pending transmission */\n\tif ( tls->tx_pending & TLS_TX_CLIENT_HELLO ) {\n\t\t/* Serialise server negotiations within a session, to\n\t\t * provide a consistent view of session IDs and\n\t\t * session tickets.\n\t\t */\n\t\tlist_for_each_entry ( conn, &session->conn, list ) {\n\t\t\tif ( conn == tls )\n\t\t\t\tbreak;\n\t\t\tif ( is_pending ( &conn->server_negotiation ) )\n\t\t\t\treturn;\n\t\t}\n\t\t/* Record or generate session ID and associated master secret */\n\t\tif ( session->id_len ) {\n\t\t\t/* Attempt to resume an existing session */\n\t\t\tmemcpy ( tls->session_id, session->id,\n\t\t\t\t sizeof ( tls->session_id ) );\n\t\t\ttls->session_id_len = session->id_len;\n\t\t\tmemcpy ( tls->master_secret, session->master_secret,\n\t\t\t\t sizeof ( tls->master_secret ) );\n\t\t} else {\n\t\t\t/* No existing session: use a random session ID */\n\t\t\tassert ( sizeof ( tls->session_id ) ==\n\t\t\t\t sizeof ( tls->client_random ) );\n\t\t\tmemcpy ( tls->session_id, &tls->client_random,\n\t\t\t\t sizeof ( tls->session_id ) );\n\t\t\ttls->session_id_len = sizeof ( tls->session_id );\n\t\t}\n\t\t/* Send Client Hello */\n\t\tif ( ( rc = tls_send_client_hello ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Client Hello: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CLIENT_HELLO;\n\t} else if ( tls->tx_pending & TLS_TX_CERTIFICATE ) {\n\t\t/* Send Certificate */\n\t\tif ( ( rc = tls_send_certificate ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p cold not send Certificate: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CERTIFICATE;\n\t} else if ( tls->tx_pending & TLS_TX_CLIENT_KEY_EXCHANGE ) {\n\t\t/* Send Client Key Exchange */\n\t\tif ( ( rc = tls_send_client_key_exchange ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Client Key \"\n\t\t\t       \"Exchange: %s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CLIENT_KEY_EXCHANGE;\n\t} else if ( tls->tx_pending & TLS_TX_CERTIFICATE_VERIFY ) {\n\t\t/* Send Certificate Verify */\n\t\tif ( ( rc = tls_send_certificate_verify ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Certificate \"\n\t\t\t       \"Verify: %s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_CERTIFICATE_VERIFY;\n\t} else if ( tls->tx_pending & TLS_TX_CHANGE_CIPHER ) {\n\t\t/* Send Change Cipher, and then change the cipher in use */\n\t\tif ( ( rc = tls_send_change_cipher ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Change Cipher: \"\n\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\tif ( ( rc = tls_change_cipher ( tls,\n\t\t\t\t\t\t&tls->tx_cipherspec_pending,\n\t\t\t\t\t\t&tls->tx_cipherspec )) != 0 ){\n\t\t\tDBGC ( tls, \"TLS %p could not activate TX cipher: \"\n\t\t\t       \"%s\\n\", tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_seq = 0;\n\t\ttls->tx_pending &= ~TLS_TX_CHANGE_CIPHER;\n\t} else if ( tls->tx_pending & TLS_TX_FINISHED ) {\n\t\t/* Send Finished */\n\t\tif ( ( rc = tls_send_finished ( tls ) ) != 0 ) {\n\t\t\tDBGC ( tls, \"TLS %p could not send Finished: %s\\n\",\n\t\t\t       tls, strerror ( rc ) );\n\t\t\tgoto err;\n\t\t}\n\t\ttls->tx_pending &= ~TLS_TX_FINISHED;\n\t}\n\n\t/* Reschedule process if pending transmissions remain,\n\t * otherwise send notification of a window change.\n\t */\n\tif ( tls->tx_pending ) {\n\t\ttls_tx_resume ( tls );\n\t} else {\n\t\txfer_window_changed ( &tls->plainstream );\n\t}\n\n\treturn;\n\n err:\n\ttls_close ( tls, rc );\n}\n\n/** TLS TX process descriptor */\nstatic struct process_descriptor tls_process_desc =\n\tPROC_DESC_ONCE ( struct tls_connection, process, tls_tx_step );\n\n/******************************************************************************\n *\n * Session management\n *\n ******************************************************************************\n */\n\n/**\n * Find or create session for TLS connection\n *\n * @v tls\t\tTLS connection\n * @v name\t\tServer name\n * @ret rc\t\tReturn status code\n */\nstatic int tls_session ( struct tls_connection *tls, const char *name ) {\n\tstruct tls_session *session;\n\tchar *name_copy;\n\tint rc;\n\n\t/* Find existing matching session, if any */\n\tlist_for_each_entry ( session, &tls_sessions, list ) {\n\t\tif ( ( strcmp ( name, session->name ) == 0 ) &&\n\t\t     ( tls->root == session->root ) &&\n\t\t     ( tls->key == session->key ) ) {\n\t\t\tref_get ( &session->refcnt );\n\t\t\ttls->session = session;\n\t\t\tDBGC ( tls, \"TLS %p joining session %s\\n\", tls, name );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Create new session */\n\tsession = zalloc ( sizeof ( *session ) + strlen ( name )\n\t\t\t   + 1 /* NUL */ );\n\tif ( ! session ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tref_init ( &session->refcnt, free_tls_session );\n\tname_copy = ( ( ( void * ) session ) + sizeof ( *session ) );\n\tstrcpy ( name_copy, name );\n\tsession->name = name_copy;\n\tsession->root = x509_root_get ( tls->root );\n\tsession->key = privkey_get ( tls->key );\n\tINIT_LIST_HEAD ( &session->conn );\n\tlist_add ( &session->list, &tls_sessions );\n\n\t/* Record session */\n\ttls->session = session;\n\n\tDBGC ( tls, \"TLS %p created session %s\\n\", tls, name );\n\treturn 0;\n\n\tref_put ( &session->refcnt );\n err_alloc:\n\treturn rc;\n}\n\n/******************************************************************************\n *\n * Instantiator\n *\n ******************************************************************************\n */\n\n/**\n * Add TLS on an interface\n *\n * @v xfer\t\tData transfer interface\n * @v name\t\tHost name\n * @v root\t\tRoot of trust (or NULL to use default)\n * @v key\t\tPrivate key (or NULL to use default)\n * @ret rc\t\tReturn status code\n */\nint add_tls ( struct interface *xfer, const char *name,\n\t      struct x509_root *root, struct private_key *key ) {\n\tstruct tls_connection *tls;\n\tint rc;\n\n\t/* Allocate and initialise TLS structure */\n\ttls = malloc ( sizeof ( *tls ) );\n\tif ( ! tls ) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tmemset ( tls, 0, sizeof ( *tls ) );\n\tref_init ( &tls->refcnt, free_tls );\n\tINIT_LIST_HEAD ( &tls->list );\n\tintf_init ( &tls->plainstream, &tls_plainstream_desc, &tls->refcnt );\n\tintf_init ( &tls->cipherstream, &tls_cipherstream_desc, &tls->refcnt );\n\tintf_init ( &tls->validator, &tls_validator_desc, &tls->refcnt );\n\tprocess_init_stopped ( &tls->process, &tls_process_desc,\n\t\t\t       &tls->refcnt );\n\ttls->key = privkey_get ( key ? key : &private_key );\n\ttls->root = x509_root_get ( root ? root : &root_certificates );\n\ttls->version = TLS_VERSION_MAX;\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->tx_cipherspec_pending );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec );\n\ttls_clear_cipher ( tls, &tls->rx_cipherspec_pending );\n\ttls->client_random.gmt_unix_time = time ( NULL );\n\tiob_populate ( &tls->rx_header_iobuf, &tls->rx_header, 0,\n\t\t       sizeof ( tls->rx_header ) );\n\tINIT_LIST_HEAD ( &tls->rx_data );\n\tif ( ( rc = tls_generate_random ( tls, &tls->client_random.random,\n\t\t\t  ( sizeof ( tls->client_random.random ) ) ) ) != 0 ) {\n\t\tgoto err_random;\n\t}\n\tif ( ( rc = tls_session ( tls, name ) ) != 0 )\n\t\tgoto err_session;\n\tlist_add_tail ( &tls->list, &tls->session->conn );\n\n\t/* Start negotiation */\n\ttls_restart ( tls );\n\n\t/* Attach to parent interface, mortalise self, and return */\n\tintf_insert ( xfer, &tls->plainstream, &tls->cipherstream );\n\tref_put ( &tls->refcnt );\n\treturn 0;\n\n err_session:\n err_random:\n\tref_put ( &tls->refcnt );\n err_alloc:\n\treturn rc;\n}\n\n/* Drag in objects via add_tls() */\nREQUIRING_SYMBOL ( add_tls );\n\n/* Drag in crypto configuration */\nREQUIRE_OBJECT ( config_crypto );\n"], "filenames": ["src/net/tls.c"], "buggy_code_start_loc": [2824], "buggy_code_end_loc": [2826], "fixing_code_start_loc": [2824], "fixing_code_end_loc": [2826], "type": "CWE-200", "message": "A vulnerability was found in iPXE. It has been declared as problematic. This vulnerability affects the function tls_new_ciphertext of the file src/net/tls.c of the component TLS. The manipulation of the argument pad_len leads to information exposure through discrepancy. The name of the patch is 186306d6199096b7a7c4b4574d4be8cdb8426729. It is recommended to apply a patch to fix this issue. VDB-214054 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4087", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-21T07:15:08.957", "lastModified": "2023-02-03T14:38:46.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in iPXE. It has been declared as problematic. This vulnerability affects the function tls_new_ciphertext of the file src/net/tls.c of the component TLS. The manipulation of the argument pad_len leads to information exposure through discrepancy. The name of the patch is 186306d6199096b7a7c4b4574d4be8cdb8426729. It is recommended to apply a patch to fix this issue. VDB-214054 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-203"}, {"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:ipxe:ipxe:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-08", "matchCriteriaId": "F3AF5B8D-B282-4683-96B5-FBBFBB7F1DEB"}]}]}], "references": [{"url": "https://github.com/ipxe/ipxe/commit/186306d6199096b7a7c4b4574d4be8cdb8426729", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.214054", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ipxe/ipxe/commit/186306d6199096b7a7c4b4574d4be8cdb8426729"}}