{"buggy_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nconst AREA = 'customer';\nrequire __DIR__ . '/lib/init.php';\n\nuse Froxlor\\Api\\Commands\\Ftps as Ftps;\nuse Froxlor\\CurrentUser;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\UI\\Collection;\nuse Froxlor\\UI\\HTML;\nuse Froxlor\\UI\\Listing;\nuse Froxlor\\UI\\Panel\\UI;\nuse Froxlor\\UI\\Request;\nuse Froxlor\\UI\\Response;\n\n// redirect if this customer page is hidden via settings\nif (Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\tResponse::redirectTo('customer_index.php');\n}\n\n$id = (int)Request::any('id', 0);\n\nif ($page == 'overview' || $page == 'accounts') {\n\tif ($action == '') {\n\t\t$log->logAction(FroxlorLogger::USR_ACTION, LOG_NOTICE, \"viewed customer_ftp::accounts\");\n\t\ttry {\n\t\t\t$ftp_list_data = include_once dirname(__FILE__) . '/lib/tablelisting/customer/tablelisting.ftps.php';\n\t\t\t$collection = (new Collection(Ftps::class, $userinfo))\n\t\t\t\t->withPagination($ftp_list_data['ftp_list']['columns'], $ftp_list_data['ftp_list']['default_sorting']);\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\n\t\t$actions_links = [];\n\t\tif (CurrentUser::canAddResource('ftps')) {\n\t\t\t$actions_links = [\n\t\t\t\t'href' => $linker->getLink(['section' => 'ftp', 'page' => 'accounts', 'action' => 'add']),\n\t\t\t\t'label' => lng('ftp.account_add')\n\t\t\t];\n\t\t}\n\t\t$actions_links[] = [\n\t\t\t'href' => 'https://docs.froxlor.org/v2/user-guide/ftp-accounts/',\n\t\t\t'target' => '_blank',\n\t\t\t'icon' => 'fa-solid fa-circle-info',\n\t\t\t'class' => 'btn-outline-secondary'\n\t\t];\n\n\t\tUI::view('user/table.html.twig', [\n\t\t\t'listing' => Listing::format($collection, $ftp_list_data, 'ftp_list'),\n\t\t\t'actions_links' => $actions_links,\n\t\t\t'entity_info' => lng('ftp.description')\n\t\t]);\n\t} elseif ($action == 'delete' && $id != 0) {\n\t\ttry {\n\t\t\t$json_result = Ftps::getLocal($userinfo, [\n\t\t\t\t'id' => $id\n\t\t\t])->get();\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\tif (isset($result['username']) && $result['username'] != $userinfo['loginname']) {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->delete();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tHTML::askYesNoWithCheckbox('ftp_reallydelete', 'admin_customer_alsoremoveftphomedir', $filename, [\n\t\t\t\t\t'id' => $id,\n\t\t\t\t\t'page' => $page,\n\t\t\t\t\t'action' => $action\n\t\t\t\t], $result['username']);\n\t\t\t}\n\t\t} else {\n\t\t\tResponse::standardError('ftp_cantdeletemainaccount');\n\t\t}\n\t} elseif ($action == 'add') {\n\t\tif ($userinfo['ftps_used'] < $userinfo['ftps'] || $userinfo['ftps'] == '-1') {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->add();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\t$pathSelect = FileDir::makePathfield($userinfo['documentroot'], $userinfo['guid'], $userinfo['guid'], '/');\n\n\t\t\t\tif (Settings::Get('customer.ftpatdomain') == '1') {\n\t\t\t\t\t$domainlist = [];\n\t\t\t\t\t$result_domains_stmt = Database::prepare(\"SELECT `domain` FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\t\tWHERE `customerid`= :customerid ORDER BY `domain` ASC\");\n\t\t\t\t\tDatabase::pexecute($result_domains_stmt, [\n\t\t\t\t\t\t\"customerid\" => $userinfo['customerid']\n\t\t\t\t\t]);\n\n\t\t\t\t\twhile ($row_domain = $result_domains_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t\t$domainlist[$row_domain['domain']] = $idna_convert->decode($row_domain['domain']);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t\t$shells['/bin/false'] = \"/bin/false\";\n\t\t\t\t\t$shells_avail = Settings::Get('system.available_shells');\n\t\t\t\t\tif (!empty($shells_avail)) {\n\t\t\t\t\t\t$shells_avail_arr = explode(\",\", $shells_avail);\n\t\t\t\t\t\t$shells_avail_arr = array_map(\"trim\", $shells_avail_arr);\n\t\t\t\t\t\tforeach ($shells_avail_arr as $shell) {\n\t\t\t\t\t\t\t$shells[$shell] = $shell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$ftp_add_data = include_once dirname(__FILE__) . '/lib/formfields/customer/ftp/formfield.ftp_add.php';\n\n\t\t\t\tUI::view('user/form.html.twig', [\n\t\t\t\t\t'formaction' => $linker->getLink(['section' => 'ftp']),\n\t\t\t\t\t'formdata' => $ftp_add_data['ftp_add']\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t} elseif ($action == 'edit' && $id != 0) {\n\t\ttry {\n\t\t\t$json_result = Ftps::getLocal($userinfo, [\n\t\t\t\t'id' => $id\n\t\t\t])->get();\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\tif (isset($result['username']) && $result['username'] != '') {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->update();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tif (strpos($result['homedir'], $userinfo['documentroot']) === 0) {\n\t\t\t\t\t$homedir = str_replace($userinfo['documentroot'], \"/\", $result['homedir']);\n\t\t\t\t} else {\n\t\t\t\t\t$homedir = $result['homedir'];\n\t\t\t\t}\n\t\t\t\t$homedir = FileDir::makeCorrectDir($homedir);\n\n\t\t\t\t$pathSelect = FileDir::makePathfield($userinfo['documentroot'], $userinfo['guid'], $userinfo['guid'], $homedir);\n\n\t\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t\t$shells['/bin/false'] = \"/bin/false\";\n\t\t\t\t\t$shells_avail = Settings::Get('system.available_shells');\n\t\t\t\t\tif (!empty($shells_avail)) {\n\t\t\t\t\t\t$shells_avail_arr = explode(\",\", $shells_avail);\n\t\t\t\t\t\t$shells_avail_arr = array_map(\"trim\", $shells_avail_arr);\n\t\t\t\t\t\tforeach ($shells_avail_arr as $shell) {\n\t\t\t\t\t\t\t$shells[$shell] = $shell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$ftp_edit_data = include_once dirname(__FILE__) . '/lib/formfields/customer/ftp/formfield.ftp_edit.php';\n\n\t\t\t\tUI::view('user/form.html.twig', [\n\t\t\t\t\t'formaction' => $linker->getLink(['section' => 'ftp', 'id' => $id]),\n\t\t\t\t\t'formdata' => $ftp_edit_data['ftp_edit'],\n\t\t\t\t\t'editid' => $id\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass DirOptions extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add options for a given directory\n\t *\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $path\n\t *            path relative to the customer's home-Directory\n\t * @param bool $options_indexes\n\t *            optional, activate directory-listing for this path, default 0 (false)\n\t * @param bool $options_cgi\n\t *            optional, allow Perl/CGI execution, default 0 (false)\n\t * @param string $error404path\n\t *            optional, custom 404 error string/file\n\t * @param string $error403path\n\t *            optional, custom 403 error string/file\n\t * @param string $error500path\n\t *            optional, custom 500 error string/file\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// required parameters\n\t\t$path = $this->getParam('path');\n\n\t\t// parameters\n\t\t$options_indexes = $this->getBoolParam('options_indexes', true, 0);\n\t\t$options_cgi = $this->getBoolParam('options_cgi', true, 0);\n\t\t$error404path = $this->getParam('error404path', true, '');\n\t\t$error403path = $this->getParam('error403path', true, '');\n\t\t$error500path = $this->getParam('error500path', true, '');\n\n\t\t// validation\n\t\t$path = FileDir::makeCorrectDir(Validate::validate($path, 'path', Validate::REGEX_DIR, '', [], true));\n\t\t$userpath = $path;\n\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);\n\n\t\tif (!empty($error404path)) {\n\t\t\t$error404path = $this->correctErrorDocument($error404path, true);\n\t\t}\n\n\t\tif (!empty($error403path)) {\n\t\t\t$error403path = $this->correctErrorDocument($error403path, true);\n\t\t}\n\n\t\tif (!empty($error500path)) {\n\t\t\t$error500path = $this->correctErrorDocument($error500path, true);\n\t\t}\n\n\t\t// check for duplicate path\n\t\t$path_dupe_check_stmt = Database::prepare(\"\n\t\t\tSELECT `id`, `path` FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `path`= :path AND `customerid`= :customerid\n\t\t\");\n\t\t$path_dupe_check = Database::pexecute_first($path_dupe_check_stmt, [\n\t\t\t\"path\" => $path,\n\t\t\t\"customerid\" => $customer['customerid']\n\t\t], true, true);\n\n\t\t// duplicate check\n\t\tif ($path_dupe_check && $path_dupe_check['path'] == $path) {\n\t\t\tResponse::standardError('errordocpathdupe', $userpath, true);\n\t\t}\n\n\t\t// insert the entry\n\t\t$stmt = Database::prepare('\n\t\t\tINSERT INTO `' . TABLE_PANEL_HTACCESS . '` SET\n\t\t\t`customerid` = :customerid,\n\t\t\t`path` = :path,\n\t\t\t`options_indexes` = :options_indexes,\n\t\t\t`error404path` = :error404path,\n\t\t\t`error403path` = :error403path,\n\t\t\t`error500path` = :error500path,\n\t\t\t`options_cgi` = :options_cgi\n\t\t');\n\t\t$params = [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"path\" => $path,\n\t\t\t\"options_indexes\" => $options_indexes,\n\t\t\t\"error403path\" => $error403path,\n\t\t\t\"error404path\" => $error404path,\n\t\t\t\"error500path\" => $error500path,\n\t\t\t\"options_cgi\" => $options_cgi\n\t\t];\n\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t$id = Database::lastInsertId();\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added directory-option for '\" . $userpath . \"'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * this functions validates a given value as ErrorDocument\n\t * refs #267\n\t *\n\t * @param string $errdoc\n\t * @param bool $throw_exception\n\t *\n\t * @return string error-document-string\n\t *\n\t */\n\tprivate function correctErrorDocument(string $errdoc, $throw_exception = false)\n\t{\n\t\tif (trim($errdoc) != '') {\n\t\t\t// not a URL\n\t\t\tif ((strtoupper(substr($errdoc, 0, 5)) != 'HTTP:' && strtoupper(substr($errdoc, 0, 6)) != 'HTTPS:') || !Validate::validateUrl($errdoc)) {\n\t\t\t\t// a file\n\t\t\t\tif (substr($errdoc, 0, 1) != '\"') {\n\t\t\t\t\t$errdoc = FileDir::makeCorrectFile($errdoc);\n\t\t\t\t\t// apache needs a starting-slash (starting at the domains-docroot)\n\t\t\t\t\tif (!substr($errdoc, 0, 1) == '/') {\n\t\t\t\t\t\t$errdoc = '/' . $errdoc;\n\t\t\t\t\t}\n\t\t\t\t} elseif (preg_match('/^\"([^\\r\\n\\t\\f\\0\"]+)\"$/', $errdoc)) {\n\t\t\t\t\t// a string (check for ending \")\n\t\t\t\t\t// string won't work for lighty\n\t\t\t\t\tif (Settings::Get('system.webserver') == 'lighttpd') {\n\t\t\t\t\t\tResponse::standardError('stringerrordocumentnotvalidforlighty', '', $throw_exception);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('invaliderrordocumentvalue', '', $throw_exception);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Settings::Get('system.webserver') == 'lighttpd') {\n\t\t\t\t\tResponse::standardError('urlerrordocumentnotvalidforlighty', '', $throw_exception);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn trim($errdoc);\n\t}\n\n\t/**\n\t * return a directory-protection entry by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND `id` = :id\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\t\tWHERE `id` = :id\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['id'] = $id;\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get directory options for '\" . $result['path'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = \"id #\" . $id;\n\t\tthrow new Exception(\"Directory option with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update options for a given directory by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param bool $options_indexes\n\t *            optional, activate directory-listing for this path, default 0 (false)\n\t * @param bool $options_cgi\n\t *            optional, allow Perl/CGI execution, default 0 (false)\n\t * @param string $error404path\n\t *            optional, custom 404 error string/file\n\t * @param string $error403path\n\t *            optional, custom 403 error string/file\n\t * @param string $error500path\n\t *            optional, custom 500 error string/file\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\n\t\t// validation\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// parameters\n\t\t$options_indexes = $this->getBoolParam('options_indexes', true, $result['options_indexes']);\n\t\t$options_cgi = $this->getBoolParam('options_cgi', true, $result['options_cgi']);\n\t\t$error404path = $this->getParam('error404path', true, $result['error404path']);\n\t\t$error403path = $this->getParam('error403path', true, $result['error403path']);\n\t\t$error500path = $this->getParam('error500path', true, $result['error500path']);\n\n\t\tif (!empty($error404path)) {\n\t\t\t$error404path = $this->correctErrorDocument($error404path, true);\n\t\t}\n\n\t\tif (!empty($error403path)) {\n\t\t\t$error403path = $this->correctErrorDocument($error403path, true);\n\t\t}\n\n\t\tif (!empty($error500path)) {\n\t\t\t$error500path = $this->correctErrorDocument($error500path, true);\n\t\t}\n\n\t\tif (($options_indexes != $result['options_indexes']) || ($error404path != $result['error404path']) || ($error403path != $result['error403path']) || ($error500path != $result['error500path']) || ($options_cgi != $result['options_cgi'])) {\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\tSET `options_indexes` = :options_indexes,\n\t\t\t\t`error404path` = :error404path,\n\t\t\t\t`error403path` = :error403path,\n\t\t\t\t`error500path` = :error500path,\n\t\t\t\t`options_cgi` = :options_cgi\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"options_indexes\" => $options_indexes,\n\t\t\t\t\"error403path\" => $error403path,\n\t\t\t\t\"error404path\" => $error404path,\n\t\t\t\t\"error500path\" => $error500path,\n\t\t\t\t\"options_cgi\" => $options_cgi,\n\t\t\t\t\"id\" => $id\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] edited directory options for '\" . str_replace($customer['documentroot'], '/', $result['path']) . \"'\");\n\t\t}\n\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all directory-options, if called from an admin, list all directory-options of all customers you are allowed\n\t * to view, or specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.pathoptions');\n\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list directory-options\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible directory options\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.pathoptions');\n\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_htaccess FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_htaccess']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a directory-options by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get directory-option\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t// do we have to remove the symlink and folder in suexecpath?\n\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t$loginname = $customer_data['loginname'];\n\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($result['path']) . '/');\n\t\t\t$perlsymlink = FileDir::makeCorrectFile($result['path'] . '/cgi-bin');\n\t\t\t// remove symlink\n\t\t\tif (file_exists($perlsymlink)) {\n\t\t\t\tFileDir::safe_exec('rm -f ' . escapeshellarg($perlsymlink));\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_DEBUG, \"[API] deleted suexecworkaround symlink '\" . $perlsymlink . \"'\");\n\t\t\t}\n\t\t\t// remove folder in suexec-path\n\t\t\tif (file_exists($suexecpath)) {\n\t\t\t\tFileDir::safe_exec('rm -rf ' . escapeshellarg($suexecpath));\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_DEBUG, \"[API] deleted suexecworkaround path '\" . $suexecpath . \"'\");\n\t\t\t}\n\t\t}\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid`= :customerid\n\t\t\tAND `id`= :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] deleted directory-option for '\" . str_replace($customer_data['documentroot'], '/', $result['path']) . \"'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\Crypt;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass DirProtections extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add htaccess protection to a given directory\n\t *\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $path\n\t * @param string $username\n\t * @param string $directory_password\n\t * @param string $directory_authname\n\t *            optional name/description for the protection\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// required parameters\n\t\t$path = $this->getParam('path');\n\t\t$username = $this->getParam('username');\n\t\t$password = $this->getParam('directory_password');\n\n\t\t// parameters\n\t\t$authname = $this->getParam('directory_authname', true, '');\n\n\t\t// validation\n\t\t$path = FileDir::makeCorrectDir(Validate::validate($path, 'path', Validate::REGEX_DIR, '', [], true));\n\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);\n\t\t$username = Validate::validate($username, 'username', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_]+\\$?$/', '', [], true);\n\t\t$authname = Validate::validate($authname, 'directory_authname', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_ ]+\\$?$/', '', [], true);\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t// check for duplicate usernames for the path\n\t\t$username_path_check_stmt = Database::prepare(\"\n\t\t\tSELECT `id`, `username`, `path` FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `username`= :username AND `path`= :path AND `customerid`= :customerid\n\t\t\");\n\t\t$params = [\n\t\t\t\"username\" => $username,\n\t\t\t\"path\" => $path,\n\t\t\t\"customerid\" => $customer['customerid']\n\t\t];\n\t\t$username_path_check = Database::pexecute_first($username_path_check_stmt, $params, true, true);\n\n\t\t$password_enc = Crypt::makeCryptPassword($password, true);\n\n\t\t// duplicate check\n\t\tif ($username_path_check && $username_path_check['username'] == $username && $username_path_check['path'] == $path) {\n\t\t\tResponse::standardError('userpathcombinationdupe', '', true);\n\t\t} elseif ($password == $username) {\n\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t}\n\n\t\t// insert the entry\n\t\t$stmt = Database::prepare(\"\n\t\t\tINSERT INTO `\" . TABLE_PANEL_HTPASSWDS . \"` SET\n\t\t\t`customerid` = :customerid,\n\t\t\t`username` = :username,\n\t\t\t`password` = :password,\n\t\t\t`path` = :path,\n\t\t\t`authname` = :authname\n\t\t\");\n\t\t$params = [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"username\" => $username,\n\t\t\t\"password\" => $password_enc,\n\t\t\t\"path\" => $path,\n\t\t\t\"authname\" => $authname\n\t\t];\n\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t$id = Database::lastInsertId();\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added directory-protection for '\" . $username . \" (\" . $path . \")'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * return a directory-protection entry by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\t\tWHERE (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['idun'] = ($id <= 0 ? $username : $id);\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get directory protection for '\" . $result['path'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"username '\" . $username . \"'\");\n\t\tthrow new Exception(\"Directory protection with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update htaccess protection of a given directory\n\t *\n\t * @param int $id\n\t *            optional the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $directory_password\n\t *            optional, leave empty for no change\n\t * @param string $directory_authname\n\t *            optional name/description for the protection\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t// validation\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// parameters\n\t\t$password = $this->getParam('directory_password', true, '');\n\t\t$authname = $this->getParam('directory_authname', true, $result['authname']);\n\n\t\t// get needed customer info\n\t\t$customer = $this->getCustomerData();\n\n\t\t// validation\n\t\t$authname = Validate::validate($authname, 'directory_authname', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_ ]+\\$?$/', '', [], true);\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t$upd_query = \"\";\n\t\t$upd_params = [\n\t\t\t\"id\" => $result['id'],\n\t\t\t\"cid\" => $customer['customerid']\n\t\t];\n\t\tif (!empty($password)) {\n\t\t\tif ($password == $result['username']) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t}\n\t\t\t$password_enc = Crypt::makeCryptPassword($password, true);\n\n\t\t\t$upd_query .= \"`password`= :password_enc\";\n\t\t\t$upd_params['password_enc'] = $password_enc;\n\t\t}\n\t\tif ($authname != $result['authname']) {\n\t\t\tif (!empty($upd_query)) {\n\t\t\t\t$upd_query .= \", \";\n\t\t\t}\n\t\t\t$upd_query .= \"`authname` = :authname\";\n\t\t\t$upd_params['authname'] = $authname;\n\t\t}\n\n\t\t// build update query\n\t\tif (!empty($upd_query)) {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTPASSWDS . \"` SET \" . $upd_query . \" WHERE `id` = :id AND `customerid`= :cid\n\t\t\t\");\n\t\t\tDatabase::pexecute($upd_stmt, $upd_params, true, true);\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t}\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated directory-protection '\" . $result['username'] . \" (\" . $result['path'] . \")'\");\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $result['id']\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all directory-protections, if called from an admin, list all directory-protections of all customers you are\n\t * allowed to view, or specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.directoryprotection');\n\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list directory-protections\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible directory protections\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.directoryprotection');\n\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_htpasswd FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_htpasswd']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a directory-protection by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get directory protection\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_HTPASSWDS . \"` WHERE `customerid`= :customerid\tAND `id`= :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t]);\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted htpasswd for '\" . $result['username'] . \" (\" . $result['path'] . \")'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\Crypt;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\User;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass Ftps extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add a new ftp-user\n\t *\n\t * @param string $ftp_password\n\t *            password for the created database and database-user\n\t * @param string $path\n\t *            destination path relative to the customers-homedir\n\t * @param string $ftp_description\n\t *            optional, description for ftp-user\n\t * @param bool $sendinfomail\n\t *            optional, send created resource-information to customer, default: false\n\t * @param string $shell\n\t *            optional, default /bin/false (not changeable when deactivated)\n\t * @param string $ftp_username\n\t *            optional if customer.ftpatdomain is allowed, specify an username\n\t * @param string $ftp_domain\n\t *            optional if customer.ftpatdomain is allowed, specify a domain (customer must be owner)\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param array $additional_members\n\t *            optional whether to add additional usernames to the group\n\t * @param bool $is_defaultuser\n\t *            optional whether this is the standard default ftp user which is being added so no usage is decreased\n\t * @param bool $login_enabled\n\t *            optional whether to allow login (default) or not\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$is_defaultuser = $this->getBoolParam('is_defaultuser', true, 0);\n\t\t$login_enabled = $this->getBoolParam('login_enabled', true, 1);\n\n\t\tif (($this->getUserDetail('ftps_used') < $this->getUserDetail('ftps') || $this->getUserDetail('ftps') == '-1') || $this->isAdmin() && $is_defaultuser == 1) {\n\t\t\t// required parameters\n\t\t\t$path = $this->getParam('path');\n\t\t\t$password = $this->getParam('ftp_password');\n\n\t\t\t// parameters\n\t\t\t$description = $this->getParam('ftp_description', true, '');\n\t\t\t$sendinfomail = $this->getBoolParam('sendinfomail', true, 0);\n\t\t\t$shell = $this->getParam('shell', true, '/bin/false');\n\n\t\t\t$ftpusername = $this->getParam('ftp_username', true, '');\n\t\t\t$ftpdomain = $this->getParam('ftp_domain', true, '');\n\n\t\t\t$additional_members = $this->getParam('additional_members', true, []);\n\n\t\t\t// validation\n\t\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t\t$password = Crypt::validatePassword($password, true);\n\t\t\t$description = Validate::validate(trim($description), 'description', Validate::REGEX_DESC_TEXT, '', [], true);\n\n\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t$shell = Validate::validate(trim($shell), 'shell', '', '', [], true);\n\t\t\t} else {\n\t\t\t\t$shell = \"/bin/false\";\n\t\t\t}\n\n\t\t\tif (Settings::Get('customer.ftpatdomain') == '1') {\n\t\t\t\t$ftpusername = Validate::validate(trim($ftpusername), 'username', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_]+\\$?$/', '', [], true);\n\t\t\t\tif (substr($ftpdomain, 0, 4) != 'xn--') {\n\t\t\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t\t\t$ftpdomain = $idna_convert->encode(Validate::validate($ftpdomain, 'domain', '', '', [], true));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$params = [];\n\t\t\t// get needed customer info to reduce the ftp-user-counter by one\n\t\t\tif ($is_defaultuser) {\n\t\t\t\t// no resource check for default user\n\t\t\t\t$customer = $this->getCustomerData();\n\t\t\t} else {\n\t\t\t\t$customer = $this->getCustomerData('ftps');\n\t\t\t}\n\n\t\t\tif ($sendinfomail != 1) {\n\t\t\t\t$sendinfomail = 0;\n\t\t\t}\n\n\t\t\tif (Settings::Get('customer.ftpatdomain') == '1' && !$is_defaultuser) {\n\t\t\t\tif ($ftpusername == '') {\n\t\t\t\t\tResponse::standardError([\n\t\t\t\t\t\t'stringisempty',\n\t\t\t\t\t\t'username'\n\t\t\t\t\t], '', true);\n\t\t\t\t}\n\t\t\t\t$ftpdomain_check_stmt = Database::prepare(\"SELECT `id`, `domain`, `customerid` FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\t\tWHERE `domain` = :domain\n\t\t\t\t\t\tAND `customerid` = :customerid\");\n\t\t\t\t$ftpdomain_check = Database::pexecute_first($ftpdomain_check_stmt, [\n\t\t\t\t\t\"domain\" => $ftpdomain,\n\t\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t\t], true, true);\n\n\t\t\t\tif ($ftpdomain_check && $ftpdomain_check['domain'] != $ftpdomain) {\n\t\t\t\t\tResponse::standardError('maindomainnonexist', $ftpdomain, true);\n\t\t\t\t}\n\t\t\t\t$username = $ftpusername . \"@\" . $ftpdomain;\n\t\t\t} else {\n\t\t\t\tif ($is_defaultuser) {\n\t\t\t\t\t$username = $customer['loginname'];\n\t\t\t\t} else {\n\t\t\t\t\t$username = $customer['loginname'] . Settings::Get('customer.ftpprefix') . (intval($customer['ftp_lastaccountnumber']) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$username_check_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\tWHERE `username` = :username\n\t\t\t\");\n\t\t\t$username_check = Database::pexecute_first($username_check_stmt, [\n\t\t\t\t\"username\" => $username\n\t\t\t], true, true);\n\n\t\t\tif (!empty($username_check) && $username_check['username'] = $username) {\n\t\t\t\tResponse::standardError('usernamealreadyexists', $username, true);\n\t\t\t} elseif ($username == $password) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t} else {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);\n\t\t\t\t$cryptPassword = Crypt::makeCryptPassword($password, false, true);\n\n\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\t\t(`customerid`, `username`, `description`, `password`, `homedir`, `login_enabled`, `uid`, `gid`, `shell`)\n\t\t\t\t\t\tVALUES (:customerid, :username, :description, :password, :homedir, :loginenabled, :guid, :guid, :shell)\");\n\t\t\t\t$params = [\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"username\" => $username,\n\t\t\t\t\t\"description\" => $description,\n\t\t\t\t\t\"password\" => $cryptPassword,\n\t\t\t\t\t\"homedir\" => $path,\n\t\t\t\t\t\"loginenabled\" => $login_enabled ? 'Y' : 'N',\n\t\t\t\t\t\"guid\" => $customer['guid'],\n\t\t\t\t\t\"shell\" => $shell\n\t\t\t\t];\n\t\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `bytes_in_used` FROM `\" . TABLE_FTP_QUOTATALLIES . \"` WHERE `name` = :name\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($result_stmt, [\n\t\t\t\t\t\"name\" => $customer['loginname']\n\t\t\t\t], true, true);\n\n\t\t\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_QUOTATALLIES . \"`\n\t\t\t\t\t\t(`name`, `quota_type`, `bytes_in_used`, `bytes_out_used`, `bytes_xfer_used`, `files_in_used`, `files_out_used`, `files_xfer_used`)\n\t\t\t\t\t\tVALUES (:name, 'user', :bytes_in_used, '0', '0', '0', '0', '0')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\t\"name\" => $username,\n\t\t\t\t\t\t\"bytes_in_used\" => $row['bytes_in_used']\n\t\t\t\t\t], true, true);\n\t\t\t\t}\n\n\t\t\t\t// create quotatallies entry if it not exists, refs #885\n\t\t\t\tif ($result_stmt->rowCount() == 0) {\n\t\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_QUOTATALLIES . \"`\n\t\t\t\t\t\t(`name`, `quota_type`, `bytes_in_used`, `bytes_out_used`, `bytes_xfer_used`, `files_in_used`, `files_out_used`, `files_xfer_used`)\n\t\t\t\t\t\tVALUES (:name, 'user', '0', '0', '0', '0', '0', '0')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\t\"name\" => $username\n\t\t\t\t\t], true, true);\n\t\t\t\t}\n\n\t\t\t\t$group_upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_FTP_GROUPS . \"`\n\t\t\t\t\tSET `members` = CONCAT_WS(',',`members`, :username)\n\t\t\t\t\tWHERE `customerid`= :customerid AND `gid`= :guid\n\t\t\t\t\");\n\t\t\t\t$params = [\n\t\t\t\t\t\"username\" => $username,\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"guid\" => $customer['guid']\n\t\t\t\t];\n\n\t\t\t\tif ($is_defaultuser) {\n\t\t\t\t\t// add the new group\n\t\t\t\t\t$group_ins_stmt = Database::prepare(\"\n\t\t\t\t\t\tINSERT INTO `\" . TABLE_FTP_GROUPS . \"`\n\t\t\t\t\t\tSET `customerid`= :customerid, `gid`= :guid, `groupname` = :username, `members` = :username\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($group_ins_stmt, $params, true, true);\n\t\t\t\t} else {\n\t\t\t\t\t// just update\n\t\t\t\t\tDatabase::pexecute($group_upd_stmt, $params, true, true);\n\t\t\t\t}\n\n\t\t\t\tif (count($additional_members) > 0) {\n\t\t\t\t\tforeach ($additional_members as $add_member) {\n\t\t\t\t\t\t$params = [\n\t\t\t\t\t\t\t\"username\" => $add_member,\n\t\t\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\t\t\"guid\" => $customer['guid']\n\t\t\t\t\t\t];\n\t\t\t\t\t\tDatabase::pexecute($group_upd_stmt, $params, true, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$is_defaultuser) {\n\t\t\t\t\t// update customer usage\n\t\t\t\t\tCustomers::increaseUsage($customer['customerid'], 'ftps_used');\n\t\t\t\t\tCustomers::increaseUsage($customer['customerid'], 'ftp_lastaccountnumber');\n\t\t\t\t}\n\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added ftp-account '\" . $username . \" (\" . $path . \")'\");\n\t\t\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\n\t\t\t\tif ($sendinfomail == 1) {\n\t\t\t\t\t$replace_arr = [\n\t\t\t\t\t\t'SALUTATION' => User::getCorrectUserSalutation($customer),\n\t\t\t\t\t\t'CUST_NAME' => User::getCorrectUserSalutation($customer),\n\t\t\t\t\t\t// < keep this for compatibility\n\t\t\t\t\t\t'NAME' => $customer['name'],\n\t\t\t\t\t\t'FIRSTNAME' => $customer['firstname'],\n\t\t\t\t\t\t'COMPANY' => $customer['company'],\n\t\t\t\t\t\t'USERNAME' => $customer['loginname'],\n\t\t\t\t\t\t'CUSTOMER_NO' => $customer['customernumber'],\n\t\t\t\t\t\t'USR_NAME' => $username,\n\t\t\t\t\t\t'USR_PASS' => htmlentities(htmlentities($password)),\n\t\t\t\t\t\t'USR_PATH' => FileDir::makeCorrectDir(str_replace($customer['documentroot'], \"/\", $path))\n\t\t\t\t\t];\n\t\t\t\t\t// get template for mail subject\n\t\t\t\t\t$mail_subject = $this->getMailTemplate($customer, 'mails', 'new_ftpaccount_by_customer_subject', $replace_arr, lng('mails.new_ftpaccount_by_customer.subject'));\n\t\t\t\t\t// get template for mail body\n\t\t\t\t\t$mail_body = $this->getMailTemplate($customer, 'mails', 'new_ftpaccount_by_customer_mailbody', $replace_arr, lng('mails.new_ftpaccount_by_customer.mailbody'));\n\n\t\t\t\t\t$_mailerror = false;\n\t\t\t\t\t$mailerr_msg = \"\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$this->mailer()->Subject = $mail_subject;\n\t\t\t\t\t\t$this->mailer()->AltBody = $mail_body;\n\t\t\t\t\t\t$this->mailer()->msgHTML(str_replace(\"\\n\", \"<br />\", $mail_body));\n\t\t\t\t\t\t$this->mailer()->addAddress($customer['email'], User::getCorrectUserSalutation($customer));\n\t\t\t\t\t\t$this->mailer()->send();\n\t\t\t\t\t} catch (\\PHPMailer\\PHPMailer\\Exception $e) {\n\t\t\t\t\t\t$mailerr_msg = $e->errorMessage();\n\t\t\t\t\t\t$_mailerror = true;\n\t\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\t\t$mailerr_msg = $e->getMessage();\n\t\t\t\t\t\t$_mailerror = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($_mailerror) {\n\t\t\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_ERR, \"[API] Error sending mail: \" . $mailerr_msg);\n\t\t\t\t\t\tResponse::standardError('errorsendingmail', $customer['email'], true);\n\t\t\t\t\t}\n\n\t\t\t\t\t$this->mailer()->clearAddresses();\n\t\t\t\t}\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added ftp-user '\" . $username . \"'\");\n\n\t\t\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t\t\t'username' => $username\n\t\t\t\t]);\n\t\t\t\treturn $this->response($result);\n\t\t\t}\n\t\t}\n\t\tthrow new Exception(\"No more resources available\", 406);\n\t}\n\n\t/**\n\t * return a ftp-user entry by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the customer-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tWHERE (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['idun'] = ($id <= 0 ? $username : $id);\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get ftp-user '\" . $result['username'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"username '\" . $username . \"'\");\n\t\tthrow new Exception(\"FTP user with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update a given ftp-user by id or username\n\t *\n\t * @param int $id\n\t *            optional, the ftp-user-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param string $ftp_password\n\t *            optional, update password if specified\n\t * @param string $path\n\t *            destination path relative to the customers-homedir\n\t * @param string $ftp_description\n\t *            optional, description for ftp-user\n\t * @param string $shell\n\t *            optional, default /bin/false (not changeable when deactivated)\n\t * @param bool $login_enabled\n\t *            optional whether to allow login (default) or not\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// parameters\n\t\t$path = $this->getParam('path', true, '');\n\t\t$password = $this->getParam('ftp_password', true, '');\n\t\t$description = $this->getParam('ftp_description', true, $result['description']);\n\t\t$shell = $this->getParam('shell', true, $result['shell']);\n\t\t$login_enabled = $this->getBoolParam('login_enabled', true, ($result['login_enabled'] == 'Y' ? 1 : 0));\n\n\t\t// validation\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$description = Validate::validate(trim($description), 'description', Validate::REGEX_DESC_TEXT, '', [], true);\n\n\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t$shell = Validate::validate(trim($shell), 'shell', '', '', [], true);\n\t\t} else {\n\t\t\t$shell = \"/bin/false\";\n\t\t}\n\n\t\tif ($login_enabled != 1) {\n\t\t\t$login_enabled = 0;\n\t\t}\n\n\t\t// get needed customer info to reduce the ftp-user-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// password update?\n\t\tif ($password != '') {\n\t\t\t// validate password\n\t\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t\tif ($password == $result['username']) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t}\n\t\t\t$cryptPassword = Crypt::makeCryptPassword($password, false, true);\n\n\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tSET `password` = :password\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"id\" => $id,\n\t\t\t\t\"password\" => $cryptPassword\n\t\t\t], true, true);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-account password for '\" . $result['username'] . \"'\");\n\t\t}\n\n\t\t// path update?\n\t\tif ($path != '') {\n\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);\n\n\t\t\tif ($path != $result['homedir']) {\n\t\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tSET `homedir` = :homedir\n\t\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\t\tAND `id` = :id\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\"homedir\" => $path,\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"id\" => $id\n\t\t\t\t], true, true);\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-account homdir for '\" . $result['username'] . \"'\");\n\t\t\t}\n\t\t}\n\t\t// it's the task for \"new ftp\" but that will\n\t\t// create all directories and correct their permissions\n\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\n\t\t$stmt = Database::prepare(\"\n\t\t\tUPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\tSET `description` = :desc, `shell` = :shell, `login_enabled` = :loginenabled\n\t\t\tWHERE `customerid` = :customerid\n\t\t\tAND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"desc\" => $description,\n\t\t\t\"shell\" => $shell,\n\t\t\t\"loginenabled\" => $login_enabled ? 'Y' : 'N',\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'username' => $result['username']\n\t\t]);\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-user '\" . $result['username'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all ftp-users, if called from an admin, list all ftp-users of all customers you are allowed to view, or\n\t * specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select ftp-users of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select ftp-users of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\t$customer_ids = $this->getAllowedCustomerIds('ftp');\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list ftp-users\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible ftp accounts\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select ftp-users of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select ftp-users of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\t$customer_ids = $this->getAllowedCustomerIds('ftp');\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_ftps FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_ftps']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a ftp-user by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the ftp-user-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param bool $delete_userfiles\n\t *            optional, default false\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\t\t$delete_userfiles = $this->getBoolParam('delete_userfiles', true, 0);\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get ftp-user\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t// add usage of this ftp-user to main-ftp user of customer if different\n\t\tif ($result['username'] != $customer_data['loginname']) {\n\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tSET `up_count` = `up_count` + :up_count,\n\t\t\t\t`up_bytes` = `up_bytes` + :up_bytes,\n\t\t\t\t`down_count` = `down_count` + :down_count,\n\t\t\t\t`down_bytes` = `down_bytes` + :down_bytes\n\t\t\t\tWHERE `username` = :username\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"up_count\" => $result['up_count'],\n\t\t\t\t\"up_bytes\" => $result['up_bytes'],\n\t\t\t\t\"down_count\" => $result['down_count'],\n\t\t\t\t\"down_bytes\" => $result['down_bytes'],\n\t\t\t\t\"username\" => $customer_data['loginname']\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t} else {\n\t\t\t// do not allow removing default ftp-account\n\t\t\tResponse::standardError('ftp_cantdeletemainaccount', '', true);\n\t\t}\n\n\t\t// remove all quotatallies\n\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_FTP_QUOTATALLIES . \"` WHERE `name` = :name\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"name\" => $result['username']\n\t\t], true, true);\n\n\t\t// remove user itself\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_FTP_USERS . \"` WHERE `customerid` = :customerid AND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t// update ftp-groups\n\t\t$stmt = Database::prepare(\"\n\t\t\tUPDATE `\" . TABLE_FTP_GROUPS . \"` SET\n\t\t\t`members` = REPLACE(`members`, :username,'')\n\t\t\tWHERE `customerid` = :customerid\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"username\" => \",\" . $result['username'],\n\t\t\t\"customerid\" => $customer_data['customerid']\n\t\t], true, true);\n\n\t\t// refs #293\n\t\tif ($delete_userfiles == 1) {\n\t\t\tCronjob::inserttask(TaskId::DELETE_FTP_DATA, $customer_data['loginname'], $result['homedir']);\n\t\t} else {\n\t\t\tif (Settings::Get('system.nssextrausers') == 1) {\n\t\t\t\t// this is used so that the libnss-extrausers cron is fired\n\t\t\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\t\t\t}\n\t\t}\n\n\t\t// decrease ftp-user usage for customer\n\t\t$resetaccnumber = ($customer_data['ftps_used'] == '1') ? \" , `ftp_lastaccountnumber`='0'\" : '';\n\t\tCustomers::decreaseUsage($customer_data['customerid'], 'ftps_used', $resetaccnumber);\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted ftp-user '\" . $result['username'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Domain\\Domain;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass SubDomains extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add a new subdomain\n\t *\n\t * @param string $subdomain\n\t *            part before domain.tld to create as subdomain\n\t * @param string $domain\n\t *            domainname of main-domain\n\t * @param int $alias\n\t *            optional, domain-id of a domain that the new domain should be an alias of\n\t * @param string $path\n\t *            optional, destination path relative to the customers-homedir, default is customers-homedir\n\t * @param string $url\n\t *            optional, overwrites path value with an URL to generate a redirect, alternatively use the path\n\t *            parameter also for URLs\n\t * @param int $openbasedir_path\n\t *            optional, either 0 for domains-docroot [default], 1 for customers-homedir or 2 for parent-directory of domains-docroot\n\t * @param int $phpsettingid\n\t *            optional, php-settings-id, if empty the $domain value is used\n\t * @param int $redirectcode\n\t *            optional, redirect-code-id from TABLE_PANEL_REDIRECTCODES\n\t * @param int $speciallogfile\n\t *            optional, whether to create an exclusive web-logfile for this domain (1) or not (0) or inherit value from parentdomain (2, default)\n\t * @param bool $sslenabled\n\t *            optional, whether or not SSL is enabled for this domain, regardless of the assigned ssl-ips, default\n\t *            1 (true)\n\t * @param bool $ssl_redirect\n\t *            optional, whether to generate a https-redirect or not, default false; requires SSL to be enabled\n\t * @param bool $letsencrypt\n\t *            optional, whether to generate a Let's Encrypt certificate for this domain, default false; requires\n\t *            SSL to be enabled\n\t * @param bool $http2\n\t *            optional, whether to enable http/2 for this subdomain (requires to be enabled in the settings),\n\t *            default 0 (false)\n\t * @param int $hsts_maxage\n\t *            optional max-age value for HSTS header, default 0\n\t * @param bool $hsts_sub\n\t *            optional whether or not to add subdomains to the HSTS header, default 0\n\t * @param bool $hsts_preload\n\t *            optional whether or not to preload HSTS header value, default 0\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif (($this->getUserDetail('subdomains_used') < $this->getUserDetail('subdomains') || $this->getUserDetail('subdomains') == '-1') || $this->isAdmin()) {\n\t\t\t// parameters\n\t\t\t$subdomain = $this->getParam('subdomain');\n\t\t\t$domain = $this->getParam('domain');\n\n\t\t\t// optional parameters\n\t\t\t$aliasdomain = $this->getParam('alias', true, 0);\n\t\t\t$path = $this->getParam('path', true, '');\n\t\t\t$url = $this->getParam('url', true, '');\n\t\t\t$openbasedir_path = $this->getParam('openbasedir_path', true, 0);\n\t\t\t$phpsettingid = $this->getParam('phpsettingid', true, 0);\n\t\t\t$redirectcode = $this->getParam('redirectcode', true, Settings::Get('customredirect.default'));\n\t\t\t$speciallogfile = intval($this->getParam('speciallogfile', true, 2));\n\t\t\t$isemaildomain = $this->getParam('isemaildomain', true, 0);\n\t\t\tif (Settings::Get('system.use_ssl')) {\n\t\t\t\t$sslenabled = $this->getBoolParam('sslenabled', true, 1);\n\t\t\t\t$ssl_redirect = $this->getBoolParam('ssl_redirect', true, 0);\n\t\t\t\t$letsencrypt = $this->getBoolParam('letsencrypt', true, 0);\n\t\t\t\t$http2 = $this->getBoolParam('http2', true, 0);\n\t\t\t\t$hsts_maxage = $this->getParam('hsts_maxage', true, 0);\n\t\t\t\t$hsts_sub = $this->getBoolParam('hsts_sub', true, 0);\n\t\t\t\t$hsts_preload = $this->getBoolParam('hsts_preload', true, 0);\n\t\t\t} else {\n\t\t\t\t$sslenabled = 0;\n\t\t\t\t$ssl_redirect = 0;\n\t\t\t\t$letsencrypt = 0;\n\t\t\t\t$http2 = 0;\n\t\t\t\t$hsts_maxage = 0;\n\t\t\t\t$hsts_sub = 0;\n\t\t\t\t$hsts_preload = 0;\n\t\t\t}\n\n\t\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t\t$customer = $this->getCustomerData('subdomains');\n\n\t\t\t// validation\n\t\t\t$subdomain = strtolower($subdomain);\n\t\t\tif (substr($subdomain, 0, 4) == 'xn--') {\n\t\t\t\tResponse::standardError('domain_nopunycode', '', true);\n\t\t\t}\n\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$subdomain = $idna_convert->encode(preg_replace([\n\t\t\t\t'/\\:(\\d)+$/',\n\t\t\t\t'/^https?\\:\\/\\//'\n\t\t\t], '', Validate::validate($subdomain, 'subdomain', '', 'subdomainiswrong', [], true)));\n\n\t\t\t// merge the two parts together\n\t\t\t$completedomain = $subdomain . '.' . $domain;\n\n\t\t\tif (Settings::Get('system.validate_domain') && !Validate::validateDomain($completedomain)) {\n\t\t\t\tResponse::standardError([\n\t\t\t\t\t'stringiswrong',\n\t\t\t\t\t'mydomain'\n\t\t\t\t], '', true);\n\t\t\t}\n\t\t\tif ($completedomain == strtolower(Settings::Get('system.hostname'))) {\n\t\t\t\tResponse::standardError('admin_domain_emailsystemhostname', '', true);\n\t\t\t}\n\n\t\t\t// check whether the domain already exists\n\t\t\t$completedomain_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\tWHERE `domain` = :domain\n\t\t\t\tAND `customerid` = :customerid\n\t\t\t\tAND `email_only` = '0'\n\t\t\t\tAND `caneditdomain` = '1'\n\t\t\t\");\n\t\t\t$completedomain_check = Database::pexecute_first($completedomain_stmt, [\n\t\t\t\t\"domain\" => $completedomain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\n\t\t\tif ($completedomain_check) {\n\t\t\t\t// no exception so far - domain exists\n\t\t\t\tResponse::standardError('domainexistalready', $completedomain, true);\n\t\t\t}\n\n\t\t\t// alias domain checked?\n\t\t\tif ($aliasdomain != 0) {\n\t\t\t\t// also check ip/port combination to be the same, #176\n\t\t\t\t$aliasdomain_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `d`.`id` FROM `\" . TABLE_PANEL_DOMAINS . \"` `d` , `\" . TABLE_PANEL_CUSTOMERS . \"` `c` , `\" . TABLE_DOMAINTOIP . \"` `dip`\n\t\t\t\t\tWHERE `d`.`aliasdomain` IS NULL\n\t\t\t\t\tAND `d`.`id` = :id\n\t\t\t\t\tAND `c`.`standardsubdomain` <> `d`.`id`\n\t\t\t\t\tAND `d`.`customerid` = :customerid\n\t\t\t\t\tAND `c`.`customerid` = `d`.`customerid`\n\t\t\t\t\tAND `d`.`id` = `dip`.`id_domain`\n\t\t\t\t\tAND `dip`.`id_ipandports`\n\t\t\t\t\tIN (SELECT `id_ipandports` FROM `\" . TABLE_DOMAINTOIP . \"` WHERE `id_domain` = :id )\n\t\t\t\t\tGROUP BY `d`.`domain`\n\t\t\t\t\tORDER BY `d`.`domain` ASC\n\t\t\t\t\");\n\t\t\t\t$aliasdomain_check = Database::pexecute_first($aliasdomain_stmt, [\n\t\t\t\t\t\"id\" => $aliasdomain,\n\t\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t\t], true, true);\n\t\t\t\tif ($aliasdomain_check['id'] != $aliasdomain) {\n\t\t\t\t\tResponse::standardError('domainisaliasorothercustomer', '', true);\n\t\t\t\t}\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t}\n\n\t\t\t// validate / correct path/url of domain\n\t\t\t$_doredirect = false;\n\t\t\t$path = $this->validateDomainDocumentRoot($path, $url, $customer, $completedomain, $_doredirect);\n\n\t\t\tif ($openbasedir_path > 2 && $openbasedir_path < 0) {\n\t\t\t\t$openbasedir_path = 0;\n\t\t\t}\n\n\t\t\t// get main domain for various checks\n\t\t\t$domain_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\tWHERE `domain` = :domain\n\t\t\t\tAND `customerid` = :customerid\n\t\t\t\tAND `parentdomainid` = '0'\n\t\t\t\tAND `email_only` = '0'\n\t\t\t\tAND `caneditdomain` = '1'\n\t\t\t\");\n\t\t\t$domain_check = Database::pexecute_first($domain_stmt, [\n\t\t\t\t\"domain\" => $domain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\n\t\t\tif (!$domain_check) {\n\t\t\t\t// the given main-domain\n\t\t\t\tResponse::standardError('maindomainnonexist', $domain, true);\n\t\t\t} elseif ($subdomain == 'www' && $domain_check['wwwserveralias'] == '1') {\n\t\t\t\t// you cannot add 'www' as subdomain when the maindomain generates a www-alias\n\t\t\t\tResponse::standardError('wwwnotallowed', '', true);\n\t\t\t} elseif ($completedomain_check && strtolower($completedomain_check['domain']) == strtolower($completedomain)) {\n\t\t\t\t// the domain does already exist as main-domain\n\t\t\t\tResponse::standardError('domainexistalready', $completedomain, true);\n\t\t\t} elseif ((int)$domain_check['deactivated'] == 1) {\n\t\t\t\t// main domain is deactivated\n\t\t\t\tResponse::standardError('maindomaindeactivated', $domain, true);\n\t\t\t}\n\n\t\t\t// if allowed, check for 'is email domain'-flag\n\t\t\tif ($domain_check['subcanemaildomain'] == '1' || $domain_check['subcanemaildomain'] == '2') {\n\t\t\t\t$isemaildomain = intval($isemaildomain);\n\t\t\t} else {\n\t\t\t\t$isemaildomain = $domain_check['subcanemaildomain'] == '3' ? 1 : 0;\n\t\t\t}\n\n\t\t\tif ($ssl_redirect != 0) {\n\t\t\t\t// a ssl-redirect only works if there actually is a\n\t\t\t\t// ssl ip/port assigned to the domain\n\t\t\t\tif (Domain::domainHasSslIpPort($domain_check['id']) == true) {\n\t\t\t\t\t$ssl_redirect = '1';\n\t\t\t\t\t$_doredirect = true;\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('sslredirectonlypossiblewithsslipport', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($letsencrypt != 0) {\n\t\t\t\t// let's encrypt only works if there actually is a\n\t\t\t\t// ssl ip/port assigned to the domain\n\t\t\t\tif (Domain::domainHasSslIpPort($domain_check['id']) == true) {\n\t\t\t\t\t$letsencrypt = '1';\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('letsencryptonlypossiblewithsslipport', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// validate dns if lets encrypt is enabled to check whether we can use it at all\n\t\t\tif ($letsencrypt == '1' && Settings::Get('system.le_domain_dnscheck') == '1') {\n\t\t\t\t$our_ips = Domain::getIpsOfDomain($domain_check['id']);\n\t\t\t\t$domain_ips = PhpHelper::gethostbynamel6($completedomain, true, Settings::Get('system.le_domain_dnscheck_resolver'));\n\t\t\t\tif ($domain_ips == false || count(array_intersect($our_ips, $domain_ips)) <= 0) {\n\t\t\t\t\tResponse::standardError('invaliddnsforletsencrypt', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Temporarily deactivate ssl_redirect until Let's Encrypt certificate was generated\n\t\t\tif ($ssl_redirect > 0 && $letsencrypt == 1) {\n\t\t\t\t$ssl_redirect = 2;\n\t\t\t}\n\n\t\t\t// validate speciallogfile value\n\t\t\tif ($speciallogfile < 0 || $speciallogfile > 2) {\n\t\t\t\t$speciallogfile = 2; // inherit from parent-domain\n\t\t\t}\n\n\t\t\t// get the phpsettingid from parentdomain, #107\n\t\t\t$phpsid_stmt = Database::prepare(\"\n\t\t\t\tSELECT `phpsettingid` FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `id` = :id\n\t\t\t\");\n\t\t\t$phpsid_result = Database::pexecute_first($phpsid_stmt, [\n\t\t\t\t\"id\" => $domain_check['id']\n\t\t\t], true, true);\n\n\t\t\tif (!isset($phpsid_result['phpsettingid']) || (int)$phpsid_result['phpsettingid'] <= 0) {\n\t\t\t\t// assign default config\n\t\t\t\t$phpsid_result['phpsettingid'] = 1;\n\t\t\t}\n\t\t\t// check whether the customer has chosen its own php-config\n\t\t\tif ($phpsettingid > 0 && $phpsettingid != $phpsid_result['phpsettingid']) {\n\t\t\t\t$phpsid_result['phpsettingid'] = intval($phpsettingid);\n\t\t\t}\n\n\t\t\t$allowed_phpconfigs = $customer['allowed_phpconfigs'];\n\t\t\tif (!empty($allowed_phpconfigs)) {\n\t\t\t\t$allowed_phpconfigs = json_decode($allowed_phpconfigs, true);\n\t\t\t} else {\n\t\t\t\t$allowed_phpconfigs = [];\n\t\t\t}\n\t\t\t// only with fcgid/fpm enabled will it be possible to select a php-setting\n\t\t\tif ((int)Settings::Get('system.mod_fcgid') == 1 || (int)Settings::Get('phpfpm.enabled') == 1) {\n\t\t\t\tif (!in_array($phpsid_result['phpsettingid'], $allowed_phpconfigs)) {\n\t\t\t\t\tResponse::standardError('notallowedphpconfigused', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// actually insert domain\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tINSERT INTO `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t`customerid` = :customerid,\n\t\t\t\t`adminid` = :adminid,\n\t\t\t\t`domain` = :domain,\n\t\t\t\t`domain_ace` = :domain_ace,\n\t\t\t\t`documentroot` = :documentroot,\n\t\t\t\t`aliasdomain` = :aliasdomain,\n\t\t\t\t`parentdomainid` = :parentdomainid,\n\t\t\t\t`wwwserveralias` = :wwwserveralias,\n\t\t\t\t`isemaildomain` = :isemaildomain,\n\t\t\t\t`iswildcarddomain` = :iswildcarddomain,\n\t\t\t\t`phpenabled` = :phpenabled,\n\t\t\t\t`openbasedir` = :openbasedir,\n\t\t\t\t`openbasedir_path` = :openbasedir_path,\n\t\t\t\t`speciallogfile` = :speciallogfile,\n\t\t\t\t`specialsettings` = :specialsettings,\n\t\t\t\t`ssl_specialsettings` = :ssl_specialsettings,\n\t\t\t\t`include_specialsettings` = :include_specialsettings,\n\t\t\t\t`ssl_redirect` = :ssl_redirect,\n\t\t\t\t`phpsettingid` = :phpsettingid,\n\t\t\t\t`letsencrypt` = :letsencrypt,\n\t\t\t\t`http2` = :http2,\n\t\t\t\t`hsts` = :hsts,\n\t\t\t\t`hsts_sub` = :hsts_sub,\n\t\t\t\t`hsts_preload` = :hsts_preload,\n\t\t\t\t`ocsp_stapling` = :ocsp_stapling,\n\t\t\t\t`override_tls` = :override_tls,\n\t\t\t\t`ssl_protocols` = :ssl_protocols,\n\t\t\t\t`ssl_cipher_list` = :ssl_cipher_list,\n\t\t\t\t`tlsv13_cipher_list` = :tlsv13_cipher_list,\n\t\t\t\t`ssl_enabled` = :sslenabled\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"adminid\" => $customer['adminid'],\n\t\t\t\t\"domain\" => $completedomain,\n\t\t\t\t\"domain_ace\" => $idna_convert->decode($completedomain),\n\t\t\t\t\"documentroot\" => $path,\n\t\t\t\t\"aliasdomain\" => $aliasdomain != 0 ? $aliasdomain : null,\n\t\t\t\t\"parentdomainid\" => $domain_check['id'],\n\t\t\t\t\"wwwserveralias\" => $domain_check['wwwserveralias'] == '1' ? '1' : '0',\n\t\t\t\t\"iswildcarddomain\" => $domain_check['iswildcarddomain'] == '1' ? '1' : '0',\n\t\t\t\t\"isemaildomain\" => $isemaildomain,\n\t\t\t\t\"openbasedir\" => $domain_check['openbasedir'],\n\t\t\t\t\"openbasedir_path\" => $openbasedir_path,\n\t\t\t\t\"phpenabled\" => $domain_check['phpenabled'],\n\t\t\t\t\"speciallogfile\" => $speciallogfile == 2 ? $domain_check['speciallogfile'] : $speciallogfile,\n\t\t\t\t\"specialsettings\" => $domain_check['specialsettings'],\n\t\t\t\t\"ssl_specialsettings\" => $domain_check['ssl_specialsettings'],\n\t\t\t\t\"include_specialsettings\" => $domain_check['include_specialsettings'],\n\t\t\t\t\"ssl_redirect\" => $ssl_redirect,\n\t\t\t\t\"phpsettingid\" => $phpsid_result['phpsettingid'],\n\t\t\t\t\"letsencrypt\" => $letsencrypt,\n\t\t\t\t\"http2\" => $http2,\n\t\t\t\t\"hsts\" => $hsts_maxage,\n\t\t\t\t\"hsts_sub\" => $hsts_sub,\n\t\t\t\t\"hsts_preload\" => $hsts_preload,\n\t\t\t\t\"ocsp_stapling\" => $domain_check['ocsp_stapling'],\n\t\t\t\t\"override_tls\" => $domain_check['override_tls'],\n\t\t\t\t\"ssl_protocols\" => $domain_check['ssl_protocols'],\n\t\t\t\t\"ssl_cipher_list\" => $domain_check['ssl_cipher_list'],\n\t\t\t\t\"tlsv13_cipher_list\" => $domain_check['tlsv13_cipher_list'],\n\t\t\t\t\"sslenabled\" => $sslenabled\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$subdomain_id = Database::lastInsertId();\n\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tINSERT INTO `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\t(`id_domain`, `id_ipandports`)\n\t\t\t\tSELECT LAST_INSERT_ID(), `id_ipandports`\n\t\t\t\tFROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\tWHERE `id_domain` = :id_domain\n\t\t\t\");\n\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\"id_domain\" => $domain_check['id']\n\t\t\t]);\n\n\t\t\tif ($_doredirect) {\n\t\t\t\tDomain::addRedirectToDomain($subdomain_id, $redirectcode);\n\t\t\t}\n\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\t// Using nameserver, insert a task which rebuilds the server config\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\n\t\t\tCustomers::increaseUsage($customer['customerid'], 'subdomains_used');\n\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] added subdomain '\" . $completedomain . \"'\");\n\n\t\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t\t'id' => $subdomain_id\n\t\t\t]);\n\t\t\treturn $this->response($result);\n\t\t}\n\t\tthrow new Exception(\"No more resources available\", 406);\n\t}\n\n\t/**\n\t * return a subdomain entry by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param bool $with_ips\n\t *            optional, default true\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\t\t$with_ips = $this->getParam('with_ips', true, true);\n\n\t\t// convert possible idn domain to punycode\n\t\tif (substr($domainname, 0, 4) != 'xn--') {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$domainname = $idna_convert->encode($domainname);\n\t\t}\n\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') != 1) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\tif (count($customer_ids) > 0) {\n\t\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\t\t\tWHERE \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \" AND d.`customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\t\t\");\n\t\t\t\t\t$params = [\n\t\t\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"You do not have any customers yet\", 406);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\t\tWHERE \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \"\n\t\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\t\");\n\t\t\t\t$params = [\n\t\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t\t];\n\t\t\t}\n\t\t} else {\n\t\t\tif (!$this->isInternal() && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\tWHERE d.`customerid`= :customerid AND \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \"\n\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t'customerid' => $this->getUserDetail('customerid'),\n\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t];\n\t\t}\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$result['ipsandports'] = [];\n\t\t\tif ($with_ips) {\n\t\t\t\t$result['ipsandports'] = $this->getIpsForDomain($result['id']);\n\t\t\t}\n\t\t\t$result['domain_hascert'] = $this->getHasCertValueForDomain((int)$result['id'], (int)$result['parentdomainid']);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get subdomain '\" . $result['domain'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"domainname '\" . $domainname . \"'\");\n\t\tthrow new Exception(\"Subdomain with \" . $key . \" could not be found\", 404);\n\t}\n\n\tprivate function getHasCertValueForDomain(int $domainid, int $parentdomainid): int\n\t{\n\t\t// nothing (ssl_global)\n\t\t$domain_hascert = 0;\n\t\t$ssl_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :domainid\");\n\t\tDatabase::pexecute($ssl_stmt, array(\n\t\t\t\"domainid\" => $domainid\n\t\t));\n\t\t$ssl_result = $ssl_stmt->fetch(PDO::FETCH_ASSOC);\n\t\tif (is_array($ssl_result) && isset($ssl_result['ssl_cert_file']) && $ssl_result['ssl_cert_file'] != '') {\n\t\t\t// own certificate (ssl_customer_green)\n\t\t\t$domain_hascert = 1;\n\t\t} else {\n\t\t\t// check if it's parent has one set (shared)\n\t\t\tif ($parentdomainid != 0) {\n\t\t\t\t$ssl_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :domainid\");\n\t\t\t\tDatabase::pexecute($ssl_stmt, array(\n\t\t\t\t\t\"domainid\" => $parentdomainid\n\t\t\t\t));\n\t\t\t\t$ssl_result = $ssl_stmt->fetch(PDO::FETCH_ASSOC);\n\t\t\t\tif (is_array($ssl_result) && isset($ssl_result['ssl_cert_file']) && $ssl_result['ssl_cert_file'] != '') {\n\t\t\t\t\t// parent has a certificate (ssl_shared)\n\t\t\t\t\t$domain_hascert = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $domain_hascert;\n\t}\n\n\t/**\n\t * validate given path and replace with url if given and valid\n\t *\n\t * @param string $path\n\t * @param string $url\n\t * @param array $customer\n\t * @param string $completedomain\n\t * @param boolean $_doredirect\n\t *\n\t * @return string validated path\n\t * @throws Exception\n\t */\n\tprivate function validateDomainDocumentRoot($path = null, $url = null, $customer = null, $completedomain = null, &$_doredirect = false)\n\t{\n\t\t// check whether an URL was specified\n\t\t$_doredirect = false;\n\t\tif (!empty($url) && Validate::validateUrl($url, true)) {\n\t\t\t$path = $url;\n\t\t\t$_doredirect = true;\n\t\t} else {\n\t\t\t$path = Validate::validate($path, 'path', '', '', [], true);\n\t\t}\n\n\t\t// check whether path is a real path\n\t\tif (!preg_match('/^https?\\:\\/\\//', $path) || !Validate::validateUrl($path, true)) {\n\t\t\tif (strstr($path, \":\") !== false) {\n\t\t\t\tResponse::standardError('pathmaynotcontaincolon', '', true);\n\t\t\t}\n\t\t\t// If path is empty or '/' and 'Use domain name as default value for DocumentRoot path' is enabled in settings,\n\t\t\t// set default path to subdomain or domain name\n\t\t\tif ((($path == '') || ($path == '/')) && Settings::Get('system.documentroot_use_default_value') == 1) {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $completedomain);\n\t\t\t} else {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);\n\t\t\t}\n\t\t} else {\n\t\t\t// no it's not, create a redirect\n\t\t\t$_doredirect = true;\n\t\t}\n\t\treturn $path;\n\t}\n\n\t/**\n\t * update subdomain entry by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param int $alias\n\t *            optional, domain-id of a domain that the new domain should be an alias of\n\t * @param string $path\n\t *            optional, destination path relative to the customers-homedir, default is customers-homedir\n\t * @param string $url\n\t *            optional, overwrites path value with an URL to generate a redirect, alternatively use the path\n\t *            parameter also for URLs\n\t * @param int $selectserveralias\n\t *            optional, 0 = wildcard, 1 = www-alias, 2 = none\n\t * @param bool $isemaildomain\n\t *            optional\n\t * @param int $openbasedir_path\n\t *            optional, either 0 for domains-docroot, 1 for customers-homedir or 2 for parent-directory of domains-docroot\n\t * @param int $phpsettingid\n\t *            optional, php-settings-id, if empty the $domain value is used\n\t * @param int $redirectcode\n\t *            optional, redirect-code-id from TABLE_PANEL_REDIRECTCODES\n\t * @param bool $speciallogfile\n\t *            optional, whether to create an exclusive web-logfile for this domain\n\t * @param bool $speciallogverified\n\t *            optional, when setting $speciallogfile to false, this needs to be set to true to confirm the action,\n\t *            default 0 (false)\n\t * @param bool $sslenabled\n\t *            optional, whether or not SSL is enabled for this domain, regardless of the assigned ssl-ips, default\n\t *            1 (true)\n\t * @param bool $ssl_redirect\n\t *            optional, whether to generate a https-redirect or not, default false; requires SSL to be enabled\n\t * @param bool $letsencrypt\n\t *            optional, whether to generate a Let's Encrypt certificate for this domain, default false; requires\n\t *            SSL to be enabled\n\t * @param bool $http2\n\t *            optional, whether to enable http/2 for this domain (requires to be enabled in the settings), default\n\t *            0 (false)\n\t * @param int $hsts_maxage\n\t *            optional max-age value for HSTS header\n\t * @param bool $hsts_sub\n\t *            optional whether or not to add subdomains to the HSTS header\n\t * @param bool $hsts_preload\n\t *            optional whether or not to preload HSTS header value\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id,\n\t\t\t'domainname' => $domainname\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin() == false && (int)$result['caneditdomain'] == 0) {\n\t\t\tthrow new Exception(lng('error.domaincannotbeedited', [$result['domain']]), 406);\n\t\t}\n\n\t\t// parameters\n\t\t$aliasdomain = $this->getParam('alias', true, 0);\n\t\t$path = $this->getParam('path', true, $result['documentroot']);\n\t\t$url = $this->getParam('url', true, '');\n\t\t// default: 0 = wildcard, 1 = www-alias, 2 = none\n\t\t$_serveraliasdefault = $result['iswildcarddomain'] == '1' ? 0 : ($result['wwwserveralias'] == '1' ? 1 : 2);\n\t\t$selectserveralias = $this->getParam('selectserveralias', true, $_serveraliasdefault);\n\t\t$isemaildomain = $this->getBoolParam('isemaildomain', true, $result['isemaildomain']);\n\t\t$openbasedir_path = $this->getParam('openbasedir_path', true, $result['openbasedir_path']);\n\t\t$phpsettingid = $this->getParam('phpsettingid', true, $result['phpsettingid']);\n\t\t$redirectcode = $this->getParam('redirectcode', true, Domain::getDomainRedirectId($id));\n\t\t$speciallogfile = $this->getBoolParam('speciallogfile', true, $result['speciallogfile']);\n\t\t$speciallogverified = $this->getBoolParam('speciallogverified', true, 0);\n\t\tif (Settings::Get('system.use_ssl')) {\n\t\t\t$sslenabled = $this->getBoolParam('sslenabled', true, $result['ssl_enabled']);\n\t\t\t$ssl_redirect = $this->getBoolParam('ssl_redirect', true, $result['ssl_redirect']);\n\t\t\t$letsencrypt = $this->getBoolParam('letsencrypt', true, $result['letsencrypt']);\n\t\t\t$http2 = $this->getBoolParam('http2', true, $result['http2']);\n\t\t\t$hsts_maxage = $this->getParam('hsts_maxage', true, $result['hsts']);\n\t\t\t$hsts_sub = $this->getBoolParam('hsts_sub', true, $result['hsts_sub']);\n\t\t\t$hsts_preload = $this->getBoolParam('hsts_preload', true, $result['hsts_preload']);\n\t\t} else {\n\t\t\t$sslenabled = 0;\n\t\t\t$ssl_redirect = 0;\n\t\t\t$letsencrypt = 0;\n\t\t\t$http2 = 0;\n\t\t\t$hsts_maxage = 0;\n\t\t\t$hsts_sub = 0;\n\t\t\t$hsts_preload = 0;\n\t\t}\n\n\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t$alias_stmt = Database::prepare(\"SELECT COUNT(`id`) AS count FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `aliasdomain`= :aliasdomain\");\n\t\t$alias_check = Database::pexecute_first($alias_stmt, [\n\t\t\t\"aliasdomain\" => $result['id']\n\t\t]);\n\t\t$alias_check = $alias_check['count'];\n\n\t\t// alias domain checked?\n\t\tif ($aliasdomain != 0) {\n\t\t\t$aliasdomain_stmt = Database::prepare(\"\n\t\t\t\tSELECT `id` FROM `\" . TABLE_PANEL_DOMAINS . \"` `d`,`\" . TABLE_PANEL_CUSTOMERS . \"` `c`\n\t\t\t\tWHERE `d`.`customerid`= :customerid\n\t\t\t\tAND `d`.`aliasdomain` IS NULL\n\t\t\t\tAND `d`.`id`<>`c`.`standardsubdomain`\n\t\t\t\tAND `c`.`customerid`= :customerid\n\t\t\t\tAND `d`.`id`= :id\n\t\t\t\");\n\t\t\t$aliasdomain_check = Database::pexecute_first($aliasdomain_stmt, [\n\t\t\t\t\"id\" => $aliasdomain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\t\t\tif ($aliasdomain_check['id'] != $aliasdomain) {\n\t\t\t\tResponse::standardError('domainisaliasorothercustomer', '', true);\n\t\t\t}\n\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t}\n\n\t\t// validate / correct path/url of domain\n\t\t$_doredirect = false;\n\t\t$path = $this->validateDomainDocumentRoot($path, $url, $customer, $result['domain'], $_doredirect);\n\n\t\t// set alias-fields according to selected alias mode\n\t\t$iswildcarddomain = ($selectserveralias == '0') ? '1' : '0';\n\t\t$wwwserveralias = ($selectserveralias == '1') ? '1' : '0';\n\n\t\t// if allowed, check for 'is email domain'-flag\n\t\tif ($isemaildomain != $result['isemaildomain']) {\n\t\t\tif ($result['parentdomainid'] != '0' && ($result['subcanemaildomain'] == '1' || $result['subcanemaildomain'] == '2')) {\n\t\t\t\t$isemaildomain = intval($isemaildomain);\n\t\t\t} elseif ($result['parentdomainid'] != '0') {\n\t\t\t\t$isemaildomain = $result['subcanemaildomain'] == '3' ? 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\t// check changes of openbasedir-path variable\n\t\tif ($openbasedir_path > 2 && $openbasedir_path < 0) {\n\t\t\t$openbasedir_path = 0;\n\t\t}\n\n\t\tif ($ssl_redirect != 0) {\n\t\t\t// a ssl-redirect only works if there actually is a\n\t\t\t// ssl ip/port assigned to the domain\n\t\t\tif (Domain::domainHasSslIpPort($result['id']) == true) {\n\t\t\t\t$ssl_redirect = '1';\n\t\t\t\t$_doredirect = true;\n\t\t\t} else {\n\t\t\t\tResponse::standardError('sslredirectonlypossiblewithsslipport', '', true);\n\t\t\t}\n\t\t}\n\n\t\tif ($letsencrypt != 0) {\n\t\t\t// let's encrypt only works if there actually is a\n\t\t\t// ssl ip/port assigned to the domain\n\t\t\tif (Domain::domainHasSslIpPort($result['id']) == true) {\n\t\t\t\t$letsencrypt = '1';\n\t\t\t} else {\n\t\t\t\tResponse::standardError('letsencryptonlypossiblewithsslipport', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// validate dns if lets encrypt is enabled to check whether we can use it at all\n\t\tif ($result['letsencrypt'] != $letsencrypt && $letsencrypt == '1' && Settings::Get('system.le_domain_dnscheck') == '1') {\n\t\t\t$our_ips = Domain::getIpsOfDomain($result['parentdomainid']);\n\t\t\t$domain_ips = PhpHelper::gethostbynamel6($result['domain'], true, Settings::Get('system.le_domain_dnscheck_resolver'));\n\t\t\tif ($domain_ips == false || count(array_intersect($our_ips, $domain_ips)) <= 0) {\n\t\t\t\tResponse::standardError('invaliddnsforletsencrypt', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// We can't enable let's encrypt for wildcard-domains\n\t\tif ($iswildcarddomain == '1' && $letsencrypt == '1') {\n\t\t\tResponse::standardError('nowildcardwithletsencrypt', '', true);\n\t\t}\n\n\t\t// Temporarily deactivate ssl_redirect until Let's Encrypt certificate was generated\n\t\tif ($ssl_redirect > 0 && $letsencrypt == 1 && $result['letsencrypt'] != $letsencrypt) {\n\t\t\t$ssl_redirect = 2;\n\t\t}\n\n\t\tif ($speciallogfile != $result['speciallogfile'] && $speciallogverified != '1') {\n\t\t\t$speciallogfile = $result['speciallogfile'];\n\t\t}\n\n\t\t// is-email-domain flag changed - remove mail accounts and mail-addresses\n\t\tif (($result['isemaildomain'] == '1') && $isemaildomain == '0') {\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"domainid\" => $id\n\t\t\t];\n\t\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_MAIL_USERS . \"` WHERE `customerid`= :customerid AND `domainid`= :domainid\");\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_MAIL_VIRTUAL . \"` WHERE `customerid`= :customerid AND `domainid`= :domainid\");\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] automatically deleted mail-table entries for '\" . $idna_convert->decode($result['domain']) . \"'\");\n\t\t}\n\n\t\t$allowed_phpconfigs = $customer['allowed_phpconfigs'];\n\t\tif (!empty($allowed_phpconfigs)) {\n\t\t\t$allowed_phpconfigs = json_decode($allowed_phpconfigs, true);\n\t\t} else {\n\t\t\t$allowed_phpconfigs = [];\n\t\t}\n\t\t// only with fcgid/fpm enabled will it be possible to select a php-setting\n\t\tif ((int)Settings::Get('system.mod_fcgid') == 1 || (int)Settings::Get('phpfpm.enabled') == 1) {\n\t\t\tif (!in_array($phpsettingid, $allowed_phpconfigs)) {\n\t\t\t\tResponse::standardError('notallowedphpconfigused', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// handle redirect\n\t\tif ($_doredirect) {\n\t\t\tDomain::updateRedirectOfDomain($id, $redirectcode);\n\t\t}\n\n\t\tif ($path != $result['documentroot']\n\t\t\t|| $isemaildomain != $result['isemaildomain']\n\t\t\t|| $wwwserveralias != $result['wwwserveralias']\n\t\t\t|| $iswildcarddomain != $result['iswildcarddomain']\n\t\t\t|| $aliasdomain != (int)$result['aliasdomain']\n\t\t\t|| $openbasedir_path != $result['openbasedir_path']\n\t\t\t|| $ssl_redirect != $result['ssl_redirect']\n\t\t\t|| $letsencrypt != $result['letsencrypt']\n\t\t\t|| $hsts_maxage != $result['hsts']\n\t\t\t|| $hsts_sub != $result['hsts_sub']\n\t\t\t|| $hsts_preload != $result['hsts_preload']\n\t\t\t|| $phpsettingid != $result['phpsettingid']\n\t\t\t|| $http2 != $result['http2']\n\t\t\t|| ($speciallogfile != $result['speciallogfile'] && $speciallogverified == '1')\n\t\t) {\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t\t`documentroot` = :documentroot,\n\t\t\t\t\t`isemaildomain` = :isemaildomain,\n\t\t\t\t\t`wwwserveralias` = :wwwserveralias,\n\t\t\t\t\t`iswildcarddomain` = :iswildcarddomain,\n\t\t\t\t\t`aliasdomain` = :aliasdomain,\n\t\t\t\t\t`openbasedir_path` = :openbasedir_path,\n\t\t\t\t\t`ssl_enabled` = :sslenabled,\n\t\t\t\t\t`ssl_redirect` = :ssl_redirect,\n\t\t\t\t\t`letsencrypt` = :letsencrypt,\n\t\t\t\t\t`http2` = :http2,\n\t\t\t\t\t`hsts` = :hsts,\n\t\t\t\t\t`hsts_sub` = :hsts_sub,\n\t\t\t\t\t`hsts_preload` = :hsts_preload,\n\t\t\t\t\t`phpsettingid` = :phpsettingid,\n\t\t\t\t\t`speciallogfile` = :speciallogfile\n\t\t\t\t\tWHERE `customerid`= :customerid AND `id`= :id\n\t\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"documentroot\" => $path,\n\t\t\t\t\"isemaildomain\" => $isemaildomain,\n\t\t\t\t\"wwwserveralias\" => $wwwserveralias,\n\t\t\t\t\"iswildcarddomain\" => $iswildcarddomain,\n\t\t\t\t\"aliasdomain\" => ($aliasdomain != 0 && $alias_check == 0) ? $aliasdomain : null,\n\t\t\t\t\"openbasedir_path\" => $openbasedir_path,\n\t\t\t\t\"sslenabled\" => $sslenabled,\n\t\t\t\t\"ssl_redirect\" => $ssl_redirect,\n\t\t\t\t\"letsencrypt\" => $letsencrypt,\n\t\t\t\t\"http2\" => $http2,\n\t\t\t\t\"hsts\" => $hsts_maxage,\n\t\t\t\t\"hsts_sub\" => $hsts_sub,\n\t\t\t\t\"hsts_preload\" => $hsts_preload,\n\t\t\t\t\"phpsettingid\" => $phpsettingid,\n\t\t\t\t\"speciallogfile\" => $speciallogfile,\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"id\" => $id\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\n\t\t\tif ($result['aliasdomain'] != $aliasdomain && is_numeric($result['aliasdomain'])) {\n\t\t\t\t// trigger when domain id for alias destination has changed: both for old and new destination\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($result['aliasdomain'], $this->logger());\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t}\n\t\t\tif ($result['wwwserveralias'] != $wwwserveralias || $result['letsencrypt'] != $letsencrypt) {\n\t\t\t\t// or when wwwserveralias or letsencrypt was changed\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t\tif ((int)$aliasdomain === 0) {\n\t\t\t\t\t// in case the wwwserveralias is set on a main domain, $aliasdomain is 0\n\t\t\t\t\t// --> the call just above to triggerLetsEncryptCSRForAliasDestinationDomain\n\t\t\t\t\t// is a noop...let's repeat it with the domain id of the main domain\n\t\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($id, $this->logger());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check whether LE has been disabled, so we remove the certificate\n\t\t\tif ($letsencrypt == '0' && $result['letsencrypt'] == '1') {\n\t\t\t\t$del_stmt = Database::prepare(\"\n\t\t\t\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :id\n\t\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($del_stmt, [\n\t\t\t\t\t'id' => $id\n\t\t\t\t], true, true);\n\t\t\t\t// remove domain from acme.sh / lets encrypt if used\n\t\t\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_SSL, $result['domain']);\n\t\t\t}\n\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] edited domain '\" . $idna_convert->decode($result['domain']) . \"'\");\n\t\t}\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * lists all customer domain/subdomain entries\n\t *\n\t * @param bool $with_ips\n\t *            optional, default true\n\t * @param int $customerid\n\t *            optional, admin-only, select (sub)domains of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select (sub)domains of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\t$with_ips = $this->getParam('with_ips', true, true);\n\t\tif ($this->isAdmin()) {\n\t\t\t// if we're an admin, list all subdomains of all the admins customers\n\t\t\t// or optionally for one specific customer identified by id or loginname\n\t\t\t$customerid = $this->getParam('customerid', true, 0);\n\t\t\t$loginname = $this->getParam('loginname', true, '');\n\n\t\t\tif (!empty($customerid) || !empty($loginname)) {\n\t\t\t\t$result = $this->apiCall('Customers.get', [\n\t\t\t\t\t'id' => $customerid,\n\t\t\t\t\t'loginname' => $loginname\n\t\t\t\t]);\n\t\t\t\t$custom_list_result = [\n\t\t\t\t\t$result\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t}\n\t\t\t$customer_ids = [];\n\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t}\n\t\t\tif (empty($customer_ids)) {\n\t\t\t\tthrow new Exception(\"Required resource unsatisfied.\", 405);\n\t\t\t}\n\n\t\t\t$select_fields = [\n\t\t\t\t'`d`.*'\n\t\t\t];\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$customer_ids = [\n\t\t\t\t$this->getUserDetail('customerid')\n\t\t\t];\n\n\t\t\t$select_fields = [\n\t\t\t\t'`d`.`id`',\n\t\t\t\t'`d`.`customerid`',\n\t\t\t\t'`d`.`domain`',\n\t\t\t\t'`d`.`domain_ace`',\n\t\t\t\t'`d`.`documentroot`',\n\t\t\t\t'`d`.`isbinddomain`',\n\t\t\t\t'`d`.`isemaildomain`',\n\t\t\t\t'`d`.`caneditdomain`',\n\t\t\t\t'`d`.`iswildcarddomain`',\n\t\t\t\t'`d`.`parentdomainid`',\n\t\t\t\t'`d`.`letsencrypt`',\n\t\t\t\t'`d`.`registration_date`',\n\t\t\t\t'`d`.`termination_date`',\n\t\t\t\t'`d`.`deactivated`'\n\t\t\t];\n\t\t}\n\t\t$query_fields = [];\n\n\t\t// prepare select statement\n\t\t$domains_stmt = Database::prepare(\"\n\t\t\tSELECT \" . implode(\",\", $select_fields) . \", IF(`d`.`parentdomainid` > 0, `pd`.`domain_ace`, `d`.`domain_ace`) AS `parentdomainname`, `ad`.`id` AS `aliasdomainid`, `ad`.`domain` AS `aliasdomain`, `da`.`id` AS `domainaliasid`, `da`.`domain` AS `domainalias`\n\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` `d`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `ad` ON `d`.`aliasdomain`=`ad`.`id`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `da` ON `da`.`aliasdomain`=`d`.`id`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `pd` ON `pd`.`id`=`d`.`parentdomainid`\n\t\t\tWHERE `d`.`customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\tAND `d`.`email_only` = '0'\n\t\t\t\" . $this->getSearchWhere($query_fields, true) . \" GROUP BY `d`.`id` ORDER BY `parentdomainname` ASC, `d`.`parentdomainid` ASC \" . $this->getOrderBy(true) . $this->getLimit());\n\n\t\t$result = [];\n\t\tDatabase::pexecute($domains_stmt, $query_fields, true, true);\n\t\twhile ($row = $domains_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$row['ipsandports'] = [];\n\t\t\tif ($with_ips) {\n\t\t\t\t$row['ipsandports'] = $this->getIpsForDomain($row['id']);\n\t\t\t}\n\t\t\t$row['domain_hascert'] = $this->getHasCertValueForDomain((int)$row['id'], (int)$row['parentdomainid']);\n\t\t\t$result[] = $row;\n\t\t}\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * get ips connected to given domain as array\n\t *\n\t * @param number $domain_id\n\t * @param bool $ssl_only\n\t *            optional, return only ssl enabled ip's, default false\n\t * @return array\n\t */\n\tprivate function getIpsForDomain($domain_id = 0, $ssl_only = false)\n\t{\n\t\t$fields = '`ips`.ip, `ips`.port, `ips`.ssl';\n\t\tif ($this->isAdmin()) {\n\t\t\t$fields = '`ips`.*';\n\t\t}\n\t\t$resultips_stmt = Database::prepare(\"\n\t\t\tSELECT \" . $fields . \" FROM `\" . TABLE_DOMAINTOIP . \"` AS `dti`, `\" . TABLE_PANEL_IPSANDPORTS . \"` AS `ips`\n\t\t\tWHERE `dti`.`id_ipandports` = `ips`.`id` AND `dti`.`id_domain` = :domainid \" . ($ssl_only ? \" AND `ips`.`ssl` = '1'\" : \"\"));\n\n\t\tDatabase::pexecute($resultips_stmt, [\n\t\t\t'domainid' => $domain_id\n\t\t]);\n\n\t\t$ipandports = [];\n\t\twhile ($rowip = $resultips_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif (filter_var($rowip['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$rowip['is_ipv6'] = true;\n\t\t\t}\n\t\t\t$ipandports[] = $rowip;\n\t\t}\n\n\t\treturn $ipandports;\n\t}\n\n\t/**\n\t * returns the total number of accessible subdomain entries\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select (sub)domains of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select (sub)domains of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin()) {\n\t\t\t// if we're an admin, list all databases of all the admins customers\n\t\t\t// or optionally for one specific customer identified by id or loginname\n\t\t\t$customerid = $this->getParam('customerid', true, 0);\n\t\t\t$loginname = $this->getParam('loginname', true, '');\n\n\t\t\tif (!empty($customerid) || !empty($loginname)) {\n\t\t\t\t$result = $this->apiCall('Customers.get', [\n\t\t\t\t\t'id' => $customerid,\n\t\t\t\t\t'loginname' => $loginname\n\t\t\t\t]);\n\t\t\t\t$custom_list_result = [\n\t\t\t\t\t$result\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t}\n\t\t\t$customer_ids = [];\n\t\t\t$customer_stdsubs = [];\n\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t$customer_stdsubs[$customer['customerid']] = $customer['standardsubdomain'];\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$customer_ids = [\n\t\t\t\t$this->getUserDetail('customerid')\n\t\t\t];\n\t\t\t$customer_stdsubs = [\n\t\t\t\t$this->getUserDetail('customerid') => $this->getUserDetail('standardsubdomain')\n\t\t\t];\n\t\t}\n\t\tif (!empty($customer_ids)) {\n\t\t\t// prepare select statement\n\t\t\t$domains_stmt = Database::prepare(\"\n\t\t\t\tSELECT COUNT(*) as num_subdom\n\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` `d`\n\t\t\t\tWHERE `d`.`customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\t\tAND `d`.`email_only` = '0'\n\t\t\t\tAND `d`.`id` NOT IN (\" . implode(', ', $customer_stdsubs) . \")\n\t\t\t\");\n\t\t\t$result = Database::pexecute_first($domains_stmt, null, true, true);\n\t\t\tif ($result) {\n\t\t\t\treturn $this->response($result['num_subdom']);\n\t\t\t}\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a subdomain by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id,\n\t\t\t'domainname' => $domainname\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\tif (!$this->isAdmin() && $result['caneditdomain'] == 0) {\n\t\t\tthrow new Exception(\"You cannot edit this resource\", 405);\n\t\t}\n\n\t\tif ($result['isemaildomain'] == '1') {\n\t\t\t// check for e-mail addresses\n\t\t\t$emails_stmt = Database::prepare(\"\n\t\t\t\tSELECT COUNT(`id`) AS `count` FROM `\" . TABLE_MAIL_VIRTUAL . \"`\n\t\t\t\tWHERE `customerid` = :customerid AND `domainid` = :domainid\n\t\t\t\");\n\t\t\t$emails = Database::pexecute_first($emails_stmt, [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"domainid\" => $id\n\t\t\t], true, true);\n\n\t\t\tif ($emails['count'] != '0') {\n\t\t\t\tResponse::standardError('domains_cantdeletedomainwithemail', '', true);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)$result['aliasdomain'] !== 0) {\n\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($result['aliasdomain'], $this->logger());\n\t\t}\n\n\t\t// delete domain from table\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `customerid` = :customerid AND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t// remove connections to ips and domainredirects\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\tWHERE `id_domain` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove redirect-codes\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAINREDIRECTS . \"`\n\t\t\tWHERE `did` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove certificate from domain_ssl_settings, fixes #1596\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"`\n\t\t\tWHERE `domainid` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove possible existing DNS entries\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_DOMAIN_DNS . \"`\n\t\t\tWHERE `domain_id` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t// Using nameserver, insert a task which rebuilds the server config\n\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t// remove domains DNS from powerDNS if used, #581\n\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_PDNS, $result['domain']);\n\t\t// remove domain from acme.sh / lets encrypt if used\n\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_SSL, $result['domain']);\n\n\t\t// reduce subdomain-usage-counter\n\t\tCustomers::decreaseUsage($customer['customerid'], 'subdomains_used');\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted subdomain '\" . $result['domain'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Cron\\Http;\n\nuse Froxlor\\Froxlor;\nuse Froxlor\\Cron\\Http\\Php\\PhpInterface;\nuse Froxlor\\Customer\\Customer;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Domain\\Domain;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Http\\Directory;\nuse Froxlor\\Http\\Statistics;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\Validate\\Validate;\nuse Froxlor\\System\\Crypt;\nuse PDO;\n\nclass Apache extends HttpConfigBase\n{\n\n\t// protected\n\tprotected $known_diroptionsfilenames = [];\n\n\tprotected $known_htpasswdsfilenames = [];\n\n\tprotected $virtualhosts_data = [];\n\n\tprotected $diroptions_data = [];\n\n\tprotected $htpasswds_data = [];\n\n\t/**\n\t * indicator whether a customer is deactivated or not\n\t * if yes, only the webroot will be generated\n\t *\n\t * @var bool\n\t */\n\tprivate $deactivated = false;\n\n\tpublic function createIpPort()\n\t{\n\t\t$result_ipsandports_stmt = Database::query(\"SELECT * FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` ORDER BY `ip` ASC, `port` ASC\");\n\n\t\twhile ($row_ipsandports = $result_ipsandports_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif (filter_var($row_ipsandports['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$ipport = '[' . $row_ipsandports['ip'] . ']:' . $row_ipsandports['port'];\n\t\t\t} else {\n\t\t\t\t$ipport = $row_ipsandports['ip'] . ':' . $row_ipsandports['port'];\n\t\t\t}\n\n\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'apache::createIpPort: creating ip/port settings for  ' . $ipport);\n\t\t\t$vhosts_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_vhost') . '/10_froxlor_ipandport_' . trim(str_replace(':', '.', $row_ipsandports['ip']), '.') . '.' . $row_ipsandports['port'] . '.conf');\n\n\t\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['listen_statement'] == '1') {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'Listen ' . $ipport . \"\\n\";\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted listen-statement');\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['namevirtualhost_statement'] == '1') {\n\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, $ipport . ' :: namevirtualhost-statement no longer needed for apache-2.4');\n\t\t\t\t} else {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'NameVirtualHost ' . $ipport . \"\\n\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted namevirtualhost-statement');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['vhostcontainer'] == '1') {\n\t\t\t\t$without_vhost = $this->virtualhosts_data[$vhosts_filename];\n\t\t\t\t$close_vhost = true;\n\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '<VirtualHost ' . $ipport . '>' . \"\\n\";\n\n\t\t\t\t$mypath = $this->getMyPath($row_ipsandports);\n\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'DocumentRoot \"' . rtrim($mypath, \"/\") . '\"' . \"\\n\";\n\n\t\t\t\tif ($row_ipsandports['vhostcontainer_servername_statement'] == '1') {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' ServerName ' . Settings::Get('system.hostname') . \"\\n\";\n\n\t\t\t\t\t$froxlor_aliases = Settings::Get('system.froxloraliases');\n\t\t\t\t\tif (!empty($froxlor_aliases)) {\n\t\t\t\t\t\t$froxlor_aliases = explode(\",\", $froxlor_aliases);\n\t\t\t\t\t\t$aliases = \"\";\n\t\t\t\t\t\tforeach ($froxlor_aliases as $falias) {\n\t\t\t\t\t\t\tif (Validate::validateDomain(trim($falias))) {\n\t\t\t\t\t\t\t\t$aliases .= trim($falias) . \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$aliases = trim($aliases);\n\t\t\t\t\t\tif (!empty($aliases)) {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' ServerAlias ' . $aliases . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$is_redirect = false;\n\t\t\t\t// check for SSL redirect\n\t\t\t\tif ($row_ipsandports['ssl'] == '0' && Settings::Get('system.le_froxlor_redirect') == '1') {\n\t\t\t\t\t$is_redirect = true;\n\t\t\t\t\t// check whether froxlor uses Let's Encrypt and not cert is being generated yet\n\t\t\t\t\t// or a renew is ongoing - disable redirect\n\t\t\t\t\tif (Settings::Get('system.le_froxlor_enabled') && ($this->froxlorVhostHasLetsEncryptCert() == false || $this->froxlorVhostLetsEncryptNeedsRenew())) {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# temp. disabled ssl-redirect due to Let\\'s Encrypt certificate generation.' . PHP_EOL;\n\t\t\t\t\t\t$is_redirect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$_sslport = $this->checkAlternativeSslPort();\n\n\t\t\t\t\t\t$mypath = 'https://' . Settings::Get('system.hostname') . $_sslport . '/';\n\t\t\t\t\t\t$code = '301';\n\t\t\t\t\t\t$modrew_red = ' [R=' . $code . ';L,NE]';\n\n\t\t\t\t\t\t// redirect everything, not only root-directory, #541\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <IfModule mod_rewrite.c>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteEngine On' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteCond %{HTTPS} off' . \"\\n\";\n\t\t\t\t\t\tif (Settings::Get('system.le_froxlor_enabled') == '1') {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteRule ^/(.*) ' . $mypath . '$1' . $modrew_red . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </IfModule>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <IfModule !mod_rewrite.c>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Redirect ' . $code . ' / ' . $mypath . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </IfModule>' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$is_redirect) {\n\t\t\t\t\tif (Settings::Get('system.froxlordirectlyviahostname')) {\n\t\t\t\t\t\t$relpath = \"/\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$relpath = \"/\".basename(Froxlor::getInstallDir());\n\t\t\t\t\t}\n\t\t\t\t\t// protect lib/userdata.inc.php\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . rtrim($relpath, \"/\") . '/lib/\">' . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    <Files \"userdata.inc.php\">' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all denied' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order deny,allow' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    deny from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </Files>' . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t// protect bin/\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <DirectoryMatch \"^' . rtrim($relpath, \"/\") . '/(bin|cache|logs|tests|vendor)/\">' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all denied' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order deny,allow' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    deny from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </DirectoryMatch>' . \"\\n\";\n\n\t\t\t\t\t// create fcgid <Directory>-Part (starter is created in apache_fcgid)\n\t\t\t\t\tif (Settings::Get('system.mod_fcgid_ownvhost') == '1' && Settings::Get('system.mod_fcgid') == '1') {\n\t\t\t\t\t\t$configdir = FileDir::makeCorrectDir(Settings::Get('system.mod_fcgid_configdir') . '/froxlor.panel/' . Settings::Get('system.hostname'));\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  FcgidIdleTimeout ' . Settings::Get('system.mod_fcgid_idle_timeout') . \"\\n\";\n\t\t\t\t\t\tif ((int)Settings::Get('system.mod_fcgid_wrapper') == 0) {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SuexecUserGroup \"' . Settings::Get('system.mod_fcgid_httpuser') . '\" \"' . Settings::Get('system.mod_fcgid_httpgroup') . '\"' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  ScriptAlias /php/ ' . $configdir . \"\\n\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t\t'mod_fcgid_starter' => -1,\n\t\t\t\t\t\t\t\t'mod_fcgid_maxrequests' => -1,\n\t\t\t\t\t\t\t\t'guid' => Settings::Get('system.mod_fcgid_httpuser'),\n\t\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t$php = new PhpInterface($domain);\n\t\t\t\t\t\t\t$phpconfig = $php->getPhpConfig(Settings::Get('system.mod_fcgid_defaultini_ownvhost'));\n\n\t\t\t\t\t\t\t$starter_filename = FileDir::makeCorrectFile($configdir . '/php-fcgi-starter');\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SuexecUserGroup \"' . Settings::Get('system.mod_fcgid_httpuser') . '\" \"' . Settings::Get('system.mod_fcgid_httpgroup') . '\"' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t$file_extensions = explode(' ', $phpconfig['file_extensions']);\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    <FilesMatch \"\\.(' . implode('|', $file_extensions) . ')$\">' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      SetHandler fcgid-script' . \"\\n\";\n\t\t\t\t\t\t\tforeach ($file_extensions as $file_extension) {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      FcgidWrapper ' . $starter_filename . ' .' . $file_extension . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      Options +ExecCGI' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\t$mypath_dir = new Directory($mypath);\n\t\t\t\t\t\t\t\t// only create the require all granted if there is not active directory-protection\n\t\t\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif (Settings::Get('phpfpm.enabled') == '1' && (int)Settings::Get('phpfpm.enabled_ownvhost') == 1) {\n\t\t\t\t\t\t// get fpm config\n\t\t\t\t\t\t$fpm_sel_stmt = Database::prepare(\"\n\t\t\t\t\t\t\tSELECT f.id FROM `\" . TABLE_PANEL_FPMDAEMONS . \"` f\n\t\t\t\t\t\t\tLEFT JOIN `\" . TABLE_PANEL_PHPCONFIGS . \"` p ON p.fpmsettingid = f.id\n\t\t\t\t\t\t\tWHERE p.id = :phpconfigid\n\t\t\t\t\t\t\");\n\t\t\t\t\t\t$fpm_config = Database::pexecute_first($fpm_sel_stmt, [\n\t\t\t\t\t\t\t'phpconfigid' => Settings::Get('phpfpm.vhost_defaultini')\n\t\t\t\t\t\t]);\n\t\t\t\t\t\t// create php-fpm <Directory>-Part (config is created in apache_fcgid)\n\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t'mod_fcgid_starter' => -1,\n\t\t\t\t\t\t\t'mod_fcgid_maxrequests' => -1,\n\t\t\t\t\t\t\t'guid' => Settings::Get('phpfpm.vhost_httpuser'),\n\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t'customerroot' => $mypath,\n\t\t\t\t\t\t\t'fpm_config_id' => isset($fpm_config['id']) ? $fpm_config['id'] : 1\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\t$php = new phpinterface($domain);\n\t\t\t\t\t\t$phpconfig = $php->getPhpConfig(Settings::Get('phpfpm.vhost_defaultini'));\n\t\t\t\t\t\t$srvName = substr(md5($ipport), 0, 4) . '.fpm.external';\n\t\t\t\t\t\tif ($row_ipsandports['ssl']) {\n\t\t\t\t\t\t\t$srvName = substr(md5($ipport), 0, 4) . '.ssl-fpm.external';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// mod_proxy stuff for apache-2.4\n\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1' && Settings::Get('phpfpm.use_mod_proxy') == '1') {\n\t\t\t\t\t\t\t$filesmatch = $phpconfig['fpm_settings']['limit_extensions'];\n\t\t\t\t\t\t\t$extensions = explode(\" \", $filesmatch);\n\t\t\t\t\t\t\t$filesmatch = \"\";\n\t\t\t\t\t\t\tforeach ($extensions as $ext) {\n\t\t\t\t\t\t\t\t$filesmatch .= substr($ext, 1) . '|';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// start block, cut off last pipe and close block\n\t\t\t\t\t\t\t$filesmatch = '(' . str_replace(\".\", \"\\.\", substr($filesmatch, 0, -1)) . ')';\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <FilesMatch \\.' . $filesmatch . '$>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SetHandler proxy:unix:' . $php->getInterface()->getSocketFile() . '|fcgi://localhost' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\tif ($phpconfig['pass_authorizationheader'] == '1') {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      CGIPassAuth On' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$addheader = \"\";\n\t\t\t\t\t\t\tif ($phpconfig['pass_authorizationheader'] == '1') {\n\t\t\t\t\t\t\t\t$addheader = \" -pass-header Authorization\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  FastCgiExternalServer ' . $php->getInterface()->getAliasConfigDir() . $srvName . ' -socket ' . $php->getInterface()->getSocketFile() . ' -idle-timeout ' . $phpconfig['fpm_settings']['idle_timeout'] . $addheader . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t$filesmatch = $phpconfig['fpm_settings']['limit_extensions'];\n\t\t\t\t\t\t\t$extensions = explode(\" \", $filesmatch);\n\t\t\t\t\t\t\t$filesmatch = \"\";\n\t\t\t\t\t\t\tforeach ($extensions as $ext) {\n\t\t\t\t\t\t\t\t$filesmatch .= substr($ext, 1) . '|';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// start block, cut off last pipe and close block\n\t\t\t\t\t\t\t$filesmatch = '(' . str_replace(\".\", \"\\.\", substr($filesmatch, 0, -1)) . ')';\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '   <FilesMatch \\.' . $filesmatch . '$>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '     AddHandler php-fastcgi .php' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '     Action php-fastcgi /fastcgiphp' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      Options +ExecCGI' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\t$mypath_dir = new Directory($mypath);\n\t\t\t\t\t\t\t\t// only create the require all granted if there is not active directory-protection\n\t\t\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  Alias /fastcgiphp ' . $php->getInterface()->getAliasConfigDir() . $srvName . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// mod_php\n\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t'guid' => Settings::Get('system.httpuser'),\n\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\t// end of ssl-redirect check\n\t\t\t\t} else {\n\t\t\t\t\t// fallback of froxlor domain-data for processSpecialConfigTemplate()\n\t\t\t\t\t$domain = [\n\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * dirprotection, see #72\n\t\t\t\t *\n\t\t\t\t * @todo deferred until 0.9.5, needs more testing\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t<Directory \\\"'.$mypath.'(images|packages|templates)\\\">\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tAllow from all\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tOptions -Indexes\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t</Directory>\\n\";\n\t\t\t\t *\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t<Directory \\\"'.$mypath.'*\\\">\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tOrder Deny,Allow\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tDeny from All\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t</Directory>\\n\";\n\t\t\t\t *       end of dirprotection\n\t\t\t\t */\n\n\t\t\t\tif ($row_ipsandports['specialsettings'] != '' && ($row_ipsandports['ssl'] == '0' || ($row_ipsandports['ssl'] == '1' && Settings::Get('system.use_ssl') == '1' && $row_ipsandports['include_specialsettings'] == '1'))) {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->processSpecialConfigTemplate($row_ipsandports['specialsettings'], $domain, $row_ipsandports['ip'], $row_ipsandports['port'], $row_ipsandports['ssl'] == '1') . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($row_ipsandports['ssl'] == '1' && Settings::Get('system.use_ssl') == '1') {\n\t\t\t\t\tif ($row_ipsandports['ssl_specialsettings'] != '') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->processSpecialConfigTemplate($row_ipsandports['ssl_specialsettings'], $domain, $row_ipsandports['ip'], $row_ipsandports['port'], $row_ipsandports['ssl'] == '1') . \"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for required fallback\n\t\t\t\t\tif (($row_ipsandports['ssl_cert_file'] == '' || !file_exists($row_ipsandports['ssl_cert_file'])) && (Settings::Get('system.le_froxlor_enabled') == '0' || $this->froxlorVhostHasLetsEncryptCert() == false)) {\n\t\t\t\t\t\t$row_ipsandports['ssl_cert_file'] = Settings::Get('system.ssl_cert_file');\n\t\t\t\t\t\tif (!file_exists($row_ipsandports['ssl_cert_file'])) {\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate file \"' . Settings::Get('system.ssl_cert_file') . '\" does not seem to exist. Creating self-signed certificate...');\n\t\t\t\t\t\t\tCrypt::createSelfSignedCertificate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($row_ipsandports['ssl_key_file'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_key_file'] = Settings::Get('system.ssl_key_file');\n\t\t\t\t\t\tif (!file_exists($row_ipsandports['ssl_key_file'])) {\n\t\t\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t\t\t$row_ipsandports['ssl_cert_file'] = \"\";\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate key-file \"' . Settings::Get('system.ssl_key_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . Settings::Get('system.hostname') . '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($row_ipsandports['ssl_ca_file'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_ca_file'] = Settings::Get('system.ssl_ca_file');\n\t\t\t\t\t}\n\n\t\t\t\t\t// #418\n\t\t\t\t\tif ($row_ipsandports['ssl_cert_chainfile'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_cert_chainfile'] = Settings::Get('system.ssl_cert_chainfile');\n\t\t\t\t\t}\n\n\t\t\t\t\t$domain = [\n\t\t\t\t\t\t'id' => 0,\n\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t'customerroot' => $mypath,\n\t\t\t\t\t\t'parentdomainid' => 0,\n\t\t\t\t\t\t'ssl_honorcipherorder' => Settings::Get('system.honorcipherorder'),\n\t\t\t\t\t\t'ssl_sessiontickets' => Settings::Get('system.sessiontickets')\n\t\t\t\t\t];\n\n\t\t\t\t\t// override corresponding array values\n\t\t\t\t\t$domain['ssl_cert_file'] = $row_ipsandports['ssl_cert_file'];\n\t\t\t\t\t$domain['ssl_key_file'] = $row_ipsandports['ssl_key_file'];\n\t\t\t\t\t$domain['ssl_ca_file'] = $row_ipsandports['ssl_ca_file'];\n\t\t\t\t\t$domain['ssl_cert_chainfile'] = $row_ipsandports['ssl_cert_chainfile'];\n\n\t\t\t\t\t// SSL STUFF\n\t\t\t\t\t$dssl = new DomainSSL();\n\t\t\t\t\t// this sets the ssl-related array-indices in the $domain array\n\t\t\t\t\t// if the domain has customer-defined ssl-certificates\n\t\t\t\t\t$dssl->setDomainSSLFilesArray($domain);\n\n\t\t\t\t\tif ($domain['ssl_cert_file'] != '') {\n\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\tif (!file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate file \"' . $domain['ssl_cert_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLEngine On' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLProtocol -ALL +' . str_replace(\",\", \" +\", Settings::Get('system.ssl_protocols')) . \"\\n\";\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\tif (Settings::Get('system.http2_support') == '1') {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' Protocols h2 http/1.1' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!empty(Settings::Get('system.dhparams_file'))) {\n\t\t\t\t\t\t\t\t\t$dhparams = FileDir::makeCorrectFile(Settings::Get('system.dhparams_file'));\n\t\t\t\t\t\t\t\t\tif (!file_exists($dhparams)) {\n\t\t\t\t\t\t\t\t\t\tFileDir::safe_exec('openssl dhparam -out ' . escapeshellarg($dhparams) . ' 4096');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLOpenSSLConfCmd DHParameters \"' . $dhparams . '\"' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCompression Off' . \"\\n\";\n\t\t\t\t\t\t\t\tif (Settings::Get('system.sessionticketsenabled') == '1') {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLSessionTickets ' . ($domain['ssl_sessiontickets'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLHonorCipherOrder ' . ($domain['ssl_honorcipherorder'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCipherSuite ' . Settings::Get('system.ssl_cipher_list') . \"\\n\";\n\t\t\t\t\t\t\t$protocols = array_map('trim', explode(\",\", Settings::Get('system.ssl_protocols')));\n\t\t\t\t\t\t\tif (in_array(\"TLSv1.3\", $protocols) && !empty(Settings::Get('system.tlsv13_cipher_list')) && Settings::Get('system.apache24') == 1) {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCipherSuite TLSv1.3 ' . Settings::Get('system.tlsv13_cipher_list') . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLVerifyDepth 10' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateFile ' . FileDir::makeCorrectFile($domain['ssl_cert_file']) . \"\\n\";\n\n\t\t\t\t\t\t\tif ($domain['ssl_key_file'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_key_file'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate key file \"' . $domain['ssl_key_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateKeyFile ' . FileDir::makeCorrectFile($domain['ssl_key_file']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ($domain['ssl_ca_file'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_ca_file'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate CA file \"' . $domain['ssl_ca_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCACertificateFile ' . FileDir::makeCorrectFile($domain['ssl_ca_file']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// #418\n\t\t\t\t\t\t\tif ($domain['ssl_cert_chainfile'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_cert_chainfile'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate chain file \"' . $domain['ssl_cert_chainfile'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateChainFile ' . FileDir::makeCorrectFile($domain['ssl_cert_chainfile']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if there is no cert-file specified but we are generating a ssl-vhost,\n\t\t\t\t\t\t// we should return an empty string because this vhost would suck dick, ref #1583\n\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $domain['domain'] . ' :: empty certificate file! Cannot create ssl-directives');\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = $without_vhost;\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# no ssl-certificate was specified for this domain, therefore no explicit vhost-container is being generated';\n\t\t\t\t\t\t$close_vhost = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($close_vhost) {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '</VirtualHost>' . \"\\n\";\n\t\t\t\t}\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted vhostcontainer');\n\t\t\t}\n\t\t\tunset($vhosts_filename);\n\t\t}\n\n\t\t/**\n\t\t * bug #32\n\t\t */\n\t\t$this->createStandardDirectoryEntry();\n\n\t\t/**\n\t\t * bug #unknown-yet\n\t\t */\n\t\t$this->createStandardErrorHandler();\n\t}\n\n\t/**\n\t * define a standard <Directory>-statement, bug #32\n\t */\n\tprivate function createStandardDirectoryEntry()\n\t{\n\t\t$vhosts_folder = '';\n\t\tif (is_dir(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t$vhosts_folder = FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'));\n\t\t} else {\n\t\t\t$vhosts_folder = FileDir::makeCorrectDir(dirname(Settings::Get('system.apacheconf_vhost')));\n\t\t}\n\t\t$vhosts_filename = FileDir::makeCorrectFile($vhosts_folder . '/05_froxlor_dirfix_nofcgid.conf');\n\n\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t}\n\n\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . FileDir::makeCorrectDir(Settings::Get('system.documentroot_prefix')) . '\">' . \"\\n\";\n\n\t\t// check for custom values, see #1638\n\t\t$custom_opts = Settings::Get('system.apacheglobaldiropt');\n\t\tif (!empty($custom_opts)) {\n\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $custom_opts . \"\\n\";\n\t\t} else {\n\t\t\t// >=apache-2.4 enabled?\n\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t}\n\t\t}\n\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\n\t\t$ocsp_cache_filename = FileDir::makeCorrectFile($vhosts_folder . '/03_froxlor_ocsp_cache.conf');\n\t\tif (Settings::Get('system.use_ssl') == '1' && Settings::Get('system.apache24') == 1) {\n\t\t\t$this->virtualhosts_data[$ocsp_cache_filename] = 'SSLStaplingCache ' . Settings::Get('system.apache24_ocsp_cache_path') . \"\\n\";\n\t\t} else {\n\t\t\tif (file_exists($ocsp_cache_filename)) {\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::_createStandardDirectoryEntry: unlinking ' . basename($ocsp_cache_filename));\n\t\t\t\tunlink(FileDir::makeCorrectFile($ocsp_cache_filename));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * define a default ErrorDocument-statement, bug #unknown-yet\n\t */\n\tprivate function createStandardErrorHandler()\n\t{\n\t\tif (Settings::Get('defaultwebsrverrhandler.enabled') == '1' && (Settings::Get('defaultwebsrverrhandler.err401') != '' || Settings::Get('defaultwebsrverrhandler.err403') != '' || Settings::Get('defaultwebsrverrhandler.err404') != '' || Settings::Get('defaultwebsrverrhandler.err500') != '')) {\n\t\t\t$vhosts_folder = '';\n\t\t\tif (is_dir(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t\t$vhosts_folder = FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'));\n\t\t\t} else {\n\t\t\t\t$vhosts_folder = FileDir::makeCorrectDir(dirname(Settings::Get('system.apacheconf_vhost')));\n\t\t\t}\n\n\t\t\t$vhosts_filename = FileDir::makeCorrectFile($vhosts_folder . '/05_froxlor_default_errorhandler.conf');\n\n\t\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t\t}\n\n\t\t\t$statusCodes = [\n\t\t\t\t'401',\n\t\t\t\t'403',\n\t\t\t\t'404',\n\t\t\t\t'500'\n\t\t\t];\n\t\t\tforeach ($statusCodes as $statusCode) {\n\t\t\t\tif (Settings::Get('defaultwebsrverrhandler.err' . $statusCode) != '') {\n\t\t\t\t\t$defhandler = Settings::Get('defaultwebsrverrhandler.err' . $statusCode);\n\t\t\t\t\tif (!Validate::validateUrl($defhandler)) {\n\t\t\t\t\t\tif (substr($defhandler, 0, 1) != '\"' && substr($defhandler, -1, 1) != '\"') {\n\t\t\t\t\t\t\t$defhandler = '\"' . FileDir::makeCorrectFile($defhandler) . '\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'ErrorDocument ' . $statusCode . ' ' . $defhandler . \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function createOwnVhostStarter()\n\t{\n\t\treturn;\n\t}\n\n\t/**\n\t * We compose the virtualhost entries for the domains\n\t */\n\tpublic function createVirtualHosts()\n\t{\n\t\t$domains = WebserverBase::getVhostsToCreate();\n\t\tforeach ($domains as $domain) {\n\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'apache::createVirtualHosts: creating vhost container for domain ' . $domain['id'] . ', customer ' . $domain['loginname']);\n\t\t\t$vhosts_filename = $this->getVhostFilename($domain);\n\n\t\t\t// Apply header\n\t\t\t$this->virtualhosts_data[$vhosts_filename] = '# Domain ID: ' . $domain['id'] . ' - CustomerID: ' . $domain['customerid'] . ' - CustomerLogin: ' . $domain['loginname'] . \"\\n\";\n\n\t\t\t$ddr = Settings::Get('system.deactivateddocroot');\n\t\t\tif (($domain['deactivated'] == '1' || $domain['customer_deactivated'] == '1') && empty($ddr)) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# Customer/domain deactivated and a docroot for deactivated users hasn\\'t been set.' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t// Create vhost without ssl\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->getVhostContent($domain, false);\n\n\t\t\t\tif ($domain['ssl_enabled'] == '1' && ($domain['ssl'] == '1' || $domain['ssl_redirect'] == '1')) {\n\t\t\t\t\t// Adding ssl stuff if enabled\n\t\t\t\t\t$vhosts_filename_ssl = $this->getVhostFilename($domain, true);\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename_ssl] = '# Domain ID: ' . $domain['id'] . ' (SSL) - CustomerID: ' . $domain['customerid'] . ' - CustomerLogin: ' . $domain['loginname'] . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename_ssl] .= $this->getVhostContent($domain, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * We compose the virtualhost entry for one domain\n\t */\n\tprotected function getVhostContent($domain, $ssl_vhost = false)\n\t{\n\t\tif ($ssl_vhost === true && ($domain['ssl_redirect'] != '1' && $domain['ssl'] != '1')) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$query = \"SELECT * FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` `i`, `\" . TABLE_DOMAINTOIP . \"` `dip`\n\t\t\tWHERE dip.id_domain = :domainid AND i.id = dip.id_ipandports \";\n\n\t\tif ($ssl_vhost === true && ($domain['ssl'] == '1' || $domain['ssl_redirect'] == '1')) {\n\t\t\t// by ordering by cert-file the row with filled out SSL-Fields will be shown last, thus it is enough to fill out 1 set of SSL-Fields\n\t\t\t$query .= \"AND i.ssl = '1' ORDER BY i.ssl_cert_file ASC;\";\n\t\t} else {\n\t\t\t$query .= \"AND i.ssl = '0';\";\n\t\t}\n\n\t\t$vhost_content = '';\n\t\t$result_stmt = Database::prepare($query);\n\t\tDatabase::pexecute($result_stmt, [\n\t\t\t'domainid' => $domain['id']\n\t\t]);\n\n\t\t$ipportlist = '';\n\t\t$_vhost_content = '';\n\t\twhile ($ipandport = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$ipport = '';\n\t\t\t$domain['ip'] = $ipandport['ip'];\n\t\t\t$domain['port'] = $ipandport['port'];\n\t\t\tif ($domain['ssl'] == '1') {\n\t\t\t\t$domain['ssl_cert_file'] = $ipandport['ssl_cert_file'];\n\t\t\t\t$domain['ssl_key_file'] = $ipandport['ssl_key_file'];\n\t\t\t\t$domain['ssl_ca_file'] = $ipandport['ssl_ca_file'];\n\t\t\t\t$domain['ssl_cert_chainfile'] = $ipandport['ssl_cert_chainfile'];\n\n\t\t\t\t// SSL STUFF\n\t\t\t\t$dssl = new DomainSSL();\n\t\t\t\t// this sets the ssl-related array-indices in the $domain array\n\t\t\t\t// if the domain has customer-defined ssl-certificates\n\t\t\t\t$dssl->setDomainSSLFilesArray($domain);\n\t\t\t}\n\n\t\t\tif (filter_var($domain['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$ipport = '[' . $domain['ip'] . ']:' . $domain['port'] . ' ';\n\t\t\t} else {\n\t\t\t\t$ipport = $domain['ip'] . ':' . $domain['port'] . ' ';\n\t\t\t}\n\n\t\t\tif ($ipandport['default_vhostconf_domain'] != '' && ($ssl_vhost == false || ($ssl_vhost == true && $ipandport['include_default_vhostconf_domain'] == '1'))) {\n\t\t\t\t$_vhost_content .= $this->processSpecialConfigTemplate($ipandport['default_vhostconf_domain'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t\tif ($ipandport['ssl_default_vhostconf_domain'] != '' && $ssl_vhost == true) {\n\t\t\t\t$_vhost_content .= $this->processSpecialConfigTemplate($ipandport['ssl_default_vhostconf_domain'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t\t$ipportlist .= $ipport;\n\t\t}\n\n\t\t$vhost_content .= '<VirtualHost ' . trim($ipportlist) . '>' . \"\\n\";\n\t\t$vhost_content .= $this->getServerNames($domain);\n\n\t\t$domain['documentroot_norewrite'] = $domain['documentroot'];\n\t\tif (($ssl_vhost == false && $domain['ssl'] == '1' && $domain['ssl_redirect'] == '1')) {\n\t\t\t// We must not check if our port differs from port 443,\n\t\t\t// but if there is a destination-port != 443\n\t\t\t$_sslport = '';\n\t\t\t// This returns the first port that is != 443 with ssl enabled, if any\n\t\t\t// ordered by ssl-certificate (if any) so that the ip/port combo\n\t\t\t// with certificate is used\n\t\t\t$ssldestport_stmt = Database::prepare(\"\n\t\t\t\tSELECT `ip`.`port` FROM \" . TABLE_PANEL_IPSANDPORTS . \" `ip`\n\t\t\t\tLEFT JOIN `\" . TABLE_DOMAINTOIP . \"` `dip` ON (`ip`.`id` = `dip`.`id_ipandports`)\n\t\t\t\tWHERE `dip`.`id_domain` = :domainid\n\t\t\t\tAND `ip`.`ssl` = '1'  AND `ip`.`port` != 443\n\t\t\t\tORDER BY `ip`.`ssl_cert_file` DESC, `ip`.`port` LIMIT 1;\n\t\t\t\");\n\t\t\t$ssldestport = Database::pexecute_first($ssldestport_stmt, [\n\t\t\t\t'domainid' => $domain['id']\n\t\t\t]);\n\n\t\t\tif ($ssldestport && $ssldestport['port'] != '') {\n\t\t\t\t$_sslport = \":\" . $ssldestport['port'];\n\t\t\t}\n\n\t\t\t$domain['documentroot'] = 'https://%{HTTP_HOST}' . $_sslport . '/';\n\t\t\t$domain['documentroot_norewrite'] = 'https://' . $domain['domain'] . $_sslport . '/';\n\t\t}\n\n\t\tif ($ssl_vhost === true && $domain['ssl'] == '1' && Settings::Get('system.use_ssl') == '1') {\n\t\t\tif ($domain['ssl_cert_file'] == '' || !file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t$domain['ssl_cert_file'] = Settings::Get('system.ssl_cert_file');\n\t\t\t\tif (!file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t$domain['ssl_cert_file'] = \"\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate file \"' . Settings::Get('system.ssl_cert_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . $domain['domain'] . '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($domain['ssl_key_file'] == '' || !file_exists($domain['ssl_key_file'])) {\n\t\t\t\t$domain['ssl_key_file'] = Settings::Get('system.ssl_key_file');\n\t\t\t\tif (!file_exists($domain['ssl_key_file'])) {\n\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t$domain['ssl_cert_file'] = \"\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate key-file \"' . Settings::Get('system.ssl_key_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . $domain['domain'] . '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($domain['ssl_ca_file'] == '') {\n\t\t\t\t$domain['ssl_ca_file'] = Settings::Get('system.ssl_ca_file');\n\t\t\t}\n\n\t\t\tif ($domain['ssl_cert_chainfile'] == '') {\n\t\t\t\t$domain['ssl_cert_chainfile'] = Settings::Get('system.ssl_cert_chainfile');\n\t\t\t}\n\n\t\t\tif ($domain['ssl_cert_file'] != '') {\n\t\t\t\t$ssl_protocols = ($domain['override_tls'] == '1' && !empty($domain['ssl_protocols'])) ? $domain['ssl_protocols'] : Settings::Get('system.ssl_protocols');\n\t\t\t\t$ssl_cipher_list = ($domain['override_tls'] == '1' && !empty($domain['ssl_cipher_list'])) ? $domain['ssl_cipher_list'] : Settings::Get('system.ssl_cipher_list');\n\t\t\t\t$tlsv13_cipher_list = ($domain['override_tls'] == '1' && !empty($domain['tlsv13_cipher_list'])) ? $domain['tlsv13_cipher_list'] : Settings::Get('system.tlsv13_cipher_list');\n\n\t\t\t\t$vhost_content .= '  SSLEngine On' . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLProtocol -ALL +' . str_replace(\",\", \" +\", $ssl_protocols) . \"\\n\";\n\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\tif (isset($domain['http2']) && $domain['http2'] == '1' && Settings::Get('system.http2_support') == '1') {\n\t\t\t\t\t\t$vhost_content .= '  Protocols h2 http/1.1' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (!empty(Settings::Get('system.dhparams_file'))) {\n\t\t\t\t\t\t$dhparams = FileDir::makeCorrectFile(Settings::Get('system.dhparams_file'));\n\t\t\t\t\t\tif (!file_exists($dhparams)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('openssl dhparam -out ' . escapeshellarg($dhparams) . ' 4096');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$vhost_content .= '  SSLOpenSSLConfCmd DHParameters \"' . $dhparams . '\"' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$vhost_content .= '  SSLCompression Off' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.sessionticketsenabled') == '1') {\n\t\t\t\t\t\t$vhost_content .= '  SSLSessionTickets ' . ($domain['ssl_sessiontickets'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '  SSLHonorCipherOrder ' . ($domain['ssl_honorcipherorder'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLCipherSuite ' . $ssl_cipher_list . \"\\n\";\n\t\t\t\t$protocols = array_map('trim', explode(\",\", $ssl_protocols));\n\t\t\t\tif (in_array(\"TLSv1.3\", $protocols) && !empty($tlsv13_cipher_list) && Settings::Get('system.apache24') == 1) {\n\t\t\t\t\t$vhost_content .= '  SSLCipherSuite TLSv1.3 ' . $tlsv13_cipher_list . \"\\n\";\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '  SSLVerifyDepth 10' . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLCertificateFile ' . FileDir::makeCorrectFile($domain['ssl_cert_file']) . \"\\n\";\n\n\t\t\t\tif ($domain['ssl_key_file'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCertificateKeyFile ' . FileDir::makeCorrectFile($domain['ssl_key_file']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($domain['ssl_ca_file'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCACertificateFile ' . FileDir::makeCorrectFile($domain['ssl_ca_file']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($domain['ssl_cert_chainfile'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCertificateChainFile ' . FileDir::makeCorrectFile($domain['ssl_cert_chainfile']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (Settings::Get('system.apache24') == '1' && isset($domain['ocsp_stapling']) && $domain['ocsp_stapling'] == '1') {\n\t\t\t\t\t$vhost_content .= '  SSLUseStapling on' . PHP_EOL;\n\t\t\t\t}\n\n\t\t\t\tif ($domain['hsts'] >= 0) {\n\t\t\t\t\t$vhost_content .= '  <IfModule mod_headers.c>' . \"\\n\";\n\t\t\t\t\t$vhost_content .= '    Header always set Strict-Transport-Security \"max-age=' . $domain['hsts'];\n\t\t\t\t\tif ($domain['hsts_sub'] == 1) {\n\t\t\t\t\t\t$vhost_content .= '; includeSubDomains';\n\t\t\t\t\t}\n\t\t\t\t\tif ($domain['hsts_preload'] == 1) {\n\t\t\t\t\t\t$vhost_content .= '; preload';\n\t\t\t\t\t}\n\t\t\t\t\t$vhost_content .= '\"' . \"\\n\";\n\t\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if there is no cert-file specified but we are generating a ssl-vhost,\n\t\t\t\t// we should return an empty string because this vhost would suck dick, ref #1583\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $domain['domain'] . ' :: empty certificate file! Cannot create ssl-directives');\n\t\t\t\treturn '# no ssl-certificate was specified for this domain, therefore no explicit vhost is being generated';\n\t\t\t}\n\t\t}\n\n\t\t// avoid using any whitespaces\n\t\t$domain['documentroot'] = trim($domain['documentroot']);\n\n\t\tif (preg_match('/^https?\\:\\/\\//', $domain['documentroot'])) {\n\t\t\t$possible_deactivated_webroot = $this->getWebroot($domain);\n\t\t\tif ($this->deactivated == false) {\n\t\t\t\t$corrected_docroot = $domain['documentroot'];\n\n\t\t\t\t// Get domain's redirect code\n\t\t\t\t$code = Domain::getDomainRedirectCode($domain['id']);\n\t\t\t\t$modrew_red = '';\n\t\t\t\tif ($code != '') {\n\t\t\t\t\t$modrew_red = ' [R=' . $code . ';L,NE]';\n\t\t\t\t}\n\n\t\t\t\t// redirect everything, not only root-directory, #541\n\t\t\t\t$vhost_content .= '  <IfModule mod_rewrite.c>' . \"\\n\";\n\t\t\t\t$vhost_content .= '    RewriteEngine On' . \"\\n\";\n\t\t\t\tif (!$ssl_vhost) {\n\t\t\t\t\t$vhost_content .= '    RewriteCond %{HTTPS} off' . \"\\n\";\n\t\t\t\t}\n\t\t\t\tif ($domain['letsencrypt'] == '1') {\n\t\t\t\t\t$vhost_content .= '    RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge' . \"\\n\";\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '    RewriteRule ^/(.*) ' . $corrected_docroot . '$1' . $modrew_red . \"\\n\";\n\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t\t$vhost_content .= '  <IfModule !mod_rewrite.c>' . \"\\n\";\n\t\t\t\t$vhost_content .= '    Redirect ' . $code . ' / ' . $domain['documentroot_norewrite'] . \"\\n\";\n\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t} elseif (Settings::Get('system.deactivateddocroot') != '') {\n\t\t\t\t$vhost_content .= $possible_deactivated_webroot;\n\t\t\t}\n\t\t} else {\n\t\t\tFileDir::mkDirWithCorrectOwnership($domain['customerroot'], $domain['documentroot'], $domain['guid'], $domain['guid'], true, true);\n\t\t\t$vhost_content .= $this->getWebroot($domain);\n\t\t\tif ($this->deactivated == false) {\n\t\t\t\t$vhost_content .= $this->composePhpOptions($domain, $ssl_vhost);\n\t\t\t\t$vhost_content .= $this->getStats($domain);\n\t\t\t}\n\t\t\t$vhost_content .= $this->getLogfiles($domain);\n\n\t\t\tif ($domain['specialsettings'] != '' && ($ssl_vhost == false || ($ssl_vhost == true && $domain['include_specialsettings'] == 1))) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate($domain['specialsettings'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif ($domain['ssl_specialsettings'] != '' && $ssl_vhost == true) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate($domain['ssl_specialsettings'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif ($_vhost_content != '') {\n\t\t\t\t$vhost_content .= $_vhost_content;\n\t\t\t}\n\n\t\t\tif (Settings::Get('system.default_vhostconf') != '' && ($ssl_vhost == false || ($ssl_vhost == true && Settings::Get('system.include_default_vhostconf') == 1))) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate(Settings::Get('system.default_vhostconf'), $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif (Settings::Get('system.default_sslvhostconf') != '' && $ssl_vhost == true) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate(Settings::Get('system.default_sslvhostconf'), $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t}\n\n\t\t$vhost_content .= '</VirtualHost>' . \"\\n\";\n\n\t\treturn $vhost_content;\n\t}\n\n\t/**\n\t * We collect all servernames and Aliases\n\t */\n\tprotected function getServerNames($domain)\n\t{\n\t\t$servernames_text = '  ServerName ' . $domain['domain'] . \"\\n\";\n\n\t\t$server_alias = '';\n\t\tif ($domain['iswildcarddomain'] == '1') {\n\t\t\t$server_alias = '*.' . $domain['domain'];\n\t\t} elseif ($domain['wwwserveralias'] == '1') {\n\t\t\t$server_alias = 'www.' . $domain['domain'];\n\t\t}\n\n\t\tif (trim($server_alias) != '') {\n\t\t\t$servernames_text .= '  ServerAlias ' . $server_alias . \"\\n\";\n\t\t}\n\n\t\t$alias_domains_stmt = Database::prepare(\"\n\t\t\tSELECT `domain`, `iswildcarddomain`, `wwwserveralias`\n\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\tWHERE `aliasdomain`= :domainid\n\t\t\");\n\t\tDatabase::pexecute($alias_domains_stmt, [\n\t\t\t'domainid' => $domain['id']\n\t\t]);\n\n\t\twhile (($alias_domain = $alias_domains_stmt->fetch(PDO::FETCH_ASSOC)) !== false) {\n\t\t\t$server_alias = '  ServerAlias ' . $alias_domain['domain'];\n\n\t\t\tif ($alias_domain['iswildcarddomain'] == '1') {\n\t\t\t\t$server_alias .= ' *.' . $alias_domain['domain'];\n\t\t\t} else {\n\t\t\t\tif ($alias_domain['wwwserveralias'] == '1') {\n\t\t\t\t\t$server_alias .= ' www.' . $alias_domain['domain'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$servernames_text .= $server_alias . \"\\n\";\n\t\t}\n\n\t\t$servernames_text .= '  ServerAdmin ' . $domain['email'] . \"\\n\";\n\t\treturn $servernames_text;\n\t}\n\n\t/**\n\t * Let's get the webroot\n\t */\n\tprotected function getWebroot($domain)\n\t{\n\t\t$webroot_text = '';\n\t\t$domain['customerroot'] = FileDir::makeCorrectDir($domain['customerroot']);\n\t\t$domain['documentroot'] = FileDir::makeCorrectDir($domain['documentroot']);\n\n\t\tif (($domain['deactivated'] == '1' || $domain['customer_deactivated'] == '1') && Settings::Get('system.deactivateddocroot') != '') {\n\t\t\t$webroot_text .= '  # Using docroot for deactivated users/domains...' . \"\\n\";\n\t\t\t$webroot_text .= '  DocumentRoot \"' . rtrim(FileDir::makeCorrectDir(Settings::Get('system.deactivateddocroot')), \"/\") . \"\\\"\\n\";\n\t\t\t$webroot_text .= '  <Directory \"' . FileDir::makeCorrectDir(Settings::Get('system.deactivateddocroot')) . '\">' . \"\\n\";\n\t\t\t// >=apache-2.4 enabled?\n\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t$webroot_text .= '    Require all granted' . \"\\n\";\n\t\t\t\t$webroot_text .= '    AllowOverride All' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$webroot_text .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t$webroot_text .= '    allow from all' . \"\\n\";\n\t\t\t}\n\t\t\t$webroot_text .= '  </Directory>' . \"\\n\";\n\t\t\t$this->deactivated = true;\n\t\t} else {\n\t\t\t$webroot_text .= '  DocumentRoot \"' . rtrim($domain['documentroot'], \"/\") . \"\\\"\\n\";\n\t\t\t$this->deactivated = false;\n\t\t}\n\n\t\treturn $webroot_text;\n\t}\n\n\t/**\n\t * We put together the needed php options in the virtualhost entries\n\t *\n\t * @param array $domain\n\t * @param bool $ssl_vhost\n\t *\n\t * @return string\n\t */\n\tprotected function composePhpOptions(&$domain, $ssl_vhost = false)\n\t{\n\t\t$php_options_text = '';\n\n\t\tif ($domain['phpenabled_customer'] == 1 && $domain['phpenabled_vhost'] == '1') {\n\t\t\t// This vHost has PHP enabled and we are using the regular mod_php\n\t\t\t$cmail = Customer::getCustomerDetail($domain['customerid'], 'email');\n\t\t\t$php_options_text .= '  php_admin_value sendmail_path \"/usr/sbin/sendmail -t -f ' . $cmail . '\"' . PHP_EOL;\n\n\t\t\tif ($domain['openbasedir'] == '1') {\n\t\t\t\tif ($domain['openbasedir_path'] == '1' || strstr($domain['documentroot'], \":\") !== false) {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath($domain['customerroot'], true);\n\t\t\t\t} else if ($domain['openbasedir_path'] == '2' && strpos(dirname($domain['documentroot']).'/', $domain['customerroot']) !== false) {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath(dirname($domain['documentroot']).'/', true);\n\t\t\t\t} else {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath($domain['documentroot'], true);\n\t\t\t\t}\n\n\t\t\t\t$_custom_openbasedir = explode(':', Settings::Get('system.phpappendopenbasedir'));\n\t\t\t\tforeach ($_custom_openbasedir as $cobd) {\n\t\t\t\t\t$_phpappendopenbasedir .= Domain::appendOpenBasedirPath($cobd);\n\t\t\t\t}\n\n\t\t\t\t$php_options_text .= '  php_admin_value open_basedir \"' . $_phpappendopenbasedir . '\"' . \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\t$php_options_text .= '  # PHP is disabled for this vHost' . \"\\n\";\n\t\t\t$php_options_text .= '  php_flag engine off' . \"\\n\";\n\t\t}\n\n\t\t/**\n\t\t * check for apache-itk-support, #1400\n\t\t * why is this here? Because it only works with mod_php\n\t\t */\n\t\tif (Settings::get('system.apacheitksupport') == 1) {\n\t\t\t$php_options_text .= '  <IfModule mpm_itk_module>' . \"\\n\";\n\t\t\t$php_options_text .= '    AssignUserID ' . $domain['loginname'] . ' ' . $domain['loginname'] . \"\\n\";\n\t\t\t$php_options_text .= '  </IfModule>' . \"\\n\";\n\t\t}\n\n\t\treturn $php_options_text;\n\t}\n\n\t/**\n\t * Lets set the text part for the stats software\n\t */\n\tprotected function getStats($domain)\n\t{\n\t\t$stats_text = '';\n\n\t\t$statTool = Settings::Get('system.traffictool');\n\t\t$statDomain = \"\";\n\t\tif ($statTool == 'awstats') {\n\t\t\t// awstats generates for each domain regardless of speciallogfile\n\t\t\t$statDomain = \"/\" . $domain['domain'];\n\t\t}\n\t\tif ($domain['speciallogfile'] == '1') {\n\t\t\t$statDomain = \"/\" . (($domain['parentdomainid'] == '0') ? $domain['domain'] : $domain['parentdomain']);\n\t\t}\n\t\t$statDocroot = FileDir::makeCorrectFile($domain['customerroot'] . '/' . $statTool . $statDomain);\n\n\t\t$stats_text .= '  Alias /'.$statTool.' \"' . $statDocroot . '\"' . \"\\n\";\n\t\t// awstats special requirement for icons\n\t\tif ($statTool == 'awstats') {\n\t\t\t\t$stats_text .= '  Alias /awstats-icon \"' . FileDir::makeCorrectDir(Settings::Get('system.awstats_icons')) . '\"' . \"\\n\";\n\t\t}\n\n\t\treturn $stats_text;\n\t}\n\n\t/**\n\t * Lets set the logfiles\n\t */\n\tprotected function getLogfiles($domain)\n\t{\n\t\t$logfiles_text = '';\n\n\t\tif ($domain['speciallogfile'] == '1') {\n\t\t\tif ($domain['parentdomainid'] == '0') {\n\t\t\t\t$speciallogfile = '-' . $domain['domain'];\n\t\t\t} else {\n\t\t\t\t$speciallogfile = '-' . $domain['parentdomain'];\n\t\t\t}\n\t\t} else {\n\t\t\t$speciallogfile = '';\n\t\t}\n\n\t\tif ($domain['writeerrorlog']) {\n\t\t\t// The normal access/error - logging is enabled\n\t\t\t$error_log = FileDir::makeCorrectFile(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-error.log');\n\t\t\t// Create the logfile if it does not exist (fixes #46)\n\t\t\ttouch($error_log);\n\t\t\tchown($error_log, Settings::Get('system.httpuser'));\n\t\t\tchgrp($error_log, Settings::Get('system.httpgroup'));\n\t\t\t// set error log log-level\n\t\t\t$logfiles_text .= '  LogLevel ' . Settings::Get('system.errorlog_level') . \"\\n\";\n\t\t} else {\n\t\t\t$error_log = '/dev/null';\n\t\t}\n\n\t\tif ($domain['writeaccesslog']) {\n\t\t\t$access_log = FileDir::makeCorrectFile(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-access.log');\n\t\t\t// Create the logfile if it does not exist (fixes #46)\n\t\t\ttouch($access_log);\n\t\t\tchown($access_log, Settings::Get('system.httpuser'));\n\t\t\tchgrp($access_log, Settings::Get('system.httpgroup'));\n\t\t} else {\n\t\t\t$access_log = '/dev/null';\n\t\t}\n\n\t\t$logtype = 'combined';\n\t\tif (Settings::Get('system.logfiles_format') != '') {\n\t\t\t$logtype = 'frx_custom';\n\t\t\t$logfiles_text .= '  LogFormat ' . Settings::Get('system.logfiles_format') . ' ' . $logtype . \"\\n\";\n\t\t}\n\t\tif (Settings::Get('system.logfiles_type') == '2' && Settings::Get('system.logfiles_format') == '') {\n\t\t\t$logtype = 'vhost_combined';\n\t\t}\n\n\t\tif (Settings::Get('system.logfiles_piped') == '1' && Settings::Get('system.logfiles_script') != '') {\n\t\t\tif ($domain['writeerrorlog']) {\n\t\t\t\t// replace for error_log\n\t\t\t\t$command = PhpHelper::replaceVariables(Settings::Get('system.logfiles_script'), [\n\t\t\t\t\t'LOGFILE' => $error_log,\n\t\t\t\t\t'DOMAIN' => $domain['domain'],\n\t\t\t\t\t'CUSTOMER' => $domain['loginname']\n\t\t\t\t]);\n\t\t\t\t$logfiles_text .= '  ErrorLog \"|' . $command . \"\\\"\\n\";\n\t\t\t} else {\n\t\t\t\t$logfiles_text .= '  ErrorLog \"' . $error_log . '\"' . \"\\n\";\n\t\t\t}\n\t\t\tif ($domain['writeaccesslog']) {\n\t\t\t\t// replace for access_log\n\t\t\t\t$command = PhpHelper::replaceVariables(Settings::Get('system.logfiles_script'), [\n\t\t\t\t\t'LOGFILE' => $access_log,\n\t\t\t\t\t'DOMAIN' => $domain['domain'],\n\t\t\t\t\t'CUSTOMER' => $domain['loginname']\n\t\t\t\t]);\n\t\t\t\t$logfiles_text .= '  CustomLog \"|' . $command . '\" ' . $logtype . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$logfiles_text .= '  CustomLog \"' . $access_log . '\" ' . $logtype . \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\t$logfiles_text .= '  ErrorLog \"' . $error_log . '\"' . \"\\n\";\n\t\t\t$logfiles_text .= '  CustomLog \"' . $access_log . '\" ' . $logtype . \"\\n\";\n\t\t}\n\n\t\tif (Settings::Get('system.traffictool') == 'awstats') {\n\t\t\tif ((int)$domain['parentdomainid'] == 0) {\n\t\t\t\t// prepare the aliases and subdomains for stats config files\n\t\t\t\t$server_alias = '';\n\t\t\t\t$alias_domains_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `domain`, `iswildcarddomain`, `wwwserveralias`\n\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\tWHERE `aliasdomain` = :domainid OR `parentdomainid` = :domainid\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($alias_domains_stmt, [\n\t\t\t\t\t'domainid' => $domain['id']\n\t\t\t\t]);\n\n\t\t\t\twhile (($alias_domain = $alias_domains_stmt->fetch(PDO::FETCH_ASSOC)) !== false) {\n\t\t\t\t\t$server_alias .= ' ' . $alias_domain['domain'] . ' ';\n\n\t\t\t\t\tif ($alias_domain['iswildcarddomain'] == '1') {\n\t\t\t\t\t\t$server_alias .= '*.' . $alias_domain['domain'];\n\t\t\t\t\t} elseif ($alias_domain['wwwserveralias'] == '1') {\n\t\t\t\t\t\t$server_alias .= 'www.' . $alias_domain['domain'];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$alias = '';\n\t\t\t\tif ($domain['iswildcarddomain'] == '1') {\n\t\t\t\t\t$alias = '*.' . $domain['domain'];\n\t\t\t\t} elseif ($domain['wwwserveralias'] == '1') {\n\t\t\t\t\t$alias = 'www.' . $domain['domain'];\n\t\t\t\t}\n\n\t\t\t\t// After inserting the AWStats information,\n\t\t\t\t// be sure to build the awstats conf file as well\n\t\t\t\t// and chown it using $awstats_params, #258\n\t\t\t\t// Bug 960 + Bug 970 : Use full $domain instead of custom $awstats_params as following classes depend on the information\n\t\t\t\tStatistics::createAWStatsConf(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-access.log', $domain['domain'], $alias . $server_alias, $domain['customerroot'], $domain);\n\t\t\t}\n\t\t}\n\n\t\treturn $logfiles_text;\n\t}\n\n\t/**\n\t * We compose the diroption entries for the paths\n\t */\n\tpublic function createFileDirOptions()\n\t{\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `htac`.*, `c`.`guid`, `c`.`documentroot` AS `customerroot`\n\t\t\tFROM `\" . TABLE_PANEL_HTACCESS . \"` `htac`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_CUSTOMERS . \"` `c` USING (`customerid`)\n\t\t\tORDER BY `htac`.`path`\n\t\t\");\n\t\t$diroptions = [];\n\n\t\twhile ($row_diroptions = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif ($row_diroptions['customerid'] != 0 && isset($row_diroptions['customerroot']) && $row_diroptions['customerroot'] != '') {\n\t\t\t\t$diroptions[$row_diroptions['path']] = $row_diroptions;\n\t\t\t\t$diroptions[$row_diroptions['path']]['htpasswds'] = [];\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `htpw`.*, `c`.`guid`, `c`.`documentroot` AS `customerroot`\n\t\t\tFROM `\" . TABLE_PANEL_HTPASSWDS . \"` `htpw`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_CUSTOMERS . \"` `c` USING (`customerid`)\n\t\t\tORDER BY `htpw`.`path`, `htpw`.`username`\n\t\t\");\n\n\t\twhile ($row_htpasswds = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif ($row_htpasswds['customerid'] != 0 && isset($row_htpasswds['customerroot']) && $row_htpasswds['customerroot'] != '') {\n\t\t\t\tif (!isset($diroptions[$row_htpasswds['path']]) || !is_array($diroptions[$row_htpasswds['path']])) {\n\t\t\t\t\t$diroptions[$row_htpasswds['path']] = [];\n\t\t\t\t}\n\n\t\t\t\t$diroptions[$row_htpasswds['path']]['path'] = $row_htpasswds['path'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['guid'] = $row_htpasswds['guid'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['customerroot'] = $row_htpasswds['customerroot'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['customerid'] = $row_htpasswds['customerid'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['htpasswds'][] = $row_htpasswds;\n\t\t\t}\n\t\t}\n\n\t\tforeach ($diroptions as $row_diroptions) {\n\t\t\t$row_diroptions['path'] = FileDir::makeCorrectDir($row_diroptions['path']);\n\t\t\tFileDir::mkDirWithCorrectOwnership($row_diroptions['customerroot'], $row_diroptions['path'], $row_diroptions['guid'], $row_diroptions['guid']);\n\t\t\t$diroptions_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_diroptions') . '/40_froxlor_diroption_' . md5($row_diroptions['path']) . '.conf');\n\n\t\t\tif (!isset($this->diroptions_data[$diroptions_filename])) {\n\t\t\t\t$this->diroptions_data[$diroptions_filename] = '';\n\t\t\t}\n\n\t\t\tif (is_dir($row_diroptions['path'])) {\n\t\t\t\t$cperlenabled = Customer::customerHasPerlEnabled($row_diroptions['customerid']);\n\n\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '<Directory \"' . $row_diroptions['path'] . '\">' . \"\\n\";\n\n\t\t\t\tif (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '1') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Options +Indexes';\n\n\t\t\t\t\t// add perl options if enabled\n\t\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options +Indexes for ' . $row_diroptions['path']);\n\t\t\t\t}\n\n\t\t\t\tif (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '0') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Options -Indexes';\n\n\t\t\t\t\t// add perl options if enabled\n\t\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options -Indexes for ' . $row_diroptions['path']);\n\t\t\t\t}\n\n\t\t\t\t$statusCodes = [\n\t\t\t\t\t'404',\n\t\t\t\t\t'403',\n\t\t\t\t\t'500'\n\t\t\t\t];\n\t\t\t\tforeach ($statusCodes as $statusCode) {\n\t\t\t\t\tif (isset($row_diroptions['error' . $statusCode . 'path']) && $row_diroptions['error' . $statusCode . 'path'] != '') {\n\t\t\t\t\t\t$defhandler = $row_diroptions['error' . $statusCode . 'path'];\n\t\t\t\t\t\tif (!Validate::validateUrl($defhandler)) {\n\t\t\t\t\t\t\tif (substr($defhandler, 0, 1) != '\"' && substr($defhandler, -1, 1) != '\"') {\n\t\t\t\t\t\t\t\t$defhandler = '\"' . FileDir::makeCorrectFile($defhandler) . '\"';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  ErrorDocument ' . $statusCode . ' ' . $defhandler . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AllowOverride None' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AddHandler cgi-script .cgi .pl' . \"\\n\";\n\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$mypath_dir = new Directory($row_diroptions['path']);\n\t\t\t\t\t\t// only create the require all granted if there is not active directory-protection\n\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t// $this->diroptions_data[$diroptions_filename] .= ' AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Allow from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Enabling perl execution for ' . $row_diroptions['path']);\n\n\t\t\t\t\t// check for suexec-workaround, #319\n\t\t\t\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t\t\t\t// symlink this directory to suexec-safe-path\n\t\t\t\t\t\t$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');\n\t\t\t\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');\n\n\t\t\t\t\t\tif (!file_exists($suexecpath)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('mkdir -p ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t\tFileDir::safe_exec('chown -R ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// symlink to {$givenpath}/cgi-bin\n\t\t\t\t\t\t// NOTE: symlinks are FILES, so do not append a / here\n\t\t\t\t\t\t$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');\n\t\t\t\t\t\tif (!file_exists($perlsymlink)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('ln -s ' . escapeshellarg($suexecpath) . ' ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFileDir::safe_exec('chown -h ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if no perl-execution is enabled but the workaround is,\n\t\t\t\t\t// we have to remove the symlink and folder in suexecpath\n\t\t\t\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t\t\t\t$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');\n\t\t\t\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');\n\t\t\t\t\t\t$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');\n\n\t\t\t\t\t\t// remove symlink\n\t\t\t\t\t\tif (file_exists($perlsymlink)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('rm -f ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// remove folder in suexec-path\n\t\t\t\t\t\tif (file_exists($suexecpath)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('rm -rf ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (count($row_diroptions['htpasswds']) > 0) {\n\t\t\t\t\t$htpasswd_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_htpasswddir') . '/' . $row_diroptions['customerid'] . '-' . md5($row_diroptions['path']) . '.htpasswd');\n\n\t\t\t\t\tif (!isset($this->htpasswds_data[$htpasswd_filename])) {\n\t\t\t\t\t\t$this->htpasswds_data[$htpasswd_filename] = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach ($row_diroptions['htpasswds'] as $row_htpasswd) {\n\t\t\t\t\t\t$this->htpasswds_data[$htpasswd_filename] .= $row_htpasswd['username'] . ':' . $row_htpasswd['password'] . \"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthType Basic' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthName \"' . $row_htpasswd['authname'] . '\"' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthUserFile ' . $htpasswd_filename . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  require valid-user' . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '</Directory>' . \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * We write the configs\n\t */\n\tpublic function writeConfigs()\n\t{\n\t\t// Write diroptions\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_diroptions'));\n\n\t\tif (count($this->diroptions_data) > 0) {\n\t\t\t$optsDir = new Directory(Settings::Get('system.apacheconf_diroptions'));\n\t\t\tif (!$optsDir->isConfigDir()) {\n\t\t\t\t// Save one big file\n\t\t\t\t$diroptions_file = '';\n\n\t\t\t\tforeach ($this->diroptions_data as $diroptions_filename => $diroptions_content) {\n\t\t\t\t\t$diroptions_file .= $diroptions_content . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t$diroptions_filename = Settings::Get('system.apacheconf_diroptions');\n\n\t\t\t\t// Apply header\n\t\t\t\t$diroptions_file = '# ' . basename($diroptions_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $diroptions_file;\n\t\t\t\t$diroptions_file_handler = fopen($diroptions_filename, 'w');\n\t\t\t\tfwrite($diroptions_file_handler, $diroptions_file);\n\t\t\t\tfclose($diroptions_file_handler);\n\t\t\t} else {\n\t\t\t\tif (!file_exists(Settings::Get('system.apacheconf_diroptions'))) {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::writeConfigs: mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_diroptions'))));\n\t\t\t\t\tFileDir::safe_exec('mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_diroptions'))));\n\t\t\t\t}\n\n\t\t\t\t// Write a single file for every diroption\n\t\t\t\tforeach ($this->diroptions_data as $diroptions_filename => $diroptions_file) {\n\t\t\t\t\t$this->known_diroptionsfilenames[] = basename($diroptions_filename);\n\n\t\t\t\t\t// Apply header\n\t\t\t\t\t$diroptions_file = '# ' . basename($diroptions_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $diroptions_file;\n\t\t\t\t\t$diroptions_file_handler = fopen($diroptions_filename, 'w');\n\t\t\t\t\tfwrite($diroptions_file_handler, $diroptions_file);\n\t\t\t\t\tfclose($diroptions_file_handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Write htpasswds\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_htpasswddir'));\n\n\t\tif (count($this->htpasswds_data) > 0) {\n\t\t\tif (!file_exists(Settings::Get('system.apacheconf_htpasswddir'))) {\n\t\t\t\t$umask = umask();\n\t\t\t\tumask(0000);\n\t\t\t\tmkdir(Settings::Get('system.apacheconf_htpasswddir'), 0751);\n\t\t\t\tumask($umask);\n\t\t\t}\n\n\t\t\t$htpasswdDir = new Directory(Settings::Get('system.apacheconf_htpasswddir'));\n\t\t\tif ($htpasswdDir->isConfigDir(true)) {\n\t\t\t\tforeach ($this->htpasswds_data as $htpasswd_filename => $htpasswd_file) {\n\t\t\t\t\t$this->known_htpasswdsfilenames[] = basename($htpasswd_filename);\n\t\t\t\t\t$htpasswd_file_handler = fopen($htpasswd_filename, 'w');\n\t\t\t\t\tfwrite($htpasswd_file_handler, $htpasswd_file);\n\t\t\t\t\tfclose($htpasswd_file_handler);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_WARNING, 'WARNING!!! ' . Settings::Get('system.apacheconf_htpasswddir') . ' is not a directory. htpasswd directory protection is disabled!!!');\n\t\t\t}\n\t\t}\n\n\t\t// Write virtualhosts\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_vhost'));\n\n\t\tif (count($this->virtualhosts_data) > 0) {\n\t\t\t$vhostDir = new Directory(Settings::Get('system.apacheconf_vhost'));\n\t\t\tif (!$vhostDir->isConfigDir()) {\n\t\t\t\t// Save one big file\n\t\t\t\t$vhosts_file = '';\n\n\t\t\t\t// sort by filename so the order is:\n\t\t\t\t// 1. subdomains x-29\n\t\t\t\t// 2. subdomains as main-domains 30\n\t\t\t\t// 3. main-domains 35\n\t\t\t\t// #437\n\t\t\t\tksort($this->virtualhosts_data);\n\n\t\t\t\tforeach ($this->virtualhosts_data as $vhosts_filename => $vhost_content) {\n\t\t\t\t\t$vhosts_file .= $vhost_content . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t// Include diroptions file in case it exists\n\t\t\t\tif (file_exists(Settings::Get('system.apacheconf_diroptions'))) {\n\t\t\t\t\t$vhosts_file .= \"\\n\" . 'Include ' . Settings::Get('system.apacheconf_diroptions') . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t$vhosts_filename = Settings::Get('system.apacheconf_vhost');\n\n\t\t\t\t// Apply header\n\t\t\t\t$vhosts_file = '# ' . basename($vhosts_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $vhosts_file;\n\t\t\t\t$vhosts_file_handler = fopen($vhosts_filename, 'w');\n\t\t\t\tfwrite($vhosts_file_handler, $vhosts_file);\n\t\t\t\tfclose($vhosts_file_handler);\n\t\t\t} else {\n\t\t\t\tif (!file_exists(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::writeConfigs: mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'))));\n\t\t\t\t\tFileDir::safe_exec('mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'))));\n\t\t\t\t}\n\n\t\t\t\t// Write a single file for every vhost\n\t\t\t\tforeach ($this->virtualhosts_data as $vhosts_filename => $vhosts_file) {\n\t\t\t\t\t// Apply header\n\t\t\t\t\t$vhosts_file = '# ' . basename($vhosts_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $vhosts_file;\n\t\t\t\t\t$vhosts_file_handler = fopen($vhosts_filename, 'w');\n\t\t\t\t\tfwrite($vhosts_file_handler, $vhosts_file);\n\t\t\t\t\tfclose($vhosts_file_handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse PDO;\nuse RecursiveCallbackFilterIterator;\nuse Froxlor\\Customer\\Customer;\nuse Froxlor\\Database\\Database;\n\nclass FileDir\n{\n\t/**\n\t * Creates a directory below a users homedir and sets all directories,\n\t * which had to be created below with correct Owner/Group\n\t * (Copied from cron_tasks.php:rev1189 as we'll need this more often in future)\n\t *\n\t * @param string $homeDir The homedir of the user\n\t * @param string $dirToCreate The dir which should be created\n\t * @param int $uid The uid of the user\n\t * @param int $gid The gid of the user\n\t * @param bool $placeindex Place standard-index.html into the new folder\n\t * @param bool $allow_notwithinhomedir Allow creating a directory out of the customers docroot\n\t *\n\t * @return bool true if everything went okay, false if something went wrong\n\t * @throws Exception\n\t */\n\tpublic static function mkDirWithCorrectOwnership(\n\t\tstring $homeDir,\n\t\tstring $dirToCreate,\n\t\tint $uid,\n\t\tint $gid,\n\t\tbool $placeindex = false,\n\t\tbool $allow_notwithinhomedir = false\n\t): bool {\n\t\tif ($homeDir != '' && $dirToCreate != '') {\n\t\t\t$homeDir = self::makeCorrectDir($homeDir);\n\t\t\t$dirToCreate = self::makeCorrectDir($dirToCreate);\n\n\t\t\tif (substr($dirToCreate, 0, strlen($homeDir)) == $homeDir) {\n\t\t\t\t$subdir = substr($dirToCreate, strlen($homeDir) - 1);\n\t\t\t\t$within_homedir = true;\n\t\t\t} else {\n\t\t\t\t$subdir = $dirToCreate;\n\t\t\t\t$within_homedir = false;\n\t\t\t}\n\n\t\t\t$subdir = self::makeCorrectDir($subdir);\n\t\t\t$subdirs = [];\n\n\t\t\tif ($within_homedir || !$allow_notwithinhomedir) {\n\t\t\t\t$subdirlen = strlen($subdir);\n\t\t\t\t$offset = 0;\n\n\t\t\t\twhile ($offset < $subdirlen) {\n\t\t\t\t\t$offset = strpos($subdir, '/', $offset);\n\t\t\t\t\t$subdirelem = substr($subdir, 0, $offset);\n\t\t\t\t\t$offset++;\n\t\t\t\t\tarray_push($subdirs, self::makeCorrectDir($homeDir . $subdirelem));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarray_push($subdirs, $dirToCreate);\n\t\t\t}\n\n\t\t\t$subdirs = array_unique($subdirs);\n\t\t\tsort($subdirs);\n\t\t\tforeach ($subdirs as $sdir) {\n\t\t\t\tif (!is_dir($sdir)) {\n\t\t\t\t\t$sdir = self::makeCorrectDir($sdir);\n\t\t\t\t\tself::safe_exec('mkdir -p ' . escapeshellarg($sdir));\n\t\t\t\t\t// place index\n\t\t\t\t\tif ($placeindex) {\n\t\t\t\t\t\t$loginname = Customer::getLoginNameByUid($uid);\n\t\t\t\t\t\tif ($loginname !== false) {\n\t\t\t\t\t\t\tself::storeDefaultIndex($loginname, $sdir, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tself::safe_exec('chown -R ' . (int)$uid . ':' . (int)$gid . ' ' . escapeshellarg($sdir));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function which returns a correct dirname, means to add slashes at the beginning and at the end if there weren't\n\t * some\n\t *\n\t * @param string $dir the path to correct\n\t *\n\t * @return string the corrected path\n\t * @throws Exception\n\t */\n\tpublic static function makeCorrectDir(string $dir): string\n\t{\n\t\tif (strlen($dir) > 0) {\n\t\t\t$dir = trim($dir);\n\t\t\tif (substr($dir, -1, 1) != '/') {\n\t\t\t\t$dir .= '/';\n\t\t\t}\n\t\t\tif (substr($dir, 0, 1) != '/') {\n\t\t\t\t$dir = '/' . $dir;\n\t\t\t}\n\t\t\treturn self::makeSecurePath($dir);\n\t\t}\n\t\tthrow new Exception(\"Cannot validate directory in \" . __FUNCTION__ . \" which is very dangerous.\");\n\t}\n\n\t/**\n\t * Function which returns a secure path, means to remove all multiple dots and slashes\n\t *\n\t * @param string $path the path to secure\n\t *\n\t * @return string the corrected path\n\t */\n\tpublic static function makeSecurePath(string $path): string\n\t{\n\t\t// check for bad characters, some are allowed with escaping,\n\t\t// but we generally don't want them in our directory-names,\n\t\t// thx to aaronmueller for this snippet\n\t\t$badchars = [\n\t\t\t':',\n\t\t\t';',\n\t\t\t'|',\n\t\t\t'&',\n\t\t\t'>',\n\t\t\t'<',\n\t\t\t'`',\n\t\t\t'$',\n\t\t\t'~',\n\t\t\t'?',\n\t\t\t\"\\0\",\n\t\t\t\"\\n\",\n\t\t\t\"\\r\",\n\t\t\t\"\\t\",\n\t\t\t\"\\f\"\n\t\t];\n\t\tforeach ($badchars as $bc) {\n\t\t\t$path = str_replace($bc, \"\", $path);\n\t\t}\n\n\t\t$search = [\n\t\t\t'#/+#',\n\t\t\t'#\\.+#'\n\t\t];\n\t\t$replace = [\n\t\t\t'/',\n\t\t\t'.'\n\t\t];\n\t\t$path = preg_replace($search, $replace, $path);\n\t\t// don't just replace a space with an escaped space\n\t\t// it might be escaped already\n\t\t$path = str_replace(\"\\ \", \" \", $path);\n\t\t$path = str_replace(\" \", \"\\ \", $path);\n\n\t\treturn $path;\n\t}\n\n\t/**\n\t * Wrapper around the exec command.\n\t *\n\t * @param string $exec_string command to be executed\n\t * @param mixed $return_value referenced variable where the output is stored\n\t * @param ?array $allowedChars optional array of allowed characters in path/command\n\t *\n\t * @return array result of exec()\n\t */\n\tpublic static function safe_exec(string $exec_string, &$return_value = false, $allowedChars = null)\n\t{\n\t\t$disallowed = [\n\t\t\t';',\n\t\t\t'|',\n\t\t\t'&',\n\t\t\t'>',\n\t\t\t'<',\n\t\t\t'`',\n\t\t\t'$',\n\t\t\t'~',\n\t\t\t'?'\n\t\t];\n\n\t\t$acheck = false;\n\t\tif ($allowedChars != null && is_array($allowedChars) && count($allowedChars) > 0) {\n\t\t\t$acheck = true;\n\t\t}\n\n\t\tforeach ($disallowed as $dc) {\n\t\t\tif ($acheck && in_array($dc, $allowedChars)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// check for bad signs in execute command\n\t\t\tif (stristr($exec_string, $dc)) {\n\t\t\t\tdie(\"SECURITY CHECK FAILED!\\nThe execute string '\" . $exec_string . \"' is a possible security risk!\\nPlease check your whole server for security problems by hand!\\n\");\n\t\t\t}\n\t\t}\n\n\t\t// execute the command and return output\n\t\t$return = [];\n\n\t\t// -------------------------------------------------------------------------------\n\t\tif ($return_value == false) {\n\t\t\texec($exec_string, $return);\n\t\t} else {\n\t\t\texec($exec_string, $return, $return_value);\n\t\t}\n\n\t\treturn $return;\n\t}\n\n\t/**\n\t * store the default index-file in a given destination folder\n\t *\n\t * @param string $loginname customers loginname\n\t * @param string $destination path where to create the file\n\t * @param object $logger FroxlorLogger object\n\t * @param bool $force force creation whatever the settings say (needed for task #2, create new user)\n\t *\n\t * @return void\n\t * @throws Exception\n\t */\n\tpublic static function storeDefaultIndex(\n\t\tstring $loginname,\n\t\tstring $destination,\n\t\t$logger = null,\n\t\tbool $force = false\n\t) {\n\t\tif ($force || (int)Settings::Get('system.store_index_file_subs') == 1) {\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT `t`.`value`, `c`.`email` AS `customer_email`, `a`.`email` AS `admin_email`, `c`.`loginname` AS `customer_login`, `a`.`loginname` AS `admin_login`\n\t\t\tFROM `\" . TABLE_PANEL_CUSTOMERS . \"` AS `c` INNER JOIN `\" . TABLE_PANEL_ADMINS . \"` AS `a`\n\t\t\tON `c`.`adminid` = `a`.`adminid`\n\t\t\tINNER JOIN `\" . TABLE_PANEL_TEMPLATES . \"` AS `t`\n\t\t\tON `a`.`adminid` = `t`.`adminid`\n\t\t\tWHERE `varname` = 'index_html' AND `c`.`loginname` = :loginname\");\n\t\t\tDatabase::pexecute($result_stmt, [\n\t\t\t\t'loginname' => $loginname\n\t\t\t]);\n\n\t\t\tif (Database::num_rows() > 0) {\n\t\t\t\t$template = $result_stmt->fetch(PDO::FETCH_ASSOC);\n\n\t\t\t\t$replace_arr = [\n\t\t\t\t\t'SERVERNAME' => Settings::Get('system.hostname'),\n\t\t\t\t\t'CUSTOMER' => $template['customer_login'],\n\t\t\t\t\t'ADMIN' => $template['admin_login'],\n\t\t\t\t\t'CUSTOMER_EMAIL' => $template['customer_email'],\n\t\t\t\t\t'ADMIN_EMAIL' => $template['admin_email']\n\t\t\t\t];\n\n\t\t\t\t// replaceVariables\n\t\t\t\t$htmlcontent = PhpHelper::replaceVariables($template['value'], $replace_arr);\n\t\t\t\t$indexhtmlpath = self::makeCorrectFile($destination . '/index.' . Settings::Get('system.index_file_extension'));\n\t\t\t\t$index_html_handler = fopen($indexhtmlpath, 'w');\n\t\t\t\tfwrite($index_html_handler, $htmlcontent);\n\t\t\t\tfclose($index_html_handler);\n\t\t\t\tif ($logger !== null) {\n\t\t\t\t\t$logger->logAction(\n\t\t\t\t\t\tFroxlorLogger::CRON_ACTION,\n\t\t\t\t\t\tLOG_NOTICE,\n\t\t\t\t\t\t'Creating \\'index.' . Settings::Get('system.index_file_extension') . '\\' for Customer \\'' . $template['customer_login'] . '\\' based on template in directory ' . escapeshellarg($indexhtmlpath)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$destination = self::makeCorrectDir($destination);\n\t\t\t\tif ($logger !== null) {\n\t\t\t\t\t$logger->logAction(\n\t\t\t\t\t\tFroxlorLogger::CRON_ACTION,\n\t\t\t\t\t\tLOG_NOTICE,\n\t\t\t\t\t\t'Running: cp -a ' . Froxlor::getInstallDir() . '/templates/misc/standardcustomer/* ' . escapeshellarg($destination)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tself::safe_exec('cp -a ' . Froxlor::getInstallDir() . '/templates/misc/standardcustomer/* ' . escapeshellarg($destination));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function which returns a correct filename, means to add a slash at the beginning if there wasn't one\n\t *\n\t * @param string $filename the filename\n\t *\n\t * @return string the corrected filename\n\t */\n\tpublic static function makeCorrectFile(string $filename): string\n\t{\n\t\tif (trim($filename) == '') {\n\t\t\t$error = 'Given filename for function ' . __FUNCTION__ . ' is empty.' . \"\\n\";\n\t\t\t$error .= 'This is very dangerous and should not happen.' . \"\\n\";\n\t\t\t$error .= 'Please inform the Froxlor team about this issue so they can fix it.';\n\t\t\techo $error;\n\t\t\t// so we can see WHERE this happened\n\t\t\tdebug_print_backtrace();\n\t\t\tdie();\n\t\t}\n\n\t\tif (substr($filename, 0, 1) != '/') {\n\t\t\t$filename = '/' . $filename;\n\t\t}\n\n\t\treturn self::makeSecurePath($filename);\n\t}\n\n\t/**\n\t * checks a directory against disallowed paths which could\n\t * lead to a damaged system if you use them\n\t *\n\t * @param string|null $path\n\t *\n\t * @return bool\n\t * @throws Exception\n\t */\n\tpublic static function checkDisallowedPaths(string $path): bool\n\t{\n\t\t/*\n\t\t * disallow base-directories and /\n\t\t */\n\t\t$disallowed_values = [\n\t\t\t\"/\",\n\t\t\t\"/bin/\",\n\t\t\t\"/boot/\",\n\t\t\t\"/dev/\",\n\t\t\t\"/etc/\",\n\t\t\t\"/home/\",\n\t\t\t\"/lib/\",\n\t\t\t\"/lib32/\",\n\t\t\t\"/lib64/\",\n\t\t\t\"/opt/\",\n\t\t\t\"/proc/\",\n\t\t\t\"/root/\",\n\t\t\t\"/run/\",\n\t\t\t\"/sbin/\",\n\t\t\t\"/sys/\",\n\t\t\t\"/tmp/\",\n\t\t\t\"/usr/\",\n\t\t\t\"/var/\"\n\t\t];\n\n\t\t$path = self::makeCorrectDir($path);\n\n\t\t// check if it's a disallowed path\n\t\tif (in_array($path, $disallowed_values)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Function which returns a correct destination for Postfix Virtual Table\n\t *\n\t * @param string $destination The destinations\n\t *\n\t * @return string the corrected destinations\n\t */\n\tpublic static function makeCorrectDestination(string $destination): string\n\t{\n\t\t$search = '/ +/';\n\t\t$replace = ' ';\n\t\t$destination = preg_replace($search, $replace, $destination);\n\n\t\tif (substr($destination, 0, 1) == ' ') {\n\t\t\t$destination = substr($destination, 1);\n\t\t}\n\n\t\tif (substr($destination, -1, 1) == ' ') {\n\t\t\t$destination = substr($destination, 0, strlen($destination) - 1);\n\t\t}\n\n\t\treturn $destination;\n\t}\n\n\t/**\n\t * Returns a valid html tag for the chosen $fieldType for paths\n\t *\n\t * @param string $path The path to start searching in\n\t * @param int $uid The uid which must match the found directories\n\t * @param int $gid The gid which must match the found directories\n\t * @param string $value the value for the input-field\n\t * @param bool $dom\n\t *\n\t * @return array\n\t *\n\t * @throws Exception\n\t * @author Manuel Bernhardt <manuel.bernhardt@syscp.de>\n\t * @author Martin Burchert <martin.burchert@syscp.de>\n\t */\n\tpublic static function makePathfield(string $path, int $uid, int $gid, string $value = '', bool $dom = false): array\n\t{\n\t\t$value = str_replace($path, '', $value);\n\t\t$field = [];\n\n\t\t// path is given without starting slash\n\t\t// but dirList holds the paths with starting slash,\n\t\t// so we just add one here to get the correct\n\t\t// default path selected, #225\n\t\tif (substr($value, 0, 1) != '/' && !$dom) {\n\t\t\t$value = '/' . $value;\n\t\t}\n\n\t\t$fieldType = strtolower(Settings::Get('panel.pathedit'));\n\n\t\tif ($fieldType == 'manual') {\n\t\t\t$field = [\n\t\t\t\t'type' => 'text',\n\t\t\t\t'value' => htmlspecialchars($value)\n\t\t\t];\n\t\t} elseif ($fieldType == 'dropdown') {\n\t\t\t$dirList = self::findDirs($path, $uid, $gid);\n\t\t\tnatcasesort($dirList);\n\n\t\t\tif (sizeof($dirList) > 0) {\n\t\t\t\t$_field = [];\n\t\t\t\tforeach ($dirList as $dir) {\n\t\t\t\t\tif (strpos($dir, $path) === 0) {\n\t\t\t\t\t\t$dir = substr($dir, strlen($path));\n\t\t\t\t\t\t// docroot cut off of current directory == empty -> directory is the docroot\n\t\t\t\t\t\tif (empty($dir)) {\n\t\t\t\t\t\t\t$dir = '/';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$dir = self::makeCorrectDir($dir);\n\t\t\t\t\t}\n\t\t\t\t\t$_field[$dir] = $dir;\n\t\t\t\t}\n\t\t\t\t$field = [\n\t\t\t\t\t'type' => 'select',\n\t\t\t\t\t'select_var' => $_field,\n\t\t\t\t\t'selected' => $value,\n\t\t\t\t\t'value' => $value\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$field = [\n\t\t\t\t\t'type' => 'hidden',\n\t\t\t\t\t'value' => '/',\n\t\t\t\t\t'note' => lng('panel.dirsmissing')\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn $field;\n\t}\n\n\t/**\n\t * Returns an array of found directories\n\t *\n\t * This function checks every found directory if they match either $uid or $gid, if they do\n\t * the found directory is valid. It uses recursive-iterators to find subdirectories.\n\t *\n\t * @param string $path the path to start searching in\n\t * @param int $uid the uid which must match the found directories\n\t * @param int $gid the gid which must match the found directories\n\t *\n\t * @return array Array of found valid paths\n\t * @throws Exception\n\t */\n\tprivate static function findDirs(string $path, int $uid, int $gid): array\n\t{\n\t\t$_fileList = [];\n\t\t$path = self::makeCorrectDir($path);\n\n\t\t// valid directory?\n\t\tif (is_dir($path)) {\n\t\t\t// Will exclude everything under these directories\n\t\t\t$exclude = [\n\t\t\t\t'awstats',\n\t\t\t\t'webalizer',\n\t\t\t\t'goaccess'\n\t\t\t];\n\n\t\t\t/**\n\t\t\t *\n\t\t\t * @param SplFileInfo $file\n\t\t\t * @param mixed $key\n\t\t\t * @param RecursiveCallbackFilterIterator $iterator\n\t\t\t * @return bool True if you need to recurse or if the item is acceptable\n\t\t\t */\n\t\t\t$filter = function ($file, $key, $iterator) use ($exclude) {\n\t\t\t\tif (in_array($file->getFilename(), $exclude)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} elseif (substr($file->getFilename(), 0, 1) == '.') {\n\t\t\t\t\t// also hide hidden folders\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\t// create RecursiveIteratorIterator\n\t\t\t$its = new \\RecursiveIteratorIterator(\n\t\t\t\tnew \\RecursiveCallbackFilterIterator(\n\t\t\t\t\tnew \\RecursiveDirectoryIterator($path, \\RecursiveDirectoryIterator::SKIP_DOTS),\n\t\t\t\t\t$filter\n\t\t\t\t),\n\t\t\t\t\\RecursiveIteratorIterator::SELF_FIRST,\n\t\t\t\t\\RecursiveIteratorIterator::CATCH_GET_CHILD\n\t\t\t);\n\t\t\t// we can limit the recursion-depth, but will it be helpful or\n\t\t\t// will people start asking \"why do I only see 2 subdirectories, i want to use /a/b/c\"\n\t\t\t// let's keep this in mind and see whether it will be useful\n\t\t\t$its->setMaxDepth(2);\n\n\t\t\t// check every file\n\t\t\tforeach ($its as $fullFileName => $it) {\n\t\t\t\tif ($it->isDir() && (fileowner($fullFileName) == $uid || filegroup($fullFileName) == $gid)) {\n\t\t\t\t\t$_fileList[] = self::makeCorrectDir($fullFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$_fileList[] = $path;\n\t\t}\n\n\t\treturn array_unique($_fileList);\n\t}\n\n\t/**\n\t * set the immutable flag for a file\n\t *\n\t * @param string $filename the file to set the flag for\n\t *\n\t * @return void\n\t */\n\tpublic static function setImmutable(string $filename)\n\t{\n\t\tself::safe_exec(self::getImmutableFunction(false) . escapeshellarg($filename));\n\t}\n\n\t/**\n\t * internal function to check whether\n\t * to use chattr (Linux) or chflags (FreeBSD)\n\t *\n\t * @param bool $remove whether to use +i|schg (false) or -i|noschg (true)\n\t *\n\t * @return string functionname + parameter (not the file)\n\t */\n\tprivate static function getImmutableFunction(bool $remove = false): string\n\t{\n\t\tif (self::isFreeBSD()) {\n\t\t\t// FreeBSD style\n\t\t\treturn 'chflags ' . (($remove === true) ? 'noschg ' : 'schg ');\n\t\t} else {\n\t\t\t// Linux style\n\t\t\treturn 'chattr ' . (($remove === true) ? '-i ' : '+i ');\n\t\t}\n\t}\n\n\t/**\n\t * check if the system is FreeBSD (if exact)\n\t * or BSD-based (NetBSD, OpenBSD, etc.\n\t * if exact = false [default])\n\t *\n\t * @param bool $exact whether to check explicitly for FreeBSD or *BSD\n\t *\n\t * @return bool\n\t */\n\tpublic static function isFreeBSD(bool $exact = false): bool\n\t{\n\t\tif (($exact && PHP_OS == 'FreeBSD') || (!$exact && stristr(PHP_OS, 'BSD'))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * removes the immutable flag for a file\n\t *\n\t * @param string $filename the file to set the flag for\n\t *\n\t * @return void\n\t */\n\tpublic static function removeImmutable(string $filename)\n\t{\n\t\tFileDir::safe_exec(self::getImmutableFunction(true) . escapeshellarg($filename));\n\t}\n\n\t/**\n\t *\n\t * @return array|false\n\t */\n\tpublic static function getFilesystemQuota()\n\t{\n\t\t// enabled at all?\n\t\tif (Settings::Get('system.diskquota_enabled')) {\n\t\t\t// set linux defaults\n\t\t\t$repquota_params = \"-np\";\n\t\t\t// $quota_line_regex = \"/^#([0-9]+)\\s*[+-]{2}\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)/i\";\n\t\t\t$quota_line_regex = \"/^#([0-9]+)\\s+[+-]{2}\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/i\";\n\n\t\t\t// check for freebsd - which needs other values\n\t\t\tif (self::isFreeBSD()) {\n\t\t\t\t$repquota_params = \"-nu\";\n\t\t\t\t$quota_line_regex = \"/^([0-9]+)\\s+[+-]{2}\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)/i\";\n\t\t\t}\n\n\t\t\t// Fetch all quota in the desired partition\n\t\t\t$repquota = [];\n\t\t\texec(\n\t\t\t\tSettings::Get('system.diskquota_repquota_path') . \" \" . $repquota_params . \" \" . escapeshellarg(Settings::Get('system.diskquota_customer_partition')),\n\t\t\t\t$repquota\n\t\t\t);\n\n\t\t\t$usedquota = [];\n\t\t\tforeach ($repquota as $tmpquota) {\n\t\t\t\t$matches = null;\n\t\t\t\t// Let's see if the line matches a quota - line\n\t\t\t\tif (preg_match($quota_line_regex, $tmpquota, $matches)) {\n\t\t\t\t\t// It matches - put it into an array with userid as key (for easy lookup later)\n\t\t\t\t\t$usedquota[$matches[1]] = [\n\t\t\t\t\t\t'block' => [\n\t\t\t\t\t\t\t'used' => $matches[2],\n\t\t\t\t\t\t\t'soft' => $matches[3],\n\t\t\t\t\t\t\t'hard' => $matches[4],\n\t\t\t\t\t\t\t'grace' => (self::isFreeBSD() ? '0' : $matches[5])\n\t\t\t\t\t\t],\n\t\t\t\t\t\t'file' => [\n\t\t\t\t\t\t\t'used' => $matches[6],\n\t\t\t\t\t\t\t'soft' => $matches[7],\n\t\t\t\t\t\t\t'hard' => $matches[8],\n\t\t\t\t\t\t\t'grace' => (self::isFreeBSD() ? '0' : $matches[9])\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $usedquota;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "<?php\nuse PHPUnit\\Framework\\TestCase;\n\nuse Froxlor\\Api\\Commands\\Admins;\nuse Froxlor\\Api\\Commands\\Customers;\nuse Froxlor\\Api\\Commands\\Ftps;\n\n/**\n *\n * @covers \\Froxlor\\Api\\ApiCommand\n * @covers \\Froxlor\\Api\\ApiParameter\n * @covers \\Froxlor\\Api\\Commands\\Admins\n * @covers \\Froxlor\\Api\\Commands\\Customers\n * @covers \\Froxlor\\Api\\Commands\\Ftps\n */\nclass FtpsTest extends TestCase\n{\n\n\tpublic function testAdminFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\t// should be the ftp user of the first added customr 'test1'\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testResellerFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get reseller\n\t\t$json_result = Admins::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'reseller'\n\t\t))->get();\n\t\t$reseller_userdata = json_decode($json_result, true)['data'];\n\t\t$reseller_userdata['adminsession'] = 1;\n\t\t$json_result = Ftps::getLocal($reseller_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$json_result = Ftps::getLocal($customer_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\t// should be the ftp user of the first added customr 'test1'\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsGetOtherId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$this->expectExceptionCode(404);\n\n\t\tFtps::getLocal($customer_userdata, array(\n\t\t\t'id' => 10\n\t\t))->get();\n\t}\n\n\tpublic function testAdminFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(2, $result['count']);\n\n\t\t$json_result = Ftps::getLocal($admin_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(2, $result);\n\t}\n\n\tpublic function testAdminFtpsListSpecificCustomer()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\t}\n\n\tpublic function testResellerFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get reseller\n\t\t$json_result = Admins::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'reseller'\n\t\t))->get();\n\t\t$reseller_userdata = json_decode($json_result, true)['data'];\n\t\t$reseller_userdata['adminsession'] = 1;\n\t\t$json_result = Ftps::getLocal($reseller_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\n\t\t$json_result = Ftps::getLocal($reseller_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result);\n\t}\n\n\tpublic function testCustomerFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$json_result = Ftps::getLocal($customer_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\n\t\t$json_result = Ftps::getLocal($customer_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result);\n\t}\n\n\tpublic function testCustomerFtpsAdd()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->add();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'], $result['homedir']);\n\t}\n\n\tpublic function testCustomerFtpsAddNoMoreResources()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data']; //\n\n\t\t$customer_userdata['ftps_used'] = 100;\n\n\t\t$this->expectExceptionCode(406);\n\t\t$this->expectExceptionMessage('No more resources available');\n\t\t$json_result = Ftps::getLocal($customer_userdata)->add();\n\t}\n\n\tpublic function testAdminFtpsAddCustomerRequired()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$data = [\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => 1\n\t\t];\n\n\t\t$this->expectExceptionCode(406);\n\t\t$this->expectExceptionMessage('Requested parameter \"loginname\" is empty where it should not be for \"Customers:get\"');\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->add();\n\t}\n\n\tpublic function testCustomerFtpsEdit()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1',\n\t\t\t'ftp_password' => 'h4xXx0r2',\n\t\t\t'path' => '/subfolder',\n\t\t\t'ftp_description' => 'testing2'\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->update();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'] . 'subfolder/', $result['homedir']);\n\t\t$this->assertEquals('testing2', $result['description']);\n\t}\n\n\tpublic function testAdminFtpsEdit()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1',\n\t\t\t'customerid' => 1,\n\t\t\t'ftp_password' => 'h4xXx0r2',\n\t\t\t'path' => '/anotherfolder',\n\t\t\t'ftp_description' => 'testing3'\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->update();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'] . 'anotherfolder/', $result['homedir']);\n\t\t$this->assertEquals('testing3', $result['description']);\n\t}\n\n\tpublic function testAdminFtpsAdd()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'customerid' => $customer_userdata['customerid'],\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->add();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'], $result['homedir']);\n\t}\n\n\tpublic function testCustomerFtpsDelete()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1'\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->delete();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1ftp1', $result['username']);\n\t}\n\n\tpublic function testAdminFtpsDelete()\n\t{\n\t\tglobal $admin_userdata;\n\t\t$data = [\n\t\t\t'username' => 'test1ftp2'\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->delete();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1ftp2', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsDeleteDefaultUser()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1'\n\t\t];\n\t\t$this->expectExceptionCode(400);\n\t\t$this->expectExceptionMessage('You cannot delete your main FTP account');\n\t\tFtps::getLocal($customer_userdata, $data)->delete();\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nconst AREA = 'customer';\nrequire __DIR__ . '/lib/init.php';\n\nuse Froxlor\\Api\\Commands\\Ftps as Ftps;\nuse Froxlor\\CurrentUser;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\UI\\Collection;\nuse Froxlor\\UI\\HTML;\nuse Froxlor\\UI\\Listing;\nuse Froxlor\\UI\\Panel\\UI;\nuse Froxlor\\UI\\Request;\nuse Froxlor\\UI\\Response;\n\n// redirect if this customer page is hidden via settings\nif (Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\tResponse::redirectTo('customer_index.php');\n}\n\n$id = (int)Request::any('id', 0);\n\nif ($page == 'overview' || $page == 'accounts') {\n\tif ($action == '') {\n\t\t$log->logAction(FroxlorLogger::USR_ACTION, LOG_NOTICE, \"viewed customer_ftp::accounts\");\n\t\ttry {\n\t\t\t$ftp_list_data = include_once dirname(__FILE__) . '/lib/tablelisting/customer/tablelisting.ftps.php';\n\t\t\t$collection = (new Collection(Ftps::class, $userinfo))\n\t\t\t\t->withPagination($ftp_list_data['ftp_list']['columns'], $ftp_list_data['ftp_list']['default_sorting']);\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\n\t\t$actions_links = [];\n\t\tif (CurrentUser::canAddResource('ftps')) {\n\t\t\t$actions_links[] = [\n\t\t\t\t'href' => $linker->getLink(['section' => 'ftp', 'page' => 'accounts', 'action' => 'add']),\n\t\t\t\t'label' => lng('ftp.account_add')\n\t\t\t];\n\t\t}\n\t\t$actions_links[] = [\n\t\t\t'href' => 'https://docs.froxlor.org/v2/user-guide/ftp-accounts/',\n\t\t\t'target' => '_blank',\n\t\t\t'icon' => 'fa-solid fa-circle-info',\n\t\t\t'class' => 'btn-outline-secondary'\n\t\t];\n\n\t\tUI::view('user/table.html.twig', [\n\t\t\t'listing' => Listing::format($collection, $ftp_list_data, 'ftp_list'),\n\t\t\t'actions_links' => $actions_links,\n\t\t\t'entity_info' => lng('ftp.description')\n\t\t]);\n\t} elseif ($action == 'delete' && $id != 0) {\n\t\ttry {\n\t\t\t$json_result = Ftps::getLocal($userinfo, [\n\t\t\t\t'id' => $id\n\t\t\t])->get();\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\tif (isset($result['username']) && $result['username'] != $userinfo['loginname']) {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->delete();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tHTML::askYesNoWithCheckbox('ftp_reallydelete', 'admin_customer_alsoremoveftphomedir', $filename, [\n\t\t\t\t\t'id' => $id,\n\t\t\t\t\t'page' => $page,\n\t\t\t\t\t'action' => $action\n\t\t\t\t], $result['username']);\n\t\t\t}\n\t\t} else {\n\t\t\tResponse::standardError('ftp_cantdeletemainaccount');\n\t\t}\n\t} elseif ($action == 'add') {\n\t\tif ($userinfo['ftps_used'] < $userinfo['ftps'] || $userinfo['ftps'] == '-1') {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->add();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\t$pathSelect = FileDir::makePathfield($userinfo['documentroot'], $userinfo['guid'], $userinfo['guid'], '/');\n\n\t\t\t\tif (Settings::Get('customer.ftpatdomain') == '1') {\n\t\t\t\t\t$domainlist = [];\n\t\t\t\t\t$result_domains_stmt = Database::prepare(\"SELECT `domain` FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\t\tWHERE `customerid`= :customerid ORDER BY `domain` ASC\");\n\t\t\t\t\tDatabase::pexecute($result_domains_stmt, [\n\t\t\t\t\t\t\"customerid\" => $userinfo['customerid']\n\t\t\t\t\t]);\n\n\t\t\t\t\twhile ($row_domain = $result_domains_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t\t$domainlist[$row_domain['domain']] = $idna_convert->decode($row_domain['domain']);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t\t$shells['/bin/false'] = \"/bin/false\";\n\t\t\t\t\t$shells_avail = Settings::Get('system.available_shells');\n\t\t\t\t\tif (!empty($shells_avail)) {\n\t\t\t\t\t\t$shells_avail_arr = explode(\",\", $shells_avail);\n\t\t\t\t\t\t$shells_avail_arr = array_map(\"trim\", $shells_avail_arr);\n\t\t\t\t\t\tforeach ($shells_avail_arr as $shell) {\n\t\t\t\t\t\t\t$shells[$shell] = $shell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$ftp_add_data = include_once dirname(__FILE__) . '/lib/formfields/customer/ftp/formfield.ftp_add.php';\n\n\t\t\t\tUI::view('user/form.html.twig', [\n\t\t\t\t\t'formaction' => $linker->getLink(['section' => 'ftp']),\n\t\t\t\t\t'formdata' => $ftp_add_data['ftp_add']\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t} elseif ($action == 'edit' && $id != 0) {\n\t\ttry {\n\t\t\t$json_result = Ftps::getLocal($userinfo, [\n\t\t\t\t'id' => $id\n\t\t\t])->get();\n\t\t} catch (Exception $e) {\n\t\t\tResponse::dynamicError($e->getMessage());\n\t\t}\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\tif (isset($result['username']) && $result['username'] != '') {\n\t\t\tif (isset($_POST['send']) && $_POST['send'] == 'send') {\n\t\t\t\ttry {\n\t\t\t\t\tFtps::getLocal($userinfo, $_POST)->update();\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\tResponse::dynamicError($e->getMessage());\n\t\t\t\t}\n\t\t\t\tResponse::redirectTo($filename, [\n\t\t\t\t\t'page' => $page\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tif (strpos($result['homedir'], $userinfo['documentroot']) === 0) {\n\t\t\t\t\t$homedir = str_replace($userinfo['documentroot'], \"/\", $result['homedir']);\n\t\t\t\t} else {\n\t\t\t\t\t$homedir = $result['homedir'];\n\t\t\t\t}\n\t\t\t\t$homedir = FileDir::makeCorrectDir($homedir);\n\n\t\t\t\t$pathSelect = FileDir::makePathfield($userinfo['documentroot'], $userinfo['guid'], $userinfo['guid'], $homedir);\n\n\t\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t\t$shells['/bin/false'] = \"/bin/false\";\n\t\t\t\t\t$shells_avail = Settings::Get('system.available_shells');\n\t\t\t\t\tif (!empty($shells_avail)) {\n\t\t\t\t\t\t$shells_avail_arr = explode(\",\", $shells_avail);\n\t\t\t\t\t\t$shells_avail_arr = array_map(\"trim\", $shells_avail_arr);\n\t\t\t\t\t\tforeach ($shells_avail_arr as $shell) {\n\t\t\t\t\t\t\t$shells[$shell] = $shell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$ftp_edit_data = include_once dirname(__FILE__) . '/lib/formfields/customer/ftp/formfield.ftp_edit.php';\n\n\t\t\t\tUI::view('user/form.html.twig', [\n\t\t\t\t\t'formaction' => $linker->getLink(['section' => 'ftp', 'id' => $id]),\n\t\t\t\t\t'formdata' => $ftp_edit_data['ftp_edit'],\n\t\t\t\t\t'editid' => $id\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass DirOptions extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add options for a given directory\n\t *\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $path\n\t *            path relative to the customer's home-Directory\n\t * @param bool $options_indexes\n\t *            optional, activate directory-listing for this path, default 0 (false)\n\t * @param bool $options_cgi\n\t *            optional, allow Perl/CGI execution, default 0 (false)\n\t * @param string $error404path\n\t *            optional, custom 404 error string/file\n\t * @param string $error403path\n\t *            optional, custom 403 error string/file\n\t * @param string $error500path\n\t *            optional, custom 500 error string/file\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// required parameters\n\t\t$path = $this->getParam('path');\n\n\t\t// parameters\n\t\t$options_indexes = $this->getBoolParam('options_indexes', true, 0);\n\t\t$options_cgi = $this->getBoolParam('options_cgi', true, 0);\n\t\t$error404path = $this->getParam('error404path', true, '');\n\t\t$error403path = $this->getParam('error403path', true, '');\n\t\t$error500path = $this->getParam('error500path', true, '');\n\n\t\t// validation\n\t\t$path = FileDir::makeCorrectDir(Validate::validate($path, 'path', Validate::REGEX_DIR, '', [], true));\n\t\t$userpath = $path;\n\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path, $customer['documentroot']);\n\n\t\tif (!empty($error404path)) {\n\t\t\t$error404path = $this->correctErrorDocument($error404path, true);\n\t\t}\n\n\t\tif (!empty($error403path)) {\n\t\t\t$error403path = $this->correctErrorDocument($error403path, true);\n\t\t}\n\n\t\tif (!empty($error500path)) {\n\t\t\t$error500path = $this->correctErrorDocument($error500path, true);\n\t\t}\n\n\t\t// check for duplicate path\n\t\t$path_dupe_check_stmt = Database::prepare(\"\n\t\t\tSELECT `id`, `path` FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `path`= :path AND `customerid`= :customerid\n\t\t\");\n\t\t$path_dupe_check = Database::pexecute_first($path_dupe_check_stmt, [\n\t\t\t\"path\" => $path,\n\t\t\t\"customerid\" => $customer['customerid']\n\t\t], true, true);\n\n\t\t// duplicate check\n\t\tif ($path_dupe_check && $path_dupe_check['path'] == $path) {\n\t\t\tResponse::standardError('errordocpathdupe', $userpath, true);\n\t\t}\n\n\t\t// insert the entry\n\t\t$stmt = Database::prepare('\n\t\t\tINSERT INTO `' . TABLE_PANEL_HTACCESS . '` SET\n\t\t\t`customerid` = :customerid,\n\t\t\t`path` = :path,\n\t\t\t`options_indexes` = :options_indexes,\n\t\t\t`error404path` = :error404path,\n\t\t\t`error403path` = :error403path,\n\t\t\t`error500path` = :error500path,\n\t\t\t`options_cgi` = :options_cgi\n\t\t');\n\t\t$params = [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"path\" => $path,\n\t\t\t\"options_indexes\" => $options_indexes,\n\t\t\t\"error403path\" => $error403path,\n\t\t\t\"error404path\" => $error404path,\n\t\t\t\"error500path\" => $error500path,\n\t\t\t\"options_cgi\" => $options_cgi\n\t\t];\n\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t$id = Database::lastInsertId();\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added directory-option for '\" . $userpath . \"'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * this functions validates a given value as ErrorDocument\n\t * refs #267\n\t *\n\t * @param string $errdoc\n\t * @param bool $throw_exception\n\t *\n\t * @return string error-document-string\n\t *\n\t */\n\tprivate function correctErrorDocument(string $errdoc, $throw_exception = false)\n\t{\n\t\tif (trim($errdoc) != '') {\n\t\t\t// not a URL\n\t\t\tif ((strtoupper(substr($errdoc, 0, 5)) != 'HTTP:' && strtoupper(substr($errdoc, 0, 6)) != 'HTTPS:') || !Validate::validateUrl($errdoc)) {\n\t\t\t\t// a file\n\t\t\t\tif (substr($errdoc, 0, 1) != '\"') {\n\t\t\t\t\t$errdoc = FileDir::makeCorrectFile($errdoc);\n\t\t\t\t\t// apache needs a starting-slash (starting at the domains-docroot)\n\t\t\t\t\tif (!substr($errdoc, 0, 1) == '/') {\n\t\t\t\t\t\t$errdoc = '/' . $errdoc;\n\t\t\t\t\t}\n\t\t\t\t} elseif (preg_match('/^\"([^\\r\\n\\t\\f\\0\"]+)\"$/', $errdoc)) {\n\t\t\t\t\t// a string (check for ending \")\n\t\t\t\t\t// string won't work for lighty\n\t\t\t\t\tif (Settings::Get('system.webserver') == 'lighttpd') {\n\t\t\t\t\t\tResponse::standardError('stringerrordocumentnotvalidforlighty', '', $throw_exception);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('invaliderrordocumentvalue', '', $throw_exception);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Settings::Get('system.webserver') == 'lighttpd') {\n\t\t\t\t\tResponse::standardError('urlerrordocumentnotvalidforlighty', '', $throw_exception);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn trim($errdoc);\n\t}\n\n\t/**\n\t * return a directory-protection entry by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND `id` = :id\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\t\tWHERE `id` = :id\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['id'] = $id;\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get directory options for '\" . $result['path'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = \"id #\" . $id;\n\t\tthrow new Exception(\"Directory option with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update options for a given directory by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param bool $options_indexes\n\t *            optional, activate directory-listing for this path, default 0 (false)\n\t * @param bool $options_cgi\n\t *            optional, allow Perl/CGI execution, default 0 (false)\n\t * @param string $error404path\n\t *            optional, custom 404 error string/file\n\t * @param string $error403path\n\t *            optional, custom 403 error string/file\n\t * @param string $error500path\n\t *            optional, custom 500 error string/file\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\n\t\t// validation\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// parameters\n\t\t$options_indexes = $this->getBoolParam('options_indexes', true, $result['options_indexes']);\n\t\t$options_cgi = $this->getBoolParam('options_cgi', true, $result['options_cgi']);\n\t\t$error404path = $this->getParam('error404path', true, $result['error404path']);\n\t\t$error403path = $this->getParam('error403path', true, $result['error403path']);\n\t\t$error500path = $this->getParam('error500path', true, $result['error500path']);\n\n\t\tif (!empty($error404path)) {\n\t\t\t$error404path = $this->correctErrorDocument($error404path, true);\n\t\t}\n\n\t\tif (!empty($error403path)) {\n\t\t\t$error403path = $this->correctErrorDocument($error403path, true);\n\t\t}\n\n\t\tif (!empty($error500path)) {\n\t\t\t$error500path = $this->correctErrorDocument($error500path, true);\n\t\t}\n\n\t\tif (($options_indexes != $result['options_indexes']) || ($error404path != $result['error404path']) || ($error403path != $result['error403path']) || ($error500path != $result['error500path']) || ($options_cgi != $result['options_cgi'])) {\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\t\tSET `options_indexes` = :options_indexes,\n\t\t\t\t`error404path` = :error404path,\n\t\t\t\t`error403path` = :error403path,\n\t\t\t\t`error500path` = :error500path,\n\t\t\t\t`options_cgi` = :options_cgi\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"options_indexes\" => $options_indexes,\n\t\t\t\t\"error403path\" => $error403path,\n\t\t\t\t\"error404path\" => $error404path,\n\t\t\t\t\"error500path\" => $error500path,\n\t\t\t\t\"options_cgi\" => $options_cgi,\n\t\t\t\t\"id\" => $id\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] edited directory options for '\" . str_replace($customer['documentroot'], '/', $result['path']) . \"'\");\n\t\t}\n\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all directory-options, if called from an admin, list all directory-options of all customers you are allowed\n\t * to view, or specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.pathoptions');\n\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list directory-options\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible directory options\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.pathoptions');\n\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_htaccess FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_htaccess']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a directory-options by id\n\t *\n\t * @param int $id\n\t *            id of dir-protection entry\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.pathoptions')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get directory-option\n\t\t$result = $this->apiCall('DirOptions.get', [\n\t\t\t'id' => $id\n\t\t]);\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t// do we have to remove the symlink and folder in suexecpath?\n\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t$loginname = $customer_data['loginname'];\n\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($result['path']) . '/');\n\t\t\t$perlsymlink = FileDir::makeCorrectFile($result['path'] . '/cgi-bin');\n\t\t\t// remove symlink\n\t\t\tif (file_exists($perlsymlink)) {\n\t\t\t\tFileDir::safe_exec('rm -f ' . escapeshellarg($perlsymlink));\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_DEBUG, \"[API] deleted suexecworkaround symlink '\" . $perlsymlink . \"'\");\n\t\t\t}\n\t\t\t// remove folder in suexec-path\n\t\t\tif (file_exists($suexecpath)) {\n\t\t\t\tFileDir::safe_exec('rm -rf ' . escapeshellarg($suexecpath));\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_DEBUG, \"[API] deleted suexecworkaround path '\" . $suexecpath . \"'\");\n\t\t\t}\n\t\t}\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_HTACCESS . \"`\n\t\t\tWHERE `customerid`= :customerid\n\t\t\tAND `id`= :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] deleted directory-option for '\" . str_replace($customer_data['documentroot'], '/', $result['path']) . \"'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\Crypt;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass DirProtections extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add htaccess protection to a given directory\n\t *\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $path\n\t * @param string $username\n\t * @param string $directory_password\n\t * @param string $directory_authname\n\t *            optional name/description for the protection\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get needed customer info to reduce the email-address-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// required parameters\n\t\t$path = $this->getParam('path');\n\t\t$username = $this->getParam('username');\n\t\t$password = $this->getParam('directory_password');\n\n\t\t// parameters\n\t\t$authname = $this->getParam('directory_authname', true, '');\n\n\t\t// validation\n\t\t$path = FileDir::makeCorrectDir(Validate::validate($path, 'path', Validate::REGEX_DIR, '', [], true));\n\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path, $customer['documentroot']);\n\t\t$username = Validate::validate($username, 'username', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_]+\\$?$/', '', [], true);\n\t\t$authname = Validate::validate($authname, 'directory_authname', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_ ]+\\$?$/', '', [], true);\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t// check for duplicate usernames for the path\n\t\t$username_path_check_stmt = Database::prepare(\"\n\t\t\tSELECT `id`, `username`, `path` FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `username`= :username AND `path`= :path AND `customerid`= :customerid\n\t\t\");\n\t\t$params = [\n\t\t\t\"username\" => $username,\n\t\t\t\"path\" => $path,\n\t\t\t\"customerid\" => $customer['customerid']\n\t\t];\n\t\t$username_path_check = Database::pexecute_first($username_path_check_stmt, $params, true, true);\n\n\t\t$password_enc = Crypt::makeCryptPassword($password, true);\n\n\t\t// duplicate check\n\t\tif ($username_path_check && $username_path_check['username'] == $username && $username_path_check['path'] == $path) {\n\t\t\tResponse::standardError('userpathcombinationdupe', '', true);\n\t\t} elseif ($password == $username) {\n\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t}\n\n\t\t// insert the entry\n\t\t$stmt = Database::prepare(\"\n\t\t\tINSERT INTO `\" . TABLE_PANEL_HTPASSWDS . \"` SET\n\t\t\t`customerid` = :customerid,\n\t\t\t`username` = :username,\n\t\t\t`password` = :password,\n\t\t\t`path` = :path,\n\t\t\t`authname` = :authname\n\t\t\");\n\t\t$params = [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"username\" => $username,\n\t\t\t\"password\" => $password_enc,\n\t\t\t\"path\" => $path,\n\t\t\t\"authname\" => $authname\n\t\t];\n\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t$id = Database::lastInsertId();\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added directory-protection for '\" . $username . \" (\" . $path . \")'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * return a directory-protection entry by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\t\tWHERE (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['idun'] = ($id <= 0 ? $username : $id);\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get directory protection for '\" . $result['path'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"username '\" . $username . \"'\");\n\t\tthrow new Exception(\"Directory protection with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update htaccess protection of a given directory\n\t *\n\t * @param int $id\n\t *            optional the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param string $directory_password\n\t *            optional, leave empty for no change\n\t * @param string $directory_authname\n\t *            optional name/description for the protection\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t// validation\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// parameters\n\t\t$password = $this->getParam('directory_password', true, '');\n\t\t$authname = $this->getParam('directory_authname', true, $result['authname']);\n\n\t\t// get needed customer info\n\t\t$customer = $this->getCustomerData();\n\n\t\t// validation\n\t\t$authname = Validate::validate($authname, 'directory_authname', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_ ]+\\$?$/', '', [], true);\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t$upd_query = \"\";\n\t\t$upd_params = [\n\t\t\t\"id\" => $result['id'],\n\t\t\t\"cid\" => $customer['customerid']\n\t\t];\n\t\tif (!empty($password)) {\n\t\t\tif ($password == $result['username']) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t}\n\t\t\t$password_enc = Crypt::makeCryptPassword($password, true);\n\n\t\t\t$upd_query .= \"`password`= :password_enc\";\n\t\t\t$upd_params['password_enc'] = $password_enc;\n\t\t}\n\t\tif ($authname != $result['authname']) {\n\t\t\tif (!empty($upd_query)) {\n\t\t\t\t$upd_query .= \", \";\n\t\t\t}\n\t\t\t$upd_query .= \"`authname` = :authname\";\n\t\t\t$upd_params['authname'] = $authname;\n\t\t}\n\n\t\t// build update query\n\t\tif (!empty($upd_query)) {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTPASSWDS . \"` SET \" . $upd_query . \" WHERE `id` = :id AND `customerid`= :cid\n\t\t\t\");\n\t\t\tDatabase::pexecute($upd_stmt, $upd_params, true, true);\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t}\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated directory-protection '\" . $result['username'] . \" (\" . $result['path'] . \")'\");\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $result['id']\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all directory-protections, if called from an admin, list all directory-protections of all customers you are\n\t * allowed to view, or specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.directoryprotection');\n\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list directory-protections\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible directory protections\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select directory-protections of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select directory-protections of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\t\t$customer_ids = $this->getAllowedCustomerIds('extras.directoryprotection');\n\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_htpasswd FROM `\" . TABLE_PANEL_HTPASSWDS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_htpasswd']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a directory-protection by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the directory-protection-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'extras.directoryprotection')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get directory protection\n\t\t$result = $this->apiCall('DirProtections.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_HTPASSWDS . \"` WHERE `customerid`= :customerid\tAND `id`= :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t]);\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted htpasswd for '\" . $result['username'] . \" (\" . $result['path'] . \")'\");\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\Crypt;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\User;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass Ftps extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add a new ftp-user\n\t *\n\t * @param string $ftp_password\n\t *            password for the created database and database-user\n\t * @param string $path\n\t *            destination path relative to the customers-homedir\n\t * @param string $ftp_description\n\t *            optional, description for ftp-user\n\t * @param bool $sendinfomail\n\t *            optional, send created resource-information to customer, default: false\n\t * @param string $shell\n\t *            optional, default /bin/false (not changeable when deactivated)\n\t * @param string $ftp_username\n\t *            optional if customer.ftpatdomain is allowed, specify an username\n\t * @param string $ftp_domain\n\t *            optional if customer.ftpatdomain is allowed, specify a domain (customer must be owner)\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t * @param array $additional_members\n\t *            optional whether to add additional usernames to the group\n\t * @param bool $is_defaultuser\n\t *            optional whether this is the standard default ftp user which is being added so no usage is decreased\n\t * @param bool $login_enabled\n\t *            optional whether to allow login (default) or not\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$is_defaultuser = $this->getBoolParam('is_defaultuser', true, 0);\n\t\t$login_enabled = $this->getBoolParam('login_enabled', true, 1);\n\n\t\tif (($this->getUserDetail('ftps_used') < $this->getUserDetail('ftps') || $this->getUserDetail('ftps') == '-1') || $this->isAdmin() && $is_defaultuser == 1) {\n\t\t\t// required parameters\n\t\t\t$path = $this->getParam('path');\n\t\t\t$password = $this->getParam('ftp_password');\n\n\t\t\t// parameters\n\t\t\t$description = $this->getParam('ftp_description', true, '');\n\t\t\t$sendinfomail = $this->getBoolParam('sendinfomail', true, 0);\n\t\t\t$shell = $this->getParam('shell', true, '/bin/false');\n\n\t\t\t$ftpusername = $this->getParam('ftp_username', true, '');\n\t\t\t$ftpdomain = $this->getParam('ftp_domain', true, '');\n\n\t\t\t$additional_members = $this->getParam('additional_members', true, []);\n\n\t\t\t// validation\n\t\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t\t$password = Crypt::validatePassword($password, true);\n\t\t\t$description = Validate::validate(trim($description), 'description', Validate::REGEX_DESC_TEXT, '', [], true);\n\n\t\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t\t$shell = Validate::validate(trim($shell), 'shell', '', '', [], true);\n\t\t\t} else {\n\t\t\t\t$shell = \"/bin/false\";\n\t\t\t}\n\n\t\t\tif (Settings::Get('customer.ftpatdomain') == '1') {\n\t\t\t\t$ftpusername = Validate::validate(trim($ftpusername), 'username', '/^[a-zA-Z0-9][a-zA-Z0-9\\-_]+\\$?$/', '', [], true);\n\t\t\t\tif (substr($ftpdomain, 0, 4) != 'xn--') {\n\t\t\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t\t\t$ftpdomain = $idna_convert->encode(Validate::validate($ftpdomain, 'domain', '', '', [], true));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$params = [];\n\t\t\t// get needed customer info to reduce the ftp-user-counter by one\n\t\t\tif ($is_defaultuser) {\n\t\t\t\t// no resource check for default user\n\t\t\t\t$customer = $this->getCustomerData();\n\t\t\t} else {\n\t\t\t\t$customer = $this->getCustomerData('ftps');\n\t\t\t}\n\n\t\t\tif ($sendinfomail != 1) {\n\t\t\t\t$sendinfomail = 0;\n\t\t\t}\n\n\t\t\tif (Settings::Get('customer.ftpatdomain') == '1' && !$is_defaultuser) {\n\t\t\t\tif ($ftpusername == '') {\n\t\t\t\t\tResponse::standardError([\n\t\t\t\t\t\t'stringisempty',\n\t\t\t\t\t\t'username'\n\t\t\t\t\t], '', true);\n\t\t\t\t}\n\t\t\t\t$ftpdomain_check_stmt = Database::prepare(\"SELECT `id`, `domain`, `customerid` FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\t\tWHERE `domain` = :domain\n\t\t\t\t\t\tAND `customerid` = :customerid\");\n\t\t\t\t$ftpdomain_check = Database::pexecute_first($ftpdomain_check_stmt, [\n\t\t\t\t\t\"domain\" => $ftpdomain,\n\t\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t\t], true, true);\n\n\t\t\t\tif ($ftpdomain_check && $ftpdomain_check['domain'] != $ftpdomain) {\n\t\t\t\t\tResponse::standardError('maindomainnonexist', $ftpdomain, true);\n\t\t\t\t}\n\t\t\t\t$username = $ftpusername . \"@\" . $ftpdomain;\n\t\t\t} else {\n\t\t\t\tif ($is_defaultuser) {\n\t\t\t\t\t$username = $customer['loginname'];\n\t\t\t\t} else {\n\t\t\t\t\t$username = $customer['loginname'] . Settings::Get('customer.ftpprefix') . (intval($customer['ftp_lastaccountnumber']) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$username_check_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\tWHERE `username` = :username\n\t\t\t\");\n\t\t\t$username_check = Database::pexecute_first($username_check_stmt, [\n\t\t\t\t\"username\" => $username\n\t\t\t], true, true);\n\n\t\t\tif (!empty($username_check) && $username_check['username'] = $username) {\n\t\t\t\tResponse::standardError('usernamealreadyexists', $username, true);\n\t\t\t} elseif ($username == $password) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t} else {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path, $customer['documentroot']);\n\t\t\t\t$cryptPassword = Crypt::makeCryptPassword($password, false, true);\n\n\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\t\t(`customerid`, `username`, `description`, `password`, `homedir`, `login_enabled`, `uid`, `gid`, `shell`)\n\t\t\t\t\t\tVALUES (:customerid, :username, :description, :password, :homedir, :loginenabled, :guid, :guid, :shell)\");\n\t\t\t\t$params = [\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"username\" => $username,\n\t\t\t\t\t\"description\" => $description,\n\t\t\t\t\t\"password\" => $cryptPassword,\n\t\t\t\t\t\"homedir\" => $path,\n\t\t\t\t\t\"loginenabled\" => $login_enabled ? 'Y' : 'N',\n\t\t\t\t\t\"guid\" => $customer['guid'],\n\t\t\t\t\t\"shell\" => $shell\n\t\t\t\t];\n\t\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `bytes_in_used` FROM `\" . TABLE_FTP_QUOTATALLIES . \"` WHERE `name` = :name\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($result_stmt, [\n\t\t\t\t\t\"name\" => $customer['loginname']\n\t\t\t\t], true, true);\n\n\t\t\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_QUOTATALLIES . \"`\n\t\t\t\t\t\t(`name`, `quota_type`, `bytes_in_used`, `bytes_out_used`, `bytes_xfer_used`, `files_in_used`, `files_out_used`, `files_xfer_used`)\n\t\t\t\t\t\tVALUES (:name, 'user', :bytes_in_used, '0', '0', '0', '0', '0')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\t\"name\" => $username,\n\t\t\t\t\t\t\"bytes_in_used\" => $row['bytes_in_used']\n\t\t\t\t\t], true, true);\n\t\t\t\t}\n\n\t\t\t\t// create quotatallies entry if it not exists, refs #885\n\t\t\t\tif ($result_stmt->rowCount() == 0) {\n\t\t\t\t\t$stmt = Database::prepare(\"INSERT INTO `\" . TABLE_FTP_QUOTATALLIES . \"`\n\t\t\t\t\t\t(`name`, `quota_type`, `bytes_in_used`, `bytes_out_used`, `bytes_xfer_used`, `files_in_used`, `files_out_used`, `files_xfer_used`)\n\t\t\t\t\t\tVALUES (:name, 'user', '0', '0', '0', '0', '0', '0')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\t\"name\" => $username\n\t\t\t\t\t], true, true);\n\t\t\t\t}\n\n\t\t\t\t$group_upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_FTP_GROUPS . \"`\n\t\t\t\t\tSET `members` = CONCAT_WS(',',`members`, :username)\n\t\t\t\t\tWHERE `customerid`= :customerid AND `gid`= :guid\n\t\t\t\t\");\n\t\t\t\t$params = [\n\t\t\t\t\t\"username\" => $username,\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"guid\" => $customer['guid']\n\t\t\t\t];\n\n\t\t\t\tif ($is_defaultuser) {\n\t\t\t\t\t// add the new group\n\t\t\t\t\t$group_ins_stmt = Database::prepare(\"\n\t\t\t\t\t\tINSERT INTO `\" . TABLE_FTP_GROUPS . \"`\n\t\t\t\t\t\tSET `customerid`= :customerid, `gid`= :guid, `groupname` = :username, `members` = :username\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($group_ins_stmt, $params, true, true);\n\t\t\t\t} else {\n\t\t\t\t\t// just update\n\t\t\t\t\tDatabase::pexecute($group_upd_stmt, $params, true, true);\n\t\t\t\t}\n\n\t\t\t\tif (count($additional_members) > 0) {\n\t\t\t\t\tforeach ($additional_members as $add_member) {\n\t\t\t\t\t\t$params = [\n\t\t\t\t\t\t\t\"username\" => $add_member,\n\t\t\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\t\t\"guid\" => $customer['guid']\n\t\t\t\t\t\t];\n\t\t\t\t\t\tDatabase::pexecute($group_upd_stmt, $params, true, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$is_defaultuser) {\n\t\t\t\t\t// update customer usage\n\t\t\t\t\tCustomers::increaseUsage($customer['customerid'], 'ftps_used');\n\t\t\t\t\tCustomers::increaseUsage($customer['customerid'], 'ftp_lastaccountnumber');\n\t\t\t\t}\n\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added ftp-account '\" . $username . \" (\" . $path . \")'\");\n\t\t\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\n\t\t\t\tif ($sendinfomail == 1) {\n\t\t\t\t\t$replace_arr = [\n\t\t\t\t\t\t'SALUTATION' => User::getCorrectUserSalutation($customer),\n\t\t\t\t\t\t'CUST_NAME' => User::getCorrectUserSalutation($customer),\n\t\t\t\t\t\t// < keep this for compatibility\n\t\t\t\t\t\t'NAME' => $customer['name'],\n\t\t\t\t\t\t'FIRSTNAME' => $customer['firstname'],\n\t\t\t\t\t\t'COMPANY' => $customer['company'],\n\t\t\t\t\t\t'USERNAME' => $customer['loginname'],\n\t\t\t\t\t\t'CUSTOMER_NO' => $customer['customernumber'],\n\t\t\t\t\t\t'USR_NAME' => $username,\n\t\t\t\t\t\t'USR_PASS' => htmlentities(htmlentities($password)),\n\t\t\t\t\t\t'USR_PATH' => FileDir::makeCorrectDir(str_replace($customer['documentroot'], \"/\", $path))\n\t\t\t\t\t];\n\t\t\t\t\t// get template for mail subject\n\t\t\t\t\t$mail_subject = $this->getMailTemplate($customer, 'mails', 'new_ftpaccount_by_customer_subject', $replace_arr, lng('mails.new_ftpaccount_by_customer.subject'));\n\t\t\t\t\t// get template for mail body\n\t\t\t\t\t$mail_body = $this->getMailTemplate($customer, 'mails', 'new_ftpaccount_by_customer_mailbody', $replace_arr, lng('mails.new_ftpaccount_by_customer.mailbody'));\n\n\t\t\t\t\t$_mailerror = false;\n\t\t\t\t\t$mailerr_msg = \"\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$this->mailer()->Subject = $mail_subject;\n\t\t\t\t\t\t$this->mailer()->AltBody = $mail_body;\n\t\t\t\t\t\t$this->mailer()->msgHTML(str_replace(\"\\n\", \"<br />\", $mail_body));\n\t\t\t\t\t\t$this->mailer()->addAddress($customer['email'], User::getCorrectUserSalutation($customer));\n\t\t\t\t\t\t$this->mailer()->send();\n\t\t\t\t\t} catch (\\PHPMailer\\PHPMailer\\Exception $e) {\n\t\t\t\t\t\t$mailerr_msg = $e->errorMessage();\n\t\t\t\t\t\t$_mailerror = true;\n\t\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\t\t$mailerr_msg = $e->getMessage();\n\t\t\t\t\t\t$_mailerror = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($_mailerror) {\n\t\t\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_ERR, \"[API] Error sending mail: \" . $mailerr_msg);\n\t\t\t\t\t\tResponse::standardError('errorsendingmail', $customer['email'], true);\n\t\t\t\t\t}\n\n\t\t\t\t\t$this->mailer()->clearAddresses();\n\t\t\t\t}\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] added ftp-user '\" . $username . \"'\");\n\n\t\t\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t\t\t'username' => $username\n\t\t\t\t]);\n\t\t\t\treturn $this->response($result);\n\t\t\t}\n\t\t}\n\t\tthrow new Exception(\"No more resources available\", 406);\n\t}\n\n\t/**\n\t * return a ftp-user entry by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the customer-id\n\t * @param string $username\n\t *            optional, the username\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$params = [];\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') == false) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tWHERE (`id` = :idun OR `username` = :idun)\n\t\t\t\t\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND (`id` = :idun OR `username` = :idun)\n\t\t\t\");\n\t\t\t$params['customerid'] = $this->getUserDetail('customerid');\n\t\t}\n\t\t$params['idun'] = ($id <= 0 ? $username : $id);\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get ftp-user '\" . $result['username'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"username '\" . $username . \"'\");\n\t\tthrow new Exception(\"FTP user with \" . $key . \" could not be found\", 404);\n\t}\n\n\t/**\n\t * update a given ftp-user by id or username\n\t *\n\t * @param int $id\n\t *            optional, the ftp-user-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param string $ftp_password\n\t *            optional, update password if specified\n\t * @param string $path\n\t *            destination path relative to the customers-homedir\n\t * @param string $ftp_description\n\t *            optional, description for ftp-user\n\t * @param string $shell\n\t *            optional, default /bin/false (not changeable when deactivated)\n\t * @param bool $login_enabled\n\t *            optional whether to allow login (default) or not\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// parameters\n\t\t$path = $this->getParam('path', true, '');\n\t\t$password = $this->getParam('ftp_password', true, '');\n\t\t$description = $this->getParam('ftp_description', true, $result['description']);\n\t\t$shell = $this->getParam('shell', true, $result['shell']);\n\t\t$login_enabled = $this->getBoolParam('login_enabled', true, ($result['login_enabled'] == 'Y' ? 1 : 0));\n\n\t\t// validation\n\t\t$password = Validate::validate($password, 'password', '', '', [], true);\n\t\t$description = Validate::validate(trim($description), 'description', Validate::REGEX_DESC_TEXT, '', [], true);\n\n\t\tif (Settings::Get('system.allow_customer_shell') == '1') {\n\t\t\t$shell = Validate::validate(trim($shell), 'shell', '', '', [], true);\n\t\t} else {\n\t\t\t$shell = \"/bin/false\";\n\t\t}\n\n\t\tif ($login_enabled != 1) {\n\t\t\t$login_enabled = 0;\n\t\t}\n\n\t\t// get needed customer info to reduce the ftp-user-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t// password update?\n\t\tif ($password != '') {\n\t\t\t// validate password\n\t\t\t$password = Crypt::validatePassword($password, true);\n\n\t\t\tif ($password == $result['username']) {\n\t\t\t\tResponse::standardError('passwordshouldnotbeusername', '', true);\n\t\t\t}\n\t\t\t$cryptPassword = Crypt::makeCryptPassword($password, false, true);\n\n\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tSET `password` = :password\n\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\tAND `id` = :id\n\t\t\t\");\n\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"id\" => $id,\n\t\t\t\t\"password\" => $cryptPassword\n\t\t\t], true, true);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-account password for '\" . $result['username'] . \"'\");\n\t\t}\n\n\t\t// path update?\n\t\tif ($path != '') {\n\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path, $customer['documentroot']);\n\n\t\t\tif ($path != $result['homedir']) {\n\t\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\t\tSET `homedir` = :homedir\n\t\t\t\t\tWHERE `customerid` = :customerid\n\t\t\t\t\tAND `id` = :id\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\t\"homedir\" => $path,\n\t\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\t\"id\" => $id\n\t\t\t\t], true, true);\n\t\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-account homdir for '\" . $result['username'] . \"'\");\n\t\t\t}\n\t\t}\n\t\t// it's the task for \"new ftp\" but that will\n\t\t// create all directories and correct their permissions\n\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\n\t\t$stmt = Database::prepare(\"\n\t\t\tUPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\tSET `description` = :desc, `shell` = :shell, `login_enabled` = :loginenabled\n\t\t\tWHERE `customerid` = :customerid\n\t\t\tAND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"desc\" => $description,\n\t\t\t\"shell\" => $shell,\n\t\t\t\"loginenabled\" => $login_enabled ? 'Y' : 'N',\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'username' => $result['username']\n\t\t]);\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] updated ftp-user '\" . $result['username'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * list all ftp-users, if called from an admin, list all ftp-users of all customers you are allowed to view, or\n\t * specify id or loginname for one specific customer\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select ftp-users of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select ftp-users of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\t$customer_ids = $this->getAllowedCustomerIds('ftp');\n\t\t$result = [];\n\t\t$query_fields = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT * FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\" . $this->getSearchWhere($query_fields, true) . $this->getOrderBy() . $this->getLimit());\n\t\tDatabase::pexecute($result_stmt, $query_fields, true, true);\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$result[] = $row;\n\t\t}\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] list ftp-users\");\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * returns the total number of accessible ftp accounts\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select ftp-users of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select ftp-users of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\t$customer_ids = $this->getAllowedCustomerIds('ftp');\n\t\t$result = [];\n\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT COUNT(*) as num_ftps FROM `\" . TABLE_FTP_USERS . \"`\n\t\t\tWHERE `customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\");\n\t\t$result = Database::pexecute_first($result_stmt, null, true, true);\n\t\tif ($result) {\n\t\t\treturn $this->response($result['num_ftps']);\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a ftp-user by either id or username\n\t *\n\t * @param int $id\n\t *            optional, the ftp-user-id\n\t * @param string $username\n\t *            optional, the username\n\t * @param bool $delete_userfiles\n\t *            optional, default false\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$un_optional = $id > 0;\n\t\t$username = $this->getParam('username', $un_optional, '');\n\t\t$delete_userfiles = $this->getBoolParam('delete_userfiles', true, 0);\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t// get ftp-user\n\t\t$result = $this->apiCall('Ftps.get', [\n\t\t\t'id' => $id,\n\t\t\t'username' => $username\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin()) {\n\t\t\t// get customer-data\n\t\t\t$customer_data = $this->apiCall('Customers.get', [\n\t\t\t\t'id' => $result['customerid']\n\t\t\t]);\n\t\t} else {\n\t\t\t$customer_data = $this->getUserData();\n\t\t}\n\n\t\t// add usage of this ftp-user to main-ftp user of customer if different\n\t\tif ($result['username'] != $customer_data['loginname']) {\n\t\t\t$stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_USERS . \"`\n\t\t\t\tSET `up_count` = `up_count` + :up_count,\n\t\t\t\t`up_bytes` = `up_bytes` + :up_bytes,\n\t\t\t\t`down_count` = `down_count` + :down_count,\n\t\t\t\t`down_bytes` = `down_bytes` + :down_bytes\n\t\t\t\tWHERE `username` = :username\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"up_count\" => $result['up_count'],\n\t\t\t\t\"up_bytes\" => $result['up_bytes'],\n\t\t\t\t\"down_count\" => $result['down_count'],\n\t\t\t\t\"down_bytes\" => $result['down_bytes'],\n\t\t\t\t\"username\" => $customer_data['loginname']\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t} else {\n\t\t\t// do not allow removing default ftp-account\n\t\t\tResponse::standardError('ftp_cantdeletemainaccount', '', true);\n\t\t}\n\n\t\t// remove all quotatallies\n\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_FTP_QUOTATALLIES . \"` WHERE `name` = :name\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"name\" => $result['username']\n\t\t], true, true);\n\n\t\t// remove user itself\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_FTP_USERS . \"` WHERE `customerid` = :customerid AND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer_data['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t// update ftp-groups\n\t\t$stmt = Database::prepare(\"\n\t\t\tUPDATE `\" . TABLE_FTP_GROUPS . \"` SET\n\t\t\t`members` = REPLACE(`members`, :username,'')\n\t\t\tWHERE `customerid` = :customerid\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"username\" => \",\" . $result['username'],\n\t\t\t\"customerid\" => $customer_data['customerid']\n\t\t], true, true);\n\n\t\t// refs #293\n\t\tif ($delete_userfiles == 1) {\n\t\t\tCronjob::inserttask(TaskId::DELETE_FTP_DATA, $customer_data['loginname'], $result['homedir']);\n\t\t} else {\n\t\t\tif (Settings::Get('system.nssextrausers') == 1) {\n\t\t\t\t// this is used so that the libnss-extrausers cron is fired\n\t\t\t\tCronjob::inserttask(TaskId::CREATE_FTP);\n\t\t\t}\n\t\t}\n\n\t\t// decrease ftp-user usage for customer\n\t\t$resetaccnumber = ($customer_data['ftps_used'] == '1') ? \" , `ftp_lastaccountnumber`='0'\" : '';\n\t\tCustomers::decreaseUsage($customer_data['customerid'], 'ftps_used', $resetaccnumber);\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted ftp-user '\" . $result['username'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Api\\Commands;\n\nuse Exception;\nuse Froxlor\\Api\\ApiCommand;\nuse Froxlor\\Api\\ResourceEntity;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Domain\\Domain;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\UI\\Response;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * @since 0.10.0\n */\nclass SubDomains extends ApiCommand implements ResourceEntity\n{\n\n\t/**\n\t * add a new subdomain\n\t *\n\t * @param string $subdomain\n\t *            part before domain.tld to create as subdomain\n\t * @param string $domain\n\t *            domainname of main-domain\n\t * @param int $alias\n\t *            optional, domain-id of a domain that the new domain should be an alias of\n\t * @param string $path\n\t *            optional, destination path relative to the customers-homedir, default is customers-homedir\n\t * @param string $url\n\t *            optional, overwrites path value with an URL to generate a redirect, alternatively use the path\n\t *            parameter also for URLs\n\t * @param int $openbasedir_path\n\t *            optional, either 0 for domains-docroot [default], 1 for customers-homedir or 2 for parent-directory of domains-docroot\n\t * @param int $phpsettingid\n\t *            optional, php-settings-id, if empty the $domain value is used\n\t * @param int $redirectcode\n\t *            optional, redirect-code-id from TABLE_PANEL_REDIRECTCODES\n\t * @param int $speciallogfile\n\t *            optional, whether to create an exclusive web-logfile for this domain (1) or not (0) or inherit value from parentdomain (2, default)\n\t * @param bool $sslenabled\n\t *            optional, whether or not SSL is enabled for this domain, regardless of the assigned ssl-ips, default\n\t *            1 (true)\n\t * @param bool $ssl_redirect\n\t *            optional, whether to generate a https-redirect or not, default false; requires SSL to be enabled\n\t * @param bool $letsencrypt\n\t *            optional, whether to generate a Let's Encrypt certificate for this domain, default false; requires\n\t *            SSL to be enabled\n\t * @param bool $http2\n\t *            optional, whether to enable http/2 for this subdomain (requires to be enabled in the settings),\n\t *            default 0 (false)\n\t * @param int $hsts_maxage\n\t *            optional max-age value for HSTS header, default 0\n\t * @param bool $hsts_sub\n\t *            optional whether or not to add subdomains to the HSTS header, default 0\n\t * @param bool $hsts_preload\n\t *            optional whether or not to preload HSTS header value, default 0\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function add()\n\t{\n\t\tif (($this->getUserDetail('subdomains_used') < $this->getUserDetail('subdomains') || $this->getUserDetail('subdomains') == '-1') || $this->isAdmin()) {\n\t\t\t// parameters\n\t\t\t$subdomain = $this->getParam('subdomain');\n\t\t\t$domain = $this->getParam('domain');\n\n\t\t\t// optional parameters\n\t\t\t$aliasdomain = $this->getParam('alias', true, 0);\n\t\t\t$path = $this->getParam('path', true, '');\n\t\t\t$url = $this->getParam('url', true, '');\n\t\t\t$openbasedir_path = $this->getParam('openbasedir_path', true, 0);\n\t\t\t$phpsettingid = $this->getParam('phpsettingid', true, 0);\n\t\t\t$redirectcode = $this->getParam('redirectcode', true, Settings::Get('customredirect.default'));\n\t\t\t$speciallogfile = intval($this->getParam('speciallogfile', true, 2));\n\t\t\t$isemaildomain = $this->getParam('isemaildomain', true, 0);\n\t\t\tif (Settings::Get('system.use_ssl')) {\n\t\t\t\t$sslenabled = $this->getBoolParam('sslenabled', true, 1);\n\t\t\t\t$ssl_redirect = $this->getBoolParam('ssl_redirect', true, 0);\n\t\t\t\t$letsencrypt = $this->getBoolParam('letsencrypt', true, 0);\n\t\t\t\t$http2 = $this->getBoolParam('http2', true, 0);\n\t\t\t\t$hsts_maxage = $this->getParam('hsts_maxage', true, 0);\n\t\t\t\t$hsts_sub = $this->getBoolParam('hsts_sub', true, 0);\n\t\t\t\t$hsts_preload = $this->getBoolParam('hsts_preload', true, 0);\n\t\t\t} else {\n\t\t\t\t$sslenabled = 0;\n\t\t\t\t$ssl_redirect = 0;\n\t\t\t\t$letsencrypt = 0;\n\t\t\t\t$http2 = 0;\n\t\t\t\t$hsts_maxage = 0;\n\t\t\t\t$hsts_sub = 0;\n\t\t\t\t$hsts_preload = 0;\n\t\t\t}\n\n\t\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t\t$customer = $this->getCustomerData('subdomains');\n\n\t\t\t// validation\n\t\t\t$subdomain = strtolower($subdomain);\n\t\t\tif (substr($subdomain, 0, 4) == 'xn--') {\n\t\t\t\tResponse::standardError('domain_nopunycode', '', true);\n\t\t\t}\n\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$subdomain = $idna_convert->encode(preg_replace([\n\t\t\t\t'/\\:(\\d)+$/',\n\t\t\t\t'/^https?\\:\\/\\//'\n\t\t\t], '', Validate::validate($subdomain, 'subdomain', '', 'subdomainiswrong', [], true)));\n\n\t\t\t// merge the two parts together\n\t\t\t$completedomain = $subdomain . '.' . $domain;\n\n\t\t\tif (Settings::Get('system.validate_domain') && !Validate::validateDomain($completedomain)) {\n\t\t\t\tResponse::standardError([\n\t\t\t\t\t'stringiswrong',\n\t\t\t\t\t'mydomain'\n\t\t\t\t], '', true);\n\t\t\t}\n\t\t\tif ($completedomain == strtolower(Settings::Get('system.hostname'))) {\n\t\t\t\tResponse::standardError('admin_domain_emailsystemhostname', '', true);\n\t\t\t}\n\n\t\t\t// check whether the domain already exists\n\t\t\t$completedomain_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\tWHERE `domain` = :domain\n\t\t\t\tAND `customerid` = :customerid\n\t\t\t\tAND `email_only` = '0'\n\t\t\t\tAND `caneditdomain` = '1'\n\t\t\t\");\n\t\t\t$completedomain_check = Database::pexecute_first($completedomain_stmt, [\n\t\t\t\t\"domain\" => $completedomain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\n\t\t\tif ($completedomain_check) {\n\t\t\t\t// no exception so far - domain exists\n\t\t\t\tResponse::standardError('domainexistalready', $completedomain, true);\n\t\t\t}\n\n\t\t\t// alias domain checked?\n\t\t\tif ($aliasdomain != 0) {\n\t\t\t\t// also check ip/port combination to be the same, #176\n\t\t\t\t$aliasdomain_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `d`.`id` FROM `\" . TABLE_PANEL_DOMAINS . \"` `d` , `\" . TABLE_PANEL_CUSTOMERS . \"` `c` , `\" . TABLE_DOMAINTOIP . \"` `dip`\n\t\t\t\t\tWHERE `d`.`aliasdomain` IS NULL\n\t\t\t\t\tAND `d`.`id` = :id\n\t\t\t\t\tAND `c`.`standardsubdomain` <> `d`.`id`\n\t\t\t\t\tAND `d`.`customerid` = :customerid\n\t\t\t\t\tAND `c`.`customerid` = `d`.`customerid`\n\t\t\t\t\tAND `d`.`id` = `dip`.`id_domain`\n\t\t\t\t\tAND `dip`.`id_ipandports`\n\t\t\t\t\tIN (SELECT `id_ipandports` FROM `\" . TABLE_DOMAINTOIP . \"` WHERE `id_domain` = :id )\n\t\t\t\t\tGROUP BY `d`.`domain`\n\t\t\t\t\tORDER BY `d`.`domain` ASC\n\t\t\t\t\");\n\t\t\t\t$aliasdomain_check = Database::pexecute_first($aliasdomain_stmt, [\n\t\t\t\t\t\"id\" => $aliasdomain,\n\t\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t\t], true, true);\n\t\t\t\tif ($aliasdomain_check['id'] != $aliasdomain) {\n\t\t\t\t\tResponse::standardError('domainisaliasorothercustomer', '', true);\n\t\t\t\t}\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t}\n\n\t\t\t// validate / correct path/url of domain\n\t\t\t$_doredirect = false;\n\t\t\t$path = $this->validateDomainDocumentRoot($path, $url, $customer, $completedomain, $_doredirect);\n\n\t\t\tif ($openbasedir_path > 2 && $openbasedir_path < 0) {\n\t\t\t\t$openbasedir_path = 0;\n\t\t\t}\n\n\t\t\t// get main domain for various checks\n\t\t\t$domain_stmt = Database::prepare(\"\n\t\t\t\tSELECT * FROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\tWHERE `domain` = :domain\n\t\t\t\tAND `customerid` = :customerid\n\t\t\t\tAND `parentdomainid` = '0'\n\t\t\t\tAND `email_only` = '0'\n\t\t\t\tAND `caneditdomain` = '1'\n\t\t\t\");\n\t\t\t$domain_check = Database::pexecute_first($domain_stmt, [\n\t\t\t\t\"domain\" => $domain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\n\t\t\tif (!$domain_check) {\n\t\t\t\t// the given main-domain\n\t\t\t\tResponse::standardError('maindomainnonexist', $domain, true);\n\t\t\t} elseif ($subdomain == 'www' && $domain_check['wwwserveralias'] == '1') {\n\t\t\t\t// you cannot add 'www' as subdomain when the maindomain generates a www-alias\n\t\t\t\tResponse::standardError('wwwnotallowed', '', true);\n\t\t\t} elseif ($completedomain_check && strtolower($completedomain_check['domain']) == strtolower($completedomain)) {\n\t\t\t\t// the domain does already exist as main-domain\n\t\t\t\tResponse::standardError('domainexistalready', $completedomain, true);\n\t\t\t} elseif ((int)$domain_check['deactivated'] == 1) {\n\t\t\t\t// main domain is deactivated\n\t\t\t\tResponse::standardError('maindomaindeactivated', $domain, true);\n\t\t\t}\n\n\t\t\t// if allowed, check for 'is email domain'-flag\n\t\t\tif ($domain_check['subcanemaildomain'] == '1' || $domain_check['subcanemaildomain'] == '2') {\n\t\t\t\t$isemaildomain = intval($isemaildomain);\n\t\t\t} else {\n\t\t\t\t$isemaildomain = $domain_check['subcanemaildomain'] == '3' ? 1 : 0;\n\t\t\t}\n\n\t\t\tif ($ssl_redirect != 0) {\n\t\t\t\t// a ssl-redirect only works if there actually is a\n\t\t\t\t// ssl ip/port assigned to the domain\n\t\t\t\tif (Domain::domainHasSslIpPort($domain_check['id']) == true) {\n\t\t\t\t\t$ssl_redirect = '1';\n\t\t\t\t\t$_doredirect = true;\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('sslredirectonlypossiblewithsslipport', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($letsencrypt != 0) {\n\t\t\t\t// let's encrypt only works if there actually is a\n\t\t\t\t// ssl ip/port assigned to the domain\n\t\t\t\tif (Domain::domainHasSslIpPort($domain_check['id']) == true) {\n\t\t\t\t\t$letsencrypt = '1';\n\t\t\t\t} else {\n\t\t\t\t\tResponse::standardError('letsencryptonlypossiblewithsslipport', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// validate dns if lets encrypt is enabled to check whether we can use it at all\n\t\t\tif ($letsencrypt == '1' && Settings::Get('system.le_domain_dnscheck') == '1') {\n\t\t\t\t$our_ips = Domain::getIpsOfDomain($domain_check['id']);\n\t\t\t\t$domain_ips = PhpHelper::gethostbynamel6($completedomain, true, Settings::Get('system.le_domain_dnscheck_resolver'));\n\t\t\t\tif ($domain_ips == false || count(array_intersect($our_ips, $domain_ips)) <= 0) {\n\t\t\t\t\tResponse::standardError('invaliddnsforletsencrypt', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Temporarily deactivate ssl_redirect until Let's Encrypt certificate was generated\n\t\t\tif ($ssl_redirect > 0 && $letsencrypt == 1) {\n\t\t\t\t$ssl_redirect = 2;\n\t\t\t}\n\n\t\t\t// validate speciallogfile value\n\t\t\tif ($speciallogfile < 0 || $speciallogfile > 2) {\n\t\t\t\t$speciallogfile = 2; // inherit from parent-domain\n\t\t\t}\n\n\t\t\t// get the phpsettingid from parentdomain, #107\n\t\t\t$phpsid_stmt = Database::prepare(\"\n\t\t\t\tSELECT `phpsettingid` FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `id` = :id\n\t\t\t\");\n\t\t\t$phpsid_result = Database::pexecute_first($phpsid_stmt, [\n\t\t\t\t\"id\" => $domain_check['id']\n\t\t\t], true, true);\n\n\t\t\tif (!isset($phpsid_result['phpsettingid']) || (int)$phpsid_result['phpsettingid'] <= 0) {\n\t\t\t\t// assign default config\n\t\t\t\t$phpsid_result['phpsettingid'] = 1;\n\t\t\t}\n\t\t\t// check whether the customer has chosen its own php-config\n\t\t\tif ($phpsettingid > 0 && $phpsettingid != $phpsid_result['phpsettingid']) {\n\t\t\t\t$phpsid_result['phpsettingid'] = intval($phpsettingid);\n\t\t\t}\n\n\t\t\t$allowed_phpconfigs = $customer['allowed_phpconfigs'];\n\t\t\tif (!empty($allowed_phpconfigs)) {\n\t\t\t\t$allowed_phpconfigs = json_decode($allowed_phpconfigs, true);\n\t\t\t} else {\n\t\t\t\t$allowed_phpconfigs = [];\n\t\t\t}\n\t\t\t// only with fcgid/fpm enabled will it be possible to select a php-setting\n\t\t\tif ((int)Settings::Get('system.mod_fcgid') == 1 || (int)Settings::Get('phpfpm.enabled') == 1) {\n\t\t\t\tif (!in_array($phpsid_result['phpsettingid'], $allowed_phpconfigs)) {\n\t\t\t\t\tResponse::standardError('notallowedphpconfigused', '', true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// actually insert domain\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tINSERT INTO `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t`customerid` = :customerid,\n\t\t\t\t`adminid` = :adminid,\n\t\t\t\t`domain` = :domain,\n\t\t\t\t`domain_ace` = :domain_ace,\n\t\t\t\t`documentroot` = :documentroot,\n\t\t\t\t`aliasdomain` = :aliasdomain,\n\t\t\t\t`parentdomainid` = :parentdomainid,\n\t\t\t\t`wwwserveralias` = :wwwserveralias,\n\t\t\t\t`isemaildomain` = :isemaildomain,\n\t\t\t\t`iswildcarddomain` = :iswildcarddomain,\n\t\t\t\t`phpenabled` = :phpenabled,\n\t\t\t\t`openbasedir` = :openbasedir,\n\t\t\t\t`openbasedir_path` = :openbasedir_path,\n\t\t\t\t`speciallogfile` = :speciallogfile,\n\t\t\t\t`specialsettings` = :specialsettings,\n\t\t\t\t`ssl_specialsettings` = :ssl_specialsettings,\n\t\t\t\t`include_specialsettings` = :include_specialsettings,\n\t\t\t\t`ssl_redirect` = :ssl_redirect,\n\t\t\t\t`phpsettingid` = :phpsettingid,\n\t\t\t\t`letsencrypt` = :letsencrypt,\n\t\t\t\t`http2` = :http2,\n\t\t\t\t`hsts` = :hsts,\n\t\t\t\t`hsts_sub` = :hsts_sub,\n\t\t\t\t`hsts_preload` = :hsts_preload,\n\t\t\t\t`ocsp_stapling` = :ocsp_stapling,\n\t\t\t\t`override_tls` = :override_tls,\n\t\t\t\t`ssl_protocols` = :ssl_protocols,\n\t\t\t\t`ssl_cipher_list` = :ssl_cipher_list,\n\t\t\t\t`tlsv13_cipher_list` = :tlsv13_cipher_list,\n\t\t\t\t`ssl_enabled` = :sslenabled\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"adminid\" => $customer['adminid'],\n\t\t\t\t\"domain\" => $completedomain,\n\t\t\t\t\"domain_ace\" => $idna_convert->decode($completedomain),\n\t\t\t\t\"documentroot\" => $path,\n\t\t\t\t\"aliasdomain\" => $aliasdomain != 0 ? $aliasdomain : null,\n\t\t\t\t\"parentdomainid\" => $domain_check['id'],\n\t\t\t\t\"wwwserveralias\" => $domain_check['wwwserveralias'] == '1' ? '1' : '0',\n\t\t\t\t\"iswildcarddomain\" => $domain_check['iswildcarddomain'] == '1' ? '1' : '0',\n\t\t\t\t\"isemaildomain\" => $isemaildomain,\n\t\t\t\t\"openbasedir\" => $domain_check['openbasedir'],\n\t\t\t\t\"openbasedir_path\" => $openbasedir_path,\n\t\t\t\t\"phpenabled\" => $domain_check['phpenabled'],\n\t\t\t\t\"speciallogfile\" => $speciallogfile == 2 ? $domain_check['speciallogfile'] : $speciallogfile,\n\t\t\t\t\"specialsettings\" => $domain_check['specialsettings'],\n\t\t\t\t\"ssl_specialsettings\" => $domain_check['ssl_specialsettings'],\n\t\t\t\t\"include_specialsettings\" => $domain_check['include_specialsettings'],\n\t\t\t\t\"ssl_redirect\" => $ssl_redirect,\n\t\t\t\t\"phpsettingid\" => $phpsid_result['phpsettingid'],\n\t\t\t\t\"letsencrypt\" => $letsencrypt,\n\t\t\t\t\"http2\" => $http2,\n\t\t\t\t\"hsts\" => $hsts_maxage,\n\t\t\t\t\"hsts_sub\" => $hsts_sub,\n\t\t\t\t\"hsts_preload\" => $hsts_preload,\n\t\t\t\t\"ocsp_stapling\" => $domain_check['ocsp_stapling'],\n\t\t\t\t\"override_tls\" => $domain_check['override_tls'],\n\t\t\t\t\"ssl_protocols\" => $domain_check['ssl_protocols'],\n\t\t\t\t\"ssl_cipher_list\" => $domain_check['ssl_cipher_list'],\n\t\t\t\t\"tlsv13_cipher_list\" => $domain_check['tlsv13_cipher_list'],\n\t\t\t\t\"sslenabled\" => $sslenabled\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$subdomain_id = Database::lastInsertId();\n\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\tINSERT INTO `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\t(`id_domain`, `id_ipandports`)\n\t\t\t\tSELECT LAST_INSERT_ID(), `id_ipandports`\n\t\t\t\tFROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\tWHERE `id_domain` = :id_domain\n\t\t\t\");\n\t\t\tDatabase::pexecute($stmt, [\n\t\t\t\t\"id_domain\" => $domain_check['id']\n\t\t\t]);\n\n\t\t\tif ($_doredirect) {\n\t\t\t\tDomain::addRedirectToDomain($subdomain_id, $redirectcode);\n\t\t\t}\n\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\t// Using nameserver, insert a task which rebuilds the server config\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\n\t\t\tCustomers::increaseUsage($customer['customerid'], 'subdomains_used');\n\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] added subdomain '\" . $completedomain . \"'\");\n\n\t\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t\t'id' => $subdomain_id\n\t\t\t]);\n\t\t\treturn $this->response($result);\n\t\t}\n\t\tthrow new Exception(\"No more resources available\", 406);\n\t}\n\n\t/**\n\t * return a subdomain entry by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param bool $with_ips\n\t *            optional, default true\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function get()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\t\t$with_ips = $this->getParam('with_ips', true, true);\n\n\t\t// convert possible idn domain to punycode\n\t\tif (substr($domainname, 0, 4) != 'xn--') {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$domainname = $idna_convert->encode($domainname);\n\t\t}\n\n\t\tif ($this->isAdmin()) {\n\t\t\tif ($this->getUserDetail('customers_see_all') != 1) {\n\t\t\t\t// if it's a reseller or an admin who cannot see all customers, we need to check\n\t\t\t\t// whether the database belongs to one of his customers\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t\t$customer_ids = [];\n\t\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t}\n\t\t\t\tif (count($customer_ids) > 0) {\n\t\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\t\t\tWHERE \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \" AND d.`customerid` IN (\" . implode(\", \", $customer_ids) . \")\n\t\t\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\t\t\");\n\t\t\t\t\t$params = [\n\t\t\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"You do not have any customers yet\", 406);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\t\tWHERE \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \"\n\t\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\t\");\n\t\t\t\t$params = [\n\t\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t\t];\n\t\t\t}\n\t\t} else {\n\t\t\tif (!$this->isInternal() && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\t\tSELECT d.*, pd.`subcanemaildomain`, pd.`isbinddomain` as subisbinddomain\n\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` d, `\" . TABLE_PANEL_DOMAINS . \"` pd\n\t\t\t\tWHERE d.`customerid`= :customerid AND \" . ($id > 0 ? \"d.`id` = :iddn\" : \"d.`domain` = :iddn\") . \"\n\t\t\t\tAND ((d.`parentdomainid`!='0' AND pd.`id` = d.`parentdomainid`) OR (d.`parentdomainid`='0' AND pd.`id` = d.`id`))\n\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t'customerid' => $this->getUserDetail('customerid'),\n\t\t\t\t'iddn' => ($id <= 0 ? $domainname : $id)\n\t\t\t];\n\t\t}\n\t\t$result = Database::pexecute_first($result_stmt, $params, true, true);\n\t\tif ($result) {\n\t\t\t$result['ipsandports'] = [];\n\t\t\tif ($with_ips) {\n\t\t\t\t$result['ipsandports'] = $this->getIpsForDomain($result['id']);\n\t\t\t}\n\t\t\t$result['domain_hascert'] = $this->getHasCertValueForDomain((int)$result['id'], (int)$result['parentdomainid']);\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_INFO, \"[API] get subdomain '\" . $result['domain'] . \"'\");\n\t\t\treturn $this->response($result);\n\t\t}\n\t\t$key = ($id > 0 ? \"id #\" . $id : \"domainname '\" . $domainname . \"'\");\n\t\tthrow new Exception(\"Subdomain with \" . $key . \" could not be found\", 404);\n\t}\n\n\tprivate function getHasCertValueForDomain(int $domainid, int $parentdomainid): int\n\t{\n\t\t// nothing (ssl_global)\n\t\t$domain_hascert = 0;\n\t\t$ssl_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :domainid\");\n\t\tDatabase::pexecute($ssl_stmt, array(\n\t\t\t\"domainid\" => $domainid\n\t\t));\n\t\t$ssl_result = $ssl_stmt->fetch(PDO::FETCH_ASSOC);\n\t\tif (is_array($ssl_result) && isset($ssl_result['ssl_cert_file']) && $ssl_result['ssl_cert_file'] != '') {\n\t\t\t// own certificate (ssl_customer_green)\n\t\t\t$domain_hascert = 1;\n\t\t} else {\n\t\t\t// check if it's parent has one set (shared)\n\t\t\tif ($parentdomainid != 0) {\n\t\t\t\t$ssl_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :domainid\");\n\t\t\t\tDatabase::pexecute($ssl_stmt, array(\n\t\t\t\t\t\"domainid\" => $parentdomainid\n\t\t\t\t));\n\t\t\t\t$ssl_result = $ssl_stmt->fetch(PDO::FETCH_ASSOC);\n\t\t\t\tif (is_array($ssl_result) && isset($ssl_result['ssl_cert_file']) && $ssl_result['ssl_cert_file'] != '') {\n\t\t\t\t\t// parent has a certificate (ssl_shared)\n\t\t\t\t\t$domain_hascert = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $domain_hascert;\n\t}\n\n\t/**\n\t * validate given path and replace with url if given and valid\n\t *\n\t * @param string $path\n\t * @param string $url\n\t * @param array $customer\n\t * @param string $completedomain\n\t * @param boolean $_doredirect\n\t *\n\t * @return string validated path\n\t * @throws Exception\n\t */\n\tprivate function validateDomainDocumentRoot($path = null, $url = null, $customer = null, $completedomain = null, &$_doredirect = false)\n\t{\n\t\t// check whether an URL was specified\n\t\t$_doredirect = false;\n\t\tif (!empty($url) && Validate::validateUrl($url, true)) {\n\t\t\t$path = $url;\n\t\t\t$_doredirect = true;\n\t\t} else {\n\t\t\t$path = Validate::validate($path, 'path', '', '', [], true);\n\t\t}\n\n\t\t// check whether path is a real path\n\t\tif (!preg_match('/^https?\\:\\/\\//', $path) || !Validate::validateUrl($path, true)) {\n\t\t\tif (strstr($path, \":\") !== false) {\n\t\t\t\tResponse::standardError('pathmaynotcontaincolon', '', true);\n\t\t\t}\n\t\t\t// If path is empty or '/' and 'Use domain name as default value for DocumentRoot path' is enabled in settings,\n\t\t\t// set default path to subdomain or domain name\n\t\t\tif ((($path == '') || ($path == '/')) && Settings::Get('system.documentroot_use_default_value') == 1) {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $completedomain, $customer['documentroot']);\n\t\t\t} else {\n\t\t\t\t$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path, $customer['documentroot']);\n\t\t\t}\n\t\t} else {\n\t\t\t// no it's not, create a redirect\n\t\t\t$_doredirect = true;\n\t\t}\n\t\treturn $path;\n\t}\n\n\t/**\n\t * update subdomain entry by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param int $alias\n\t *            optional, domain-id of a domain that the new domain should be an alias of\n\t * @param string $path\n\t *            optional, destination path relative to the customers-homedir, default is customers-homedir\n\t * @param string $url\n\t *            optional, overwrites path value with an URL to generate a redirect, alternatively use the path\n\t *            parameter also for URLs\n\t * @param int $selectserveralias\n\t *            optional, 0 = wildcard, 1 = www-alias, 2 = none\n\t * @param bool $isemaildomain\n\t *            optional\n\t * @param int $openbasedir_path\n\t *            optional, either 0 for domains-docroot, 1 for customers-homedir or 2 for parent-directory of domains-docroot\n\t * @param int $phpsettingid\n\t *            optional, php-settings-id, if empty the $domain value is used\n\t * @param int $redirectcode\n\t *            optional, redirect-code-id from TABLE_PANEL_REDIRECTCODES\n\t * @param bool $speciallogfile\n\t *            optional, whether to create an exclusive web-logfile for this domain\n\t * @param bool $speciallogverified\n\t *            optional, when setting $speciallogfile to false, this needs to be set to true to confirm the action,\n\t *            default 0 (false)\n\t * @param bool $sslenabled\n\t *            optional, whether or not SSL is enabled for this domain, regardless of the assigned ssl-ips, default\n\t *            1 (true)\n\t * @param bool $ssl_redirect\n\t *            optional, whether to generate a https-redirect or not, default false; requires SSL to be enabled\n\t * @param bool $letsencrypt\n\t *            optional, whether to generate a Let's Encrypt certificate for this domain, default false; requires\n\t *            SSL to be enabled\n\t * @param bool $http2\n\t *            optional, whether to enable http/2 for this domain (requires to be enabled in the settings), default\n\t *            0 (false)\n\t * @param int $hsts_maxage\n\t *            optional max-age value for HSTS header\n\t * @param bool $hsts_sub\n\t *            optional whether or not to add subdomains to the HSTS header\n\t * @param bool $hsts_preload\n\t *            optional whether or not to preload HSTS header value\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function update()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id,\n\t\t\t'domainname' => $domainname\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\tif ($this->isAdmin() == false && (int)$result['caneditdomain'] == 0) {\n\t\t\tthrow new Exception(lng('error.domaincannotbeedited', [$result['domain']]), 406);\n\t\t}\n\n\t\t// parameters\n\t\t$aliasdomain = $this->getParam('alias', true, 0);\n\t\t$path = $this->getParam('path', true, $result['documentroot']);\n\t\t$url = $this->getParam('url', true, '');\n\t\t// default: 0 = wildcard, 1 = www-alias, 2 = none\n\t\t$_serveraliasdefault = $result['iswildcarddomain'] == '1' ? 0 : ($result['wwwserveralias'] == '1' ? 1 : 2);\n\t\t$selectserveralias = $this->getParam('selectserveralias', true, $_serveraliasdefault);\n\t\t$isemaildomain = $this->getBoolParam('isemaildomain', true, $result['isemaildomain']);\n\t\t$openbasedir_path = $this->getParam('openbasedir_path', true, $result['openbasedir_path']);\n\t\t$phpsettingid = $this->getParam('phpsettingid', true, $result['phpsettingid']);\n\t\t$redirectcode = $this->getParam('redirectcode', true, Domain::getDomainRedirectId($id));\n\t\t$speciallogfile = $this->getBoolParam('speciallogfile', true, $result['speciallogfile']);\n\t\t$speciallogverified = $this->getBoolParam('speciallogverified', true, 0);\n\t\tif (Settings::Get('system.use_ssl')) {\n\t\t\t$sslenabled = $this->getBoolParam('sslenabled', true, $result['ssl_enabled']);\n\t\t\t$ssl_redirect = $this->getBoolParam('ssl_redirect', true, $result['ssl_redirect']);\n\t\t\t$letsencrypt = $this->getBoolParam('letsencrypt', true, $result['letsencrypt']);\n\t\t\t$http2 = $this->getBoolParam('http2', true, $result['http2']);\n\t\t\t$hsts_maxage = $this->getParam('hsts_maxage', true, $result['hsts']);\n\t\t\t$hsts_sub = $this->getBoolParam('hsts_sub', true, $result['hsts_sub']);\n\t\t\t$hsts_preload = $this->getBoolParam('hsts_preload', true, $result['hsts_preload']);\n\t\t} else {\n\t\t\t$sslenabled = 0;\n\t\t\t$ssl_redirect = 0;\n\t\t\t$letsencrypt = 0;\n\t\t\t$http2 = 0;\n\t\t\t$hsts_maxage = 0;\n\t\t\t$hsts_sub = 0;\n\t\t\t$hsts_preload = 0;\n\t\t}\n\n\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\t$alias_stmt = Database::prepare(\"SELECT COUNT(`id`) AS count FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `aliasdomain`= :aliasdomain\");\n\t\t$alias_check = Database::pexecute_first($alias_stmt, [\n\t\t\t\"aliasdomain\" => $result['id']\n\t\t]);\n\t\t$alias_check = $alias_check['count'];\n\n\t\t// alias domain checked?\n\t\tif ($aliasdomain != 0) {\n\t\t\t$aliasdomain_stmt = Database::prepare(\"\n\t\t\t\tSELECT `id` FROM `\" . TABLE_PANEL_DOMAINS . \"` `d`,`\" . TABLE_PANEL_CUSTOMERS . \"` `c`\n\t\t\t\tWHERE `d`.`customerid`= :customerid\n\t\t\t\tAND `d`.`aliasdomain` IS NULL\n\t\t\t\tAND `d`.`id`<>`c`.`standardsubdomain`\n\t\t\t\tAND `c`.`customerid`= :customerid\n\t\t\t\tAND `d`.`id`= :id\n\t\t\t\");\n\t\t\t$aliasdomain_check = Database::pexecute_first($aliasdomain_stmt, [\n\t\t\t\t\"id\" => $aliasdomain,\n\t\t\t\t\"customerid\" => $customer['customerid']\n\t\t\t], true, true);\n\t\t\tif ($aliasdomain_check['id'] != $aliasdomain) {\n\t\t\t\tResponse::standardError('domainisaliasorothercustomer', '', true);\n\t\t\t}\n\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t}\n\n\t\t// validate / correct path/url of domain\n\t\t$_doredirect = false;\n\t\t$path = $this->validateDomainDocumentRoot($path, $url, $customer, $result['domain'], $_doredirect);\n\n\t\t// set alias-fields according to selected alias mode\n\t\t$iswildcarddomain = ($selectserveralias == '0') ? '1' : '0';\n\t\t$wwwserveralias = ($selectserveralias == '1') ? '1' : '0';\n\n\t\t// if allowed, check for 'is email domain'-flag\n\t\tif ($isemaildomain != $result['isemaildomain']) {\n\t\t\tif ($result['parentdomainid'] != '0' && ($result['subcanemaildomain'] == '1' || $result['subcanemaildomain'] == '2')) {\n\t\t\t\t$isemaildomain = intval($isemaildomain);\n\t\t\t} elseif ($result['parentdomainid'] != '0') {\n\t\t\t\t$isemaildomain = $result['subcanemaildomain'] == '3' ? 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\t// check changes of openbasedir-path variable\n\t\tif ($openbasedir_path > 2 && $openbasedir_path < 0) {\n\t\t\t$openbasedir_path = 0;\n\t\t}\n\n\t\tif ($ssl_redirect != 0) {\n\t\t\t// a ssl-redirect only works if there actually is a\n\t\t\t// ssl ip/port assigned to the domain\n\t\t\tif (Domain::domainHasSslIpPort($result['id']) == true) {\n\t\t\t\t$ssl_redirect = '1';\n\t\t\t\t$_doredirect = true;\n\t\t\t} else {\n\t\t\t\tResponse::standardError('sslredirectonlypossiblewithsslipport', '', true);\n\t\t\t}\n\t\t}\n\n\t\tif ($letsencrypt != 0) {\n\t\t\t// let's encrypt only works if there actually is a\n\t\t\t// ssl ip/port assigned to the domain\n\t\t\tif (Domain::domainHasSslIpPort($result['id']) == true) {\n\t\t\t\t$letsencrypt = '1';\n\t\t\t} else {\n\t\t\t\tResponse::standardError('letsencryptonlypossiblewithsslipport', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// validate dns if lets encrypt is enabled to check whether we can use it at all\n\t\tif ($result['letsencrypt'] != $letsencrypt && $letsencrypt == '1' && Settings::Get('system.le_domain_dnscheck') == '1') {\n\t\t\t$our_ips = Domain::getIpsOfDomain($result['parentdomainid']);\n\t\t\t$domain_ips = PhpHelper::gethostbynamel6($result['domain'], true, Settings::Get('system.le_domain_dnscheck_resolver'));\n\t\t\tif ($domain_ips == false || count(array_intersect($our_ips, $domain_ips)) <= 0) {\n\t\t\t\tResponse::standardError('invaliddnsforletsencrypt', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// We can't enable let's encrypt for wildcard-domains\n\t\tif ($iswildcarddomain == '1' && $letsencrypt == '1') {\n\t\t\tResponse::standardError('nowildcardwithletsencrypt', '', true);\n\t\t}\n\n\t\t// Temporarily deactivate ssl_redirect until Let's Encrypt certificate was generated\n\t\tif ($ssl_redirect > 0 && $letsencrypt == 1 && $result['letsencrypt'] != $letsencrypt) {\n\t\t\t$ssl_redirect = 2;\n\t\t}\n\n\t\tif ($speciallogfile != $result['speciallogfile'] && $speciallogverified != '1') {\n\t\t\t$speciallogfile = $result['speciallogfile'];\n\t\t}\n\n\t\t// is-email-domain flag changed - remove mail accounts and mail-addresses\n\t\tif (($result['isemaildomain'] == '1') && $isemaildomain == '0') {\n\t\t\t$params = [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"domainid\" => $id\n\t\t\t];\n\t\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_MAIL_USERS . \"` WHERE `customerid`= :customerid AND `domainid`= :domainid\");\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$stmt = Database::prepare(\"DELETE FROM `\" . TABLE_MAIL_VIRTUAL . \"` WHERE `customerid`= :customerid AND `domainid`= :domainid\");\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] automatically deleted mail-table entries for '\" . $idna_convert->decode($result['domain']) . \"'\");\n\t\t}\n\n\t\t$allowed_phpconfigs = $customer['allowed_phpconfigs'];\n\t\tif (!empty($allowed_phpconfigs)) {\n\t\t\t$allowed_phpconfigs = json_decode($allowed_phpconfigs, true);\n\t\t} else {\n\t\t\t$allowed_phpconfigs = [];\n\t\t}\n\t\t// only with fcgid/fpm enabled will it be possible to select a php-setting\n\t\tif ((int)Settings::Get('system.mod_fcgid') == 1 || (int)Settings::Get('phpfpm.enabled') == 1) {\n\t\t\tif (!in_array($phpsettingid, $allowed_phpconfigs)) {\n\t\t\t\tResponse::standardError('notallowedphpconfigused', '', true);\n\t\t\t}\n\t\t}\n\n\t\t// handle redirect\n\t\tif ($_doredirect) {\n\t\t\tDomain::updateRedirectOfDomain($id, $redirectcode);\n\t\t}\n\n\t\tif ($path != $result['documentroot']\n\t\t\t|| $isemaildomain != $result['isemaildomain']\n\t\t\t|| $wwwserveralias != $result['wwwserveralias']\n\t\t\t|| $iswildcarddomain != $result['iswildcarddomain']\n\t\t\t|| $aliasdomain != (int)$result['aliasdomain']\n\t\t\t|| $openbasedir_path != $result['openbasedir_path']\n\t\t\t|| $ssl_redirect != $result['ssl_redirect']\n\t\t\t|| $letsencrypt != $result['letsencrypt']\n\t\t\t|| $hsts_maxage != $result['hsts']\n\t\t\t|| $hsts_sub != $result['hsts_sub']\n\t\t\t|| $hsts_preload != $result['hsts_preload']\n\t\t\t|| $phpsettingid != $result['phpsettingid']\n\t\t\t|| $http2 != $result['http2']\n\t\t\t|| ($speciallogfile != $result['speciallogfile'] && $speciallogverified == '1')\n\t\t) {\n\t\t\t$stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t\t`documentroot` = :documentroot,\n\t\t\t\t\t`isemaildomain` = :isemaildomain,\n\t\t\t\t\t`wwwserveralias` = :wwwserveralias,\n\t\t\t\t\t`iswildcarddomain` = :iswildcarddomain,\n\t\t\t\t\t`aliasdomain` = :aliasdomain,\n\t\t\t\t\t`openbasedir_path` = :openbasedir_path,\n\t\t\t\t\t`ssl_enabled` = :sslenabled,\n\t\t\t\t\t`ssl_redirect` = :ssl_redirect,\n\t\t\t\t\t`letsencrypt` = :letsencrypt,\n\t\t\t\t\t`http2` = :http2,\n\t\t\t\t\t`hsts` = :hsts,\n\t\t\t\t\t`hsts_sub` = :hsts_sub,\n\t\t\t\t\t`hsts_preload` = :hsts_preload,\n\t\t\t\t\t`phpsettingid` = :phpsettingid,\n\t\t\t\t\t`speciallogfile` = :speciallogfile\n\t\t\t\t\tWHERE `customerid`= :customerid AND `id`= :id\n\t\t\t\t\");\n\t\t\t$params = [\n\t\t\t\t\"documentroot\" => $path,\n\t\t\t\t\"isemaildomain\" => $isemaildomain,\n\t\t\t\t\"wwwserveralias\" => $wwwserveralias,\n\t\t\t\t\"iswildcarddomain\" => $iswildcarddomain,\n\t\t\t\t\"aliasdomain\" => ($aliasdomain != 0 && $alias_check == 0) ? $aliasdomain : null,\n\t\t\t\t\"openbasedir_path\" => $openbasedir_path,\n\t\t\t\t\"sslenabled\" => $sslenabled,\n\t\t\t\t\"ssl_redirect\" => $ssl_redirect,\n\t\t\t\t\"letsencrypt\" => $letsencrypt,\n\t\t\t\t\"http2\" => $http2,\n\t\t\t\t\"hsts\" => $hsts_maxage,\n\t\t\t\t\"hsts_sub\" => $hsts_sub,\n\t\t\t\t\"hsts_preload\" => $hsts_preload,\n\t\t\t\t\"phpsettingid\" => $phpsettingid,\n\t\t\t\t\"speciallogfile\" => $speciallogfile,\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"id\" => $id\n\t\t\t];\n\t\t\tDatabase::pexecute($stmt, $params, true, true);\n\n\t\t\tif ($result['aliasdomain'] != $aliasdomain && is_numeric($result['aliasdomain'])) {\n\t\t\t\t// trigger when domain id for alias destination has changed: both for old and new destination\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($result['aliasdomain'], $this->logger());\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t}\n\t\t\tif ($result['wwwserveralias'] != $wwwserveralias || $result['letsencrypt'] != $letsencrypt) {\n\t\t\t\t// or when wwwserveralias or letsencrypt was changed\n\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($aliasdomain, $this->logger());\n\t\t\t\tif ((int)$aliasdomain === 0) {\n\t\t\t\t\t// in case the wwwserveralias is set on a main domain, $aliasdomain is 0\n\t\t\t\t\t// --> the call just above to triggerLetsEncryptCSRForAliasDestinationDomain\n\t\t\t\t\t// is a noop...let's repeat it with the domain id of the main domain\n\t\t\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($id, $this->logger());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check whether LE has been disabled, so we remove the certificate\n\t\t\tif ($letsencrypt == '0' && $result['letsencrypt'] == '1') {\n\t\t\t\t$del_stmt = Database::prepare(\"\n\t\t\t\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = :id\n\t\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($del_stmt, [\n\t\t\t\t\t'id' => $id\n\t\t\t\t], true, true);\n\t\t\t\t// remove domain from acme.sh / lets encrypt if used\n\t\t\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_SSL, $result['domain']);\n\t\t\t}\n\n\t\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, \"[API] edited domain '\" . $idna_convert->decode($result['domain']) . \"'\");\n\t\t}\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id\n\t\t]);\n\t\treturn $this->response($result);\n\t}\n\n\t/**\n\t * lists all customer domain/subdomain entries\n\t *\n\t * @param bool $with_ips\n\t *            optional, default true\n\t * @param int $customerid\n\t *            optional, admin-only, select (sub)domains of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select (sub)domains of a specific customer by loginname\n\t * @param array $sql_search\n\t *            optional array with index = fieldname, and value = array with 'op' => operator (one of <, > or =),\n\t *            LIKE is used if left empty and 'value' => searchvalue\n\t * @param int $sql_limit\n\t *            optional specify number of results to be returned\n\t * @param int $sql_offset\n\t *            optional specify offset for resultset\n\t * @param array $sql_orderby\n\t *            optional array with index = fieldname and value = ASC|DESC to order the resultset by one or more\n\t *            fields\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array count|list\n\t * @throws Exception\n\t */\n\tpublic function listing()\n\t{\n\t\t$with_ips = $this->getParam('with_ips', true, true);\n\t\tif ($this->isAdmin()) {\n\t\t\t// if we're an admin, list all subdomains of all the admins customers\n\t\t\t// or optionally for one specific customer identified by id or loginname\n\t\t\t$customerid = $this->getParam('customerid', true, 0);\n\t\t\t$loginname = $this->getParam('loginname', true, '');\n\n\t\t\tif (!empty($customerid) || !empty($loginname)) {\n\t\t\t\t$result = $this->apiCall('Customers.get', [\n\t\t\t\t\t'id' => $customerid,\n\t\t\t\t\t'loginname' => $loginname\n\t\t\t\t]);\n\t\t\t\t$custom_list_result = [\n\t\t\t\t\t$result\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t}\n\t\t\t$customer_ids = [];\n\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t}\n\t\t\tif (empty($customer_ids)) {\n\t\t\t\tthrow new Exception(\"Required resource unsatisfied.\", 405);\n\t\t\t}\n\n\t\t\t$select_fields = [\n\t\t\t\t'`d`.*'\n\t\t\t];\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$customer_ids = [\n\t\t\t\t$this->getUserDetail('customerid')\n\t\t\t];\n\n\t\t\t$select_fields = [\n\t\t\t\t'`d`.`id`',\n\t\t\t\t'`d`.`customerid`',\n\t\t\t\t'`d`.`domain`',\n\t\t\t\t'`d`.`domain_ace`',\n\t\t\t\t'`d`.`documentroot`',\n\t\t\t\t'`d`.`isbinddomain`',\n\t\t\t\t'`d`.`isemaildomain`',\n\t\t\t\t'`d`.`caneditdomain`',\n\t\t\t\t'`d`.`iswildcarddomain`',\n\t\t\t\t'`d`.`parentdomainid`',\n\t\t\t\t'`d`.`letsencrypt`',\n\t\t\t\t'`d`.`registration_date`',\n\t\t\t\t'`d`.`termination_date`',\n\t\t\t\t'`d`.`deactivated`'\n\t\t\t];\n\t\t}\n\t\t$query_fields = [];\n\n\t\t// prepare select statement\n\t\t$domains_stmt = Database::prepare(\"\n\t\t\tSELECT \" . implode(\",\", $select_fields) . \", IF(`d`.`parentdomainid` > 0, `pd`.`domain_ace`, `d`.`domain_ace`) AS `parentdomainname`, `ad`.`id` AS `aliasdomainid`, `ad`.`domain` AS `aliasdomain`, `da`.`id` AS `domainaliasid`, `da`.`domain` AS `domainalias`\n\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` `d`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `ad` ON `d`.`aliasdomain`=`ad`.`id`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `da` ON `da`.`aliasdomain`=`d`.`id`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_DOMAINS . \"` `pd` ON `pd`.`id`=`d`.`parentdomainid`\n\t\t\tWHERE `d`.`customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\tAND `d`.`email_only` = '0'\n\t\t\t\" . $this->getSearchWhere($query_fields, true) . \" GROUP BY `d`.`id` ORDER BY `parentdomainname` ASC, `d`.`parentdomainid` ASC \" . $this->getOrderBy(true) . $this->getLimit());\n\n\t\t$result = [];\n\t\tDatabase::pexecute($domains_stmt, $query_fields, true, true);\n\t\twhile ($row = $domains_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$row['ipsandports'] = [];\n\t\t\tif ($with_ips) {\n\t\t\t\t$row['ipsandports'] = $this->getIpsForDomain($row['id']);\n\t\t\t}\n\t\t\t$row['domain_hascert'] = $this->getHasCertValueForDomain((int)$row['id'], (int)$row['parentdomainid']);\n\t\t\t$result[] = $row;\n\t\t}\n\t\treturn $this->response([\n\t\t\t'count' => count($result),\n\t\t\t'list' => $result\n\t\t]);\n\t}\n\n\t/**\n\t * get ips connected to given domain as array\n\t *\n\t * @param number $domain_id\n\t * @param bool $ssl_only\n\t *            optional, return only ssl enabled ip's, default false\n\t * @return array\n\t */\n\tprivate function getIpsForDomain($domain_id = 0, $ssl_only = false)\n\t{\n\t\t$fields = '`ips`.ip, `ips`.port, `ips`.ssl';\n\t\tif ($this->isAdmin()) {\n\t\t\t$fields = '`ips`.*';\n\t\t}\n\t\t$resultips_stmt = Database::prepare(\"\n\t\t\tSELECT \" . $fields . \" FROM `\" . TABLE_DOMAINTOIP . \"` AS `dti`, `\" . TABLE_PANEL_IPSANDPORTS . \"` AS `ips`\n\t\t\tWHERE `dti`.`id_ipandports` = `ips`.`id` AND `dti`.`id_domain` = :domainid \" . ($ssl_only ? \" AND `ips`.`ssl` = '1'\" : \"\"));\n\n\t\tDatabase::pexecute($resultips_stmt, [\n\t\t\t'domainid' => $domain_id\n\t\t]);\n\n\t\t$ipandports = [];\n\t\twhile ($rowip = $resultips_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif (filter_var($rowip['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$rowip['is_ipv6'] = true;\n\t\t\t}\n\t\t\t$ipandports[] = $rowip;\n\t\t}\n\n\t\treturn $ipandports;\n\t}\n\n\t/**\n\t * returns the total number of accessible subdomain entries\n\t *\n\t * @param int $customerid\n\t *            optional, admin-only, select (sub)domains of a specific customer by id\n\t * @param string $loginname\n\t *            optional, admin-only, select (sub)domains of a specific customer by loginname\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded response message\n\t * @throws Exception\n\t */\n\tpublic function listingCount()\n\t{\n\t\tif ($this->isAdmin()) {\n\t\t\t// if we're an admin, list all databases of all the admins customers\n\t\t\t// or optionally for one specific customer identified by id or loginname\n\t\t\t$customerid = $this->getParam('customerid', true, 0);\n\t\t\t$loginname = $this->getParam('loginname', true, '');\n\n\t\t\tif (!empty($customerid) || !empty($loginname)) {\n\t\t\t\t$result = $this->apiCall('Customers.get', [\n\t\t\t\t\t'id' => $customerid,\n\t\t\t\t\t'loginname' => $loginname\n\t\t\t\t]);\n\t\t\t\t$custom_list_result = [\n\t\t\t\t\t$result\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$_custom_list_result = $this->apiCall('Customers.listing');\n\t\t\t\t$custom_list_result = $_custom_list_result['list'];\n\t\t\t}\n\t\t\t$customer_ids = [];\n\t\t\t$customer_stdsubs = [];\n\t\t\tforeach ($custom_list_result as $customer) {\n\t\t\t\t$customer_ids[] = $customer['customerid'];\n\t\t\t\t$customer_stdsubs[$customer['customerid']] = $customer['standardsubdomain'];\n\t\t\t}\n\t\t} else {\n\t\t\tif (Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t\t}\n\t\t\t$customer_ids = [\n\t\t\t\t$this->getUserDetail('customerid')\n\t\t\t];\n\t\t\t$customer_stdsubs = [\n\t\t\t\t$this->getUserDetail('customerid') => $this->getUserDetail('standardsubdomain')\n\t\t\t];\n\t\t}\n\t\tif (!empty($customer_ids)) {\n\t\t\t// prepare select statement\n\t\t\t$domains_stmt = Database::prepare(\"\n\t\t\t\tSELECT COUNT(*) as num_subdom\n\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"` `d`\n\t\t\t\tWHERE `d`.`customerid` IN (\" . implode(', ', $customer_ids) . \")\n\t\t\t\tAND `d`.`email_only` = '0'\n\t\t\t\tAND `d`.`id` NOT IN (\" . implode(', ', $customer_stdsubs) . \")\n\t\t\t\");\n\t\t\t$result = Database::pexecute_first($domains_stmt, null, true, true);\n\t\t\tif ($result) {\n\t\t\t\treturn $this->response($result['num_subdom']);\n\t\t\t}\n\t\t}\n\t\treturn $this->response(0);\n\t}\n\n\t/**\n\t * delete a subdomain by either id or domainname\n\t *\n\t * @param int $id\n\t *            optional, the domain-id\n\t * @param string $domainname\n\t *            optional, the domainname\n\t * @param int $customerid\n\t *            optional, required when called as admin (if $loginname is not specified)\n\t * @param string $loginname\n\t *            optional, required when called as admin (if $customerid is not specified)\n\t *\n\t * @access admin, customer\n\t * @return string json-encoded array\n\t * @throws Exception\n\t */\n\tpublic function delete()\n\t{\n\t\t$id = $this->getParam('id', true, 0);\n\t\t$dn_optional = $id > 0;\n\t\t$domainname = $this->getParam('domainname', $dn_optional, '');\n\n\t\tif ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'domains')) {\n\t\t\tthrow new Exception(\"You cannot access this resource\", 405);\n\t\t}\n\n\t\t$result = $this->apiCall('SubDomains.get', [\n\t\t\t'id' => $id,\n\t\t\t'domainname' => $domainname\n\t\t]);\n\t\t$id = $result['id'];\n\n\t\t// get needed customer info to reduce the subdomain-usage-counter by one\n\t\t$customer = $this->getCustomerData();\n\n\t\tif (!$this->isAdmin() && $result['caneditdomain'] == 0) {\n\t\t\tthrow new Exception(\"You cannot edit this resource\", 405);\n\t\t}\n\n\t\tif ($result['isemaildomain'] == '1') {\n\t\t\t// check for e-mail addresses\n\t\t\t$emails_stmt = Database::prepare(\"\n\t\t\t\tSELECT COUNT(`id`) AS `count` FROM `\" . TABLE_MAIL_VIRTUAL . \"`\n\t\t\t\tWHERE `customerid` = :customerid AND `domainid` = :domainid\n\t\t\t\");\n\t\t\t$emails = Database::pexecute_first($emails_stmt, [\n\t\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\t\"domainid\" => $id\n\t\t\t], true, true);\n\n\t\t\tif ($emails['count'] != '0') {\n\t\t\t\tResponse::standardError('domains_cantdeletedomainwithemail', '', true);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)$result['aliasdomain'] !== 0) {\n\t\t\tDomain::triggerLetsEncryptCSRForAliasDestinationDomain($result['aliasdomain'], $this->logger());\n\t\t}\n\n\t\t// delete domain from table\n\t\t$stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAINS . \"` WHERE `customerid` = :customerid AND `id` = :id\n\t\t\");\n\t\tDatabase::pexecute($stmt, [\n\t\t\t\"customerid\" => $customer['customerid'],\n\t\t\t\"id\" => $id\n\t\t], true, true);\n\n\t\t// remove connections to ips and domainredirects\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\tWHERE `id_domain` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove redirect-codes\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAINREDIRECTS . \"`\n\t\t\tWHERE `did` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove certificate from domain_ssl_settings, fixes #1596\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"`\n\t\t\tWHERE `domainid` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\t// remove possible existing DNS entries\n\t\t$del_stmt = Database::prepare(\"\n\t\t\tDELETE FROM `\" . TABLE_DOMAIN_DNS . \"`\n\t\t\tWHERE `domain_id` = :domainid\n\t\t\");\n\t\tDatabase::pexecute($del_stmt, [\n\t\t\t'domainid' => $id\n\t\t], true, true);\n\n\t\tCronjob::inserttask(TaskId::REBUILD_VHOST);\n\t\t// Using nameserver, insert a task which rebuilds the server config\n\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t// remove domains DNS from powerDNS if used, #581\n\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_PDNS, $result['domain']);\n\t\t// remove domain from acme.sh / lets encrypt if used\n\t\tCronjob::inserttask(TaskId::DELETE_DOMAIN_SSL, $result['domain']);\n\n\t\t// reduce subdomain-usage-counter\n\t\tCustomers::decreaseUsage($customer['customerid'], 'subdomains_used');\n\n\t\t$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_WARNING, \"[API] deleted subdomain '\" . $result['domain'] . \"'\");\n\t\treturn $this->response($result);\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Cron\\Http;\n\nuse Froxlor\\Froxlor;\nuse Froxlor\\Cron\\Http\\Php\\PhpInterface;\nuse Froxlor\\Customer\\Customer;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Domain\\Domain;\nuse Froxlor\\FileDir;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Http\\Directory;\nuse Froxlor\\Http\\Statistics;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\Validate\\Validate;\nuse Froxlor\\System\\Crypt;\nuse PDO;\n\nclass Apache extends HttpConfigBase\n{\n\n\t// protected\n\tprotected $known_diroptionsfilenames = [];\n\n\tprotected $known_htpasswdsfilenames = [];\n\n\tprotected $virtualhosts_data = [];\n\n\tprotected $diroptions_data = [];\n\n\tprotected $htpasswds_data = [];\n\n\t/**\n\t * indicator whether a customer is deactivated or not\n\t * if yes, only the webroot will be generated\n\t *\n\t * @var bool\n\t */\n\tprivate $deactivated = false;\n\n\tpublic function createIpPort()\n\t{\n\t\t$result_ipsandports_stmt = Database::query(\"SELECT * FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` ORDER BY `ip` ASC, `port` ASC\");\n\n\t\twhile ($row_ipsandports = $result_ipsandports_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif (filter_var($row_ipsandports['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$ipport = '[' . $row_ipsandports['ip'] . ']:' . $row_ipsandports['port'];\n\t\t\t} else {\n\t\t\t\t$ipport = $row_ipsandports['ip'] . ':' . $row_ipsandports['port'];\n\t\t\t}\n\n\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'apache::createIpPort: creating ip/port settings for  ' . $ipport);\n\t\t\t$vhosts_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_vhost') . '/10_froxlor_ipandport_' . trim(str_replace(':', '.', $row_ipsandports['ip']), '.') . '.' . $row_ipsandports['port'] . '.conf');\n\n\t\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['listen_statement'] == '1') {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'Listen ' . $ipport . \"\\n\";\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted listen-statement');\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['namevirtualhost_statement'] == '1') {\n\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, $ipport . ' :: namevirtualhost-statement no longer needed for apache-2.4');\n\t\t\t\t} else {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'NameVirtualHost ' . $ipport . \"\\n\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted namevirtualhost-statement');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($row_ipsandports['vhostcontainer'] == '1') {\n\t\t\t\t$without_vhost = $this->virtualhosts_data[$vhosts_filename];\n\t\t\t\t$close_vhost = true;\n\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '<VirtualHost ' . $ipport . '>' . \"\\n\";\n\n\t\t\t\t$mypath = $this->getMyPath($row_ipsandports);\n\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'DocumentRoot \"' . rtrim($mypath, \"/\") . '\"' . \"\\n\";\n\n\t\t\t\tif ($row_ipsandports['vhostcontainer_servername_statement'] == '1') {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' ServerName ' . Settings::Get('system.hostname') . \"\\n\";\n\n\t\t\t\t\t$froxlor_aliases = Settings::Get('system.froxloraliases');\n\t\t\t\t\tif (!empty($froxlor_aliases)) {\n\t\t\t\t\t\t$froxlor_aliases = explode(\",\", $froxlor_aliases);\n\t\t\t\t\t\t$aliases = \"\";\n\t\t\t\t\t\tforeach ($froxlor_aliases as $falias) {\n\t\t\t\t\t\t\tif (Validate::validateDomain(trim($falias))) {\n\t\t\t\t\t\t\t\t$aliases .= trim($falias) . \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$aliases = trim($aliases);\n\t\t\t\t\t\tif (!empty($aliases)) {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' ServerAlias ' . $aliases . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$is_redirect = false;\n\t\t\t\t// check for SSL redirect\n\t\t\t\tif ($row_ipsandports['ssl'] == '0' && Settings::Get('system.le_froxlor_redirect') == '1') {\n\t\t\t\t\t$is_redirect = true;\n\t\t\t\t\t// check whether froxlor uses Let's Encrypt and not cert is being generated yet\n\t\t\t\t\t// or a renewal is ongoing - disable redirect\n\t\t\t\t\tif (Settings::Get('system.le_froxlor_enabled') && ($this->froxlorVhostHasLetsEncryptCert() == false || $this->froxlorVhostLetsEncryptNeedsRenew())) {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# temp. disabled ssl-redirect due to Let\\'s Encrypt certificate generation.' . PHP_EOL;\n\t\t\t\t\t\t$is_redirect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$_sslport = $this->checkAlternativeSslPort();\n\n\t\t\t\t\t\t$mypath = 'https://' . Settings::Get('system.hostname') . $_sslport . '/';\n\t\t\t\t\t\t$code = '301';\n\t\t\t\t\t\t$modrew_red = ' [R=' . $code . ';L,NE]';\n\n\t\t\t\t\t\t// redirect everything, not only root-directory, #541\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <IfModule mod_rewrite.c>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteEngine On' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteCond %{HTTPS} off' . \"\\n\";\n\t\t\t\t\t\tif (Settings::Get('system.le_froxlor_enabled') == '1') {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    RewriteRule ^/(.*) ' . $mypath . '$1' . $modrew_red . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </IfModule>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <IfModule !mod_rewrite.c>' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Redirect ' . $code . ' / ' . $mypath . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </IfModule>' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$is_redirect) {\n\t\t\t\t\tif (Settings::Get('system.froxlordirectlyviahostname')) {\n\t\t\t\t\t\t$relpath = \"/\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$relpath = \"/\".basename(Froxlor::getInstallDir());\n\t\t\t\t\t}\n\t\t\t\t\t// protect lib/userdata.inc.php\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . rtrim($relpath, \"/\") . '/lib/\">' . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    <Files \"userdata.inc.php\">' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all denied' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order deny,allow' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    deny from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </Files>' . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t// protect bin/\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <DirectoryMatch \"^' . rtrim($relpath, \"/\") . '/(bin|cache|logs|tests|vendor)/\">' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all denied' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order deny,allow' . \"\\n\";\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    deny from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </DirectoryMatch>' . \"\\n\";\n\n\t\t\t\t\t// create fcgid <Directory>-Part (starter is created in apache_fcgid)\n\t\t\t\t\tif (Settings::Get('system.mod_fcgid_ownvhost') == '1' && Settings::Get('system.mod_fcgid') == '1') {\n\t\t\t\t\t\t$configdir = FileDir::makeCorrectDir(Settings::Get('system.mod_fcgid_configdir') . '/froxlor.panel/' . Settings::Get('system.hostname'));\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  FcgidIdleTimeout ' . Settings::Get('system.mod_fcgid_idle_timeout') . \"\\n\";\n\t\t\t\t\t\tif ((int)Settings::Get('system.mod_fcgid_wrapper') == 0) {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SuexecUserGroup \"' . Settings::Get('system.mod_fcgid_httpuser') . '\" \"' . Settings::Get('system.mod_fcgid_httpgroup') . '\"' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  ScriptAlias /php/ ' . $configdir . \"\\n\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t\t'mod_fcgid_starter' => -1,\n\t\t\t\t\t\t\t\t'mod_fcgid_maxrequests' => -1,\n\t\t\t\t\t\t\t\t'guid' => Settings::Get('system.mod_fcgid_httpuser'),\n\t\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t$php = new PhpInterface($domain);\n\t\t\t\t\t\t\t$phpconfig = $php->getPhpConfig(Settings::Get('system.mod_fcgid_defaultini_ownvhost'));\n\n\t\t\t\t\t\t\t$starter_filename = FileDir::makeCorrectFile($configdir . '/php-fcgi-starter');\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SuexecUserGroup \"' . Settings::Get('system.mod_fcgid_httpuser') . '\" \"' . Settings::Get('system.mod_fcgid_httpgroup') . '\"' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t$file_extensions = explode(' ', $phpconfig['file_extensions']);\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    <FilesMatch \"\\.(' . implode('|', $file_extensions) . ')$\">' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      SetHandler fcgid-script' . \"\\n\";\n\t\t\t\t\t\t\tforeach ($file_extensions as $file_extension) {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      FcgidWrapper ' . $starter_filename . ' .' . $file_extension . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      Options +ExecCGI' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\t$mypath_dir = new Directory($mypath);\n\t\t\t\t\t\t\t\t// only create the require all granted if there is not active directory-protection\n\t\t\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif (Settings::Get('phpfpm.enabled') == '1' && (int)Settings::Get('phpfpm.enabled_ownvhost') == 1) {\n\t\t\t\t\t\t// get fpm config\n\t\t\t\t\t\t$fpm_sel_stmt = Database::prepare(\"\n\t\t\t\t\t\t\tSELECT f.id FROM `\" . TABLE_PANEL_FPMDAEMONS . \"` f\n\t\t\t\t\t\t\tLEFT JOIN `\" . TABLE_PANEL_PHPCONFIGS . \"` p ON p.fpmsettingid = f.id\n\t\t\t\t\t\t\tWHERE p.id = :phpconfigid\n\t\t\t\t\t\t\");\n\t\t\t\t\t\t$fpm_config = Database::pexecute_first($fpm_sel_stmt, [\n\t\t\t\t\t\t\t'phpconfigid' => Settings::Get('phpfpm.vhost_defaultini')\n\t\t\t\t\t\t]);\n\t\t\t\t\t\t// create php-fpm <Directory>-Part (config is created in apache_fcgid)\n\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t'mod_fcgid_starter' => -1,\n\t\t\t\t\t\t\t'mod_fcgid_maxrequests' => -1,\n\t\t\t\t\t\t\t'guid' => Settings::Get('phpfpm.vhost_httpuser'),\n\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t'customerroot' => $mypath,\n\t\t\t\t\t\t\t'fpm_config_id' => isset($fpm_config['id']) ? $fpm_config['id'] : 1\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\t$php = new phpinterface($domain);\n\t\t\t\t\t\t$phpconfig = $php->getPhpConfig(Settings::Get('phpfpm.vhost_defaultini'));\n\t\t\t\t\t\t$srvName = substr(md5($ipport), 0, 4) . '.fpm.external';\n\t\t\t\t\t\tif ($row_ipsandports['ssl']) {\n\t\t\t\t\t\t\t$srvName = substr(md5($ipport), 0, 4) . '.ssl-fpm.external';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// mod_proxy stuff for apache-2.4\n\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1' && Settings::Get('phpfpm.use_mod_proxy') == '1') {\n\t\t\t\t\t\t\t$filesmatch = $phpconfig['fpm_settings']['limit_extensions'];\n\t\t\t\t\t\t\t$extensions = explode(\" \", $filesmatch);\n\t\t\t\t\t\t\t$filesmatch = \"\";\n\t\t\t\t\t\t\tforeach ($extensions as $ext) {\n\t\t\t\t\t\t\t\t$filesmatch .= substr($ext, 1) . '|';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// start block, cut off last pipe and close block\n\t\t\t\t\t\t\t$filesmatch = '(' . str_replace(\".\", \"\\.\", substr($filesmatch, 0, -1)) . ')';\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <FilesMatch \\.' . $filesmatch . '$>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  SetHandler proxy:unix:' . $php->getInterface()->getSocketFile() . '|fcgi://localhost' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\tif ($phpconfig['pass_authorizationheader'] == '1') {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      CGIPassAuth On' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$addheader = \"\";\n\t\t\t\t\t\t\tif ($phpconfig['pass_authorizationheader'] == '1') {\n\t\t\t\t\t\t\t\t$addheader = \" -pass-header Authorization\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  FastCgiExternalServer ' . $php->getInterface()->getAliasConfigDir() . $srvName . ' -socket ' . $php->getInterface()->getSocketFile() . ' -idle-timeout ' . $phpconfig['fpm_settings']['idle_timeout'] . $addheader . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . $mypath . '\">' . \"\\n\";\n\t\t\t\t\t\t\t$filesmatch = $phpconfig['fpm_settings']['limit_extensions'];\n\t\t\t\t\t\t\t$extensions = explode(\" \", $filesmatch);\n\t\t\t\t\t\t\t$filesmatch = \"\";\n\t\t\t\t\t\t\tforeach ($extensions as $ext) {\n\t\t\t\t\t\t\t\t$filesmatch .= substr($ext, 1) . '|';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// start block, cut off last pipe and close block\n\t\t\t\t\t\t\t$filesmatch = '(' . str_replace(\".\", \"\\.\", substr($filesmatch, 0, -1)) . ')';\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '   <FilesMatch \\.' . $filesmatch . '$>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '     AddHandler php-fastcgi .php' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '     Action php-fastcgi /fastcgiphp' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '      Options +ExecCGI' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    </FilesMatch>' . \"\\n\";\n\t\t\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\t$mypath_dir = new Directory($mypath);\n\t\t\t\t\t\t\t\t// only create the require all granted if there is not active directory-protection\n\t\t\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '  Alias /fastcgiphp ' . $php->getInterface()->getAliasConfigDir() . $srvName . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// mod_php\n\t\t\t\t\t\t$domain = [\n\t\t\t\t\t\t\t'id' => 'none',\n\t\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t\t'guid' => Settings::Get('system.httpuser'),\n\t\t\t\t\t\t\t'openbasedir' => 0,\n\t\t\t\t\t\t\t'email' => Settings::Get('panel.adminmail'),\n\t\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\t// end of ssl-redirect check\n\t\t\t\t} else {\n\t\t\t\t\t// fallback of froxlor domain-data for processSpecialConfigTemplate()\n\t\t\t\t\t$domain = [\n\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t'customerroot' => $mypath\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * dirprotection, see #72\n\t\t\t\t *\n\t\t\t\t * @todo deferred until 0.9.5, needs more testing\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t<Directory \\\"'.$mypath.'(images|packages|templates)\\\">\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tAllow from all\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tOptions -Indexes\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t</Directory>\\n\";\n\t\t\t\t *\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t<Directory \\\"'.$mypath.'*\\\">\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tOrder Deny,Allow\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t\\tDeny from All\\n\";\n\t\t\t\t *       $this->virtualhosts_data[$vhosts_filename] .= \"\\t</Directory>\\n\";\n\t\t\t\t *       end of dirprotection\n\t\t\t\t */\n\n\t\t\t\tif ($row_ipsandports['specialsettings'] != '' && ($row_ipsandports['ssl'] == '0' || ($row_ipsandports['ssl'] == '1' && Settings::Get('system.use_ssl') == '1' && $row_ipsandports['include_specialsettings'] == '1'))) {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->processSpecialConfigTemplate($row_ipsandports['specialsettings'], $domain, $row_ipsandports['ip'], $row_ipsandports['port'], $row_ipsandports['ssl'] == '1') . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($row_ipsandports['ssl'] == '1' && Settings::Get('system.use_ssl') == '1') {\n\t\t\t\t\tif ($row_ipsandports['ssl_specialsettings'] != '') {\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->processSpecialConfigTemplate($row_ipsandports['ssl_specialsettings'], $domain, $row_ipsandports['ip'], $row_ipsandports['port'], $row_ipsandports['ssl'] == '1') . \"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for required fallback\n\t\t\t\t\tif (($row_ipsandports['ssl_cert_file'] == '' || !file_exists($row_ipsandports['ssl_cert_file'])) && (Settings::Get('system.le_froxlor_enabled') == '0' || $this->froxlorVhostHasLetsEncryptCert() == false)) {\n\t\t\t\t\t\t$row_ipsandports['ssl_cert_file'] = Settings::Get('system.ssl_cert_file');\n\t\t\t\t\t\tif (!file_exists($row_ipsandports['ssl_cert_file'])) {\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate file \"' . Settings::Get('system.ssl_cert_file') . '\" does not seem to exist. Creating self-signed certificate...');\n\t\t\t\t\t\t\tCrypt::createSelfSignedCertificate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($row_ipsandports['ssl_key_file'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_key_file'] = Settings::Get('system.ssl_key_file');\n\t\t\t\t\t\tif (!file_exists($row_ipsandports['ssl_key_file'])) {\n\t\t\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t\t\t$row_ipsandports['ssl_cert_file'] = \"\";\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate key-file \"' . Settings::Get('system.ssl_key_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . Settings::Get('system.hostname') . '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($row_ipsandports['ssl_ca_file'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_ca_file'] = Settings::Get('system.ssl_ca_file');\n\t\t\t\t\t}\n\n\t\t\t\t\t// #418\n\t\t\t\t\tif ($row_ipsandports['ssl_cert_chainfile'] == '') {\n\t\t\t\t\t\t$row_ipsandports['ssl_cert_chainfile'] = Settings::Get('system.ssl_cert_chainfile');\n\t\t\t\t\t}\n\n\t\t\t\t\t$domain = [\n\t\t\t\t\t\t'id' => 0,\n\t\t\t\t\t\t'domain' => Settings::Get('system.hostname'),\n\t\t\t\t\t\t'adminid' => 1, /* first admin-user (superadmin) */\n\t\t\t\t\t\t'loginname' => 'froxlor.panel',\n\t\t\t\t\t\t'documentroot' => $mypath,\n\t\t\t\t\t\t'customerroot' => $mypath,\n\t\t\t\t\t\t'parentdomainid' => 0,\n\t\t\t\t\t\t'ssl_honorcipherorder' => Settings::Get('system.honorcipherorder'),\n\t\t\t\t\t\t'ssl_sessiontickets' => Settings::Get('system.sessiontickets')\n\t\t\t\t\t];\n\n\t\t\t\t\t// override corresponding array values\n\t\t\t\t\t$domain['ssl_cert_file'] = $row_ipsandports['ssl_cert_file'];\n\t\t\t\t\t$domain['ssl_key_file'] = $row_ipsandports['ssl_key_file'];\n\t\t\t\t\t$domain['ssl_ca_file'] = $row_ipsandports['ssl_ca_file'];\n\t\t\t\t\t$domain['ssl_cert_chainfile'] = $row_ipsandports['ssl_cert_chainfile'];\n\n\t\t\t\t\t// SSL STUFF\n\t\t\t\t\t$dssl = new DomainSSL();\n\t\t\t\t\t// this sets the ssl-related array-indices in the $domain array\n\t\t\t\t\t// if the domain has customer-defined ssl-certificates\n\t\t\t\t\t$dssl->setDomainSSLFilesArray($domain);\n\n\t\t\t\t\tif ($domain['ssl_cert_file'] != '') {\n\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\tif (!file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate file \"' . $domain['ssl_cert_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLEngine On' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLProtocol -ALL +' . str_replace(\",\", \" +\", Settings::Get('system.ssl_protocols')) . \"\\n\";\n\t\t\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t\t\tif (Settings::Get('system.http2_support') == '1') {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' Protocols h2 http/1.1' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!empty(Settings::Get('system.dhparams_file'))) {\n\t\t\t\t\t\t\t\t\t$dhparams = FileDir::makeCorrectFile(Settings::Get('system.dhparams_file'));\n\t\t\t\t\t\t\t\t\tif (!file_exists($dhparams)) {\n\t\t\t\t\t\t\t\t\t\tFileDir::safe_exec('openssl dhparam -out ' . escapeshellarg($dhparams) . ' 4096');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLOpenSSLConfCmd DHParameters \"' . $dhparams . '\"' . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCompression Off' . \"\\n\";\n\t\t\t\t\t\t\t\tif (Settings::Get('system.sessionticketsenabled') == '1') {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLSessionTickets ' . ($domain['ssl_sessiontickets'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLHonorCipherOrder ' . ($domain['ssl_honorcipherorder'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCipherSuite ' . Settings::Get('system.ssl_cipher_list') . \"\\n\";\n\t\t\t\t\t\t\t$protocols = array_map('trim', explode(\",\", Settings::Get('system.ssl_protocols')));\n\t\t\t\t\t\t\tif (in_array(\"TLSv1.3\", $protocols) && !empty(Settings::Get('system.tlsv13_cipher_list')) && Settings::Get('system.apache24') == 1) {\n\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCipherSuite TLSv1.3 ' . Settings::Get('system.tlsv13_cipher_list') . \"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLVerifyDepth 10' . \"\\n\";\n\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateFile ' . FileDir::makeCorrectFile($domain['ssl_cert_file']) . \"\\n\";\n\n\t\t\t\t\t\t\tif ($domain['ssl_key_file'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_key_file'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate key file \"' . $domain['ssl_key_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateKeyFile ' . FileDir::makeCorrectFile($domain['ssl_key_file']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ($domain['ssl_ca_file'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_ca_file'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate CA file \"' . $domain['ssl_ca_file'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCACertificateFile ' . FileDir::makeCorrectFile($domain['ssl_ca_file']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// #418\n\t\t\t\t\t\t\tif ($domain['ssl_cert_chainfile'] != '') {\n\t\t\t\t\t\t\t\t// check for existence, #1485\n\t\t\t\t\t\t\t\tif (!file_exists($domain['ssl_cert_chainfile'])) {\n\t\t\t\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $ipport . ' :: certificate chain file \"' . $domain['ssl_cert_chainfile'] . '\" does not exist! Cannot create ssl-directives');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= ' SSLCertificateChainFile ' . FileDir::makeCorrectFile($domain['ssl_cert_chainfile']) . \"\\n\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if there is no cert-file specified but we are generating a ssl-vhost,\n\t\t\t\t\t\t// we should return an empty string because this vhost would suck dick, ref #1583\n\t\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $domain['domain'] . ' :: empty certificate file! Cannot create ssl-directives');\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = $without_vhost;\n\t\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# no ssl-certificate was specified for this domain, therefore no explicit vhost-container is being generated';\n\t\t\t\t\t\t$close_vhost = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($close_vhost) {\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '</VirtualHost>' . \"\\n\";\n\t\t\t\t}\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, $ipport . ' :: inserted vhostcontainer');\n\t\t\t}\n\t\t\tunset($vhosts_filename);\n\t\t}\n\n\t\t/**\n\t\t * bug #32\n\t\t */\n\t\t$this->createStandardDirectoryEntry();\n\n\t\t/**\n\t\t * bug #unknown-yet\n\t\t */\n\t\t$this->createStandardErrorHandler();\n\t}\n\n\t/**\n\t * define a standard <Directory>-statement, bug #32\n\t */\n\tprivate function createStandardDirectoryEntry()\n\t{\n\t\t$vhosts_folder = '';\n\t\tif (is_dir(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t$vhosts_folder = FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'));\n\t\t} else {\n\t\t\t$vhosts_folder = FileDir::makeCorrectDir(dirname(Settings::Get('system.apacheconf_vhost')));\n\t\t}\n\t\t$vhosts_filename = FileDir::makeCorrectFile($vhosts_folder . '/05_froxlor_dirfix_nofcgid.conf');\n\n\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t}\n\n\t\t$this->virtualhosts_data[$vhosts_filename] .= '  <Directory \"' . FileDir::makeCorrectDir(Settings::Get('system.documentroot_prefix')) . '\">' . \"\\n\";\n\n\t\t// check for custom values, see #1638\n\t\t$custom_opts = Settings::Get('system.apacheglobaldiropt');\n\t\tif (!empty($custom_opts)) {\n\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $custom_opts . \"\\n\";\n\t\t} else {\n\t\t\t// >=apache-2.4 enabled?\n\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Require all granted' . \"\\n\";\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    AllowOverride All' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '    allow from all' . \"\\n\";\n\t\t\t}\n\t\t}\n\t\t$this->virtualhosts_data[$vhosts_filename] .= '  </Directory>' . \"\\n\";\n\n\t\t$ocsp_cache_filename = FileDir::makeCorrectFile($vhosts_folder . '/03_froxlor_ocsp_cache.conf');\n\t\tif (Settings::Get('system.use_ssl') == '1' && Settings::Get('system.apache24') == 1) {\n\t\t\t$this->virtualhosts_data[$ocsp_cache_filename] = 'SSLStaplingCache ' . Settings::Get('system.apache24_ocsp_cache_path') . \"\\n\";\n\t\t} else {\n\t\t\tif (file_exists($ocsp_cache_filename)) {\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::_createStandardDirectoryEntry: unlinking ' . basename($ocsp_cache_filename));\n\t\t\t\tunlink(FileDir::makeCorrectFile($ocsp_cache_filename));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * define a default ErrorDocument-statement, bug #unknown-yet\n\t */\n\tprivate function createStandardErrorHandler()\n\t{\n\t\tif (Settings::Get('defaultwebsrverrhandler.enabled') == '1' && (Settings::Get('defaultwebsrverrhandler.err401') != '' || Settings::Get('defaultwebsrverrhandler.err403') != '' || Settings::Get('defaultwebsrverrhandler.err404') != '' || Settings::Get('defaultwebsrverrhandler.err500') != '')) {\n\t\t\t$vhosts_folder = '';\n\t\t\tif (is_dir(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t\t$vhosts_folder = FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'));\n\t\t\t} else {\n\t\t\t\t$vhosts_folder = FileDir::makeCorrectDir(dirname(Settings::Get('system.apacheconf_vhost')));\n\t\t\t}\n\n\t\t\t$vhosts_filename = FileDir::makeCorrectFile($vhosts_folder . '/05_froxlor_default_errorhandler.conf');\n\n\t\t\tif (!isset($this->virtualhosts_data[$vhosts_filename])) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] = '';\n\t\t\t}\n\n\t\t\t$statusCodes = [\n\t\t\t\t'401',\n\t\t\t\t'403',\n\t\t\t\t'404',\n\t\t\t\t'500'\n\t\t\t];\n\t\t\tforeach ($statusCodes as $statusCode) {\n\t\t\t\tif (Settings::Get('defaultwebsrverrhandler.err' . $statusCode) != '') {\n\t\t\t\t\t$defhandler = Settings::Get('defaultwebsrverrhandler.err' . $statusCode);\n\t\t\t\t\tif (!Validate::validateUrl($defhandler)) {\n\t\t\t\t\t\tif (substr($defhandler, 0, 1) != '\"' && substr($defhandler, -1, 1) != '\"') {\n\t\t\t\t\t\t\t$defhandler = '\"' . FileDir::makeCorrectFile($defhandler) . '\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= 'ErrorDocument ' . $statusCode . ' ' . $defhandler . \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function createOwnVhostStarter()\n\t{\n\t\treturn;\n\t}\n\n\t/**\n\t * We compose the virtualhost entries for the domains\n\t */\n\tpublic function createVirtualHosts()\n\t{\n\t\t$domains = WebserverBase::getVhostsToCreate();\n\t\tforeach ($domains as $domain) {\n\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'apache::createVirtualHosts: creating vhost container for domain ' . $domain['id'] . ', customer ' . $domain['loginname']);\n\t\t\t$vhosts_filename = $this->getVhostFilename($domain);\n\n\t\t\t// Apply header\n\t\t\t$this->virtualhosts_data[$vhosts_filename] = '# Domain ID: ' . $domain['id'] . ' - CustomerID: ' . $domain['customerid'] . ' - CustomerLogin: ' . $domain['loginname'] . \"\\n\";\n\n\t\t\t$ddr = Settings::Get('system.deactivateddocroot');\n\t\t\tif (($domain['deactivated'] == '1' || $domain['customer_deactivated'] == '1') && empty($ddr)) {\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= '# Customer/domain deactivated and a docroot for deactivated users hasn\\'t been set.' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t// Create vhost without ssl\n\t\t\t\t$this->virtualhosts_data[$vhosts_filename] .= $this->getVhostContent($domain, false);\n\n\t\t\t\tif ($domain['ssl_enabled'] == '1' && ($domain['ssl'] == '1' || $domain['ssl_redirect'] == '1')) {\n\t\t\t\t\t// Adding ssl stuff if enabled\n\t\t\t\t\t$vhosts_filename_ssl = $this->getVhostFilename($domain, true);\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename_ssl] = '# Domain ID: ' . $domain['id'] . ' (SSL) - CustomerID: ' . $domain['customerid'] . ' - CustomerLogin: ' . $domain['loginname'] . \"\\n\";\n\t\t\t\t\t$this->virtualhosts_data[$vhosts_filename_ssl] .= $this->getVhostContent($domain, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * We compose the virtualhost entry for one domain\n\t */\n\tprotected function getVhostContent($domain, $ssl_vhost = false)\n\t{\n\t\tif ($ssl_vhost === true && ($domain['ssl_redirect'] != '1' && $domain['ssl'] != '1')) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$query = \"SELECT * FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` `i`, `\" . TABLE_DOMAINTOIP . \"` `dip`\n\t\t\tWHERE dip.id_domain = :domainid AND i.id = dip.id_ipandports \";\n\n\t\tif ($ssl_vhost === true && ($domain['ssl'] == '1' || $domain['ssl_redirect'] == '1')) {\n\t\t\t// by ordering by cert-file the row with filled out SSL-Fields will be shown last, thus it is enough to fill out 1 set of SSL-Fields\n\t\t\t$query .= \"AND i.ssl = '1' ORDER BY i.ssl_cert_file ASC;\";\n\t\t} else {\n\t\t\t$query .= \"AND i.ssl = '0';\";\n\t\t}\n\n\t\t$vhost_content = '';\n\t\t$result_stmt = Database::prepare($query);\n\t\tDatabase::pexecute($result_stmt, [\n\t\t\t'domainid' => $domain['id']\n\t\t]);\n\n\t\t$ipportlist = '';\n\t\t$_vhost_content = '';\n\t\twhile ($ipandport = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$ipport = '';\n\t\t\t$domain['ip'] = $ipandport['ip'];\n\t\t\t$domain['port'] = $ipandport['port'];\n\t\t\tif ($domain['ssl'] == '1') {\n\t\t\t\t$domain['ssl_cert_file'] = $ipandport['ssl_cert_file'];\n\t\t\t\t$domain['ssl_key_file'] = $ipandport['ssl_key_file'];\n\t\t\t\t$domain['ssl_ca_file'] = $ipandport['ssl_ca_file'];\n\t\t\t\t$domain['ssl_cert_chainfile'] = $ipandport['ssl_cert_chainfile'];\n\n\t\t\t\t// SSL STUFF\n\t\t\t\t$dssl = new DomainSSL();\n\t\t\t\t// this sets the ssl-related array-indices in the $domain array\n\t\t\t\t// if the domain has customer-defined ssl-certificates\n\t\t\t\t$dssl->setDomainSSLFilesArray($domain);\n\t\t\t}\n\n\t\t\tif (filter_var($domain['ip'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n\t\t\t\t$ipport = '[' . $domain['ip'] . ']:' . $domain['port'] . ' ';\n\t\t\t} else {\n\t\t\t\t$ipport = $domain['ip'] . ':' . $domain['port'] . ' ';\n\t\t\t}\n\n\t\t\tif ($ipandport['default_vhostconf_domain'] != '' && ($ssl_vhost == false || ($ssl_vhost == true && $ipandport['include_default_vhostconf_domain'] == '1'))) {\n\t\t\t\t$_vhost_content .= $this->processSpecialConfigTemplate($ipandport['default_vhostconf_domain'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t\tif ($ipandport['ssl_default_vhostconf_domain'] != '' && $ssl_vhost == true) {\n\t\t\t\t$_vhost_content .= $this->processSpecialConfigTemplate($ipandport['ssl_default_vhostconf_domain'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t\t$ipportlist .= $ipport;\n\t\t}\n\n\t\t$vhost_content .= '<VirtualHost ' . trim($ipportlist) . '>' . \"\\n\";\n\t\t$vhost_content .= $this->getServerNames($domain);\n\n\t\t$domain['documentroot_norewrite'] = $domain['documentroot'];\n\t\tif (($ssl_vhost == false && $domain['ssl'] == '1' && $domain['ssl_redirect'] == '1')) {\n\t\t\t// We must not check if our port differs from port 443,\n\t\t\t// but if there is a destination-port != 443\n\t\t\t$_sslport = '';\n\t\t\t// This returns the first port that is != 443 with ssl enabled, if any\n\t\t\t// ordered by ssl-certificate (if any) so that the ip/port combo\n\t\t\t// with certificate is used\n\t\t\t$ssldestport_stmt = Database::prepare(\"\n\t\t\t\tSELECT `ip`.`port` FROM \" . TABLE_PANEL_IPSANDPORTS . \" `ip`\n\t\t\t\tLEFT JOIN `\" . TABLE_DOMAINTOIP . \"` `dip` ON (`ip`.`id` = `dip`.`id_ipandports`)\n\t\t\t\tWHERE `dip`.`id_domain` = :domainid\n\t\t\t\tAND `ip`.`ssl` = '1'  AND `ip`.`port` != 443\n\t\t\t\tORDER BY `ip`.`ssl_cert_file` DESC, `ip`.`port` LIMIT 1;\n\t\t\t\");\n\t\t\t$ssldestport = Database::pexecute_first($ssldestport_stmt, [\n\t\t\t\t'domainid' => $domain['id']\n\t\t\t]);\n\n\t\t\tif ($ssldestport && $ssldestport['port'] != '') {\n\t\t\t\t$_sslport = \":\" . $ssldestport['port'];\n\t\t\t}\n\n\t\t\t$domain['documentroot'] = 'https://%{HTTP_HOST}' . $_sslport . '/';\n\t\t\t$domain['documentroot_norewrite'] = 'https://' . $domain['domain'] . $_sslport . '/';\n\t\t}\n\n\t\tif ($ssl_vhost === true && $domain['ssl'] == '1' && Settings::Get('system.use_ssl') == '1') {\n\t\t\tif ($domain['ssl_cert_file'] == '' || !file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t$domain['ssl_cert_file'] = Settings::Get('system.ssl_cert_file');\n\t\t\t\tif (!file_exists($domain['ssl_cert_file'])) {\n\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t$domain['ssl_cert_file'] = \"\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate file \"' . Settings::Get('system.ssl_cert_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . $domain['domain'] . '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($domain['ssl_key_file'] == '' || !file_exists($domain['ssl_key_file'])) {\n\t\t\t\t$domain['ssl_key_file'] = Settings::Get('system.ssl_key_file');\n\t\t\t\tif (!file_exists($domain['ssl_key_file'])) {\n\t\t\t\t\t// explicitly disable ssl for this vhost\n\t\t\t\t\t$domain['ssl_cert_file'] = \"\";\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_DEBUG, 'System certificate key-file \"' . Settings::Get('system.ssl_key_file') . '\" does not seem to exist. Disabling SSL-vhost for \"' . $domain['domain'] . '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($domain['ssl_ca_file'] == '') {\n\t\t\t\t$domain['ssl_ca_file'] = Settings::Get('system.ssl_ca_file');\n\t\t\t}\n\n\t\t\tif ($domain['ssl_cert_chainfile'] == '') {\n\t\t\t\t$domain['ssl_cert_chainfile'] = Settings::Get('system.ssl_cert_chainfile');\n\t\t\t}\n\n\t\t\tif ($domain['ssl_cert_file'] != '') {\n\t\t\t\t$ssl_protocols = ($domain['override_tls'] == '1' && !empty($domain['ssl_protocols'])) ? $domain['ssl_protocols'] : Settings::Get('system.ssl_protocols');\n\t\t\t\t$ssl_cipher_list = ($domain['override_tls'] == '1' && !empty($domain['ssl_cipher_list'])) ? $domain['ssl_cipher_list'] : Settings::Get('system.ssl_cipher_list');\n\t\t\t\t$tlsv13_cipher_list = ($domain['override_tls'] == '1' && !empty($domain['tlsv13_cipher_list'])) ? $domain['tlsv13_cipher_list'] : Settings::Get('system.tlsv13_cipher_list');\n\n\t\t\t\t$vhost_content .= '  SSLEngine On' . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLProtocol -ALL +' . str_replace(\",\", \" +\", $ssl_protocols) . \"\\n\";\n\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\tif (isset($domain['http2']) && $domain['http2'] == '1' && Settings::Get('system.http2_support') == '1') {\n\t\t\t\t\t\t$vhost_content .= '  Protocols h2 http/1.1' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (!empty(Settings::Get('system.dhparams_file'))) {\n\t\t\t\t\t\t$dhparams = FileDir::makeCorrectFile(Settings::Get('system.dhparams_file'));\n\t\t\t\t\t\tif (!file_exists($dhparams)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('openssl dhparam -out ' . escapeshellarg($dhparams) . ' 4096');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$vhost_content .= '  SSLOpenSSLConfCmd DHParameters \"' . $dhparams . '\"' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\t$vhost_content .= '  SSLCompression Off' . \"\\n\";\n\t\t\t\t\tif (Settings::Get('system.sessionticketsenabled') == '1') {\n\t\t\t\t\t\t$vhost_content .= '  SSLSessionTickets ' . ($domain['ssl_sessiontickets'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '  SSLHonorCipherOrder ' . ($domain['ssl_honorcipherorder'] == '1' ? 'on' : 'off') . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLCipherSuite ' . $ssl_cipher_list . \"\\n\";\n\t\t\t\t$protocols = array_map('trim', explode(\",\", $ssl_protocols));\n\t\t\t\tif (in_array(\"TLSv1.3\", $protocols) && !empty($tlsv13_cipher_list) && Settings::Get('system.apache24') == 1) {\n\t\t\t\t\t$vhost_content .= '  SSLCipherSuite TLSv1.3 ' . $tlsv13_cipher_list . \"\\n\";\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '  SSLVerifyDepth 10' . \"\\n\";\n\t\t\t\t$vhost_content .= '  SSLCertificateFile ' . FileDir::makeCorrectFile($domain['ssl_cert_file']) . \"\\n\";\n\n\t\t\t\tif ($domain['ssl_key_file'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCertificateKeyFile ' . FileDir::makeCorrectFile($domain['ssl_key_file']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($domain['ssl_ca_file'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCACertificateFile ' . FileDir::makeCorrectFile($domain['ssl_ca_file']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif ($domain['ssl_cert_chainfile'] != '') {\n\t\t\t\t\t$vhost_content .= '  SSLCertificateChainFile ' . FileDir::makeCorrectFile($domain['ssl_cert_chainfile']) . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (Settings::Get('system.apache24') == '1' && isset($domain['ocsp_stapling']) && $domain['ocsp_stapling'] == '1') {\n\t\t\t\t\t$vhost_content .= '  SSLUseStapling on' . PHP_EOL;\n\t\t\t\t}\n\n\t\t\t\tif ($domain['hsts'] >= 0) {\n\t\t\t\t\t$vhost_content .= '  <IfModule mod_headers.c>' . \"\\n\";\n\t\t\t\t\t$vhost_content .= '    Header always set Strict-Transport-Security \"max-age=' . $domain['hsts'];\n\t\t\t\t\tif ($domain['hsts_sub'] == 1) {\n\t\t\t\t\t\t$vhost_content .= '; includeSubDomains';\n\t\t\t\t\t}\n\t\t\t\t\tif ($domain['hsts_preload'] == 1) {\n\t\t\t\t\t\t$vhost_content .= '; preload';\n\t\t\t\t\t}\n\t\t\t\t\t$vhost_content .= '\"' . \"\\n\";\n\t\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if there is no cert-file specified but we are generating a ssl-vhost,\n\t\t\t\t// we should return an empty string because this vhost would suck dick, ref #1583\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_ERR, $domain['domain'] . ' :: empty certificate file! Cannot create ssl-directives');\n\t\t\t\treturn '# no ssl-certificate was specified for this domain, therefore no explicit vhost is being generated';\n\t\t\t}\n\t\t}\n\n\t\t// avoid using any whitespaces\n\t\t$domain['documentroot'] = trim($domain['documentroot']);\n\n\t\tif (preg_match('/^https?\\:\\/\\//', $domain['documentroot'])) {\n\t\t\t$possible_deactivated_webroot = $this->getWebroot($domain);\n\t\t\tif ($this->deactivated == false) {\n\t\t\t\t$corrected_docroot = $domain['documentroot'];\n\n\t\t\t\t// Get domain's redirect code\n\t\t\t\t$code = Domain::getDomainRedirectCode($domain['id']);\n\t\t\t\t$modrew_red = '';\n\t\t\t\tif ($code != '') {\n\t\t\t\t\t$modrew_red = ' [R=' . $code . ';L,NE]';\n\t\t\t\t}\n\n\t\t\t\t// redirect everything, not only root-directory, #541\n\t\t\t\t$vhost_content .= '  <IfModule mod_rewrite.c>' . \"\\n\";\n\t\t\t\t$vhost_content .= '    RewriteEngine On' . \"\\n\";\n\t\t\t\tif (!$ssl_vhost) {\n\t\t\t\t\t$vhost_content .= '    RewriteCond %{HTTPS} off' . \"\\n\";\n\t\t\t\t}\n\t\t\t\tif ($domain['letsencrypt'] == '1') {\n\t\t\t\t\t$vhost_content .= '    RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge' . \"\\n\";\n\t\t\t\t}\n\t\t\t\t$vhost_content .= '    RewriteRule ^/(.*) ' . $corrected_docroot . '$1' . $modrew_red . \"\\n\";\n\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t\t$vhost_content .= '  <IfModule !mod_rewrite.c>' . \"\\n\";\n\t\t\t\t$vhost_content .= '    Redirect ' . $code . ' / ' . $domain['documentroot_norewrite'] . \"\\n\";\n\t\t\t\t$vhost_content .= '  </IfModule>' . \"\\n\";\n\t\t\t} elseif (Settings::Get('system.deactivateddocroot') != '') {\n\t\t\t\t$vhost_content .= $possible_deactivated_webroot;\n\t\t\t}\n\t\t} else {\n\t\t\tFileDir::mkDirWithCorrectOwnership($domain['customerroot'], $domain['documentroot'], $domain['guid'], $domain['guid'], true, true);\n\t\t\t$vhost_content .= $this->getWebroot($domain);\n\t\t\tif ($this->deactivated == false) {\n\t\t\t\t$vhost_content .= $this->composePhpOptions($domain, $ssl_vhost);\n\t\t\t\t$vhost_content .= $this->getStats($domain);\n\t\t\t}\n\t\t\t$vhost_content .= $this->getLogfiles($domain);\n\n\t\t\tif ($domain['specialsettings'] != '' && ($ssl_vhost == false || ($ssl_vhost == true && $domain['include_specialsettings'] == 1))) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate($domain['specialsettings'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif ($domain['ssl_specialsettings'] != '' && $ssl_vhost == true) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate($domain['ssl_specialsettings'], $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif ($_vhost_content != '') {\n\t\t\t\t$vhost_content .= $_vhost_content;\n\t\t\t}\n\n\t\t\tif (Settings::Get('system.default_vhostconf') != '' && ($ssl_vhost == false || ($ssl_vhost == true && Settings::Get('system.include_default_vhostconf') == 1))) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate(Settings::Get('system.default_vhostconf'), $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\n\t\t\tif (Settings::Get('system.default_sslvhostconf') != '' && $ssl_vhost == true) {\n\t\t\t\t$vhost_content .= $this->processSpecialConfigTemplate(Settings::Get('system.default_sslvhostconf'), $domain, $domain['ip'], $domain['port'], $ssl_vhost) . \"\\n\";\n\t\t\t}\n\t\t}\n\n\t\t$vhost_content .= '</VirtualHost>' . \"\\n\";\n\n\t\treturn $vhost_content;\n\t}\n\n\t/**\n\t * We collect all servernames and Aliases\n\t */\n\tprotected function getServerNames($domain)\n\t{\n\t\t$servernames_text = '  ServerName ' . $domain['domain'] . \"\\n\";\n\n\t\t$server_alias = '';\n\t\tif ($domain['iswildcarddomain'] == '1') {\n\t\t\t$server_alias = '*.' . $domain['domain'];\n\t\t} elseif ($domain['wwwserveralias'] == '1') {\n\t\t\t$server_alias = 'www.' . $domain['domain'];\n\t\t}\n\n\t\tif (trim($server_alias) != '') {\n\t\t\t$servernames_text .= '  ServerAlias ' . $server_alias . \"\\n\";\n\t\t}\n\n\t\t$alias_domains_stmt = Database::prepare(\"\n\t\t\tSELECT `domain`, `iswildcarddomain`, `wwwserveralias`\n\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\tWHERE `aliasdomain`= :domainid\n\t\t\");\n\t\tDatabase::pexecute($alias_domains_stmt, [\n\t\t\t'domainid' => $domain['id']\n\t\t]);\n\n\t\twhile (($alias_domain = $alias_domains_stmt->fetch(PDO::FETCH_ASSOC)) !== false) {\n\t\t\t$server_alias = '  ServerAlias ' . $alias_domain['domain'];\n\n\t\t\tif ($alias_domain['iswildcarddomain'] == '1') {\n\t\t\t\t$server_alias .= ' *.' . $alias_domain['domain'];\n\t\t\t} else {\n\t\t\t\tif ($alias_domain['wwwserveralias'] == '1') {\n\t\t\t\t\t$server_alias .= ' www.' . $alias_domain['domain'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$servernames_text .= $server_alias . \"\\n\";\n\t\t}\n\n\t\t$servernames_text .= '  ServerAdmin ' . $domain['email'] . \"\\n\";\n\t\treturn $servernames_text;\n\t}\n\n\t/**\n\t * Let's get the webroot\n\t */\n\tprotected function getWebroot($domain)\n\t{\n\t\t$webroot_text = '';\n\t\t$domain['customerroot'] = FileDir::makeCorrectDir($domain['customerroot']);\n\t\t$domain['documentroot'] = FileDir::makeCorrectDir($domain['documentroot']);\n\n\t\tif (($domain['deactivated'] == '1' || $domain['customer_deactivated'] == '1') && Settings::Get('system.deactivateddocroot') != '') {\n\t\t\t$webroot_text .= '  # Using docroot for deactivated users/domains...' . \"\\n\";\n\t\t\t$webroot_text .= '  DocumentRoot \"' . rtrim(FileDir::makeCorrectDir(Settings::Get('system.deactivateddocroot')), \"/\") . \"\\\"\\n\";\n\t\t\t$webroot_text .= '  <Directory \"' . FileDir::makeCorrectDir(Settings::Get('system.deactivateddocroot')) . '\">' . \"\\n\";\n\t\t\t// >=apache-2.4 enabled?\n\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t$webroot_text .= '    Require all granted' . \"\\n\";\n\t\t\t\t$webroot_text .= '    AllowOverride All' . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$webroot_text .= '    Order allow,deny' . \"\\n\";\n\t\t\t\t$webroot_text .= '    allow from all' . \"\\n\";\n\t\t\t}\n\t\t\t$webroot_text .= '  </Directory>' . \"\\n\";\n\t\t\t$this->deactivated = true;\n\t\t} else {\n\t\t\t$webroot_text .= '  DocumentRoot \"' . rtrim($domain['documentroot'], \"/\") . \"\\\"\\n\";\n\t\t\t$this->deactivated = false;\n\t\t}\n\n\t\treturn $webroot_text;\n\t}\n\n\t/**\n\t * We put together the needed php options in the virtualhost entries\n\t *\n\t * @param array $domain\n\t * @param bool $ssl_vhost\n\t *\n\t * @return string\n\t */\n\tprotected function composePhpOptions(&$domain, $ssl_vhost = false)\n\t{\n\t\t$php_options_text = '';\n\n\t\tif ($domain['phpenabled_customer'] == 1 && $domain['phpenabled_vhost'] == '1') {\n\t\t\t// This vHost has PHP enabled and we are using the regular mod_php\n\t\t\t$cmail = Customer::getCustomerDetail($domain['customerid'], 'email');\n\t\t\t$php_options_text .= '  php_admin_value sendmail_path \"/usr/sbin/sendmail -t -f ' . $cmail . '\"' . PHP_EOL;\n\n\t\t\tif ($domain['openbasedir'] == '1') {\n\t\t\t\tif ($domain['openbasedir_path'] == '1' || strstr($domain['documentroot'], \":\") !== false) {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath($domain['customerroot'], true);\n\t\t\t\t} else if ($domain['openbasedir_path'] == '2' && strpos(dirname($domain['documentroot']).'/', $domain['customerroot']) !== false) {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath(dirname($domain['documentroot']).'/', true);\n\t\t\t\t} else {\n\t\t\t\t\t$_phpappendopenbasedir = Domain::appendOpenBasedirPath($domain['documentroot'], true);\n\t\t\t\t}\n\n\t\t\t\t$_custom_openbasedir = explode(':', Settings::Get('system.phpappendopenbasedir'));\n\t\t\t\tforeach ($_custom_openbasedir as $cobd) {\n\t\t\t\t\t$_phpappendopenbasedir .= Domain::appendOpenBasedirPath($cobd);\n\t\t\t\t}\n\n\t\t\t\t$php_options_text .= '  php_admin_value open_basedir \"' . $_phpappendopenbasedir . '\"' . \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\t$php_options_text .= '  # PHP is disabled for this vHost' . \"\\n\";\n\t\t\t$php_options_text .= '  php_flag engine off' . \"\\n\";\n\t\t}\n\n\t\t/**\n\t\t * check for apache-itk-support, #1400\n\t\t * why is this here? Because it only works with mod_php\n\t\t */\n\t\tif (Settings::get('system.apacheitksupport') == 1) {\n\t\t\t$php_options_text .= '  <IfModule mpm_itk_module>' . \"\\n\";\n\t\t\t$php_options_text .= '    AssignUserID ' . $domain['loginname'] . ' ' . $domain['loginname'] . \"\\n\";\n\t\t\t$php_options_text .= '  </IfModule>' . \"\\n\";\n\t\t}\n\n\t\treturn $php_options_text;\n\t}\n\n\t/**\n\t * Lets set the text part for the stats software\n\t */\n\tprotected function getStats($domain)\n\t{\n\t\t$stats_text = '';\n\n\t\t$statTool = Settings::Get('system.traffictool');\n\t\t$statDomain = \"\";\n\t\tif ($statTool == 'awstats') {\n\t\t\t// awstats generates for each domain regardless of speciallogfile\n\t\t\t$statDomain = \"/\" . $domain['domain'];\n\t\t}\n\t\tif ($domain['speciallogfile'] == '1') {\n\t\t\t$statDomain = \"/\" . (($domain['parentdomainid'] == '0') ? $domain['domain'] : $domain['parentdomain']);\n\t\t}\n\t\t$statDocroot = FileDir::makeCorrectFile($domain['customerroot'] . '/' . $statTool . $statDomain);\n\n\t\t$stats_text .= '  Alias /'.$statTool.' \"' . $statDocroot . '\"' . \"\\n\";\n\t\t// awstats special requirement for icons\n\t\tif ($statTool == 'awstats') {\n\t\t\t\t$stats_text .= '  Alias /awstats-icon \"' . FileDir::makeCorrectDir(Settings::Get('system.awstats_icons')) . '\"' . \"\\n\";\n\t\t}\n\n\t\treturn $stats_text;\n\t}\n\n\t/**\n\t * Lets set the logfiles\n\t */\n\tprotected function getLogfiles($domain)\n\t{\n\t\t$logfiles_text = '';\n\n\t\tif ($domain['speciallogfile'] == '1') {\n\t\t\tif ($domain['parentdomainid'] == '0') {\n\t\t\t\t$speciallogfile = '-' . $domain['domain'];\n\t\t\t} else {\n\t\t\t\t$speciallogfile = '-' . $domain['parentdomain'];\n\t\t\t}\n\t\t} else {\n\t\t\t$speciallogfile = '';\n\t\t}\n\n\t\tif ($domain['writeerrorlog']) {\n\t\t\t// The normal access/error - logging is enabled\n\t\t\t$error_log = FileDir::makeCorrectFile(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-error.log');\n\t\t\t// Create the logfile if it does not exist (fixes #46)\n\t\t\ttouch($error_log);\n\t\t\tchown($error_log, Settings::Get('system.httpuser'));\n\t\t\tchgrp($error_log, Settings::Get('system.httpgroup'));\n\t\t\t// set error log log-level\n\t\t\t$logfiles_text .= '  LogLevel ' . Settings::Get('system.errorlog_level') . \"\\n\";\n\t\t} else {\n\t\t\t$error_log = '/dev/null';\n\t\t}\n\n\t\tif ($domain['writeaccesslog']) {\n\t\t\t$access_log = FileDir::makeCorrectFile(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-access.log');\n\t\t\t// Create the logfile if it does not exist (fixes #46)\n\t\t\ttouch($access_log);\n\t\t\tchown($access_log, Settings::Get('system.httpuser'));\n\t\t\tchgrp($access_log, Settings::Get('system.httpgroup'));\n\t\t} else {\n\t\t\t$access_log = '/dev/null';\n\t\t}\n\n\t\t$logtype = 'combined';\n\t\tif (Settings::Get('system.logfiles_format') != '') {\n\t\t\t$logtype = 'frx_custom';\n\t\t\t$logfiles_text .= '  LogFormat ' . Settings::Get('system.logfiles_format') . ' ' . $logtype . \"\\n\";\n\t\t}\n\t\tif (Settings::Get('system.logfiles_type') == '2' && Settings::Get('system.logfiles_format') == '') {\n\t\t\t$logtype = 'vhost_combined';\n\t\t}\n\n\t\tif (Settings::Get('system.logfiles_piped') == '1' && Settings::Get('system.logfiles_script') != '') {\n\t\t\tif ($domain['writeerrorlog']) {\n\t\t\t\t// replace for error_log\n\t\t\t\t$command = PhpHelper::replaceVariables(Settings::Get('system.logfiles_script'), [\n\t\t\t\t\t'LOGFILE' => $error_log,\n\t\t\t\t\t'DOMAIN' => $domain['domain'],\n\t\t\t\t\t'CUSTOMER' => $domain['loginname']\n\t\t\t\t]);\n\t\t\t\t$logfiles_text .= '  ErrorLog \"|' . $command . \"\\\"\\n\";\n\t\t\t} else {\n\t\t\t\t$logfiles_text .= '  ErrorLog \"' . $error_log . '\"' . \"\\n\";\n\t\t\t}\n\t\t\tif ($domain['writeaccesslog']) {\n\t\t\t\t// replace for access_log\n\t\t\t\t$command = PhpHelper::replaceVariables(Settings::Get('system.logfiles_script'), [\n\t\t\t\t\t'LOGFILE' => $access_log,\n\t\t\t\t\t'DOMAIN' => $domain['domain'],\n\t\t\t\t\t'CUSTOMER' => $domain['loginname']\n\t\t\t\t]);\n\t\t\t\t$logfiles_text .= '  CustomLog \"|' . $command . '\" ' . $logtype . \"\\n\";\n\t\t\t} else {\n\t\t\t\t$logfiles_text .= '  CustomLog \"' . $access_log . '\" ' . $logtype . \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\t$logfiles_text .= '  ErrorLog \"' . $error_log . '\"' . \"\\n\";\n\t\t\t$logfiles_text .= '  CustomLog \"' . $access_log . '\" ' . $logtype . \"\\n\";\n\t\t}\n\n\t\tif (Settings::Get('system.traffictool') == 'awstats') {\n\t\t\tif ((int)$domain['parentdomainid'] == 0) {\n\t\t\t\t// prepare the aliases and subdomains for stats config files\n\t\t\t\t$server_alias = '';\n\t\t\t\t$alias_domains_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `domain`, `iswildcarddomain`, `wwwserveralias`\n\t\t\t\t\tFROM `\" . TABLE_PANEL_DOMAINS . \"`\n\t\t\t\t\tWHERE `aliasdomain` = :domainid OR `parentdomainid` = :domainid\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($alias_domains_stmt, [\n\t\t\t\t\t'domainid' => $domain['id']\n\t\t\t\t]);\n\n\t\t\t\twhile (($alias_domain = $alias_domains_stmt->fetch(PDO::FETCH_ASSOC)) !== false) {\n\t\t\t\t\t$server_alias .= ' ' . $alias_domain['domain'] . ' ';\n\n\t\t\t\t\tif ($alias_domain['iswildcarddomain'] == '1') {\n\t\t\t\t\t\t$server_alias .= '*.' . $alias_domain['domain'];\n\t\t\t\t\t} elseif ($alias_domain['wwwserveralias'] == '1') {\n\t\t\t\t\t\t$server_alias .= 'www.' . $alias_domain['domain'];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$alias = '';\n\t\t\t\tif ($domain['iswildcarddomain'] == '1') {\n\t\t\t\t\t$alias = '*.' . $domain['domain'];\n\t\t\t\t} elseif ($domain['wwwserveralias'] == '1') {\n\t\t\t\t\t$alias = 'www.' . $domain['domain'];\n\t\t\t\t}\n\n\t\t\t\t// After inserting the AWStats information,\n\t\t\t\t// be sure to build the awstats conf file as well\n\t\t\t\t// and chown it using $awstats_params, #258\n\t\t\t\t// Bug 960 + Bug 970 : Use full $domain instead of custom $awstats_params as following classes depend on the information\n\t\t\t\tStatistics::createAWStatsConf(Settings::Get('system.logfiles_directory') . $domain['loginname'] . $speciallogfile . '-access.log', $domain['domain'], $alias . $server_alias, $domain['customerroot'], $domain);\n\t\t\t}\n\t\t}\n\n\t\treturn $logfiles_text;\n\t}\n\n\t/**\n\t * We compose the diroption entries for the paths\n\t */\n\tpublic function createFileDirOptions()\n\t{\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `htac`.*, `c`.`guid`, `c`.`documentroot` AS `customerroot`\n\t\t\tFROM `\" . TABLE_PANEL_HTACCESS . \"` `htac`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_CUSTOMERS . \"` `c` USING (`customerid`)\n\t\t\tORDER BY `htac`.`path`\n\t\t\");\n\t\t$diroptions = [];\n\n\t\twhile ($row_diroptions = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif ($row_diroptions['customerid'] != 0 && isset($row_diroptions['customerroot']) && $row_diroptions['customerroot'] != '') {\n\t\t\t\t$diroptions[$row_diroptions['path']] = $row_diroptions;\n\t\t\t\t$diroptions[$row_diroptions['path']]['htpasswds'] = [];\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `htpw`.*, `c`.`guid`, `c`.`documentroot` AS `customerroot`\n\t\t\tFROM `\" . TABLE_PANEL_HTPASSWDS . \"` `htpw`\n\t\t\tLEFT JOIN `\" . TABLE_PANEL_CUSTOMERS . \"` `c` USING (`customerid`)\n\t\t\tORDER BY `htpw`.`path`, `htpw`.`username`\n\t\t\");\n\n\t\twhile ($row_htpasswds = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tif ($row_htpasswds['customerid'] != 0 && isset($row_htpasswds['customerroot']) && $row_htpasswds['customerroot'] != '') {\n\t\t\t\tif (!isset($diroptions[$row_htpasswds['path']]) || !is_array($diroptions[$row_htpasswds['path']])) {\n\t\t\t\t\t$diroptions[$row_htpasswds['path']] = [];\n\t\t\t\t}\n\n\t\t\t\t$diroptions[$row_htpasswds['path']]['path'] = $row_htpasswds['path'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['guid'] = $row_htpasswds['guid'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['customerroot'] = $row_htpasswds['customerroot'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['customerid'] = $row_htpasswds['customerid'];\n\t\t\t\t$diroptions[$row_htpasswds['path']]['htpasswds'][] = $row_htpasswds;\n\t\t\t}\n\t\t}\n\n\t\tforeach ($diroptions as $row_diroptions) {\n\t\t\t$row_diroptions['path'] = FileDir::makeCorrectDir($row_diroptions['path']);\n\t\t\tFileDir::mkDirWithCorrectOwnership($row_diroptions['customerroot'], $row_diroptions['path'], $row_diroptions['guid'], $row_diroptions['guid']);\n\t\t\t$diroptions_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_diroptions') . '/40_froxlor_diroption_' . md5($row_diroptions['path']) . '.conf');\n\n\t\t\tif (!isset($this->diroptions_data[$diroptions_filename])) {\n\t\t\t\t$this->diroptions_data[$diroptions_filename] = '';\n\t\t\t}\n\n\t\t\tif (is_dir($row_diroptions['path'])) {\n\t\t\t\t$cperlenabled = Customer::customerHasPerlEnabled($row_diroptions['customerid']);\n\n\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '<Directory \"' . $row_diroptions['path'] . '\">' . \"\\n\";\n\n\t\t\t\tif (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '1') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Options +Indexes';\n\n\t\t\t\t\t// add perl options if enabled\n\t\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options +Indexes for ' . $row_diroptions['path']);\n\t\t\t\t}\n\n\t\t\t\tif (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '0') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Options -Indexes';\n\n\t\t\t\t\t// add perl options if enabled\n\t\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options -Indexes for ' . $row_diroptions['path']);\n\t\t\t\t}\n\n\t\t\t\t$statusCodes = [\n\t\t\t\t\t'404',\n\t\t\t\t\t'403',\n\t\t\t\t\t'500'\n\t\t\t\t];\n\t\t\t\tforeach ($statusCodes as $statusCode) {\n\t\t\t\t\tif (isset($row_diroptions['error' . $statusCode . 'path']) && $row_diroptions['error' . $statusCode . 'path'] != '') {\n\t\t\t\t\t\t$defhandler = $row_diroptions['error' . $statusCode . 'path'];\n\t\t\t\t\t\tif (!Validate::validateUrl($defhandler)) {\n\t\t\t\t\t\t\tif (substr($defhandler, 0, 1) != '\"' && substr($defhandler, -1, 1) != '\"') {\n\t\t\t\t\t\t\t\t$defhandler = '\"' . FileDir::makeCorrectFile($defhandler) . '\"';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  ErrorDocument ' . $statusCode . ' ' . $defhandler . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AllowOverride None' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AddHandler cgi-script .cgi .pl' . \"\\n\";\n\t\t\t\t\t// >=apache-2.4 enabled?\n\t\t\t\t\tif (Settings::Get('system.apache24') == '1') {\n\t\t\t\t\t\t$mypath_dir = new Directory($row_diroptions['path']);\n\t\t\t\t\t\t// only create the' require all granted' if there is no active directory-protection\n\t\t\t\t\t\t// for this path, as this would be the first require and therefore grant all access\n\t\t\t\t\t\tif ($mypath_dir->isUserProtected() == false) {\n\t\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Require all granted' . \"\\n\";\n\t\t\t\t\t\t\t// $this->diroptions_data[$diroptions_filename] .= ' AllowOverride All' . \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Order allow,deny' . \"\\n\";\n\t\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  Allow from all' . \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Enabling perl execution for ' . $row_diroptions['path']);\n\n\t\t\t\t\t// check for suexec-workaround, #319\n\t\t\t\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t\t\t\t// symlink this directory to suexec-safe-path\n\t\t\t\t\t\t$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');\n\t\t\t\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');\n\n\t\t\t\t\t\tif (!file_exists($suexecpath)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('mkdir -p ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t\tFileDir::safe_exec('chown -R ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// symlink to {$givenpath}/cgi-bin\n\t\t\t\t\t\t// NOTE: symlinks are FILES, so do not append a / here\n\t\t\t\t\t\t$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');\n\t\t\t\t\t\tif (!file_exists($perlsymlink)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('ln -s ' . escapeshellarg($suexecpath) . ' ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFileDir::safe_exec('chown -h ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if no perl-execution is enabled but the workaround is,\n\t\t\t\t\t// we have to remove the symlink and folder in suexecpath\n\t\t\t\t\tif ((int)Settings::Get('perl.suexecworkaround') == 1) {\n\t\t\t\t\t\t$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');\n\t\t\t\t\t\t$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');\n\t\t\t\t\t\t$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');\n\n\t\t\t\t\t\t// remove symlink\n\t\t\t\t\t\tif (file_exists($perlsymlink)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('rm -f ' . escapeshellarg($perlsymlink));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// remove folder in suexec-path\n\t\t\t\t\t\tif (file_exists($suexecpath)) {\n\t\t\t\t\t\t\tFileDir::safe_exec('rm -rf ' . escapeshellarg($suexecpath));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (count($row_diroptions['htpasswds']) > 0) {\n\t\t\t\t\t$htpasswd_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_htpasswddir') . '/' . $row_diroptions['customerid'] . '-' . md5($row_diroptions['path']) . '.htpasswd');\n\n\t\t\t\t\tif (!isset($this->htpasswds_data[$htpasswd_filename])) {\n\t\t\t\t\t\t$this->htpasswds_data[$htpasswd_filename] = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach ($row_diroptions['htpasswds'] as $row_htpasswd) {\n\t\t\t\t\t\t$this->htpasswds_data[$htpasswd_filename] .= $row_htpasswd['username'] . ':' . $row_htpasswd['password'] . \"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthType Basic' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthName \"' . $row_htpasswd['authname'] . '\"' . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  AuthUserFile ' . $htpasswd_filename . \"\\n\";\n\t\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '  require valid-user' . \"\\n\";\n\t\t\t\t}\n\n\t\t\t\t$this->diroptions_data[$diroptions_filename] .= '</Directory>' . \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * We write the configs\n\t */\n\tpublic function writeConfigs()\n\t{\n\t\t// Write diroptions\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_diroptions'));\n\n\t\tif (count($this->diroptions_data) > 0) {\n\t\t\t$optsDir = new Directory(Settings::Get('system.apacheconf_diroptions'));\n\t\t\tif (!$optsDir->isConfigDir()) {\n\t\t\t\t// Save one big file\n\t\t\t\t$diroptions_file = '';\n\n\t\t\t\tforeach ($this->diroptions_data as $diroptions_filename => $diroptions_content) {\n\t\t\t\t\t$diroptions_file .= $diroptions_content . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t$diroptions_filename = Settings::Get('system.apacheconf_diroptions');\n\n\t\t\t\t// Apply header\n\t\t\t\t$diroptions_file = '# ' . basename($diroptions_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $diroptions_file;\n\t\t\t\t$diroptions_file_handler = fopen($diroptions_filename, 'w');\n\t\t\t\tfwrite($diroptions_file_handler, $diroptions_file);\n\t\t\t\tfclose($diroptions_file_handler);\n\t\t\t} else {\n\t\t\t\tif (!file_exists(Settings::Get('system.apacheconf_diroptions'))) {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::writeConfigs: mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_diroptions'))));\n\t\t\t\t\tFileDir::safe_exec('mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_diroptions'))));\n\t\t\t\t}\n\n\t\t\t\t// Write a single file for every diroption\n\t\t\t\tforeach ($this->diroptions_data as $diroptions_filename => $diroptions_file) {\n\t\t\t\t\t$this->known_diroptionsfilenames[] = basename($diroptions_filename);\n\n\t\t\t\t\t// Apply header\n\t\t\t\t\t$diroptions_file = '# ' . basename($diroptions_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $diroptions_file;\n\t\t\t\t\t$diroptions_file_handler = fopen($diroptions_filename, 'w');\n\t\t\t\t\tfwrite($diroptions_file_handler, $diroptions_file);\n\t\t\t\t\tfclose($diroptions_file_handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Write htpasswds\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_htpasswddir'));\n\n\t\tif (count($this->htpasswds_data) > 0) {\n\t\t\tif (!file_exists(Settings::Get('system.apacheconf_htpasswddir'))) {\n\t\t\t\t$umask = umask();\n\t\t\t\tumask(0000);\n\t\t\t\tmkdir(Settings::Get('system.apacheconf_htpasswddir'), 0751);\n\t\t\t\tumask($umask);\n\t\t\t}\n\n\t\t\t$htpasswdDir = new Directory(Settings::Get('system.apacheconf_htpasswddir'));\n\t\t\tif ($htpasswdDir->isConfigDir(true)) {\n\t\t\t\tforeach ($this->htpasswds_data as $htpasswd_filename => $htpasswd_file) {\n\t\t\t\t\t$this->known_htpasswdsfilenames[] = basename($htpasswd_filename);\n\t\t\t\t\t$htpasswd_file_handler = fopen($htpasswd_filename, 'w');\n\t\t\t\t\tfwrite($htpasswd_file_handler, $htpasswd_file);\n\t\t\t\t\tfclose($htpasswd_file_handler);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_WARNING, 'WARNING!!! ' . Settings::Get('system.apacheconf_htpasswddir') . ' is not a directory. htpasswd directory protection is disabled!!!');\n\t\t\t}\n\t\t}\n\n\t\t// Write virtualhosts\n\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, \"apache::writeConfigs: rebuilding \" . Settings::Get('system.apacheconf_vhost'));\n\n\t\tif (count($this->virtualhosts_data) > 0) {\n\t\t\t$vhostDir = new Directory(Settings::Get('system.apacheconf_vhost'));\n\t\t\tif (!$vhostDir->isConfigDir()) {\n\t\t\t\t// Save one big file\n\t\t\t\t$vhosts_file = '';\n\n\t\t\t\t// sort by filename so the order is:\n\t\t\t\t// 1. subdomains x-29\n\t\t\t\t// 2. subdomains as main-domains 30\n\t\t\t\t// 3. main-domains 35\n\t\t\t\t// #437\n\t\t\t\tksort($this->virtualhosts_data);\n\n\t\t\t\tforeach ($this->virtualhosts_data as $vhosts_filename => $vhost_content) {\n\t\t\t\t\t$vhosts_file .= $vhost_content . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t// Include diroptions file in case it exists\n\t\t\t\tif (file_exists(Settings::Get('system.apacheconf_diroptions'))) {\n\t\t\t\t\t$vhosts_file .= \"\\n\" . 'Include ' . Settings::Get('system.apacheconf_diroptions') . \"\\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t$vhosts_filename = Settings::Get('system.apacheconf_vhost');\n\n\t\t\t\t// Apply header\n\t\t\t\t$vhosts_file = '# ' . basename($vhosts_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $vhosts_file;\n\t\t\t\t$vhosts_file_handler = fopen($vhosts_filename, 'w');\n\t\t\t\tfwrite($vhosts_file_handler, $vhosts_file);\n\t\t\t\tfclose($vhosts_file_handler);\n\t\t\t} else {\n\t\t\t\tif (!file_exists(Settings::Get('system.apacheconf_vhost'))) {\n\t\t\t\t\tFroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_NOTICE, 'apache::writeConfigs: mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'))));\n\t\t\t\t\tFileDir::safe_exec('mkdir ' . escapeshellarg(FileDir::makeCorrectDir(Settings::Get('system.apacheconf_vhost'))));\n\t\t\t\t}\n\n\t\t\t\t// Write a single file for every vhost\n\t\t\t\tforeach ($this->virtualhosts_data as $vhosts_filename => $vhosts_file) {\n\t\t\t\t\t// Apply header\n\t\t\t\t\t$vhosts_file = '# ' . basename($vhosts_filename) . \"\\n\" . '# Created ' . date('d.m.Y H:i') . \"\\n\" . '# Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel.' . \"\\n\" . \"\\n\" . $vhosts_file;\n\t\t\t\t\t$vhosts_file_handler = fopen($vhosts_filename, 'w');\n\t\t\t\t\tfwrite($vhosts_file_handler, $vhosts_file);\n\t\t\t\t\tfclose($vhosts_file_handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse Froxlor\\Customer\\Customer;\nuse Froxlor\\Database\\Database;\nuse PDO;\nuse RecursiveCallbackFilterIterator;\n\nclass FileDir\n{\n\t/**\n\t * Creates a directory below a users homedir and sets all directories,\n\t * which had to be created below with correct Owner/Group\n\t * (Copied from cron_tasks.php:rev1189 as we'll need this more often in future)\n\t *\n\t * @param string $homeDir The homedir of the user\n\t * @param string $dirToCreate The dir which should be created\n\t * @param int $uid The uid of the user\n\t * @param int $gid The gid of the user\n\t * @param bool $placeindex Place standard-index.html into the new folder\n\t * @param bool $allow_notwithinhomedir Allow creating a directory out of the customers docroot\n\t *\n\t * @return bool true if everything went okay, false if something went wrong\n\t * @throws Exception\n\t */\n\tpublic static function mkDirWithCorrectOwnership(\n\t\tstring $homeDir,\n\t\tstring $dirToCreate,\n\t\tint    $uid,\n\t\tint    $gid,\n\t\tbool   $placeindex = false,\n\t\tbool   $allow_notwithinhomedir = false\n\t): bool\n\t{\n\t\tif ($homeDir != '' && $dirToCreate != '') {\n\t\t\t$homeDir = self::makeCorrectDir($homeDir);\n\t\t\t$dirToCreate = self::makeCorrectDir($dirToCreate);\n\n\t\t\tif (substr($dirToCreate, 0, strlen($homeDir)) == $homeDir) {\n\t\t\t\t$subdir = substr($dirToCreate, strlen($homeDir) - 1);\n\t\t\t\t$within_homedir = true;\n\t\t\t} else {\n\t\t\t\t$subdir = $dirToCreate;\n\t\t\t\t$within_homedir = false;\n\t\t\t}\n\n\t\t\t$subdir = self::makeCorrectDir($subdir);\n\t\t\t$subdirs = [];\n\n\t\t\tif ($within_homedir || !$allow_notwithinhomedir) {\n\t\t\t\t$subdirlen = strlen($subdir);\n\t\t\t\t$offset = 0;\n\n\t\t\t\twhile ($offset < $subdirlen) {\n\t\t\t\t\t$offset = strpos($subdir, '/', $offset);\n\t\t\t\t\t$subdirelem = substr($subdir, 0, $offset);\n\t\t\t\t\t$offset++;\n\t\t\t\t\tarray_push($subdirs, self::makeCorrectDir($homeDir . $subdirelem));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarray_push($subdirs, $dirToCreate);\n\t\t\t}\n\n\t\t\t$subdirs = array_unique($subdirs);\n\t\t\tsort($subdirs);\n\t\t\tforeach ($subdirs as $sdir) {\n\t\t\t\tif (!is_dir($sdir)) {\n\t\t\t\t\t$sdir = self::makeCorrectDir($sdir);\n\t\t\t\t\tself::safe_exec('mkdir -p ' . escapeshellarg($sdir));\n\t\t\t\t\t// place index\n\t\t\t\t\tif ($placeindex) {\n\t\t\t\t\t\t$loginname = Customer::getLoginNameByUid($uid);\n\t\t\t\t\t\tif ($loginname !== false) {\n\t\t\t\t\t\t\tself::storeDefaultIndex($loginname, $sdir, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tself::safe_exec('chown -R ' . (int)$uid . ':' . (int)$gid . ' ' . escapeshellarg($sdir));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a correct/secure dirname, means to add slashes at the beginning and at the end if there weren't\n\t * some. If $fixes_homedir is specified,\n\t *\n\t *\n\t * @param string $dir the path to correct\n\t *\n\t * @return string the corrected path\n\t * @throws Exception\n\t */\n\tpublic static function makeCorrectDir(string $dir, string $fixed_homedir = \"\"): string\n\t{\n\t\tif (strlen($dir) > 0) {\n\t\t\t$dir = trim($dir);\n\t\t\tif (substr($dir, -1, 1) != '/') {\n\t\t\t\t$dir .= '/';\n\t\t\t}\n\t\t\tif (substr($dir, 0, 1) != '/') {\n\t\t\t\t$dir = '/' . $dir;\n\t\t\t}\n\n\t\t\t// if given, check that the target path is within the $fixed_homedir\n\t\t\t// by checking each folder for being a symlink and whether it targets\n\t\t\t// the customers homedir or points outside of it\n\t\t\tif (!empty($fixed_homedir)) {\n\t\t\t\t$to_check = explode(\"/\", substr($dir, strlen($fixed_homedir) + 1), -1);\n\t\t\t\t$check_dir = substr($fixed_homedir, 0, -1);\n\t\t\t\t// Symlink check\n\t\t\t\tforeach ($to_check as $sub_dir) {\n\t\t\t\t\t$check_dir .= '/' . $sub_dir;\n\t\t\t\t\tif (is_link($check_dir)) {\n\t\t\t\t\t\t$original_target = $check_dir;\n\t\t\t\t\t\t$check_dir = readlink($check_dir);\n\t\t\t\t\t\tif (substr($check_dir, 0, strlen($fixed_homedir)) != $fixed_homedir) {\n\t\t\t\t\t\t\tthrow new Exception(\"Found symlink pointing outside of customer home directory: \" . substr($original_target, strlen($fixed_homedir)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check for the path to be within the given homedir\n\t\t\t\tif (substr($dir, 0, strlen($fixed_homedir)) != $fixed_homedir) {\n\t\t\t\t\tthrow new Exception(\"Target path not within the required customer home directory\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn self::makeSecurePath($dir);\n\t\t}\n\t\tthrow new Exception(\"Cannot validate directory in \" . __FUNCTION__ . \" which is very dangerous.\");\n\t}\n\n\t/**\n\t * Function which returns a secure path, means to remove all multiple dots and slashes\n\t *\n\t * @param string $path the path to secure\n\t *\n\t * @return string the corrected path\n\t */\n\tpublic static function makeSecurePath(string $path): string\n\t{\n\t\t// check for bad characters, some are allowed with escaping,\n\t\t// but we generally don't want them in our directory-names,\n\t\t// thx to aaronmueller for this snippet\n\t\t$badchars = [\n\t\t\t':',\n\t\t\t';',\n\t\t\t'|',\n\t\t\t'&',\n\t\t\t'>',\n\t\t\t'<',\n\t\t\t'`',\n\t\t\t'$',\n\t\t\t'~',\n\t\t\t'?',\n\t\t\t\"\\0\",\n\t\t\t\"\\n\",\n\t\t\t\"\\r\",\n\t\t\t\"\\t\",\n\t\t\t\"\\f\"\n\t\t];\n\t\tforeach ($badchars as $bc) {\n\t\t\t$path = str_replace($bc, \"\", $path);\n\t\t}\n\n\t\t$search = [\n\t\t\t'#/+#',\n\t\t\t'#\\.+#'\n\t\t];\n\t\t$replace = [\n\t\t\t'/',\n\t\t\t'.'\n\t\t];\n\t\t$path = preg_replace($search, $replace, $path);\n\t\t// don't just replace a space with an escaped space\n\t\t// it might be escaped already\n\t\t$path = str_replace(\"\\ \", \" \", $path);\n\t\t$path = str_replace(\" \", \"\\ \", $path);\n\n\t\treturn $path;\n\t}\n\n\t/**\n\t * Wrapper around the exec command.\n\t *\n\t * @param string $exec_string command to be executed\n\t * @param mixed $return_value referenced variable where the output is stored\n\t * @param ?array $allowedChars optional array of allowed characters in path/command\n\t *\n\t * @return array result of exec()\n\t */\n\tpublic static function safe_exec(string $exec_string, &$return_value = false, $allowedChars = null)\n\t{\n\t\t$disallowed = [\n\t\t\t';',\n\t\t\t'|',\n\t\t\t'&',\n\t\t\t'>',\n\t\t\t'<',\n\t\t\t'`',\n\t\t\t'$',\n\t\t\t'~',\n\t\t\t'?'\n\t\t];\n\n\t\t$acheck = false;\n\t\tif ($allowedChars != null && is_array($allowedChars) && count($allowedChars) > 0) {\n\t\t\t$acheck = true;\n\t\t}\n\n\t\tforeach ($disallowed as $dc) {\n\t\t\tif ($acheck && in_array($dc, $allowedChars)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// check for bad signs in execute command\n\t\t\tif (stristr($exec_string, $dc)) {\n\t\t\t\tdie(\"SECURITY CHECK FAILED!\\nThe execute string '\" . $exec_string . \"' is a possible security risk!\\nPlease check your whole server for security problems by hand!\\n\");\n\t\t\t}\n\t\t}\n\n\t\t// execute the command and return output\n\t\t$return = [];\n\n\t\t// -------------------------------------------------------------------------------\n\t\tif ($return_value == false) {\n\t\t\texec($exec_string, $return);\n\t\t} else {\n\t\t\texec($exec_string, $return, $return_value);\n\t\t}\n\n\t\treturn $return;\n\t}\n\n\t/**\n\t * store the default index-file in a given destination folder\n\t *\n\t * @param string $loginname customers loginname\n\t * @param string $destination path where to create the file\n\t * @param object $logger FroxlorLogger object\n\t * @param bool $force force creation whatever the settings say (needed for task #2, create new user)\n\t *\n\t * @return void\n\t * @throws Exception\n\t */\n\tpublic static function storeDefaultIndex(\n\t\tstring $loginname,\n\t\tstring $destination,\n\t\t\t   $logger = null,\n\t\tbool   $force = false\n\t)\n\t{\n\t\tif ($force || (int)Settings::Get('system.store_index_file_subs') == 1) {\n\t\t\t$result_stmt = Database::prepare(\"\n\t\t\tSELECT `t`.`value`, `c`.`email` AS `customer_email`, `a`.`email` AS `admin_email`, `c`.`loginname` AS `customer_login`, `a`.`loginname` AS `admin_login`\n\t\t\tFROM `\" . TABLE_PANEL_CUSTOMERS . \"` AS `c` INNER JOIN `\" . TABLE_PANEL_ADMINS . \"` AS `a`\n\t\t\tON `c`.`adminid` = `a`.`adminid`\n\t\t\tINNER JOIN `\" . TABLE_PANEL_TEMPLATES . \"` AS `t`\n\t\t\tON `a`.`adminid` = `t`.`adminid`\n\t\t\tWHERE `varname` = 'index_html' AND `c`.`loginname` = :loginname\");\n\t\t\tDatabase::pexecute($result_stmt, [\n\t\t\t\t'loginname' => $loginname\n\t\t\t]);\n\n\t\t\tif (Database::num_rows() > 0) {\n\t\t\t\t$template = $result_stmt->fetch(PDO::FETCH_ASSOC);\n\n\t\t\t\t$replace_arr = [\n\t\t\t\t\t'SERVERNAME' => Settings::Get('system.hostname'),\n\t\t\t\t\t'CUSTOMER' => $template['customer_login'],\n\t\t\t\t\t'ADMIN' => $template['admin_login'],\n\t\t\t\t\t'CUSTOMER_EMAIL' => $template['customer_email'],\n\t\t\t\t\t'ADMIN_EMAIL' => $template['admin_email']\n\t\t\t\t];\n\n\t\t\t\t// replaceVariables\n\t\t\t\t$htmlcontent = PhpHelper::replaceVariables($template['value'], $replace_arr);\n\t\t\t\t$indexhtmlpath = self::makeCorrectFile($destination . '/index.' . Settings::Get('system.index_file_extension'));\n\t\t\t\t$index_html_handler = fopen($indexhtmlpath, 'w');\n\t\t\t\tfwrite($index_html_handler, $htmlcontent);\n\t\t\t\tfclose($index_html_handler);\n\t\t\t\tif ($logger !== null) {\n\t\t\t\t\t$logger->logAction(\n\t\t\t\t\t\tFroxlorLogger::CRON_ACTION,\n\t\t\t\t\t\tLOG_NOTICE,\n\t\t\t\t\t\t'Creating \\'index.' . Settings::Get('system.index_file_extension') . '\\' for Customer \\'' . $template['customer_login'] . '\\' based on template in directory ' . escapeshellarg($indexhtmlpath)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$destination = self::makeCorrectDir($destination);\n\t\t\t\tif ($logger !== null) {\n\t\t\t\t\t$logger->logAction(\n\t\t\t\t\t\tFroxlorLogger::CRON_ACTION,\n\t\t\t\t\t\tLOG_NOTICE,\n\t\t\t\t\t\t'Running: cp -a ' . Froxlor::getInstallDir() . '/templates/misc/standardcustomer/* ' . escapeshellarg($destination)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tself::safe_exec('cp -a ' . Froxlor::getInstallDir() . '/templates/misc/standardcustomer/* ' . escapeshellarg($destination));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function which returns a correct filename, means to add a slash at the beginning if there wasn't one\n\t *\n\t * @param string $filename the filename\n\t *\n\t * @return string the corrected filename\n\t */\n\tpublic static function makeCorrectFile(string $filename): string\n\t{\n\t\tif (trim($filename) == '') {\n\t\t\t$error = 'Given filename for function ' . __FUNCTION__ . ' is empty.' . \"\\n\";\n\t\t\t$error .= 'This is very dangerous and should not happen.' . \"\\n\";\n\t\t\t$error .= 'Please inform the Froxlor team about this issue so they can fix it.';\n\t\t\techo $error;\n\t\t\t// so we can see WHERE this happened\n\t\t\tdebug_print_backtrace();\n\t\t\tdie();\n\t\t}\n\n\t\tif (substr($filename, 0, 1) != '/') {\n\t\t\t$filename = '/' . $filename;\n\t\t}\n\n\t\treturn self::makeSecurePath($filename);\n\t}\n\n\t/**\n\t * checks a directory against disallowed paths which could\n\t * lead to a damaged system if you use them\n\t *\n\t * @param string|null $path\n\t *\n\t * @return bool\n\t * @throws Exception\n\t */\n\tpublic static function checkDisallowedPaths(string $path): bool\n\t{\n\t\t/*\n\t\t * disallow base-directories and /\n\t\t */\n\t\t$disallowed_values = [\n\t\t\t\"/\",\n\t\t\t\"/bin/\",\n\t\t\t\"/boot/\",\n\t\t\t\"/dev/\",\n\t\t\t\"/etc/\",\n\t\t\t\"/home/\",\n\t\t\t\"/lib/\",\n\t\t\t\"/lib32/\",\n\t\t\t\"/lib64/\",\n\t\t\t\"/opt/\",\n\t\t\t\"/proc/\",\n\t\t\t\"/root/\",\n\t\t\t\"/run/\",\n\t\t\t\"/sbin/\",\n\t\t\t\"/sys/\",\n\t\t\t\"/tmp/\",\n\t\t\t\"/usr/\",\n\t\t\t\"/var/\"\n\t\t];\n\n\t\t$path = self::makeCorrectDir($path);\n\n\t\t// check if it's a disallowed path\n\t\tif (in_array($path, $disallowed_values)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Function which returns a correct destination for Postfix Virtual Table\n\t *\n\t * @param string $destination The destinations\n\t *\n\t * @return string the corrected destinations\n\t */\n\tpublic static function makeCorrectDestination(string $destination): string\n\t{\n\t\t$search = '/ +/';\n\t\t$replace = ' ';\n\t\t$destination = preg_replace($search, $replace, $destination);\n\n\t\tif (substr($destination, 0, 1) == ' ') {\n\t\t\t$destination = substr($destination, 1);\n\t\t}\n\n\t\tif (substr($destination, -1, 1) == ' ') {\n\t\t\t$destination = substr($destination, 0, strlen($destination) - 1);\n\t\t}\n\n\t\treturn $destination;\n\t}\n\n\t/**\n\t * Returns a valid html tag for the chosen $fieldType for paths\n\t *\n\t * @param string $path The path to start searching in\n\t * @param int $uid The uid which must match the found directories\n\t * @param int $gid The gid which must match the found directories\n\t * @param string $value the value for the input-field\n\t * @param bool $dom\n\t *\n\t * @return array\n\t *\n\t * @throws Exception\n\t * @author Manuel Bernhardt <manuel.bernhardt@syscp.de>\n\t * @author Martin Burchert <martin.burchert@syscp.de>\n\t */\n\tpublic static function makePathfield(string $path, int $uid, int $gid, string $value = '', bool $dom = false): array\n\t{\n\t\t$value = str_replace($path, '', $value);\n\t\t$field = [];\n\n\t\t// path is given without starting slash\n\t\t// but dirList holds the paths with starting slash,\n\t\t// so we just add one here to get the correct\n\t\t// default path selected, #225\n\t\tif (substr($value, 0, 1) != '/' && !$dom) {\n\t\t\t$value = '/' . $value;\n\t\t}\n\n\t\t$fieldType = strtolower(Settings::Get('panel.pathedit'));\n\n\t\tif ($fieldType == 'manual') {\n\t\t\t$field = [\n\t\t\t\t'type' => 'text',\n\t\t\t\t'value' => htmlspecialchars($value)\n\t\t\t];\n\t\t} elseif ($fieldType == 'dropdown') {\n\t\t\t$dirList = self::findDirs($path, $uid, $gid);\n\t\t\tnatcasesort($dirList);\n\n\t\t\tif (sizeof($dirList) > 0) {\n\t\t\t\t$_field = [];\n\t\t\t\tforeach ($dirList as $dir) {\n\t\t\t\t\tif (strpos($dir, $path) === 0) {\n\t\t\t\t\t\t$dir = substr($dir, strlen($path));\n\t\t\t\t\t\t// docroot cut off of current directory == empty -> directory is the docroot\n\t\t\t\t\t\tif (empty($dir)) {\n\t\t\t\t\t\t\t$dir = '/';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$dir = self::makeCorrectDir($dir);\n\t\t\t\t\t}\n\t\t\t\t\t$_field[$dir] = $dir;\n\t\t\t\t}\n\t\t\t\t$field = [\n\t\t\t\t\t'type' => 'select',\n\t\t\t\t\t'select_var' => $_field,\n\t\t\t\t\t'selected' => $value,\n\t\t\t\t\t'value' => $value\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$field = [\n\t\t\t\t\t'type' => 'hidden',\n\t\t\t\t\t'value' => '/',\n\t\t\t\t\t'note' => lng('panel.dirsmissing')\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn $field;\n\t}\n\n\t/**\n\t * Returns an array of found directories\n\t *\n\t * This function checks every found directory if they match either $uid or $gid, if they do\n\t * the found directory is valid. It uses recursive-iterators to find subdirectories.\n\t *\n\t * @param string $path the path to start searching in\n\t * @param int $uid the uid which must match the found directories\n\t * @param int $gid the gid which must match the found directories\n\t *\n\t * @return array Array of found valid paths\n\t * @throws Exception\n\t */\n\tprivate static function findDirs(string $path, int $uid, int $gid): array\n\t{\n\t\t$_fileList = [];\n\t\t$path = self::makeCorrectDir($path);\n\n\t\t// valid directory?\n\t\tif (is_dir($path)) {\n\t\t\t// Will exclude everything under these directories\n\t\t\t$exclude = [\n\t\t\t\t'awstats',\n\t\t\t\t'webalizer',\n\t\t\t\t'goaccess'\n\t\t\t];\n\n\t\t\t/**\n\t\t\t *\n\t\t\t * @param SplFileInfo $file\n\t\t\t * @param mixed $key\n\t\t\t * @param RecursiveCallbackFilterIterator $iterator\n\t\t\t * @return bool True if you need to recurse or if the item is acceptable\n\t\t\t */\n\t\t\t$filter = function ($file, $key, $iterator) use ($exclude) {\n\t\t\t\tif (in_array($file->getFilename(), $exclude)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} elseif (substr($file->getFilename(), 0, 1) == '.') {\n\t\t\t\t\t// also hide hidden folders\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\t// create RecursiveIteratorIterator\n\t\t\t$its = new \\RecursiveIteratorIterator(\n\t\t\t\tnew \\RecursiveCallbackFilterIterator(\n\t\t\t\t\tnew \\RecursiveDirectoryIterator($path, \\RecursiveDirectoryIterator::SKIP_DOTS),\n\t\t\t\t\t$filter\n\t\t\t\t),\n\t\t\t\t\\RecursiveIteratorIterator::SELF_FIRST,\n\t\t\t\t\\RecursiveIteratorIterator::CATCH_GET_CHILD\n\t\t\t);\n\t\t\t// we can limit the recursion-depth, but will it be helpful or\n\t\t\t// will people start asking \"why do I only see 2 subdirectories, i want to use /a/b/c\"\n\t\t\t// let's keep this in mind and see whether it will be useful\n\t\t\t$its->setMaxDepth(2);\n\n\t\t\t// check every file\n\t\t\tforeach ($its as $fullFileName => $it) {\n\t\t\t\tif ($it->isDir() && (fileowner($fullFileName) == $uid || filegroup($fullFileName) == $gid)) {\n\t\t\t\t\t$_fileList[] = self::makeCorrectDir($fullFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$_fileList[] = $path;\n\t\t}\n\n\t\treturn array_unique($_fileList);\n\t}\n\n\t/**\n\t * set the immutable flag for a file\n\t *\n\t * @param string $filename the file to set the flag for\n\t *\n\t * @return void\n\t */\n\tpublic static function setImmutable(string $filename)\n\t{\n\t\tself::safe_exec(self::getImmutableFunction(false) . escapeshellarg($filename));\n\t}\n\n\t/**\n\t * internal function to check whether\n\t * to use chattr (Linux) or chflags (FreeBSD)\n\t *\n\t * @param bool $remove whether to use +i|schg (false) or -i|noschg (true)\n\t *\n\t * @return string functionname + parameter (not the file)\n\t */\n\tprivate static function getImmutableFunction(bool $remove = false): string\n\t{\n\t\tif (self::isFreeBSD()) {\n\t\t\t// FreeBSD style\n\t\t\treturn 'chflags ' . (($remove === true) ? 'noschg ' : 'schg ');\n\t\t} else {\n\t\t\t// Linux style\n\t\t\treturn 'chattr ' . (($remove === true) ? '-i ' : '+i ');\n\t\t}\n\t}\n\n\t/**\n\t * check if the system is FreeBSD (if exact)\n\t * or BSD-based (NetBSD, OpenBSD, etc.\n\t * if exact = false [default])\n\t *\n\t * @param bool $exact whether to check explicitly for FreeBSD or *BSD\n\t *\n\t * @return bool\n\t */\n\tpublic static function isFreeBSD(bool $exact = false): bool\n\t{\n\t\tif (($exact && PHP_OS == 'FreeBSD') || (!$exact && stristr(PHP_OS, 'BSD'))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * removes the immutable flag for a file\n\t *\n\t * @param string $filename the file to set the flag for\n\t *\n\t * @return void\n\t */\n\tpublic static function removeImmutable(string $filename)\n\t{\n\t\tFileDir::safe_exec(self::getImmutableFunction(true) . escapeshellarg($filename));\n\t}\n\n\t/**\n\t *\n\t * @return array|false\n\t */\n\tpublic static function getFilesystemQuota()\n\t{\n\t\t// enabled at all?\n\t\tif (Settings::Get('system.diskquota_enabled')) {\n\t\t\t// set linux defaults\n\t\t\t$repquota_params = \"-np\";\n\t\t\t// $quota_line_regex = \"/^#([0-9]+)\\s*[+-]{2}\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)\\s*(\\d+)/i\";\n\t\t\t$quota_line_regex = \"/^#([0-9]+)\\s+[+-]{2}\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/i\";\n\n\t\t\t// check for freebsd - which needs other values\n\t\t\tif (self::isFreeBSD()) {\n\t\t\t\t$repquota_params = \"-nu\";\n\t\t\t\t$quota_line_regex = \"/^([0-9]+)\\s+[+-]{2}\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)/i\";\n\t\t\t}\n\n\t\t\t// Fetch all quota in the desired partition\n\t\t\t$repquota = [];\n\t\t\texec(\n\t\t\t\tSettings::Get('system.diskquota_repquota_path') . \" \" . $repquota_params . \" \" . escapeshellarg(Settings::Get('system.diskquota_customer_partition')),\n\t\t\t\t$repquota\n\t\t\t);\n\n\t\t\t$usedquota = [];\n\t\t\tforeach ($repquota as $tmpquota) {\n\t\t\t\t$matches = null;\n\t\t\t\t// Let's see if the line matches a quota - line\n\t\t\t\tif (preg_match($quota_line_regex, $tmpquota, $matches)) {\n\t\t\t\t\t// It matches - put it into an array with userid as key (for easy lookup later)\n\t\t\t\t\t$usedquota[$matches[1]] = [\n\t\t\t\t\t\t'block' => [\n\t\t\t\t\t\t\t'used' => $matches[2],\n\t\t\t\t\t\t\t'soft' => $matches[3],\n\t\t\t\t\t\t\t'hard' => $matches[4],\n\t\t\t\t\t\t\t'grace' => (self::isFreeBSD() ? '0' : $matches[5])\n\t\t\t\t\t\t],\n\t\t\t\t\t\t'file' => [\n\t\t\t\t\t\t\t'used' => $matches[6],\n\t\t\t\t\t\t\t'soft' => $matches[7],\n\t\t\t\t\t\t\t'hard' => $matches[8],\n\t\t\t\t\t\t\t'grace' => (self::isFreeBSD() ? '0' : $matches[9])\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $usedquota;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "<?php\n\nuse Froxlor\\Api\\Commands\\Admins;\nuse Froxlor\\Api\\Commands\\Customers;\nuse Froxlor\\Api\\Commands\\Ftps;\nuse Froxlor\\Froxlor;\nuse PHPUnit\\Framework\\TestCase;\n\n/**\n *\n * @covers \\Froxlor\\Api\\ApiCommand\n * @covers \\Froxlor\\Api\\ApiParameter\n * @covers \\Froxlor\\Api\\Commands\\Admins\n * @covers \\Froxlor\\Api\\Commands\\Customers\n * @covers \\Froxlor\\Api\\Commands\\Ftps\n */\nclass FtpsTest extends TestCase\n{\n\n\tpublic function testAdminFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\t// should be the ftp user of the first added customr 'test1'\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testResellerFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get reseller\n\t\t$json_result = Admins::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'reseller'\n\t\t))->get();\n\t\t$reseller_userdata = json_decode($json_result, true)['data'];\n\t\t$reseller_userdata['adminsession'] = 1;\n\t\t$json_result = Ftps::getLocal($reseller_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsGetId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$json_result = Ftps::getLocal($customer_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$result = json_decode($json_result, true)['data'];\n\n\t\t// should be the ftp user of the first added customr 'test1'\n\t\t$this->assertEquals('test1', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsGetOtherId()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'id' => 1\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$this->expectExceptionCode(404);\n\n\t\tFtps::getLocal($customer_userdata, array(\n\t\t\t'id' => 10\n\t\t))->get();\n\t}\n\n\tpublic function testAdminFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(2, $result['count']);\n\n\t\t$json_result = Ftps::getLocal($admin_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(2, $result);\n\t}\n\n\tpublic function testAdminFtpsListSpecificCustomer()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$json_result = Ftps::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\t}\n\n\tpublic function testResellerFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get reseller\n\t\t$json_result = Admins::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'reseller'\n\t\t))->get();\n\t\t$reseller_userdata = json_decode($json_result, true)['data'];\n\t\t$reseller_userdata['adminsession'] = 1;\n\t\t$json_result = Ftps::getLocal($reseller_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\n\t\t$json_result = Ftps::getLocal($reseller_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result);\n\t}\n\n\tpublic function testCustomerFtpsList()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$json_result = Ftps::getLocal($customer_userdata)->listing();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result['count']);\n\t\t$this->assertEquals('test1', $result['list'][0]['username']);\n\n\t\t$json_result = Ftps::getLocal($customer_userdata)->listingCount();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals(1, $result);\n\t}\n\n\tpublic function testCustomerFtpsAdd()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->add();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'], $result['homedir']);\n\t}\n\n\tpublic function testCustomerFtpsAddSymlinkOutsideHomedir()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data']; //\n\n\t\t$customer_userdata['documentroot'] = sys_get_temp_dir() . '/';\n\t\t@unlink($customer_userdata['documentroot'] . '/frx');\n\t\tsymlink(Froxlor::getInstallDir(), $customer_userdata['documentroot'] . '/frx');\n\n\t\t$data = [\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/frx/sub',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1\n\t\t];\n\n\t\t$this->expectExceptionMessage('Found symlink pointing outside of customer home directory: /frx');\n\t\tFtps::getLocal($customer_userdata, $data)->add();\n\t}\n\n\tpublic function testCustomerFtpsAddNoMoreResources()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data']; //\n\n\t\t$customer_userdata['ftps_used'] = 100;\n\n\t\t$this->expectExceptionCode(406);\n\t\t$this->expectExceptionMessage('No more resources available');\n\t\tFtps::getLocal($customer_userdata)->add();\n\t}\n\n\tpublic function testAdminFtpsAddCustomerRequired()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t$data = [\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => 1\n\t\t];\n\n\t\t$this->expectExceptionCode(406);\n\t\t$this->expectExceptionMessage('Requested parameter \"loginname\" is empty where it should not be for \"Customers:get\"');\n\t\tFtps::getLocal($admin_userdata, $data)->add();\n\t}\n\n\tpublic function testCustomerFtpsEdit()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1',\n\t\t\t'ftp_password' => 'h4xXx0r2',\n\t\t\t'path' => '/subfolder',\n\t\t\t'ftp_description' => 'testing2'\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->update();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'] . 'subfolder/', $result['homedir']);\n\t\t$this->assertEquals('testing2', $result['description']);\n\t}\n\n\tpublic function testAdminFtpsEdit()\n\t{\n\t\tglobal $admin_userdata;\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1',\n\t\t\t'customerid' => 1,\n\t\t\t'ftp_password' => 'h4xXx0r2',\n\t\t\t'path' => '/anotherfolder',\n\t\t\t'ftp_description' => 'testing3'\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->update();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'] . 'anotherfolder/', $result['homedir']);\n\t\t$this->assertEquals('testing3', $result['description']);\n\t}\n\n\tpublic function testAdminFtpsAdd()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\n\t\t$data = [\n\t\t\t'customerid' => $customer_userdata['customerid'],\n\t\t\t'ftp_password' => 'h4xXx0r',\n\t\t\t'path' => '/',\n\t\t\t'ftp_description' => 'testing',\n\t\t\t'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->add();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals($customer_userdata['documentroot'], $result['homedir']);\n\t}\n\n\tpublic function testCustomerFtpsDelete()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1ftp1'\n\t\t];\n\t\t$json_result = Ftps::getLocal($customer_userdata, $data)->delete();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1ftp1', $result['username']);\n\t}\n\n\tpublic function testAdminFtpsDelete()\n\t{\n\t\tglobal $admin_userdata;\n\t\t$data = [\n\t\t\t'username' => 'test1ftp2'\n\t\t];\n\t\t$json_result = Ftps::getLocal($admin_userdata, $data)->delete();\n\t\t$result = json_decode($json_result, true)['data'];\n\t\t$this->assertEquals('test1ftp2', $result['username']);\n\t}\n\n\tpublic function testCustomerFtpsDeleteDefaultUser()\n\t{\n\t\tglobal $admin_userdata;\n\n\t\t// get customer\n\t\t$json_result = Customers::getLocal($admin_userdata, array(\n\t\t\t'loginname' => 'test1'\n\t\t))->get();\n\t\t$customer_userdata = json_decode($json_result, true)['data'];\n\t\t$data = [\n\t\t\t'username' => 'test1'\n\t\t];\n\t\t$this->expectExceptionCode(400);\n\t\t$this->expectExceptionMessage('You cannot delete your main FTP account');\n\t\tFtps::getLocal($customer_userdata, $data)->delete();\n\t}\n}\n"], "filenames": ["customer_ftp.php", "lib/Froxlor/Api/Commands/DirOptions.php", "lib/Froxlor/Api/Commands/DirProtections.php", "lib/Froxlor/Api/Commands/Ftps.php", "lib/Froxlor/Api/Commands/SubDomains.php", "lib/Froxlor/Cron/Http/Apache.php", "lib/Froxlor/FileDir.php", "tests/Ftps/FtpsTest.php"], "buggy_code_start_loc": [62, 96, 87, 177, 567, 132, 28, 2], "buggy_code_end_loc": [63, 97, 88, 473, 570, 1259, 251, 198], "fixing_code_start_loc": [62, 96, 87, 177, 567, 132, 29, 1], "fixing_code_end_loc": [63, 97, 88, 473, 570, 1259, 278, 224], "type": "CWE-59", "message": "Improper Link Resolution Before File Access in GitHub repository froxlor/froxlor prior to 2.1.0.\n\n", "other": {"cve": {"id": "CVE-2023-6069", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-10T01:15:07.623", "lastModified": "2024-01-21T03:06:57.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Link Resolution Before File Access in GitHub repository froxlor/froxlor prior to 2.1.0.\n\n"}, {"lang": "es", "value": "Validaci\u00f3n de entrada incorrecta en el repositorio de GitHub froxlor/froxlor anterior a 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:froxlor:froxlor:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "3198109A-4339-43E3-AC82-0C238676EE5A"}]}]}], "references": [{"url": "https://github.com/froxlor/froxlor/commit/9e8f32f1e86016733b603b50c31b97f472e8dabc", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/aac0627e-e59d-476e-9385-edb7ff53758c", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/froxlor/froxlor/commit/9e8f32f1e86016733b603b50c31b97f472e8dabc"}}