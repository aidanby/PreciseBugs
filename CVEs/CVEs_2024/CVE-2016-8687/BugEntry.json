{"buggy_code": ["/*-\n * Copyright (c) 2003-2007 Tim Kientzle\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"bsdtar_platform.h\"\n__FBSDID(\"$FreeBSD: src/usr.bin/tar/util.c,v 1.23 2008/12/15 06:00:25 kientzle Exp $\");\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>  /* Linux doesn't define mode_t, etc. in sys/stat.h. */\n#endif\n#include <ctype.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_IO_H\n#include <io.h>\n#endif\n#ifdef HAVE_STDARG_H\n#include <stdarg.h>\n#endif\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_WCTYPE_H\n#include <wctype.h>\n#else\n/* If we don't have wctype, we need to hack up some version of iswprint(). */\n#define\tiswprint isprint\n#endif\n\n#include \"bsdtar.h\"\n#include \"err.h\"\n#include \"passphrase.h\"\n\nstatic size_t\tbsdtar_expand_char(char *, size_t, char);\nstatic const char *strip_components(const char *path, int elements);\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tread _read\n#endif\n\n/* TODO:  Hack up a version of mbtowc for platforms with no wide\n * character support at all.  I think the following might suffice,\n * but it needs careful testing.\n * #if !HAVE_MBTOWC\n * #define\tmbtowc(wcp, p, n) ((*wcp = *p), 1)\n * #endif\n */\n\n/*\n * Print a string, taking care with any non-printable characters.\n *\n * Note that we use a stack-allocated buffer to receive the formatted\n * string if we can.  This is partly performance (avoiding a call to\n * malloc()), partly out of expedience (we have to call vsnprintf()\n * before malloc() anyway to find out how big a buffer we need; we may\n * as well point that first call at a small local buffer in case it\n * works), but mostly for safety (so we can use this to print messages\n * about out-of-memory conditions).\n */\n\nvoid\nsafe_fprintf(FILE *f, const char *fmt, ...)\n{\n\tchar fmtbuff_stack[256]; /* Place to format the printf() string. */\n\tchar outbuff[256]; /* Buffer for outgoing characters. */\n\tchar *fmtbuff_heap; /* If fmtbuff_stack is too small, we use malloc */\n\tchar *fmtbuff;  /* Pointer to fmtbuff_stack or fmtbuff_heap. */\n\tint fmtbuff_length;\n\tint length, n;\n\tva_list ap;\n\tconst char *p;\n\tunsigned i;\n\twchar_t wc;\n\tchar try_wc;\n\n\t/* Use a stack-allocated buffer if we can, for speed and safety. */\n\tfmtbuff_heap = NULL;\n\tfmtbuff_length = sizeof(fmtbuff_stack);\n\tfmtbuff = fmtbuff_stack;\n\n\t/* Try formatting into the stack buffer. */\n\tva_start(ap, fmt);\n\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\tva_end(ap);\n\n\t/* If the result was too large, allocate a buffer on the heap. */\n\twhile (length < 0 || length >= fmtbuff_length) {\n\t\tif (length >= fmtbuff_length)\n\t\t\tfmtbuff_length = length+1;\n\t\telse if (fmtbuff_length < 8192)\n\t\t\tfmtbuff_length *= 2;\n\t\telse if (fmtbuff_length < 1000000)\n\t\t\tfmtbuff_length += fmtbuff_length / 4;\n\t\telse {\n\t\t\tlength = fmtbuff_length;\n\t\t\tfmtbuff_heap[length-1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tfree(fmtbuff_heap);\n\t\tfmtbuff_heap = malloc(fmtbuff_length);\n\n\t\t/* Reformat the result into the heap buffer if we can. */\n\t\tif (fmtbuff_heap != NULL) {\n\t\t\tfmtbuff = fmtbuff_heap;\n\t\t\tva_start(ap, fmt);\n\t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\t\t\tva_end(ap);\n\t\t} else {\n\t\t\t/* Leave fmtbuff pointing to the truncated\n\t\t\t * string in fmtbuff_stack. */\n\t\t\tlength = sizeof(fmtbuff_stack) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Note: mbrtowc() has a cleaner API, but mbtowc() seems a bit\n\t * more portable, so we use that here instead. */\n\tif (mbtowc(NULL, NULL, 1) == -1) { /* Reset the shift state. */\n\t\t/* mbtowc() should never fail in practice, but\n\t\t * handle the theoretical error anyway. */\n\t\tfree(fmtbuff_heap);\n\t\treturn;\n\t}\n\n\t/* Write data, expanding unprintable characters. */\n\tp = fmtbuff;\n\ti = 0;\n\ttry_wc = 1;\n\twhile (*p != '\\0') {\n\n\t\t/* Convert to wide char, test if the wide\n\t\t * char is printable in the current locale. */\n\t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {\n\t\t\tlength -= n;\n\t\t\tif (iswprint(wc) && wc != L'\\\\') {\n\t\t\t\t/* Printable, copy the bytes through. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\toutbuff[i++] = *p++;\n\t\t\t} else {\n\t\t\t\t/* Not printable, format the bytes. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\ti += (unsigned)bsdtar_expand_char(\n\t\t\t\t\t    outbuff, i, *p++);\n\t\t\t}\n\t\t} else {\n\t\t\t/* After any conversion failure, don't bother\n\t\t\t * trying to convert the rest. */\n\t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);\n\t\t\ttry_wc = 0;\n\t\t}\n\n\t\t/* If our output buffer is full, dump it and keep going. */\n\t\tif (i > (sizeof(outbuff) - 20)) {\n\t\t\toutbuff[i] = '\\0';\n\t\t\tfprintf(f, \"%s\", outbuff);\n\t\t\ti = 0;\n\t\t}\n\t}\n\toutbuff[i] = '\\0';\n\tfprintf(f, \"%s\", outbuff);\n\n\t/* If we allocated a heap-based formatting buffer, free it now. */\n\tfree(fmtbuff_heap);\n}\n\n/*\n * Render an arbitrary sequence of bytes into printable ASCII characters.\n */\nstatic size_t\nbsdtar_expand_char(char *buff, size_t offset, char c)\n{\n\tsize_t i = offset;\n\n\tif (isprint((unsigned char)c) && c != '\\\\')\n\t\tbuff[i++] = c;\n\telse {\n\t\tbuff[i++] = '\\\\';\n\t\tswitch (c) {\n\t\tcase '\\a': buff[i++] = 'a'; break;\n\t\tcase '\\b': buff[i++] = 'b'; break;\n\t\tcase '\\f': buff[i++] = 'f'; break;\n\t\tcase '\\n': buff[i++] = 'n'; break;\n#if '\\r' != '\\n'\n\t\t/* On some platforms, \\n and \\r are the same. */\n\t\tcase '\\r': buff[i++] = 'r'; break;\n#endif\n\t\tcase '\\t': buff[i++] = 't'; break;\n\t\tcase '\\v': buff[i++] = 'v'; break;\n\t\tcase '\\\\': buff[i++] = '\\\\'; break;\n\t\tdefault:\n\t\t\tsprintf(buff + i, \"%03o\", 0xFF & (int)c);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn (i - offset);\n}\n\nint\nyes(const char *fmt, ...)\n{\n\tchar buff[32];\n\tchar *p;\n\tssize_t l;\n\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tfprintf(stderr, \" (y/N)? \");\n\tfflush(stderr);\n\n\tl = read(2, buff, sizeof(buff) - 1);\n\tif (l < 0) {\n\t  fprintf(stderr, \"Keyboard read failed\\n\");\n\t  exit(1);\n\t}\n\tif (l == 0)\n\t\treturn (0);\n\tbuff[l] = 0;\n\n\tfor (p = buff; *p != '\\0'; p++) {\n\t\tif (isspace((unsigned char)*p))\n\t\t\tcontinue;\n\t\tswitch(*p) {\n\t\tcase 'y': case 'Y':\n\t\t\treturn (1);\n\t\tcase 'n': case 'N':\n\t\t\treturn (0);\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/*-\n * The logic here for -C <dir> attempts to avoid\n * chdir() as long as possible.  For example:\n * \"-C /foo -C /bar file\"          needs chdir(\"/bar\") but not chdir(\"/foo\")\n * \"-C /foo -C bar file\"           needs chdir(\"/foo/bar\")\n * \"-C /foo -C bar /file1\"         does not need chdir()\n * \"-C /foo -C bar /file1 file2\"   needs chdir(\"/foo/bar\") before file2\n *\n * The only correct way to handle this is to record a \"pending\" chdir\n * request and combine multiple requests intelligently until we\n * need to process a non-absolute file.  set_chdir() adds the new dir\n * to the pending list; do_chdir() actually executes any pending chdir.\n *\n * This way, programs that build tar command lines don't have to worry\n * about -C with non-existent directories; such requests will only\n * fail if the directory must be accessed.\n *\n */\nvoid\nset_chdir(struct bsdtar *bsdtar, const char *newdir)\n{\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tif (newdir[0] == '/' || newdir[0] == '\\\\' ||\n\t    /* Detect this type, for example, \"C:\\\" or \"C:/\" */\n\t    (((newdir[0] >= 'a' && newdir[0] <= 'z') ||\n\t      (newdir[0] >= 'A' && newdir[0] <= 'Z')) &&\n\t    newdir[1] == ':' && (newdir[2] == '/' || newdir[2] == '\\\\'))) {\n#else\n\tif (newdir[0] == '/') {\n#endif\n\t\t/* The -C /foo -C /bar case; dump first one. */\n\t\tfree(bsdtar->pending_chdir);\n\t\tbsdtar->pending_chdir = NULL;\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\t/* Easy case: no previously-saved dir. */\n\t\tbsdtar->pending_chdir = strdup(newdir);\n\telse {\n\t\t/* The -C /foo -C bar case; concatenate */\n\t\tchar *old_pending = bsdtar->pending_chdir;\n\t\tsize_t old_len = strlen(old_pending);\n\t\tbsdtar->pending_chdir = malloc(old_len + strlen(newdir) + 2);\n\t\tif (old_pending[old_len - 1] == '/')\n\t\t\told_pending[old_len - 1] = '\\0';\n\t\tif (bsdtar->pending_chdir != NULL)\n\t\t\tsprintf(bsdtar->pending_chdir, \"%s/%s\",\n\t\t\t    old_pending, newdir);\n\t\tfree(old_pending);\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\tlafe_errc(1, errno, \"No memory\");\n}\n\nvoid\ndo_chdir(struct bsdtar *bsdtar)\n{\n\tif (bsdtar->pending_chdir == NULL)\n\t\treturn;\n\n\tif (chdir(bsdtar->pending_chdir) != 0) {\n\t\tlafe_errc(1, 0, \"could not chdir to '%s'\\n\",\n\t\t    bsdtar->pending_chdir);\n\t}\n\tfree(bsdtar->pending_chdir);\n\tbsdtar->pending_chdir = NULL;\n}\n\nstatic const char *\nstrip_components(const char *p, int elements)\n{\n\t/* Skip as many elements as necessary. */\n\twhile (elements > 0) {\n\t\tswitch (*p++) {\n\t\tcase '/':\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tcase '\\\\': /* Support \\ path sep on Windows ONLY. */\n#endif\n\t\t\telements--;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t/* Path is too short, skip it. */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/* Skip any / characters.  This handles short paths that have\n\t * additional / termination.  This also handles the case where\n\t * the logic above stops in the middle of a duplicate //\n\t * sequence (which would otherwise get converted to an\n\t * absolute path). */\n\tfor (;;) {\n\t\tswitch (*p) {\n\t\tcase '/':\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tcase '\\\\': /* Support \\ path sep on Windows ONLY. */\n#endif\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\treturn (NULL);\n\t\tdefault:\n\t\t\treturn (p);\n\t\t}\n\t}\n}\n\nstatic void\nwarn_strip_leading_char(struct bsdtar *bsdtar, const char *c)\n{\n\tif (!bsdtar->warned_lead_slash) {\n\t\tlafe_warnc(0,\n\t\t\t   \"Removing leading '%c' from member names\",\n\t\t\t   c[0]);\n\t\tbsdtar->warned_lead_slash = 1;\n\t}\n}\n\nstatic void\nwarn_strip_drive_letter(struct bsdtar *bsdtar)\n{\n\tif (!bsdtar->warned_lead_slash) {\n\t\tlafe_warnc(0,\n\t\t\t   \"Removing leading drive letter from \"\n\t\t\t   \"member names\");\n\t\tbsdtar->warned_lead_slash = 1;\n\t}\n}\n\n/*\n * Convert absolute path to non-absolute path by skipping leading\n * absolute path prefixes.\n */\nstatic const char*\nstrip_absolute_path(struct bsdtar *bsdtar, const char *p)\n{\n\tconst char *rp;\n\n\t/* Remove leading \"//./\" or \"//?/\" or \"//?/UNC/\"\n\t * (absolute path prefixes used by Windows API) */\n\tif ((p[0] == '/' || p[0] == '\\\\') &&\n\t    (p[1] == '/' || p[1] == '\\\\') &&\n\t    (p[2] == '.' || p[2] == '?') &&\n\t    (p[3] == '/' || p[3] == '\\\\'))\n\t{\n\t\tif (p[2] == '?' &&\n\t\t    (p[4] == 'U' || p[4] == 'u') &&\n\t\t    (p[5] == 'N' || p[5] == 'n') &&\n\t\t    (p[6] == 'C' || p[6] == 'c') &&\n\t\t    (p[7] == '/' || p[7] == '\\\\'))\n\t\t\tp += 8;\n\t\telse\n\t\t\tp += 4;\n\t\twarn_strip_drive_letter(bsdtar);\n\t}\n\n\t/* Remove multiple leading slashes and Windows drive letters. */\n\tdo {\n\t\trp = p;\n\t\tif (((p[0] >= 'a' && p[0] <= 'z') ||\n\t\t     (p[0] >= 'A' && p[0] <= 'Z')) &&\n\t\t    p[1] == ':') {\n\t\t\tp += 2;\n\t\t\twarn_strip_drive_letter(bsdtar);\n\t\t}\n\n\t\t/* Remove leading \"/../\", \"/./\", \"//\", etc. */\n\t\twhile (p[0] == '/' || p[0] == '\\\\') {\n\t\t\tif (p[1] == '.' &&\n\t\t\t    p[2] == '.' &&\n\t\t\t    (p[3] == '/' || p[3] == '\\\\')) {\n\t\t\t\tp += 3; /* Remove \"/..\", leave \"/\" for next pass. */\n\t\t\t} else if (p[1] == '.' &&\n\t\t\t\t   (p[2] == '/' || p[2] == '\\\\')) {\n\t\t\t\tp += 2; /* Remove \"/.\", leave \"/\" for next pass. */\n\t\t\t} else\n\t\t\t\tp += 1; /* Remove \"/\". */\n\t\t\twarn_strip_leading_char(bsdtar, rp);\n\t\t}\n\t} while (rp != p);\n\n\treturn (p);\n}\n\n/*\n * Handle --strip-components and any future path-rewriting options.\n * Returns non-zero if the pathname should not be extracted.\n *\n * Note: The rewrites are applied uniformly to pathnames and hardlink\n * names but not to symlink bodies.  This is deliberate: Symlink\n * bodies are not necessarily filenames.  Even when they are, they\n * need to be interpreted relative to the directory containing them,\n * so simple rewrites like this are rarely appropriate.\n *\n * TODO: Support pax-style regex path rewrites.\n */\nint\nedit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n{\n\tconst char *name = archive_entry_pathname(entry);\n\tconst char *original_name = name;\n\tconst char *hardlinkname = archive_entry_hardlink(entry);\n\tconst char *original_hardlinkname = hardlinkname;\n#if defined(HAVE_REGEX_H) || defined(HAVE_PCREPOSIX_H)\n\tchar *subst_name;\n\tint r;\n\n\t/* Apply user-specified substitution to pathname. */\n\tr = apply_substitution(bsdtar, name, &subst_name, 0, 0);\n\tif (r == -1) {\n\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\treturn 1;\n\t}\n\tif (r == 1) {\n\t\tarchive_entry_copy_pathname(entry, subst_name);\n\t\tif (*subst_name == '\\0') {\n\t\t\tfree(subst_name);\n\t\t\treturn -1;\n\t\t} else\n\t\t\tfree(subst_name);\n\t\tname = archive_entry_pathname(entry);\n\t\toriginal_name = name;\n\t}\n\n\t/* Apply user-specified substitution to hardlink target. */\n\tif (hardlinkname != NULL) {\n\t\tr = apply_substitution(bsdtar, hardlinkname, &subst_name, 0, 1);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_hardlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t\thardlinkname = archive_entry_hardlink(entry);\n\t\toriginal_hardlinkname = hardlinkname;\n\t}\n\n\t/* Apply user-specified substitution to symlink body. */\n\tif (archive_entry_symlink(entry) != NULL) {\n\t\tr = apply_substitution(bsdtar, archive_entry_symlink(entry), &subst_name, 1, 0);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_symlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t}\n#endif\n\n\t/* Strip leading dir names as per --strip-components option. */\n\tif (bsdtar->strip_components > 0) {\n\t\tname = strip_components(name, bsdtar->strip_components);\n\t\tif (name == NULL)\n\t\t\treturn (1);\n\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_components(hardlinkname,\n\t\t\t    bsdtar->strip_components);\n\t\t\tif (hardlinkname == NULL)\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (!bsdtar->option_absolute_paths) {\n\t\t/* By default, don't write or restore absolute pathnames. */\n\t\tname = strip_absolute_path(bsdtar, name);\n\t\tif (*name == '\\0')\n\t\t\tname = \".\";\n\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_absolute_path(bsdtar, hardlinkname);\n\t\t\tif (*hardlinkname == '\\0')\n\t\t\t\treturn (1);\n\t\t}\n\t} else {\n\t\t/* Strip redundant leading '/' characters. */\n\t\twhile (name[0] == '/' && name[1] == '/')\n\t\t\tname++;\n\t}\n\n\t/* Replace name in archive_entry. */\n\tif (name != original_name) {\n\t\tarchive_entry_copy_pathname(entry, name);\n\t}\n\tif (hardlinkname != original_hardlinkname) {\n\t\tarchive_entry_copy_hardlink(entry, hardlinkname);\n\t}\n\treturn (0);\n}\n\n/*\n * It would be nice to just use printf() for formatting large numbers,\n * but the compatibility problems are quite a headache.  Hence the\n * following simple utility function.\n */\nconst char *\ntar_i64toa(int64_t n0)\n{\n\tstatic char buff[24];\n\tuint64_t n = n0 < 0 ? -n0 : n0;\n\tchar *p = buff + sizeof(buff);\n\n\t*--p = '\\0';\n\tdo {\n\t\t*--p = '0' + (int)(n % 10);\n\t} while (n /= 10);\n\tif (n0 < 0)\n\t\t*--p = '-';\n\treturn p;\n}\n\n/*\n * Like strcmp(), but try to be a little more aware of the fact that\n * we're comparing two paths.  Right now, it just handles leading\n * \"./\" and trailing '/' specially, so that \"a/b/\" == \"./a/b\"\n *\n * TODO: Make this better, so that \"./a//b/./c/\" == \"a/b/c\"\n * TODO: After this works, push it down into libarchive.\n * TODO: Publish the path normalization routines in libarchive so\n * that bsdtar can normalize paths and use fast strcmp() instead\n * of this.\n *\n * Note: This is currently only used within write.c, so should\n * not handle \\ path separators.\n */\n\nint\npathcmp(const char *a, const char *b)\n{\n\t/* Skip leading './' */\n\tif (a[0] == '.' && a[1] == '/' && a[2] != '\\0')\n\t\ta += 2;\n\tif (b[0] == '.' && b[1] == '/' && b[2] != '\\0')\n\t\tb += 2;\n\t/* Find the first difference, or return (0) if none. */\n\twhile (*a == *b) {\n\t\tif (*a == '\\0')\n\t\t\treturn (0);\n\t\ta++;\n\t\tb++;\n\t}\n\t/*\n\t * If one ends in '/' and the other one doesn't,\n\t * they're the same.\n\t */\n\tif (a[0] == '/' && a[1] == '\\0' && b[0] == '\\0')\n\t\treturn (0);\n\tif (a[0] == '\\0' && b[0] == '/' && b[1] == '\\0')\n\t\treturn (0);\n\t/* They're really different, return the correct sign. */\n\treturn (*(const unsigned char *)a - *(const unsigned char *)b);\n}\n\n#define PPBUFF_SIZE 1024\nconst char *\npassphrase_callback(struct archive *a, void *_client_data)\n{\n\tstruct bsdtar *bsdtar = (struct bsdtar *)_client_data;\n\t(void)a; /* UNUSED */\n\n\tif (bsdtar->ppbuff == NULL) {\n\t\tbsdtar->ppbuff = malloc(PPBUFF_SIZE);\n\t\tif (bsdtar->ppbuff == NULL)\n\t\t\tlafe_errc(1, errno, \"Out of memory\");\n\t}\n\treturn lafe_readpassphrase(\"Enter passphrase:\",\n\t\tbsdtar->ppbuff, PPBUFF_SIZE);\n}\n\nvoid\npassphrase_free(char *ppbuff)\n{\n\tif (ppbuff != NULL) {\n\t\tmemset(ppbuff, 0, PPBUFF_SIZE);\n\t\tfree(ppbuff);\n\t}\n}\n\n/*\n * Display information about the current file.\n *\n * The format here roughly duplicates the output of 'ls -l'.\n * This is based on SUSv2, where 'tar tv' is documented as\n * listing additional information in an \"unspecified format,\"\n * and 'pax -l' is documented as using the same format as 'ls -l'.\n */\nvoid\nlist_item_verbose(struct bsdtar *bsdtar, FILE *out, struct archive_entry *entry)\n{\n\tchar\t\t\t tmp[100];\n\tsize_t\t\t\t w;\n\tconst char\t\t*p;\n\tconst char\t\t*fmt;\n\ttime_t\t\t\t tim;\n\tstatic time_t\t\t now;\n\n\t/*\n\t * We avoid collecting the entire list in memory at once by\n\t * listing things as we see them.  However, that also means we can't\n\t * just pre-compute the field widths.  Instead, we start with guesses\n\t * and just widen them as necessary.  These numbers are completely\n\t * arbitrary.\n\t */\n\tif (!bsdtar->u_width) {\n\t\tbsdtar->u_width = 6;\n\t\tbsdtar->gs_width = 13;\n\t}\n\tif (!now)\n\t\ttime(&now);\n\tfprintf(out, \"%s %d \",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry));\n\n\t/* Use uname if it's present, else uid. */\n\tp = archive_entry_uname(entry);\n\tif ((p == NULL) || (*p == '\\0')) {\n\t\tsprintf(tmp, \"%lu \",\n\t\t    (unsigned long)archive_entry_uid(entry));\n\t\tp = tmp;\n\t}\n\tw = strlen(p);\n\tif (w > bsdtar->u_width)\n\t\tbsdtar->u_width = w;\n\tfprintf(out, \"%-*s \", (int)bsdtar->u_width, p);\n\n\t/* Use gname if it's present, else gid. */\n\tp = archive_entry_gname(entry);\n\tif (p != NULL && p[0] != '\\0') {\n\t\tfprintf(out, \"%s\", p);\n\t\tw = strlen(p);\n\t} else {\n\t\tsprintf(tmp, \"%lu\",\n\t\t    (unsigned long)archive_entry_gid(entry));\n\t\tw = strlen(tmp);\n\t\tfprintf(out, \"%s\", tmp);\n\t}\n\n\t/*\n\t * Print device number or file size, right-aligned so as to make\n\t * total width of group and devnum/filesize fields be gs_width.\n\t * If gs_width is too small, grow it.\n\t */\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsprintf(tmp, \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(tmp, tar_i64toa(archive_entry_size(entry)));\n\t}\n\tif (w + strlen(tmp) >= bsdtar->gs_width)\n\t\tbsdtar->gs_width = w+strlen(tmp)+1;\n\tfprintf(out, \"%*s\", (int)(bsdtar->gs_width - w), tmp);\n\n\t/* Format the time using 'ls -l' conventions. */\n\ttim = archive_entry_mtime(entry);\n#define\tHALF_YEAR (time_t)365 * 86400 / 2\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tDAY_FMT  \"%d\"  /* Windows' strftime function does not support %e format. */\n#else\n#define\tDAY_FMT  \"%e\"  /* Day number without leading zeros */\n#endif\n\tif (tim < now - HALF_YEAR || tim > now + HALF_YEAR)\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b  %Y\" : \"%b \" DAY_FMT \"  %Y\";\n\telse\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b %H:%M\" : \"%b \" DAY_FMT \" %H:%M\";\n\tstrftime(tmp, sizeof(tmp), fmt, localtime(&tim));\n\tfprintf(out, \" %s \", tmp);\n\tsafe_fprintf(out, \"%s\", archive_entry_pathname(entry));\n\n\t/* Extra information for links. */\n\tif (archive_entry_hardlink(entry)) /* Hard link */\n\t\tsafe_fprintf(out, \" link to %s\",\n\t\t    archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) /* Symbolic link */\n\t\tsafe_fprintf(out, \" -> %s\", archive_entry_symlink(entry));\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2007 Tim Kientzle\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"bsdtar_platform.h\"\n__FBSDID(\"$FreeBSD: src/usr.bin/tar/util.c,v 1.23 2008/12/15 06:00:25 kientzle Exp $\");\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>  /* Linux doesn't define mode_t, etc. in sys/stat.h. */\n#endif\n#include <ctype.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_IO_H\n#include <io.h>\n#endif\n#ifdef HAVE_STDARG_H\n#include <stdarg.h>\n#endif\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_WCTYPE_H\n#include <wctype.h>\n#else\n/* If we don't have wctype, we need to hack up some version of iswprint(). */\n#define\tiswprint isprint\n#endif\n\n#include \"bsdtar.h\"\n#include \"err.h\"\n#include \"passphrase.h\"\n\nstatic size_t\tbsdtar_expand_char(char *, size_t, char);\nstatic const char *strip_components(const char *path, int elements);\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tread _read\n#endif\n\n/* TODO:  Hack up a version of mbtowc for platforms with no wide\n * character support at all.  I think the following might suffice,\n * but it needs careful testing.\n * #if !HAVE_MBTOWC\n * #define\tmbtowc(wcp, p, n) ((*wcp = *p), 1)\n * #endif\n */\n\n/*\n * Print a string, taking care with any non-printable characters.\n *\n * Note that we use a stack-allocated buffer to receive the formatted\n * string if we can.  This is partly performance (avoiding a call to\n * malloc()), partly out of expedience (we have to call vsnprintf()\n * before malloc() anyway to find out how big a buffer we need; we may\n * as well point that first call at a small local buffer in case it\n * works), but mostly for safety (so we can use this to print messages\n * about out-of-memory conditions).\n */\n\nvoid\nsafe_fprintf(FILE *f, const char *fmt, ...)\n{\n\tchar fmtbuff_stack[256]; /* Place to format the printf() string. */\n\tchar outbuff[256]; /* Buffer for outgoing characters. */\n\tchar *fmtbuff_heap; /* If fmtbuff_stack is too small, we use malloc */\n\tchar *fmtbuff;  /* Pointer to fmtbuff_stack or fmtbuff_heap. */\n\tint fmtbuff_length;\n\tint length, n;\n\tva_list ap;\n\tconst char *p;\n\tunsigned i;\n\twchar_t wc;\n\tchar try_wc;\n\n\t/* Use a stack-allocated buffer if we can, for speed and safety. */\n\tfmtbuff_heap = NULL;\n\tfmtbuff_length = sizeof(fmtbuff_stack);\n\tfmtbuff = fmtbuff_stack;\n\n\t/* Try formatting into the stack buffer. */\n\tva_start(ap, fmt);\n\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\tva_end(ap);\n\n\t/* If the result was too large, allocate a buffer on the heap. */\n\twhile (length < 0 || length >= fmtbuff_length) {\n\t\tif (length >= fmtbuff_length)\n\t\t\tfmtbuff_length = length+1;\n\t\telse if (fmtbuff_length < 8192)\n\t\t\tfmtbuff_length *= 2;\n\t\telse if (fmtbuff_length < 1000000)\n\t\t\tfmtbuff_length += fmtbuff_length / 4;\n\t\telse {\n\t\t\tlength = fmtbuff_length;\n\t\t\tfmtbuff_heap[length-1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tfree(fmtbuff_heap);\n\t\tfmtbuff_heap = malloc(fmtbuff_length);\n\n\t\t/* Reformat the result into the heap buffer if we can. */\n\t\tif (fmtbuff_heap != NULL) {\n\t\t\tfmtbuff = fmtbuff_heap;\n\t\t\tva_start(ap, fmt);\n\t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\t\t\tva_end(ap);\n\t\t} else {\n\t\t\t/* Leave fmtbuff pointing to the truncated\n\t\t\t * string in fmtbuff_stack. */\n\t\t\tlength = sizeof(fmtbuff_stack) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Note: mbrtowc() has a cleaner API, but mbtowc() seems a bit\n\t * more portable, so we use that here instead. */\n\tif (mbtowc(NULL, NULL, 1) == -1) { /* Reset the shift state. */\n\t\t/* mbtowc() should never fail in practice, but\n\t\t * handle the theoretical error anyway. */\n\t\tfree(fmtbuff_heap);\n\t\treturn;\n\t}\n\n\t/* Write data, expanding unprintable characters. */\n\tp = fmtbuff;\n\ti = 0;\n\ttry_wc = 1;\n\twhile (*p != '\\0') {\n\n\t\t/* Convert to wide char, test if the wide\n\t\t * char is printable in the current locale. */\n\t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {\n\t\t\tlength -= n;\n\t\t\tif (iswprint(wc) && wc != L'\\\\') {\n\t\t\t\t/* Printable, copy the bytes through. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\toutbuff[i++] = *p++;\n\t\t\t} else {\n\t\t\t\t/* Not printable, format the bytes. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\ti += (unsigned)bsdtar_expand_char(\n\t\t\t\t\t    outbuff, i, *p++);\n\t\t\t}\n\t\t} else {\n\t\t\t/* After any conversion failure, don't bother\n\t\t\t * trying to convert the rest. */\n\t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);\n\t\t\ttry_wc = 0;\n\t\t}\n\n\t\t/* If our output buffer is full, dump it and keep going. */\n\t\tif (i > (sizeof(outbuff) - 128)) {\n\t\t\toutbuff[i] = '\\0';\n\t\t\tfprintf(f, \"%s\", outbuff);\n\t\t\ti = 0;\n\t\t}\n\t}\n\toutbuff[i] = '\\0';\n\tfprintf(f, \"%s\", outbuff);\n\n\t/* If we allocated a heap-based formatting buffer, free it now. */\n\tfree(fmtbuff_heap);\n}\n\n/*\n * Render an arbitrary sequence of bytes into printable ASCII characters.\n */\nstatic size_t\nbsdtar_expand_char(char *buff, size_t offset, char c)\n{\n\tsize_t i = offset;\n\n\tif (isprint((unsigned char)c) && c != '\\\\')\n\t\tbuff[i++] = c;\n\telse {\n\t\tbuff[i++] = '\\\\';\n\t\tswitch (c) {\n\t\tcase '\\a': buff[i++] = 'a'; break;\n\t\tcase '\\b': buff[i++] = 'b'; break;\n\t\tcase '\\f': buff[i++] = 'f'; break;\n\t\tcase '\\n': buff[i++] = 'n'; break;\n#if '\\r' != '\\n'\n\t\t/* On some platforms, \\n and \\r are the same. */\n\t\tcase '\\r': buff[i++] = 'r'; break;\n#endif\n\t\tcase '\\t': buff[i++] = 't'; break;\n\t\tcase '\\v': buff[i++] = 'v'; break;\n\t\tcase '\\\\': buff[i++] = '\\\\'; break;\n\t\tdefault:\n\t\t\tsprintf(buff + i, \"%03o\", 0xFF & (int)c);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn (i - offset);\n}\n\nint\nyes(const char *fmt, ...)\n{\n\tchar buff[32];\n\tchar *p;\n\tssize_t l;\n\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tfprintf(stderr, \" (y/N)? \");\n\tfflush(stderr);\n\n\tl = read(2, buff, sizeof(buff) - 1);\n\tif (l < 0) {\n\t  fprintf(stderr, \"Keyboard read failed\\n\");\n\t  exit(1);\n\t}\n\tif (l == 0)\n\t\treturn (0);\n\tbuff[l] = 0;\n\n\tfor (p = buff; *p != '\\0'; p++) {\n\t\tif (isspace((unsigned char)*p))\n\t\t\tcontinue;\n\t\tswitch(*p) {\n\t\tcase 'y': case 'Y':\n\t\t\treturn (1);\n\t\tcase 'n': case 'N':\n\t\t\treturn (0);\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/*-\n * The logic here for -C <dir> attempts to avoid\n * chdir() as long as possible.  For example:\n * \"-C /foo -C /bar file\"          needs chdir(\"/bar\") but not chdir(\"/foo\")\n * \"-C /foo -C bar file\"           needs chdir(\"/foo/bar\")\n * \"-C /foo -C bar /file1\"         does not need chdir()\n * \"-C /foo -C bar /file1 file2\"   needs chdir(\"/foo/bar\") before file2\n *\n * The only correct way to handle this is to record a \"pending\" chdir\n * request and combine multiple requests intelligently until we\n * need to process a non-absolute file.  set_chdir() adds the new dir\n * to the pending list; do_chdir() actually executes any pending chdir.\n *\n * This way, programs that build tar command lines don't have to worry\n * about -C with non-existent directories; such requests will only\n * fail if the directory must be accessed.\n *\n */\nvoid\nset_chdir(struct bsdtar *bsdtar, const char *newdir)\n{\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tif (newdir[0] == '/' || newdir[0] == '\\\\' ||\n\t    /* Detect this type, for example, \"C:\\\" or \"C:/\" */\n\t    (((newdir[0] >= 'a' && newdir[0] <= 'z') ||\n\t      (newdir[0] >= 'A' && newdir[0] <= 'Z')) &&\n\t    newdir[1] == ':' && (newdir[2] == '/' || newdir[2] == '\\\\'))) {\n#else\n\tif (newdir[0] == '/') {\n#endif\n\t\t/* The -C /foo -C /bar case; dump first one. */\n\t\tfree(bsdtar->pending_chdir);\n\t\tbsdtar->pending_chdir = NULL;\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\t/* Easy case: no previously-saved dir. */\n\t\tbsdtar->pending_chdir = strdup(newdir);\n\telse {\n\t\t/* The -C /foo -C bar case; concatenate */\n\t\tchar *old_pending = bsdtar->pending_chdir;\n\t\tsize_t old_len = strlen(old_pending);\n\t\tbsdtar->pending_chdir = malloc(old_len + strlen(newdir) + 2);\n\t\tif (old_pending[old_len - 1] == '/')\n\t\t\told_pending[old_len - 1] = '\\0';\n\t\tif (bsdtar->pending_chdir != NULL)\n\t\t\tsprintf(bsdtar->pending_chdir, \"%s/%s\",\n\t\t\t    old_pending, newdir);\n\t\tfree(old_pending);\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\tlafe_errc(1, errno, \"No memory\");\n}\n\nvoid\ndo_chdir(struct bsdtar *bsdtar)\n{\n\tif (bsdtar->pending_chdir == NULL)\n\t\treturn;\n\n\tif (chdir(bsdtar->pending_chdir) != 0) {\n\t\tlafe_errc(1, 0, \"could not chdir to '%s'\\n\",\n\t\t    bsdtar->pending_chdir);\n\t}\n\tfree(bsdtar->pending_chdir);\n\tbsdtar->pending_chdir = NULL;\n}\n\nstatic const char *\nstrip_components(const char *p, int elements)\n{\n\t/* Skip as many elements as necessary. */\n\twhile (elements > 0) {\n\t\tswitch (*p++) {\n\t\tcase '/':\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tcase '\\\\': /* Support \\ path sep on Windows ONLY. */\n#endif\n\t\t\telements--;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t/* Path is too short, skip it. */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/* Skip any / characters.  This handles short paths that have\n\t * additional / termination.  This also handles the case where\n\t * the logic above stops in the middle of a duplicate //\n\t * sequence (which would otherwise get converted to an\n\t * absolute path). */\n\tfor (;;) {\n\t\tswitch (*p) {\n\t\tcase '/':\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tcase '\\\\': /* Support \\ path sep on Windows ONLY. */\n#endif\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\treturn (NULL);\n\t\tdefault:\n\t\t\treturn (p);\n\t\t}\n\t}\n}\n\nstatic void\nwarn_strip_leading_char(struct bsdtar *bsdtar, const char *c)\n{\n\tif (!bsdtar->warned_lead_slash) {\n\t\tlafe_warnc(0,\n\t\t\t   \"Removing leading '%c' from member names\",\n\t\t\t   c[0]);\n\t\tbsdtar->warned_lead_slash = 1;\n\t}\n}\n\nstatic void\nwarn_strip_drive_letter(struct bsdtar *bsdtar)\n{\n\tif (!bsdtar->warned_lead_slash) {\n\t\tlafe_warnc(0,\n\t\t\t   \"Removing leading drive letter from \"\n\t\t\t   \"member names\");\n\t\tbsdtar->warned_lead_slash = 1;\n\t}\n}\n\n/*\n * Convert absolute path to non-absolute path by skipping leading\n * absolute path prefixes.\n */\nstatic const char*\nstrip_absolute_path(struct bsdtar *bsdtar, const char *p)\n{\n\tconst char *rp;\n\n\t/* Remove leading \"//./\" or \"//?/\" or \"//?/UNC/\"\n\t * (absolute path prefixes used by Windows API) */\n\tif ((p[0] == '/' || p[0] == '\\\\') &&\n\t    (p[1] == '/' || p[1] == '\\\\') &&\n\t    (p[2] == '.' || p[2] == '?') &&\n\t    (p[3] == '/' || p[3] == '\\\\'))\n\t{\n\t\tif (p[2] == '?' &&\n\t\t    (p[4] == 'U' || p[4] == 'u') &&\n\t\t    (p[5] == 'N' || p[5] == 'n') &&\n\t\t    (p[6] == 'C' || p[6] == 'c') &&\n\t\t    (p[7] == '/' || p[7] == '\\\\'))\n\t\t\tp += 8;\n\t\telse\n\t\t\tp += 4;\n\t\twarn_strip_drive_letter(bsdtar);\n\t}\n\n\t/* Remove multiple leading slashes and Windows drive letters. */\n\tdo {\n\t\trp = p;\n\t\tif (((p[0] >= 'a' && p[0] <= 'z') ||\n\t\t     (p[0] >= 'A' && p[0] <= 'Z')) &&\n\t\t    p[1] == ':') {\n\t\t\tp += 2;\n\t\t\twarn_strip_drive_letter(bsdtar);\n\t\t}\n\n\t\t/* Remove leading \"/../\", \"/./\", \"//\", etc. */\n\t\twhile (p[0] == '/' || p[0] == '\\\\') {\n\t\t\tif (p[1] == '.' &&\n\t\t\t    p[2] == '.' &&\n\t\t\t    (p[3] == '/' || p[3] == '\\\\')) {\n\t\t\t\tp += 3; /* Remove \"/..\", leave \"/\" for next pass. */\n\t\t\t} else if (p[1] == '.' &&\n\t\t\t\t   (p[2] == '/' || p[2] == '\\\\')) {\n\t\t\t\tp += 2; /* Remove \"/.\", leave \"/\" for next pass. */\n\t\t\t} else\n\t\t\t\tp += 1; /* Remove \"/\". */\n\t\t\twarn_strip_leading_char(bsdtar, rp);\n\t\t}\n\t} while (rp != p);\n\n\treturn (p);\n}\n\n/*\n * Handle --strip-components and any future path-rewriting options.\n * Returns non-zero if the pathname should not be extracted.\n *\n * Note: The rewrites are applied uniformly to pathnames and hardlink\n * names but not to symlink bodies.  This is deliberate: Symlink\n * bodies are not necessarily filenames.  Even when they are, they\n * need to be interpreted relative to the directory containing them,\n * so simple rewrites like this are rarely appropriate.\n *\n * TODO: Support pax-style regex path rewrites.\n */\nint\nedit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n{\n\tconst char *name = archive_entry_pathname(entry);\n\tconst char *original_name = name;\n\tconst char *hardlinkname = archive_entry_hardlink(entry);\n\tconst char *original_hardlinkname = hardlinkname;\n#if defined(HAVE_REGEX_H) || defined(HAVE_PCREPOSIX_H)\n\tchar *subst_name;\n\tint r;\n\n\t/* Apply user-specified substitution to pathname. */\n\tr = apply_substitution(bsdtar, name, &subst_name, 0, 0);\n\tif (r == -1) {\n\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\treturn 1;\n\t}\n\tif (r == 1) {\n\t\tarchive_entry_copy_pathname(entry, subst_name);\n\t\tif (*subst_name == '\\0') {\n\t\t\tfree(subst_name);\n\t\t\treturn -1;\n\t\t} else\n\t\t\tfree(subst_name);\n\t\tname = archive_entry_pathname(entry);\n\t\toriginal_name = name;\n\t}\n\n\t/* Apply user-specified substitution to hardlink target. */\n\tif (hardlinkname != NULL) {\n\t\tr = apply_substitution(bsdtar, hardlinkname, &subst_name, 0, 1);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_hardlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t\thardlinkname = archive_entry_hardlink(entry);\n\t\toriginal_hardlinkname = hardlinkname;\n\t}\n\n\t/* Apply user-specified substitution to symlink body. */\n\tif (archive_entry_symlink(entry) != NULL) {\n\t\tr = apply_substitution(bsdtar, archive_entry_symlink(entry), &subst_name, 1, 0);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_symlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t}\n#endif\n\n\t/* Strip leading dir names as per --strip-components option. */\n\tif (bsdtar->strip_components > 0) {\n\t\tname = strip_components(name, bsdtar->strip_components);\n\t\tif (name == NULL)\n\t\t\treturn (1);\n\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_components(hardlinkname,\n\t\t\t    bsdtar->strip_components);\n\t\t\tif (hardlinkname == NULL)\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (!bsdtar->option_absolute_paths) {\n\t\t/* By default, don't write or restore absolute pathnames. */\n\t\tname = strip_absolute_path(bsdtar, name);\n\t\tif (*name == '\\0')\n\t\t\tname = \".\";\n\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_absolute_path(bsdtar, hardlinkname);\n\t\t\tif (*hardlinkname == '\\0')\n\t\t\t\treturn (1);\n\t\t}\n\t} else {\n\t\t/* Strip redundant leading '/' characters. */\n\t\twhile (name[0] == '/' && name[1] == '/')\n\t\t\tname++;\n\t}\n\n\t/* Replace name in archive_entry. */\n\tif (name != original_name) {\n\t\tarchive_entry_copy_pathname(entry, name);\n\t}\n\tif (hardlinkname != original_hardlinkname) {\n\t\tarchive_entry_copy_hardlink(entry, hardlinkname);\n\t}\n\treturn (0);\n}\n\n/*\n * It would be nice to just use printf() for formatting large numbers,\n * but the compatibility problems are quite a headache.  Hence the\n * following simple utility function.\n */\nconst char *\ntar_i64toa(int64_t n0)\n{\n\tstatic char buff[24];\n\tuint64_t n = n0 < 0 ? -n0 : n0;\n\tchar *p = buff + sizeof(buff);\n\n\t*--p = '\\0';\n\tdo {\n\t\t*--p = '0' + (int)(n % 10);\n\t} while (n /= 10);\n\tif (n0 < 0)\n\t\t*--p = '-';\n\treturn p;\n}\n\n/*\n * Like strcmp(), but try to be a little more aware of the fact that\n * we're comparing two paths.  Right now, it just handles leading\n * \"./\" and trailing '/' specially, so that \"a/b/\" == \"./a/b\"\n *\n * TODO: Make this better, so that \"./a//b/./c/\" == \"a/b/c\"\n * TODO: After this works, push it down into libarchive.\n * TODO: Publish the path normalization routines in libarchive so\n * that bsdtar can normalize paths and use fast strcmp() instead\n * of this.\n *\n * Note: This is currently only used within write.c, so should\n * not handle \\ path separators.\n */\n\nint\npathcmp(const char *a, const char *b)\n{\n\t/* Skip leading './' */\n\tif (a[0] == '.' && a[1] == '/' && a[2] != '\\0')\n\t\ta += 2;\n\tif (b[0] == '.' && b[1] == '/' && b[2] != '\\0')\n\t\tb += 2;\n\t/* Find the first difference, or return (0) if none. */\n\twhile (*a == *b) {\n\t\tif (*a == '\\0')\n\t\t\treturn (0);\n\t\ta++;\n\t\tb++;\n\t}\n\t/*\n\t * If one ends in '/' and the other one doesn't,\n\t * they're the same.\n\t */\n\tif (a[0] == '/' && a[1] == '\\0' && b[0] == '\\0')\n\t\treturn (0);\n\tif (a[0] == '\\0' && b[0] == '/' && b[1] == '\\0')\n\t\treturn (0);\n\t/* They're really different, return the correct sign. */\n\treturn (*(const unsigned char *)a - *(const unsigned char *)b);\n}\n\n#define PPBUFF_SIZE 1024\nconst char *\npassphrase_callback(struct archive *a, void *_client_data)\n{\n\tstruct bsdtar *bsdtar = (struct bsdtar *)_client_data;\n\t(void)a; /* UNUSED */\n\n\tif (bsdtar->ppbuff == NULL) {\n\t\tbsdtar->ppbuff = malloc(PPBUFF_SIZE);\n\t\tif (bsdtar->ppbuff == NULL)\n\t\t\tlafe_errc(1, errno, \"Out of memory\");\n\t}\n\treturn lafe_readpassphrase(\"Enter passphrase:\",\n\t\tbsdtar->ppbuff, PPBUFF_SIZE);\n}\n\nvoid\npassphrase_free(char *ppbuff)\n{\n\tif (ppbuff != NULL) {\n\t\tmemset(ppbuff, 0, PPBUFF_SIZE);\n\t\tfree(ppbuff);\n\t}\n}\n\n/*\n * Display information about the current file.\n *\n * The format here roughly duplicates the output of 'ls -l'.\n * This is based on SUSv2, where 'tar tv' is documented as\n * listing additional information in an \"unspecified format,\"\n * and 'pax -l' is documented as using the same format as 'ls -l'.\n */\nvoid\nlist_item_verbose(struct bsdtar *bsdtar, FILE *out, struct archive_entry *entry)\n{\n\tchar\t\t\t tmp[100];\n\tsize_t\t\t\t w;\n\tconst char\t\t*p;\n\tconst char\t\t*fmt;\n\ttime_t\t\t\t tim;\n\tstatic time_t\t\t now;\n\n\t/*\n\t * We avoid collecting the entire list in memory at once by\n\t * listing things as we see them.  However, that also means we can't\n\t * just pre-compute the field widths.  Instead, we start with guesses\n\t * and just widen them as necessary.  These numbers are completely\n\t * arbitrary.\n\t */\n\tif (!bsdtar->u_width) {\n\t\tbsdtar->u_width = 6;\n\t\tbsdtar->gs_width = 13;\n\t}\n\tif (!now)\n\t\ttime(&now);\n\tfprintf(out, \"%s %d \",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry));\n\n\t/* Use uname if it's present, else uid. */\n\tp = archive_entry_uname(entry);\n\tif ((p == NULL) || (*p == '\\0')) {\n\t\tsprintf(tmp, \"%lu \",\n\t\t    (unsigned long)archive_entry_uid(entry));\n\t\tp = tmp;\n\t}\n\tw = strlen(p);\n\tif (w > bsdtar->u_width)\n\t\tbsdtar->u_width = w;\n\tfprintf(out, \"%-*s \", (int)bsdtar->u_width, p);\n\n\t/* Use gname if it's present, else gid. */\n\tp = archive_entry_gname(entry);\n\tif (p != NULL && p[0] != '\\0') {\n\t\tfprintf(out, \"%s\", p);\n\t\tw = strlen(p);\n\t} else {\n\t\tsprintf(tmp, \"%lu\",\n\t\t    (unsigned long)archive_entry_gid(entry));\n\t\tw = strlen(tmp);\n\t\tfprintf(out, \"%s\", tmp);\n\t}\n\n\t/*\n\t * Print device number or file size, right-aligned so as to make\n\t * total width of group and devnum/filesize fields be gs_width.\n\t * If gs_width is too small, grow it.\n\t */\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsprintf(tmp, \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(tmp, tar_i64toa(archive_entry_size(entry)));\n\t}\n\tif (w + strlen(tmp) >= bsdtar->gs_width)\n\t\tbsdtar->gs_width = w+strlen(tmp)+1;\n\tfprintf(out, \"%*s\", (int)(bsdtar->gs_width - w), tmp);\n\n\t/* Format the time using 'ls -l' conventions. */\n\ttim = archive_entry_mtime(entry);\n#define\tHALF_YEAR (time_t)365 * 86400 / 2\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tDAY_FMT  \"%d\"  /* Windows' strftime function does not support %e format. */\n#else\n#define\tDAY_FMT  \"%e\"  /* Day number without leading zeros */\n#endif\n\tif (tim < now - HALF_YEAR || tim > now + HALF_YEAR)\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b  %Y\" : \"%b \" DAY_FMT \"  %Y\";\n\telse\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b %H:%M\" : \"%b \" DAY_FMT \" %H:%M\";\n\tstrftime(tmp, sizeof(tmp), fmt, localtime(&tim));\n\tfprintf(out, \" %s \", tmp);\n\tsafe_fprintf(out, \"%s\", archive_entry_pathname(entry));\n\n\t/* Extra information for links. */\n\tif (archive_entry_hardlink(entry)) /* Hard link */\n\t\tsafe_fprintf(out, \" link to %s\",\n\t\t    archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) /* Symbolic link */\n\t\tsafe_fprintf(out, \" -> %s\", archive_entry_symlink(entry));\n}\n"], "filenames": ["tar/util.c"], "buggy_code_start_loc": [185], "buggy_code_end_loc": [186], "fixing_code_start_loc": [185], "fixing_code_end_loc": [186], "type": "CWE-119", "message": "Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.", "other": {"cve": {"id": "CVE-2016-8687", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-15T19:59:00.580", "lastModified": "2018-11-30T11:29:00.860", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en pila en la funci\u00f3n safe_fprintf en tar/util.c en libarchive 3.2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio a trav\u00e9s de un car\u00e1cter multibyte manipulado no imprimible en un nombre de archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "4D64396A-0476-4C56-82AB-353D8DA332E3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00027.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/16/11", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93781", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037668", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/09/11/libarchive-bsdtar-stack-based-buffer-overflow-in-bsdtar_expand_char-util-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1377926", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libarchive/libarchive/commit/e37b620fe8f14535d737e89a4dcabaed4517bf1a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00037.html", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201701-03", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/e37b620fe8f14535d737e89a4dcabaed4517bf1a"}}