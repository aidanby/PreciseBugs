{"buggy_code": ["/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n\n#include <base/math.h>\n#include <base/system.h>\n\n#include <engine/config.h>\n#include <engine/console.h>\n#include <engine/engine.h>\n#include <engine/map.h>\n#include <engine/masterserver.h>\n#include <engine/server.h>\n#include <engine/storage.h>\n\n#include <engine/shared/compression.h>\n#include <engine/shared/config.h>\n#include <engine/shared/datafile.h>\n#include <engine/shared/demo.h>\n#include <engine/shared/econ.h>\n#include <engine/shared/filecollection.h>\n#include <engine/shared/mapchecker.h>\n#include <engine/shared/netban.h>\n#include <engine/shared/network.h>\n#include <engine/shared/packer.h>\n#include <engine/shared/protocol.h>\n#include <engine/shared/snapshot.h>\n\n#include <mastersrv/mastersrv.h>\n\n#include \"register.h\"\n#include \"server.h\"\n\n#if defined(CONF_FAMILY_WINDOWS)\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n#endif\n\n/*static const char *StrLtrim(const char *pStr)\n{\n\twhile(*pStr && *pStr >= 0 && *pStr <= 32)\n\t\tpStr++;\n\treturn pStr;\n}\n\nstatic void StrRtrim(char *pStr)\n{\n\tint i = str_length(pStr);\n\twhile(i >= 0)\n\t{\n\t\tif(pStr[i] < 0 || pStr[i] > 32)\n\t\t\tbreak;\n\t\tpStr[i] = 0;\n\t\ti--;\n\t}\n}*/\n\n\nCSnapIDPool::CSnapIDPool()\n{\n\tReset();\n}\n\nvoid CSnapIDPool::Reset()\n{\n\tfor(int i = 0; i < MAX_IDS; i++)\n\t{\n\t\tm_aIDs[i].m_Next = i+1;\n\t\tm_aIDs[i].m_State = 0;\n\t}\n\n\tm_aIDs[MAX_IDS-1].m_Next = -1;\n\tm_FirstFree = 0;\n\tm_FirstTimed = -1;\n\tm_LastTimed = -1;\n\tm_Usage = 0;\n\tm_InUsage = 0;\n}\n\n\nvoid CSnapIDPool::RemoveFirstTimeout()\n{\n\tint NextTimed = m_aIDs[m_FirstTimed].m_Next;\n\n\t// add it to the free list\n\tm_aIDs[m_FirstTimed].m_Next = m_FirstFree;\n\tm_aIDs[m_FirstTimed].m_State = 0;\n\tm_FirstFree = m_FirstTimed;\n\n\t// remove it from the timed list\n\tm_FirstTimed = NextTimed;\n\tif(m_FirstTimed == -1)\n\t\tm_LastTimed = -1;\n\n\tm_Usage--;\n}\n\nint CSnapIDPool::NewID()\n{\n\tint64 Now = time_get();\n\n\t// process timed ids\n\twhile(m_FirstTimed != -1 && m_aIDs[m_FirstTimed].m_Timeout < Now)\n\t\tRemoveFirstTimeout();\n\n\tint ID = m_FirstFree;\n\tdbg_assert(ID != -1, \"id error\");\n\tif(ID == -1)\n\t\treturn ID;\n\tm_FirstFree = m_aIDs[m_FirstFree].m_Next;\n\tm_aIDs[ID].m_State = 1;\n\tm_Usage++;\n\tm_InUsage++;\n\treturn ID;\n}\n\nvoid CSnapIDPool::TimeoutIDs()\n{\n\t// process timed ids\n\twhile(m_FirstTimed != -1)\n\t\tRemoveFirstTimeout();\n}\n\nvoid CSnapIDPool::FreeID(int ID)\n{\n\tif(ID < 0)\n\t\treturn;\n\tdbg_assert(m_aIDs[ID].m_State == 1, \"id is not allocated\");\n\n\tm_InUsage--;\n\tm_aIDs[ID].m_State = 2;\n\tm_aIDs[ID].m_Timeout = time_get()+time_freq()*5;\n\tm_aIDs[ID].m_Next = -1;\n\n\tif(m_LastTimed != -1)\n\t{\n\t\tm_aIDs[m_LastTimed].m_Next = ID;\n\t\tm_LastTimed = ID;\n\t}\n\telse\n\t{\n\t\tm_FirstTimed = ID;\n\t\tm_LastTimed = ID;\n\t}\n}\n\n\nvoid CServerBan::InitServerBan(IConsole *pConsole, IStorage *pStorage, CServer* pServer)\n{\n\tCNetBan::Init(pConsole, pStorage);\n\n\tm_pServer = pServer;\n\n\t// overwrites base command, todo: improve this\n\tConsole()->Register(\"ban\", \"s[id|ip|range] ?i[minutes] r[reason]\", CFGFLAG_SERVER|CFGFLAG_STORE, ConBanExt, this, \"Ban player with IP/IP range/client id for x minutes for any reason\");\n}\n\ntemplate<class T>\nint CServerBan::BanExt(T *pBanPool, const typename T::CDataType *pData, int Seconds, const char *pReason)\n{\n\t// validate address\n\tif(Server()->m_RconClientID >= 0 && Server()->m_RconClientID < MAX_CLIENTS &&\n\t\tServer()->m_aClients[Server()->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)\n\t{\n\t\tif(NetMatch(pData, Server()->m_NetServer.ClientAddr(Server()->m_RconClientID)))\n\t\t{\n\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (you can't ban yourself)\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t{\n\t\t\tif(i == Server()->m_RconClientID || Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\t\tcontinue;\n\n\t\t\tif(Server()->m_aClients[i].m_Authed >= Server()->m_RconAuthLevel && NetMatch(pData, Server()->m_NetServer.ClientAddr(i)))\n\t\t\t{\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (command denied)\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(Server()->m_RconClientID == IServer::RCON_CID_VOTE)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t{\n\t\t\tif(Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\t\tcontinue;\n\n\t\t\tif(Server()->m_aClients[i].m_Authed != CServer::AUTHED_NO && NetMatch(pData, Server()->m_NetServer.ClientAddr(i)))\n\t\t\t{\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (command denied)\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint Result = Ban(pBanPool, pData, Seconds, pReason);\n\tif(Result != 0)\n\t\treturn Result;\n\n\t// drop banned clients\n\ttypename T::CDataType Data = *pData;\n\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t{\n\t\tif(Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\tcontinue;\n\n\t\tif(NetMatch(&Data, Server()->m_NetServer.ClientAddr(i)))\n\t\t{\n\t\t\tCNetHash NetHash(&Data);\n\t\t\tchar aBuf[256];\n\t\t\tMakeBanInfo(pBanPool->Find(&Data, &NetHash), aBuf, sizeof(aBuf), MSGTYPE_PLAYER);\n\t\t\tServer()->m_NetServer.Drop(i, aBuf);\n\t\t}\n\t}\n\n\treturn Result;\n}\n\nint CServerBan::BanAddr(const NETADDR *pAddr, int Seconds, const char *pReason)\n{\n\treturn BanExt(&m_BanAddrPool, pAddr, Seconds, pReason);\n}\n\nint CServerBan::BanRange(const CNetRange *pRange, int Seconds, const char *pReason)\n{\n\tif(pRange->IsValid())\n\t\treturn BanExt(&m_BanRangePool, pRange, Seconds, pReason);\n\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban failed (invalid range)\");\n\treturn -1;\n}\n\nvoid CServerBan::ConBanExt(IConsole::IResult *pResult, void *pUser)\n{\n\tCServerBan *pThis = static_cast<CServerBan *>(pUser);\n\n\tconst char *pStr = pResult->GetString(0);\n\tint Minutes = pResult->NumArguments()>1 ? clamp(pResult->GetInteger(1), 0, 44640) : 30;\n\tconst char *pReason = pResult->NumArguments()>2 ? pResult->GetString(2) : \"No reason given\";\n\n\tif(!str_is_number(pStr))\n\t{\n\t\tint ClientID = str_toint(pStr);\n\t\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || pThis->Server()->m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (invalid client id)\");\n\t\telse\n\t\t\tpThis->BanAddr(pThis->Server()->m_NetServer.ClientAddr(ClientID), Minutes*60, pReason);\n\t}\n\telse\n\t\tConBan(pResult, pUser);\n}\n\n\nvoid CServer::CClient::Reset()\n{\n\t// reset input\n\tfor(int i = 0; i < 200; i++)\n\t\tm_aInputs[i].m_GameTick = -1;\n\tm_CurrentInput = 0;\n\tmem_zero(&m_LatestInput, sizeof(m_LatestInput));\n\n\tm_Snapshots.PurgeAll();\n\tm_LastAckedSnapshot = -1;\n\tm_LastInputTick = -1;\n\tm_SnapRate = CClient::SNAPRATE_INIT;\n\tm_Score = 0;\n\tm_MapChunk = 0;\n}\n\nCServer::CServer() : m_DemoRecorder(&m_SnapshotDelta)\n{\n\tm_TickSpeed = SERVER_TICK_SPEED;\n\n\tm_pGameServer = 0;\n\n\tm_CurrentGameTick = 0;\n\tm_RunServer = 1;\n\n\tm_pCurrentMapData = 0;\n\tm_CurrentMapSize = 0;\n\n\tm_NumMapEntries = 0;\n\tm_pFirstMapEntry = 0;\n\tm_pLastMapEntry = 0;\n\tm_pMapListHeap = 0;\n\n\tm_MapReload = 0;\n\n\tm_RconClientID = IServer::RCON_CID_SERV;\n\tm_RconAuthLevel = AUTHED_ADMIN;\n\n\tm_RconPasswordSet = 0;\n\tm_GeneratedRconPassword = 0;\n\n\tInit();\n}\n\n\nvoid CServer::SetClientName(int ClientID, const char *pName)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY || !pName)\n\t\treturn;\n\n\tconst char *pDefaultName = \"(1)\";\n\tpName = str_utf8_skip_whitespaces(pName);\n\tstr_copy(m_aClients[ClientID].m_aName, *pName ? pName : pDefaultName, MAX_NAME_LENGTH);\n}\n\nvoid CServer::SetClientClan(int ClientID, const char *pClan)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY || !pClan)\n\t\treturn;\n\n\tstr_copy(m_aClients[ClientID].m_aClan, pClan, MAX_CLAN_LENGTH);\n}\n\nvoid CServer::SetClientCountry(int ClientID, int Country)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY)\n\t\treturn;\n\n\tm_aClients[ClientID].m_Country = Country;\n}\n\nvoid CServer::SetClientScore(int ClientID, int Score)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY)\n\t\treturn;\n\tm_aClients[ClientID].m_Score = Score;\n}\n\nvoid CServer::Kick(int ClientID, const char *pReason)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"invalid client id to kick\");\n\t\treturn;\n\t}\n\telse if(m_RconClientID == ClientID)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"you can't kick yourself\");\n \t\treturn;\n\t}\n\telse if(m_aClients[ClientID].m_Authed > m_RconAuthLevel)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"kick command denied\");\n \t\treturn;\n\t}\n\n\tm_NetServer.Drop(ClientID, pReason);\n}\n\n/*int CServer::Tick()\n{\n\treturn m_CurrentGameTick;\n}*/\n\nint64 CServer::TickStartTime(int Tick)\n{\n\treturn m_GameStartTime + (time_freq()*Tick)/SERVER_TICK_SPEED;\n}\n\n/*int CServer::TickSpeed()\n{\n\treturn SERVER_TICK_SPEED;\n}*/\n\nint CServer::Init()\n{\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tm_aClients[i].m_State = CClient::STATE_EMPTY;\n\t\tm_aClients[i].m_aName[0] = 0;\n\t\tm_aClients[i].m_aClan[0] = 0;\n\t\tm_aClients[i].m_Country = -1;\n\t\tm_aClients[i].m_Snapshots.Init();\n\t}\n\n\tm_CurrentGameTick = 0;\n\n\treturn 0;\n}\n\nvoid CServer::SetRconCID(int ClientID)\n{\n\tm_RconClientID = ClientID;\n}\n\nbool CServer::IsAuthed(int ClientID) const\n{\n\treturn m_aClients[ClientID].m_Authed;\n}\n\nbool CServer::IsBanned(int ClientID)\n{\n\treturn m_ServerBan.IsBanned(m_NetServer.ClientAddr(ClientID), 0, 0, 0);\n}\n\nint CServer::GetClientInfo(int ClientID, CClientInfo *pInfo) const\n{\n\tdbg_assert(ClientID >= 0 && ClientID < MAX_CLIENTS, \"client_id is not valid\");\n\tdbg_assert(pInfo != 0, \"info can not be null\");\n\n\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t{\n\t\tpInfo->m_pName = m_aClients[ClientID].m_aName;\n\t\tpInfo->m_Latency = m_aClients[ClientID].m_Latency;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid CServer::GetClientAddr(int ClientID, char *pAddrStr, int Size) const\n{\n\tif(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), pAddrStr, Size, false);\n}\n\nint CServer::GetClientVersion(int ClientID) const\n{\n\tif(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_Version;\n\treturn 0;\n}\n\nconst char *CServer::ClientName(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn \"(invalid)\";\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_aName;\n\telse\n\t\treturn \"(connecting)\";\n\n}\n\nconst char *CServer::ClientClan(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn \"\";\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_aClan;\n\telse\n\t\treturn \"\";\n}\n\nint CServer::ClientCountry(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn -1;\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_Country;\n\telse\n\t\treturn -1;\n}\n\nbool CServer::ClientIngame(int ClientID) const\n{\n\treturn ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME;\n}\n\nvoid CServer::InitRconPasswordIfUnset()\n{\n\tif(m_RconPasswordSet)\n\t{\n\t\treturn;\n\t}\n\n\tstatic const char VALUES[] = \"ABCDEFGHKLMNPRSTUVWXYZabcdefghjkmnopqt23456789\";\n\tstatic const size_t NUM_VALUES = sizeof(VALUES) - 1; // Disregard the '\\0'.\n\tstatic const size_t PASSWORD_LENGTH = 6;\n\tdbg_assert(NUM_VALUES * NUM_VALUES >= 2048, \"need at least 2048 possibilities for 2-character sequences\");\n\t// With 6 characters, we get a password entropy of log(2048) * 6/2 = 33bit.\n\n\tdbg_assert(PASSWORD_LENGTH % 2 == 0, \"need an even password length\");\n\tunsigned short aRandom[PASSWORD_LENGTH / 2];\n\tchar aRandomPassword[PASSWORD_LENGTH+1];\n\taRandomPassword[PASSWORD_LENGTH] = 0;\n\n\tsecure_random_fill(aRandom, sizeof(aRandom));\n\tfor(size_t i = 0; i < PASSWORD_LENGTH / 2; i++)\n\t{\n\t\tunsigned short RandomNumber = aRandom[i] % 2048;\n\t\taRandomPassword[2 * i + 0] = VALUES[RandomNumber / NUM_VALUES];\n\t\taRandomPassword[2 * i + 1] = VALUES[RandomNumber % NUM_VALUES];\n\t}\n\n\tstr_copy(Config()->m_SvRconPassword, aRandomPassword, sizeof(Config()->m_SvRconPassword));\n\tm_GeneratedRconPassword = 1;\n}\n\nint CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\n\t// drop packet to dummy client\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\n\t// write message to demo recorder\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\t// broadcast\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}\n\nvoid CServer::DoSnapshot()\n{\n\tGameServer()->OnPreSnap();\n\n\t// create snapshot for demo recording\n\tif(m_DemoRecorder.IsRecording())\n\t{\n\t\tchar aData[CSnapshot::MAX_SIZE];\n\t\tint SnapshotSize;\n\n\t\t// build snap and possibly add some messages\n\t\tm_SnapshotBuilder.Init();\n\t\tGameServer()->OnSnap(-1);\n\t\tSnapshotSize = m_SnapshotBuilder.Finish(aData);\n\n\t\t// write snapshot\n\t\tm_DemoRecorder.RecordSnapshot(Tick(), aData, SnapshotSize);\n\t}\n\n\t// create snapshots for all clients\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\t// client must be ingame to receive snapshots\n\t\tif(m_aClients[i].m_State != CClient::STATE_INGAME)\n\t\t\tcontinue;\n\n\t\t// this client is trying to recover, don't spam snapshots\n\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_RECOVER && (Tick()%50) != 0)\n\t\t\tcontinue;\n\n\t\t// this client is trying to recover, don't spam snapshots\n\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_INIT && (Tick()%10) != 0)\n\t\t\tcontinue;\n\n\t\t{\n\t\t\tchar aData[CSnapshot::MAX_SIZE];\n\t\t\tCSnapshot *pData = (CSnapshot*)aData;\t// Fix compiler warning for strict-aliasing\n\t\t\tchar aDeltaData[CSnapshot::MAX_SIZE];\n\t\t\tchar aCompData[CSnapshot::MAX_SIZE];\n\t\t\tint SnapshotSize;\n\t\t\tint Crc;\n\t\t\tstatic CSnapshot EmptySnap;\n\t\t\tCSnapshot *pDeltashot = &EmptySnap;\n\t\t\tint DeltashotSize;\n\t\t\tint DeltaTick = -1;\n\t\t\tint DeltaSize;\n\n\t\t\tm_SnapshotBuilder.Init();\n\n\t\t\tGameServer()->OnSnap(i);\n\n\t\t\t// finish snapshot\n\t\t\tSnapshotSize = m_SnapshotBuilder.Finish(pData);\n\t\t\tCrc = pData->Crc();\n\n\t\t\t// remove old snapshos\n\t\t\t// keep 3 seconds worth of snapshots\n\t\t\tm_aClients[i].m_Snapshots.PurgeUntil(m_CurrentGameTick-SERVER_TICK_SPEED*3);\n\n\t\t\t// save it the snapshot\n\t\t\tm_aClients[i].m_Snapshots.Add(m_CurrentGameTick, time_get(), SnapshotSize, pData, 0);\n\n\t\t\t// find snapshot that we can perform delta against\n\t\t\tEmptySnap.Clear();\n\n\t\t\t{\n\t\t\t\tDeltashotSize = m_aClients[i].m_Snapshots.Get(m_aClients[i].m_LastAckedSnapshot, 0, &pDeltashot, 0);\n\t\t\t\tif(DeltashotSize >= 0)\n\t\t\t\t\tDeltaTick = m_aClients[i].m_LastAckedSnapshot;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// no acked package found, force client to recover rate\n\t\t\t\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_FULL)\n\t\t\t\t\t\tm_aClients[i].m_SnapRate = CClient::SNAPRATE_RECOVER;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create delta\n\t\t\tDeltaSize = m_SnapshotDelta.CreateDelta(pDeltashot, pData, aDeltaData);\n\n\t\t\tif(DeltaSize)\n\t\t\t{\n\t\t\t\t// compress it\n\t\t\t\tint SnapshotSize;\n\t\t\t\tconst int MaxSize = MAX_SNAPSHOT_PACKSIZE;\n\t\t\t\tint NumPackets;\n\n\t\t\t\tSnapshotSize = CVariableInt::Compress(aDeltaData, DeltaSize, aCompData, sizeof(aCompData));\n\t\t\t\tNumPackets = (SnapshotSize+MaxSize-1)/MaxSize;\n\n\t\t\t\tfor(int n = 0, Left = SnapshotSize; Left > 0; n++)\n\t\t\t\t{\n\t\t\t\t\tint Chunk = Left < MaxSize ? Left : MaxSize;\n\t\t\t\t\tLeft -= Chunk;\n\n\t\t\t\t\tif(NumPackets == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMsgPacker Msg(NETMSG_SNAPSINGLE, true);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\t\t\tMsg.AddInt(Crc);\n\t\t\t\t\t\tMsg.AddInt(Chunk);\n\t\t\t\t\t\tMsg.AddRaw(&aCompData[n*MaxSize], Chunk);\n\t\t\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCMsgPacker Msg(NETMSG_SNAP, true);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\t\t\tMsg.AddInt(NumPackets);\n\t\t\t\t\t\tMsg.AddInt(n);\n\t\t\t\t\t\tMsg.AddInt(Crc);\n\t\t\t\t\t\tMsg.AddInt(Chunk);\n\t\t\t\t\t\tMsg.AddRaw(&aCompData[n*MaxSize], Chunk);\n\t\t\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCMsgPacker Msg(NETMSG_SNAPEMPTY, true);\n\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tGameServer()->OnPostSnap();\n}\n\n\nint CServer::NewClientCallback(int ClientID, void *pUser)\n{\n\tCServer *pThis = (CServer *)pUser;\n\n\t// Remove non human player on same slot\n\tif(pThis->GameServer()->IsClientBot(ClientID))\n\t{\n\t\tpThis->GameServer()->OnClientDrop(ClientID, \"removing dummy\");\n\t}\n\n\tpThis->m_aClients[ClientID].m_State = CClient::STATE_AUTH;\n\tpThis->m_aClients[ClientID].m_aName[0] = 0;\n\tpThis->m_aClients[ClientID].m_aClan[0] = 0;\n\tpThis->m_aClients[ClientID].m_Country = -1;\n\tpThis->m_aClients[ClientID].m_Authed = AUTHED_NO;\n\tpThis->m_aClients[ClientID].m_AuthTries = 0;\n\tpThis->m_aClients[ClientID].m_pRconCmdToSend = 0;\n\tpThis->m_aClients[ClientID].m_pMapListEntryToSend = 0;\n\tpThis->m_aClients[ClientID].m_NoRconNote = false;\n\tpThis->m_aClients[ClientID].m_Quitting = false;\n\tpThis->m_aClients[ClientID].Reset();\n\n\treturn 0;\n}\n\nint CServer::DelClientCallback(int ClientID, const char *pReason, void *pUser)\n{\n\tCServer *pThis = (CServer *)pUser;\n\n\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\tnet_addr_str(pThis->m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"client dropped. cid=%d addr=%s reason='%s'\", ClientID, aAddrStr, pReason);\n\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\n\t// notify the mod about the drop\n\tif(pThis->m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t{\n\t\tpThis->m_aClients[ClientID].m_Quitting = true;\n\t\tpThis->GameServer()->OnClientDrop(ClientID, pReason);\n\t}\n\n\tpThis->m_aClients[ClientID].m_State = CClient::STATE_EMPTY;\n\tpThis->m_aClients[ClientID].m_aName[0] = 0;\n\tpThis->m_aClients[ClientID].m_aClan[0] = 0;\n\tpThis->m_aClients[ClientID].m_Country = -1;\n\tpThis->m_aClients[ClientID].m_Authed = AUTHED_NO;\n\tpThis->m_aClients[ClientID].m_AuthTries = 0;\n\tpThis->m_aClients[ClientID].m_pRconCmdToSend = 0;\n\tpThis->m_aClients[ClientID].m_pMapListEntryToSend = 0;\n\tpThis->m_aClients[ClientID].m_NoRconNote = false;\n\tpThis->m_aClients[ClientID].m_Quitting = false;\n\tpThis->m_aClients[ClientID].m_Snapshots.PurgeAll();\n\treturn 0;\n}\n\nvoid CServer::SendMap(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAP_CHANGE, true);\n\tMsg.AddString(GetMapName(), 0);\n\tMsg.AddInt(m_CurrentMapCrc);\n\tMsg.AddInt(m_CurrentMapSize);\n\tMsg.AddInt(m_MapChunksPerRequest);\n\tMsg.AddInt(MAP_CHUNK_SIZE);\n\tMsg.AddRaw(&m_CurrentMapSha256, sizeof(m_CurrentMapSha256));\n\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\nvoid CServer::SendConnectionReady(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_CON_READY, true);\n\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\nvoid CServer::SendRconLine(int ClientID, const char *pLine)\n{\n\tCMsgPacker Msg(NETMSG_RCON_LINE, true);\n\tMsg.AddString(pLine, 512);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendRconLineAuthed(const char *pLine, void *pUser, bool Highlighted)\n{\n\tCServer *pThis = (CServer *)pUser;\n\tstatic volatile int ReentryGuard = 0;\n\tint i;\n\n\tif(ReentryGuard) return;\n\tReentryGuard++;\n\n\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(pThis->m_aClients[i].m_State != CClient::STATE_EMPTY && pThis->m_aClients[i].m_Authed >= pThis->m_RconAuthLevel)\n\t\t\tpThis->SendRconLine(i, pLine);\n\t}\n\n\tReentryGuard--;\n}\n\nvoid CServer::SendRconCmdAdd(const IConsole::CCommandInfo *pCommandInfo, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD_ADD, true);\n\tMsg.AddString(pCommandInfo->m_pName, IConsole::TEMPCMD_NAME_LENGTH);\n\tMsg.AddString(pCommandInfo->m_pHelp, IConsole::TEMPCMD_HELP_LENGTH);\n\tMsg.AddString(pCommandInfo->m_pParams, IConsole::TEMPCMD_PARAMS_LENGTH);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendRconCmdRem(const IConsole::CCommandInfo *pCommandInfo, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD_REM, true);\n\tMsg.AddString(pCommandInfo->m_pName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::UpdateClientRconCommands()\n{\n\tfor(int ClientID = Tick() % MAX_RCONCMD_RATIO; ClientID < MAX_CLIENTS; ClientID += MAX_RCONCMD_RATIO)\n\t{\n\t\tif(m_aClients[ClientID].m_State != CClient::STATE_EMPTY && m_aClients[ClientID].m_Authed)\n\t\t{\n\t\t\tint ConsoleAccessLevel = m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD;\n\t\t\tfor(int i = 0; i < MAX_RCONCMD_SEND && m_aClients[ClientID].m_pRconCmdToSend; ++i)\n\t\t\t{\n\t\t\t\tSendRconCmdAdd(m_aClients[ClientID].m_pRconCmdToSend, ClientID);\n\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = m_aClients[ClientID].m_pRconCmdToSend->NextCommandInfo(ConsoleAccessLevel, CFGFLAG_SERVER);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::SendMapListEntryAdd(const CMapListEntry *pMapListEntry, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAPLIST_ENTRY_ADD, true);\n\tMsg.AddString(pMapListEntry->m_aName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendMapListEntryRem(const CMapListEntry *pMapListEntry, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAPLIST_ENTRY_REM, true);\n\tMsg.AddString(pMapListEntry->m_aName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\n\nvoid CServer::UpdateClientMapListEntries()\n{\n\tfor(int ClientID = Tick() % MAX_RCONCMD_RATIO; ClientID < MAX_CLIENTS; ClientID += MAX_RCONCMD_RATIO)\n\t{\n\t\tif(m_aClients[ClientID].m_State != CClient::STATE_EMPTY && m_aClients[ClientID].m_Authed)\n\t\t{\n\t\t\tfor(int i = 0; i < MAX_MAPLISTENTRY_SEND && m_aClients[ClientID].m_pMapListEntryToSend; ++i)\n\t\t\t{\n\t\t\t\tSendMapListEntryAdd(m_aClients[ClientID].m_pMapListEntryToSend, ClientID);\n\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_aClients[ClientID].m_pMapListEntryToSend->m_pNext;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::ProcessClientPacket(CNetChunk *pPacket)\n{\n\tint ClientID = pPacket->m_ClientID;\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif(Msg == NETMSG_INFO)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_AUTH)\n\t\t\t{\n\t\t\t\tconst char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(str_comp(pVersion, GameServer()->NetVersion()) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong version\n\t\t\t\t\tchar aReason[256];\n\t\t\t\t\tstr_format(aReason, sizeof(aReason), \"Wrong version. Server is running '%s' and client '%s'\", GameServer()->NetVersion(), pVersion);\n\t\t\t\t\tm_NetServer.Drop(ClientID, aReason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(Config()->m_Password[0] != 0 && str_comp(Config()->m_Password, pPassword) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong password\n\t\t\t\t\tm_NetServer.Drop(ClientID, \"Wrong password\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tm_aClients[ClientID].m_Version = Unpacker.GetInt();\n\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_CONNECTING;\n\t\t\t\tSendMap(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_REQUEST_MAP_DATA)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))\n\t\t\t{\n\t\t\t\tint ChunkSize = MAP_CHUNK_SIZE;\n\n\t\t\t\t// send map chunks\n\t\t\t\tfor(int i = 0; i < m_MapChunksPerRequest && m_aClients[ClientID].m_MapChunk >= 0; ++i)\n\t\t\t\t{\n\t\t\t\t\tint Chunk = m_aClients[ClientID].m_MapChunk;\n\t\t\t\t\tint Offset = Chunk * ChunkSize;\n\n\t\t\t\t\t// check for last part\n\t\t\t\t\tif(Offset+ChunkSize >= m_CurrentMapSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tChunkSize = m_CurrentMapSize-Offset;\n\t\t\t\t\t\tm_aClients[ClientID].m_MapChunk = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tm_aClients[ClientID].m_MapChunk++;\n\n\t\t\t\t\tCMsgPacker Msg(NETMSG_MAP_DATA, true);\n\t\t\t\t\tMsg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n\n\t\t\t\t\tif(Config()->m_Debug)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar aBuf[64];\n\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"sending chunk %d with size %d\", Chunk, ChunkSize);\n\t\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_READY)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player is ready. ClientID=%d addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\n\t\t\t\tbool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_READY;\n\t\t\t\tGameServer()->OnClientConnected(ClientID, ConnectAsSpec);\n\t\t\t\tSendConnectionReady(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_ENTERGAME)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player has entered the game. ClientID=%d addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_INGAME;\n\t\t\t\tSendServerInfo(ClientID);\n\t\t\t\tGameServer()->OnClientEnter(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_INPUT)\n\t\t{\n\t\t\tCClient::CInput *pInput;\n\t\t\tint64 TagTime;\n\t\t\tint64 Now = time_get();\n\n\t\t\tm_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();\n\t\t\tint IntendedTick = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\n\t\t\t// check for errors\n\t\t\tif(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)\n\t\t\t\treturn;\n\n\t\t\tif(m_aClients[ClientID].m_LastAckedSnapshot > 0)\n\t\t\t\tm_aClients[ClientID].m_SnapRate = CClient::SNAPRATE_FULL;\n\n\t\t\t// add message to report the input timing\n\t\t\t// skip packets that are old\n\t\t\tif(IntendedTick > m_aClients[ClientID].m_LastInputTick)\n\t\t\t{\n\t\t\t\tint TimeLeft = ((TickStartTime(IntendedTick)-Now)*1000) / time_freq();\n\n\t\t\t\tCMsgPacker Msg(NETMSG_INPUTTIMING, true);\n\t\t\t\tMsg.AddInt(IntendedTick);\n\t\t\t\tMsg.AddInt(TimeLeft);\n\t\t\t\tSendMsg(&Msg, 0, ClientID);\n\t\t\t}\n\n\t\t\tm_aClients[ClientID].m_LastInputTick = IntendedTick;\n\n\t\t\tpInput = &m_aClients[ClientID].m_aInputs[m_aClients[ClientID].m_CurrentInput];\n\n\t\t\tif(IntendedTick <= Tick())\n\t\t\t\tIntendedTick = Tick()+1;\n\n\t\t\tpInput->m_GameTick = IntendedTick;\n\n\t\t\tfor(int i = 0; i < Size/4; i++)\n\t\t\t\tpInput->m_aData[i] = Unpacker.GetInt();\n\n\t\t\tint PingCorrection = clamp(Unpacker.GetInt(), 0, 50);\n\t\t\tif(m_aClients[ClientID].m_Snapshots.Get(m_aClients[ClientID].m_LastAckedSnapshot, &TagTime, 0, 0) >= 0)\n\t\t\t{\n\t\t\t\tm_aClients[ClientID].m_Latency = (int)(((Now-TagTime)*1000)/time_freq());\n\t\t\t\tm_aClients[ClientID].m_Latency = max(0, m_aClients[ClientID].m_Latency - PingCorrection);\n\t\t\t}\n\n\t\t\tmem_copy(m_aClients[ClientID].m_LatestInput.m_aData, pInput->m_aData, MAX_INPUT_SIZE*sizeof(int));\n\n\t\t\tm_aClients[ClientID].m_CurrentInput++;\n\t\t\tm_aClients[ClientID].m_CurrentInput %= 200;\n\n\t\t\t// call the mod with the fresh input data\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\t\t\tGameServer()->OnClientDirectInput(ClientID, m_aClients[ClientID].m_LatestInput.m_aData);\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_CMD)\n\t\t{\n\t\t\tconst char *pCmd = Unpacker.GetString();\n\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Unpacker.Error() == 0 && m_aClients[ClientID].m_Authed)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d rcon='%s'\", ClientID, pCmd);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_RconClientID = ClientID;\n\t\t\t\tm_RconAuthLevel = m_aClients[ClientID].m_Authed;\n\t\t\t\tConsole()->SetAccessLevel(m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD);\n\t\t\t\tConsole()->ExecuteLineFlag(pCmd, CFGFLAG_SERVER);\n\t\t\t\tConsole()->SetAccessLevel(IConsole::ACCESS_LEVEL_ADMIN);\n\t\t\t\tm_RconClientID = IServer::RCON_CID_SERV;\n\t\t\t\tm_RconAuthLevel = AUTHED_ADMIN;\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_AUTH)\n\t\t{\n\t\t\tconst char *pPw = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Unpacker.Error() == 0)\n\t\t\t{\n\t\t\t\tif(Config()->m_SvRconPassword[0] == 0 && Config()->m_SvRconModPassword[0] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(!m_aClients[ClientID].m_NoRconNote)\n\t\t\t\t\t{\n\t\t\t\t\t\tSendRconLine(ClientID, \"No rcon password set on server. Set sv_rcon_password and/or sv_rcon_mod_password to enable the remote console.\");\n\t\t\t\t\t\tm_aClients[ClientID].m_NoRconNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconPassword[0] && str_comp(pPw, Config()->m_SvRconPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_ADMIN;\n\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_ADMIN, CFGFLAG_SERVER);\n\t\t\t\t\tif(m_aClients[ClientID].m_Version >= MIN_MAPLIST_CLIENTVERSION)\n\t\t\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_pFirstMapEntry;\n\t\t\t\t\tSendRconLine(ClientID, \"Admin authentication successful. Full remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (admin)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconModPassword[0] && str_comp(pPw, Config()->m_SvRconModPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_MOD;\n\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_MOD, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Moderator authentication successful. Limited remote console access granted.\");\n\t\t\t\t\tconst IConsole::CCommandInfo *pInfo = Console()->GetCommandInfo(\"sv_map\", CFGFLAG_SERVER, false);\n\t\t\t\t\tif(pInfo && pInfo->GetAccessLevel() == IConsole::ACCESS_LEVEL_MOD && m_aClients[ClientID].m_Version >= MIN_MAPLIST_CLIENTVERSION)\n\t\t\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_pFirstMapEntry;\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (moderator)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconMaxTries && m_ServerBan.IsBannable(m_NetServer.ClientAddr(ClientID)))\n\t\t\t\t{\n\t\t\t\t\tm_aClients[ClientID].m_AuthTries++;\n\t\t\t\t\tchar aBuf[128];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"Wrong password %d/%d.\", m_aClients[ClientID].m_AuthTries, Config()->m_SvRconMaxTries);\n\t\t\t\t\tSendRconLine(ClientID, aBuf);\n\t\t\t\t\tif(m_aClients[ClientID].m_AuthTries >= Config()->m_SvRconMaxTries)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Config()->m_SvRconBantime)\n\t\t\t\t\t\t\tm_NetServer.Drop(ClientID, \"Too many remote console authentication tries\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm_ServerBan.BanAddr(m_NetServer.ClientAddr(ClientID), Config()->m_SvRconBantime*60, \"Too many remote console authentication tries\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"Wrong password.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY, true);\n\t\t\tSendMsg(&Msg, 0, ClientID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Config()->m_Debug)\n\t\t\t{\n\t\t\t\tchar aHex[] = \"0123456789ABCDEF\";\n\t\t\t\tchar aBuf[512];\n\n\t\t\t\tfor(int b = 0; b < pPacket->m_DataSize && b < 32; b++)\n\t\t\t\t{\n\t\t\t\t\taBuf[b*3] = aHex[((const unsigned char *)pPacket->m_pData)[b]>>4];\n\t\t\t\t\taBuf[b*3+1] = aHex[((const unsigned char *)pPacket->m_pData)[b]&0xf];\n\t\t\t\t\taBuf[b*3+2] = ' ';\n\t\t\t\t\taBuf[b*3+3] = 0;\n\t\t\t\t}\n\n\t\t\t\tchar aBufMsg[256];\n\t\t\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"strange message ClientID=%d msg=%d data_size=%d\", ClientID, Msg, pPacket->m_DataSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBufMsg);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// game message\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t\t\tGameServer()->OnMessage(Msg, &Unpacker, ClientID);\n\t}\n}\n\nvoid CServer::GenerateServerInfo(CPacker *pPacker, int Token)\n{\n\t// count the players\n\tint PlayerCount = 0, ClientCount = 0;\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t{\n\t\t\tif(GameServer()->IsClientPlayer(i))\n\t\t\t\tPlayerCount++;\n\n\t\t\tClientCount++;\n\t\t}\n\t}\n\n\tif(Token != -1)\n\t{\n\t\tpPacker->Reset();\n\t\tpPacker->AddRaw(SERVERBROWSE_INFO, sizeof(SERVERBROWSE_INFO));\n\t\tpPacker->AddInt(Token);\n\t}\n\n\tpPacker->AddString(GameServer()->Version(), 32);\n\tpPacker->AddString(Config()->m_SvName, 64);\n\tpPacker->AddString(Config()->m_SvHostname, 128);\n\tpPacker->AddString(GetMapName(), 32);\n\n\t// gametype\n\tpPacker->AddString(GameServer()->GameType(), 16);\n\n\t// flags\n\tint Flags = 0;\n\tif(Config()->m_Password[0])  // password set\n\t\tFlags |= SERVERINFO_FLAG_PASSWORD;\n\tif(GameServer()->TimeScore())\n\t\tFlags |= SERVERINFO_FLAG_TIMESCORE;\n\tpPacker->AddInt(Flags);\n\n\tpPacker->AddInt(Config()->m_SvSkillLevel);\t// server skill level\n\tpPacker->AddInt(PlayerCount); // num players\n\tpPacker->AddInt(Config()->m_SvPlayerSlots); // max players\n\tpPacker->AddInt(ClientCount); // num clients\n\tpPacker->AddInt(max(ClientCount, Config()->m_SvMaxClients)); // max clients\n\n\tif(Token != -1)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t\t{\n\t\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t\t{\n\t\t\t\tpPacker->AddString(ClientName(i), MAX_NAME_LENGTH); // client name\n\t\t\t\tpPacker->AddString(ClientClan(i), MAX_CLAN_LENGTH); // client clan\n\t\t\t\tpPacker->AddInt(m_aClients[i].m_Country); // client country\n\t\t\t\tpPacker->AddInt(m_aClients[i].m_Score); // client score\n\t\t\t\tpPacker->AddInt(GameServer()->IsClientPlayer(i)?0:1); // flag spectator=1, bot=2 (player=0)\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::SendServerInfo(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_SERVERINFO, true);\n\tGenerateServerInfo(&Msg, -1);\n\tif(ClientID == -1)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t\t{\n\t\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, i);\n\t\t}\n\t}\n\telse if(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State != CClient::STATE_EMPTY)\n\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\n\nvoid CServer::PumpNetwork()\n{\n\tCNetChunk Packet;\n\tTOKEN ResponseToken;\n\n\tm_NetServer.Update();\n\n\t// process packets\n\twhile(m_NetServer.Recv(&Packet, &ResponseToken))\n\t{\n\t\tif(Packet.m_Flags&NETSENDFLAG_CONNLESS)\n\t\t{\n\t\t\tif(m_Register.RegisterProcessPacket(&Packet, ResponseToken))\n\t\t\t\tcontinue;\n\t\t\tif(Packet.m_DataSize >= int(sizeof(SERVERBROWSE_GETINFO)) &&\n\t\t\t\tmem_comp(Packet.m_pData, SERVERBROWSE_GETINFO, sizeof(SERVERBROWSE_GETINFO)) == 0)\n\t\t\t{\n\t\t\t\tCUnpacker Unpacker;\n\t\t\t\tUnpacker.Reset((unsigned char*)Packet.m_pData+sizeof(SERVERBROWSE_GETINFO), Packet.m_DataSize-sizeof(SERVERBROWSE_GETINFO));\n\t\t\t\tint SrvBrwsToken = Unpacker.GetInt();\n\t\t\t\tif(Unpacker.Error())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCPacker Packer;\n\t\t\t\tCNetChunk Response;\n\n\t\t\t\tGenerateServerInfo(&Packer, SrvBrwsToken);\n\n\t\t\t\tResponse.m_ClientID = -1;\n\t\t\t\tResponse.m_Address = Packet.m_Address;\n\t\t\t\tResponse.m_Flags = NETSENDFLAG_CONNLESS;\n\t\t\t\tResponse.m_pData = Packer.Data();\n\t\t\t\tResponse.m_DataSize = Packer.Size();\n\t\t\t\tm_NetServer.Send(&Response, ResponseToken);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tProcessClientPacket(&Packet);\n\t}\n\n\tm_ServerBan.Update();\n\tm_Econ.Update();\n}\n\nconst char *CServer::GetMapName()\n{\n\t// get the name of the map without his path\n\tchar *pMapShortName = &Config()->m_SvMap[0];\n\tfor(int i = 0; i < str_length(Config()->m_SvMap)-1; i++)\n\t{\n\t\tif(Config()->m_SvMap[i] == '/' || Config()->m_SvMap[i] == '\\\\')\n\t\t\tpMapShortName = &Config()->m_SvMap[i+1];\n\t}\n\treturn pMapShortName;\n}\n\nint CServer::LoadMap(const char *pMapName)\n{\n\tchar aBuf[IO_MAX_PATH_LENGTH];\n\tstr_format(aBuf, sizeof(aBuf), \"maps/%s.map\", pMapName);\n\n\t// check for valid standard map\n\tif(!m_MapChecker.ReadAndValidateMap(Storage(), aBuf, IStorage::TYPE_ALL))\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"mapchecker\", \"invalid standard map\");\n\t\treturn 0;\n\t}\n\n\tif(!m_pMap->Load(aBuf))\n\t\treturn 0;\n\n\t// stop recording when we change map\n\tm_DemoRecorder.Stop();\n\n\t// reinit snapshot ids\n\tm_IDPool.TimeoutIDs();\n\n\t// get the sha256 and crc of the map\n\tm_CurrentMapSha256 = m_pMap->Sha256();\n\tm_CurrentMapCrc = m_pMap->Crc();\n\tchar aSha256[SHA256_MAXSTRSIZE];\n\tsha256_str(m_CurrentMapSha256, aSha256, sizeof(aSha256));\n\tchar aBufMsg[256];\n\tstr_format(aBufMsg, sizeof(aBufMsg), \"%s sha256 is %s\", aBuf, aSha256);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBufMsg);\n\tstr_format(aBufMsg, sizeof(aBufMsg), \"%s crc is %08x\", aBuf, m_CurrentMapCrc);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBufMsg);\n\n\tstr_copy(m_aCurrentMap, pMapName, sizeof(m_aCurrentMap));\n\n\t// load complete map into memory for download\n\t{\n\t\tIOHANDLE File = Storage()->OpenFile(aBuf, IOFLAG_READ, IStorage::TYPE_ALL);\n\t\tm_CurrentMapSize = (int)io_length(File);\n\t\tif(m_pCurrentMapData)\n\t\t\tmem_free(m_pCurrentMapData);\n\t\tm_pCurrentMapData = (unsigned char *)mem_alloc(m_CurrentMapSize, 1);\n\t\tio_read(File, m_pCurrentMapData, m_CurrentMapSize);\n\t\tio_close(File);\n\t}\n\treturn 1;\n}\n\nvoid CServer::InitRegister(CNetServer *pNetServer, IEngineMasterServer *pMasterServer, CConfig *pConfig, IConsole *pConsole)\n{\n\tm_Register.Init(pNetServer, pMasterServer, pConfig, pConsole);\n}\n\nvoid CServer::InitInterfaces(CConfig *pConfig, IConsole *pConsole, IGameServer *pGameServer, IEngineMap *pMap, IStorage *pStorage)\n{\n\tm_pConfig = pConfig;\n\tm_pConsole = pConsole;\n\tm_pGameServer = pGameServer;\n\tm_pMap = pMap;\n\tm_pStorage = pStorage;\n}\n\nint CServer::Run()\n{\n\t//\n\tm_PrintCBIndex = Console()->RegisterPrintCallback(Config()->m_ConsoleOutputLevel, SendRconLineAuthed, this);\n\n\t// list maps\n\tm_pMapListHeap = new CHeap();\n\tCSubdirCallbackUserdata Userdata;\n\tUserdata.m_pServer = this;\n\tstr_copy(Userdata.m_aName, \"\", sizeof(Userdata.m_aName));\n\tm_pStorage->ListDirectory(IStorage::TYPE_ALL, \"maps/\", MapListEntryCallback, &Userdata);\n\n\t// load map\n\tif(!LoadMap(Config()->m_SvMap))\n\t{\n\t\tdbg_msg(\"server\", \"failed to load map. mapname='%s'\", Config()->m_SvMap);\n\t\treturn -1;\n\t}\n\tm_MapChunksPerRequest = Config()->m_SvMapDownloadSpeed;\n\n\t// start server\n\tNETADDR BindAddr;\n\tif(Config()->m_Bindaddr[0] && net_host_lookup(Config()->m_Bindaddr, &BindAddr, NETTYPE_ALL) == 0)\n\t{\n\t\t// sweet!\n\t\tBindAddr.type = NETTYPE_ALL;\n\t\tBindAddr.port = Config()->m_SvPort;\n\t}\n\telse\n\t{\n\t\tmem_zero(&BindAddr, sizeof(BindAddr));\n\t\tBindAddr.type = NETTYPE_ALL;\n\t\tBindAddr.port = Config()->m_SvPort;\n\t}\n\n\tif(!m_NetServer.Open(BindAddr, Config(), Console(), Kernel()->RequestInterface<IEngine>(), &m_ServerBan,\n\t\tConfig()->m_SvMaxClients, Config()->m_SvMaxClientsPerIP, NewClientCallback, DelClientCallback, this))\n\t{\n\t\tdbg_msg(\"server\", \"couldn't open socket. port %d might already be in use\", Config()->m_SvPort);\n\t\treturn -1;\n\t}\n\n\tm_Econ.Init(Config(), Console(), &m_ServerBan);\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"server name is '%s'\", Config()->m_SvName);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\n\tGameServer()->OnInit();\n\tstr_format(aBuf, sizeof(aBuf), \"version %s\", GameServer()->NetVersion());\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\tif(str_comp(GameServer()->NetVersionHashUsed(), GameServer()->NetVersionHashReal()))\n\t{\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"WARNING: netversion hash differs\");\n\t}\n\n\t// process pending commands\n\tm_pConsole->StoreCommands(false);\n\n\tif(m_GeneratedRconPassword)\n\t{\n\t\tdbg_msg(\"server\", \"+-------------------------+\");\n\t\tdbg_msg(\"server\", \"| rcon password: '%s' |\", Config()->m_SvRconPassword);\n\t\tdbg_msg(\"server\", \"+-------------------------+\");\n\t}\n\n\t// start game\n\t{\n\t\tint64 ReportTime = time_get();\n\t\tint ReportInterval = 3;\n\n\t\tm_Lastheartbeat = 0;\n\t\tm_GameStartTime = time_get();\n\n\t\twhile(m_RunServer)\n\t\t{\n\t\t\tint64 t = time_get();\n\t\t\tint NewTicks = 0;\n\n\t\t\t// load new map TODO: don't poll this\n\t\t\tif(str_comp(Config()->m_SvMap, m_aCurrentMap) != 0 || m_MapReload || m_CurrentGameTick >= 0x6FFFFFFF) //\tforce reload to make sure the ticks stay within a valid range\n\t\t\t{\n\t\t\t\tm_MapReload = 0;\n\n\t\t\t\t// load map\n\t\t\t\tif(LoadMap(Config()->m_SvMap))\n\t\t\t\t{\n\t\t\t\t\t// new map loaded\n\t\t\t\t\tbool aSpecs[MAX_CLIENTS];\n\t\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t\t\taSpecs[c] = GameServer()->IsClientSpectator(c);\n\n\t\t\t\t\tGameServer()->OnShutdown();\n\n\t\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_aClients[c].m_State <= CClient::STATE_AUTH)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tSendMap(c);\n\t\t\t\t\t\tm_aClients[c].Reset();\n\t\t\t\t\t\tm_aClients[c].m_State = aSpecs[c] ? CClient::STATE_CONNECTING_AS_SPEC : CClient::STATE_CONNECTING;\n\t\t\t\t\t}\n\n\t\t\t\t\tm_GameStartTime = time_get();\n\t\t\t\t\tm_CurrentGameTick = 0;\n\t\t\t\t\tKernel()->ReregisterInterface(GameServer());\n\t\t\t\t\tGameServer()->OnInit();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"failed to load map. mapname='%s'\", Config()->m_SvMap);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t\tstr_copy(Config()->m_SvMap, m_aCurrentMap, sizeof(Config()->m_SvMap));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(t > TickStartTime(m_CurrentGameTick+1))\n\t\t\t{\n\t\t\t\tm_CurrentGameTick++;\n\t\t\t\tNewTicks++;\n\n\t\t\t\t// apply new input\n\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t{\n\t\t\t\t\tif(m_aClients[c].m_State == CClient::STATE_EMPTY)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int i = 0; i < 200; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_aClients[c].m_aInputs[i].m_GameTick == Tick())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_aClients[c].m_State == CClient::STATE_INGAME)\n\t\t\t\t\t\t\t\tGameServer()->OnClientPredictedInput(c, m_aClients[c].m_aInputs[i].m_aData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tGameServer()->OnTick();\n\t\t\t}\n\n\t\t\t// snap game\n\t\t\tif(NewTicks)\n\t\t\t{\n\t\t\t\tif(Config()->m_SvHighBandwidth || (m_CurrentGameTick%2) == 0)\n\t\t\t\t\tDoSnapshot();\n\n\t\t\t\tUpdateClientRconCommands();\n\t\t\t\tUpdateClientMapListEntries();\n\t\t\t}\n\n\t\t\t// master server stuff\n\t\t\tm_Register.RegisterUpdate(m_NetServer.NetType());\n\n\t\t\tPumpNetwork();\n\n\t\t\tif(ReportTime < time_get())\n\t\t\t{\n\t\t\t\tif(Config()->m_Debug)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\tstatic NETSTATS prev_stats;\n\t\t\t\t\tNETSTATS stats;\n\t\t\t\t\tnetserver_stats(net, &stats);\n\n\t\t\t\t\tperf_next();\n\n\t\t\t\t\tif(config.dbg_pref)\n\t\t\t\t\t\tperf_dump(&rootscope);\n\n\t\t\t\t\tdbg_msg(\"server\", \"send=%8d recv=%8d\",\n\t\t\t\t\t\t(stats.send_bytes - prev_stats.send_bytes)/reportinterval,\n\t\t\t\t\t\t(stats.recv_bytes - prev_stats.recv_bytes)/reportinterval);\n\n\t\t\t\t\tprev_stats = stats;\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\tReportTime += time_freq()*ReportInterval;\n\t\t\t}\n\n\t\t\t// wait for incomming data\n\t\t\tm_NetServer.Wait(5);\n\t\t}\n\t}\n\t// disconnect all clients on shutdown\n\tm_NetServer.Close();\n\tm_Econ.Shutdown();\n\n\tGameServer()->OnShutdown();\n\tm_pMap->Unload();\n\n\tif(m_pCurrentMapData)\n\t{\n\t\tmem_free(m_pCurrentMapData);\n\t\tm_pCurrentMapData = 0;\n\t}\n\tif(m_pMapListHeap)\n\t{\n\t\tdelete m_pMapListHeap;\n\t\tm_pMapListHeap = 0;\n\t}\n\treturn 0;\n}\n\nint CServer::MapListEntryCallback(const char *pFilename, int IsDir, int DirType, void *pUser)\n{\n\tCSubdirCallbackUserdata *pUserdata = (CSubdirCallbackUserdata *)pUser;\n\tCServer *pThis = pUserdata->m_pServer;\n\n\tif(pFilename[0] == '.') // hidden files\n\t\treturn 0;\n\n\tchar aFilename[IO_MAX_PATH_LENGTH];\n\tif(pUserdata->m_aName[0])\n\t\tstr_format(aFilename, sizeof(aFilename), \"%s/%s\", pUserdata->m_aName, pFilename);\n\telse\n\t\tstr_format(aFilename, sizeof(aFilename), \"%s\", pFilename);\n\n\tif(IsDir)\n\t{\n\t\tCSubdirCallbackUserdata Userdata;\n\t\tUserdata.m_pServer = pThis;\n\t\tstr_copy(Userdata.m_aName, aFilename, sizeof(Userdata.m_aName));\n\t\tchar FindPath[IO_MAX_PATH_LENGTH];\n\t\tstr_format(FindPath, sizeof(FindPath), \"maps/%s/\", aFilename);\n\t\tpThis->m_pStorage->ListDirectory(IStorage::TYPE_ALL, FindPath, MapListEntryCallback, &Userdata);\n\t\treturn 0;\n\t}\n\n\tconst char *pSuffix = str_endswith(aFilename, \".map\");\n\tif(!pSuffix) // not ending with .map\n\t{\n\t\t\treturn 0;\n\t}\n\n\tCMapListEntry *pEntry = (CMapListEntry *)pThis->m_pMapListHeap->Allocate(sizeof(CMapListEntry));\n\tpThis->m_NumMapEntries++;\n\tpEntry->m_pNext = 0;\n\tpEntry->m_pPrev = pThis->m_pLastMapEntry;\n\tif(pEntry->m_pPrev)\n\t\tpEntry->m_pPrev->m_pNext = pEntry;\n\tpThis->m_pLastMapEntry = pEntry;\n\tif(!pThis->m_pFirstMapEntry)\n\t\tpThis->m_pFirstMapEntry = pEntry;\n\n\tstr_truncate(pEntry->m_aName, sizeof(pEntry->m_aName), aFilename, pSuffix-aFilename);\n\n\treturn 0;\n}\n\nvoid CServer::ConKick(IConsole::IResult *pResult, void *pUser)\n{\n\tif(pResult->NumArguments() > 1)\n\t{\n\t\tchar aBuf[128];\n\t\tstr_format(aBuf, sizeof(aBuf), \"Kicked (%s)\", pResult->GetString(1));\n\t\t((CServer *)pUser)->Kick(pResult->GetInteger(0), aBuf);\n\t}\n\telse\n\t\t((CServer *)pUser)->Kick(pResult->GetInteger(0), \"Kicked by console\");\n}\n\nvoid CServer::ConStatus(IConsole::IResult *pResult, void *pUser)\n{\n\tchar aBuf[1024];\n\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\tCServer* pThis = static_cast<CServer *>(pUser);\n\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(pThis->m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t{\n\t\t\tnet_addr_str(pThis->m_NetServer.ClientAddr(i), aAddrStr, sizeof(aAddrStr), true);\n\t\t\tif(pThis->m_aClients[i].m_State == CClient::STATE_INGAME)\n\t\t\t{\n\t\t\t\tconst char *pAuthStr = pThis->m_aClients[i].m_Authed == CServer::AUTHED_ADMIN ? \"(Admin)\" :\n\t\t\t\t\t\t\t\t\t\tpThis->m_aClients[i].m_Authed == CServer::AUTHED_MOD ? \"(Mod)\" : \"\";\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"id=%d addr=%s client=%x name='%s' score=%d %s\", i, aAddrStr,\n\t\t\t\t\tpThis->m_aClients[i].m_Version, pThis->m_aClients[i].m_aName, pThis->m_aClients[i].m_Score, pAuthStr);\n\t\t\t}\n\t\t\telse\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"id=%d addr=%s connecting\", i, aAddrStr);\n\t\t\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t}\n\t}\n}\n\nvoid CServer::ConShutdown(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_RunServer = 0;\n}\n\nvoid CServer::DemoRecorder_HandleAutoStart()\n{\n\tif(Config()->m_SvAutoDemoRecord)\n\t{\n\t\tm_DemoRecorder.Stop();\n\t\tchar aFilename[128];\n\t\tchar aDate[20];\n\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s_%s.demo\", \"auto/autorecord\", aDate);\n\t\tm_DemoRecorder.Start(Storage(), m_pConsole, aFilename, GameServer()->NetVersion(), m_aCurrentMap, m_CurrentMapSha256, m_CurrentMapCrc, \"server\");\n\t\tif(Config()->m_SvAutoDemoMax)\n\t\t{\n\t\t\t// clean up auto recorded demos\n\t\t\tCFileCollection AutoDemos;\n\t\t\tAutoDemos.Init(Storage(), \"demos/server\", \"autorecord\", \".demo\", Config()->m_SvAutoDemoMax);\n\t\t}\n\t}\n}\n\nbool CServer::DemoRecorder_IsRecording()\n{\n\treturn m_DemoRecorder.IsRecording();\n}\n\nvoid CServer::ConRecord(IConsole::IResult *pResult, void *pUser)\n{\n\tCServer* pServer = (CServer *)pUser;\n\tchar aFilename[128];\n\tif(pResult->NumArguments())\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s.demo\", pResult->GetString(0));\n\telse\n\t{\n\t\tchar aDate[20];\n\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/demo_%s.demo\", aDate);\n\t}\n\tpServer->m_DemoRecorder.Start(pServer->Storage(), pServer->Console(), aFilename, pServer->GameServer()->NetVersion(), pServer->m_aCurrentMap, pServer->m_CurrentMapSha256, pServer->m_CurrentMapCrc, \"server\");\n}\n\nvoid CServer::ConStopRecord(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_DemoRecorder.Stop();\n}\n\nvoid CServer::ConMapReload(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_MapReload = 1;\n}\n\nvoid CServer::ConLogout(IConsole::IResult *pResult, void *pUser)\n{\n\tCServer *pServer = (CServer *)pUser;\n\n\tif(pServer->m_RconClientID >= 0 && pServer->m_RconClientID < MAX_CLIENTS &&\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)\n\t{\n\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_OFF, true);\n\t\tpServer->SendMsg(&Msg, MSGFLAG_VITAL, pServer->m_RconClientID);\n\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_Authed = AUTHED_NO;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_AuthTries = 0;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_pRconCmdToSend = 0;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_pMapListEntryToSend = 0;\n\t\tpServer->SendRconLine(pServer->m_RconClientID, \"Logout successful.\");\n\t\tchar aBuf[32];\n\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d logged out\", pServer->m_RconClientID);\n\t\tpServer->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t}\n}\n\nvoid CServer::ConchainSpecialInfoupdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tstr_clean_whitespaces(pSelf->Config()->m_SvName);\n\t\tpSelf->SendServerInfo(-1);\n\t}\n}\n\nvoid CServer::ConchainPlayerSlotsUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tif(pSelf->Config()->m_SvMaxClients < pSelf->Config()->m_SvPlayerSlots)\n\t\t\tpSelf->Config()->m_SvPlayerSlots = pSelf->Config()->m_SvMaxClients;\n\t}\n}\n\nvoid CServer::ConchainMaxclientsUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tif(pSelf->Config()->m_SvMaxClients < pSelf->Config()->m_SvPlayerSlots)\n\t\t\tpSelf->Config()->m_SvPlayerSlots = pSelf->Config()->m_SvMaxClients;\n\t\tpSelf->m_NetServer.SetMaxClients(pResult->GetInteger(0));\n\t}\n}\n\nvoid CServer::ConchainMaxclientsperipUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments())\n\t\t((CServer *)pUserData)->m_NetServer.SetMaxClientsPerIP(pResult->GetInteger(0));\n}\n\nvoid CServer::ConchainModCommandUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tif(pResult->NumArguments() == 2)\n\t{\n\t\tCServer *pThis = static_cast<CServer *>(pUserData);\n\t\tconst IConsole::CCommandInfo *pInfo = pThis->Console()->GetCommandInfo(pResult->GetString(0), CFGFLAG_SERVER, false);\n\t\tint OldAccessLevel = 0;\n\t\tif(pInfo)\n\t\t\tOldAccessLevel = pInfo->GetAccessLevel();\n\t\tpfnCallback(pResult, pCallbackUserData);\n\t\tif(pInfo && OldAccessLevel != pInfo->GetAccessLevel())\n\t\t{\n\t\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t\t{\n\t\t\t\tif(pThis->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY || pThis->m_aClients[i].m_Authed != CServer::AUTHED_MOD ||\n\t\t\t\t\t(pThis->m_aClients[i].m_pRconCmdToSend && str_comp(pResult->GetString(0), pThis->m_aClients[i].m_pRconCmdToSend->m_pName) >= 0))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(OldAccessLevel == IConsole::ACCESS_LEVEL_ADMIN)\n\t\t\t\t\tpThis->SendRconCmdAdd(pInfo, i);\n\t\t\t\telse\n\t\t\t\t\tpThis->SendRconCmdRem(pInfo, i);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tpfnCallback(pResult, pCallbackUserData);\n}\n\nvoid CServer::ConchainConsoleOutputLevelUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments() == 1)\n\t{\n\t\tCServer *pThis = static_cast<CServer *>(pUserData);\n\t\tpThis->Console()->SetPrintOutputLevel(pThis->m_PrintCBIndex, pResult->GetInteger(0));\n\t}\n}\n\nvoid CServer::ConchainRconPasswordSet(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments() >= 1)\n\t{\n\t\tstatic_cast<CServer *>(pUserData)->m_RconPasswordSet = 1;\n\t}\n}\n\nvoid CServer::RegisterCommands()\n{\n\t// register console commands\n\tConsole()->Register(\"kick\", \"i[id] ?r[reason]\", CFGFLAG_SERVER, ConKick, this, \"Kick player with specified id for any reason\");\n\tConsole()->Register(\"status\", \"\", CFGFLAG_SERVER, ConStatus, this, \"List players\");\n\tConsole()->Register(\"shutdown\", \"\", CFGFLAG_SERVER, ConShutdown, this, \"Shut down\");\n\tConsole()->Register(\"logout\", \"\", CFGFLAG_SERVER|CFGFLAG_BASICACCESS, ConLogout, this, \"Logout of rcon\");\n\n\tConsole()->Register(\"record\", \"?s[file]\", CFGFLAG_SERVER|CFGFLAG_STORE, ConRecord, this, \"Record to a file\");\n\tConsole()->Register(\"stoprecord\", \"\", CFGFLAG_SERVER, ConStopRecord, this, \"Stop recording\");\n\n\tConsole()->Register(\"reload\", \"\", CFGFLAG_SERVER, ConMapReload, this, \"Reload the map\");\n\n\tConsole()->Chain(\"sv_name\", ConchainSpecialInfoupdate, this);\n\tConsole()->Chain(\"password\", ConchainSpecialInfoupdate, this);\n\n\tConsole()->Chain(\"sv_player_slots\", ConchainPlayerSlotsUpdate, this);\n\tConsole()->Chain(\"sv_max_clients\", ConchainMaxclientsUpdate, this);\n\tConsole()->Chain(\"sv_max_clients\", ConchainSpecialInfoupdate, this);\n\tConsole()->Chain(\"sv_max_clients_per_ip\", ConchainMaxclientsperipUpdate, this);\n\tConsole()->Chain(\"mod_command\", ConchainModCommandUpdate, this);\n\tConsole()->Chain(\"console_output_level\", ConchainConsoleOutputLevelUpdate, this);\n\tConsole()->Chain(\"sv_rcon_password\", ConchainRconPasswordSet, this);\n\n\t// register console commands in sub parts\n\tm_ServerBan.InitServerBan(Console(), Storage(), this);\n\tm_pGameServer->OnConsoleInit();\n}\n\n\nint CServer::SnapNewID()\n{\n\treturn m_IDPool.NewID();\n}\n\nvoid CServer::SnapFreeID(int ID)\n{\n\tm_IDPool.FreeID(ID);\n}\n\n\nvoid *CServer::SnapNewItem(int Type, int ID, int Size)\n{\n\tdbg_assert(Type >= 0 && Type <=0xffff, \"incorrect type\");\n\tdbg_assert(ID >= 0 && ID <=0xffff, \"incorrect id\");\n\treturn ID < 0 ? 0 : m_SnapshotBuilder.NewItem(Type, ID, Size);\n}\n\nvoid CServer::SnapSetStaticsize(int ItemType, int Size)\n{\n\tm_SnapshotDelta.SetStaticsize(ItemType, Size);\n}\n\nstatic CServer *CreateServer() { return new CServer(); }\n\nint main(int argc, const char **argv) // ignore_convention\n{\n#if defined(CONF_FAMILY_WINDOWS)\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-s\", argv[i]) == 0 || str_comp(\"--silent\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tShowWindow(GetConsoleWindow(), SW_HIDE);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\n\tbool UseDefaultConfig = false;\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-d\", argv[i]) == 0 || str_comp(\"--default\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tUseDefaultConfig = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(secure_random_init() != 0)\n\t{\n\t\tdbg_msg(\"secure\", \"could not initialize secure RNG\");\n\t\treturn -1;\n\t}\n\n\tCServer *pServer = CreateServer();\n\tIKernel *pKernel = IKernel::Create();\n\n\t// create the components\n\tint FlagMask = CFGFLAG_SERVER|CFGFLAG_ECON;\n\tIEngine *pEngine = CreateEngine(\"Teeworlds_Server\");\n\tIEngineMap *pEngineMap = CreateEngineMap();\n\tIGameServer *pGameServer = CreateGameServer();\n\tIConsole *pConsole = CreateConsole(CFGFLAG_SERVER|CFGFLAG_ECON);\n\tIEngineMasterServer *pEngineMasterServer = CreateEngineMasterServer();\n\tIStorage *pStorage = CreateStorage(\"Teeworlds\", IStorage::STORAGETYPE_SERVER, argc, argv); // ignore_convention\n\tIConfigManager *pConfigManager = CreateConfigManager();\n\n\tpServer->InitRegister(&pServer->m_NetServer, pEngineMasterServer, pConfigManager->Values(), pConsole);\n\n\t{\n\t\tbool RegisterFail = false;\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pServer); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pEngine);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMap*>(pEngineMap)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMap*>(pEngineMap));\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pGameServer);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConsole);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pStorage);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConfigManager);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMasterServer*>(pEngineMasterServer)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMasterServer*>(pEngineMasterServer));\n\n\t\tif(RegisterFail)\n\t\t\treturn -1;\n\t}\n\n\tpEngine->Init();\n\tpConfigManager->Init(FlagMask);\n\tpConsole->Init();\n\tpEngineMasterServer->Init();\n\tpEngineMasterServer->Load();\n\n\tpServer->InitInterfaces(pConfigManager->Values(), pConsole, pGameServer, pEngineMap, pStorage);\n\tif(!UseDefaultConfig)\n\t{\n\t\t// register all console commands\n\t\tpServer->RegisterCommands();\n\n\t\t// execute autoexec file\n\t\tpConsole->ExecuteFile(\"autoexec.cfg\");\n\n\t\t// parse the command line arguments\n\t\tif(argc > 1) // ignore_convention\n\t\t\tpConsole->ParseArguments(argc-1, &argv[1]); // ignore_convention\n\t}\n\n\t// restore empty config strings to their defaults\n\tpConfigManager->RestoreStrings();\n\n\tpEngine->InitLogfile();\n\n\tpServer->InitRconPasswordIfUnset();\n\n\t// run the server\n\tdbg_msg(\"server\", \"starting...\");\n\tint Ret = pServer->Run();\n\n\t// free\n\tdelete pServer;\n\tdelete pKernel;\n\tdelete pEngine;\n\tdelete pEngineMap;\n\tdelete pGameServer;\n\tdelete pConsole;\n\tdelete pEngineMasterServer;\n\tdelete pStorage;\n\tdelete pConfigManager;\n\n\treturn Ret;\n}\n"], "fixing_code": ["/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n\n#include <base/math.h>\n#include <base/system.h>\n\n#include <engine/config.h>\n#include <engine/console.h>\n#include <engine/engine.h>\n#include <engine/map.h>\n#include <engine/masterserver.h>\n#include <engine/server.h>\n#include <engine/storage.h>\n\n#include <engine/shared/compression.h>\n#include <engine/shared/config.h>\n#include <engine/shared/datafile.h>\n#include <engine/shared/demo.h>\n#include <engine/shared/econ.h>\n#include <engine/shared/filecollection.h>\n#include <engine/shared/mapchecker.h>\n#include <engine/shared/netban.h>\n#include <engine/shared/network.h>\n#include <engine/shared/packer.h>\n#include <engine/shared/protocol.h>\n#include <engine/shared/snapshot.h>\n\n#include <mastersrv/mastersrv.h>\n\n#include \"register.h\"\n#include \"server.h\"\n\n#if defined(CONF_FAMILY_WINDOWS)\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n#endif\n\n/*static const char *StrLtrim(const char *pStr)\n{\n\twhile(*pStr && *pStr >= 0 && *pStr <= 32)\n\t\tpStr++;\n\treturn pStr;\n}\n\nstatic void StrRtrim(char *pStr)\n{\n\tint i = str_length(pStr);\n\twhile(i >= 0)\n\t{\n\t\tif(pStr[i] < 0 || pStr[i] > 32)\n\t\t\tbreak;\n\t\tpStr[i] = 0;\n\t\ti--;\n\t}\n}*/\n\n\nCSnapIDPool::CSnapIDPool()\n{\n\tReset();\n}\n\nvoid CSnapIDPool::Reset()\n{\n\tfor(int i = 0; i < MAX_IDS; i++)\n\t{\n\t\tm_aIDs[i].m_Next = i+1;\n\t\tm_aIDs[i].m_State = 0;\n\t}\n\n\tm_aIDs[MAX_IDS-1].m_Next = -1;\n\tm_FirstFree = 0;\n\tm_FirstTimed = -1;\n\tm_LastTimed = -1;\n\tm_Usage = 0;\n\tm_InUsage = 0;\n}\n\n\nvoid CSnapIDPool::RemoveFirstTimeout()\n{\n\tint NextTimed = m_aIDs[m_FirstTimed].m_Next;\n\n\t// add it to the free list\n\tm_aIDs[m_FirstTimed].m_Next = m_FirstFree;\n\tm_aIDs[m_FirstTimed].m_State = 0;\n\tm_FirstFree = m_FirstTimed;\n\n\t// remove it from the timed list\n\tm_FirstTimed = NextTimed;\n\tif(m_FirstTimed == -1)\n\t\tm_LastTimed = -1;\n\n\tm_Usage--;\n}\n\nint CSnapIDPool::NewID()\n{\n\tint64 Now = time_get();\n\n\t// process timed ids\n\twhile(m_FirstTimed != -1 && m_aIDs[m_FirstTimed].m_Timeout < Now)\n\t\tRemoveFirstTimeout();\n\n\tint ID = m_FirstFree;\n\tdbg_assert(ID != -1, \"id error\");\n\tif(ID == -1)\n\t\treturn ID;\n\tm_FirstFree = m_aIDs[m_FirstFree].m_Next;\n\tm_aIDs[ID].m_State = 1;\n\tm_Usage++;\n\tm_InUsage++;\n\treturn ID;\n}\n\nvoid CSnapIDPool::TimeoutIDs()\n{\n\t// process timed ids\n\twhile(m_FirstTimed != -1)\n\t\tRemoveFirstTimeout();\n}\n\nvoid CSnapIDPool::FreeID(int ID)\n{\n\tif(ID < 0)\n\t\treturn;\n\tdbg_assert(m_aIDs[ID].m_State == 1, \"id is not allocated\");\n\n\tm_InUsage--;\n\tm_aIDs[ID].m_State = 2;\n\tm_aIDs[ID].m_Timeout = time_get()+time_freq()*5;\n\tm_aIDs[ID].m_Next = -1;\n\n\tif(m_LastTimed != -1)\n\t{\n\t\tm_aIDs[m_LastTimed].m_Next = ID;\n\t\tm_LastTimed = ID;\n\t}\n\telse\n\t{\n\t\tm_FirstTimed = ID;\n\t\tm_LastTimed = ID;\n\t}\n}\n\n\nvoid CServerBan::InitServerBan(IConsole *pConsole, IStorage *pStorage, CServer* pServer)\n{\n\tCNetBan::Init(pConsole, pStorage);\n\n\tm_pServer = pServer;\n\n\t// overwrites base command, todo: improve this\n\tConsole()->Register(\"ban\", \"s[id|ip|range] ?i[minutes] r[reason]\", CFGFLAG_SERVER|CFGFLAG_STORE, ConBanExt, this, \"Ban player with IP/IP range/client id for x minutes for any reason\");\n}\n\ntemplate<class T>\nint CServerBan::BanExt(T *pBanPool, const typename T::CDataType *pData, int Seconds, const char *pReason)\n{\n\t// validate address\n\tif(Server()->m_RconClientID >= 0 && Server()->m_RconClientID < MAX_CLIENTS &&\n\t\tServer()->m_aClients[Server()->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)\n\t{\n\t\tif(NetMatch(pData, Server()->m_NetServer.ClientAddr(Server()->m_RconClientID)))\n\t\t{\n\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (you can't ban yourself)\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t{\n\t\t\tif(i == Server()->m_RconClientID || Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\t\tcontinue;\n\n\t\t\tif(Server()->m_aClients[i].m_Authed >= Server()->m_RconAuthLevel && NetMatch(pData, Server()->m_NetServer.ClientAddr(i)))\n\t\t\t{\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (command denied)\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(Server()->m_RconClientID == IServer::RCON_CID_VOTE)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t{\n\t\t\tif(Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\t\tcontinue;\n\n\t\t\tif(Server()->m_aClients[i].m_Authed != CServer::AUTHED_NO && NetMatch(pData, Server()->m_NetServer.ClientAddr(i)))\n\t\t\t{\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (command denied)\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint Result = Ban(pBanPool, pData, Seconds, pReason);\n\tif(Result != 0)\n\t\treturn Result;\n\n\t// drop banned clients\n\ttypename T::CDataType Data = *pData;\n\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t{\n\t\tif(Server()->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\tcontinue;\n\n\t\tif(NetMatch(&Data, Server()->m_NetServer.ClientAddr(i)))\n\t\t{\n\t\t\tCNetHash NetHash(&Data);\n\t\t\tchar aBuf[256];\n\t\t\tMakeBanInfo(pBanPool->Find(&Data, &NetHash), aBuf, sizeof(aBuf), MSGTYPE_PLAYER);\n\t\t\tServer()->m_NetServer.Drop(i, aBuf);\n\t\t}\n\t}\n\n\treturn Result;\n}\n\nint CServerBan::BanAddr(const NETADDR *pAddr, int Seconds, const char *pReason)\n{\n\treturn BanExt(&m_BanAddrPool, pAddr, Seconds, pReason);\n}\n\nint CServerBan::BanRange(const CNetRange *pRange, int Seconds, const char *pReason)\n{\n\tif(pRange->IsValid())\n\t\treturn BanExt(&m_BanRangePool, pRange, Seconds, pReason);\n\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban failed (invalid range)\");\n\treturn -1;\n}\n\nvoid CServerBan::ConBanExt(IConsole::IResult *pResult, void *pUser)\n{\n\tCServerBan *pThis = static_cast<CServerBan *>(pUser);\n\n\tconst char *pStr = pResult->GetString(0);\n\tint Minutes = pResult->NumArguments()>1 ? clamp(pResult->GetInteger(1), 0, 44640) : 30;\n\tconst char *pReason = pResult->NumArguments()>2 ? pResult->GetString(2) : \"No reason given\";\n\n\tif(!str_is_number(pStr))\n\t{\n\t\tint ClientID = str_toint(pStr);\n\t\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || pThis->Server()->m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\t\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"net_ban\", \"ban error (invalid client id)\");\n\t\telse\n\t\t\tpThis->BanAddr(pThis->Server()->m_NetServer.ClientAddr(ClientID), Minutes*60, pReason);\n\t}\n\telse\n\t\tConBan(pResult, pUser);\n}\n\n\nvoid CServer::CClient::Reset()\n{\n\t// reset input\n\tfor(int i = 0; i < 200; i++)\n\t\tm_aInputs[i].m_GameTick = -1;\n\tm_CurrentInput = 0;\n\tmem_zero(&m_LatestInput, sizeof(m_LatestInput));\n\n\tm_Snapshots.PurgeAll();\n\tm_LastAckedSnapshot = -1;\n\tm_LastInputTick = -1;\n\tm_SnapRate = CClient::SNAPRATE_INIT;\n\tm_Score = 0;\n\tm_MapChunk = 0;\n}\n\nCServer::CServer() : m_DemoRecorder(&m_SnapshotDelta)\n{\n\tm_TickSpeed = SERVER_TICK_SPEED;\n\n\tm_pGameServer = 0;\n\n\tm_CurrentGameTick = 0;\n\tm_RunServer = 1;\n\n\tm_pCurrentMapData = 0;\n\tm_CurrentMapSize = 0;\n\n\tm_NumMapEntries = 0;\n\tm_pFirstMapEntry = 0;\n\tm_pLastMapEntry = 0;\n\tm_pMapListHeap = 0;\n\n\tm_MapReload = 0;\n\n\tm_RconClientID = IServer::RCON_CID_SERV;\n\tm_RconAuthLevel = AUTHED_ADMIN;\n\n\tm_RconPasswordSet = 0;\n\tm_GeneratedRconPassword = 0;\n\n\tInit();\n}\n\n\nvoid CServer::SetClientName(int ClientID, const char *pName)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY || !pName)\n\t\treturn;\n\n\tconst char *pDefaultName = \"(1)\";\n\tpName = str_utf8_skip_whitespaces(pName);\n\tstr_copy(m_aClients[ClientID].m_aName, *pName ? pName : pDefaultName, MAX_NAME_LENGTH);\n}\n\nvoid CServer::SetClientClan(int ClientID, const char *pClan)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY || !pClan)\n\t\treturn;\n\n\tstr_copy(m_aClients[ClientID].m_aClan, pClan, MAX_CLAN_LENGTH);\n}\n\nvoid CServer::SetClientCountry(int ClientID, int Country)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY)\n\t\treturn;\n\n\tm_aClients[ClientID].m_Country = Country;\n}\n\nvoid CServer::SetClientScore(int ClientID, int Score)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State < CClient::STATE_READY)\n\t\treturn;\n\tm_aClients[ClientID].m_Score = Score;\n}\n\nvoid CServer::Kick(int ClientID, const char *pReason)\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"invalid client id to kick\");\n\t\treturn;\n\t}\n\telse if(m_RconClientID == ClientID)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"you can't kick yourself\");\n \t\treturn;\n\t}\n\telse if(m_aClients[ClientID].m_Authed > m_RconAuthLevel)\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"kick command denied\");\n \t\treturn;\n\t}\n\n\tm_NetServer.Drop(ClientID, pReason);\n}\n\n/*int CServer::Tick()\n{\n\treturn m_CurrentGameTick;\n}*/\n\nint64 CServer::TickStartTime(int Tick)\n{\n\treturn m_GameStartTime + (time_freq()*Tick)/SERVER_TICK_SPEED;\n}\n\n/*int CServer::TickSpeed()\n{\n\treturn SERVER_TICK_SPEED;\n}*/\n\nint CServer::Init()\n{\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tm_aClients[i].m_State = CClient::STATE_EMPTY;\n\t\tm_aClients[i].m_aName[0] = 0;\n\t\tm_aClients[i].m_aClan[0] = 0;\n\t\tm_aClients[i].m_Country = -1;\n\t\tm_aClients[i].m_Snapshots.Init();\n\t}\n\n\tm_CurrentGameTick = 0;\n\n\treturn 0;\n}\n\nvoid CServer::SetRconCID(int ClientID)\n{\n\tm_RconClientID = ClientID;\n}\n\nbool CServer::IsAuthed(int ClientID) const\n{\n\treturn m_aClients[ClientID].m_Authed;\n}\n\nbool CServer::IsBanned(int ClientID)\n{\n\treturn m_ServerBan.IsBanned(m_NetServer.ClientAddr(ClientID), 0, 0, 0);\n}\n\nint CServer::GetClientInfo(int ClientID, CClientInfo *pInfo) const\n{\n\tdbg_assert(ClientID >= 0 && ClientID < MAX_CLIENTS, \"client_id is not valid\");\n\tdbg_assert(pInfo != 0, \"info can not be null\");\n\n\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t{\n\t\tpInfo->m_pName = m_aClients[ClientID].m_aName;\n\t\tpInfo->m_Latency = m_aClients[ClientID].m_Latency;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid CServer::GetClientAddr(int ClientID, char *pAddrStr, int Size) const\n{\n\tif(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), pAddrStr, Size, false);\n}\n\nint CServer::GetClientVersion(int ClientID) const\n{\n\tif(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_Version;\n\treturn 0;\n}\n\nconst char *CServer::ClientName(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn \"(invalid)\";\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_aName;\n\telse\n\t\treturn \"(connecting)\";\n\n}\n\nconst char *CServer::ClientClan(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn \"\";\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_aClan;\n\telse\n\t\treturn \"\";\n}\n\nint CServer::ClientCountry(int ClientID) const\n{\n\tif(ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CServer::CClient::STATE_EMPTY)\n\t\treturn -1;\n\tif(m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME)\n\t\treturn m_aClients[ClientID].m_Country;\n\telse\n\t\treturn -1;\n}\n\nbool CServer::ClientIngame(int ClientID) const\n{\n\treturn ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State == CServer::CClient::STATE_INGAME;\n}\n\nvoid CServer::InitRconPasswordIfUnset()\n{\n\tif(m_RconPasswordSet)\n\t{\n\t\treturn;\n\t}\n\n\tstatic const char VALUES[] = \"ABCDEFGHKLMNPRSTUVWXYZabcdefghjkmnopqt23456789\";\n\tstatic const size_t NUM_VALUES = sizeof(VALUES) - 1; // Disregard the '\\0'.\n\tstatic const size_t PASSWORD_LENGTH = 6;\n\tdbg_assert(NUM_VALUES * NUM_VALUES >= 2048, \"need at least 2048 possibilities for 2-character sequences\");\n\t// With 6 characters, we get a password entropy of log(2048) * 6/2 = 33bit.\n\n\tdbg_assert(PASSWORD_LENGTH % 2 == 0, \"need an even password length\");\n\tunsigned short aRandom[PASSWORD_LENGTH / 2];\n\tchar aRandomPassword[PASSWORD_LENGTH+1];\n\taRandomPassword[PASSWORD_LENGTH] = 0;\n\n\tsecure_random_fill(aRandom, sizeof(aRandom));\n\tfor(size_t i = 0; i < PASSWORD_LENGTH / 2; i++)\n\t{\n\t\tunsigned short RandomNumber = aRandom[i] % 2048;\n\t\taRandomPassword[2 * i + 0] = VALUES[RandomNumber / NUM_VALUES];\n\t\taRandomPassword[2 * i + 1] = VALUES[RandomNumber % NUM_VALUES];\n\t}\n\n\tstr_copy(Config()->m_SvRconPassword, aRandomPassword, sizeof(Config()->m_SvRconPassword));\n\tm_GeneratedRconPassword = 1;\n}\n\nint CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\n\t// drop invalid packet\n\tif(ClientID != -1 && (ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY || m_aClients[ClientID].m_Quitting))\n\t\treturn 0;\n\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\n\t// write message to demo recorder\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\t// broadcast\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}\n\nvoid CServer::DoSnapshot()\n{\n\tGameServer()->OnPreSnap();\n\n\t// create snapshot for demo recording\n\tif(m_DemoRecorder.IsRecording())\n\t{\n\t\tchar aData[CSnapshot::MAX_SIZE];\n\t\tint SnapshotSize;\n\n\t\t// build snap and possibly add some messages\n\t\tm_SnapshotBuilder.Init();\n\t\tGameServer()->OnSnap(-1);\n\t\tSnapshotSize = m_SnapshotBuilder.Finish(aData);\n\n\t\t// write snapshot\n\t\tm_DemoRecorder.RecordSnapshot(Tick(), aData, SnapshotSize);\n\t}\n\n\t// create snapshots for all clients\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\t// client must be ingame to receive snapshots\n\t\tif(m_aClients[i].m_State != CClient::STATE_INGAME)\n\t\t\tcontinue;\n\n\t\t// this client is trying to recover, don't spam snapshots\n\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_RECOVER && (Tick()%50) != 0)\n\t\t\tcontinue;\n\n\t\t// this client is trying to recover, don't spam snapshots\n\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_INIT && (Tick()%10) != 0)\n\t\t\tcontinue;\n\n\t\t{\n\t\t\tchar aData[CSnapshot::MAX_SIZE];\n\t\t\tCSnapshot *pData = (CSnapshot*)aData;\t// Fix compiler warning for strict-aliasing\n\t\t\tchar aDeltaData[CSnapshot::MAX_SIZE];\n\t\t\tchar aCompData[CSnapshot::MAX_SIZE];\n\t\t\tint SnapshotSize;\n\t\t\tint Crc;\n\t\t\tstatic CSnapshot EmptySnap;\n\t\t\tCSnapshot *pDeltashot = &EmptySnap;\n\t\t\tint DeltashotSize;\n\t\t\tint DeltaTick = -1;\n\t\t\tint DeltaSize;\n\n\t\t\tm_SnapshotBuilder.Init();\n\n\t\t\tGameServer()->OnSnap(i);\n\n\t\t\t// finish snapshot\n\t\t\tSnapshotSize = m_SnapshotBuilder.Finish(pData);\n\t\t\tCrc = pData->Crc();\n\n\t\t\t// remove old snapshos\n\t\t\t// keep 3 seconds worth of snapshots\n\t\t\tm_aClients[i].m_Snapshots.PurgeUntil(m_CurrentGameTick-SERVER_TICK_SPEED*3);\n\n\t\t\t// save it the snapshot\n\t\t\tm_aClients[i].m_Snapshots.Add(m_CurrentGameTick, time_get(), SnapshotSize, pData, 0);\n\n\t\t\t// find snapshot that we can perform delta against\n\t\t\tEmptySnap.Clear();\n\n\t\t\t{\n\t\t\t\tDeltashotSize = m_aClients[i].m_Snapshots.Get(m_aClients[i].m_LastAckedSnapshot, 0, &pDeltashot, 0);\n\t\t\t\tif(DeltashotSize >= 0)\n\t\t\t\t\tDeltaTick = m_aClients[i].m_LastAckedSnapshot;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// no acked package found, force client to recover rate\n\t\t\t\t\tif(m_aClients[i].m_SnapRate == CClient::SNAPRATE_FULL)\n\t\t\t\t\t\tm_aClients[i].m_SnapRate = CClient::SNAPRATE_RECOVER;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create delta\n\t\t\tDeltaSize = m_SnapshotDelta.CreateDelta(pDeltashot, pData, aDeltaData);\n\n\t\t\tif(DeltaSize)\n\t\t\t{\n\t\t\t\t// compress it\n\t\t\t\tint SnapshotSize;\n\t\t\t\tconst int MaxSize = MAX_SNAPSHOT_PACKSIZE;\n\t\t\t\tint NumPackets;\n\n\t\t\t\tSnapshotSize = CVariableInt::Compress(aDeltaData, DeltaSize, aCompData, sizeof(aCompData));\n\t\t\t\tNumPackets = (SnapshotSize+MaxSize-1)/MaxSize;\n\n\t\t\t\tfor(int n = 0, Left = SnapshotSize; Left > 0; n++)\n\t\t\t\t{\n\t\t\t\t\tint Chunk = Left < MaxSize ? Left : MaxSize;\n\t\t\t\t\tLeft -= Chunk;\n\n\t\t\t\t\tif(NumPackets == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMsgPacker Msg(NETMSG_SNAPSINGLE, true);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\t\t\tMsg.AddInt(Crc);\n\t\t\t\t\t\tMsg.AddInt(Chunk);\n\t\t\t\t\t\tMsg.AddRaw(&aCompData[n*MaxSize], Chunk);\n\t\t\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCMsgPacker Msg(NETMSG_SNAP, true);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\t\t\tMsg.AddInt(NumPackets);\n\t\t\t\t\t\tMsg.AddInt(n);\n\t\t\t\t\t\tMsg.AddInt(Crc);\n\t\t\t\t\t\tMsg.AddInt(Chunk);\n\t\t\t\t\t\tMsg.AddRaw(&aCompData[n*MaxSize], Chunk);\n\t\t\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCMsgPacker Msg(NETMSG_SNAPEMPTY, true);\n\t\t\t\tMsg.AddInt(m_CurrentGameTick);\n\t\t\t\tMsg.AddInt(m_CurrentGameTick-DeltaTick);\n\t\t\t\tSendMsg(&Msg, MSGFLAG_FLUSH, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tGameServer()->OnPostSnap();\n}\n\n\nint CServer::NewClientCallback(int ClientID, void *pUser)\n{\n\tCServer *pThis = (CServer *)pUser;\n\n\t// Remove non human player on same slot\n\tif(pThis->GameServer()->IsClientBot(ClientID))\n\t{\n\t\tpThis->GameServer()->OnClientDrop(ClientID, \"removing dummy\");\n\t}\n\n\tpThis->m_aClients[ClientID].m_State = CClient::STATE_AUTH;\n\tpThis->m_aClients[ClientID].m_aName[0] = 0;\n\tpThis->m_aClients[ClientID].m_aClan[0] = 0;\n\tpThis->m_aClients[ClientID].m_Country = -1;\n\tpThis->m_aClients[ClientID].m_Authed = AUTHED_NO;\n\tpThis->m_aClients[ClientID].m_AuthTries = 0;\n\tpThis->m_aClients[ClientID].m_pRconCmdToSend = 0;\n\tpThis->m_aClients[ClientID].m_pMapListEntryToSend = 0;\n\tpThis->m_aClients[ClientID].m_NoRconNote = false;\n\tpThis->m_aClients[ClientID].m_Quitting = false;\n\tpThis->m_aClients[ClientID].Reset();\n\n\treturn 0;\n}\n\nint CServer::DelClientCallback(int ClientID, const char *pReason, void *pUser)\n{\n\tCServer *pThis = (CServer *)pUser;\n\n\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\tnet_addr_str(pThis->m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"client dropped. cid=%d addr=%s reason='%s'\", ClientID, aAddrStr, pReason);\n\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\n\t// notify the mod about the drop\n\tif(pThis->m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t{\n\t\tpThis->m_aClients[ClientID].m_Quitting = true;\n\t\tpThis->GameServer()->OnClientDrop(ClientID, pReason);\n\t}\n\n\tpThis->m_aClients[ClientID].m_State = CClient::STATE_EMPTY;\n\tpThis->m_aClients[ClientID].m_aName[0] = 0;\n\tpThis->m_aClients[ClientID].m_aClan[0] = 0;\n\tpThis->m_aClients[ClientID].m_Country = -1;\n\tpThis->m_aClients[ClientID].m_Authed = AUTHED_NO;\n\tpThis->m_aClients[ClientID].m_AuthTries = 0;\n\tpThis->m_aClients[ClientID].m_pRconCmdToSend = 0;\n\tpThis->m_aClients[ClientID].m_pMapListEntryToSend = 0;\n\tpThis->m_aClients[ClientID].m_NoRconNote = false;\n\tpThis->m_aClients[ClientID].m_Quitting = false;\n\tpThis->m_aClients[ClientID].m_Snapshots.PurgeAll();\n\treturn 0;\n}\n\nvoid CServer::SendMap(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAP_CHANGE, true);\n\tMsg.AddString(GetMapName(), 0);\n\tMsg.AddInt(m_CurrentMapCrc);\n\tMsg.AddInt(m_CurrentMapSize);\n\tMsg.AddInt(m_MapChunksPerRequest);\n\tMsg.AddInt(MAP_CHUNK_SIZE);\n\tMsg.AddRaw(&m_CurrentMapSha256, sizeof(m_CurrentMapSha256));\n\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\nvoid CServer::SendConnectionReady(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_CON_READY, true);\n\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\nvoid CServer::SendRconLine(int ClientID, const char *pLine)\n{\n\tCMsgPacker Msg(NETMSG_RCON_LINE, true);\n\tMsg.AddString(pLine, 512);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendRconLineAuthed(const char *pLine, void *pUser, bool Highlighted)\n{\n\tCServer *pThis = (CServer *)pUser;\n\tstatic volatile int ReentryGuard = 0;\n\tint i;\n\n\tif(ReentryGuard) return;\n\tReentryGuard++;\n\n\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(pThis->m_aClients[i].m_State != CClient::STATE_EMPTY && pThis->m_aClients[i].m_Authed >= pThis->m_RconAuthLevel)\n\t\t\tpThis->SendRconLine(i, pLine);\n\t}\n\n\tReentryGuard--;\n}\n\nvoid CServer::SendRconCmdAdd(const IConsole::CCommandInfo *pCommandInfo, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD_ADD, true);\n\tMsg.AddString(pCommandInfo->m_pName, IConsole::TEMPCMD_NAME_LENGTH);\n\tMsg.AddString(pCommandInfo->m_pHelp, IConsole::TEMPCMD_HELP_LENGTH);\n\tMsg.AddString(pCommandInfo->m_pParams, IConsole::TEMPCMD_PARAMS_LENGTH);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendRconCmdRem(const IConsole::CCommandInfo *pCommandInfo, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD_REM, true);\n\tMsg.AddString(pCommandInfo->m_pName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::UpdateClientRconCommands()\n{\n\tfor(int ClientID = Tick() % MAX_RCONCMD_RATIO; ClientID < MAX_CLIENTS; ClientID += MAX_RCONCMD_RATIO)\n\t{\n\t\tif(m_aClients[ClientID].m_State != CClient::STATE_EMPTY && m_aClients[ClientID].m_Authed)\n\t\t{\n\t\t\tint ConsoleAccessLevel = m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD;\n\t\t\tfor(int i = 0; i < MAX_RCONCMD_SEND && m_aClients[ClientID].m_pRconCmdToSend; ++i)\n\t\t\t{\n\t\t\t\tSendRconCmdAdd(m_aClients[ClientID].m_pRconCmdToSend, ClientID);\n\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = m_aClients[ClientID].m_pRconCmdToSend->NextCommandInfo(ConsoleAccessLevel, CFGFLAG_SERVER);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::SendMapListEntryAdd(const CMapListEntry *pMapListEntry, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAPLIST_ENTRY_ADD, true);\n\tMsg.AddString(pMapListEntry->m_aName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\nvoid CServer::SendMapListEntryRem(const CMapListEntry *pMapListEntry, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_MAPLIST_ENTRY_REM, true);\n\tMsg.AddString(pMapListEntry->m_aName, 256);\n\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n}\n\n\nvoid CServer::UpdateClientMapListEntries()\n{\n\tfor(int ClientID = Tick() % MAX_RCONCMD_RATIO; ClientID < MAX_CLIENTS; ClientID += MAX_RCONCMD_RATIO)\n\t{\n\t\tif(m_aClients[ClientID].m_State != CClient::STATE_EMPTY && m_aClients[ClientID].m_Authed)\n\t\t{\n\t\t\tfor(int i = 0; i < MAX_MAPLISTENTRY_SEND && m_aClients[ClientID].m_pMapListEntryToSend; ++i)\n\t\t\t{\n\t\t\t\tSendMapListEntryAdd(m_aClients[ClientID].m_pMapListEntryToSend, ClientID);\n\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_aClients[ClientID].m_pMapListEntryToSend->m_pNext;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::ProcessClientPacket(CNetChunk *pPacket)\n{\n\tint ClientID = pPacket->m_ClientID;\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif(Msg == NETMSG_INFO)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_AUTH)\n\t\t\t{\n\t\t\t\tconst char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(str_comp(pVersion, GameServer()->NetVersion()) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong version\n\t\t\t\t\tchar aReason[256];\n\t\t\t\t\tstr_format(aReason, sizeof(aReason), \"Wrong version. Server is running '%s' and client '%s'\", GameServer()->NetVersion(), pVersion);\n\t\t\t\t\tm_NetServer.Drop(ClientID, aReason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(Config()->m_Password[0] != 0 && str_comp(Config()->m_Password, pPassword) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong password\n\t\t\t\t\tm_NetServer.Drop(ClientID, \"Wrong password\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tm_aClients[ClientID].m_Version = Unpacker.GetInt();\n\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_CONNECTING;\n\t\t\t\tSendMap(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_REQUEST_MAP_DATA)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))\n\t\t\t{\n\t\t\t\tint ChunkSize = MAP_CHUNK_SIZE;\n\n\t\t\t\t// send map chunks\n\t\t\t\tfor(int i = 0; i < m_MapChunksPerRequest && m_aClients[ClientID].m_MapChunk >= 0; ++i)\n\t\t\t\t{\n\t\t\t\t\tint Chunk = m_aClients[ClientID].m_MapChunk;\n\t\t\t\t\tint Offset = Chunk * ChunkSize;\n\n\t\t\t\t\t// check for last part\n\t\t\t\t\tif(Offset+ChunkSize >= m_CurrentMapSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tChunkSize = m_CurrentMapSize-Offset;\n\t\t\t\t\t\tm_aClients[ClientID].m_MapChunk = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tm_aClients[ClientID].m_MapChunk++;\n\n\t\t\t\t\tCMsgPacker Msg(NETMSG_MAP_DATA, true);\n\t\t\t\t\tMsg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n\n\t\t\t\t\tif(Config()->m_Debug)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar aBuf[64];\n\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"sending chunk %d with size %d\", Chunk, ChunkSize);\n\t\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_READY)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player is ready. ClientID=%d addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\n\t\t\t\tbool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_READY;\n\t\t\t\tGameServer()->OnClientConnected(ClientID, ConnectAsSpec);\n\t\t\t\tSendConnectionReady(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_ENTERGAME)\n\t\t{\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player has entered the game. ClientID=%d addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_INGAME;\n\t\t\t\tSendServerInfo(ClientID);\n\t\t\t\tGameServer()->OnClientEnter(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_INPUT)\n\t\t{\n\t\t\tCClient::CInput *pInput;\n\t\t\tint64 TagTime;\n\t\t\tint64 Now = time_get();\n\n\t\t\tm_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();\n\t\t\tint IntendedTick = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\n\t\t\t// check for errors\n\t\t\tif(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)\n\t\t\t\treturn;\n\n\t\t\tif(m_aClients[ClientID].m_LastAckedSnapshot > 0)\n\t\t\t\tm_aClients[ClientID].m_SnapRate = CClient::SNAPRATE_FULL;\n\n\t\t\t// add message to report the input timing\n\t\t\t// skip packets that are old\n\t\t\tif(IntendedTick > m_aClients[ClientID].m_LastInputTick)\n\t\t\t{\n\t\t\t\tint TimeLeft = ((TickStartTime(IntendedTick)-Now)*1000) / time_freq();\n\n\t\t\t\tCMsgPacker Msg(NETMSG_INPUTTIMING, true);\n\t\t\t\tMsg.AddInt(IntendedTick);\n\t\t\t\tMsg.AddInt(TimeLeft);\n\t\t\t\tSendMsg(&Msg, 0, ClientID);\n\t\t\t}\n\n\t\t\tm_aClients[ClientID].m_LastInputTick = IntendedTick;\n\n\t\t\tpInput = &m_aClients[ClientID].m_aInputs[m_aClients[ClientID].m_CurrentInput];\n\n\t\t\tif(IntendedTick <= Tick())\n\t\t\t\tIntendedTick = Tick()+1;\n\n\t\t\tpInput->m_GameTick = IntendedTick;\n\n\t\t\tfor(int i = 0; i < Size/4; i++)\n\t\t\t\tpInput->m_aData[i] = Unpacker.GetInt();\n\n\t\t\tint PingCorrection = clamp(Unpacker.GetInt(), 0, 50);\n\t\t\tif(m_aClients[ClientID].m_Snapshots.Get(m_aClients[ClientID].m_LastAckedSnapshot, &TagTime, 0, 0) >= 0)\n\t\t\t{\n\t\t\t\tm_aClients[ClientID].m_Latency = (int)(((Now-TagTime)*1000)/time_freq());\n\t\t\t\tm_aClients[ClientID].m_Latency = max(0, m_aClients[ClientID].m_Latency - PingCorrection);\n\t\t\t}\n\n\t\t\tmem_copy(m_aClients[ClientID].m_LatestInput.m_aData, pInput->m_aData, MAX_INPUT_SIZE*sizeof(int));\n\n\t\t\tm_aClients[ClientID].m_CurrentInput++;\n\t\t\tm_aClients[ClientID].m_CurrentInput %= 200;\n\n\t\t\t// call the mod with the fresh input data\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\t\t\tGameServer()->OnClientDirectInput(ClientID, m_aClients[ClientID].m_LatestInput.m_aData);\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_CMD)\n\t\t{\n\t\t\tconst char *pCmd = Unpacker.GetString();\n\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Unpacker.Error() == 0 && m_aClients[ClientID].m_Authed)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d rcon='%s'\", ClientID, pCmd);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_RconClientID = ClientID;\n\t\t\t\tm_RconAuthLevel = m_aClients[ClientID].m_Authed;\n\t\t\t\tConsole()->SetAccessLevel(m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD);\n\t\t\t\tConsole()->ExecuteLineFlag(pCmd, CFGFLAG_SERVER);\n\t\t\t\tConsole()->SetAccessLevel(IConsole::ACCESS_LEVEL_ADMIN);\n\t\t\t\tm_RconClientID = IServer::RCON_CID_SERV;\n\t\t\t\tm_RconAuthLevel = AUTHED_ADMIN;\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_AUTH)\n\t\t{\n\t\t\tconst char *pPw = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\n\t\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Unpacker.Error() == 0)\n\t\t\t{\n\t\t\t\tif(Config()->m_SvRconPassword[0] == 0 && Config()->m_SvRconModPassword[0] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(!m_aClients[ClientID].m_NoRconNote)\n\t\t\t\t\t{\n\t\t\t\t\t\tSendRconLine(ClientID, \"No rcon password set on server. Set sv_rcon_password and/or sv_rcon_mod_password to enable the remote console.\");\n\t\t\t\t\t\tm_aClients[ClientID].m_NoRconNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconPassword[0] && str_comp(pPw, Config()->m_SvRconPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_ADMIN;\n\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_ADMIN, CFGFLAG_SERVER);\n\t\t\t\t\tif(m_aClients[ClientID].m_Version >= MIN_MAPLIST_CLIENTVERSION)\n\t\t\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_pFirstMapEntry;\n\t\t\t\t\tSendRconLine(ClientID, \"Admin authentication successful. Full remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (admin)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconModPassword[0] && str_comp(pPw, Config()->m_SvRconModPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);\n\t\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL, ClientID);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_MOD;\n\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_MOD, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Moderator authentication successful. Limited remote console access granted.\");\n\t\t\t\t\tconst IConsole::CCommandInfo *pInfo = Console()->GetCommandInfo(\"sv_map\", CFGFLAG_SERVER, false);\n\t\t\t\t\tif(pInfo && pInfo->GetAccessLevel() == IConsole::ACCESS_LEVEL_MOD && m_aClients[ClientID].m_Version >= MIN_MAPLIST_CLIENTVERSION)\n\t\t\t\t\t\tm_aClients[ClientID].m_pMapListEntryToSend = m_pFirstMapEntry;\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (moderator)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(Config()->m_SvRconMaxTries && m_ServerBan.IsBannable(m_NetServer.ClientAddr(ClientID)))\n\t\t\t\t{\n\t\t\t\t\tm_aClients[ClientID].m_AuthTries++;\n\t\t\t\t\tchar aBuf[128];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"Wrong password %d/%d.\", m_aClients[ClientID].m_AuthTries, Config()->m_SvRconMaxTries);\n\t\t\t\t\tSendRconLine(ClientID, aBuf);\n\t\t\t\t\tif(m_aClients[ClientID].m_AuthTries >= Config()->m_SvRconMaxTries)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Config()->m_SvRconBantime)\n\t\t\t\t\t\t\tm_NetServer.Drop(ClientID, \"Too many remote console authentication tries\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm_ServerBan.BanAddr(m_NetServer.ClientAddr(ClientID), Config()->m_SvRconBantime*60, \"Too many remote console authentication tries\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"Wrong password.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY, true);\n\t\t\tSendMsg(&Msg, 0, ClientID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Config()->m_Debug)\n\t\t\t{\n\t\t\t\tchar aHex[] = \"0123456789ABCDEF\";\n\t\t\t\tchar aBuf[512];\n\n\t\t\t\tfor(int b = 0; b < pPacket->m_DataSize && b < 32; b++)\n\t\t\t\t{\n\t\t\t\t\taBuf[b*3] = aHex[((const unsigned char *)pPacket->m_pData)[b]>>4];\n\t\t\t\t\taBuf[b*3+1] = aHex[((const unsigned char *)pPacket->m_pData)[b]&0xf];\n\t\t\t\t\taBuf[b*3+2] = ' ';\n\t\t\t\t\taBuf[b*3+3] = 0;\n\t\t\t\t}\n\n\t\t\t\tchar aBufMsg[256];\n\t\t\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"strange message ClientID=%d msg=%d data_size=%d\", ClientID, Msg, pPacket->m_DataSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBufMsg);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// game message\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t\t\tGameServer()->OnMessage(Msg, &Unpacker, ClientID);\n\t}\n}\n\nvoid CServer::GenerateServerInfo(CPacker *pPacker, int Token)\n{\n\t// count the players\n\tint PlayerCount = 0, ClientCount = 0;\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t{\n\t\t\tif(GameServer()->IsClientPlayer(i))\n\t\t\t\tPlayerCount++;\n\n\t\t\tClientCount++;\n\t\t}\n\t}\n\n\tif(Token != -1)\n\t{\n\t\tpPacker->Reset();\n\t\tpPacker->AddRaw(SERVERBROWSE_INFO, sizeof(SERVERBROWSE_INFO));\n\t\tpPacker->AddInt(Token);\n\t}\n\n\tpPacker->AddString(GameServer()->Version(), 32);\n\tpPacker->AddString(Config()->m_SvName, 64);\n\tpPacker->AddString(Config()->m_SvHostname, 128);\n\tpPacker->AddString(GetMapName(), 32);\n\n\t// gametype\n\tpPacker->AddString(GameServer()->GameType(), 16);\n\n\t// flags\n\tint Flags = 0;\n\tif(Config()->m_Password[0])  // password set\n\t\tFlags |= SERVERINFO_FLAG_PASSWORD;\n\tif(GameServer()->TimeScore())\n\t\tFlags |= SERVERINFO_FLAG_TIMESCORE;\n\tpPacker->AddInt(Flags);\n\n\tpPacker->AddInt(Config()->m_SvSkillLevel);\t// server skill level\n\tpPacker->AddInt(PlayerCount); // num players\n\tpPacker->AddInt(Config()->m_SvPlayerSlots); // max players\n\tpPacker->AddInt(ClientCount); // num clients\n\tpPacker->AddInt(max(ClientCount, Config()->m_SvMaxClients)); // max clients\n\n\tif(Token != -1)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t\t{\n\t\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t\t{\n\t\t\t\tpPacker->AddString(ClientName(i), MAX_NAME_LENGTH); // client name\n\t\t\t\tpPacker->AddString(ClientClan(i), MAX_CLAN_LENGTH); // client clan\n\t\t\t\tpPacker->AddInt(m_aClients[i].m_Country); // client country\n\t\t\t\tpPacker->AddInt(m_aClients[i].m_Score); // client score\n\t\t\t\tpPacker->AddInt(GameServer()->IsClientPlayer(i)?0:1); // flag spectator=1, bot=2 (player=0)\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CServer::SendServerInfo(int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_SERVERINFO, true);\n\tGenerateServerInfo(&Msg, -1);\n\tif(ClientID == -1)\n\t{\n\t\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t\t{\n\t\t\tif(m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, i);\n\t\t}\n\t}\n\telse if(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State != CClient::STATE_EMPTY)\n\t\tSendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);\n}\n\n\nvoid CServer::PumpNetwork()\n{\n\tCNetChunk Packet;\n\tTOKEN ResponseToken;\n\n\tm_NetServer.Update();\n\n\t// process packets\n\twhile(m_NetServer.Recv(&Packet, &ResponseToken))\n\t{\n\t\tif(Packet.m_Flags&NETSENDFLAG_CONNLESS)\n\t\t{\n\t\t\tif(m_Register.RegisterProcessPacket(&Packet, ResponseToken))\n\t\t\t\tcontinue;\n\t\t\tif(Packet.m_DataSize >= int(sizeof(SERVERBROWSE_GETINFO)) &&\n\t\t\t\tmem_comp(Packet.m_pData, SERVERBROWSE_GETINFO, sizeof(SERVERBROWSE_GETINFO)) == 0)\n\t\t\t{\n\t\t\t\tCUnpacker Unpacker;\n\t\t\t\tUnpacker.Reset((unsigned char*)Packet.m_pData+sizeof(SERVERBROWSE_GETINFO), Packet.m_DataSize-sizeof(SERVERBROWSE_GETINFO));\n\t\t\t\tint SrvBrwsToken = Unpacker.GetInt();\n\t\t\t\tif(Unpacker.Error())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCPacker Packer;\n\t\t\t\tCNetChunk Response;\n\n\t\t\t\tGenerateServerInfo(&Packer, SrvBrwsToken);\n\n\t\t\t\tResponse.m_ClientID = -1;\n\t\t\t\tResponse.m_Address = Packet.m_Address;\n\t\t\t\tResponse.m_Flags = NETSENDFLAG_CONNLESS;\n\t\t\t\tResponse.m_pData = Packer.Data();\n\t\t\t\tResponse.m_DataSize = Packer.Size();\n\t\t\t\tm_NetServer.Send(&Response, ResponseToken);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tProcessClientPacket(&Packet);\n\t}\n\n\tm_ServerBan.Update();\n\tm_Econ.Update();\n}\n\nconst char *CServer::GetMapName()\n{\n\t// get the name of the map without his path\n\tchar *pMapShortName = &Config()->m_SvMap[0];\n\tfor(int i = 0; i < str_length(Config()->m_SvMap)-1; i++)\n\t{\n\t\tif(Config()->m_SvMap[i] == '/' || Config()->m_SvMap[i] == '\\\\')\n\t\t\tpMapShortName = &Config()->m_SvMap[i+1];\n\t}\n\treturn pMapShortName;\n}\n\nint CServer::LoadMap(const char *pMapName)\n{\n\tchar aBuf[IO_MAX_PATH_LENGTH];\n\tstr_format(aBuf, sizeof(aBuf), \"maps/%s.map\", pMapName);\n\n\t// check for valid standard map\n\tif(!m_MapChecker.ReadAndValidateMap(Storage(), aBuf, IStorage::TYPE_ALL))\n\t{\n\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"mapchecker\", \"invalid standard map\");\n\t\treturn 0;\n\t}\n\n\tif(!m_pMap->Load(aBuf))\n\t\treturn 0;\n\n\t// stop recording when we change map\n\tm_DemoRecorder.Stop();\n\n\t// reinit snapshot ids\n\tm_IDPool.TimeoutIDs();\n\n\t// get the sha256 and crc of the map\n\tm_CurrentMapSha256 = m_pMap->Sha256();\n\tm_CurrentMapCrc = m_pMap->Crc();\n\tchar aSha256[SHA256_MAXSTRSIZE];\n\tsha256_str(m_CurrentMapSha256, aSha256, sizeof(aSha256));\n\tchar aBufMsg[256];\n\tstr_format(aBufMsg, sizeof(aBufMsg), \"%s sha256 is %s\", aBuf, aSha256);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBufMsg);\n\tstr_format(aBufMsg, sizeof(aBufMsg), \"%s crc is %08x\", aBuf, m_CurrentMapCrc);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBufMsg);\n\n\tstr_copy(m_aCurrentMap, pMapName, sizeof(m_aCurrentMap));\n\n\t// load complete map into memory for download\n\t{\n\t\tIOHANDLE File = Storage()->OpenFile(aBuf, IOFLAG_READ, IStorage::TYPE_ALL);\n\t\tm_CurrentMapSize = (int)io_length(File);\n\t\tif(m_pCurrentMapData)\n\t\t\tmem_free(m_pCurrentMapData);\n\t\tm_pCurrentMapData = (unsigned char *)mem_alloc(m_CurrentMapSize, 1);\n\t\tio_read(File, m_pCurrentMapData, m_CurrentMapSize);\n\t\tio_close(File);\n\t}\n\treturn 1;\n}\n\nvoid CServer::InitRegister(CNetServer *pNetServer, IEngineMasterServer *pMasterServer, CConfig *pConfig, IConsole *pConsole)\n{\n\tm_Register.Init(pNetServer, pMasterServer, pConfig, pConsole);\n}\n\nvoid CServer::InitInterfaces(CConfig *pConfig, IConsole *pConsole, IGameServer *pGameServer, IEngineMap *pMap, IStorage *pStorage)\n{\n\tm_pConfig = pConfig;\n\tm_pConsole = pConsole;\n\tm_pGameServer = pGameServer;\n\tm_pMap = pMap;\n\tm_pStorage = pStorage;\n}\n\nint CServer::Run()\n{\n\t//\n\tm_PrintCBIndex = Console()->RegisterPrintCallback(Config()->m_ConsoleOutputLevel, SendRconLineAuthed, this);\n\n\t// list maps\n\tm_pMapListHeap = new CHeap();\n\tCSubdirCallbackUserdata Userdata;\n\tUserdata.m_pServer = this;\n\tstr_copy(Userdata.m_aName, \"\", sizeof(Userdata.m_aName));\n\tm_pStorage->ListDirectory(IStorage::TYPE_ALL, \"maps/\", MapListEntryCallback, &Userdata);\n\n\t// load map\n\tif(!LoadMap(Config()->m_SvMap))\n\t{\n\t\tdbg_msg(\"server\", \"failed to load map. mapname='%s'\", Config()->m_SvMap);\n\t\treturn -1;\n\t}\n\tm_MapChunksPerRequest = Config()->m_SvMapDownloadSpeed;\n\n\t// start server\n\tNETADDR BindAddr;\n\tif(Config()->m_Bindaddr[0] && net_host_lookup(Config()->m_Bindaddr, &BindAddr, NETTYPE_ALL) == 0)\n\t{\n\t\t// sweet!\n\t\tBindAddr.type = NETTYPE_ALL;\n\t\tBindAddr.port = Config()->m_SvPort;\n\t}\n\telse\n\t{\n\t\tmem_zero(&BindAddr, sizeof(BindAddr));\n\t\tBindAddr.type = NETTYPE_ALL;\n\t\tBindAddr.port = Config()->m_SvPort;\n\t}\n\n\tif(!m_NetServer.Open(BindAddr, Config(), Console(), Kernel()->RequestInterface<IEngine>(), &m_ServerBan,\n\t\tConfig()->m_SvMaxClients, Config()->m_SvMaxClientsPerIP, NewClientCallback, DelClientCallback, this))\n\t{\n\t\tdbg_msg(\"server\", \"couldn't open socket. port %d might already be in use\", Config()->m_SvPort);\n\t\treturn -1;\n\t}\n\n\tm_Econ.Init(Config(), Console(), &m_ServerBan);\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"server name is '%s'\", Config()->m_SvName);\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\n\tGameServer()->OnInit();\n\tstr_format(aBuf, sizeof(aBuf), \"version %s\", GameServer()->NetVersion());\n\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\tif(str_comp(GameServer()->NetVersionHashUsed(), GameServer()->NetVersionHashReal()))\n\t{\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", \"WARNING: netversion hash differs\");\n\t}\n\n\t// process pending commands\n\tm_pConsole->StoreCommands(false);\n\n\tif(m_GeneratedRconPassword)\n\t{\n\t\tdbg_msg(\"server\", \"+-------------------------+\");\n\t\tdbg_msg(\"server\", \"| rcon password: '%s' |\", Config()->m_SvRconPassword);\n\t\tdbg_msg(\"server\", \"+-------------------------+\");\n\t}\n\n\t// start game\n\t{\n\t\tint64 ReportTime = time_get();\n\t\tint ReportInterval = 3;\n\n\t\tm_Lastheartbeat = 0;\n\t\tm_GameStartTime = time_get();\n\n\t\twhile(m_RunServer)\n\t\t{\n\t\t\tint64 t = time_get();\n\t\t\tint NewTicks = 0;\n\n\t\t\t// load new map TODO: don't poll this\n\t\t\tif(str_comp(Config()->m_SvMap, m_aCurrentMap) != 0 || m_MapReload || m_CurrentGameTick >= 0x6FFFFFFF) //\tforce reload to make sure the ticks stay within a valid range\n\t\t\t{\n\t\t\t\tm_MapReload = 0;\n\n\t\t\t\t// load map\n\t\t\t\tif(LoadMap(Config()->m_SvMap))\n\t\t\t\t{\n\t\t\t\t\t// new map loaded\n\t\t\t\t\tbool aSpecs[MAX_CLIENTS];\n\t\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t\t\taSpecs[c] = GameServer()->IsClientSpectator(c);\n\n\t\t\t\t\tGameServer()->OnShutdown();\n\n\t\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_aClients[c].m_State <= CClient::STATE_AUTH)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tSendMap(c);\n\t\t\t\t\t\tm_aClients[c].Reset();\n\t\t\t\t\t\tm_aClients[c].m_State = aSpecs[c] ? CClient::STATE_CONNECTING_AS_SPEC : CClient::STATE_CONNECTING;\n\t\t\t\t\t}\n\n\t\t\t\t\tm_GameStartTime = time_get();\n\t\t\t\t\tm_CurrentGameTick = 0;\n\t\t\t\t\tKernel()->ReregisterInterface(GameServer());\n\t\t\t\t\tGameServer()->OnInit();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"failed to load map. mapname='%s'\", Config()->m_SvMap);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t\tstr_copy(Config()->m_SvMap, m_aCurrentMap, sizeof(Config()->m_SvMap));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(t > TickStartTime(m_CurrentGameTick+1))\n\t\t\t{\n\t\t\t\tm_CurrentGameTick++;\n\t\t\t\tNewTicks++;\n\n\t\t\t\t// apply new input\n\t\t\t\tfor(int c = 0; c < MAX_CLIENTS; c++)\n\t\t\t\t{\n\t\t\t\t\tif(m_aClients[c].m_State == CClient::STATE_EMPTY)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int i = 0; i < 200; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_aClients[c].m_aInputs[i].m_GameTick == Tick())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_aClients[c].m_State == CClient::STATE_INGAME)\n\t\t\t\t\t\t\t\tGameServer()->OnClientPredictedInput(c, m_aClients[c].m_aInputs[i].m_aData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tGameServer()->OnTick();\n\t\t\t}\n\n\t\t\t// snap game\n\t\t\tif(NewTicks)\n\t\t\t{\n\t\t\t\tif(Config()->m_SvHighBandwidth || (m_CurrentGameTick%2) == 0)\n\t\t\t\t\tDoSnapshot();\n\n\t\t\t\tUpdateClientRconCommands();\n\t\t\t\tUpdateClientMapListEntries();\n\t\t\t}\n\n\t\t\t// master server stuff\n\t\t\tm_Register.RegisterUpdate(m_NetServer.NetType());\n\n\t\t\tPumpNetwork();\n\n\t\t\tif(ReportTime < time_get())\n\t\t\t{\n\t\t\t\tif(Config()->m_Debug)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\tstatic NETSTATS prev_stats;\n\t\t\t\t\tNETSTATS stats;\n\t\t\t\t\tnetserver_stats(net, &stats);\n\n\t\t\t\t\tperf_next();\n\n\t\t\t\t\tif(config.dbg_pref)\n\t\t\t\t\t\tperf_dump(&rootscope);\n\n\t\t\t\t\tdbg_msg(\"server\", \"send=%8d recv=%8d\",\n\t\t\t\t\t\t(stats.send_bytes - prev_stats.send_bytes)/reportinterval,\n\t\t\t\t\t\t(stats.recv_bytes - prev_stats.recv_bytes)/reportinterval);\n\n\t\t\t\t\tprev_stats = stats;\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\tReportTime += time_freq()*ReportInterval;\n\t\t\t}\n\n\t\t\t// wait for incomming data\n\t\t\tm_NetServer.Wait(5);\n\t\t}\n\t}\n\t// disconnect all clients on shutdown\n\tm_NetServer.Close();\n\tm_Econ.Shutdown();\n\n\tGameServer()->OnShutdown();\n\tm_pMap->Unload();\n\n\tif(m_pCurrentMapData)\n\t{\n\t\tmem_free(m_pCurrentMapData);\n\t\tm_pCurrentMapData = 0;\n\t}\n\tif(m_pMapListHeap)\n\t{\n\t\tdelete m_pMapListHeap;\n\t\tm_pMapListHeap = 0;\n\t}\n\treturn 0;\n}\n\nint CServer::MapListEntryCallback(const char *pFilename, int IsDir, int DirType, void *pUser)\n{\n\tCSubdirCallbackUserdata *pUserdata = (CSubdirCallbackUserdata *)pUser;\n\tCServer *pThis = pUserdata->m_pServer;\n\n\tif(pFilename[0] == '.') // hidden files\n\t\treturn 0;\n\n\tchar aFilename[IO_MAX_PATH_LENGTH];\n\tif(pUserdata->m_aName[0])\n\t\tstr_format(aFilename, sizeof(aFilename), \"%s/%s\", pUserdata->m_aName, pFilename);\n\telse\n\t\tstr_format(aFilename, sizeof(aFilename), \"%s\", pFilename);\n\n\tif(IsDir)\n\t{\n\t\tCSubdirCallbackUserdata Userdata;\n\t\tUserdata.m_pServer = pThis;\n\t\tstr_copy(Userdata.m_aName, aFilename, sizeof(Userdata.m_aName));\n\t\tchar FindPath[IO_MAX_PATH_LENGTH];\n\t\tstr_format(FindPath, sizeof(FindPath), \"maps/%s/\", aFilename);\n\t\tpThis->m_pStorage->ListDirectory(IStorage::TYPE_ALL, FindPath, MapListEntryCallback, &Userdata);\n\t\treturn 0;\n\t}\n\n\tconst char *pSuffix = str_endswith(aFilename, \".map\");\n\tif(!pSuffix) // not ending with .map\n\t{\n\t\t\treturn 0;\n\t}\n\n\tCMapListEntry *pEntry = (CMapListEntry *)pThis->m_pMapListHeap->Allocate(sizeof(CMapListEntry));\n\tpThis->m_NumMapEntries++;\n\tpEntry->m_pNext = 0;\n\tpEntry->m_pPrev = pThis->m_pLastMapEntry;\n\tif(pEntry->m_pPrev)\n\t\tpEntry->m_pPrev->m_pNext = pEntry;\n\tpThis->m_pLastMapEntry = pEntry;\n\tif(!pThis->m_pFirstMapEntry)\n\t\tpThis->m_pFirstMapEntry = pEntry;\n\n\tstr_truncate(pEntry->m_aName, sizeof(pEntry->m_aName), aFilename, pSuffix-aFilename);\n\n\treturn 0;\n}\n\nvoid CServer::ConKick(IConsole::IResult *pResult, void *pUser)\n{\n\tif(pResult->NumArguments() > 1)\n\t{\n\t\tchar aBuf[128];\n\t\tstr_format(aBuf, sizeof(aBuf), \"Kicked (%s)\", pResult->GetString(1));\n\t\t((CServer *)pUser)->Kick(pResult->GetInteger(0), aBuf);\n\t}\n\telse\n\t\t((CServer *)pUser)->Kick(pResult->GetInteger(0), \"Kicked by console\");\n}\n\nvoid CServer::ConStatus(IConsole::IResult *pResult, void *pUser)\n{\n\tchar aBuf[1024];\n\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\tCServer* pThis = static_cast<CServer *>(pUser);\n\n\tfor(int i = 0; i < MAX_CLIENTS; i++)\n\t{\n\t\tif(pThis->m_aClients[i].m_State != CClient::STATE_EMPTY)\n\t\t{\n\t\t\tnet_addr_str(pThis->m_NetServer.ClientAddr(i), aAddrStr, sizeof(aAddrStr), true);\n\t\t\tif(pThis->m_aClients[i].m_State == CClient::STATE_INGAME)\n\t\t\t{\n\t\t\t\tconst char *pAuthStr = pThis->m_aClients[i].m_Authed == CServer::AUTHED_ADMIN ? \"(Admin)\" :\n\t\t\t\t\t\t\t\t\t\tpThis->m_aClients[i].m_Authed == CServer::AUTHED_MOD ? \"(Mod)\" : \"\";\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"id=%d addr=%s client=%x name='%s' score=%d %s\", i, aAddrStr,\n\t\t\t\t\tpThis->m_aClients[i].m_Version, pThis->m_aClients[i].m_aName, pThis->m_aClients[i].m_Score, pAuthStr);\n\t\t\t}\n\t\t\telse\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"id=%d addr=%s connecting\", i, aAddrStr);\n\t\t\tpThis->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t}\n\t}\n}\n\nvoid CServer::ConShutdown(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_RunServer = 0;\n}\n\nvoid CServer::DemoRecorder_HandleAutoStart()\n{\n\tif(Config()->m_SvAutoDemoRecord)\n\t{\n\t\tm_DemoRecorder.Stop();\n\t\tchar aFilename[128];\n\t\tchar aDate[20];\n\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s_%s.demo\", \"auto/autorecord\", aDate);\n\t\tm_DemoRecorder.Start(Storage(), m_pConsole, aFilename, GameServer()->NetVersion(), m_aCurrentMap, m_CurrentMapSha256, m_CurrentMapCrc, \"server\");\n\t\tif(Config()->m_SvAutoDemoMax)\n\t\t{\n\t\t\t// clean up auto recorded demos\n\t\t\tCFileCollection AutoDemos;\n\t\t\tAutoDemos.Init(Storage(), \"demos/server\", \"autorecord\", \".demo\", Config()->m_SvAutoDemoMax);\n\t\t}\n\t}\n}\n\nbool CServer::DemoRecorder_IsRecording()\n{\n\treturn m_DemoRecorder.IsRecording();\n}\n\nvoid CServer::ConRecord(IConsole::IResult *pResult, void *pUser)\n{\n\tCServer* pServer = (CServer *)pUser;\n\tchar aFilename[128];\n\tif(pResult->NumArguments())\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s.demo\", pResult->GetString(0));\n\telse\n\t{\n\t\tchar aDate[20];\n\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\tstr_format(aFilename, sizeof(aFilename), \"demos/demo_%s.demo\", aDate);\n\t}\n\tpServer->m_DemoRecorder.Start(pServer->Storage(), pServer->Console(), aFilename, pServer->GameServer()->NetVersion(), pServer->m_aCurrentMap, pServer->m_CurrentMapSha256, pServer->m_CurrentMapCrc, \"server\");\n}\n\nvoid CServer::ConStopRecord(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_DemoRecorder.Stop();\n}\n\nvoid CServer::ConMapReload(IConsole::IResult *pResult, void *pUser)\n{\n\t((CServer *)pUser)->m_MapReload = 1;\n}\n\nvoid CServer::ConLogout(IConsole::IResult *pResult, void *pUser)\n{\n\tCServer *pServer = (CServer *)pUser;\n\n\tif(pServer->m_RconClientID >= 0 && pServer->m_RconClientID < MAX_CLIENTS &&\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)\n\t{\n\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_OFF, true);\n\t\tpServer->SendMsg(&Msg, MSGFLAG_VITAL, pServer->m_RconClientID);\n\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_Authed = AUTHED_NO;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_AuthTries = 0;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_pRconCmdToSend = 0;\n\t\tpServer->m_aClients[pServer->m_RconClientID].m_pMapListEntryToSend = 0;\n\t\tpServer->SendRconLine(pServer->m_RconClientID, \"Logout successful.\");\n\t\tchar aBuf[32];\n\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d logged out\", pServer->m_RconClientID);\n\t\tpServer->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t}\n}\n\nvoid CServer::ConchainSpecialInfoupdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tstr_clean_whitespaces(pSelf->Config()->m_SvName);\n\t\tpSelf->SendServerInfo(-1);\n\t}\n}\n\nvoid CServer::ConchainPlayerSlotsUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tif(pSelf->Config()->m_SvMaxClients < pSelf->Config()->m_SvPlayerSlots)\n\t\t\tpSelf->Config()->m_SvPlayerSlots = pSelf->Config()->m_SvMaxClients;\n\t}\n}\n\nvoid CServer::ConchainMaxclientsUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tCServer *pSelf = (CServer *)pUserData;\n\tif(pResult->NumArguments())\n\t{\n\t\tif(pSelf->Config()->m_SvMaxClients < pSelf->Config()->m_SvPlayerSlots)\n\t\t\tpSelf->Config()->m_SvPlayerSlots = pSelf->Config()->m_SvMaxClients;\n\t\tpSelf->m_NetServer.SetMaxClients(pResult->GetInteger(0));\n\t}\n}\n\nvoid CServer::ConchainMaxclientsperipUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments())\n\t\t((CServer *)pUserData)->m_NetServer.SetMaxClientsPerIP(pResult->GetInteger(0));\n}\n\nvoid CServer::ConchainModCommandUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tif(pResult->NumArguments() == 2)\n\t{\n\t\tCServer *pThis = static_cast<CServer *>(pUserData);\n\t\tconst IConsole::CCommandInfo *pInfo = pThis->Console()->GetCommandInfo(pResult->GetString(0), CFGFLAG_SERVER, false);\n\t\tint OldAccessLevel = 0;\n\t\tif(pInfo)\n\t\t\tOldAccessLevel = pInfo->GetAccessLevel();\n\t\tpfnCallback(pResult, pCallbackUserData);\n\t\tif(pInfo && OldAccessLevel != pInfo->GetAccessLevel())\n\t\t{\n\t\t\tfor(int i = 0; i < MAX_CLIENTS; ++i)\n\t\t\t{\n\t\t\t\tif(pThis->m_aClients[i].m_State == CServer::CClient::STATE_EMPTY || pThis->m_aClients[i].m_Authed != CServer::AUTHED_MOD ||\n\t\t\t\t\t(pThis->m_aClients[i].m_pRconCmdToSend && str_comp(pResult->GetString(0), pThis->m_aClients[i].m_pRconCmdToSend->m_pName) >= 0))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(OldAccessLevel == IConsole::ACCESS_LEVEL_ADMIN)\n\t\t\t\t\tpThis->SendRconCmdAdd(pInfo, i);\n\t\t\t\telse\n\t\t\t\t\tpThis->SendRconCmdRem(pInfo, i);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tpfnCallback(pResult, pCallbackUserData);\n}\n\nvoid CServer::ConchainConsoleOutputLevelUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments() == 1)\n\t{\n\t\tCServer *pThis = static_cast<CServer *>(pUserData);\n\t\tpThis->Console()->SetPrintOutputLevel(pThis->m_PrintCBIndex, pResult->GetInteger(0));\n\t}\n}\n\nvoid CServer::ConchainRconPasswordSet(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments() >= 1)\n\t{\n\t\tstatic_cast<CServer *>(pUserData)->m_RconPasswordSet = 1;\n\t}\n}\n\nvoid CServer::RegisterCommands()\n{\n\t// register console commands\n\tConsole()->Register(\"kick\", \"i[id] ?r[reason]\", CFGFLAG_SERVER, ConKick, this, \"Kick player with specified id for any reason\");\n\tConsole()->Register(\"status\", \"\", CFGFLAG_SERVER, ConStatus, this, \"List players\");\n\tConsole()->Register(\"shutdown\", \"\", CFGFLAG_SERVER, ConShutdown, this, \"Shut down\");\n\tConsole()->Register(\"logout\", \"\", CFGFLAG_SERVER|CFGFLAG_BASICACCESS, ConLogout, this, \"Logout of rcon\");\n\n\tConsole()->Register(\"record\", \"?s[file]\", CFGFLAG_SERVER|CFGFLAG_STORE, ConRecord, this, \"Record to a file\");\n\tConsole()->Register(\"stoprecord\", \"\", CFGFLAG_SERVER, ConStopRecord, this, \"Stop recording\");\n\n\tConsole()->Register(\"reload\", \"\", CFGFLAG_SERVER, ConMapReload, this, \"Reload the map\");\n\n\tConsole()->Chain(\"sv_name\", ConchainSpecialInfoupdate, this);\n\tConsole()->Chain(\"password\", ConchainSpecialInfoupdate, this);\n\n\tConsole()->Chain(\"sv_player_slots\", ConchainPlayerSlotsUpdate, this);\n\tConsole()->Chain(\"sv_max_clients\", ConchainMaxclientsUpdate, this);\n\tConsole()->Chain(\"sv_max_clients\", ConchainSpecialInfoupdate, this);\n\tConsole()->Chain(\"sv_max_clients_per_ip\", ConchainMaxclientsperipUpdate, this);\n\tConsole()->Chain(\"mod_command\", ConchainModCommandUpdate, this);\n\tConsole()->Chain(\"console_output_level\", ConchainConsoleOutputLevelUpdate, this);\n\tConsole()->Chain(\"sv_rcon_password\", ConchainRconPasswordSet, this);\n\n\t// register console commands in sub parts\n\tm_ServerBan.InitServerBan(Console(), Storage(), this);\n\tm_pGameServer->OnConsoleInit();\n}\n\n\nint CServer::SnapNewID()\n{\n\treturn m_IDPool.NewID();\n}\n\nvoid CServer::SnapFreeID(int ID)\n{\n\tm_IDPool.FreeID(ID);\n}\n\n\nvoid *CServer::SnapNewItem(int Type, int ID, int Size)\n{\n\tdbg_assert(Type >= 0 && Type <=0xffff, \"incorrect type\");\n\tdbg_assert(ID >= 0 && ID <=0xffff, \"incorrect id\");\n\treturn ID < 0 ? 0 : m_SnapshotBuilder.NewItem(Type, ID, Size);\n}\n\nvoid CServer::SnapSetStaticsize(int ItemType, int Size)\n{\n\tm_SnapshotDelta.SetStaticsize(ItemType, Size);\n}\n\nstatic CServer *CreateServer() { return new CServer(); }\n\nint main(int argc, const char **argv) // ignore_convention\n{\n#if defined(CONF_FAMILY_WINDOWS)\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-s\", argv[i]) == 0 || str_comp(\"--silent\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tShowWindow(GetConsoleWindow(), SW_HIDE);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\n\tbool UseDefaultConfig = false;\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-d\", argv[i]) == 0 || str_comp(\"--default\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tUseDefaultConfig = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(secure_random_init() != 0)\n\t{\n\t\tdbg_msg(\"secure\", \"could not initialize secure RNG\");\n\t\treturn -1;\n\t}\n\n\tCServer *pServer = CreateServer();\n\tIKernel *pKernel = IKernel::Create();\n\n\t// create the components\n\tint FlagMask = CFGFLAG_SERVER|CFGFLAG_ECON;\n\tIEngine *pEngine = CreateEngine(\"Teeworlds_Server\");\n\tIEngineMap *pEngineMap = CreateEngineMap();\n\tIGameServer *pGameServer = CreateGameServer();\n\tIConsole *pConsole = CreateConsole(CFGFLAG_SERVER|CFGFLAG_ECON);\n\tIEngineMasterServer *pEngineMasterServer = CreateEngineMasterServer();\n\tIStorage *pStorage = CreateStorage(\"Teeworlds\", IStorage::STORAGETYPE_SERVER, argc, argv); // ignore_convention\n\tIConfigManager *pConfigManager = CreateConfigManager();\n\n\tpServer->InitRegister(&pServer->m_NetServer, pEngineMasterServer, pConfigManager->Values(), pConsole);\n\n\t{\n\t\tbool RegisterFail = false;\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pServer); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pEngine);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMap*>(pEngineMap)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMap*>(pEngineMap));\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pGameServer);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConsole);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pStorage);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConfigManager);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMasterServer*>(pEngineMasterServer)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMasterServer*>(pEngineMasterServer));\n\n\t\tif(RegisterFail)\n\t\t\treturn -1;\n\t}\n\n\tpEngine->Init();\n\tpConfigManager->Init(FlagMask);\n\tpConsole->Init();\n\tpEngineMasterServer->Init();\n\tpEngineMasterServer->Load();\n\n\tpServer->InitInterfaces(pConfigManager->Values(), pConsole, pGameServer, pEngineMap, pStorage);\n\tif(!UseDefaultConfig)\n\t{\n\t\t// register all console commands\n\t\tpServer->RegisterCommands();\n\n\t\t// execute autoexec file\n\t\tpConsole->ExecuteFile(\"autoexec.cfg\");\n\n\t\t// parse the command line arguments\n\t\tif(argc > 1) // ignore_convention\n\t\t\tpConsole->ParseArguments(argc-1, &argv[1]); // ignore_convention\n\t}\n\n\t// restore empty config strings to their defaults\n\tpConfigManager->RestoreStrings();\n\n\tpEngine->InitLogfile();\n\n\tpServer->InitRconPasswordIfUnset();\n\n\t// run the server\n\tdbg_msg(\"server\", \"starting...\");\n\tint Ret = pServer->Run();\n\n\t// free\n\tdelete pServer;\n\tdelete pKernel;\n\tdelete pEngine;\n\tdelete pEngineMap;\n\tdelete pGameServer;\n\tdelete pConsole;\n\tdelete pEngineMasterServer;\n\tdelete pStorage;\n\tdelete pConfigManager;\n\n\treturn Ret;\n}\n"], "filenames": ["src/engine/server/server.cpp"], "buggy_code_start_loc": [499], "buggy_code_end_loc": [501], "fixing_code_start_loc": [499], "fixing_code_end_loc": [501], "type": "CWE-20", "message": "CServer::SendMsg in engine/server/server.cpp in Teeworlds 0.7.x before 0.7.5 allows remote attackers to shut down the server.", "other": {"cve": {"id": "CVE-2020-12066", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-22T17:15:12.510", "lastModified": "2022-04-29T13:24:57.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CServer::SendMsg in engine/server/server.cpp in Teeworlds 0.7.x before 0.7.5 allows remote attackers to shut down the server."}, {"lang": "es", "value": "La funci\u00f3n CServer::SendMsg en el archivo engine/server/server.cpp en Teeworlds versiones 0.7.x anteriores a 0.7.5, permite a atacantes remotos apagar el servidor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teeworlds:teeworlds:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.7.0", "versionEndExcluding": "0.7.5", "matchCriteriaId": "AAB4A3CE-4615-4BB4-A870-697FC97FE11C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00044.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/teeworlds/teeworlds/commit/c68402fa7e279d42886d5951d1ea8ac2facc1ea5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AVYG7CCPS5F3OPOQMJKVNXTQ7BXSEX2V/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4553-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4763", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.teeworlds.com/forum/viewtopic.php?id=14785", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/teeworlds/teeworlds/commit/c68402fa7e279d42886d5951d1ea8ac2facc1ea5"}}