{"buggy_code": ["/*\n * Authored by Alex Hultman, 2018-2020.\n * Intellectual property of third-party.\n\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n *     http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef UWS_TOPICTREE_H\n#define UWS_TOPICTREE_H\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string_view>\n#include <functional>\n#include <set>\n#include <chrono>\n#include <list>\n#include <cstring>\n\nnamespace uWS {\n\n/* A Subscriber is an extension of a socket */\nstruct Subscriber {\n    std::list<struct Topic *> subscriptions;\n    void *user;\n\n    Subscriber(void *user) : user(user) {}\n};\n\nstruct Topic {\n    /* Memory for our name */\n    char *name;\n    size_t length;\n\n    /* Our parent or nullptr */\n    Topic *parent = nullptr;\n\n    /* Next triggered Topic */\n    bool triggered = false;\n\n    /* Exact string matches */\n    std::map<std::string_view, Topic *> children;\n\n    /* Wildcard child */\n    Topic *wildcardChild = nullptr;\n\n    /* Terminating wildcard child */\n    Topic *terminatingWildcardChild = nullptr;\n\n    /* What we published, {inflated, deflated} */\n    std::map<unsigned int, std::pair<std::string, std::string>> messages;\n\n    std::set<Subscriber *> subs;\n};\n\nstruct TopicTree {\nprivate:\n    std::function<int(Subscriber *, std::pair<std::string_view, std::string_view>)> cb;\n\n    Topic *root = new Topic;\n\n    /* Global messageId for deduplication of overlapping topics and ordering between topics */\n    unsigned int messageId = 0;\n\n    /* The triggered topics */\n    Topic *triggeredTopics[64];\n    int numTriggeredTopics = 0;\n    Subscriber *min = (Subscriber *) UINTPTR_MAX;\n\n    /* Cull or trim unused Topic nodes from leaf to root */\n    void trimTree(Topic *topic) {\n        repeat:\n        if (!topic->subs.size() && !topic->children.size() && !topic->terminatingWildcardChild && !topic->wildcardChild) {\n            Topic *parent = topic->parent;\n\n            if (topic->length == 1) {\n                if (topic->name[0] == '#') {\n                    parent->terminatingWildcardChild = nullptr;\n                } else if (topic->name[0] == '+') {\n                    parent->wildcardChild = nullptr;\n                }\n            }\n            /* Erase us from our parents set (wildcards also live here) */\n            parent->children.erase(std::string_view(topic->name, topic->length));\n\n            /* If this node is triggered, make sure to remove it from the triggered list */\n            if (topic->triggered) {\n                Topic *tmp[64];\n                int length = 0;\n                for (int i = 0; i < numTriggeredTopics; i++) {\n                    if (triggeredTopics[i] != topic) {\n                        tmp[length++] = triggeredTopics[i];\n                    }\n                }\n\n                for (int i = 0; i < length; i++) {\n                    triggeredTopics[i] = tmp[i];\n                }\n                numTriggeredTopics = length;\n            }\n\n            /* Free various memory for the node */\n            delete [] topic->name;\n            delete topic;\n\n            if (parent != root) {\n                topic = parent;\n                goto repeat;\n                //trimTree(parent);\n            }\n        }\n    }\n\n    /* Should be getData and commit? */\n    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        /* If we already have 64 triggered topics make sure to drain it here */\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n\n        /* Iterate over all segments in given topic */\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            /* It is very important to disallow wildcards when publishing.\n             * We will not catch EVERY misuse this lazy way, but enough to hinder\n             * explosive recursion.\n             * Terminating wildcards MAY still get triggered along the way, if for\n             * instace the error is found late while iterating the topic segments. */\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            /* Do we have a terminating wildcard child? */\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                /* Add this topic to triggered */\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            /* Do we have a wildcard child? */\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                /* Stop trying to match by exact string */\n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        /* If we went all the way we matched exactly */\n        iterator->messages[messageId] = message;\n\n        /* Add this topic to triggered */\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }\n\npublic:\n\n    TopicTree(std::function<int(Subscriber *, std::pair<std::string_view, std::string_view>)> cb) {\n        this->cb = cb;\n    }\n\n    ~TopicTree() {\n        delete root;\n    }\n\n    void subscribe(std::string_view topic, Subscriber *subscriber) {\n        /* Start iterating from the root */\n        Topic *iterator = root;\n\n        /* Traverse the topic, inserting a node for every new segment separated by / */\n        for (size_t start = 0, stop = 0; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            auto lb = iterator->children.lower_bound(segment);\n\n            if (lb != iterator->children.end() && !(iterator->children.key_comp()(segment, lb->first))) {\n                iterator = lb->second;\n            } else {\n                /* Allocate and insert new node */\n                Topic *newTopic = new Topic;\n                newTopic->parent = iterator;\n                newTopic->name = new char[segment.length()];\n                newTopic->length = segment.length();\n                newTopic->terminatingWildcardChild = nullptr;\n                newTopic->wildcardChild = nullptr;\n                memcpy(newTopic->name, segment.data(), segment.length());\n\n                /* For simplicity we do insert wildcards with text */\n                iterator->children.insert(lb, {std::string_view(newTopic->name, segment.length()), newTopic});\n\n                /* Store fast lookup to wildcards */\n                if (segment.length() == 1) {\n                    /* If this segment is '+' it is a wildcard */\n                    if (segment[0] == '+') {\n                        iterator->wildcardChild = newTopic;\n                    }\n                    /* If this segment is '#' it is a terminating wildcard */\n                    if (segment[0] == '#') {\n                        iterator->terminatingWildcardChild = newTopic;\n                    }\n                }\n\n                iterator = newTopic;\n            }\n        }\n\n        /* If this topic is triggered, drain the tree before we join */\n        if (iterator->triggered) {\n            drain();\n        }\n\n        /* Add socket to Topic's Set */\n        auto [it, inserted] = iterator->subs.insert(subscriber);\n\n        /* Add Topic to list of subscriptions only if we weren't already subscribed */\n        if (inserted) {\n            subscriber->subscriptions.push_back(iterator);\n        }\n    }\n\n    void publish(std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        publish(root, 0, 0, topic, message);\n        messageId++;\n    }\n\n    /* Returns whether we were subscribed prior */\n    bool unsubscribe(std::string_view topic, Subscriber *subscriber) {\n        /* Subscribers are likely to have very few subscriptions (20 or fewer) */\n        if (subscriber) {\n            /* Lookup exact Topic ptr from string */\n            Topic *iterator = root;\n            for (size_t start = 0, stop = 0; stop != std::string::npos; start = stop + 1) {\n                stop = topic.find('/', start);\n                std::string_view segment = topic.substr(start, stop - start);\n\n                std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n                if (it == iterator->children.end()) {\n                    /* This topic does not even exist */\n                    return false;\n                }\n\n                iterator = it->second;\n            }\n\n            /* Try and remove this topic from our list */\n            for (auto it = subscriber->subscriptions.begin(); it != subscriber->subscriptions.end(); it++) {\n                if (*it == iterator) {\n                    /* If this topic is triggered, drain the tree before we leave */\n                    if (iterator->triggered) {\n                        drain();\n                    }\n\n                    /* Remove topic ptr from our list */\n                    subscriber->subscriptions.erase(it);\n\n                    /* Remove us from Topic's subs */\n                    iterator->subs.erase(subscriber);\n                    trimTree(iterator);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /* Can be called with nullptr, ignore it then */\n    void unsubscribeAll(Subscriber *subscriber, bool mayFlush = true) {\n        if (subscriber) {\n            for (Topic *topic : subscriber->subscriptions) {\n\n                /* We do not want to flush when closing a socket, it makes no sense to do so */\n\n                /* If this topic is triggered, drain the tree before we leave */\n                if (mayFlush && topic->triggered) {\n                    drain();\n                }\n\n                /* Remove us from the topic's set */\n                topic->subs.erase(subscriber);\n                trimTree(topic);\n            }\n            subscriber->subscriptions.clear();\n        }\n    }\n\n    /* Drain the tree by emitting what to send with every Subscriber */\n    /* Better name would be commit() and making it public so that one can commit and shutdown, etc */\n    void drain() {\n\n        /* Do nothing if nothing to send */\n        if (!numTriggeredTopics) {\n            return;\n        }\n\n        /* bug fix: Filter triggered topics without subscribers */\n        int numFilteredTriggeredTopics = 0;\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            if (triggeredTopics[i]->subs.size()) {\n                triggeredTopics[numFilteredTriggeredTopics++] = triggeredTopics[i];\n            } else {\n                /* If we no longer have any subscribers, yet still keep this Topic alive (parent),\n                 * make sure to clear its potential messages. */\n                triggeredTopics[i]->messages.clear();\n                triggeredTopics[i]->triggered = false;\n            }\n        }\n        numTriggeredTopics = numFilteredTriggeredTopics;\n\n        if (!numTriggeredTopics) {\n            return;\n        }\n\n        /* bug fix: update min, as the one tracked via subscribe gets invalid as you unsubscribe */\n        min = (Subscriber *)UINTPTR_MAX;\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            if ((triggeredTopics[i]->subs.size()) && (min > *triggeredTopics[i]->subs.begin())) {\n                min = *triggeredTopics[i]->subs.begin();\n            }\n        }\n\n        /* Check if we really have any sockets still */\n        if (min != (Subscriber *)UINTPTR_MAX) {\n\n            /* Up to 64 triggered Topics per batch */\n            std::map<uint64_t, std::pair<std::string, std::string>> intersectionCache;\n\n            /* Loop over these here */\n            std::set<Subscriber *>::iterator it[64];\n            std::set<Subscriber *>::iterator end[64];\n            for (int i = 0; i < numTriggeredTopics; i++) {\n                it[i] = triggeredTopics[i]->subs.begin();\n                end[i] = triggeredTopics[i]->subs.end();\n            }\n\n            /* Empty all sets from unique subscribers */\n            for (int nonEmpty = numTriggeredTopics; nonEmpty; ) {\n\n                Subscriber *nextMin = (Subscriber *)UINTPTR_MAX;\n\n                /* The message sets relevant for this intersection */\n                std::map<unsigned int, std::pair<std::string, std::string>> *perSubscriberIntersectingTopicMessages[64];\n                int numPerSubscriberIntersectingTopicMessages = 0;\n\n                uint64_t intersection = 0;\n\n                for (int i = 0; i < numTriggeredTopics; i++) {\n                    if ((it[i] != end[i]) && (*it[i] == min)) {\n\n                        /* Mark this intersection */\n                        intersection |= ((uint64_t)1 << i);\n                        perSubscriberIntersectingTopicMessages[numPerSubscriberIntersectingTopicMessages++] = &triggeredTopics[i]->messages;\n\n                        it[i]++;\n                        if (it[i] == end[i]) {\n                            nonEmpty--;\n                        }\n                        else {\n                            if (nextMin > *it[i]) {\n                                nextMin = *it[i];\n                            }\n                        }\n                    }\n                    else {\n                        /* We need to lower nextMin to us, in the case of min being the last in a set */\n                        if ((it[i] != end[i]) && (nextMin > *it[i])) {\n                            nextMin = *it[i];\n                        }\n                    }\n                }\n\n                /* Generate cache for intersection */\n                if (intersectionCache[intersection].first.length() == 0) {\n\n                    /* Build the union in order without duplicates */\n                    std::map<unsigned int, std::pair<std::string, std::string>> complete;\n                    for (int i = 0; i < numPerSubscriberIntersectingTopicMessages; i++) {\n                        complete.insert(perSubscriberIntersectingTopicMessages[i]->begin(), perSubscriberIntersectingTopicMessages[i]->end());\n                    }\n\n                    /* Create the linear cache, {inflated, deflated} */\n                    std::pair<std::string, std::string> res;\n                    for (auto &p : complete) {\n                        res.first.append(p.second.first);\n                        res.second.append(p.second.second);\n                    }\n\n                    cb(min, intersectionCache[intersection] = std::move(res));\n                }\n                else {\n                    cb(min, intersectionCache[intersection]);\n                }\n\n                min = nextMin;\n            }\n\n        }\n\n        /* Clear messages of triggered Topics */\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            triggeredTopics[i]->messages.clear();\n            triggeredTopics[i]->triggered = false;\n        }\n        numTriggeredTopics = 0;\n    }\n};\n\n}\n\n#endif\n"], "fixing_code": ["/*\n * Authored by Alex Hultman, 2018-2020.\n * Intellectual property of third-party.\n\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n *     http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef UWS_TOPICTREE_H\n#define UWS_TOPICTREE_H\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string_view>\n#include <functional>\n#include <set>\n#include <chrono>\n#include <list>\n#include <cstring>\n\nnamespace uWS {\n\n/* A Subscriber is an extension of a socket */\nstruct Subscriber {\n    std::list<struct Topic *> subscriptions;\n    void *user;\n\n    Subscriber(void *user) : user(user) {}\n};\n\nstruct Topic {\n    /* Memory for our name */\n    char *name;\n    size_t length;\n\n    /* Our parent or nullptr */\n    Topic *parent = nullptr;\n\n    /* Next triggered Topic */\n    bool triggered = false;\n\n    /* Exact string matches */\n    std::map<std::string_view, Topic *> children;\n\n    /* Wildcard child */\n    Topic *wildcardChild = nullptr;\n\n    /* Terminating wildcard child */\n    Topic *terminatingWildcardChild = nullptr;\n\n    /* What we published, {inflated, deflated} */\n    std::map<unsigned int, std::pair<std::string, std::string>> messages;\n\n    std::set<Subscriber *> subs;\n};\n\nstruct TopicTree {\nprivate:\n    std::function<int(Subscriber *, std::pair<std::string_view, std::string_view>)> cb;\n\n    Topic *root = new Topic;\n\n    /* Global messageId for deduplication of overlapping topics and ordering between topics */\n    unsigned int messageId = 0;\n\n    /* The triggered topics */\n    Topic *triggeredTopics[64];\n    int numTriggeredTopics = 0;\n    Subscriber *min = (Subscriber *) UINTPTR_MAX;\n\n    /* Cull or trim unused Topic nodes from leaf to root */\n    void trimTree(Topic *topic) {\n        repeat:\n        if (!topic->subs.size() && !topic->children.size() && !topic->terminatingWildcardChild && !topic->wildcardChild) {\n            Topic *parent = topic->parent;\n\n            if (topic->length == 1) {\n                if (topic->name[0] == '#') {\n                    parent->terminatingWildcardChild = nullptr;\n                } else if (topic->name[0] == '+') {\n                    parent->wildcardChild = nullptr;\n                }\n            }\n            /* Erase us from our parents set (wildcards also live here) */\n            parent->children.erase(std::string_view(topic->name, topic->length));\n\n            /* If this node is triggered, make sure to remove it from the triggered list */\n            if (topic->triggered) {\n                Topic *tmp[64];\n                int length = 0;\n                for (int i = 0; i < numTriggeredTopics; i++) {\n                    if (triggeredTopics[i] != topic) {\n                        tmp[length++] = triggeredTopics[i];\n                    }\n                }\n\n                for (int i = 0; i < length; i++) {\n                    triggeredTopics[i] = tmp[i];\n                }\n                numTriggeredTopics = length;\n            }\n\n            /* Free various memory for the node */\n            delete [] topic->name;\n            delete topic;\n\n            if (parent != root) {\n                topic = parent;\n                goto repeat;\n                //trimTree(parent);\n            }\n        }\n    }\n\n    /* Should be getData and commit? */\n    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n\n        /* Iterate over all segments in given topic */\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            /* It is very important to disallow wildcards when publishing.\n             * We will not catch EVERY misuse this lazy way, but enough to hinder\n             * explosive recursion.\n             * Terminating wildcards MAY still get triggered along the way, if for\n             * instace the error is found late while iterating the topic segments. */\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            /* Do we have a terminating wildcard child? */\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                /* Add this topic to triggered */\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    /* If we already have 64 triggered topics make sure to drain it here */\n                    if (numTriggeredTopics == 64) {\n                        drain();\n                    }\n\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            /* Do we have a wildcard child? */\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                /* Stop trying to match by exact string */\n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        /* If we went all the way we matched exactly */\n        iterator->messages[messageId] = message;\n\n        /* Add this topic to triggered */\n        if (!iterator->triggered) {\n            /* If we already have 64 triggered topics make sure to drain it here */\n            if (numTriggeredTopics == 64) {\n                drain();\n            }\n\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }\n\npublic:\n\n    TopicTree(std::function<int(Subscriber *, std::pair<std::string_view, std::string_view>)> cb) {\n        this->cb = cb;\n    }\n\n    ~TopicTree() {\n        delete root;\n    }\n\n    void subscribe(std::string_view topic, Subscriber *subscriber) {\n        /* Start iterating from the root */\n        Topic *iterator = root;\n\n        /* Traverse the topic, inserting a node for every new segment separated by / */\n        for (size_t start = 0, stop = 0; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            auto lb = iterator->children.lower_bound(segment);\n\n            if (lb != iterator->children.end() && !(iterator->children.key_comp()(segment, lb->first))) {\n                iterator = lb->second;\n            } else {\n                /* Allocate and insert new node */\n                Topic *newTopic = new Topic;\n                newTopic->parent = iterator;\n                newTopic->name = new char[segment.length()];\n                newTopic->length = segment.length();\n                newTopic->terminatingWildcardChild = nullptr;\n                newTopic->wildcardChild = nullptr;\n                memcpy(newTopic->name, segment.data(), segment.length());\n\n                /* For simplicity we do insert wildcards with text */\n                iterator->children.insert(lb, {std::string_view(newTopic->name, segment.length()), newTopic});\n\n                /* Store fast lookup to wildcards */\n                if (segment.length() == 1) {\n                    /* If this segment is '+' it is a wildcard */\n                    if (segment[0] == '+') {\n                        iterator->wildcardChild = newTopic;\n                    }\n                    /* If this segment is '#' it is a terminating wildcard */\n                    if (segment[0] == '#') {\n                        iterator->terminatingWildcardChild = newTopic;\n                    }\n                }\n\n                iterator = newTopic;\n            }\n        }\n\n        /* If this topic is triggered, drain the tree before we join */\n        if (iterator->triggered) {\n            drain();\n        }\n\n        /* Add socket to Topic's Set */\n        auto [it, inserted] = iterator->subs.insert(subscriber);\n\n        /* Add Topic to list of subscriptions only if we weren't already subscribed */\n        if (inserted) {\n            subscriber->subscriptions.push_back(iterator);\n        }\n    }\n\n    void publish(std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        publish(root, 0, 0, topic, message);\n        messageId++;\n    }\n\n    /* Returns whether we were subscribed prior */\n    bool unsubscribe(std::string_view topic, Subscriber *subscriber) {\n        /* Subscribers are likely to have very few subscriptions (20 or fewer) */\n        if (subscriber) {\n            /* Lookup exact Topic ptr from string */\n            Topic *iterator = root;\n            for (size_t start = 0, stop = 0; stop != std::string::npos; start = stop + 1) {\n                stop = topic.find('/', start);\n                std::string_view segment = topic.substr(start, stop - start);\n\n                std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n                if (it == iterator->children.end()) {\n                    /* This topic does not even exist */\n                    return false;\n                }\n\n                iterator = it->second;\n            }\n\n            /* Try and remove this topic from our list */\n            for (auto it = subscriber->subscriptions.begin(); it != subscriber->subscriptions.end(); it++) {\n                if (*it == iterator) {\n                    /* If this topic is triggered, drain the tree before we leave */\n                    if (iterator->triggered) {\n                        drain();\n                    }\n\n                    /* Remove topic ptr from our list */\n                    subscriber->subscriptions.erase(it);\n\n                    /* Remove us from Topic's subs */\n                    iterator->subs.erase(subscriber);\n                    trimTree(iterator);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /* Can be called with nullptr, ignore it then */\n    void unsubscribeAll(Subscriber *subscriber, bool mayFlush = true) {\n        if (subscriber) {\n            for (Topic *topic : subscriber->subscriptions) {\n\n                /* We do not want to flush when closing a socket, it makes no sense to do so */\n\n                /* If this topic is triggered, drain the tree before we leave */\n                if (mayFlush && topic->triggered) {\n                    drain();\n                }\n\n                /* Remove us from the topic's set */\n                topic->subs.erase(subscriber);\n                trimTree(topic);\n            }\n            subscriber->subscriptions.clear();\n        }\n    }\n\n    /* Drain the tree by emitting what to send with every Subscriber */\n    /* Better name would be commit() and making it public so that one can commit and shutdown, etc */\n    void drain() {\n\n        /* Do nothing if nothing to send */\n        if (!numTriggeredTopics) {\n            return;\n        }\n\n        /* bug fix: Filter triggered topics without subscribers */\n        int numFilteredTriggeredTopics = 0;\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            if (triggeredTopics[i]->subs.size()) {\n                triggeredTopics[numFilteredTriggeredTopics++] = triggeredTopics[i];\n            } else {\n                /* If we no longer have any subscribers, yet still keep this Topic alive (parent),\n                 * make sure to clear its potential messages. */\n                triggeredTopics[i]->messages.clear();\n                triggeredTopics[i]->triggered = false;\n            }\n        }\n        numTriggeredTopics = numFilteredTriggeredTopics;\n\n        if (!numTriggeredTopics) {\n            return;\n        }\n\n        /* bug fix: update min, as the one tracked via subscribe gets invalid as you unsubscribe */\n        min = (Subscriber *)UINTPTR_MAX;\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            if ((triggeredTopics[i]->subs.size()) && (min > *triggeredTopics[i]->subs.begin())) {\n                min = *triggeredTopics[i]->subs.begin();\n            }\n        }\n\n        /* Check if we really have any sockets still */\n        if (min != (Subscriber *)UINTPTR_MAX) {\n\n            /* Up to 64 triggered Topics per batch */\n            std::map<uint64_t, std::pair<std::string, std::string>> intersectionCache;\n\n            /* Loop over these here */\n            std::set<Subscriber *>::iterator it[64];\n            std::set<Subscriber *>::iterator end[64];\n            for (int i = 0; i < numTriggeredTopics; i++) {\n                it[i] = triggeredTopics[i]->subs.begin();\n                end[i] = triggeredTopics[i]->subs.end();\n            }\n\n            /* Empty all sets from unique subscribers */\n            for (int nonEmpty = numTriggeredTopics; nonEmpty; ) {\n\n                Subscriber *nextMin = (Subscriber *)UINTPTR_MAX;\n\n                /* The message sets relevant for this intersection */\n                std::map<unsigned int, std::pair<std::string, std::string>> *perSubscriberIntersectingTopicMessages[64];\n                int numPerSubscriberIntersectingTopicMessages = 0;\n\n                uint64_t intersection = 0;\n\n                for (int i = 0; i < numTriggeredTopics; i++) {\n                    if ((it[i] != end[i]) && (*it[i] == min)) {\n\n                        /* Mark this intersection */\n                        intersection |= ((uint64_t)1 << i);\n                        perSubscriberIntersectingTopicMessages[numPerSubscriberIntersectingTopicMessages++] = &triggeredTopics[i]->messages;\n\n                        it[i]++;\n                        if (it[i] == end[i]) {\n                            nonEmpty--;\n                        }\n                        else {\n                            if (nextMin > *it[i]) {\n                                nextMin = *it[i];\n                            }\n                        }\n                    }\n                    else {\n                        /* We need to lower nextMin to us, in the case of min being the last in a set */\n                        if ((it[i] != end[i]) && (nextMin > *it[i])) {\n                            nextMin = *it[i];\n                        }\n                    }\n                }\n\n                /* Generate cache for intersection */\n                if (intersectionCache[intersection].first.length() == 0) {\n\n                    /* Build the union in order without duplicates */\n                    std::map<unsigned int, std::pair<std::string, std::string>> complete;\n                    for (int i = 0; i < numPerSubscriberIntersectingTopicMessages; i++) {\n                        complete.insert(perSubscriberIntersectingTopicMessages[i]->begin(), perSubscriberIntersectingTopicMessages[i]->end());\n                    }\n\n                    /* Create the linear cache, {inflated, deflated} */\n                    std::pair<std::string, std::string> res;\n                    for (auto &p : complete) {\n                        res.first.append(p.second.first);\n                        res.second.append(p.second.second);\n                    }\n\n                    cb(min, intersectionCache[intersection] = std::move(res));\n                }\n                else {\n                    cb(min, intersectionCache[intersection]);\n                }\n\n                min = nextMin;\n            }\n\n        }\n\n        /* Clear messages of triggered Topics */\n        for (int i = 0; i < numTriggeredTopics; i++) {\n            triggeredTopics[i]->messages.clear();\n            triggeredTopics[i]->triggered = false;\n        }\n        numTriggeredTopics = 0;\n    }\n};\n\n}\n\n#endif\n"], "filenames": ["src/TopicTree.h"], "buggy_code_start_loc": [127], "buggy_code_end_loc": [177], "fixing_code_start_loc": [126], "fixing_code_end_loc": [184], "type": "CWE-787", "message": "** DISPUTED ** uWebSockets 18.11.0 and 18.12.0 has a stack-based buffer overflow in uWS::TopicTree::trimTree (called from uWS::TopicTree::unsubscribeAll). NOTE: the vendor's position is that this is \"a minor issue or not even an issue at all\" because the developer of an application (that uses uWebSockets) should not be allowing the large number of triggered topics to accumulate.", "other": {"cve": {"id": "CVE-2020-36406", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.000", "lastModified": "2022-04-29T01:55:41.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** uWebSockets 18.11.0 and 18.12.0 has a stack-based buffer overflow in uWS::TopicTree::trimTree (called from uWS::TopicTree::unsubscribeAll). NOTE: the vendor's position is that this is \"a minor issue or not even an issue at all\" because the developer of an application (that uses uWebSockets) should not be allowing the large number of triggered topics to accumulate."}, {"lang": "es", "value": "** EN DISPUTA ** uWebSockets versiones 18.11.0 y 18.12.0, presenta un desbordamiento de b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n uWS::TopicTree::trimTree (llamado desde uWS::TopicTree::unsubscribeAll) NOTA: la posici\u00f3n del proveedor es que esto es \"un problema menor o ni siquiera un problema\" porque el desarrollador de una aplicaci\u00f3n (que utiliza uWebSockets) no deber\u00eda permitir que se acumule el gran n\u00famero de temas activados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uwebsockets_project:uwebsockets:18.11.0:*:*:*:*:node.js:*:*", "matchCriteriaId": "3AB9BB26-DE76-4B8A-8D56-998171A2F2B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:uwebsockets_project:uwebsockets:18.12.0:*:*:*:*:node.js:*:*", "matchCriteriaId": "58A20B85-0F50-4B08-91F1-4541CA700FD7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25381", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/uwebsockets/OSV-2020-1695.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/uNetworking/uWebSockets/commit/03fca626a95130ab80f86adada54b29d27242759", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uNetworking/uWebSockets/commit/03fca626a95130ab80f86adada54b29d27242759"}}