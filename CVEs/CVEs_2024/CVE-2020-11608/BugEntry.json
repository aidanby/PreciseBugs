{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * OV519 driver\n *\n * Copyright (C) 2008-2011 Jean-Fran\u00e7ois Moine <moinejf@free.fr>\n * Copyright (C) 2009 Hans de Goede <hdegoede@redhat.com>\n *\n * This module is adapted from the ov51x-jpeg package, which itself\n * was adapted from the ov511 driver.\n *\n * Original copyright for the ov511 driver is:\n *\n * Copyright (c) 1999-2006 Mark W. McClelland\n * Support for OV519, OV8610 Copyright (c) 2003 Joerg Heckenbach\n * Many improvements by Bret Wallach <bwallac1@san.rr.com>\n * Color fixes by by Orion Sky Lawlor <olawlor@acm.org> (2/26/2000)\n * OV7620 fixes by Charl P. Botha <cpbotha@ieee.org>\n * Changes by Claudio Matsuoka <claudio@conectiva.com>\n *\n * ov51x-jpeg original copyright is:\n *\n * Copyright (c) 2004-2007 Romain Beauxis <toots@rastageeks.org>\n * Support for OV7670 sensors was contributed by Sam Skipsey <aoanla@yahoo.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"ov519\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\n/* The jpeg_hdr is used by w996Xcf only */\n/* The CONEX_CAM define for jpeg.h needs renaming, now its used here too */\n#define CONEX_CAM\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"OV519 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n/* global parameters */\nstatic int frame_rate;\n\n/* Number of times to retry a failed I2C transaction. Increase this if you\n * are getting \"Failed to read sensor ID...\" */\nstatic int i2c_detect_tries = 10;\n\n/* ov519 device descriptor */\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t/* !! must be the first item */\n\n\tstruct v4l2_ctrl *jpegqual;\n\tstruct v4l2_ctrl *freq;\n\tstruct { /* h/vflip control cluster */\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct { /* autobrightness/brightness control cluster */\n\t\tstruct v4l2_ctrl *autobright;\n\t\tstruct v4l2_ctrl *brightness;\n\t};\n\n\tu8 revision;\n\n\tu8 packet_nr;\n\n\tchar bridge;\n#define BRIDGE_OV511\t\t0\n#define BRIDGE_OV511PLUS\t1\n#define BRIDGE_OV518\t\t2\n#define BRIDGE_OV518PLUS\t3\n#define BRIDGE_OV519\t\t4\t\t/* = ov530 */\n#define BRIDGE_OVFX2\t\t5\n#define BRIDGE_W9968CF\t\t6\n#define BRIDGE_MASK\t\t7\n\n\tchar invert_led;\n#define BRIDGE_INVERT_LED\t8\n\n\tchar snapshot_pressed;\n\tchar snapshot_needs_reset;\n\n\t/* Determined by sensor type */\n\tu8 sif;\n\n#define QUALITY_MIN 50\n#define QUALITY_MAX 70\n#define QUALITY_DEF 50\n\n\tu8 stopped;\t\t/* Streaming is temporarily paused */\n\tu8 first_frame;\n\n\tu8 frame_rate;\t\t/* current Framerate */\n\tu8 clockdiv;\t\t/* clockdiv override */\n\n\ts8 sensor;\t\t/* Type of image sensor chip (SEN_*) */\n\n\tu8 sensor_addr;\n\tu16 sensor_width;\n\tu16 sensor_height;\n\ts16 sensor_reg_cache[256];\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\nenum sensors {\n\tSEN_OV2610,\n\tSEN_OV2610AE,\n\tSEN_OV3610,\n\tSEN_OV6620,\n\tSEN_OV6630,\n\tSEN_OV66308AF,\n\tSEN_OV7610,\n\tSEN_OV7620,\n\tSEN_OV7620AE,\n\tSEN_OV7640,\n\tSEN_OV7648,\n\tSEN_OV7660,\n\tSEN_OV7670,\n\tSEN_OV76BE,\n\tSEN_OV8610,\n\tSEN_OV9600,\n};\n\n/* Note this is a bit of a hack, but the w9968cf driver needs the code for all\n   the ov sensors which is already present here. When we have the time we\n   really should move the sensor drivers to v4l2 sub drivers. */\n#include \"w996Xcf.c\"\n\n/* table of the disabled controls */\nstruct ctrl_valid {\n\tunsigned int has_brightness:1;\n\tunsigned int has_contrast:1;\n\tunsigned int has_exposure:1;\n\tunsigned int has_autogain:1;\n\tunsigned int has_sat:1;\n\tunsigned int has_hvflip:1;\n\tunsigned int has_autobright:1;\n\tunsigned int has_freq:1;\n};\n\nstatic const struct ctrl_valid valid_controls[] = {\n\t[SEN_OV2610] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV2610AE] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV3610] = {\n\t\t/* No controls */\n\t},\n\t[SEN_OV6620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV6630] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV66308AF] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620AE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7640] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7648] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7660] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7670] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV76BE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV8610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t},\n\t[SEN_OV9600] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n};\n\nstatic const struct v4l2_pix_format ov519_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov519_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n/* Note some of the sizeimage values for the ov511 / ov518 may seem\n   larger then necessary, however they need to be this big as the ov511 /\n   ov518 always fills the entire isoc frame, using 0 padding bytes when\n   it doesn't have any data. So with low framerates the amount of data\n   transferred can become quite large (libv4l will remove all the 0 padding\n   in userspace). */\nstatic const struct v4l2_pix_format ov518_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov518_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ov511_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov511_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ovfx2_ov2610_mode[] = {\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\nstatic const struct v4l2_pix_format ovfx2_ov3610_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1024, 768, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1024,\n\t\t.sizeimage = 1024 * 768,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{2048, 1536, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 2048,\n\t\t.sizeimage = 2048 * 1536,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ovfx2_ov9600_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1280, 1024, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\n\n/* Registers common to OV511 / OV518 */\n#define R51x_FIFO_PSIZE\t\t\t0x30\t/* 2 bytes wide w/ OV518(+) */\n#define R51x_SYS_RESET\t\t\t0x50\n\t/* Reset type flags */\n\t#define\tOV511_RESET_OMNICE\t0x08\n#define R51x_SYS_INIT\t\t\t0x53\n#define R51x_SYS_SNAP\t\t\t0x52\n#define R51x_SYS_CUST_ID\t\t0x5f\n#define R51x_COMP_LUT_BEGIN\t\t0x80\n\n/* OV511 Camera interface register numbers */\n#define R511_CAM_DELAY\t\t\t0x10\n#define R511_CAM_EDGE\t\t\t0x11\n#define R511_CAM_PXCNT\t\t\t0x12\n#define R511_CAM_LNCNT\t\t\t0x13\n#define R511_CAM_PXDIV\t\t\t0x14\n#define R511_CAM_LNDIV\t\t\t0x15\n#define R511_CAM_UV_EN\t\t\t0x16\n#define R511_CAM_LINE_MODE\t\t0x17\n#define R511_CAM_OPTS\t\t\t0x18\n\n#define R511_SNAP_FRAME\t\t\t0x19\n#define R511_SNAP_PXCNT\t\t\t0x1a\n#define R511_SNAP_LNCNT\t\t\t0x1b\n#define R511_SNAP_PXDIV\t\t\t0x1c\n#define R511_SNAP_LNDIV\t\t\t0x1d\n#define R511_SNAP_UV_EN\t\t\t0x1e\n#define R511_SNAP_OPTS\t\t\t0x1f\n\n#define R511_DRAM_FLOW_CTL\t\t0x20\n#define R511_FIFO_OPTS\t\t\t0x31\n#define R511_I2C_CTL\t\t\t0x40\n#define R511_SYS_LED_CTL\t\t0x55\t/* OV511+ only */\n#define R511_COMP_EN\t\t\t0x78\n#define R511_COMP_LUT_EN\t\t0x79\n\n/* OV518 Camera interface register numbers */\n#define R518_GPIO_OUT\t\t\t0x56\t/* OV518(+) only */\n#define R518_GPIO_CTL\t\t\t0x57\t/* OV518(+) only */\n\n/* OV519 Camera interface register numbers */\n#define OV519_R10_H_SIZE\t\t0x10\n#define OV519_R11_V_SIZE\t\t0x11\n#define OV519_R12_X_OFFSETL\t\t0x12\n#define OV519_R13_X_OFFSETH\t\t0x13\n#define OV519_R14_Y_OFFSETL\t\t0x14\n#define OV519_R15_Y_OFFSETH\t\t0x15\n#define OV519_R16_DIVIDER\t\t0x16\n#define OV519_R20_DFR\t\t\t0x20\n#define OV519_R25_FORMAT\t\t0x25\n\n/* OV519 System Controller register numbers */\n#define OV519_R51_RESET1\t\t0x51\n#define OV519_R54_EN_CLK1\t\t0x54\n#define OV519_R57_SNAPSHOT\t\t0x57\n\n#define OV519_GPIO_DATA_OUT0\t\t0x71\n#define OV519_GPIO_IO_CTRL0\t\t0x72\n\n/*#define OV511_ENDPOINT_ADDRESS 1\t * Isoc endpoint number */\n\n/*\n * The FX2 chip does not give us a zero length read at end of frame.\n * It does, however, give a short read at the end of a frame, if\n * necessary, rather than run two frames together.\n *\n * By choosing the right bulk transfer size, we are guaranteed to always\n * get a short read for the last read of each frame.  Frame sizes are\n * always a composite number (width * height, or a multiple) so if we\n * choose a prime number, we are guaranteed that the last read of a\n * frame will be short.\n *\n * But it isn't that easy: the 2.6 kernel requires a multiple of 4KB,\n * otherwise EOVERFLOW \"babbling\" errors occur.  I have not been able\n * to figure out why.  [PMiller]\n *\n * The constant (13 * 4096) is the largest \"prime enough\" number less than 64KB.\n *\n * It isn't enough to know the number of bytes per frame, in case we\n * have data dropouts or buffer overruns (even though the FX2 double\n * buffers, there are some pretty strict real time constraints for\n * isochronous transfer for larger frame sizes).\n */\n/*jfm: this value does not work for 800x600 - see isoc_init */\n#define OVFX2_BULK_SIZE (13 * 4096)\n\n/* I2C registers */\n#define R51x_I2C_W_SID\t\t0x41\n#define R51x_I2C_SADDR_3\t0x42\n#define R51x_I2C_SADDR_2\t0x43\n#define R51x_I2C_R_SID\t\t0x44\n#define R51x_I2C_DATA\t\t0x45\n#define R518_I2C_CTL\t\t0x47\t/* OV518(+) only */\n#define OVFX2_I2C_ADDR\t\t0x00\n\n/* I2C ADDRESSES */\n#define OV7xx0_SID   0x42\n#define OV_HIRES_SID 0x60\t\t/* OV9xxx / OV2xxx / OV3xxx */\n#define OV8xx0_SID   0xa0\n#define OV6xx0_SID   0xc0\n\n/* OV7610 registers */\n#define OV7610_REG_GAIN\t\t0x00\t/* gain setting (5:0) */\n#define OV7610_REG_BLUE\t\t0x01\t/* blue channel balance */\n#define OV7610_REG_RED\t\t0x02\t/* red channel balance */\n#define OV7610_REG_SAT\t\t0x03\t/* saturation */\n#define OV8610_REG_HUE\t\t0x04\t/* 04 reserved */\n#define OV7610_REG_CNT\t\t0x05\t/* Y contrast */\n#define OV7610_REG_BRT\t\t0x06\t/* Y brightness */\n#define OV7610_REG_COM_C\t0x14\t/* misc common regs */\n#define OV7610_REG_ID_HIGH\t0x1c\t/* manufacturer ID MSB */\n#define OV7610_REG_ID_LOW\t0x1d\t/* manufacturer ID LSB */\n#define OV7610_REG_COM_I\t0x29\t/* misc settings */\n\n/* OV7660 and OV7670 registers */\n#define OV7670_R00_GAIN\t\t0x00\t/* Gain lower 8 bits (rest in vref) */\n#define OV7670_R01_BLUE\t\t0x01\t/* blue gain */\n#define OV7670_R02_RED\t\t0x02\t/* red gain */\n#define OV7670_R03_VREF\t\t0x03\t/* Pieces of GAIN, VSTART, VSTOP */\n#define OV7670_R04_COM1\t\t0x04\t/* Control 1 */\n/*#define OV7670_R07_AECHH\t0x07\t * AEC MS 5 bits */\n#define OV7670_R0C_COM3\t\t0x0c\t/* Control 3 */\n#define OV7670_R0D_COM4\t\t0x0d\t/* Control 4 */\n#define OV7670_R0E_COM5\t\t0x0e\t/* All \"reserved\" */\n#define OV7670_R0F_COM6\t\t0x0f\t/* Control 6 */\n#define OV7670_R10_AECH\t\t0x10\t/* More bits of AEC value */\n#define OV7670_R11_CLKRC\t0x11\t/* Clock control */\n#define OV7670_R12_COM7\t\t0x12\t/* Control 7 */\n#define   OV7670_COM7_FMT_VGA\t 0x00\n/*#define   OV7670_COM7_YUV\t 0x00\t * YUV */\n#define   OV7670_COM7_FMT_QVGA\t 0x10\t/* QVGA format */\n#define   OV7670_COM7_FMT_MASK\t 0x38\n#define   OV7670_COM7_RESET\t 0x80\t/* Register reset */\n#define OV7670_R13_COM8\t\t0x13\t/* Control 8 */\n#define   OV7670_COM8_AEC\t 0x01\t/* Auto exposure enable */\n#define   OV7670_COM8_AWB\t 0x02\t/* White balance enable */\n#define   OV7670_COM8_AGC\t 0x04\t/* Auto gain enable */\n#define   OV7670_COM8_BFILT\t 0x20\t/* Band filter enable */\n#define   OV7670_COM8_AECSTEP\t 0x40\t/* Unlimited AEC step size */\n#define   OV7670_COM8_FASTAEC\t 0x80\t/* Enable fast AGC/AEC */\n#define OV7670_R14_COM9\t\t0x14\t/* Control 9 - gain ceiling */\n#define OV7670_R15_COM10\t0x15\t/* Control 10 */\n#define OV7670_R17_HSTART\t0x17\t/* Horiz start high bits */\n#define OV7670_R18_HSTOP\t0x18\t/* Horiz stop high bits */\n#define OV7670_R19_VSTART\t0x19\t/* Vert start high bits */\n#define OV7670_R1A_VSTOP\t0x1a\t/* Vert stop high bits */\n#define OV7670_R1E_MVFP\t\t0x1e\t/* Mirror / vflip */\n#define   OV7670_MVFP_VFLIP\t 0x10\t/* vertical flip */\n#define   OV7670_MVFP_MIRROR\t 0x20\t/* Mirror image */\n#define OV7670_R24_AEW\t\t0x24\t/* AGC upper limit */\n#define OV7670_R25_AEB\t\t0x25\t/* AGC lower limit */\n#define OV7670_R26_VPT\t\t0x26\t/* AGC/AEC fast mode op region */\n#define OV7670_R32_HREF\t\t0x32\t/* HREF pieces */\n#define OV7670_R3A_TSLB\t\t0x3a\t/* lots of stuff */\n#define OV7670_R3B_COM11\t0x3b\t/* Control 11 */\n#define   OV7670_COM11_EXP\t 0x02\n#define   OV7670_COM11_HZAUTO\t 0x10\t/* Auto detect 50/60 Hz */\n#define OV7670_R3C_COM12\t0x3c\t/* Control 12 */\n#define OV7670_R3D_COM13\t0x3d\t/* Control 13 */\n#define   OV7670_COM13_GAMMA\t 0x80\t/* Gamma enable */\n#define   OV7670_COM13_UVSAT\t 0x40\t/* UV saturation auto adjustment */\n#define OV7670_R3E_COM14\t0x3e\t/* Control 14 */\n#define OV7670_R3F_EDGE\t\t0x3f\t/* Edge enhancement factor */\n#define OV7670_R40_COM15\t0x40\t/* Control 15 */\n/*#define   OV7670_COM15_R00FF\t 0xc0\t *\t00 to FF */\n#define OV7670_R41_COM16\t0x41\t/* Control 16 */\n#define   OV7670_COM16_AWBGAIN\t 0x08\t/* AWB gain enable */\n/* end of ov7660 common registers */\n#define OV7670_R55_BRIGHT\t0x55\t/* Brightness */\n#define OV7670_R56_CONTRAS\t0x56\t/* Contrast control */\n#define OV7670_R69_GFIX\t\t0x69\t/* Fix gain control */\n/*#define OV7670_R8C_RGB444\t0x8c\t * RGB 444 control */\n#define OV7670_R9F_HAECC1\t0x9f\t/* Hist AEC/AGC control 1 */\n#define OV7670_RA0_HAECC2\t0xa0\t/* Hist AEC/AGC control 2 */\n#define OV7670_RA5_BD50MAX\t0xa5\t/* 50hz banding step limit */\n#define OV7670_RA6_HAECC3\t0xa6\t/* Hist AEC/AGC control 3 */\n#define OV7670_RA7_HAECC4\t0xa7\t/* Hist AEC/AGC control 4 */\n#define OV7670_RA8_HAECC5\t0xa8\t/* Hist AEC/AGC control 5 */\n#define OV7670_RA9_HAECC6\t0xa9\t/* Hist AEC/AGC control 6 */\n#define OV7670_RAA_HAECC7\t0xaa\t/* Hist AEC/AGC control 7 */\n#define OV7670_RAB_BD60MAX\t0xab\t/* 60hz banding step limit */\n\nstruct ov_regvals {\n\tu8 reg;\n\tu8 val;\n};\nstruct ov_i2c_regvals {\n\tu8 reg;\n\tu8 val;\n};\n\n/* Settings for OV2610 camera chip */\nstatic const struct ov_i2c_regvals norm_2610[] = {\n\t{ 0x12, 0x80 },\t/* reset */\n};\n\nstatic const struct ov_i2c_regvals norm_2610ae[] = {\n\t{0x12, 0x80},\t/* reset */\n\t{0x13, 0xcd},\n\t{0x09, 0x01},\n\t{0x0d, 0x00},\n\t{0x11, 0x80},\n\t{0x12, 0x20},\t/* 1600x1200 */\n\t{0x33, 0x0c},\n\t{0x35, 0x90},\n\t{0x36, 0x37},\n/* ms-win traces */\n\t{0x11, 0x83},\t/* clock / 3 ? */\n\t{0x2d, 0x00},\t/* 60 Hz filter */\n\t{0x24, 0xb0},\t/* normal colors */\n\t{0x25, 0x90},\n\t{0x10, 0x43},\n};\n\nstatic const struct ov_i2c_regvals norm_3620b[] = {\n\t/*\n\t * From the datasheet: \"Note that after writing to register COMH\n\t * (0x12) to change the sensor mode, registers related to the\n\t * sensor\u2019s cropping window will be reset back to their default\n\t * values.\"\n\t *\n\t * \"wait 4096 external clock ... to make sure the sensor is\n\t * stable and ready to access registers\" i.e. 160us at 24MHz\n\t */\n\t{ 0x12, 0x80 }, /* COMH reset */\n\t{ 0x12, 0x00 }, /* QXGA, master */\n\n\t/*\n\t * 11 CLKRC \"Clock Rate Control\"\n\t * [7] internal frequency doublers: on\n\t * [6] video port mode: master\n\t * [5:0] clock divider: 1\n\t */\n\t{ 0x11, 0x80 },\n\n\t/*\n\t * 13 COMI \"Common Control I\"\n\t *                  = 192 (0xC0) 11000000\n\t *    COMI[7] \"AEC speed selection\"\n\t *                  =   1 (0x01) 1....... \"Faster AEC correction\"\n\t *    COMI[6] \"AEC speed step selection\"\n\t *                  =   1 (0x01) .1...... \"Big steps, fast\"\n\t *    COMI[5] \"Banding filter on off\"\n\t *                  =   0 (0x00) ..0..... \"Off\"\n\t *    COMI[4] \"Banding filter option\"\n\t *                  =   0 (0x00) ...0.... \"Main clock is 48 MHz and\n\t *                                         the PLL is ON\"\n\t *    COMI[3] \"Reserved\"\n\t *                  =   0 (0x00) ....0...\n\t *    COMI[2] \"AGC auto manual control selection\"\n\t *                  =   0 (0x00) .....0.. \"Manual\"\n\t *    COMI[1] \"AWB auto manual control selection\"\n\t *                  =   0 (0x00) ......0. \"Manual\"\n\t *    COMI[0] \"Exposure control\"\n\t *                  =   0 (0x00) .......0 \"Manual\"\n\t */\n\t{ 0x13, 0xc0 },\n\n\t/*\n\t * 09 COMC \"Common Control C\"\n\t *                  =   8 (0x08) 00001000\n\t *    COMC[7:5] \"Reserved\"\n\t *                  =   0 (0x00) 000.....\n\t *    COMC[4] \"Sleep Mode Enable\"\n\t *                  =   0 (0x00) ...0.... \"Normal mode\"\n\t *    COMC[3:2] \"Sensor sampling reset timing selection\"\n\t *                  =   2 (0x02) ....10.. \"Longer reset time\"\n\t *    COMC[1:0] \"Output drive current select\"\n\t *                  =   0 (0x00) ......00 \"Weakest\"\n\t */\n\t{ 0x09, 0x08 },\n\n\t/*\n\t * 0C COMD \"Common Control D\"\n\t *                  =   8 (0x08) 00001000\n\t *    COMD[7] \"Reserved\"\n\t *                  =   0 (0x00) 0.......\n\t *    COMD[6] \"Swap MSB and LSB at the output port\"\n\t *                  =   0 (0x00) .0...... \"False\"\n\t *    COMD[5:3] \"Reserved\"\n\t *                  =   1 (0x01) ..001...\n\t *    COMD[2] \"Output Average On Off\"\n\t *                  =   0 (0x00) .....0.. \"Output Normal\"\n\t *    COMD[1] \"Sensor precharge voltage selection\"\n\t *                  =   0 (0x00) ......0. \"Selects internal\n\t *                                         reference precharge\n\t *                                         voltage\"\n\t *    COMD[0] \"Snapshot option\"\n\t *                  =   0 (0x00) .......0 \"Enable live video output\n\t *                                         after snapshot sequence\"\n\t */\n\t{ 0x0c, 0x08 },\n\n\t/*\n\t * 0D COME \"Common Control E\"\n\t *                  = 161 (0xA1) 10100001\n\t *    COME[7] \"Output average option\"\n\t *                  =   1 (0x01) 1....... \"Output average of 4 pixels\"\n\t *    COME[6] \"Anti-blooming control\"\n\t *                  =   0 (0x00) .0...... \"Off\"\n\t *    COME[5:3] \"Reserved\"\n\t *                  =   4 (0x04) ..100...\n\t *    COME[2] \"Clock output power down pin status\"\n\t *                  =   0 (0x00) .....0.. \"Tri-state data output pin\n\t *                                         on power down\"\n\t *    COME[1] \"Data output pin status selection at power down\"\n\t *                  =   0 (0x00) ......0. \"Tri-state VSYNC, PCLK,\n\t *                                         HREF, and CHSYNC pins on\n\t *                                         power down\"\n\t *    COME[0] \"Auto zero circuit select\"\n\t *                  =   1 (0x01) .......1 \"On\"\n\t */\n\t{ 0x0d, 0xa1 },\n\n\t/*\n\t * 0E COMF \"Common Control F\"\n\t *                  = 112 (0x70) 01110000\n\t *    COMF[7] \"System clock selection\"\n\t *                  =   0 (0x00) 0....... \"Use 24 MHz system clock\"\n\t *    COMF[6:4] \"Reserved\"\n\t *                  =   7 (0x07) .111....\n\t *    COMF[3] \"Manual auto negative offset canceling selection\"\n\t *                  =   0 (0x00) ....0... \"Auto detect negative\n\t *                                         offset and cancel it\"\n\t *    COMF[2:0] \"Reserved\"\n\t *                  =   0 (0x00) .....000\n\t */\n\t{ 0x0e, 0x70 },\n\n\t/*\n\t * 0F COMG \"Common Control G\"\n\t *                  =  66 (0x42) 01000010\n\t *    COMG[7] \"Optical black output selection\"\n\t *                  =   0 (0x00) 0....... \"Disable\"\n\t *    COMG[6] \"Black level calibrate selection\"\n\t *                  =   1 (0x01) .1...... \"Use optical black pixels\n\t *                                         to calibrate\"\n\t *    COMG[5:4] \"Reserved\"\n\t *                  =   0 (0x00) ..00....\n\t *    COMG[3] \"Channel offset adjustment\"\n\t *                  =   0 (0x00) ....0... \"Disable offset adjustment\"\n\t *    COMG[2] \"ADC black level calibration option\"\n\t *                  =   0 (0x00) .....0.. \"Use B/G line and G/R\n\t *                                         line to calibrate each\n\t *                                         channel's black level\"\n\t *    COMG[1] \"Reserved\"\n\t *                  =   1 (0x01) ......1.\n\t *    COMG[0] \"ADC black level calibration enable\"\n\t *                  =   0 (0x00) .......0 \"Disable\"\n\t */\n\t{ 0x0f, 0x42 },\n\n\t/*\n\t * 14 COMJ \"Common Control J\"\n\t *                  = 198 (0xC6) 11000110\n\t *    COMJ[7:6] \"AGC gain ceiling\"\n\t *                  =   3 (0x03) 11...... \"8x\"\n\t *    COMJ[5:4] \"Reserved\"\n\t *                  =   0 (0x00) ..00....\n\t *    COMJ[3] \"Auto banding filter\"\n\t *                  =   0 (0x00) ....0... \"Banding filter is always\n\t *                                         on off depending on\n\t *                                         COMI[5] setting\"\n\t *    COMJ[2] \"VSYNC drop option\"\n\t *                  =   1 (0x01) .....1.. \"SYNC is dropped if frame\n\t *                                         data is dropped\"\n\t *    COMJ[1] \"Frame data drop\"\n\t *                  =   1 (0x01) ......1. \"Drop frame data if\n\t *                                         exposure is not within\n\t *                                         tolerance.  In AEC mode,\n\t *                                         data is normally dropped\n\t *                                         when data is out of\n\t *                                         range.\"\n\t *    COMJ[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x14, 0xc6 },\n\n\t/*\n\t * 15 COMK \"Common Control K\"\n\t *                  =   2 (0x02) 00000010\n\t *    COMK[7] \"CHSYNC pin output swap\"\n\t *                  =   0 (0x00) 0....... \"CHSYNC\"\n\t *    COMK[6] \"HREF pin output swap\"\n\t *                  =   0 (0x00) .0...... \"HREF\"\n\t *    COMK[5] \"PCLK output selection\"\n\t *                  =   0 (0x00) ..0..... \"PCLK always output\"\n\t *    COMK[4] \"PCLK edge selection\"\n\t *                  =   0 (0x00) ...0.... \"Data valid on falling edge\"\n\t *    COMK[3] \"HREF output polarity\"\n\t *                  =   0 (0x00) ....0... \"positive\"\n\t *    COMK[2] \"Reserved\"\n\t *                  =   0 (0x00) .....0..\n\t *    COMK[1] \"VSYNC polarity\"\n\t *                  =   1 (0x01) ......1. \"negative\"\n\t *    COMK[0] \"HSYNC polarity\"\n\t *                  =   0 (0x00) .......0 \"positive\"\n\t */\n\t{ 0x15, 0x02 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =   9 (0x09) 00001001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   0 (0x00) ...0.... \"normal current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x09 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  80 (0x50) 01010000\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x34, 0x50 },\n\n\t/*\n\t * 36 VCHG \"Sensor Precharge Voltage Control\"\n\t *                  =   0 (0x00) 00000000\n\t *    VCHG[7] \"Reserved\"\n\t *                  =   0 (0x00) 0.......\n\t *    VCHG[6:4] \"Sensor precharge voltage control\"\n\t *                  =   0 (0x00) .000....\n\t *    VCHG[3:0] \"Sensor array common reference\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x36, 0x00 },\n\n\t/*\n\t * 37 ADC \"ADC Reference Control\"\n\t *                  =   4 (0x04) 00000100\n\t *    ADC[7:4] \"Reserved\"\n\t *                  =   0 (0x00) 0000....\n\t *    ADC[3] \"ADC input signal range\"\n\t *                  =   0 (0x00) ....0... \"Input signal 1.0x\"\n\t *    ADC[2:0] \"ADC range control\"\n\t *                  =   4 (0x04) .....100\n\t */\n\t{ 0x37, 0x04 },\n\n\t/*\n\t * 38 ACOM \"Analog Common Ground\"\n\t *                  =  82 (0x52) 01010010\n\t *    ACOM[7] \"Analog gain control\"\n\t *                  =   0 (0x00) 0....... \"Gain 1x\"\n\t *    ACOM[6] \"Analog black level calibration\"\n\t *                  =   1 (0x01) .1...... \"On\"\n\t *    ACOM[5:0] \"Reserved\"\n\t *                  =  18 (0x12) ..010010\n\t */\n\t{ 0x38, 0x52 },\n\n\t/*\n\t * 3A FREFA \"Internal Reference Adjustment\"\n\t *                  =   0 (0x00) 00000000\n\t *    FREFA[7:0] \"Range\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3a, 0x00 },\n\n\t/*\n\t * 3C FVOPT \"Internal Reference Adjustment\"\n\t *                  =  31 (0x1F) 00011111\n\t *    FVOPT[7:0] \"Range\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x3c, 0x1f },\n\n\t/*\n\t * 44 Undocumented  =   0 (0x00) 00000000\n\t *    44[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x44, 0x00 },\n\n\t/*\n\t * 40 Undocumented  =   0 (0x00) 00000000\n\t *    40[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x40, 0x00 },\n\n\t/*\n\t * 41 Undocumented  =   0 (0x00) 00000000\n\t *    41[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x41, 0x00 },\n\n\t/*\n\t * 42 Undocumented  =   0 (0x00) 00000000\n\t *    42[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x42, 0x00 },\n\n\t/*\n\t * 43 Undocumented  =   0 (0x00) 00000000\n\t *    43[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x43, 0x00 },\n\n\t/*\n\t * 45 Undocumented  = 128 (0x80) 10000000\n\t *    45[7:0] \"It's a secret\"\n\t *                  = 128 (0x80) 10000000\n\t */\n\t{ 0x45, 0x80 },\n\n\t/*\n\t * 48 Undocumented  = 192 (0xC0) 11000000\n\t *    48[7:0] \"It's a secret\"\n\t *                  = 192 (0xC0) 11000000\n\t */\n\t{ 0x48, 0xc0 },\n\n\t/*\n\t * 49 Undocumented  =  25 (0x19) 00011001\n\t *    49[7:0] \"It's a secret\"\n\t *                  =  25 (0x19) 00011001\n\t */\n\t{ 0x49, 0x19 },\n\n\t/*\n\t * 4B Undocumented  = 128 (0x80) 10000000\n\t *    4B[7:0] \"It's a secret\"\n\t *                  = 128 (0x80) 10000000\n\t */\n\t{ 0x4b, 0x80 },\n\n\t/*\n\t * 4D Undocumented  = 196 (0xC4) 11000100\n\t *    4D[7:0] \"It's a secret\"\n\t *                  = 196 (0xC4) 11000100\n\t */\n\t{ 0x4d, 0xc4 },\n\n\t/*\n\t * 35 VREF \"Reference Voltage Control\"\n\t *                  =  76 (0x4c) 01001100\n\t *    VREF[7:5] \"Column high reference control\"\n\t *                  =   2 (0x02) 010..... \"higher voltage\"\n\t *    VREF[4:2] \"Column low reference control\"\n\t *                  =   3 (0x03) ...011.. \"Highest voltage\"\n\t *    VREF[1:0] \"Reserved\"\n\t *                  =   0 (0x00) ......00\n\t */\n\t{ 0x35, 0x4c },\n\n\t/*\n\t * 3D Undocumented  =   0 (0x00) 00000000\n\t *    3D[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3d, 0x00 },\n\n\t/*\n\t * 3E Undocumented  =   0 (0x00) 00000000\n\t *    3E[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3e, 0x00 },\n\n\t/*\n\t * 3B FREFB \"Internal Reference Adjustment\"\n\t *                  =  24 (0x18) 00011000\n\t *    FREFB[7:0] \"Range\"\n\t *                  =  24 (0x18) 00011000\n\t */\n\t{ 0x3b, 0x18 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =  25 (0x19) 00011001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   1 (0x01) ...1.... \"double current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x19 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  90 (0x5A) 01011010\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =  10 (0x0A) ....1010\n\t */\n\t{ 0x34, 0x5a },\n\n\t/*\n\t * 3B FREFB \"Internal Reference Adjustment\"\n\t *                  =   0 (0x00) 00000000\n\t *    FREFB[7:0] \"Range\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3b, 0x00 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =   9 (0x09) 00001001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   0 (0x00) ...0.... \"normal current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x09 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  80 (0x50) 01010000\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x34, 0x50 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =  64 (0x40) 01000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   4 (0x04) .100.... \"XGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x40 },\n\n\t/*\n\t * 17 HREFST \"Horizontal window start\"\n\t *                  =  31 (0x1F) 00011111\n\t *    HREFST[7:0] \"Horizontal window start, 8 MSBs\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x17, 0x1f },\n\n\t/*\n\t * 18 HREFEND \"Horizontal window end\"\n\t *                  =  95 (0x5F) 01011111\n\t *    HREFEND[7:0] \"Horizontal Window End, 8 MSBs\"\n\t *                  =  95 (0x5F) 01011111\n\t */\n\t{ 0x18, 0x5f },\n\n\t/*\n\t * 19 VSTRT \"Vertical window start\"\n\t *                  =   0 (0x00) 00000000\n\t *    VSTRT[7:0] \"Vertical Window Start, 8 MSBs\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x19, 0x00 },\n\n\t/*\n\t * 1A VEND \"Vertical window end\"\n\t *                  =  96 (0x60) 01100000\n\t *    VEND[7:0] \"Vertical Window End, 8 MSBs\"\n\t *                  =  96 (0x60) 01100000\n\t */\n\t{ 0x1a, 0x60 },\n\n\t/*\n\t * 32 COMM \"Common Control M\"\n\t *                  =  18 (0x12) 00010010\n\t *    COMM[7:6] \"Pixel clock divide option\"\n\t *                  =   0 (0x00) 00...... \"/1\"\n\t *    COMM[5:3] \"Horizontal window end position, 3 LSBs\"\n\t *                  =   2 (0x02) ..010...\n\t *    COMM[2:0] \"Horizontal window start position, 3 LSBs\"\n\t *                  =   2 (0x02) .....010\n\t */\n\t{ 0x32, 0x12 },\n\n\t/*\n\t * 03 COMA \"Common Control A\"\n\t *                  =  74 (0x4A) 01001010\n\t *    COMA[7:4] \"AWB Update Threshold\"\n\t *                  =   4 (0x04) 0100....\n\t *    COMA[3:2] \"Vertical window end line control 2 LSBs\"\n\t *                  =   2 (0x02) ....10..\n\t *    COMA[1:0] \"Vertical window start line control 2 LSBs\"\n\t *                  =   2 (0x02) ......10\n\t */\n\t{ 0x03, 0x4a },\n\n\t/*\n\t * 11 CLKRC \"Clock Rate Control\"\n\t *                  = 128 (0x80) 10000000\n\t *    CLKRC[7] \"Internal frequency doublers on off seclection\"\n\t *                  =   1 (0x01) 1....... \"On\"\n\t *    CLKRC[6] \"Digital video master slave selection\"\n\t *                  =   0 (0x00) .0...... \"Master mode, sensor\n\t *                                         provides PCLK\"\n\t *    CLKRC[5:0] \"Clock divider { CLK = PCLK/(1+CLKRC[5:0]) }\"\n\t *                  =   0 (0x00) ..000000\n\t */\n\t{ 0x11, 0x80 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =   0 (0x00) 00000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   0 (0x00) .000.... \"QXGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x00 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =  64 (0x40) 01000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   4 (0x04) .100.... \"XGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x40 },\n\n\t/*\n\t * 17 HREFST \"Horizontal window start\"\n\t *                  =  31 (0x1F) 00011111\n\t *    HREFST[7:0] \"Horizontal window start, 8 MSBs\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x17, 0x1f },\n\n\t/*\n\t * 18 HREFEND \"Horizontal window end\"\n\t *                  =  95 (0x5F) 01011111\n\t *    HREFEND[7:0] \"Horizontal Window End, 8 MSBs\"\n\t *                  =  95 (0x5F) 01011111\n\t */\n\t{ 0x18, 0x5f },\n\n\t/*\n\t * 19 VSTRT \"Vertical window start\"\n\t *                  =   0 (0x00) 00000000\n\t *    VSTRT[7:0] \"Vertical Window Start, 8 MSBs\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x19, 0x00 },\n\n\t/*\n\t * 1A VEND \"Vertical window end\"\n\t *                  =  96 (0x60) 01100000\n\t *    VEND[7:0] \"Vertical Window End, 8 MSBs\"\n\t *                  =  96 (0x60) 01100000\n\t */\n\t{ 0x1a, 0x60 },\n\n\t/*\n\t * 32 COMM \"Common Control M\"\n\t *                  =  18 (0x12) 00010010\n\t *    COMM[7:6] \"Pixel clock divide option\"\n\t *                  =   0 (0x00) 00...... \"/1\"\n\t *    COMM[5:3] \"Horizontal window end position, 3 LSBs\"\n\t *                  =   2 (0x02) ..010...\n\t *    COMM[2:0] \"Horizontal window start position, 3 LSBs\"\n\t *                  =   2 (0x02) .....010\n\t */\n\t{ 0x32, 0x12 },\n\n\t/*\n\t * 03 COMA \"Common Control A\"\n\t *                  =  74 (0x4A) 01001010\n\t *    COMA[7:4] \"AWB Update Threshold\"\n\t *                  =   4 (0x04) 0100....\n\t *    COMA[3:2] \"Vertical window end line control 2 LSBs\"\n\t *                  =   2 (0x02) ....10..\n\t *    COMA[1:0] \"Vertical window start line control 2 LSBs\"\n\t *                  =   2 (0x02) ......10\n\t */\n\t{ 0x03, 0x4a },\n\n\t/*\n\t * 02 RED \"Red Gain Control\"\n\t *                  = 175 (0xAF) 10101111\n\t *    RED[7] \"Action\"\n\t *                  =   1 (0x01) 1....... \"gain = 1/(1+bitrev([6:0]))\"\n\t *    RED[6:0] \"Value\"\n\t *                  =  47 (0x2F) .0101111\n\t */\n\t{ 0x02, 0xaf },\n\n\t/*\n\t * 2D ADDVSL \"VSYNC Pulse Width\"\n\t *                  = 210 (0xD2) 11010010\n\t *    ADDVSL[7:0] \"VSYNC pulse width, LSB\"\n\t *                  = 210 (0xD2) 11010010\n\t */\n\t{ 0x2d, 0xd2 },\n\n\t/*\n\t * 00 GAIN          =  24 (0x18) 00011000\n\t *    GAIN[7:6] \"Reserved\"\n\t *                  =   0 (0x00) 00......\n\t *    GAIN[5] \"Double\"\n\t *                  =   0 (0x00) ..0..... \"False\"\n\t *    GAIN[4] \"Double\"\n\t *                  =   1 (0x01) ...1.... \"True\"\n\t *    GAIN[3:0] \"Range\"\n\t *                  =   8 (0x08) ....1000\n\t */\n\t{ 0x00, 0x18 },\n\n\t/*\n\t * 01 BLUE \"Blue Gain Control\"\n\t *                  = 240 (0xF0) 11110000\n\t *    BLUE[7] \"Action\"\n\t *                  =   1 (0x01) 1....... \"gain = 1/(1+bitrev([6:0]))\"\n\t *    BLUE[6:0] \"Value\"\n\t *                  = 112 (0x70) .1110000\n\t */\n\t{ 0x01, 0xf0 },\n\n\t/*\n\t * 10 AEC \"Automatic Exposure Control\"\n\t *                  =  10 (0x0A) 00001010\n\t *    AEC[7:0] \"Automatic Exposure Control, 8 MSBs\"\n\t *                  =  10 (0x0A) 00001010\n\t */\n\t{ 0x10, 0x0a },\n\n\t{ 0xe1, 0x67 },\n\t{ 0xe3, 0x03 },\n\t{ 0xe4, 0x26 },\n\t{ 0xe5, 0x3e },\n\t{ 0xf8, 0x01 },\n\t{ 0xff, 0x01 },\n};\n\nstatic const struct ov_i2c_regvals norm_6x20[] = {\n\t{ 0x12, 0x80 }, /* reset */\n\t{ 0x11, 0x01 },\n\t{ 0x03, 0x60 },\n\t{ 0x05, 0x7f }, /* For when autoadjust is off */\n\t{ 0x07, 0xa8 },\n\t/* The ratio of 0x0c and 0x0d controls the white point */\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x0f, 0x15 }, /* COMS */\n\t{ 0x10, 0x75 }, /* AEC Exposure time */\n\t{ 0x12, 0x24 }, /* Enable AGC */\n\t{ 0x14, 0x04 },\n\t/* 0x16: 0x06 helps frame stability with moving objects */\n\t{ 0x16, 0x06 },\n/*\t{ 0x20, 0x30 },  * Aperture correction enable */\n\t{ 0x26, 0xb2 }, /* BLC enable */\n\t/* 0x28: 0x05 Selects RGB format if RGB on */\n\t{ 0x28, 0x05 },\n\t{ 0x2a, 0x04 }, /* Disable framerate adjust */\n/*\t{ 0x2b, 0xac },  * Framerate; Set 2a[7] first */\n\t{ 0x2d, 0x85 },\n\t{ 0x33, 0xa0 }, /* Color Processing Parameter */\n\t{ 0x34, 0xd2 }, /* Max A/D range */\n\t{ 0x38, 0x8b },\n\t{ 0x39, 0x40 },\n\n\t{ 0x3c, 0x39 }, /* Enable AEC mode changing */\n\t{ 0x3c, 0x3c }, /* Change AEC mode */\n\t{ 0x3c, 0x24 }, /* Disable AEC mode changing */\n\n\t{ 0x3d, 0x80 },\n\t/* These next two registers (0x4a, 0x4b) are undocumented.\n\t * They control the color balance */\n\t{ 0x4a, 0x80 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4d, 0xd2 }, /* This reduces noise a bit */\n\t{ 0x4e, 0xc1 },\n\t{ 0x4f, 0x04 },\n/* Do 50-53 have any effect? */\n/* Toggle 0x12[2] off and on here? */\n};\n\nstatic const struct ov_i2c_regvals norm_6x30[] = {\n\t{ 0x12, 0x80 }, /* Reset */\n\t{ 0x00, 0x1f }, /* Gain */\n\t{ 0x01, 0x99 }, /* Blue gain */\n\t{ 0x02, 0x7c }, /* Red gain */\n\t{ 0x03, 0xc0 }, /* Saturation */\n\t{ 0x05, 0x0a }, /* Contrast */\n\t{ 0x06, 0x95 }, /* Brightness */\n\t{ 0x07, 0x2d }, /* Sharpness */\n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x0e, 0xa0 }, /* Was 0x20, bit7 enables a 2x gain which we need */\n\t{ 0x0f, 0x05 },\n\t{ 0x10, 0x9a },\n\t{ 0x11, 0x00 }, /* Pixel clock = fastest */\n\t{ 0x12, 0x24 }, /* Enable AGC and AWB */\n\t{ 0x13, 0x21 },\n\t{ 0x14, 0x80 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 },\n\t{ 0x18, 0xea },\n\t{ 0x19, 0x04 },\n\t{ 0x1a, 0x93 },\n\t{ 0x1b, 0x00 },\n\t{ 0x1e, 0xc4 },\n\t{ 0x1f, 0x04 },\n\t{ 0x20, 0x20 },\n\t{ 0x21, 0x10 },\n\t{ 0x22, 0x88 },\n\t{ 0x23, 0xc0 }, /* Crystal circuit power level */\n\t{ 0x25, 0x9a }, /* Increase AEC black ratio */\n\t{ 0x26, 0xb2 }, /* BLC enable */\n\t{ 0x27, 0xa2 },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x84 }, /* 60 Hz power */\n\t{ 0x2b, 0xa8 }, /* 60 Hz power */\n\t{ 0x2c, 0xa0 },\n\t{ 0x2d, 0x95 }, /* Enable auto-brightness */\n\t{ 0x2e, 0x88 },\n\t{ 0x33, 0x26 },\n\t{ 0x34, 0x03 },\n\t{ 0x36, 0x8f },\n\t{ 0x37, 0x80 },\n\t{ 0x38, 0x83 },\n\t{ 0x39, 0x80 },\n\t{ 0x3a, 0x0f },\n\t{ 0x3b, 0x3c },\n\t{ 0x3c, 0x1a },\n\t{ 0x3d, 0x80 },\n\t{ 0x3e, 0x80 },\n\t{ 0x3f, 0x0e },\n\t{ 0x40, 0x00 }, /* White bal */\n\t{ 0x41, 0x00 }, /* White bal */\n\t{ 0x42, 0x80 },\n\t{ 0x43, 0x3f }, /* White bal */\n\t{ 0x44, 0x80 },\n\t{ 0x45, 0x20 },\n\t{ 0x46, 0x20 },\n\t{ 0x47, 0x80 },\n\t{ 0x48, 0x7f },\n\t{ 0x49, 0x00 },\n\t{ 0x4a, 0x00 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4c, 0xd0 },\n\t{ 0x4d, 0x10 }, /* U = 0.563u, V = 0.714v */\n\t{ 0x4e, 0x40 },\n\t{ 0x4f, 0x07 }, /* UV avg., col. killer: max */\n\t{ 0x50, 0xff },\n\t{ 0x54, 0x23 }, /* Max AGC gain: 18dB */\n\t{ 0x55, 0xff },\n\t{ 0x56, 0x12 },\n\t{ 0x57, 0x81 },\n\t{ 0x58, 0x75 },\n\t{ 0x59, 0x01 }, /* AGC dark current comp.: +1 */\n\t{ 0x5a, 0x2c },\n\t{ 0x5b, 0x0f }, /* AWB chrominance levels */\n\t{ 0x5c, 0x10 },\n\t{ 0x3d, 0x80 },\n\t{ 0x27, 0xa6 },\n\t{ 0x12, 0x20 }, /* Toggle AWB */\n\t{ 0x12, 0x24 },\n};\n\n/* Lawrence Glaister <lg@jfm.bc.ca> reports:\n *\n * Register 0x0f in the 7610 has the following effects:\n *\n * 0x85 (AEC method 1): Best overall, good contrast range\n * 0x45 (AEC method 2): Very overexposed\n * 0xa5 (spec sheet default): Ok, but the black level is\n *\tshifted resulting in loss of contrast\n * 0x05 (old driver setting): very overexposed, too much\n *\tcontrast\n */\nstatic const struct ov_i2c_regvals norm_7610[] = {\n\t{ 0x10, 0xff },\n\t{ 0x16, 0x06 },\n\t{ 0x28, 0x24 },\n\t{ 0x2b, 0xac },\n\t{ 0x12, 0x00 },\n\t{ 0x38, 0x81 },\n\t{ 0x28, 0x24 },\t/* 0c */\n\t{ 0x0f, 0x85 },\t/* lg's setting */\n\t{ 0x15, 0x01 },\n\t{ 0x20, 0x1c },\n\t{ 0x23, 0x2a },\n\t{ 0x24, 0x10 },\n\t{ 0x25, 0x8a },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xc2 },\n\t{ 0x2a, 0x04 },\n\t{ 0x2c, 0xfe },\n\t{ 0x2d, 0x93 },\n\t{ 0x30, 0x71 },\n\t{ 0x31, 0x60 },\n\t{ 0x32, 0x26 },\n\t{ 0x33, 0x20 },\n\t{ 0x34, 0x48 },\n\t{ 0x12, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n};\n\nstatic const struct ov_i2c_regvals norm_7620[] = {\n\t{ 0x12, 0x80 },\t\t/* reset */\n\t{ 0x00, 0x00 },\t\t/* gain */\n\t{ 0x01, 0x80 },\t\t/* blue gain */\n\t{ 0x02, 0x80 },\t\t/* red gain */\n\t{ 0x03, 0xc0 },\t\t/* OV7670_R03_VREF */\n\t{ 0x06, 0x60 },\n\t{ 0x07, 0x00 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x24 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x84 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x2f },\n\t{ 0x18, 0xcf },\n\t{ 0x19, 0x06 },\n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0x18 },\n\t{ 0x21, 0x80 },\n\t{ 0x22, 0x80 },\n\t{ 0x23, 0x00 },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x22 }, /* Was 0x20, bit1 enables a 2x gain which we need */\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x10 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x88 },\n\t{ 0x2d, 0x91 },\n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x44 },\n\t{ 0x60, 0x27 },\n\t{ 0x61, 0x02 },\n\t{ 0x62, 0x5f },\n\t{ 0x63, 0xd5 },\n\t{ 0x64, 0x57 },\n\t{ 0x65, 0x83 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0x92 },\n\t{ 0x68, 0xcf },\n\t{ 0x69, 0x76 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x02 },\n\t{ 0x6d, 0x44 },\n\t{ 0x6e, 0x80 },\n\t{ 0x6f, 0x1d },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 },\n\t{ 0x75, 0x8e },\n\t{ 0x76, 0x00 },\n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0xe2 },\n\t{ 0x7c, 0x00 },\n};\n\n/* 7640 and 7648. The defaults should be OK for most registers. */\nstatic const struct ov_i2c_regvals norm_7640[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x12, 0x14 },\n};\n\nstatic const struct ov_regvals init_519_ov7660[] = {\n\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t{ 0x53,\t0x9b }, /* 0x9f enables the (unused) microcontroller */\n\t{ 0x54,\t0x0f }, /* bit2 (jpeg enable) */\n\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t{ 0xa3,\t0x18 },\n\t{ 0xa4,\t0x04 },\n\t{ 0xa5,\t0x28 },\n\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t{ 0x20,\t0x0c },\t/* 0x0d does U <-> V swap */\n\t{ 0x21,\t0x38 },\n\t{ 0x22,\t0x1d },\n\t{ 0x17,\t0x50 }, /* undocumented */\n\t{ 0x37,\t0x00 }, /* undocumented */\n\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n};\nstatic const struct ov_i2c_regvals norm_7660[] = {\n\t{OV7670_R12_COM7, OV7670_COM7_RESET},\n\t{OV7670_R11_CLKRC, 0x81},\n\t{0x92, 0x00},\t\t\t/* DM_LNL */\n\t{0x93, 0x00},\t\t\t/* DM_LNH */\n\t{0x9d, 0x4c},\t\t\t/* BD50ST */\n\t{0x9e, 0x3f},\t\t\t/* BD60ST */\n\t{OV7670_R3B_COM11, 0x02},\n\t{OV7670_R13_COM8, 0xf5},\n\t{OV7670_R10_AECH, 0x00},\n\t{OV7670_R00_GAIN, 0x00},\n\t{OV7670_R01_BLUE, 0x7c},\n\t{OV7670_R02_RED, 0x9d},\n\t{OV7670_R12_COM7, 0x00},\n\t{OV7670_R04_COM1, 00},\n\t{OV7670_R18_HSTOP, 0x01},\n\t{OV7670_R17_HSTART, 0x13},\n\t{OV7670_R32_HREF, 0x92},\n\t{OV7670_R19_VSTART, 0x02},\n\t{OV7670_R1A_VSTOP, 0x7a},\n\t{OV7670_R03_VREF, 0x00},\n\t{OV7670_R0E_COM5, 0x04},\n\t{OV7670_R0F_COM6, 0x62},\n\t{OV7670_R15_COM10, 0x00},\n\t{0x16, 0x02},\t\t\t/* RSVD */\n\t{0x1b, 0x00},\t\t\t/* PSHFT */\n\t{OV7670_R1E_MVFP, 0x01},\n\t{0x29, 0x3c},\t\t\t/* RSVD */\n\t{0x33, 0x00},\t\t\t/* CHLF */\n\t{0x34, 0x07},\t\t\t/* ARBLM */\n\t{0x35, 0x84},\t\t\t/* RSVD */\n\t{0x36, 0x00},\t\t\t/* RSVD */\n\t{0x37, 0x04},\t\t\t/* ADC */\n\t{0x39, 0x43},\t\t\t/* OFON */\n\t{OV7670_R3A_TSLB, 0x00},\n\t{OV7670_R3C_COM12, 0x6c},\n\t{OV7670_R3D_COM13, 0x98},\n\t{OV7670_R3F_EDGE, 0x23},\n\t{OV7670_R40_COM15, 0xc1},\n\t{OV7670_R41_COM16, 0x22},\n\t{0x6b, 0x0a},\t\t\t/* DBLV */\n\t{0xa1, 0x08},\t\t\t/* RSVD */\n\t{0x69, 0x80},\t\t\t/* HV */\n\t{0x43, 0xf0},\t\t\t/* RSVD.. */\n\t{0x44, 0x10},\n\t{0x45, 0x78},\n\t{0x46, 0xa8},\n\t{0x47, 0x60},\n\t{0x48, 0x80},\n\t{0x59, 0xba},\n\t{0x5a, 0x9a},\n\t{0x5b, 0x22},\n\t{0x5c, 0xb9},\n\t{0x5d, 0x9b},\n\t{0x5e, 0x10},\n\t{0x5f, 0xe0},\n\t{0x60, 0x85},\n\t{0x61, 0x60},\n\t{0x9f, 0x9d},\t\t\t/* RSVD */\n\t{0xa0, 0xa0},\t\t\t/* DSPC2 */\n\t{0x4f, 0x60},\t\t\t/* matrix */\n\t{0x50, 0x64},\n\t{0x51, 0x04},\n\t{0x52, 0x18},\n\t{0x53, 0x3c},\n\t{0x54, 0x54},\n\t{0x55, 0x40},\n\t{0x56, 0x40},\n\t{0x57, 0x40},\n\t{0x58, 0x0d},\t\t\t/* matrix sign */\n\t{0x8b, 0xcc},\t\t\t/* RSVD */\n\t{0x8c, 0xcc},\n\t{0x8d, 0xcf},\n\t{0x6c, 0x40},\t\t\t/* gamma curve */\n\t{0x6d, 0xe0},\n\t{0x6e, 0xa0},\n\t{0x6f, 0x80},\n\t{0x70, 0x70},\n\t{0x71, 0x80},\n\t{0x72, 0x60},\n\t{0x73, 0x60},\n\t{0x74, 0x50},\n\t{0x75, 0x40},\n\t{0x76, 0x38},\n\t{0x77, 0x3c},\n\t{0x78, 0x32},\n\t{0x79, 0x1a},\n\t{0x7a, 0x28},\n\t{0x7b, 0x24},\n\t{0x7c, 0x04},\t\t\t/* gamma curve */\n\t{0x7d, 0x12},\n\t{0x7e, 0x26},\n\t{0x7f, 0x46},\n\t{0x80, 0x54},\n\t{0x81, 0x64},\n\t{0x82, 0x70},\n\t{0x83, 0x7c},\n\t{0x84, 0x86},\n\t{0x85, 0x8e},\n\t{0x86, 0x9c},\n\t{0x87, 0xab},\n\t{0x88, 0xc4},\n\t{0x89, 0xd1},\n\t{0x8a, 0xe5},\n\t{OV7670_R14_COM9, 0x1e},\n\t{OV7670_R24_AEW, 0x80},\n\t{OV7670_R25_AEB, 0x72},\n\t{OV7670_R26_VPT, 0xb3},\n\t{0x62, 0x80},\t\t\t/* LCC1 */\n\t{0x63, 0x80},\t\t\t/* LCC2 */\n\t{0x64, 0x06},\t\t\t/* LCC3 */\n\t{0x65, 0x00},\t\t\t/* LCC4 */\n\t{0x66, 0x01},\t\t\t/* LCC5 */\n\t{0x94, 0x0e},\t\t\t/* RSVD.. */\n\t{0x95, 0x14},\n\t{OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| 0x10\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AWB\n\t\t\t| OV7670_COM8_AEC},\n\t{0xa1, 0xc8}\n};\nstatic const struct ov_i2c_regvals norm_9600[] = {\n\t{0x12, 0x80},\n\t{0x0c, 0x28},\n\t{0x11, 0x80},\n\t{0x13, 0xb5},\n\t{0x14, 0x3e},\n\t{0x1b, 0x04},\n\t{0x24, 0xb0},\n\t{0x25, 0x90},\n\t{0x26, 0x94},\n\t{0x35, 0x90},\n\t{0x37, 0x07},\n\t{0x38, 0x08},\n\t{0x01, 0x8e},\n\t{0x02, 0x85}\n};\n\n/* 7670. Defaults taken from OmniVision provided data,\n*  as provided by Jonathan Corbet of OLPC\t\t*/\nstatic const struct ov_i2c_regvals norm_7670[] = {\n\t{ OV7670_R12_COM7, OV7670_COM7_RESET },\n\t{ OV7670_R3A_TSLB, 0x04 },\t\t/* OV */\n\t{ OV7670_R12_COM7, OV7670_COM7_FMT_VGA }, /* VGA */\n\t{ OV7670_R11_CLKRC, 0x01 },\n/*\n * Set the hardware window.  These values from OV don't entirely\n * make sense - hstop is less than hstart.  But they work...\n */\n\t{ OV7670_R17_HSTART, 0x13 },\n\t{ OV7670_R18_HSTOP, 0x01 },\n\t{ OV7670_R32_HREF, 0xb6 },\n\t{ OV7670_R19_VSTART, 0x02 },\n\t{ OV7670_R1A_VSTOP, 0x7a },\n\t{ OV7670_R03_VREF, 0x0a },\n\n\t{ OV7670_R0C_COM3, 0x00 },\n\t{ OV7670_R3E_COM14, 0x00 },\n/* Mystery scaling numbers */\n\t{ 0x70, 0x3a },\n\t{ 0x71, 0x35 },\n\t{ 0x72, 0x11 },\n\t{ 0x73, 0xf0 },\n\t{ 0xa2, 0x02 },\n/*\t{ OV7670_R15_COM10, 0x0 }, */\n\n/* Gamma curve values */\n\t{ 0x7a, 0x20 },\n\t{ 0x7b, 0x10 },\n\t{ 0x7c, 0x1e },\n\t{ 0x7d, 0x35 },\n\t{ 0x7e, 0x5a },\n\t{ 0x7f, 0x69 },\n\t{ 0x80, 0x76 },\n\t{ 0x81, 0x80 },\n\t{ 0x82, 0x88 },\n\t{ 0x83, 0x8f },\n\t{ 0x84, 0x96 },\n\t{ 0x85, 0xa3 },\n\t{ 0x86, 0xaf },\n\t{ 0x87, 0xc4 },\n\t{ 0x88, 0xd7 },\n\t{ 0x89, 0xe8 },\n\n/* AGC and AEC parameters.  Note we start by disabling those features,\n   then turn them only after tweaking the values. */\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t | OV7670_COM8_AECSTEP\n\t\t\t | OV7670_COM8_BFILT },\n\t{ OV7670_R00_GAIN, 0x00 },\n\t{ OV7670_R10_AECH, 0x00 },\n\t{ OV7670_R0D_COM4, 0x40 }, /* magic reserved bit */\n\t{ OV7670_R14_COM9, 0x18 }, /* 4x gain + magic rsvd bit */\n\t{ OV7670_RA5_BD50MAX, 0x05 },\n\t{ OV7670_RAB_BD60MAX, 0x07 },\n\t{ OV7670_R24_AEW, 0x95 },\n\t{ OV7670_R25_AEB, 0x33 },\n\t{ OV7670_R26_VPT, 0xe3 },\n\t{ OV7670_R9F_HAECC1, 0x78 },\n\t{ OV7670_RA0_HAECC2, 0x68 },\n\t{ 0xa1, 0x03 }, /* magic */\n\t{ OV7670_RA6_HAECC3, 0xd8 },\n\t{ OV7670_RA7_HAECC4, 0xd8 },\n\t{ OV7670_RA8_HAECC5, 0xf0 },\n\t{ OV7670_RA9_HAECC6, 0x90 },\n\t{ OV7670_RAA_HAECC7, 0x94 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC },\n\n/* Almost all of these are magic \"reserved\" values.  */\n\t{ OV7670_R0E_COM5, 0x61 },\n\t{ OV7670_R0F_COM6, 0x4b },\n\t{ 0x16, 0x02 },\n\t{ OV7670_R1E_MVFP, 0x07 },\n\t{ 0x21, 0x02 },\n\t{ 0x22, 0x91 },\n\t{ 0x29, 0x07 },\n\t{ 0x33, 0x0b },\n\t{ 0x35, 0x0b },\n\t{ 0x37, 0x1d },\n\t{ 0x38, 0x71 },\n\t{ 0x39, 0x2a },\n\t{ OV7670_R3C_COM12, 0x78 },\n\t{ 0x4d, 0x40 },\n\t{ 0x4e, 0x20 },\n\t{ OV7670_R69_GFIX, 0x00 },\n\t{ 0x6b, 0x4a },\n\t{ 0x74, 0x10 },\n\t{ 0x8d, 0x4f },\n\t{ 0x8e, 0x00 },\n\t{ 0x8f, 0x00 },\n\t{ 0x90, 0x00 },\n\t{ 0x91, 0x00 },\n\t{ 0x96, 0x00 },\n\t{ 0x9a, 0x00 },\n\t{ 0xb0, 0x84 },\n\t{ 0xb1, 0x0c },\n\t{ 0xb2, 0x0e },\n\t{ 0xb3, 0x82 },\n\t{ 0xb8, 0x0a },\n\n/* More reserved magic, some of which tweaks white balance */\n\t{ 0x43, 0x0a },\n\t{ 0x44, 0xf0 },\n\t{ 0x45, 0x34 },\n\t{ 0x46, 0x58 },\n\t{ 0x47, 0x28 },\n\t{ 0x48, 0x3a },\n\t{ 0x59, 0x88 },\n\t{ 0x5a, 0x88 },\n\t{ 0x5b, 0x44 },\n\t{ 0x5c, 0x67 },\n\t{ 0x5d, 0x49 },\n\t{ 0x5e, 0x0e },\n\t{ 0x6c, 0x0a },\n\t{ 0x6d, 0x55 },\n\t{ 0x6e, 0x11 },\n\t{ 0x6f, 0x9f },\t\t\t/* \"9e for advance AWB\" */\n\t{ 0x6a, 0x40 },\n\t{ OV7670_R01_BLUE, 0x40 },\n\t{ OV7670_R02_RED, 0x60 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC\n\t\t\t| OV7670_COM8_AWB },\n\n/* Matrix coefficients */\n\t{ 0x4f, 0x80 },\n\t{ 0x50, 0x80 },\n\t{ 0x51, 0x00 },\n\t{ 0x52, 0x22 },\n\t{ 0x53, 0x5e },\n\t{ 0x54, 0x80 },\n\t{ 0x58, 0x9e },\n\n\t{ OV7670_R41_COM16, OV7670_COM16_AWBGAIN },\n\t{ OV7670_R3F_EDGE, 0x00 },\n\t{ 0x75, 0x05 },\n\t{ 0x76, 0xe1 },\n\t{ 0x4c, 0x00 },\n\t{ 0x77, 0x01 },\n\t{ OV7670_R3D_COM13, OV7670_COM13_GAMMA\n\t\t\t  | OV7670_COM13_UVSAT\n\t\t\t  | 2},\t\t/* was 3 */\n\t{ 0x4b, 0x09 },\n\t{ 0xc9, 0x60 },\n\t{ OV7670_R41_COM16, 0x38 },\n\t{ 0x56, 0x40 },\n\n\t{ 0x34, 0x11 },\n\t{ OV7670_R3B_COM11, OV7670_COM11_EXP|OV7670_COM11_HZAUTO },\n\t{ 0xa4, 0x88 },\n\t{ 0x96, 0x00 },\n\t{ 0x97, 0x30 },\n\t{ 0x98, 0x20 },\n\t{ 0x99, 0x30 },\n\t{ 0x9a, 0x84 },\n\t{ 0x9b, 0x29 },\n\t{ 0x9c, 0x03 },\n\t{ 0x9d, 0x4c },\n\t{ 0x9e, 0x3f },\n\t{ 0x78, 0x04 },\n\n/* Extra-weird stuff.  Some sort of multiplexor register */\n\t{ 0x79, 0x01 },\n\t{ 0xc8, 0xf0 },\n\t{ 0x79, 0x0f },\n\t{ 0xc8, 0x00 },\n\t{ 0x79, 0x10 },\n\t{ 0xc8, 0x7e },\n\t{ 0x79, 0x0a },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x0b },\n\t{ 0xc8, 0x01 },\n\t{ 0x79, 0x0c },\n\t{ 0xc8, 0x0f },\n\t{ 0x79, 0x0d },\n\t{ 0xc8, 0x20 },\n\t{ 0x79, 0x09 },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x02 },\n\t{ 0xc8, 0xc0 },\n\t{ 0x79, 0x03 },\n\t{ 0xc8, 0x40 },\n\t{ 0x79, 0x05 },\n\t{ 0xc8, 0x30 },\n\t{ 0x79, 0x26 },\n};\n\nstatic const struct ov_i2c_regvals norm_8610[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x00, 0x00 },\n\t{ 0x01, 0x80 },\n\t{ 0x02, 0x80 },\n\t{ 0x03, 0xc0 },\n\t{ 0x04, 0x30 },\n\t{ 0x05, 0x30 }, /* was 0x10, new from windrv 090403 */\n\t{ 0x06, 0x70 }, /* was 0x80, new from windrv 090403 */\n\t{ 0x0a, 0x86 },\n\t{ 0x0b, 0xb0 },\n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x25 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x04 },\n\t{ 0x15, 0x01 }, /* Lin and Win think different about UV order */\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 }, /* was 0x2f, new from windrv 090403 */\n\t{ 0x18, 0xea }, /* was 0xcf, new from windrv 090403 */\n\t{ 0x19, 0x02 }, /* was 0x06, new from windrv 090403 */\n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0xd0 }, /* was 0x90, new from windrv 090403 */\n\t{ 0x23, 0xc0 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x24, 0x30 }, /* was 0x1d, new from windrv 090403 */\n\t{ 0x25, 0x50 }, /* was 0x57, new from windrv 090403 */\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x80 },\n\t{ 0x2b, 0xc8 }, /* was 0xcc, new from windrv 090403 */\n\t{ 0x2c, 0xac },\n\t{ 0x2d, 0x45 }, /* was 0xd5, new from windrv 090403 */\n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x14 }, /* was 0x01, new from windrv 090403 */\n\t{ 0x4c, 0x00 },\n\t{ 0x4d, 0x30 }, /* was 0x10, new from windrv 090403 */\n\t{ 0x60, 0x02 }, /* was 0x01, new from windrv 090403 */\n\t{ 0x61, 0x00 }, /* was 0x09, new from windrv 090403 */\n\t{ 0x62, 0x5f }, /* was 0xd7, new from windrv 090403 */\n\t{ 0x63, 0xff },\n\t{ 0x64, 0x53 }, /* new windrv 090403 says 0x57,\n\t\t\t * maybe that's wrong */\n\t{ 0x65, 0x00 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0xb0 },\n\t{ 0x68, 0xc0 }, /* was 0xaf, new from windrv 090403 */\n\t{ 0x69, 0x02 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x99 }, /* was 0x80, old windrv says 0x00, but\n\t\t\t * deleting bit7 colors the first images red */\n\t{ 0x6d, 0x11 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x6e, 0x11 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x6f, 0x01 },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 },/* 0x60? - was 0x00, new from windrv 090403 */\n\t{ 0x75, 0x0e },\n\t{ 0x76, 0x02 }, /* was 0x02, new from windrv 090403 */\n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0x10 }, /* was 0x13, new from windrv 090403 */\n\t{ 0x7c, 0x00 },\n\t{ 0x7d, 0x08 }, /* was 0x09, new from windrv 090403 */\n\t{ 0x7e, 0x08 }, /* was 0xc0, new from windrv 090403 */\n\t{ 0x7f, 0xfb },\n\t{ 0x80, 0x28 },\n\t{ 0x81, 0x00 },\n\t{ 0x82, 0x23 },\n\t{ 0x83, 0x0b },\n\t{ 0x84, 0x00 },\n\t{ 0x85, 0x62 }, /* was 0x61, new from windrv 090403 */\n\t{ 0x86, 0xc9 },\n\t{ 0x87, 0x00 },\n\t{ 0x88, 0x00 },\n\t{ 0x89, 0x01 },\n\t{ 0x12, 0x20 },\n\t{ 0x12, 0x25 }, /* was 0x24, new from windrv 090403 */\n};\n\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\n{\n\tif (v > 127)\n\t\treturn v & 0x7f;\n\treturn (128 - v) | 0x80;\n}\n\n/* Write a OV519 register */\nstatic void reg_w(struct sd *sd, u16 index, u16 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret, req = 0;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 2;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0a;\n\t\t/* fall through */\n\tcase BRIDGE_W9968CF:\n\t\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x %04x %04x\\n\",\n\t\t\t  req, value, index);\n\t\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 500);\n\t\tgoto leave;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x 0000 %04x %02x\\n\",\n\t\t  req, index, value);\n\tsd->gspca_dev.usb_buf[0] = value;\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, 1, 500);\nleave:\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\treturn;\n\t}\n}\n\n/* Read from a OV519 register, note not valid for the w9968cf!! */\n/* returns: negative is error, pos or zero is data */\nstatic int reg_r(struct sd *sd, u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\tint req;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 3;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"GET %02x 0000 %04x %02x\\n\",\n\t\t\t  req, index, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t/*\n\t\t * Make sure the result is zeroed to avoid uninitialized\n\t\t * values.\n\t\t */\n\t\tgspca_dev->usb_buf[0] = 0;\n\t}\n\n\treturn ret;\n}\n\n/* Read 8 values from a OV519 register */\nstatic int reg_r8(struct sd *sd,\n\t\t  u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1,\t\t\t/* REQ_IO */\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 8, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r8 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t/*\n\t\t * Make sure the buffer is zeroed to avoid uninitialized\n\t\t * values.\n\t\t */\n\t\tmemset(gspca_dev->usb_buf, 0, 8);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Writes bits at positions specified by mask to an OV51x reg. Bits that are in\n * the same position as 1's in \"mask\" are cleared and set to \"value\". Bits\n * that are in the same position as 0's in \"mask\" are preserved, regardless\n * of their respective state in \"value\".\n */\nstatic void reg_w_mask(struct sd *sd,\n\t\t\tu16 index,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint ret;\n\tu8 oldval;\n\n\tif (mask != 0xff) {\n\t\tvalue &= mask;\t\t\t/* Enforce mask on value */\n\t\tret = reg_r(sd, index);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\toldval = ret & ~mask;\t\t/* Clear the masked bits */\n\t\tvalue |= oldval;\t\t/* Set the desired bits */\n\t}\n\treg_w(sd, index, value);\n}\n\n/*\n * Writes multiple (n) byte value to a single register. Only valid with certain\n * registers (0x30 and 0xc4 - 0xce).\n */\nstatic void ov518_reg_w32(struct sd *sd, u16 index, u32 value, int n)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t*((__le32 *) sd->gspca_dev.usb_buf) = __cpu_to_le32(value);\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1 /* REG_IO */,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, n, 500);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w32 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n}\n\nstatic void ov511_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, retries;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov511_i2c_w %02x %02x\\n\", reg, value);\n\n\t/* Three byte write cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Select camera register */\n\t\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t\t/* Write \"value\" to I2C data port of OV511 */\n\t\treg_w(sd, R51x_I2C_DATA, value);\n\n\t\t/* Initiate 3-byte write cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x01);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBO, \"i2c write retries exhausted\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ov511_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, value, retries;\n\n\t/* Two byte write cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Select camera register */\n\t\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t\t/* Initiate 2-byte write cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x03);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\n\t\t/* I2C abort */\n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c write retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Two byte read cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Initiate 2-byte read cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\n\t\t/* I2C abort */\n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c read retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\n\tgspca_dbg(gspca_dev, D_USBI, \"ov511_i2c_r %02x %02x\\n\", reg, value);\n\n\t/* This is needed to make i2c_w() work */\n\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\treturn value;\n}\n\n/*\n * The OV518 I2C I/O procedure is different, hence, this function.\n * This is normally only called from i2c_w(). Note that this function\n * always succeeds regardless of whether the sensor is present and working.\n */\nstatic void ov518_i2c_w(struct sd *sd,\n\t\tu8 reg,\n\t\tu8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov518_i2c_w %02x %02x\\n\", reg, value);\n\n\t/* Select camera register */\n\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t/* Write \"value\" to I2C data port of OV511 */\n\treg_w(sd, R51x_I2C_DATA, value);\n\n\t/* Initiate 3-byte write cycle */\n\treg_w(sd, R518_I2C_CTL, 0x01);\n\n\t/* wait for write complete */\n\tmsleep(4);\n\treg_r8(sd, R518_I2C_CTL);\n}\n\n/*\n * returns: negative is error, pos or zero is data\n *\n * The OV518 I2C I/O procedure is different, hence, this function.\n * This is normally only called from i2c_r(). Note that this function\n * always succeeds regardless of whether the sensor is present and working.\n */\nstatic int ov518_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint value;\n\n\t/* Select camera register */\n\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t/* Initiate 2-byte write cycle */\n\treg_w(sd, R518_I2C_CTL, 0x03);\n\treg_r8(sd, R518_I2C_CTL);\n\n\t/* Initiate 2-byte read cycle */\n\treg_w(sd, R518_I2C_CTL, 0x05);\n\treg_r8(sd, R518_I2C_CTL);\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\tgspca_dbg(gspca_dev, D_USBI, \"ov518_i2c_r %02x %02x\\n\", reg, value);\n\treturn value;\n}\n\nstatic void ovfx2_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t(u16) value, (u16) reg, NULL, 0, 500);\n\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_w %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ovfx2_i2c_w %02x %02x\\n\", reg, value);\n}\n\nstatic int ovfx2_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x03,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, (u16) reg, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"ovfx2_i2c_r %02x %02x\\n\",\n\t\t\t  reg, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_r %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tif (sd->sensor_reg_cache[reg] == value)\n\t\treturn;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tov518_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_i2c_w(sd, reg, value);\n\t\tbreak;\n\t}\n\n\tif (sd->gspca_dev.usb_err >= 0) {\n\t\t/* Up on sensor reset empty the register cache */\n\t\tif (reg == 0x12 && (value & 0x80))\n\t\t\tmemset(sd->sensor_reg_cache, -1,\n\t\t\t\tsizeof(sd->sensor_reg_cache));\n\t\telse\n\t\t\tsd->sensor_reg_cache[reg] = value;\n\t}\n}\n\nstatic int i2c_r(struct sd *sd, u8 reg)\n{\n\tint ret = -1;\n\n\tif (sd->sensor_reg_cache[reg] != -1)\n\t\treturn sd->sensor_reg_cache[reg];\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tret = ov511_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tret = ov518_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tret = ovfx2_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tret = w9968cf_i2c_r(sd, reg);\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tsd->sensor_reg_cache[reg] = ret;\n\n\treturn ret;\n}\n\n/* Writes bits at positions specified by mask to an I2C reg. Bits that are in\n * the same position as 1's in \"mask\" are cleared and set to \"value\". Bits\n * that are in the same position as 0's in \"mask\" are preserved, regardless\n * of their respective state in \"value\".\n */\nstatic void i2c_w_mask(struct sd *sd,\n\t\t\tu8 reg,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint rc;\n\tu8 oldval;\n\n\tvalue &= mask;\t\t\t/* Enforce mask on value */\n\trc = i2c_r(sd, reg);\n\tif (rc < 0)\n\t\treturn;\n\toldval = rc & ~mask;\t\t/* Clear the masked bits */\n\tvalue |= oldval;\t\t/* Set the desired bits */\n\ti2c_w(sd, reg, value);\n}\n\n/* Temporarily stops OV511 from functioning. Must do this before changing\n * registers while the camera is streaming */\nstatic inline void ov51x_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"stopping\\n\");\n\tsd->stopped = 1;\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x3d);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R51x_SYS_RESET, 0x3a, 0x3a);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x00);\t\t/* FRAR */\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x00, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x0a05); /* stop USB transfer */\n\t\tbreak;\n\t}\n}\n\n/* Restarts OV511 after ov511_stop() is called. Has no effect if it is not\n * actually stopped (for performance). */\nstatic inline void ov51x_restart(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"restarting\\n\");\n\tif (!sd->stopped)\n\t\treturn;\n\tsd->stopped = 0;\n\n\t/* Reinitialize the stream */\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, 0x2f, 0x80);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x1d);\t\t/* FRAR */\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x02, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x8a05); /* USB FIFO enable */\n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_set_slave_ids(struct sd *sd, u8 slave);\n\n/* This does an initial reset of an OmniVision sensor and ensures that I2C\n * is synchronized. Returns <0 on failure.\n */\nstatic int init_ov_sensor(struct sd *sd, u8 slave)\n{\n\tint i;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tov51x_set_slave_ids(sd, slave);\n\n\t/* Reset the sensor */\n\ti2c_w(sd, 0x12, 0x80);\n\n\t/* Wait for it to initialize */\n\tmsleep(150);\n\n\tfor (i = 0; i < i2c_detect_tries; i++) {\n\t\tif (i2c_r(sd, OV7610_REG_ID_HIGH) == 0x7f &&\n\t\t    i2c_r(sd, OV7610_REG_ID_LOW) == 0xa2) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"I2C synced in %d attempt(s)\\n\",\n\t\t\t\t  i);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Reset the sensor */\n\t\ti2c_w(sd, 0x12, 0x80);\n\n\t\t/* Wait for it to initialize */\n\t\tmsleep(150);\n\n\t\t/* Dummy read to sync I2C */\n\t\tif (i2c_r(sd, 0x00) < 0)\n\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n/* Set the read and write slave IDs. The \"slave\" argument is the write slave,\n * and the read slave will be set to (slave + 1).\n * This should not be called from outside the i2c I/O functions.\n * Sets I2C read and write slave IDs. Returns <0 for error\n */\nstatic void ov51x_set_slave_ids(struct sd *sd,\n\t\t\t\tu8 slave)\n{\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\treg_w(sd, OVFX2_I2C_ADDR, slave);\n\t\treturn;\n\tcase BRIDGE_W9968CF:\n\t\tsd->sensor_addr = slave;\n\t\treturn;\n\t}\n\n\treg_w(sd, R51x_I2C_W_SID, slave);\n\treg_w(sd, R51x_I2C_R_SID, slave + 1);\n}\n\nstatic void write_regvals(struct sd *sd,\n\t\t\t const struct ov_regvals *regvals,\n\t\t\t int n)\n{\n\twhile (--n >= 0) {\n\t\treg_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\nstatic void write_i2c_regvals(struct sd *sd,\n\t\t\tconst struct ov_i2c_regvals *regvals,\n\t\t\tint n)\n{\n\twhile (--n >= 0) {\n\t\ti2c_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\n/****************************************************************************\n *\n * OV511 and sensor configuration\n *\n ***************************************************************************/\n\n/* This initializes the OV2x10 / OV3610 / OV3620 / OV9600 */\nstatic void ov_hires_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint high, low;\n\n\tif (sd->bridge != BRIDGE_OVFX2) {\n\t\tgspca_err(gspca_dev, \"error hires sensors only supported with ovfx2\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov hires configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\thigh = i2c_r(sd, 0x0a);\n\tlow = i2c_r(sd, 0x0b);\n\t/* info(\"%x, %x\", high, low); */\n\tswitch (high) {\n\tcase 0x96:\n\t\tswitch (low) {\n\t\tcase 0x40:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610\\n\");\n\t\t\tsd->sensor = SEN_OV2610;\n\t\t\treturn;\n\t\tcase 0x41:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610AE\\n\");\n\t\t\tsd->sensor = SEN_OV2610AE;\n\t\t\treturn;\n\t\tcase 0xb1:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV9600\\n\");\n\t\t\tsd->sensor = SEN_OV9600;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0x36:\n\t\tif ((low & 0x0f) == 0x00) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV3610\\n\");\n\t\t\tsd->sensor = SEN_OV3610;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tgspca_err(gspca_dev, \"Error unknown sensor type: %02x%02x\\n\",\n\t\t  high, low);\n}\n\n/* This initializes the OV8110, OV8610 sensor. The OV8110 uses\n * the same register settings as the OV8610, since they are very similar.\n */\nstatic void ov8xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov8xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 1)\n\t\tsd->sensor = SEN_OV8610;\n\telse\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n}\n\n/* This initializes the OV7610, OV7620, or OV76BE sensor. The OV76BE uses\n * the same register settings as the OV7610, since they are very similar.\n */\nstatic void ov7xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, high, low;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV7xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\n\t/* add OV7670 here\n\t * it appears to be wrongly detected as a 7610 by default */\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 3) {\n\t\t/* quick hack to make OV7670s work */\n\t\thigh = i2c_r(sd, 0x0a);\n\t\tlow = i2c_r(sd, 0x0b);\n\t\t/* info(\"%x, %x\", high, low); */\n\t\tif (high == 0x76 && (low & 0xf0) == 0x70) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76%02x\\n\",\n\t\t\t\t  low);\n\t\t\tsd->sensor = SEN_OV7670;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7610\\n\");\n\t\t\tsd->sensor = SEN_OV7610;\n\t\t}\n\t} else if ((rc & 3) == 1) {\n\t\t/* I don't know what's different about the 76BE yet. */\n\t\tif (i2c_r(sd, 0x15) & 1) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620AE\\n\");\n\t\t\tsd->sensor = SEN_OV7620AE;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76BE\\n\");\n\t\t\tsd->sensor = SEN_OV76BE;\n\t\t}\n\t} else if ((rc & 3) == 0) {\n\t\t/* try to read product id registers */\n\t\thigh = i2c_r(sd, 0x0a);\n\t\tif (high < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip PID\\n\");\n\t\t\treturn;\n\t\t}\n\t\tlow = i2c_r(sd, 0x0b);\n\t\tif (low < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip VER\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (high == 0x76) {\n\t\t\tswitch (low) {\n\t\t\tcase 0x30:\n\t\t\t\tgspca_err(gspca_dev, \"Sensor is an OV7630/OV7635\\n\");\n\t\t\t\tgspca_err(gspca_dev, \"7630 is not supported by this driver\\n\");\n\t\t\t\treturn;\n\t\t\tcase 0x40:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640; /* FIXME */\n\t\t\t\tbreak;\n\t\t\tcase 0x45:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645B\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640; /* FIXME */\n\t\t\t\tbreak;\n\t\t\tcase 0x48:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7648\\n\");\n\t\t\t\tsd->sensor = SEN_OV7648;\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV7660\\n\");\n\t\t\t\tsd->sensor = SEN_OV7660;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgspca_err(gspca_dev, \"Unknown sensor: 0x76%02x\\n\",\n\t\t\t\t\t  low);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620\\n\");\n\t\t\tsd->sensor = SEN_OV7620;\n\t\t}\n\t} else {\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n\t}\n}\n\n/* This initializes the OV6620, OV6630, OV6630AE, or OV6630AF sensor. */\nstatic void ov6xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV6xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\n\t/* Ugh. The first two bits are the version bits, but\n\t * the entire register value must be used. I guess OVT\n\t * underestimated how many variants they would make. */\n\tswitch (rc) {\n\tcase 0x00:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66308. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tcase 0x01:\n\t\tsd->sensor = SEN_OV6620;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV6620\\n\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsd->sensor = SEN_OV6630;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AE\\n\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsd->sensor = SEN_OV66308AF;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AF\\n\");\n\t\tbreak;\n\tcase 0x90:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66307. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tgspca_err(gspca_dev, \"FATAL: Unknown sensor version: 0x%02x\\n\",\n\t\t\t  rc);\n\t\treturn;\n\t}\n\n\t/* Set sensor-specific vars */\n\tsd->sif = 1;\n}\n\n/* Turns on or off the LED. Only has an effect with OV511+/OV518(+)/OV519 */\nstatic void ov51x_led_control(struct sd *sd, int on)\n{\n\tif (sd->invert_led)\n\t\ton = !on;\n\n\tswitch (sd->bridge) {\n\t/* OV511 has no LED control */\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R511_SYS_LED_CTL, on);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R518_GPIO_OUT, 0x02 * on, 0x02);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w_mask(sd, OV519_GPIO_DATA_OUT0, on, 1);\n\t\tbreak;\n\t}\n}\n\nstatic void sd_reset_snapshot(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->snapshot_needs_reset)\n\t\treturn;\n\n\t/* Note it is important that we clear sd->snapshot_needs_reset,\n\t   before actually clearing the snapshot state in the bridge\n\t   otherwise we might race with the pkt_scan interrupt handler */\n\tsd->snapshot_needs_reset = 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02);\n\t\treg_w(sd, R51x_SYS_SNAP, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02); /* Reset */\n\t\treg_w(sd, R51x_SYS_SNAP, 0x01); /* Enable */\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, R51x_SYS_RESET, 0x40);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_upload_quan_tables(struct sd *sd)\n{\n\tstatic const unsigned char yQuanTable511[] = {\n\t\t0, 1, 1, 2, 2, 3, 3, 4,\n\t\t1, 1, 1, 2, 2, 3, 4, 4,\n\t\t1, 1, 2, 2, 3, 4, 4, 4,\n\t\t2, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 5, 5, 5,\n\t\t3, 3, 4, 4, 5, 5, 5, 5,\n\t\t3, 4, 4, 4, 5, 5, 5, 5,\n\t\t4, 4, 4, 4, 5, 5, 5, 5\n\t};\n\n\tstatic const unsigned char uvQuanTable511[] = {\n\t\t0, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 2, 4, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 4, 4, 4,\n\t\t3, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4\n\t};\n\n\t/* OV518 quantization tables are 8x4 (instead of 8x8) */\n\tstatic const unsigned char yQuanTable518[] = {\n\t\t5, 4, 5, 6, 6, 7, 7, 7,\n\t\t5, 5, 5, 5, 6, 7, 7, 7,\n\t\t6, 6, 6, 6, 7, 7, 7, 8,\n\t\t7, 7, 6, 7, 7, 7, 8, 8\n\t};\n\tstatic const unsigned char uvQuanTable518[] = {\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 8,\n\t\t7, 7, 7, 7, 7, 7, 8, 8\n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tconst unsigned char *pYTable, *pUVTable;\n\tunsigned char val0, val1;\n\tint i, size, reg = R51x_COMP_LUT_BEGIN;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Uploading quantization tables\\n\");\n\n\tif (sd->bridge == BRIDGE_OV511 || sd->bridge == BRIDGE_OV511PLUS) {\n\t\tpYTable = yQuanTable511;\n\t\tpUVTable = uvQuanTable511;\n\t\tsize = 32;\n\t} else {\n\t\tpYTable = yQuanTable518;\n\t\tpUVTable = uvQuanTable518;\n\t\tsize = 16;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tval0 = *pYTable++;\n\t\tval1 = *pYTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg, val0);\n\n\t\tval0 = *pUVTable++;\n\t\tval1 = *pUVTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg + size, val0);\n\n\t\treg++;\n\t}\n}\n\n/* This initializes the OV511/OV511+ and the sensor */\nstatic void ov511_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* For 511 and 511+ */\n\tstatic const struct ov_regvals init_511[] = {\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3d },\n\t};\n\n\tstatic const struct ov_regvals norm_511[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0x01 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0x1f },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_511_p[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0xff },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0xff },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals compress_511[] = {\n\t\t{ 0x70, 0x1f },\n\t\t{ 0x71, 0x05 },\n\t\t{ 0x72, 0x06 },\n\t\t{ 0x73, 0x06 },\n\t\t{ 0x74, 0x14 },\n\t\t{ 0x75, 0x03 },\n\t\t{ 0x76, 0x04 },\n\t\t{ 0x77, 0x04 },\n\t};\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device custom id %x\\n\",\n\t\t  reg_r(sd, R51x_SYS_CUST_ID));\n\n\twrite_regvals(sd, init_511, ARRAY_SIZE(init_511));\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\t\twrite_regvals(sd, norm_511, ARRAY_SIZE(norm_511));\n\t\tbreak;\n\tcase BRIDGE_OV511PLUS:\n\t\twrite_regvals(sd, norm_511_p, ARRAY_SIZE(norm_511_p));\n\t\tbreak;\n\t}\n\n\t/* Init compression */\n\twrite_regvals(sd, compress_511, ARRAY_SIZE(compress_511));\n\n\tov51x_upload_quan_tables(sd);\n}\n\n/* This initializes the OV518/OV518+ and the sensor */\nstatic void ov518_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* For 518 and 518+ */\n\tstatic const struct ov_regvals init_518[] = {\n\t\t{ R51x_SYS_RESET,\t0x40 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x3e },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x00 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_518[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 }, /* Reset */\n\t\t{ R51x_SYS_SNAP,\t0x01 }, /* Enable */\n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x00 },\n\t\t{ 0x51,\t\t\t0x04 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\tstatic const struct ov_regvals norm_518_p[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 }, /* Reset */\n\t\t{ R51x_SYS_SNAP,\t0x01 }, /* Enable */\n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x60 },\n\t\t{ 0x51,\t\t\t0x02 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x40,\t\t\t0xff },\n\t\t{ 0x41,\t\t\t0x42 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x33,\t\t\t0x04 },\n\t\t{ 0x21,\t\t\t0x19 },\n\t\t{ 0x3f,\t\t\t0x10 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\t/* First 5 bits of custom ID reg are a revision ID on OV518 */\n\tsd->revision = reg_r(sd, R51x_SYS_CUST_ID) & 0x1f;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device revision %d\\n\", sd->revision);\n\n\twrite_regvals(sd, init_518, ARRAY_SIZE(init_518));\n\n\t/* Set LED GPIO pin to output mode */\n\treg_w_mask(sd, R518_GPIO_CTL, 0x00, 0x02);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV518:\n\t\twrite_regvals(sd, norm_518, ARRAY_SIZE(norm_518));\n\t\tbreak;\n\tcase BRIDGE_OV518PLUS:\n\t\twrite_regvals(sd, norm_518_p, ARRAY_SIZE(norm_518_p));\n\t\tbreak;\n\t}\n\n\tov51x_upload_quan_tables(sd);\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\nstatic void ov519_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_519[] = {\n\t\t{ 0x5a, 0x6d }, /* EnableSystem */\n\t\t{ 0x53, 0x9b }, /* don't enable the microcontroller */\n\t\t{ OV519_R54_EN_CLK1, 0xff }, /* set bit2 to enable jpeg */\n\t\t{ 0x5d, 0x03 },\n\t\t{ 0x49, 0x01 },\n\t\t{ 0x48, 0x00 },\n\t\t/* Set LED pin to output mode. Bit 4 must be cleared or sensor\n\t\t * detection will fail. This deserves further investigation. */\n\t\t{ OV519_GPIO_IO_CTRL0,   0xee },\n\t\t{ OV519_R51_RESET1, 0x0f },\n\t\t{ OV519_R51_RESET1, 0x00 },\n\t\t{ 0x22, 0x00 },\n\t\t/* windows reads 0x55 at this point*/\n\t};\n\n\twrite_regvals(sd, init_519, ARRAY_SIZE(init_519));\n}\n\nstatic void ovfx2_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_fx2[] = {\n\t\t{ 0x00, 0x60 },\n\t\t{ 0x02, 0x01 },\n\t\t{ 0x0f, 0x1d },\n\t\t{ 0xe9, 0x82 },\n\t\t{ 0xea, 0xc7 },\n\t\t{ 0xeb, 0x10 },\n\t\t{ 0xec, 0xf6 },\n\t};\n\n\tsd->stopped = 1;\n\n\twrite_regvals(sd, init_fx2, ARRAY_SIZE(init_fx2));\n}\n\n/* set the mode */\n/* This function works for ov7660 only */\nstatic void ov519_set_mode(struct sd *sd)\n{\n\tstatic const struct ov_regvals bridge_ov7660[2][10] = {\n\t\t{{0x10, 0x14}, {0x11, 0x1e}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x01}, {0x26, 0x00}},\n\t\t{{0x10, 0x28}, {0x11, 0x3c}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x03}, {0x26, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660[2][3] = {\n\t\t{{0x12, 0x00}, {0x24, 0x00}, {0x0c, 0x0c}},\n\t\t{{0x12, 0x00}, {0x04, 0x00}, {0x0c, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660_2[] = {\n\t\t{OV7670_R17_HSTART, 0x13},\n\t\t{OV7670_R18_HSTOP, 0x01},\n\t\t{OV7670_R32_HREF, 0x92},\n\t\t{OV7670_R19_VSTART, 0x02},\n\t\t{OV7670_R1A_VSTOP, 0x7a},\n\t\t{OV7670_R03_VREF, 0x00},\n/*\t\t{0x33, 0x00}, */\n/*\t\t{0x34, 0x07}, */\n/*\t\t{0x36, 0x00}, */\n/*\t\t{0x6b, 0x0a}, */\n\t};\n\n\twrite_regvals(sd, bridge_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(bridge_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(sensor_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660_2,\n\t\t\tARRAY_SIZE(sensor_ov7660_2));\n}\n\n/* set the frame rate */\n/* This function works for sensors ov7640, ov7648 ov7660 and ov7670 only */\nstatic void ov519_set_fr(struct sd *sd)\n{\n\tint fr;\n\tu8 clock;\n\t/* frame rate table with indices:\n\t *\t- mode = 0: 320x240, 1: 640x480\n\t *\t- fr rate = 0: 30, 1: 25, 2: 20, 3: 15, 4: 10, 5: 5\n\t *\t- reg = 0: bridge a4, 1: bridge 23, 2: sensor 11 (clock)\n\t */\n\tstatic const u8 fr_tb[2][6][3] = {\n\t\t{{0x04, 0xff, 0x00},\n\t\t {0x04, 0x1f, 0x00},\n\t\t {0x04, 0x1b, 0x00},\n\t\t {0x04, 0x15, 0x00},\n\t\t {0x04, 0x09, 0x00},\n\t\t {0x04, 0x01, 0x00}},\n\t\t{{0x0c, 0xff, 0x00},\n\t\t {0x0c, 0x1f, 0x00},\n\t\t {0x0c, 0x1b, 0x00},\n\t\t {0x04, 0xff, 0x01},\n\t\t {0x04, 0x1f, 0x01},\n\t\t {0x04, 0x1b, 0x01}},\n\t};\n\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\tif (sd->frame_rate >= 30)\n\t\tfr = 0;\n\telse if (sd->frame_rate >= 25)\n\t\tfr = 1;\n\telse if (sd->frame_rate >= 20)\n\t\tfr = 2;\n\telse if (sd->frame_rate >= 15)\n\t\tfr = 3;\n\telse if (sd->frame_rate >= 10)\n\t\tfr = 4;\n\telse\n\t\tfr = 5;\n\treg_w(sd, 0xa4, fr_tb[sd->gspca_dev.curr_mode][fr][0]);\n\treg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);\n\tclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];\n\tif (sd->sensor == SEN_OV7660)\n\t\tclock |= 0x80;\t\t/* enable double clock */\n\tov518_i2c_w(sd, OV7670_R11_CLKRC, clock);\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x13, val ? 0x05 : 0x00, 0x05);\n}\n\n/* this function is called at probe time */\nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tsd->bridge = id->driver_info & BRIDGE_MASK;\n\tsd->invert_led = (id->driver_info & BRIDGE_INVERT_LED) != 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tcam->cam_mode = ov511_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov511_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tcam->cam_mode = ov518_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov518_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tcam->bulk_size = OVFX2_BULK_SIZE;\n\t\tcam->bulk_nurbs = MAX_NURBS;\n\t\tcam->bulk = 1;\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tcam->cam_mode = w9968cf_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode);\n\t\tbreak;\n\t}\n\n\tsd->frame_rate = 15;\n\n\treturn 0;\n}\n\n/* this function is called at probe and resume time */\nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_configure(sd);\n\t\tbreak;\n\t}\n\n\t/* The OV519 must be more aggressive about sensor detection since\n\t * I2C write will never fail if the sensor is not present. We have\n\t * to try to initialize the sensor to detect its presence */\n\tsd->sensor = -1;\n\n\t/* Test for 76xx */\n\tif (init_ov_sensor(sd, OV7xx0_SID) >= 0) {\n\t\tov7xx0_configure(sd);\n\n\t/* Test for 6xx0 */\n\t} else if (init_ov_sensor(sd, OV6xx0_SID) >= 0) {\n\t\tov6xx0_configure(sd);\n\n\t/* Test for 8xx0 */\n\t} else if (init_ov_sensor(sd, OV8xx0_SID) >= 0) {\n\t\tov8xx0_configure(sd);\n\n\t/* Test for 3xxx / 2xxx */\n\t} else if (init_ov_sensor(sd, OV_HIRES_SID) >= 0) {\n\t\tov_hires_configure(sd);\n\t} else {\n\t\tgspca_err(gspca_dev, \"Can't determine sensor slave IDs\\n\");\n\t\tgoto error;\n\t}\n\n\tif (sd->sensor < 0)\n\t\tgoto error;\n\n\tov51x_led_control(sd, 0);\t/* turn LED off */\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov511_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov511_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov518_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov518_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV2610:\n\t\tcase SEN_OV2610AE:\n\t\t\tcam->cam_mode = ovfx2_ov2610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov2610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV3610:\n\t\t\tcam->cam_mode = ovfx2_ov3610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov3610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV9600:\n\t\t\tcam->cam_mode = ovfx2_ov9600_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov9600_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (sd->sif) {\n\t\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tif (sd->sif)\n\t\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode) - 1;\n\n\t\t/* w9968cf needs initialisation once the sensor is known */\n\t\tw9968cf_init(sd);\n\t\tbreak;\n\t}\n\n\t/* initialize the sensor */\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\twrite_i2c_regvals(sd, norm_2610, ARRAY_SIZE(norm_2610));\n\n\t\t/* Enable autogain, autoexpo, awb, bandfilter */\n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV2610AE:\n\t\twrite_i2c_regvals(sd, norm_2610ae, ARRAY_SIZE(norm_2610ae));\n\n\t\t/* enable autoexpo */\n\t\ti2c_w_mask(sd, 0x13, 0x05, 0x05);\n\t\tbreak;\n\tcase SEN_OV3610:\n\t\twrite_i2c_regvals(sd, norm_3620b, ARRAY_SIZE(norm_3620b));\n\n\t\t/* Enable autogain, autoexpo, awb, bandfilter */\n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\twrite_i2c_regvals(sd, norm_6x20, ARRAY_SIZE(norm_6x20));\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\twrite_i2c_regvals(sd, norm_6x30, ARRAY_SIZE(norm_6x30));\n\t\tbreak;\n\tdefault:\n/*\tcase SEN_OV7610: */\n/*\tcase SEN_OV76BE: */\n\t\twrite_i2c_regvals(sd, norm_7610, ARRAY_SIZE(norm_7610));\n\t\ti2c_w_mask(sd, 0x0e, 0x00, 0x40);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\twrite_i2c_regvals(sd, norm_7620, ARRAY_SIZE(norm_7620));\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\twrite_i2c_regvals(sd, norm_7640, ARRAY_SIZE(norm_7640));\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\ti2c_w(sd, OV7670_R12_COM7, OV7670_COM7_RESET);\n\t\tmsleep(14);\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n\t\twrite_regvals(sd, init_519_ov7660,\n\t\t\t\tARRAY_SIZE(init_519_ov7660));\n\t\twrite_i2c_regvals(sd, norm_7660, ARRAY_SIZE(norm_7660));\n\t\tsd->gspca_dev.curr_mode = 1;\t/* 640x480 */\n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\tsd_reset_snapshot(gspca_dev);\n\t\tov51x_restart(sd);\n\t\tov51x_stop(sd);\t\t\t/* not in win traces */\n\t\tov51x_led_control(sd, 0);\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\twrite_i2c_regvals(sd, norm_7670, ARRAY_SIZE(norm_7670));\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\twrite_i2c_regvals(sd, norm_8610, ARRAY_SIZE(norm_8610));\n\t\tbreak;\n\tcase SEN_OV9600:\n\t\twrite_i2c_regvals(sd, norm_9600, ARRAY_SIZE(norm_9600));\n\n\t\t/* enable autoexpo */\n/*\t\ti2c_w_mask(sd, 0x13, 0x05, 0x05); */\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\nerror:\n\tgspca_err(gspca_dev, \"OV519 Config failed\\n\");\n\treturn -EINVAL;\n}\n\n/* function called at start time before URB creation */\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\tif (gspca_dev->pixfmt.width != 800)\n\t\t\tgspca_dev->cam.bulk_size = OVFX2_BULK_SIZE;\n\t\telse\n\t\t\tgspca_dev->cam.bulk_size = 7 * 4096;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/* Set up the OV511/OV511+ with the given image parameters.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}\n\n/* Sets up the OV518/OV518+ with the given image parameters\n *\n * OV518 needs a completely different approach, until we can figure out what\n * the individual registers do. Also, only 15 FPS is supported now.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\n/* Sets up the OV519 with the given image parameters\n *\n * OV519 needs a completely different approach, until we can figure out what\n * the individual registers do.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov519_mode_init_regs(struct sd *sd)\n{\n\tstatic const struct ov_regvals mode_init_519_ov7670[] = {\n\t\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t\t{ 0x53,\t0x9f }, /* was 9b in 1.65-1.08 */\n\t\t{ OV519_R54_EN_CLK1, 0x0f }, /* bit2 (jpeg enable) */\n\t\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t\t{ 0x20,\t0x0c },\n\t\t{ 0x21,\t0x38 },\n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 }, /* undocumented */\n\t\t{ 0x37,\t0x00 }, /* undocumented */\n\t\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n\t\t{ 0x59,\t0x04 },\t/* new from windrv 090403 */\n\t\t{ 0xff,\t0x00 }, /* undocumented */\n\t\t/* windows reads 0x55 at this point, why? */\n\t};\n\n\tstatic const struct ov_regvals mode_init_519[] = {\n\t\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t\t{ 0x53,\t0x9f }, /* was 9b in 1.65-1.08 */\n\t\t{ OV519_R54_EN_CLK1, 0x0f }, /* bit2 (jpeg enable) */\n\t\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 }, /* undocumented */\n\t\t{ 0x37,\t0x00 }, /* undocumented */\n\t\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n\t\t{ 0x59,\t0x04 },\t/* new from windrv 090403 */\n\t\t{ 0xff,\t0x00 }, /* undocumented */\n\t\t/* windows reads 0x55 at this point, why? */\n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\t/******** Set the mode ********/\n\tswitch (sd->sensor) {\n\tdefault:\n\t\twrite_regvals(sd, mode_init_519, ARRAY_SIZE(mode_init_519));\n\t\tif (sd->sensor == SEN_OV7640 ||\n\t\t    sd->sensor == SEN_OV7648) {\n\t\t\t/* Select 8-bit input mode */\n\t\t\treg_w_mask(sd, OV519_R20_DFR, 0x10, 0x10);\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\treturn;\t\t/* done by ov519_set_mode/fr() */\n\tcase SEN_OV7670:\n\t\twrite_regvals(sd, mode_init_519_ov7670,\n\t\t\t\tARRAY_SIZE(mode_init_519_ov7670));\n\t\tbreak;\n\t}\n\n\treg_w(sd, OV519_R10_H_SIZE,\tsd->gspca_dev.pixfmt.width >> 4);\n\treg_w(sd, OV519_R11_V_SIZE,\tsd->gspca_dev.pixfmt.height >> 3);\n\tif (sd->sensor == SEN_OV7670 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x04);\n\telse if (sd->sensor == SEN_OV7648 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x01);\n\telse\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x00);\n\treg_w(sd, OV519_R13_X_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R14_Y_OFFSETL,\t0x00);\n\treg_w(sd, OV519_R15_Y_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R16_DIVIDER,\t0x00);\n\treg_w(sd, OV519_R25_FORMAT,\t0x03); /* YUV422 */\n\treg_w(sd, 0x26,\t\t\t0x00); /* Undocumented */\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n/* FIXME: These are only valid at the max resolution. */\n\tsd->clockdiv = 0;\n\tswitch (sd->sensor) {\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\n/*\t\tcase 30: */\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\t/* 15 fps */\n/*\t\tcase 15: */\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7670:\t\t/* guesses, based on 7640 */\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Setting framerate to %d fps\\n\",\n\t\t\t  (sd->frame_rate == 0) ? 15 : sd->frame_rate);\n\t\treg_w(sd, 0xa4, 0x10);\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tdefault:\n/*\t\tcase 15: */\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mode_init_ov_sensor_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint qvga, xstart, xend, ystart, yend;\n\tu8 v;\n\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\n\t/******** Mode (VGA/QVGA) and sensor specific regs ********/\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\treturn;\n\tcase SEN_OV2610AE: {\n\t\tu8 v;\n\n\t\t/* frame rates:\n\t\t *\t10fps / 5 fps for 1600x1200\n\t\t *\t40fps / 20fps for 800x600\n\t\t */\n\t\tv = 80;\n\t\tif (qvga) {\n\t\t\tif (sd->frame_rate < 25)\n\t\t\t\tv = 0x81;\n\t\t} else {\n\t\t\tif (sd->frame_rate < 10)\n\t\t\t\tv = 0x81;\n\t\t}\n\t\ti2c_w(sd, 0x11, v);\n\t\ti2c_w(sd, 0x12, qvga ? 0x60 : 0x20);\n\t\treturn;\n\t    }\n\tcase SEN_OV3610:\n\t\tif (qvga) {\n\t\t\txstart = (1040 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x1f << 4);\n\t\t\tystart = (776 - gspca_dev->pixfmt.height) / 2;\n\t\t} else {\n\t\t\txstart = (2076 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x10 << 4);\n\t\t\tystart = (1544 - gspca_dev->pixfmt.height) / 2;\n\t\t}\n\t\txend = xstart + gspca_dev->pixfmt.width;\n\t\tyend = ystart + gspca_dev->pixfmt.height;\n\t\t/* Writing to the COMH register resets the other windowing regs\n\t\t   to their default values, so we must do this first. */\n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0xf0);\n\t\ti2c_w_mask(sd, 0x32,\n\t\t\t   (((xend >> 1) & 7) << 3) | ((xstart >> 1) & 7),\n\t\t\t   0x3f);\n\t\ti2c_w_mask(sd, 0x03,\n\t\t\t   (((yend >> 1) & 3) << 2) | ((ystart >> 1) & 3),\n\t\t\t   0x0f);\n\t\ti2c_w(sd, 0x17, xstart >> 4);\n\t\ti2c_w(sd, 0x18, xend >> 4);\n\t\ti2c_w(sd, 0x19, ystart >> 3);\n\t\ti2c_w(sd, 0x1a, yend >> 3);\n\t\treturn;\n\tcase SEN_OV8610:\n\t\t/* For OV8610 qvga means qsvga */\n\t\ti2c_w_mask(sd, OV7610_REG_COM_C, qvga ? (1 << 5) : 0, 1 << 5);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x40); /* from windrv 090403 */\n\t\ti2c_w_mask(sd, 0x28, 0x20, 0x20); /* progressive mode on */\n\t\tbreak;\n\tcase SEN_OV7610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV76BE:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xb0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tif (sd->sensor == SEN_OV76BE)\n\t\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\t/* Setting this undocumented bit in qvga mode removes a very\n\t\t   annoying vertical shaking of the image */\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\t/* Unknown */\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\t/* Allow higher automatic gain (to allow higher framerates) */\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x04); /* AWB: 1 */\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* set COM7_FMT_VGA or COM7_FMT_QVGA\n\t\t * do we need to set anything else?\n\t\t *\tHSTART etc are set in set_ov_sensor_window itself */\n\t\ti2c_w_mask(sd, OV7670_R12_COM7,\n\t\t\t qvga ? OV7670_COM7_FMT_QVGA : OV7670_COM7_FMT_VGA,\n\t\t\t OV7670_COM7_FMT_MASK);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_AWB,\n\t\t\t\tOV7670_COM8_AWB);\n\t\tif (qvga) {\t\t/* QVGA from ov7670.c by\n\t\t\t\t\t * Jonathan Corbet */\n\t\t\txstart = 164;\n\t\t\txend = 28;\n\t\t\tystart = 14;\n\t\t\tyend = 494;\n\t\t} else {\t\t/* VGA */\n\t\t\txstart = 158;\n\t\t\txend = 14;\n\t\t\tystart = 10;\n\t\t\tyend = 490;\n\t\t}\n\t\t/* OV7670 hardware window registers are split across\n\t\t * multiple locations */\n\t\ti2c_w(sd, OV7670_R17_HSTART, xstart >> 3);\n\t\ti2c_w(sd, OV7670_R18_HSTOP, xend >> 3);\n\t\tv = i2c_r(sd, OV7670_R32_HREF);\n\t\tv = (v & 0xc0) | ((xend & 0x7) << 3) | (xstart & 0x07);\n\t\tmsleep(10);\t/* need to sleep between read and write to\n\t\t\t\t * same reg! */\n\t\ti2c_w(sd, OV7670_R32_HREF, v);\n\n\t\ti2c_w(sd, OV7670_R19_VSTART, ystart >> 2);\n\t\ti2c_w(sd, OV7670_R1A_VSTOP, yend >> 2);\n\t\tv = i2c_r(sd, OV7670_R03_VREF);\n\t\tv = (v & 0xc0) | ((yend & 0x3) << 2) | (ystart & 0x03);\n\t\tmsleep(10);\t/* need to sleep between read and write to\n\t\t\t\t * same reg! */\n\t\ti2c_w(sd, OV7670_R03_VREF, v);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV9600: {\n\t\tconst struct ov_i2c_regvals *vals;\n\t\tstatic const struct ov_i2c_regvals sxga_15[] = {\n\t\t\t{0x11, 0x80}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals sxga_7_5[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_30[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x7e}, {0x24, 0x70}, {0x25, 0x60}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_15[] = {\n\t\t\t{0x11, 0x83}, {0x14, 0x3e}, {0x24, 0x80}, {0x25, 0x70}\n\t\t};\n\n\t\t/* frame rates:\n\t\t *\t15fps / 7.5 fps for 1280x1024\n\t\t *\t30fps / 15fps for 640x480\n\t\t */\n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0x40);\n\t\tif (qvga)\n\t\t\tvals = sd->frame_rate < 30 ? vga_15 : vga_30;\n\t\telse\n\t\t\tvals = sd->frame_rate < 15 ? sxga_7_5 : sxga_15;\n\t\twrite_i2c_regvals(sd, vals, ARRAY_SIZE(sxga_15));\n\t\treturn;\n\t    }\n\tdefault:\n\t\treturn;\n\t}\n\n\t/******** Clock programming ********/\n\ti2c_w(sd, 0x11, sd->clockdiv);\n}\n\n/* this function works for bridge ov519 and sensors ov7660 and ov7670 only */\nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\t/* block stream */\n\ti2c_w_mask(sd, OV7670_R1E_MVFP,\n\t\tOV7670_MVFP_MIRROR * hflip | OV7670_MVFP_VFLIP * vflip,\n\t\tOV7670_MVFP_MIRROR | OV7670_MVFP_VFLIP);\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\t/* restart stream */\n}\n\nstatic void set_ov_sensor_window(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev;\n\tint qvga, crop;\n\tint hwsbase, hwebase, vwsbase, vwebase, hwscale, vwscale;\n\n\t/* mode setup is fully handled in mode_init_ov_sensor_regs for these */\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\tcase SEN_OV2610AE:\n\tcase SEN_OV3610:\n\tcase SEN_OV7670:\n\tcase SEN_OV9600:\n\t\tmode_init_ov_sensor_regs(sd);\n\t\treturn;\n\tcase SEN_OV7660:\n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\treturn;\n\t}\n\n\tgspca_dev = &sd->gspca_dev;\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\tcrop = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 2;\n\n\t/* The different sensor ICs handle setting up of window differently.\n\t * IF YOU SET IT WRONG, YOU WILL GET ALL ZERO ISOC DATA FROM OV51x!! */\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\t\thwsbase = 0x1e;\n\t\thwebase = 0x1e;\n\t\tvwsbase = 0x02;\n\t\tvwebase = 0x02;\n\t\tbreak;\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = 0x05;\n\t\tvwebase = 0x06;\n\t\tif (sd->sensor == SEN_OV66308AF && qvga)\n\t\t\t/* HDG: this fixes U and V getting swapped */\n\t\t\thwsbase++;\n\t\tif (crop) {\n\t\t\thwsbase += 8;\n\t\t\thwebase += 8;\n\t\t\tvwsbase += 11;\n\t\t\tvwebase += 11;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\thwsbase = 0x2f;\t\t/* From 7620.SET (spec is wrong) */\n\t\thwebase = 0x2f;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\thwsbase = 0x1a;\n\t\thwebase = 0x1a;\n\t\tvwsbase = vwebase = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\tif (qvga) {\t\t/* QCIF */\n\t\t\thwscale = 0;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t/* CIF */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\t/* The datasheet says 0;\n\t\t\t\t\t * it's wrong */\n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tif (qvga) {\t\t/* QSVGA */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\n\t\t} else {\t\t/* SVGA */\n\t\t\thwscale = 2;\n\t\t\tvwscale = 2;\n\t\t}\n\t\tbreak;\n\tdefault:\t\t\t/* SEN_OV7xx0 */\n\t\tif (qvga) {\t\t/* QVGA */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t/* VGA */\n\t\t\thwscale = 2;\n\t\t\tvwscale = 1;\n\t\t}\n\t}\n\n\tmode_init_ov_sensor_regs(sd);\n\n\ti2c_w(sd, 0x17, hwsbase);\n\ti2c_w(sd, 0x18, hwebase + (sd->sensor_width >> hwscale));\n\ti2c_w(sd, 0x19, vwsbase);\n\ti2c_w(sd, 0x1a, vwebase + (sd->sensor_height >> vwscale));\n}\n\n/* -- start the camera -- */\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Default for most bridges, allow bridge_mode_init_regs to override */\n\tsd->sensor_width = sd->gspca_dev.pixfmt.width;\n\tsd->sensor_height = sd->gspca_dev.pixfmt.height;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_mode_init_regs(sd);\n\t\tbreak;\n\t/* case BRIDGE_OVFX2: nothing to do */\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_mode_init_regs(sd);\n\t\tbreak;\n\t}\n\n\tset_ov_sensor_window(sd);\n\n\t/* Force clear snapshot state in case the snapshot button was\n\t   pressed while we weren't streaming */\n\tsd->snapshot_needs_reset = 1;\n\tsd_reset_snapshot(gspca_dev);\n\n\tsd->first_frame = 3;\n\n\tov51x_restart(sd);\n\tov51x_led_control(sd, 1);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tov51x_stop(sd);\n\tov51x_led_control(sd, 0);\n}\n\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->gspca_dev.present)\n\t\treturn;\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_stop0(sd);\n\n#if IS_ENABLED(CONFIG_INPUT)\n\t/* If the last button state is pressed, release it now! */\n\tif (sd->snapshot_pressed) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->snapshot_pressed = 0;\n\t}\n#endif\n\tif (sd->bridge == BRIDGE_OV519)\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n}\n\nstatic void ov51x_handle_button(struct gspca_dev *gspca_dev, u8 state)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->snapshot_pressed != state) {\n#if IS_ENABLED(CONFIG_INPUT)\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\n\t\tinput_sync(gspca_dev->input_dev);\n#endif\n\t\tif (state)\n\t\t\tsd->snapshot_needs_reset = 1;\n\n\t\tsd->snapshot_pressed = state;\n\t} else {\n\t\t/* On the ov511 / ov519 we need to reset the button state\n\t\t   multiple times, as resetting does not work as long as the\n\t\t   button stays pressed */\n\t\tswitch (sd->bridge) {\n\t\tcase BRIDGE_OV511:\n\t\tcase BRIDGE_OV511PLUS:\n\t\tcase BRIDGE_OV519:\n\t\t\tif (state)\n\t\t\t\tsd->snapshot_needs_reset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ov511_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *in,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* SOF/EOF packets have 1st to 8th bytes zeroed and the 9th\n\t * byte non-zero. The EOF packet has image width/height in the\n\t * 10th and 11th bytes. The 9th byte is given as follows:\n\t *\n\t * bit 7: EOF\n\t *     6: compression enabled\n\t *     5: 422/420/400 modes\n\t *     4: 422/420/400 modes\n\t *     3: 1\n\t *     2: snapshot button on\n\t *     1: snapshot frame\n\t *     0: even/odd field\n\t */\n\tif (!(in[0] | in[1] | in[2] | in[3] | in[4] | in[5] | in[6] | in[7]) &&\n\t    (in[8] & 0x08)) {\n\t\tov51x_handle_button(gspca_dev, (in[8] >> 2) & 1);\n\t\tif (in[8] & 0x80) {\n\t\t\t/* Frame end */\n\t\t\tif ((in[9] + 1) * 8 != gspca_dev->pixfmt.width ||\n\t\t\t    (in[10] + 1) * 8 != gspca_dev->pixfmt.height) {\n\t\t\t\tgspca_err(gspca_dev, \"Invalid frame size, got: %dx%d, requested: %dx%d\\n\",\n\t\t\t\t\t  (in[9] + 1) * 8, (in[10] + 1) * 8,\n\t\t\t\t\t  gspca_dev->pixfmt.width,\n\t\t\t\t\t  gspca_dev->pixfmt.height);\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Add 11 byte footer to frame, might be useful */\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, in, 11);\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* Frame start */\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, in, 0);\n\t\t\tsd->packet_nr = 0;\n\t\t}\n\t}\n\n\t/* Ignore the packet number */\n\tlen--;\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, in, len);\n}\n\nstatic void ov518_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* A false positive here is likely, until OVT gives me\n\t * the definitive SOF/EOF format */\n\tif ((!(data[0] | data[1] | data[2] | data[3] | data[5])) && data[6]) {\n\t\tov51x_handle_button(gspca_dev, (data[6] >> 1) & 1);\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\tsd->packet_nr = 0;\n\t}\n\n\tif (gspca_dev->last_packet_type == DISCARD_PACKET)\n\t\treturn;\n\n\t/* Does this device use packet numbers ? */\n\tif (len & 7) {\n\t\tlen--;\n\t\tif (sd->packet_nr == data[len])\n\t\t\tsd->packet_nr++;\n\t\t/* The last few packets of the frame (which are all 0's\n\t\t   except that they may contain part of the footer), are\n\t\t   numbered 0 */\n\t\telse if (sd->packet_nr == 0 || data[len]) {\n\t\t\tgspca_err(gspca_dev, \"Invalid packet nr: %d (expect: %d)\\n\",\n\t\t\t\t  (int)data[len], (int)sd->packet_nr);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ov519_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\t/* Header of ov519 is 16 bytes:\n\t *     Byte     Value      Description\n\t *\t0\t0xff\tmagic\n\t *\t1\t0xff\tmagic\n\t *\t2\t0xff\tmagic\n\t *\t3\t0xXX\t0x50 = SOF, 0x51 = EOF\n\t *\t9\t0xXX\t0x01 initial frame without data,\n\t *\t\t\t0x00 standard frame with image\n\t *\t14\tLo\tin EOF: length of image data / 8\n\t *\t15\tHi\n\t */\n\n\tif (data[0] == 0xff && data[1] == 0xff && data[2] == 0xff) {\n\t\tswitch (data[3]) {\n\t\tcase 0x50:\t\t/* start of frame */\n\t\t\t/* Don't check the button state here, as the state\n\t\t\t   usually (always ?) changes at EOF and checking it\n\t\t\t   here leads to unnecessary snapshot state resets. */\n#define HDRSZ 16\n\t\t\tdata += HDRSZ;\n\t\t\tlen -= HDRSZ;\n#undef HDRSZ\n\t\t\tif (data[0] == 0xff || data[1] == 0xd8)\n\t\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\t\tdata, len);\n\t\t\telse\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\tcase 0x51:\t\t/* end of frame */\n\t\t\tov51x_handle_button(gspca_dev, data[11] & 1);\n\t\t\tif (data[9] != 0)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ovfx2_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\n\t/* A short read signals EOF */\n\tif (len < gspca_dev->cam.bulk_size) {\n\t\t/* If the frame is short, and it is one of the first ones\n\t\t   the sensor and bridge are still syncing, so drop it. */\n\t\tif (sd->first_frame) {\n\t\t\tsd->first_frame--;\n\t\t\tif (gspca_dev->image_len <\n\t\t\t\t  sd->gspca_dev.pixfmt.width *\n\t\t\t\t\tsd->gspca_dev.pixfmt.height)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t}\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\t}\n}\n\n/* -- management routines -- */\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals brit_7660[][7] = {\n\t\t{{0x0f, 0x6a}, {0x24, 0x40}, {0x25, 0x2b}, {0x26, 0x90},\n\t\t\t{0x27, 0xe0}, {0x28, 0xe0}, {0x2c, 0xe0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x50}, {0x25, 0x40}, {0x26, 0xa1},\n\t\t\t{0x27, 0xc0}, {0x28, 0xc0}, {0x2c, 0xc0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x68}, {0x25, 0x58}, {0x26, 0xc2},\n\t\t\t{0x27, 0xa0}, {0x28, 0xa0}, {0x2c, 0xa0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x70}, {0x25, 0x68}, {0x26, 0xd3},\n\t\t\t{0x27, 0x80}, {0x28, 0x80}, {0x2c, 0x80}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x80}, {0x25, 0x70}, {0x26, 0xd3},\n\t\t\t{0x27, 0x20}, {0x28, 0x20}, {0x2c, 0x20}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x88}, {0x25, 0x78}, {0x26, 0xd3},\n\t\t\t{0x27, 0x40}, {0x28, 0x40}, {0x2c, 0x40}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x90}, {0x25, 0x80}, {0x26, 0xd4},\n\t\t\t{0x27, 0x60}, {0x28, 0x60}, {0x2c, 0x60}}\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, brit_7660[val],\n\t\t\t\tARRAY_SIZE(brit_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n/*win trace\n *\t\ti2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_AEC); */\n\t\ti2c_w(sd, OV7670_R55_BRIGHT, ov7670_abs_to_sm(val));\n\t\tbreak;\n\t}\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals contrast_7660[][31] = {\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0xa0},\n\t\t {0x70, 0x58}, {0x71, 0x38}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x24}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x65},\n\t\t {0x80, 0x70}, {0x81, 0x77}, {0x82, 0x7d}, {0x83, 0x83},\n\t\t {0x84, 0x88}, {0x85, 0x8d}, {0x86, 0x96}, {0x87, 0x9f},\n\t\t {0x88, 0xb0}, {0x89, 0xc4}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0x94},\n\t\t {0x70, 0x58}, {0x71, 0x40}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x30}, {0x75, 0x30}, {0x76, 0x2c}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x31},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x62},\n\t\t {0x80, 0x6d}, {0x81, 0x75}, {0x82, 0x7b}, {0x83, 0x81},\n\t\t {0x84, 0x87}, {0x85, 0x8d}, {0x86, 0x98}, {0x87, 0xa1},\n\t\t {0x88, 0xb2}, {0x89, 0xc6}, {0x8a, 0xdb}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x84},\n\t\t {0x70, 0x58}, {0x71, 0x48}, {0x72, 0x40}, {0x73, 0x40},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x28}, {0x77, 0x24},\n\t\t {0x78, 0x26}, {0x79, 0x28}, {0x7a, 0x28}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x5d},\n\t\t {0x80, 0x68}, {0x81, 0x71}, {0x82, 0x79}, {0x83, 0x81},\n\t\t {0x84, 0x86}, {0x85, 0x8b}, {0x86, 0x95}, {0x87, 0x9e},\n\t\t {0x88, 0xb1}, {0x89, 0xc5}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x70},\n\t\t {0x70, 0x58}, {0x71, 0x58}, {0x72, 0x48}, {0x73, 0x48},\n\t\t {0x74, 0x38}, {0x75, 0x40}, {0x76, 0x34}, {0x77, 0x34},\n\t\t {0x78, 0x2e}, {0x79, 0x28}, {0x7a, 0x24}, {0x7b, 0x22},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x58},\n\t\t {0x80, 0x63}, {0x81, 0x6e}, {0x82, 0x77}, {0x83, 0x80},\n\t\t {0x84, 0x87}, {0x85, 0x8f}, {0x86, 0x9c}, {0x87, 0xa9},\n\t\t {0x88, 0xc0}, {0x89, 0xd4}, {0x8a, 0xe6}},\n\t\t{{0x6c, 0xa0}, {0x6d, 0xf0}, {0x6e, 0x90}, {0x6f, 0x80},\n\t\t {0x70, 0x70}, {0x71, 0x80}, {0x72, 0x60}, {0x73, 0x60},\n\t\t {0x74, 0x58}, {0x75, 0x60}, {0x76, 0x4c}, {0x77, 0x38},\n\t\t {0x78, 0x38}, {0x79, 0x2a}, {0x7a, 0x20}, {0x7b, 0x0e},\n\t\t {0x7c, 0x0a}, {0x7d, 0x14}, {0x7e, 0x26}, {0x7f, 0x46},\n\t\t {0x80, 0x54}, {0x81, 0x64}, {0x82, 0x70}, {0x83, 0x7c},\n\t\t {0x84, 0x87}, {0x85, 0x93}, {0x86, 0xa6}, {0x87, 0xb4},\n\t\t {0x88, 0xd0}, {0x89, 0xe5}, {0x8a, 0xf5}},\n\t\t{{0x6c, 0x60}, {0x6d, 0x80}, {0x6e, 0x60}, {0x6f, 0x80},\n\t\t {0x70, 0x80}, {0x71, 0x80}, {0x72, 0x88}, {0x73, 0x30},\n\t\t {0x74, 0x70}, {0x75, 0x68}, {0x76, 0x64}, {0x77, 0x50},\n\t\t {0x78, 0x3c}, {0x79, 0x22}, {0x7a, 0x10}, {0x7b, 0x08},\n\t\t {0x7c, 0x06}, {0x7d, 0x0e}, {0x7e, 0x1a}, {0x7f, 0x3a},\n\t\t {0x80, 0x4a}, {0x81, 0x5a}, {0x82, 0x6b}, {0x83, 0x7b},\n\t\t {0x84, 0x89}, {0x85, 0x96}, {0x86, 0xaf}, {0x87, 0xc3},\n\t\t {0x88, 0xe1}, {0x89, 0xf2}, {0x8a, 0xfa}},\n\t\t{{0x6c, 0x20}, {0x6d, 0x40}, {0x6e, 0x20}, {0x6f, 0x60},\n\t\t {0x70, 0x88}, {0x71, 0xc8}, {0x72, 0xc0}, {0x73, 0xb8},\n\t\t {0x74, 0xa8}, {0x75, 0xb8}, {0x76, 0x80}, {0x77, 0x5c},\n\t\t {0x78, 0x26}, {0x79, 0x10}, {0x7a, 0x08}, {0x7b, 0x04},\n\t\t {0x7c, 0x02}, {0x7d, 0x06}, {0x7e, 0x0a}, {0x7f, 0x22},\n\t\t {0x80, 0x33}, {0x81, 0x4c}, {0x82, 0x64}, {0x83, 0x7b},\n\t\t {0x84, 0x90}, {0x85, 0xa7}, {0x86, 0xc7}, {0x87, 0xde},\n\t\t {0x88, 0xf1}, {0x89, 0xf9}, {0x8a, 0xfd}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV7610:\n\tcase SEN_OV6620:\n\t\ti2c_w(sd, OV7610_REG_CNT, val);\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, OV7610_REG_CNT, val >> 4, 0x0f);\n\t\tbreak;\n\tcase SEN_OV8610: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x03, 0x09, 0x0b, 0x0f, 0x53, 0x6f, 0x35, 0x7f\n\t\t};\n\n\t\t/* Use Y gamma control instead. Bit 0 enables it. */\n\t\ti2c_w(sd, 0x64, ctab[val >> 5]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x01, 0x05, 0x09, 0x11, 0x15, 0x35, 0x37, 0x57,\n\t\t\t0x5b, 0xa5, 0xa7, 0xc7, 0xc9, 0xcf, 0xef, 0xff\n\t\t};\n\n\t\t/* Use Y gamma control instead. Bit 0 enables it. */\n\t\ti2c_w(sd, 0x64, ctab[val >> 4]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, contrast_7660[val],\n\t\t\t\t\tARRAY_SIZE(contrast_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* check that this isn't just the same as ov7610 */\n\t\ti2c_w(sd, OV7670_R56_CONTRAS, val >> 1);\n\t\tbreak;\n\t}\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w(sd, 0x10, val);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals colors_7660[][6] = {\n\t\t{{0x4f, 0x28}, {0x50, 0x2a}, {0x51, 0x02}, {0x52, 0x0a},\n\t\t {0x53, 0x19}, {0x54, 0x23}},\n\t\t{{0x4f, 0x47}, {0x50, 0x4a}, {0x51, 0x03}, {0x52, 0x11},\n\t\t {0x53, 0x2c}, {0x54, 0x3e}},\n\t\t{{0x4f, 0x66}, {0x50, 0x6b}, {0x51, 0x05}, {0x52, 0x19},\n\t\t {0x53, 0x40}, {0x54, 0x59}},\n\t\t{{0x4f, 0x84}, {0x50, 0x8b}, {0x51, 0x06}, {0x52, 0x20},\n\t\t {0x53, 0x53}, {0x54, 0x73}},\n\t\t{{0x4f, 0xa3}, {0x50, 0xab}, {0x51, 0x08}, {0x52, 0x28},\n\t\t {0x53, 0x66}, {0x54, 0x8e}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\t/* Use UV gamma control instead. Bits 0 & 7 are reserved. */\n/*\t\trc = ov_i2c_write(sd->dev, 0x62, (val >> 9) & 0x7e);\n\t\tif (rc < 0)\n\t\t\tgoto out; */\n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_SAT, val & 0xf0);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, colors_7660[val],\n\t\t\t\t\tARRAY_SIZE(colors_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* supported later once I work out how to do it\n\t\t * transparently fail now! */\n\t\t/* set REG_COM13 values for UV sat auto mode */\n\t\tbreak;\n\t}\n}\n\nstatic void setautobright(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x2d, val ? 0x10 : 0x00, 0x10);\n}\n\nstatic void setfreq_i(struct sd *sd, s32 val)\n{\n\tif (sd->sensor == SEN_OV7660\n\t || sd->sensor == SEN_OV7670) {\n\t\tswitch (val) {\n\t\tcase 0: /* Banding filter disabled */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_BFILT);\n\t\t\tbreak;\n\t\tcase 1: /* 50 hz */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x08, 0x18);\n\t\t\tbreak;\n\t\tcase 2: /* 60 hz */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x00, 0x18);\n\t\t\tbreak;\n\t\tcase 3: /* Auto hz - ov7670 only */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, OV7670_COM11_HZAUTO,\n\t\t\t\t   0x18);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (val) {\n\t\tcase 0: /* Banding filter disabled */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\tbreak;\n\t\tcase 1: /* 50 hz (filter on and framerate adj) */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t/* 20 fps -> 16.667 fps */\n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF)\n\t\t\t\ti2c_w(sd, 0x2b, 0x5e);\n\t\t\telse\n\t\t\t\ti2c_w(sd, 0x2b, 0xac);\n\t\t\tbreak;\n\t\tcase 2: /* 60 hz (filter on, ...) */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF) {\n\t\t\t\t/* 20 fps -> 15 fps */\n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t\ti2c_w(sd, 0x2b, 0xa8);\n\t\t\t} else {\n\t\t\t\t/* no framerate adj. */\n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsetfreq_i(sd, val);\n\n\t/* Ugly but necessary */\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_set_crop_window(sd);\n}\n\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tmemset(jcomp, 0, sizeof *jcomp);\n\tjcomp->quality = v4l2_ctrl_g_ctrl(sd->jpegqual);\n\tjcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT |\n\t\t\t      V4L2_JPEG_MARKER_DRI;\n\treturn 0;\n}\n\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tv4l2_ctrl_s_ctrl(sd->jpegqual, jcomp->quality);\n\treturn 0;\n}\n\nstatic int sd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tgspca_dev->exposure->val = i2c_r(sd, 0x10);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOBRIGHTNESS:\n\t\tif (ctrl->is_new)\n\t\t\tsetautobright(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && sd->brightness->is_new)\n\t\t\tsetbrightness(gspca_dev, sd->brightness->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev, ctrl->val, sd->vflip->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (ctrl->is_new)\n\t\t\tsetautogain(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && gspca_dev->exposure->is_new)\n\t\t\tsetexposure(gspca_dev, gspca_dev->exposure->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\treturn -EBUSY; /* Should never happen, as we grab the ctrl */\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.g_volatile_ctrl = sd_g_volatile_ctrl,\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 10);\n\tif (valid_controls[sd->sensor].has_brightness)\n\t\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 6 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 3 : 127);\n\tif (valid_controls[sd->sensor].has_contrast) {\n\t\tif (sd->sensor == SEN_OV7660)\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 6, 1, 3);\n\t\telse\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 255, 1,\n\t\t\t\t(sd->sensor == SEN_OV6630 ||\n\t\t\t\t sd->sensor == SEN_OV66308AF) ? 200 : 127);\n\t}\n\tif (valid_controls[sd->sensor].has_sat)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 4 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 2 : 127);\n\tif (valid_controls[sd->sensor].has_exposure)\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 255, 1, 127);\n\tif (valid_controls[sd->sensor].has_hvflip) {\n\t\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\tif (valid_controls[sd->sensor].has_autobright)\n\t\tsd->autobright = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOBRIGHTNESS, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_autogain)\n\t\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_freq) {\n\t\tif (sd->sensor == SEN_OV7670)\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\t\telse\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0, 0);\n\t}\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\tQUALITY_MIN, QUALITY_MAX, 1, QUALITY_DEF);\n\n\tif (hdl->error) {\n\t\tgspca_err(gspca_dev, \"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tif (gspca_dev->autogain)\n\t\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, true);\n\tif (sd->autobright)\n\t\tv4l2_ctrl_auto_cluster(2, &sd->autobright, 0, false);\n\tif (sd->hflip)\n\t\tv4l2_ctrl_cluster(2, &sd->hflip);\n\treturn 0;\n}\n\n/* sub-driver description */\nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = sd_reset_snapshot,\n\t.get_jcomp = sd_get_jcomp,\n\t.set_jcomp = sd_set_jcomp,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\n\n/* -- module initialisation -- */\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x4003), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x041e, 0x4052),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x041e, 0x405f), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4060), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4061), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4064), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4067), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4068), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x045e, 0x028c),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x054c, 0x0154), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x054c, 0x0155), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x0511), .driver_info = BRIDGE_OV511 },\n\t{USB_DEVICE(0x05a9, 0x0518), .driver_info = BRIDGE_OV518 },\n\t{USB_DEVICE(0x05a9, 0x0519),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x0530),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x2800), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x05a9, 0x4519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x8519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0xa511), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x05a9, 0xa518), .driver_info = BRIDGE_OV518PLUS },\n\t{USB_DEVICE(0x0813, 0x0002), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x0b62, 0x0059), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x0e96, 0xc001), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x1046, 0x9967), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x8020, 0xef04), .driver_info = BRIDGE_OVFX2 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n/* -- device connect -- */\nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(frame_rate, int, 0644);\nMODULE_PARM_DESC(frame_rate, \"Frame rate (5, 10, 15, 20 or 30 fps)\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * OV519 driver\n *\n * Copyright (C) 2008-2011 Jean-Fran\u00e7ois Moine <moinejf@free.fr>\n * Copyright (C) 2009 Hans de Goede <hdegoede@redhat.com>\n *\n * This module is adapted from the ov51x-jpeg package, which itself\n * was adapted from the ov511 driver.\n *\n * Original copyright for the ov511 driver is:\n *\n * Copyright (c) 1999-2006 Mark W. McClelland\n * Support for OV519, OV8610 Copyright (c) 2003 Joerg Heckenbach\n * Many improvements by Bret Wallach <bwallac1@san.rr.com>\n * Color fixes by by Orion Sky Lawlor <olawlor@acm.org> (2/26/2000)\n * OV7620 fixes by Charl P. Botha <cpbotha@ieee.org>\n * Changes by Claudio Matsuoka <claudio@conectiva.com>\n *\n * ov51x-jpeg original copyright is:\n *\n * Copyright (c) 2004-2007 Romain Beauxis <toots@rastageeks.org>\n * Support for OV7670 sensors was contributed by Sam Skipsey <aoanla@yahoo.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"ov519\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\n/* The jpeg_hdr is used by w996Xcf only */\n/* The CONEX_CAM define for jpeg.h needs renaming, now its used here too */\n#define CONEX_CAM\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"OV519 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n/* global parameters */\nstatic int frame_rate;\n\n/* Number of times to retry a failed I2C transaction. Increase this if you\n * are getting \"Failed to read sensor ID...\" */\nstatic int i2c_detect_tries = 10;\n\n/* ov519 device descriptor */\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t/* !! must be the first item */\n\n\tstruct v4l2_ctrl *jpegqual;\n\tstruct v4l2_ctrl *freq;\n\tstruct { /* h/vflip control cluster */\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct { /* autobrightness/brightness control cluster */\n\t\tstruct v4l2_ctrl *autobright;\n\t\tstruct v4l2_ctrl *brightness;\n\t};\n\n\tu8 revision;\n\n\tu8 packet_nr;\n\n\tchar bridge;\n#define BRIDGE_OV511\t\t0\n#define BRIDGE_OV511PLUS\t1\n#define BRIDGE_OV518\t\t2\n#define BRIDGE_OV518PLUS\t3\n#define BRIDGE_OV519\t\t4\t\t/* = ov530 */\n#define BRIDGE_OVFX2\t\t5\n#define BRIDGE_W9968CF\t\t6\n#define BRIDGE_MASK\t\t7\n\n\tchar invert_led;\n#define BRIDGE_INVERT_LED\t8\n\n\tchar snapshot_pressed;\n\tchar snapshot_needs_reset;\n\n\t/* Determined by sensor type */\n\tu8 sif;\n\n#define QUALITY_MIN 50\n#define QUALITY_MAX 70\n#define QUALITY_DEF 50\n\n\tu8 stopped;\t\t/* Streaming is temporarily paused */\n\tu8 first_frame;\n\n\tu8 frame_rate;\t\t/* current Framerate */\n\tu8 clockdiv;\t\t/* clockdiv override */\n\n\ts8 sensor;\t\t/* Type of image sensor chip (SEN_*) */\n\n\tu8 sensor_addr;\n\tu16 sensor_width;\n\tu16 sensor_height;\n\ts16 sensor_reg_cache[256];\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\nenum sensors {\n\tSEN_OV2610,\n\tSEN_OV2610AE,\n\tSEN_OV3610,\n\tSEN_OV6620,\n\tSEN_OV6630,\n\tSEN_OV66308AF,\n\tSEN_OV7610,\n\tSEN_OV7620,\n\tSEN_OV7620AE,\n\tSEN_OV7640,\n\tSEN_OV7648,\n\tSEN_OV7660,\n\tSEN_OV7670,\n\tSEN_OV76BE,\n\tSEN_OV8610,\n\tSEN_OV9600,\n};\n\n/* Note this is a bit of a hack, but the w9968cf driver needs the code for all\n   the ov sensors which is already present here. When we have the time we\n   really should move the sensor drivers to v4l2 sub drivers. */\n#include \"w996Xcf.c\"\n\n/* table of the disabled controls */\nstruct ctrl_valid {\n\tunsigned int has_brightness:1;\n\tunsigned int has_contrast:1;\n\tunsigned int has_exposure:1;\n\tunsigned int has_autogain:1;\n\tunsigned int has_sat:1;\n\tunsigned int has_hvflip:1;\n\tunsigned int has_autobright:1;\n\tunsigned int has_freq:1;\n};\n\nstatic const struct ctrl_valid valid_controls[] = {\n\t[SEN_OV2610] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV2610AE] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV3610] = {\n\t\t/* No controls */\n\t},\n\t[SEN_OV6620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV6630] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV66308AF] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620AE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7640] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7648] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7660] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7670] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV76BE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV8610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t},\n\t[SEN_OV9600] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n};\n\nstatic const struct v4l2_pix_format ov519_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov519_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n/* Note some of the sizeimage values for the ov511 / ov518 may seem\n   larger then necessary, however they need to be this big as the ov511 /\n   ov518 always fills the entire isoc frame, using 0 padding bytes when\n   it doesn't have any data. So with low framerates the amount of data\n   transferred can become quite large (libv4l will remove all the 0 padding\n   in userspace). */\nstatic const struct v4l2_pix_format ov518_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov518_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ov511_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov511_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ovfx2_ov2610_mode[] = {\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\nstatic const struct v4l2_pix_format ovfx2_ov3610_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1024, 768, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1024,\n\t\t.sizeimage = 1024 * 768,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{2048, 1536, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 2048,\n\t\t.sizeimage = 2048 * 1536,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ovfx2_ov9600_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1280, 1024, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\n\n/* Registers common to OV511 / OV518 */\n#define R51x_FIFO_PSIZE\t\t\t0x30\t/* 2 bytes wide w/ OV518(+) */\n#define R51x_SYS_RESET\t\t\t0x50\n\t/* Reset type flags */\n\t#define\tOV511_RESET_OMNICE\t0x08\n#define R51x_SYS_INIT\t\t\t0x53\n#define R51x_SYS_SNAP\t\t\t0x52\n#define R51x_SYS_CUST_ID\t\t0x5f\n#define R51x_COMP_LUT_BEGIN\t\t0x80\n\n/* OV511 Camera interface register numbers */\n#define R511_CAM_DELAY\t\t\t0x10\n#define R511_CAM_EDGE\t\t\t0x11\n#define R511_CAM_PXCNT\t\t\t0x12\n#define R511_CAM_LNCNT\t\t\t0x13\n#define R511_CAM_PXDIV\t\t\t0x14\n#define R511_CAM_LNDIV\t\t\t0x15\n#define R511_CAM_UV_EN\t\t\t0x16\n#define R511_CAM_LINE_MODE\t\t0x17\n#define R511_CAM_OPTS\t\t\t0x18\n\n#define R511_SNAP_FRAME\t\t\t0x19\n#define R511_SNAP_PXCNT\t\t\t0x1a\n#define R511_SNAP_LNCNT\t\t\t0x1b\n#define R511_SNAP_PXDIV\t\t\t0x1c\n#define R511_SNAP_LNDIV\t\t\t0x1d\n#define R511_SNAP_UV_EN\t\t\t0x1e\n#define R511_SNAP_OPTS\t\t\t0x1f\n\n#define R511_DRAM_FLOW_CTL\t\t0x20\n#define R511_FIFO_OPTS\t\t\t0x31\n#define R511_I2C_CTL\t\t\t0x40\n#define R511_SYS_LED_CTL\t\t0x55\t/* OV511+ only */\n#define R511_COMP_EN\t\t\t0x78\n#define R511_COMP_LUT_EN\t\t0x79\n\n/* OV518 Camera interface register numbers */\n#define R518_GPIO_OUT\t\t\t0x56\t/* OV518(+) only */\n#define R518_GPIO_CTL\t\t\t0x57\t/* OV518(+) only */\n\n/* OV519 Camera interface register numbers */\n#define OV519_R10_H_SIZE\t\t0x10\n#define OV519_R11_V_SIZE\t\t0x11\n#define OV519_R12_X_OFFSETL\t\t0x12\n#define OV519_R13_X_OFFSETH\t\t0x13\n#define OV519_R14_Y_OFFSETL\t\t0x14\n#define OV519_R15_Y_OFFSETH\t\t0x15\n#define OV519_R16_DIVIDER\t\t0x16\n#define OV519_R20_DFR\t\t\t0x20\n#define OV519_R25_FORMAT\t\t0x25\n\n/* OV519 System Controller register numbers */\n#define OV519_R51_RESET1\t\t0x51\n#define OV519_R54_EN_CLK1\t\t0x54\n#define OV519_R57_SNAPSHOT\t\t0x57\n\n#define OV519_GPIO_DATA_OUT0\t\t0x71\n#define OV519_GPIO_IO_CTRL0\t\t0x72\n\n/*#define OV511_ENDPOINT_ADDRESS 1\t * Isoc endpoint number */\n\n/*\n * The FX2 chip does not give us a zero length read at end of frame.\n * It does, however, give a short read at the end of a frame, if\n * necessary, rather than run two frames together.\n *\n * By choosing the right bulk transfer size, we are guaranteed to always\n * get a short read for the last read of each frame.  Frame sizes are\n * always a composite number (width * height, or a multiple) so if we\n * choose a prime number, we are guaranteed that the last read of a\n * frame will be short.\n *\n * But it isn't that easy: the 2.6 kernel requires a multiple of 4KB,\n * otherwise EOVERFLOW \"babbling\" errors occur.  I have not been able\n * to figure out why.  [PMiller]\n *\n * The constant (13 * 4096) is the largest \"prime enough\" number less than 64KB.\n *\n * It isn't enough to know the number of bytes per frame, in case we\n * have data dropouts or buffer overruns (even though the FX2 double\n * buffers, there are some pretty strict real time constraints for\n * isochronous transfer for larger frame sizes).\n */\n/*jfm: this value does not work for 800x600 - see isoc_init */\n#define OVFX2_BULK_SIZE (13 * 4096)\n\n/* I2C registers */\n#define R51x_I2C_W_SID\t\t0x41\n#define R51x_I2C_SADDR_3\t0x42\n#define R51x_I2C_SADDR_2\t0x43\n#define R51x_I2C_R_SID\t\t0x44\n#define R51x_I2C_DATA\t\t0x45\n#define R518_I2C_CTL\t\t0x47\t/* OV518(+) only */\n#define OVFX2_I2C_ADDR\t\t0x00\n\n/* I2C ADDRESSES */\n#define OV7xx0_SID   0x42\n#define OV_HIRES_SID 0x60\t\t/* OV9xxx / OV2xxx / OV3xxx */\n#define OV8xx0_SID   0xa0\n#define OV6xx0_SID   0xc0\n\n/* OV7610 registers */\n#define OV7610_REG_GAIN\t\t0x00\t/* gain setting (5:0) */\n#define OV7610_REG_BLUE\t\t0x01\t/* blue channel balance */\n#define OV7610_REG_RED\t\t0x02\t/* red channel balance */\n#define OV7610_REG_SAT\t\t0x03\t/* saturation */\n#define OV8610_REG_HUE\t\t0x04\t/* 04 reserved */\n#define OV7610_REG_CNT\t\t0x05\t/* Y contrast */\n#define OV7610_REG_BRT\t\t0x06\t/* Y brightness */\n#define OV7610_REG_COM_C\t0x14\t/* misc common regs */\n#define OV7610_REG_ID_HIGH\t0x1c\t/* manufacturer ID MSB */\n#define OV7610_REG_ID_LOW\t0x1d\t/* manufacturer ID LSB */\n#define OV7610_REG_COM_I\t0x29\t/* misc settings */\n\n/* OV7660 and OV7670 registers */\n#define OV7670_R00_GAIN\t\t0x00\t/* Gain lower 8 bits (rest in vref) */\n#define OV7670_R01_BLUE\t\t0x01\t/* blue gain */\n#define OV7670_R02_RED\t\t0x02\t/* red gain */\n#define OV7670_R03_VREF\t\t0x03\t/* Pieces of GAIN, VSTART, VSTOP */\n#define OV7670_R04_COM1\t\t0x04\t/* Control 1 */\n/*#define OV7670_R07_AECHH\t0x07\t * AEC MS 5 bits */\n#define OV7670_R0C_COM3\t\t0x0c\t/* Control 3 */\n#define OV7670_R0D_COM4\t\t0x0d\t/* Control 4 */\n#define OV7670_R0E_COM5\t\t0x0e\t/* All \"reserved\" */\n#define OV7670_R0F_COM6\t\t0x0f\t/* Control 6 */\n#define OV7670_R10_AECH\t\t0x10\t/* More bits of AEC value */\n#define OV7670_R11_CLKRC\t0x11\t/* Clock control */\n#define OV7670_R12_COM7\t\t0x12\t/* Control 7 */\n#define   OV7670_COM7_FMT_VGA\t 0x00\n/*#define   OV7670_COM7_YUV\t 0x00\t * YUV */\n#define   OV7670_COM7_FMT_QVGA\t 0x10\t/* QVGA format */\n#define   OV7670_COM7_FMT_MASK\t 0x38\n#define   OV7670_COM7_RESET\t 0x80\t/* Register reset */\n#define OV7670_R13_COM8\t\t0x13\t/* Control 8 */\n#define   OV7670_COM8_AEC\t 0x01\t/* Auto exposure enable */\n#define   OV7670_COM8_AWB\t 0x02\t/* White balance enable */\n#define   OV7670_COM8_AGC\t 0x04\t/* Auto gain enable */\n#define   OV7670_COM8_BFILT\t 0x20\t/* Band filter enable */\n#define   OV7670_COM8_AECSTEP\t 0x40\t/* Unlimited AEC step size */\n#define   OV7670_COM8_FASTAEC\t 0x80\t/* Enable fast AGC/AEC */\n#define OV7670_R14_COM9\t\t0x14\t/* Control 9 - gain ceiling */\n#define OV7670_R15_COM10\t0x15\t/* Control 10 */\n#define OV7670_R17_HSTART\t0x17\t/* Horiz start high bits */\n#define OV7670_R18_HSTOP\t0x18\t/* Horiz stop high bits */\n#define OV7670_R19_VSTART\t0x19\t/* Vert start high bits */\n#define OV7670_R1A_VSTOP\t0x1a\t/* Vert stop high bits */\n#define OV7670_R1E_MVFP\t\t0x1e\t/* Mirror / vflip */\n#define   OV7670_MVFP_VFLIP\t 0x10\t/* vertical flip */\n#define   OV7670_MVFP_MIRROR\t 0x20\t/* Mirror image */\n#define OV7670_R24_AEW\t\t0x24\t/* AGC upper limit */\n#define OV7670_R25_AEB\t\t0x25\t/* AGC lower limit */\n#define OV7670_R26_VPT\t\t0x26\t/* AGC/AEC fast mode op region */\n#define OV7670_R32_HREF\t\t0x32\t/* HREF pieces */\n#define OV7670_R3A_TSLB\t\t0x3a\t/* lots of stuff */\n#define OV7670_R3B_COM11\t0x3b\t/* Control 11 */\n#define   OV7670_COM11_EXP\t 0x02\n#define   OV7670_COM11_HZAUTO\t 0x10\t/* Auto detect 50/60 Hz */\n#define OV7670_R3C_COM12\t0x3c\t/* Control 12 */\n#define OV7670_R3D_COM13\t0x3d\t/* Control 13 */\n#define   OV7670_COM13_GAMMA\t 0x80\t/* Gamma enable */\n#define   OV7670_COM13_UVSAT\t 0x40\t/* UV saturation auto adjustment */\n#define OV7670_R3E_COM14\t0x3e\t/* Control 14 */\n#define OV7670_R3F_EDGE\t\t0x3f\t/* Edge enhancement factor */\n#define OV7670_R40_COM15\t0x40\t/* Control 15 */\n/*#define   OV7670_COM15_R00FF\t 0xc0\t *\t00 to FF */\n#define OV7670_R41_COM16\t0x41\t/* Control 16 */\n#define   OV7670_COM16_AWBGAIN\t 0x08\t/* AWB gain enable */\n/* end of ov7660 common registers */\n#define OV7670_R55_BRIGHT\t0x55\t/* Brightness */\n#define OV7670_R56_CONTRAS\t0x56\t/* Contrast control */\n#define OV7670_R69_GFIX\t\t0x69\t/* Fix gain control */\n/*#define OV7670_R8C_RGB444\t0x8c\t * RGB 444 control */\n#define OV7670_R9F_HAECC1\t0x9f\t/* Hist AEC/AGC control 1 */\n#define OV7670_RA0_HAECC2\t0xa0\t/* Hist AEC/AGC control 2 */\n#define OV7670_RA5_BD50MAX\t0xa5\t/* 50hz banding step limit */\n#define OV7670_RA6_HAECC3\t0xa6\t/* Hist AEC/AGC control 3 */\n#define OV7670_RA7_HAECC4\t0xa7\t/* Hist AEC/AGC control 4 */\n#define OV7670_RA8_HAECC5\t0xa8\t/* Hist AEC/AGC control 5 */\n#define OV7670_RA9_HAECC6\t0xa9\t/* Hist AEC/AGC control 6 */\n#define OV7670_RAA_HAECC7\t0xaa\t/* Hist AEC/AGC control 7 */\n#define OV7670_RAB_BD60MAX\t0xab\t/* 60hz banding step limit */\n\nstruct ov_regvals {\n\tu8 reg;\n\tu8 val;\n};\nstruct ov_i2c_regvals {\n\tu8 reg;\n\tu8 val;\n};\n\n/* Settings for OV2610 camera chip */\nstatic const struct ov_i2c_regvals norm_2610[] = {\n\t{ 0x12, 0x80 },\t/* reset */\n};\n\nstatic const struct ov_i2c_regvals norm_2610ae[] = {\n\t{0x12, 0x80},\t/* reset */\n\t{0x13, 0xcd},\n\t{0x09, 0x01},\n\t{0x0d, 0x00},\n\t{0x11, 0x80},\n\t{0x12, 0x20},\t/* 1600x1200 */\n\t{0x33, 0x0c},\n\t{0x35, 0x90},\n\t{0x36, 0x37},\n/* ms-win traces */\n\t{0x11, 0x83},\t/* clock / 3 ? */\n\t{0x2d, 0x00},\t/* 60 Hz filter */\n\t{0x24, 0xb0},\t/* normal colors */\n\t{0x25, 0x90},\n\t{0x10, 0x43},\n};\n\nstatic const struct ov_i2c_regvals norm_3620b[] = {\n\t/*\n\t * From the datasheet: \"Note that after writing to register COMH\n\t * (0x12) to change the sensor mode, registers related to the\n\t * sensor\u2019s cropping window will be reset back to their default\n\t * values.\"\n\t *\n\t * \"wait 4096 external clock ... to make sure the sensor is\n\t * stable and ready to access registers\" i.e. 160us at 24MHz\n\t */\n\t{ 0x12, 0x80 }, /* COMH reset */\n\t{ 0x12, 0x00 }, /* QXGA, master */\n\n\t/*\n\t * 11 CLKRC \"Clock Rate Control\"\n\t * [7] internal frequency doublers: on\n\t * [6] video port mode: master\n\t * [5:0] clock divider: 1\n\t */\n\t{ 0x11, 0x80 },\n\n\t/*\n\t * 13 COMI \"Common Control I\"\n\t *                  = 192 (0xC0) 11000000\n\t *    COMI[7] \"AEC speed selection\"\n\t *                  =   1 (0x01) 1....... \"Faster AEC correction\"\n\t *    COMI[6] \"AEC speed step selection\"\n\t *                  =   1 (0x01) .1...... \"Big steps, fast\"\n\t *    COMI[5] \"Banding filter on off\"\n\t *                  =   0 (0x00) ..0..... \"Off\"\n\t *    COMI[4] \"Banding filter option\"\n\t *                  =   0 (0x00) ...0.... \"Main clock is 48 MHz and\n\t *                                         the PLL is ON\"\n\t *    COMI[3] \"Reserved\"\n\t *                  =   0 (0x00) ....0...\n\t *    COMI[2] \"AGC auto manual control selection\"\n\t *                  =   0 (0x00) .....0.. \"Manual\"\n\t *    COMI[1] \"AWB auto manual control selection\"\n\t *                  =   0 (0x00) ......0. \"Manual\"\n\t *    COMI[0] \"Exposure control\"\n\t *                  =   0 (0x00) .......0 \"Manual\"\n\t */\n\t{ 0x13, 0xc0 },\n\n\t/*\n\t * 09 COMC \"Common Control C\"\n\t *                  =   8 (0x08) 00001000\n\t *    COMC[7:5] \"Reserved\"\n\t *                  =   0 (0x00) 000.....\n\t *    COMC[4] \"Sleep Mode Enable\"\n\t *                  =   0 (0x00) ...0.... \"Normal mode\"\n\t *    COMC[3:2] \"Sensor sampling reset timing selection\"\n\t *                  =   2 (0x02) ....10.. \"Longer reset time\"\n\t *    COMC[1:0] \"Output drive current select\"\n\t *                  =   0 (0x00) ......00 \"Weakest\"\n\t */\n\t{ 0x09, 0x08 },\n\n\t/*\n\t * 0C COMD \"Common Control D\"\n\t *                  =   8 (0x08) 00001000\n\t *    COMD[7] \"Reserved\"\n\t *                  =   0 (0x00) 0.......\n\t *    COMD[6] \"Swap MSB and LSB at the output port\"\n\t *                  =   0 (0x00) .0...... \"False\"\n\t *    COMD[5:3] \"Reserved\"\n\t *                  =   1 (0x01) ..001...\n\t *    COMD[2] \"Output Average On Off\"\n\t *                  =   0 (0x00) .....0.. \"Output Normal\"\n\t *    COMD[1] \"Sensor precharge voltage selection\"\n\t *                  =   0 (0x00) ......0. \"Selects internal\n\t *                                         reference precharge\n\t *                                         voltage\"\n\t *    COMD[0] \"Snapshot option\"\n\t *                  =   0 (0x00) .......0 \"Enable live video output\n\t *                                         after snapshot sequence\"\n\t */\n\t{ 0x0c, 0x08 },\n\n\t/*\n\t * 0D COME \"Common Control E\"\n\t *                  = 161 (0xA1) 10100001\n\t *    COME[7] \"Output average option\"\n\t *                  =   1 (0x01) 1....... \"Output average of 4 pixels\"\n\t *    COME[6] \"Anti-blooming control\"\n\t *                  =   0 (0x00) .0...... \"Off\"\n\t *    COME[5:3] \"Reserved\"\n\t *                  =   4 (0x04) ..100...\n\t *    COME[2] \"Clock output power down pin status\"\n\t *                  =   0 (0x00) .....0.. \"Tri-state data output pin\n\t *                                         on power down\"\n\t *    COME[1] \"Data output pin status selection at power down\"\n\t *                  =   0 (0x00) ......0. \"Tri-state VSYNC, PCLK,\n\t *                                         HREF, and CHSYNC pins on\n\t *                                         power down\"\n\t *    COME[0] \"Auto zero circuit select\"\n\t *                  =   1 (0x01) .......1 \"On\"\n\t */\n\t{ 0x0d, 0xa1 },\n\n\t/*\n\t * 0E COMF \"Common Control F\"\n\t *                  = 112 (0x70) 01110000\n\t *    COMF[7] \"System clock selection\"\n\t *                  =   0 (0x00) 0....... \"Use 24 MHz system clock\"\n\t *    COMF[6:4] \"Reserved\"\n\t *                  =   7 (0x07) .111....\n\t *    COMF[3] \"Manual auto negative offset canceling selection\"\n\t *                  =   0 (0x00) ....0... \"Auto detect negative\n\t *                                         offset and cancel it\"\n\t *    COMF[2:0] \"Reserved\"\n\t *                  =   0 (0x00) .....000\n\t */\n\t{ 0x0e, 0x70 },\n\n\t/*\n\t * 0F COMG \"Common Control G\"\n\t *                  =  66 (0x42) 01000010\n\t *    COMG[7] \"Optical black output selection\"\n\t *                  =   0 (0x00) 0....... \"Disable\"\n\t *    COMG[6] \"Black level calibrate selection\"\n\t *                  =   1 (0x01) .1...... \"Use optical black pixels\n\t *                                         to calibrate\"\n\t *    COMG[5:4] \"Reserved\"\n\t *                  =   0 (0x00) ..00....\n\t *    COMG[3] \"Channel offset adjustment\"\n\t *                  =   0 (0x00) ....0... \"Disable offset adjustment\"\n\t *    COMG[2] \"ADC black level calibration option\"\n\t *                  =   0 (0x00) .....0.. \"Use B/G line and G/R\n\t *                                         line to calibrate each\n\t *                                         channel's black level\"\n\t *    COMG[1] \"Reserved\"\n\t *                  =   1 (0x01) ......1.\n\t *    COMG[0] \"ADC black level calibration enable\"\n\t *                  =   0 (0x00) .......0 \"Disable\"\n\t */\n\t{ 0x0f, 0x42 },\n\n\t/*\n\t * 14 COMJ \"Common Control J\"\n\t *                  = 198 (0xC6) 11000110\n\t *    COMJ[7:6] \"AGC gain ceiling\"\n\t *                  =   3 (0x03) 11...... \"8x\"\n\t *    COMJ[5:4] \"Reserved\"\n\t *                  =   0 (0x00) ..00....\n\t *    COMJ[3] \"Auto banding filter\"\n\t *                  =   0 (0x00) ....0... \"Banding filter is always\n\t *                                         on off depending on\n\t *                                         COMI[5] setting\"\n\t *    COMJ[2] \"VSYNC drop option\"\n\t *                  =   1 (0x01) .....1.. \"SYNC is dropped if frame\n\t *                                         data is dropped\"\n\t *    COMJ[1] \"Frame data drop\"\n\t *                  =   1 (0x01) ......1. \"Drop frame data if\n\t *                                         exposure is not within\n\t *                                         tolerance.  In AEC mode,\n\t *                                         data is normally dropped\n\t *                                         when data is out of\n\t *                                         range.\"\n\t *    COMJ[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x14, 0xc6 },\n\n\t/*\n\t * 15 COMK \"Common Control K\"\n\t *                  =   2 (0x02) 00000010\n\t *    COMK[7] \"CHSYNC pin output swap\"\n\t *                  =   0 (0x00) 0....... \"CHSYNC\"\n\t *    COMK[6] \"HREF pin output swap\"\n\t *                  =   0 (0x00) .0...... \"HREF\"\n\t *    COMK[5] \"PCLK output selection\"\n\t *                  =   0 (0x00) ..0..... \"PCLK always output\"\n\t *    COMK[4] \"PCLK edge selection\"\n\t *                  =   0 (0x00) ...0.... \"Data valid on falling edge\"\n\t *    COMK[3] \"HREF output polarity\"\n\t *                  =   0 (0x00) ....0... \"positive\"\n\t *    COMK[2] \"Reserved\"\n\t *                  =   0 (0x00) .....0..\n\t *    COMK[1] \"VSYNC polarity\"\n\t *                  =   1 (0x01) ......1. \"negative\"\n\t *    COMK[0] \"HSYNC polarity\"\n\t *                  =   0 (0x00) .......0 \"positive\"\n\t */\n\t{ 0x15, 0x02 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =   9 (0x09) 00001001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   0 (0x00) ...0.... \"normal current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x09 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  80 (0x50) 01010000\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x34, 0x50 },\n\n\t/*\n\t * 36 VCHG \"Sensor Precharge Voltage Control\"\n\t *                  =   0 (0x00) 00000000\n\t *    VCHG[7] \"Reserved\"\n\t *                  =   0 (0x00) 0.......\n\t *    VCHG[6:4] \"Sensor precharge voltage control\"\n\t *                  =   0 (0x00) .000....\n\t *    VCHG[3:0] \"Sensor array common reference\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x36, 0x00 },\n\n\t/*\n\t * 37 ADC \"ADC Reference Control\"\n\t *                  =   4 (0x04) 00000100\n\t *    ADC[7:4] \"Reserved\"\n\t *                  =   0 (0x00) 0000....\n\t *    ADC[3] \"ADC input signal range\"\n\t *                  =   0 (0x00) ....0... \"Input signal 1.0x\"\n\t *    ADC[2:0] \"ADC range control\"\n\t *                  =   4 (0x04) .....100\n\t */\n\t{ 0x37, 0x04 },\n\n\t/*\n\t * 38 ACOM \"Analog Common Ground\"\n\t *                  =  82 (0x52) 01010010\n\t *    ACOM[7] \"Analog gain control\"\n\t *                  =   0 (0x00) 0....... \"Gain 1x\"\n\t *    ACOM[6] \"Analog black level calibration\"\n\t *                  =   1 (0x01) .1...... \"On\"\n\t *    ACOM[5:0] \"Reserved\"\n\t *                  =  18 (0x12) ..010010\n\t */\n\t{ 0x38, 0x52 },\n\n\t/*\n\t * 3A FREFA \"Internal Reference Adjustment\"\n\t *                  =   0 (0x00) 00000000\n\t *    FREFA[7:0] \"Range\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3a, 0x00 },\n\n\t/*\n\t * 3C FVOPT \"Internal Reference Adjustment\"\n\t *                  =  31 (0x1F) 00011111\n\t *    FVOPT[7:0] \"Range\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x3c, 0x1f },\n\n\t/*\n\t * 44 Undocumented  =   0 (0x00) 00000000\n\t *    44[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x44, 0x00 },\n\n\t/*\n\t * 40 Undocumented  =   0 (0x00) 00000000\n\t *    40[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x40, 0x00 },\n\n\t/*\n\t * 41 Undocumented  =   0 (0x00) 00000000\n\t *    41[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x41, 0x00 },\n\n\t/*\n\t * 42 Undocumented  =   0 (0x00) 00000000\n\t *    42[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x42, 0x00 },\n\n\t/*\n\t * 43 Undocumented  =   0 (0x00) 00000000\n\t *    43[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x43, 0x00 },\n\n\t/*\n\t * 45 Undocumented  = 128 (0x80) 10000000\n\t *    45[7:0] \"It's a secret\"\n\t *                  = 128 (0x80) 10000000\n\t */\n\t{ 0x45, 0x80 },\n\n\t/*\n\t * 48 Undocumented  = 192 (0xC0) 11000000\n\t *    48[7:0] \"It's a secret\"\n\t *                  = 192 (0xC0) 11000000\n\t */\n\t{ 0x48, 0xc0 },\n\n\t/*\n\t * 49 Undocumented  =  25 (0x19) 00011001\n\t *    49[7:0] \"It's a secret\"\n\t *                  =  25 (0x19) 00011001\n\t */\n\t{ 0x49, 0x19 },\n\n\t/*\n\t * 4B Undocumented  = 128 (0x80) 10000000\n\t *    4B[7:0] \"It's a secret\"\n\t *                  = 128 (0x80) 10000000\n\t */\n\t{ 0x4b, 0x80 },\n\n\t/*\n\t * 4D Undocumented  = 196 (0xC4) 11000100\n\t *    4D[7:0] \"It's a secret\"\n\t *                  = 196 (0xC4) 11000100\n\t */\n\t{ 0x4d, 0xc4 },\n\n\t/*\n\t * 35 VREF \"Reference Voltage Control\"\n\t *                  =  76 (0x4c) 01001100\n\t *    VREF[7:5] \"Column high reference control\"\n\t *                  =   2 (0x02) 010..... \"higher voltage\"\n\t *    VREF[4:2] \"Column low reference control\"\n\t *                  =   3 (0x03) ...011.. \"Highest voltage\"\n\t *    VREF[1:0] \"Reserved\"\n\t *                  =   0 (0x00) ......00\n\t */\n\t{ 0x35, 0x4c },\n\n\t/*\n\t * 3D Undocumented  =   0 (0x00) 00000000\n\t *    3D[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3d, 0x00 },\n\n\t/*\n\t * 3E Undocumented  =   0 (0x00) 00000000\n\t *    3E[7:0] \"It's a secret\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3e, 0x00 },\n\n\t/*\n\t * 3B FREFB \"Internal Reference Adjustment\"\n\t *                  =  24 (0x18) 00011000\n\t *    FREFB[7:0] \"Range\"\n\t *                  =  24 (0x18) 00011000\n\t */\n\t{ 0x3b, 0x18 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =  25 (0x19) 00011001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   1 (0x01) ...1.... \"double current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x19 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  90 (0x5A) 01011010\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =  10 (0x0A) ....1010\n\t */\n\t{ 0x34, 0x5a },\n\n\t/*\n\t * 3B FREFB \"Internal Reference Adjustment\"\n\t *                  =   0 (0x00) 00000000\n\t *    FREFB[7:0] \"Range\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x3b, 0x00 },\n\n\t/*\n\t * 33 CHLF \"Current Control\"\n\t *                  =   9 (0x09) 00001001\n\t *    CHLF[7:6] \"Sensor current control\"\n\t *                  =   0 (0x00) 00......\n\t *    CHLF[5] \"Sensor current range control\"\n\t *                  =   0 (0x00) ..0..... \"normal range\"\n\t *    CHLF[4] \"Sensor current\"\n\t *                  =   0 (0x00) ...0.... \"normal current\"\n\t *    CHLF[3] \"Sensor buffer current control\"\n\t *                  =   1 (0x01) ....1... \"half current\"\n\t *    CHLF[2] \"Column buffer current control\"\n\t *                  =   0 (0x00) .....0.. \"normal current\"\n\t *    CHLF[1] \"Analog DSP current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t *    CHLF[1] \"ADC current control\"\n\t *                  =   0 (0x00) ......0. \"normal current\"\n\t */\n\t{ 0x33, 0x09 },\n\n\t/*\n\t * 34 VBLM \"Blooming Control\"\n\t *                  =  80 (0x50) 01010000\n\t *    VBLM[7] \"Hard soft reset switch\"\n\t *                  =   0 (0x00) 0....... \"Hard reset\"\n\t *    VBLM[6:4] \"Blooming voltage selection\"\n\t *                  =   5 (0x05) .101....\n\t *    VBLM[3:0] \"Sensor current control\"\n\t *                  =   0 (0x00) ....0000\n\t */\n\t{ 0x34, 0x50 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =  64 (0x40) 01000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   4 (0x04) .100.... \"XGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x40 },\n\n\t/*\n\t * 17 HREFST \"Horizontal window start\"\n\t *                  =  31 (0x1F) 00011111\n\t *    HREFST[7:0] \"Horizontal window start, 8 MSBs\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x17, 0x1f },\n\n\t/*\n\t * 18 HREFEND \"Horizontal window end\"\n\t *                  =  95 (0x5F) 01011111\n\t *    HREFEND[7:0] \"Horizontal Window End, 8 MSBs\"\n\t *                  =  95 (0x5F) 01011111\n\t */\n\t{ 0x18, 0x5f },\n\n\t/*\n\t * 19 VSTRT \"Vertical window start\"\n\t *                  =   0 (0x00) 00000000\n\t *    VSTRT[7:0] \"Vertical Window Start, 8 MSBs\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x19, 0x00 },\n\n\t/*\n\t * 1A VEND \"Vertical window end\"\n\t *                  =  96 (0x60) 01100000\n\t *    VEND[7:0] \"Vertical Window End, 8 MSBs\"\n\t *                  =  96 (0x60) 01100000\n\t */\n\t{ 0x1a, 0x60 },\n\n\t/*\n\t * 32 COMM \"Common Control M\"\n\t *                  =  18 (0x12) 00010010\n\t *    COMM[7:6] \"Pixel clock divide option\"\n\t *                  =   0 (0x00) 00...... \"/1\"\n\t *    COMM[5:3] \"Horizontal window end position, 3 LSBs\"\n\t *                  =   2 (0x02) ..010...\n\t *    COMM[2:0] \"Horizontal window start position, 3 LSBs\"\n\t *                  =   2 (0x02) .....010\n\t */\n\t{ 0x32, 0x12 },\n\n\t/*\n\t * 03 COMA \"Common Control A\"\n\t *                  =  74 (0x4A) 01001010\n\t *    COMA[7:4] \"AWB Update Threshold\"\n\t *                  =   4 (0x04) 0100....\n\t *    COMA[3:2] \"Vertical window end line control 2 LSBs\"\n\t *                  =   2 (0x02) ....10..\n\t *    COMA[1:0] \"Vertical window start line control 2 LSBs\"\n\t *                  =   2 (0x02) ......10\n\t */\n\t{ 0x03, 0x4a },\n\n\t/*\n\t * 11 CLKRC \"Clock Rate Control\"\n\t *                  = 128 (0x80) 10000000\n\t *    CLKRC[7] \"Internal frequency doublers on off seclection\"\n\t *                  =   1 (0x01) 1....... \"On\"\n\t *    CLKRC[6] \"Digital video master slave selection\"\n\t *                  =   0 (0x00) .0...... \"Master mode, sensor\n\t *                                         provides PCLK\"\n\t *    CLKRC[5:0] \"Clock divider { CLK = PCLK/(1+CLKRC[5:0]) }\"\n\t *                  =   0 (0x00) ..000000\n\t */\n\t{ 0x11, 0x80 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =   0 (0x00) 00000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   0 (0x00) .000.... \"QXGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x00 },\n\n\t/*\n\t * 12 COMH \"Common Control H\"\n\t *                  =  64 (0x40) 01000000\n\t *    COMH[7] \"SRST\"\n\t *                  =   0 (0x00) 0....... \"No-op\"\n\t *    COMH[6:4] \"Resolution selection\"\n\t *                  =   4 (0x04) .100.... \"XGA\"\n\t *    COMH[3] \"Master slave selection\"\n\t *                  =   0 (0x00) ....0... \"Master mode\"\n\t *    COMH[2] \"Internal B/R channel option\"\n\t *                  =   0 (0x00) .....0.. \"B/R use same channel\"\n\t *    COMH[1] \"Color bar test pattern\"\n\t *                  =   0 (0x00) ......0. \"Off\"\n\t *    COMH[0] \"Reserved\"\n\t *                  =   0 (0x00) .......0\n\t */\n\t{ 0x12, 0x40 },\n\n\t/*\n\t * 17 HREFST \"Horizontal window start\"\n\t *                  =  31 (0x1F) 00011111\n\t *    HREFST[7:0] \"Horizontal window start, 8 MSBs\"\n\t *                  =  31 (0x1F) 00011111\n\t */\n\t{ 0x17, 0x1f },\n\n\t/*\n\t * 18 HREFEND \"Horizontal window end\"\n\t *                  =  95 (0x5F) 01011111\n\t *    HREFEND[7:0] \"Horizontal Window End, 8 MSBs\"\n\t *                  =  95 (0x5F) 01011111\n\t */\n\t{ 0x18, 0x5f },\n\n\t/*\n\t * 19 VSTRT \"Vertical window start\"\n\t *                  =   0 (0x00) 00000000\n\t *    VSTRT[7:0] \"Vertical Window Start, 8 MSBs\"\n\t *                  =   0 (0x00) 00000000\n\t */\n\t{ 0x19, 0x00 },\n\n\t/*\n\t * 1A VEND \"Vertical window end\"\n\t *                  =  96 (0x60) 01100000\n\t *    VEND[7:0] \"Vertical Window End, 8 MSBs\"\n\t *                  =  96 (0x60) 01100000\n\t */\n\t{ 0x1a, 0x60 },\n\n\t/*\n\t * 32 COMM \"Common Control M\"\n\t *                  =  18 (0x12) 00010010\n\t *    COMM[7:6] \"Pixel clock divide option\"\n\t *                  =   0 (0x00) 00...... \"/1\"\n\t *    COMM[5:3] \"Horizontal window end position, 3 LSBs\"\n\t *                  =   2 (0x02) ..010...\n\t *    COMM[2:0] \"Horizontal window start position, 3 LSBs\"\n\t *                  =   2 (0x02) .....010\n\t */\n\t{ 0x32, 0x12 },\n\n\t/*\n\t * 03 COMA \"Common Control A\"\n\t *                  =  74 (0x4A) 01001010\n\t *    COMA[7:4] \"AWB Update Threshold\"\n\t *                  =   4 (0x04) 0100....\n\t *    COMA[3:2] \"Vertical window end line control 2 LSBs\"\n\t *                  =   2 (0x02) ....10..\n\t *    COMA[1:0] \"Vertical window start line control 2 LSBs\"\n\t *                  =   2 (0x02) ......10\n\t */\n\t{ 0x03, 0x4a },\n\n\t/*\n\t * 02 RED \"Red Gain Control\"\n\t *                  = 175 (0xAF) 10101111\n\t *    RED[7] \"Action\"\n\t *                  =   1 (0x01) 1....... \"gain = 1/(1+bitrev([6:0]))\"\n\t *    RED[6:0] \"Value\"\n\t *                  =  47 (0x2F) .0101111\n\t */\n\t{ 0x02, 0xaf },\n\n\t/*\n\t * 2D ADDVSL \"VSYNC Pulse Width\"\n\t *                  = 210 (0xD2) 11010010\n\t *    ADDVSL[7:0] \"VSYNC pulse width, LSB\"\n\t *                  = 210 (0xD2) 11010010\n\t */\n\t{ 0x2d, 0xd2 },\n\n\t/*\n\t * 00 GAIN          =  24 (0x18) 00011000\n\t *    GAIN[7:6] \"Reserved\"\n\t *                  =   0 (0x00) 00......\n\t *    GAIN[5] \"Double\"\n\t *                  =   0 (0x00) ..0..... \"False\"\n\t *    GAIN[4] \"Double\"\n\t *                  =   1 (0x01) ...1.... \"True\"\n\t *    GAIN[3:0] \"Range\"\n\t *                  =   8 (0x08) ....1000\n\t */\n\t{ 0x00, 0x18 },\n\n\t/*\n\t * 01 BLUE \"Blue Gain Control\"\n\t *                  = 240 (0xF0) 11110000\n\t *    BLUE[7] \"Action\"\n\t *                  =   1 (0x01) 1....... \"gain = 1/(1+bitrev([6:0]))\"\n\t *    BLUE[6:0] \"Value\"\n\t *                  = 112 (0x70) .1110000\n\t */\n\t{ 0x01, 0xf0 },\n\n\t/*\n\t * 10 AEC \"Automatic Exposure Control\"\n\t *                  =  10 (0x0A) 00001010\n\t *    AEC[7:0] \"Automatic Exposure Control, 8 MSBs\"\n\t *                  =  10 (0x0A) 00001010\n\t */\n\t{ 0x10, 0x0a },\n\n\t{ 0xe1, 0x67 },\n\t{ 0xe3, 0x03 },\n\t{ 0xe4, 0x26 },\n\t{ 0xe5, 0x3e },\n\t{ 0xf8, 0x01 },\n\t{ 0xff, 0x01 },\n};\n\nstatic const struct ov_i2c_regvals norm_6x20[] = {\n\t{ 0x12, 0x80 }, /* reset */\n\t{ 0x11, 0x01 },\n\t{ 0x03, 0x60 },\n\t{ 0x05, 0x7f }, /* For when autoadjust is off */\n\t{ 0x07, 0xa8 },\n\t/* The ratio of 0x0c and 0x0d controls the white point */\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x0f, 0x15 }, /* COMS */\n\t{ 0x10, 0x75 }, /* AEC Exposure time */\n\t{ 0x12, 0x24 }, /* Enable AGC */\n\t{ 0x14, 0x04 },\n\t/* 0x16: 0x06 helps frame stability with moving objects */\n\t{ 0x16, 0x06 },\n/*\t{ 0x20, 0x30 },  * Aperture correction enable */\n\t{ 0x26, 0xb2 }, /* BLC enable */\n\t/* 0x28: 0x05 Selects RGB format if RGB on */\n\t{ 0x28, 0x05 },\n\t{ 0x2a, 0x04 }, /* Disable framerate adjust */\n/*\t{ 0x2b, 0xac },  * Framerate; Set 2a[7] first */\n\t{ 0x2d, 0x85 },\n\t{ 0x33, 0xa0 }, /* Color Processing Parameter */\n\t{ 0x34, 0xd2 }, /* Max A/D range */\n\t{ 0x38, 0x8b },\n\t{ 0x39, 0x40 },\n\n\t{ 0x3c, 0x39 }, /* Enable AEC mode changing */\n\t{ 0x3c, 0x3c }, /* Change AEC mode */\n\t{ 0x3c, 0x24 }, /* Disable AEC mode changing */\n\n\t{ 0x3d, 0x80 },\n\t/* These next two registers (0x4a, 0x4b) are undocumented.\n\t * They control the color balance */\n\t{ 0x4a, 0x80 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4d, 0xd2 }, /* This reduces noise a bit */\n\t{ 0x4e, 0xc1 },\n\t{ 0x4f, 0x04 },\n/* Do 50-53 have any effect? */\n/* Toggle 0x12[2] off and on here? */\n};\n\nstatic const struct ov_i2c_regvals norm_6x30[] = {\n\t{ 0x12, 0x80 }, /* Reset */\n\t{ 0x00, 0x1f }, /* Gain */\n\t{ 0x01, 0x99 }, /* Blue gain */\n\t{ 0x02, 0x7c }, /* Red gain */\n\t{ 0x03, 0xc0 }, /* Saturation */\n\t{ 0x05, 0x0a }, /* Contrast */\n\t{ 0x06, 0x95 }, /* Brightness */\n\t{ 0x07, 0x2d }, /* Sharpness */\n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x0e, 0xa0 }, /* Was 0x20, bit7 enables a 2x gain which we need */\n\t{ 0x0f, 0x05 },\n\t{ 0x10, 0x9a },\n\t{ 0x11, 0x00 }, /* Pixel clock = fastest */\n\t{ 0x12, 0x24 }, /* Enable AGC and AWB */\n\t{ 0x13, 0x21 },\n\t{ 0x14, 0x80 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 },\n\t{ 0x18, 0xea },\n\t{ 0x19, 0x04 },\n\t{ 0x1a, 0x93 },\n\t{ 0x1b, 0x00 },\n\t{ 0x1e, 0xc4 },\n\t{ 0x1f, 0x04 },\n\t{ 0x20, 0x20 },\n\t{ 0x21, 0x10 },\n\t{ 0x22, 0x88 },\n\t{ 0x23, 0xc0 }, /* Crystal circuit power level */\n\t{ 0x25, 0x9a }, /* Increase AEC black ratio */\n\t{ 0x26, 0xb2 }, /* BLC enable */\n\t{ 0x27, 0xa2 },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x84 }, /* 60 Hz power */\n\t{ 0x2b, 0xa8 }, /* 60 Hz power */\n\t{ 0x2c, 0xa0 },\n\t{ 0x2d, 0x95 }, /* Enable auto-brightness */\n\t{ 0x2e, 0x88 },\n\t{ 0x33, 0x26 },\n\t{ 0x34, 0x03 },\n\t{ 0x36, 0x8f },\n\t{ 0x37, 0x80 },\n\t{ 0x38, 0x83 },\n\t{ 0x39, 0x80 },\n\t{ 0x3a, 0x0f },\n\t{ 0x3b, 0x3c },\n\t{ 0x3c, 0x1a },\n\t{ 0x3d, 0x80 },\n\t{ 0x3e, 0x80 },\n\t{ 0x3f, 0x0e },\n\t{ 0x40, 0x00 }, /* White bal */\n\t{ 0x41, 0x00 }, /* White bal */\n\t{ 0x42, 0x80 },\n\t{ 0x43, 0x3f }, /* White bal */\n\t{ 0x44, 0x80 },\n\t{ 0x45, 0x20 },\n\t{ 0x46, 0x20 },\n\t{ 0x47, 0x80 },\n\t{ 0x48, 0x7f },\n\t{ 0x49, 0x00 },\n\t{ 0x4a, 0x00 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4c, 0xd0 },\n\t{ 0x4d, 0x10 }, /* U = 0.563u, V = 0.714v */\n\t{ 0x4e, 0x40 },\n\t{ 0x4f, 0x07 }, /* UV avg., col. killer: max */\n\t{ 0x50, 0xff },\n\t{ 0x54, 0x23 }, /* Max AGC gain: 18dB */\n\t{ 0x55, 0xff },\n\t{ 0x56, 0x12 },\n\t{ 0x57, 0x81 },\n\t{ 0x58, 0x75 },\n\t{ 0x59, 0x01 }, /* AGC dark current comp.: +1 */\n\t{ 0x5a, 0x2c },\n\t{ 0x5b, 0x0f }, /* AWB chrominance levels */\n\t{ 0x5c, 0x10 },\n\t{ 0x3d, 0x80 },\n\t{ 0x27, 0xa6 },\n\t{ 0x12, 0x20 }, /* Toggle AWB */\n\t{ 0x12, 0x24 },\n};\n\n/* Lawrence Glaister <lg@jfm.bc.ca> reports:\n *\n * Register 0x0f in the 7610 has the following effects:\n *\n * 0x85 (AEC method 1): Best overall, good contrast range\n * 0x45 (AEC method 2): Very overexposed\n * 0xa5 (spec sheet default): Ok, but the black level is\n *\tshifted resulting in loss of contrast\n * 0x05 (old driver setting): very overexposed, too much\n *\tcontrast\n */\nstatic const struct ov_i2c_regvals norm_7610[] = {\n\t{ 0x10, 0xff },\n\t{ 0x16, 0x06 },\n\t{ 0x28, 0x24 },\n\t{ 0x2b, 0xac },\n\t{ 0x12, 0x00 },\n\t{ 0x38, 0x81 },\n\t{ 0x28, 0x24 },\t/* 0c */\n\t{ 0x0f, 0x85 },\t/* lg's setting */\n\t{ 0x15, 0x01 },\n\t{ 0x20, 0x1c },\n\t{ 0x23, 0x2a },\n\t{ 0x24, 0x10 },\n\t{ 0x25, 0x8a },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xc2 },\n\t{ 0x2a, 0x04 },\n\t{ 0x2c, 0xfe },\n\t{ 0x2d, 0x93 },\n\t{ 0x30, 0x71 },\n\t{ 0x31, 0x60 },\n\t{ 0x32, 0x26 },\n\t{ 0x33, 0x20 },\n\t{ 0x34, 0x48 },\n\t{ 0x12, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n};\n\nstatic const struct ov_i2c_regvals norm_7620[] = {\n\t{ 0x12, 0x80 },\t\t/* reset */\n\t{ 0x00, 0x00 },\t\t/* gain */\n\t{ 0x01, 0x80 },\t\t/* blue gain */\n\t{ 0x02, 0x80 },\t\t/* red gain */\n\t{ 0x03, 0xc0 },\t\t/* OV7670_R03_VREF */\n\t{ 0x06, 0x60 },\n\t{ 0x07, 0x00 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x24 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x84 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x2f },\n\t{ 0x18, 0xcf },\n\t{ 0x19, 0x06 },\n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0x18 },\n\t{ 0x21, 0x80 },\n\t{ 0x22, 0x80 },\n\t{ 0x23, 0x00 },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x22 }, /* Was 0x20, bit1 enables a 2x gain which we need */\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x10 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x88 },\n\t{ 0x2d, 0x91 },\n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x44 },\n\t{ 0x60, 0x27 },\n\t{ 0x61, 0x02 },\n\t{ 0x62, 0x5f },\n\t{ 0x63, 0xd5 },\n\t{ 0x64, 0x57 },\n\t{ 0x65, 0x83 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0x92 },\n\t{ 0x68, 0xcf },\n\t{ 0x69, 0x76 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x02 },\n\t{ 0x6d, 0x44 },\n\t{ 0x6e, 0x80 },\n\t{ 0x6f, 0x1d },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 },\n\t{ 0x75, 0x8e },\n\t{ 0x76, 0x00 },\n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0xe2 },\n\t{ 0x7c, 0x00 },\n};\n\n/* 7640 and 7648. The defaults should be OK for most registers. */\nstatic const struct ov_i2c_regvals norm_7640[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x12, 0x14 },\n};\n\nstatic const struct ov_regvals init_519_ov7660[] = {\n\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t{ 0x53,\t0x9b }, /* 0x9f enables the (unused) microcontroller */\n\t{ 0x54,\t0x0f }, /* bit2 (jpeg enable) */\n\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t{ 0xa3,\t0x18 },\n\t{ 0xa4,\t0x04 },\n\t{ 0xa5,\t0x28 },\n\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t{ 0x20,\t0x0c },\t/* 0x0d does U <-> V swap */\n\t{ 0x21,\t0x38 },\n\t{ 0x22,\t0x1d },\n\t{ 0x17,\t0x50 }, /* undocumented */\n\t{ 0x37,\t0x00 }, /* undocumented */\n\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n};\nstatic const struct ov_i2c_regvals norm_7660[] = {\n\t{OV7670_R12_COM7, OV7670_COM7_RESET},\n\t{OV7670_R11_CLKRC, 0x81},\n\t{0x92, 0x00},\t\t\t/* DM_LNL */\n\t{0x93, 0x00},\t\t\t/* DM_LNH */\n\t{0x9d, 0x4c},\t\t\t/* BD50ST */\n\t{0x9e, 0x3f},\t\t\t/* BD60ST */\n\t{OV7670_R3B_COM11, 0x02},\n\t{OV7670_R13_COM8, 0xf5},\n\t{OV7670_R10_AECH, 0x00},\n\t{OV7670_R00_GAIN, 0x00},\n\t{OV7670_R01_BLUE, 0x7c},\n\t{OV7670_R02_RED, 0x9d},\n\t{OV7670_R12_COM7, 0x00},\n\t{OV7670_R04_COM1, 00},\n\t{OV7670_R18_HSTOP, 0x01},\n\t{OV7670_R17_HSTART, 0x13},\n\t{OV7670_R32_HREF, 0x92},\n\t{OV7670_R19_VSTART, 0x02},\n\t{OV7670_R1A_VSTOP, 0x7a},\n\t{OV7670_R03_VREF, 0x00},\n\t{OV7670_R0E_COM5, 0x04},\n\t{OV7670_R0F_COM6, 0x62},\n\t{OV7670_R15_COM10, 0x00},\n\t{0x16, 0x02},\t\t\t/* RSVD */\n\t{0x1b, 0x00},\t\t\t/* PSHFT */\n\t{OV7670_R1E_MVFP, 0x01},\n\t{0x29, 0x3c},\t\t\t/* RSVD */\n\t{0x33, 0x00},\t\t\t/* CHLF */\n\t{0x34, 0x07},\t\t\t/* ARBLM */\n\t{0x35, 0x84},\t\t\t/* RSVD */\n\t{0x36, 0x00},\t\t\t/* RSVD */\n\t{0x37, 0x04},\t\t\t/* ADC */\n\t{0x39, 0x43},\t\t\t/* OFON */\n\t{OV7670_R3A_TSLB, 0x00},\n\t{OV7670_R3C_COM12, 0x6c},\n\t{OV7670_R3D_COM13, 0x98},\n\t{OV7670_R3F_EDGE, 0x23},\n\t{OV7670_R40_COM15, 0xc1},\n\t{OV7670_R41_COM16, 0x22},\n\t{0x6b, 0x0a},\t\t\t/* DBLV */\n\t{0xa1, 0x08},\t\t\t/* RSVD */\n\t{0x69, 0x80},\t\t\t/* HV */\n\t{0x43, 0xf0},\t\t\t/* RSVD.. */\n\t{0x44, 0x10},\n\t{0x45, 0x78},\n\t{0x46, 0xa8},\n\t{0x47, 0x60},\n\t{0x48, 0x80},\n\t{0x59, 0xba},\n\t{0x5a, 0x9a},\n\t{0x5b, 0x22},\n\t{0x5c, 0xb9},\n\t{0x5d, 0x9b},\n\t{0x5e, 0x10},\n\t{0x5f, 0xe0},\n\t{0x60, 0x85},\n\t{0x61, 0x60},\n\t{0x9f, 0x9d},\t\t\t/* RSVD */\n\t{0xa0, 0xa0},\t\t\t/* DSPC2 */\n\t{0x4f, 0x60},\t\t\t/* matrix */\n\t{0x50, 0x64},\n\t{0x51, 0x04},\n\t{0x52, 0x18},\n\t{0x53, 0x3c},\n\t{0x54, 0x54},\n\t{0x55, 0x40},\n\t{0x56, 0x40},\n\t{0x57, 0x40},\n\t{0x58, 0x0d},\t\t\t/* matrix sign */\n\t{0x8b, 0xcc},\t\t\t/* RSVD */\n\t{0x8c, 0xcc},\n\t{0x8d, 0xcf},\n\t{0x6c, 0x40},\t\t\t/* gamma curve */\n\t{0x6d, 0xe0},\n\t{0x6e, 0xa0},\n\t{0x6f, 0x80},\n\t{0x70, 0x70},\n\t{0x71, 0x80},\n\t{0x72, 0x60},\n\t{0x73, 0x60},\n\t{0x74, 0x50},\n\t{0x75, 0x40},\n\t{0x76, 0x38},\n\t{0x77, 0x3c},\n\t{0x78, 0x32},\n\t{0x79, 0x1a},\n\t{0x7a, 0x28},\n\t{0x7b, 0x24},\n\t{0x7c, 0x04},\t\t\t/* gamma curve */\n\t{0x7d, 0x12},\n\t{0x7e, 0x26},\n\t{0x7f, 0x46},\n\t{0x80, 0x54},\n\t{0x81, 0x64},\n\t{0x82, 0x70},\n\t{0x83, 0x7c},\n\t{0x84, 0x86},\n\t{0x85, 0x8e},\n\t{0x86, 0x9c},\n\t{0x87, 0xab},\n\t{0x88, 0xc4},\n\t{0x89, 0xd1},\n\t{0x8a, 0xe5},\n\t{OV7670_R14_COM9, 0x1e},\n\t{OV7670_R24_AEW, 0x80},\n\t{OV7670_R25_AEB, 0x72},\n\t{OV7670_R26_VPT, 0xb3},\n\t{0x62, 0x80},\t\t\t/* LCC1 */\n\t{0x63, 0x80},\t\t\t/* LCC2 */\n\t{0x64, 0x06},\t\t\t/* LCC3 */\n\t{0x65, 0x00},\t\t\t/* LCC4 */\n\t{0x66, 0x01},\t\t\t/* LCC5 */\n\t{0x94, 0x0e},\t\t\t/* RSVD.. */\n\t{0x95, 0x14},\n\t{OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| 0x10\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AWB\n\t\t\t| OV7670_COM8_AEC},\n\t{0xa1, 0xc8}\n};\nstatic const struct ov_i2c_regvals norm_9600[] = {\n\t{0x12, 0x80},\n\t{0x0c, 0x28},\n\t{0x11, 0x80},\n\t{0x13, 0xb5},\n\t{0x14, 0x3e},\n\t{0x1b, 0x04},\n\t{0x24, 0xb0},\n\t{0x25, 0x90},\n\t{0x26, 0x94},\n\t{0x35, 0x90},\n\t{0x37, 0x07},\n\t{0x38, 0x08},\n\t{0x01, 0x8e},\n\t{0x02, 0x85}\n};\n\n/* 7670. Defaults taken from OmniVision provided data,\n*  as provided by Jonathan Corbet of OLPC\t\t*/\nstatic const struct ov_i2c_regvals norm_7670[] = {\n\t{ OV7670_R12_COM7, OV7670_COM7_RESET },\n\t{ OV7670_R3A_TSLB, 0x04 },\t\t/* OV */\n\t{ OV7670_R12_COM7, OV7670_COM7_FMT_VGA }, /* VGA */\n\t{ OV7670_R11_CLKRC, 0x01 },\n/*\n * Set the hardware window.  These values from OV don't entirely\n * make sense - hstop is less than hstart.  But they work...\n */\n\t{ OV7670_R17_HSTART, 0x13 },\n\t{ OV7670_R18_HSTOP, 0x01 },\n\t{ OV7670_R32_HREF, 0xb6 },\n\t{ OV7670_R19_VSTART, 0x02 },\n\t{ OV7670_R1A_VSTOP, 0x7a },\n\t{ OV7670_R03_VREF, 0x0a },\n\n\t{ OV7670_R0C_COM3, 0x00 },\n\t{ OV7670_R3E_COM14, 0x00 },\n/* Mystery scaling numbers */\n\t{ 0x70, 0x3a },\n\t{ 0x71, 0x35 },\n\t{ 0x72, 0x11 },\n\t{ 0x73, 0xf0 },\n\t{ 0xa2, 0x02 },\n/*\t{ OV7670_R15_COM10, 0x0 }, */\n\n/* Gamma curve values */\n\t{ 0x7a, 0x20 },\n\t{ 0x7b, 0x10 },\n\t{ 0x7c, 0x1e },\n\t{ 0x7d, 0x35 },\n\t{ 0x7e, 0x5a },\n\t{ 0x7f, 0x69 },\n\t{ 0x80, 0x76 },\n\t{ 0x81, 0x80 },\n\t{ 0x82, 0x88 },\n\t{ 0x83, 0x8f },\n\t{ 0x84, 0x96 },\n\t{ 0x85, 0xa3 },\n\t{ 0x86, 0xaf },\n\t{ 0x87, 0xc4 },\n\t{ 0x88, 0xd7 },\n\t{ 0x89, 0xe8 },\n\n/* AGC and AEC parameters.  Note we start by disabling those features,\n   then turn them only after tweaking the values. */\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t | OV7670_COM8_AECSTEP\n\t\t\t | OV7670_COM8_BFILT },\n\t{ OV7670_R00_GAIN, 0x00 },\n\t{ OV7670_R10_AECH, 0x00 },\n\t{ OV7670_R0D_COM4, 0x40 }, /* magic reserved bit */\n\t{ OV7670_R14_COM9, 0x18 }, /* 4x gain + magic rsvd bit */\n\t{ OV7670_RA5_BD50MAX, 0x05 },\n\t{ OV7670_RAB_BD60MAX, 0x07 },\n\t{ OV7670_R24_AEW, 0x95 },\n\t{ OV7670_R25_AEB, 0x33 },\n\t{ OV7670_R26_VPT, 0xe3 },\n\t{ OV7670_R9F_HAECC1, 0x78 },\n\t{ OV7670_RA0_HAECC2, 0x68 },\n\t{ 0xa1, 0x03 }, /* magic */\n\t{ OV7670_RA6_HAECC3, 0xd8 },\n\t{ OV7670_RA7_HAECC4, 0xd8 },\n\t{ OV7670_RA8_HAECC5, 0xf0 },\n\t{ OV7670_RA9_HAECC6, 0x90 },\n\t{ OV7670_RAA_HAECC7, 0x94 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC },\n\n/* Almost all of these are magic \"reserved\" values.  */\n\t{ OV7670_R0E_COM5, 0x61 },\n\t{ OV7670_R0F_COM6, 0x4b },\n\t{ 0x16, 0x02 },\n\t{ OV7670_R1E_MVFP, 0x07 },\n\t{ 0x21, 0x02 },\n\t{ 0x22, 0x91 },\n\t{ 0x29, 0x07 },\n\t{ 0x33, 0x0b },\n\t{ 0x35, 0x0b },\n\t{ 0x37, 0x1d },\n\t{ 0x38, 0x71 },\n\t{ 0x39, 0x2a },\n\t{ OV7670_R3C_COM12, 0x78 },\n\t{ 0x4d, 0x40 },\n\t{ 0x4e, 0x20 },\n\t{ OV7670_R69_GFIX, 0x00 },\n\t{ 0x6b, 0x4a },\n\t{ 0x74, 0x10 },\n\t{ 0x8d, 0x4f },\n\t{ 0x8e, 0x00 },\n\t{ 0x8f, 0x00 },\n\t{ 0x90, 0x00 },\n\t{ 0x91, 0x00 },\n\t{ 0x96, 0x00 },\n\t{ 0x9a, 0x00 },\n\t{ 0xb0, 0x84 },\n\t{ 0xb1, 0x0c },\n\t{ 0xb2, 0x0e },\n\t{ 0xb3, 0x82 },\n\t{ 0xb8, 0x0a },\n\n/* More reserved magic, some of which tweaks white balance */\n\t{ 0x43, 0x0a },\n\t{ 0x44, 0xf0 },\n\t{ 0x45, 0x34 },\n\t{ 0x46, 0x58 },\n\t{ 0x47, 0x28 },\n\t{ 0x48, 0x3a },\n\t{ 0x59, 0x88 },\n\t{ 0x5a, 0x88 },\n\t{ 0x5b, 0x44 },\n\t{ 0x5c, 0x67 },\n\t{ 0x5d, 0x49 },\n\t{ 0x5e, 0x0e },\n\t{ 0x6c, 0x0a },\n\t{ 0x6d, 0x55 },\n\t{ 0x6e, 0x11 },\n\t{ 0x6f, 0x9f },\t\t\t/* \"9e for advance AWB\" */\n\t{ 0x6a, 0x40 },\n\t{ OV7670_R01_BLUE, 0x40 },\n\t{ OV7670_R02_RED, 0x60 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC\n\t\t\t| OV7670_COM8_AWB },\n\n/* Matrix coefficients */\n\t{ 0x4f, 0x80 },\n\t{ 0x50, 0x80 },\n\t{ 0x51, 0x00 },\n\t{ 0x52, 0x22 },\n\t{ 0x53, 0x5e },\n\t{ 0x54, 0x80 },\n\t{ 0x58, 0x9e },\n\n\t{ OV7670_R41_COM16, OV7670_COM16_AWBGAIN },\n\t{ OV7670_R3F_EDGE, 0x00 },\n\t{ 0x75, 0x05 },\n\t{ 0x76, 0xe1 },\n\t{ 0x4c, 0x00 },\n\t{ 0x77, 0x01 },\n\t{ OV7670_R3D_COM13, OV7670_COM13_GAMMA\n\t\t\t  | OV7670_COM13_UVSAT\n\t\t\t  | 2},\t\t/* was 3 */\n\t{ 0x4b, 0x09 },\n\t{ 0xc9, 0x60 },\n\t{ OV7670_R41_COM16, 0x38 },\n\t{ 0x56, 0x40 },\n\n\t{ 0x34, 0x11 },\n\t{ OV7670_R3B_COM11, OV7670_COM11_EXP|OV7670_COM11_HZAUTO },\n\t{ 0xa4, 0x88 },\n\t{ 0x96, 0x00 },\n\t{ 0x97, 0x30 },\n\t{ 0x98, 0x20 },\n\t{ 0x99, 0x30 },\n\t{ 0x9a, 0x84 },\n\t{ 0x9b, 0x29 },\n\t{ 0x9c, 0x03 },\n\t{ 0x9d, 0x4c },\n\t{ 0x9e, 0x3f },\n\t{ 0x78, 0x04 },\n\n/* Extra-weird stuff.  Some sort of multiplexor register */\n\t{ 0x79, 0x01 },\n\t{ 0xc8, 0xf0 },\n\t{ 0x79, 0x0f },\n\t{ 0xc8, 0x00 },\n\t{ 0x79, 0x10 },\n\t{ 0xc8, 0x7e },\n\t{ 0x79, 0x0a },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x0b },\n\t{ 0xc8, 0x01 },\n\t{ 0x79, 0x0c },\n\t{ 0xc8, 0x0f },\n\t{ 0x79, 0x0d },\n\t{ 0xc8, 0x20 },\n\t{ 0x79, 0x09 },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x02 },\n\t{ 0xc8, 0xc0 },\n\t{ 0x79, 0x03 },\n\t{ 0xc8, 0x40 },\n\t{ 0x79, 0x05 },\n\t{ 0xc8, 0x30 },\n\t{ 0x79, 0x26 },\n};\n\nstatic const struct ov_i2c_regvals norm_8610[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x00, 0x00 },\n\t{ 0x01, 0x80 },\n\t{ 0x02, 0x80 },\n\t{ 0x03, 0xc0 },\n\t{ 0x04, 0x30 },\n\t{ 0x05, 0x30 }, /* was 0x10, new from windrv 090403 */\n\t{ 0x06, 0x70 }, /* was 0x80, new from windrv 090403 */\n\t{ 0x0a, 0x86 },\n\t{ 0x0b, 0xb0 },\n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x25 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x04 },\n\t{ 0x15, 0x01 }, /* Lin and Win think different about UV order */\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 }, /* was 0x2f, new from windrv 090403 */\n\t{ 0x18, 0xea }, /* was 0xcf, new from windrv 090403 */\n\t{ 0x19, 0x02 }, /* was 0x06, new from windrv 090403 */\n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0xd0 }, /* was 0x90, new from windrv 090403 */\n\t{ 0x23, 0xc0 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x24, 0x30 }, /* was 0x1d, new from windrv 090403 */\n\t{ 0x25, 0x50 }, /* was 0x57, new from windrv 090403 */\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x80 },\n\t{ 0x2b, 0xc8 }, /* was 0xcc, new from windrv 090403 */\n\t{ 0x2c, 0xac },\n\t{ 0x2d, 0x45 }, /* was 0xd5, new from windrv 090403 */\n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x14 }, /* was 0x01, new from windrv 090403 */\n\t{ 0x4c, 0x00 },\n\t{ 0x4d, 0x30 }, /* was 0x10, new from windrv 090403 */\n\t{ 0x60, 0x02 }, /* was 0x01, new from windrv 090403 */\n\t{ 0x61, 0x00 }, /* was 0x09, new from windrv 090403 */\n\t{ 0x62, 0x5f }, /* was 0xd7, new from windrv 090403 */\n\t{ 0x63, 0xff },\n\t{ 0x64, 0x53 }, /* new windrv 090403 says 0x57,\n\t\t\t * maybe that's wrong */\n\t{ 0x65, 0x00 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0xb0 },\n\t{ 0x68, 0xc0 }, /* was 0xaf, new from windrv 090403 */\n\t{ 0x69, 0x02 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x99 }, /* was 0x80, old windrv says 0x00, but\n\t\t\t * deleting bit7 colors the first images red */\n\t{ 0x6d, 0x11 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x6e, 0x11 }, /* was 0x00, new from windrv 090403 */\n\t{ 0x6f, 0x01 },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 },/* 0x60? - was 0x00, new from windrv 090403 */\n\t{ 0x75, 0x0e },\n\t{ 0x76, 0x02 }, /* was 0x02, new from windrv 090403 */\n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0x10 }, /* was 0x13, new from windrv 090403 */\n\t{ 0x7c, 0x00 },\n\t{ 0x7d, 0x08 }, /* was 0x09, new from windrv 090403 */\n\t{ 0x7e, 0x08 }, /* was 0xc0, new from windrv 090403 */\n\t{ 0x7f, 0xfb },\n\t{ 0x80, 0x28 },\n\t{ 0x81, 0x00 },\n\t{ 0x82, 0x23 },\n\t{ 0x83, 0x0b },\n\t{ 0x84, 0x00 },\n\t{ 0x85, 0x62 }, /* was 0x61, new from windrv 090403 */\n\t{ 0x86, 0xc9 },\n\t{ 0x87, 0x00 },\n\t{ 0x88, 0x00 },\n\t{ 0x89, 0x01 },\n\t{ 0x12, 0x20 },\n\t{ 0x12, 0x25 }, /* was 0x24, new from windrv 090403 */\n};\n\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\n{\n\tif (v > 127)\n\t\treturn v & 0x7f;\n\treturn (128 - v) | 0x80;\n}\n\n/* Write a OV519 register */\nstatic void reg_w(struct sd *sd, u16 index, u16 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret, req = 0;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 2;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0a;\n\t\t/* fall through */\n\tcase BRIDGE_W9968CF:\n\t\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x %04x %04x\\n\",\n\t\t\t  req, value, index);\n\t\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 500);\n\t\tgoto leave;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x 0000 %04x %02x\\n\",\n\t\t  req, index, value);\n\tsd->gspca_dev.usb_buf[0] = value;\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, 1, 500);\nleave:\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\treturn;\n\t}\n}\n\n/* Read from a OV519 register, note not valid for the w9968cf!! */\n/* returns: negative is error, pos or zero is data */\nstatic int reg_r(struct sd *sd, u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\tint req;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 3;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"GET %02x 0000 %04x %02x\\n\",\n\t\t\t  req, index, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t/*\n\t\t * Make sure the result is zeroed to avoid uninitialized\n\t\t * values.\n\t\t */\n\t\tgspca_dev->usb_buf[0] = 0;\n\t}\n\n\treturn ret;\n}\n\n/* Read 8 values from a OV519 register */\nstatic int reg_r8(struct sd *sd,\n\t\t  u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1,\t\t\t/* REQ_IO */\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 8, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r8 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t/*\n\t\t * Make sure the buffer is zeroed to avoid uninitialized\n\t\t * values.\n\t\t */\n\t\tmemset(gspca_dev->usb_buf, 0, 8);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Writes bits at positions specified by mask to an OV51x reg. Bits that are in\n * the same position as 1's in \"mask\" are cleared and set to \"value\". Bits\n * that are in the same position as 0's in \"mask\" are preserved, regardless\n * of their respective state in \"value\".\n */\nstatic void reg_w_mask(struct sd *sd,\n\t\t\tu16 index,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint ret;\n\tu8 oldval;\n\n\tif (mask != 0xff) {\n\t\tvalue &= mask;\t\t\t/* Enforce mask on value */\n\t\tret = reg_r(sd, index);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\toldval = ret & ~mask;\t\t/* Clear the masked bits */\n\t\tvalue |= oldval;\t\t/* Set the desired bits */\n\t}\n\treg_w(sd, index, value);\n}\n\n/*\n * Writes multiple (n) byte value to a single register. Only valid with certain\n * registers (0x30 and 0xc4 - 0xce).\n */\nstatic void ov518_reg_w32(struct sd *sd, u16 index, u32 value, int n)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t*((__le32 *) sd->gspca_dev.usb_buf) = __cpu_to_le32(value);\n\n\t/* Avoid things going to fast for the bridge with a xhci host */\n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1 /* REG_IO */,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, n, 500);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w32 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n}\n\nstatic void ov511_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, retries;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov511_i2c_w %02x %02x\\n\", reg, value);\n\n\t/* Three byte write cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Select camera register */\n\t\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t\t/* Write \"value\" to I2C data port of OV511 */\n\t\treg_w(sd, R51x_I2C_DATA, value);\n\n\t\t/* Initiate 3-byte write cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x01);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBO, \"i2c write retries exhausted\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ov511_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, value, retries;\n\n\t/* Two byte write cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Select camera register */\n\t\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t\t/* Initiate 2-byte write cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x03);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\n\t\t/* I2C abort */\n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c write retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Two byte read cycle */\n\tfor (retries = 6; ; ) {\n\t\t/* Initiate 2-byte read cycle */\n\t\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0)); /* Retry until idle */\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0) /* Ack? */\n\t\t\tbreak;\n\n\t\t/* I2C abort */\n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c read retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\n\tgspca_dbg(gspca_dev, D_USBI, \"ov511_i2c_r %02x %02x\\n\", reg, value);\n\n\t/* This is needed to make i2c_w() work */\n\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\treturn value;\n}\n\n/*\n * The OV518 I2C I/O procedure is different, hence, this function.\n * This is normally only called from i2c_w(). Note that this function\n * always succeeds regardless of whether the sensor is present and working.\n */\nstatic void ov518_i2c_w(struct sd *sd,\n\t\tu8 reg,\n\t\tu8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov518_i2c_w %02x %02x\\n\", reg, value);\n\n\t/* Select camera register */\n\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t/* Write \"value\" to I2C data port of OV511 */\n\treg_w(sd, R51x_I2C_DATA, value);\n\n\t/* Initiate 3-byte write cycle */\n\treg_w(sd, R518_I2C_CTL, 0x01);\n\n\t/* wait for write complete */\n\tmsleep(4);\n\treg_r8(sd, R518_I2C_CTL);\n}\n\n/*\n * returns: negative is error, pos or zero is data\n *\n * The OV518 I2C I/O procedure is different, hence, this function.\n * This is normally only called from i2c_r(). Note that this function\n * always succeeds regardless of whether the sensor is present and working.\n */\nstatic int ov518_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint value;\n\n\t/* Select camera register */\n\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t/* Initiate 2-byte write cycle */\n\treg_w(sd, R518_I2C_CTL, 0x03);\n\treg_r8(sd, R518_I2C_CTL);\n\n\t/* Initiate 2-byte read cycle */\n\treg_w(sd, R518_I2C_CTL, 0x05);\n\treg_r8(sd, R518_I2C_CTL);\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\tgspca_dbg(gspca_dev, D_USBI, \"ov518_i2c_r %02x %02x\\n\", reg, value);\n\treturn value;\n}\n\nstatic void ovfx2_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t(u16) value, (u16) reg, NULL, 0, 500);\n\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_w %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ovfx2_i2c_w %02x %02x\\n\", reg, value);\n}\n\nstatic int ovfx2_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x03,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, (u16) reg, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"ovfx2_i2c_r %02x %02x\\n\",\n\t\t\t  reg, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_r %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tif (sd->sensor_reg_cache[reg] == value)\n\t\treturn;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tov518_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_i2c_w(sd, reg, value);\n\t\tbreak;\n\t}\n\n\tif (sd->gspca_dev.usb_err >= 0) {\n\t\t/* Up on sensor reset empty the register cache */\n\t\tif (reg == 0x12 && (value & 0x80))\n\t\t\tmemset(sd->sensor_reg_cache, -1,\n\t\t\t\tsizeof(sd->sensor_reg_cache));\n\t\telse\n\t\t\tsd->sensor_reg_cache[reg] = value;\n\t}\n}\n\nstatic int i2c_r(struct sd *sd, u8 reg)\n{\n\tint ret = -1;\n\n\tif (sd->sensor_reg_cache[reg] != -1)\n\t\treturn sd->sensor_reg_cache[reg];\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tret = ov511_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tret = ov518_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tret = ovfx2_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tret = w9968cf_i2c_r(sd, reg);\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tsd->sensor_reg_cache[reg] = ret;\n\n\treturn ret;\n}\n\n/* Writes bits at positions specified by mask to an I2C reg. Bits that are in\n * the same position as 1's in \"mask\" are cleared and set to \"value\". Bits\n * that are in the same position as 0's in \"mask\" are preserved, regardless\n * of their respective state in \"value\".\n */\nstatic void i2c_w_mask(struct sd *sd,\n\t\t\tu8 reg,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint rc;\n\tu8 oldval;\n\n\tvalue &= mask;\t\t\t/* Enforce mask on value */\n\trc = i2c_r(sd, reg);\n\tif (rc < 0)\n\t\treturn;\n\toldval = rc & ~mask;\t\t/* Clear the masked bits */\n\tvalue |= oldval;\t\t/* Set the desired bits */\n\ti2c_w(sd, reg, value);\n}\n\n/* Temporarily stops OV511 from functioning. Must do this before changing\n * registers while the camera is streaming */\nstatic inline void ov51x_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"stopping\\n\");\n\tsd->stopped = 1;\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x3d);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R51x_SYS_RESET, 0x3a, 0x3a);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x00);\t\t/* FRAR */\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x00, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x0a05); /* stop USB transfer */\n\t\tbreak;\n\t}\n}\n\n/* Restarts OV511 after ov511_stop() is called. Has no effect if it is not\n * actually stopped (for performance). */\nstatic inline void ov51x_restart(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"restarting\\n\");\n\tif (!sd->stopped)\n\t\treturn;\n\tsd->stopped = 0;\n\n\t/* Reinitialize the stream */\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, 0x2f, 0x80);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x1d);\t\t/* FRAR */\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x02, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x8a05); /* USB FIFO enable */\n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_set_slave_ids(struct sd *sd, u8 slave);\n\n/* This does an initial reset of an OmniVision sensor and ensures that I2C\n * is synchronized. Returns <0 on failure.\n */\nstatic int init_ov_sensor(struct sd *sd, u8 slave)\n{\n\tint i;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tov51x_set_slave_ids(sd, slave);\n\n\t/* Reset the sensor */\n\ti2c_w(sd, 0x12, 0x80);\n\n\t/* Wait for it to initialize */\n\tmsleep(150);\n\n\tfor (i = 0; i < i2c_detect_tries; i++) {\n\t\tif (i2c_r(sd, OV7610_REG_ID_HIGH) == 0x7f &&\n\t\t    i2c_r(sd, OV7610_REG_ID_LOW) == 0xa2) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"I2C synced in %d attempt(s)\\n\",\n\t\t\t\t  i);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Reset the sensor */\n\t\ti2c_w(sd, 0x12, 0x80);\n\n\t\t/* Wait for it to initialize */\n\t\tmsleep(150);\n\n\t\t/* Dummy read to sync I2C */\n\t\tif (i2c_r(sd, 0x00) < 0)\n\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n/* Set the read and write slave IDs. The \"slave\" argument is the write slave,\n * and the read slave will be set to (slave + 1).\n * This should not be called from outside the i2c I/O functions.\n * Sets I2C read and write slave IDs. Returns <0 for error\n */\nstatic void ov51x_set_slave_ids(struct sd *sd,\n\t\t\t\tu8 slave)\n{\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\treg_w(sd, OVFX2_I2C_ADDR, slave);\n\t\treturn;\n\tcase BRIDGE_W9968CF:\n\t\tsd->sensor_addr = slave;\n\t\treturn;\n\t}\n\n\treg_w(sd, R51x_I2C_W_SID, slave);\n\treg_w(sd, R51x_I2C_R_SID, slave + 1);\n}\n\nstatic void write_regvals(struct sd *sd,\n\t\t\t const struct ov_regvals *regvals,\n\t\t\t int n)\n{\n\twhile (--n >= 0) {\n\t\treg_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\nstatic void write_i2c_regvals(struct sd *sd,\n\t\t\tconst struct ov_i2c_regvals *regvals,\n\t\t\tint n)\n{\n\twhile (--n >= 0) {\n\t\ti2c_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\n/****************************************************************************\n *\n * OV511 and sensor configuration\n *\n ***************************************************************************/\n\n/* This initializes the OV2x10 / OV3610 / OV3620 / OV9600 */\nstatic void ov_hires_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint high, low;\n\n\tif (sd->bridge != BRIDGE_OVFX2) {\n\t\tgspca_err(gspca_dev, \"error hires sensors only supported with ovfx2\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov hires configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\thigh = i2c_r(sd, 0x0a);\n\tlow = i2c_r(sd, 0x0b);\n\t/* info(\"%x, %x\", high, low); */\n\tswitch (high) {\n\tcase 0x96:\n\t\tswitch (low) {\n\t\tcase 0x40:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610\\n\");\n\t\t\tsd->sensor = SEN_OV2610;\n\t\t\treturn;\n\t\tcase 0x41:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610AE\\n\");\n\t\t\tsd->sensor = SEN_OV2610AE;\n\t\t\treturn;\n\t\tcase 0xb1:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV9600\\n\");\n\t\t\tsd->sensor = SEN_OV9600;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0x36:\n\t\tif ((low & 0x0f) == 0x00) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV3610\\n\");\n\t\t\tsd->sensor = SEN_OV3610;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tgspca_err(gspca_dev, \"Error unknown sensor type: %02x%02x\\n\",\n\t\t  high, low);\n}\n\n/* This initializes the OV8110, OV8610 sensor. The OV8110 uses\n * the same register settings as the OV8610, since they are very similar.\n */\nstatic void ov8xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov8xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 1)\n\t\tsd->sensor = SEN_OV8610;\n\telse\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n}\n\n/* This initializes the OV7610, OV7620, or OV76BE sensor. The OV76BE uses\n * the same register settings as the OV7610, since they are very similar.\n */\nstatic void ov7xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, high, low;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV7xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\n\t/* add OV7670 here\n\t * it appears to be wrongly detected as a 7610 by default */\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 3) {\n\t\t/* quick hack to make OV7670s work */\n\t\thigh = i2c_r(sd, 0x0a);\n\t\tlow = i2c_r(sd, 0x0b);\n\t\t/* info(\"%x, %x\", high, low); */\n\t\tif (high == 0x76 && (low & 0xf0) == 0x70) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76%02x\\n\",\n\t\t\t\t  low);\n\t\t\tsd->sensor = SEN_OV7670;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7610\\n\");\n\t\t\tsd->sensor = SEN_OV7610;\n\t\t}\n\t} else if ((rc & 3) == 1) {\n\t\t/* I don't know what's different about the 76BE yet. */\n\t\tif (i2c_r(sd, 0x15) & 1) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620AE\\n\");\n\t\t\tsd->sensor = SEN_OV7620AE;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76BE\\n\");\n\t\t\tsd->sensor = SEN_OV76BE;\n\t\t}\n\t} else if ((rc & 3) == 0) {\n\t\t/* try to read product id registers */\n\t\thigh = i2c_r(sd, 0x0a);\n\t\tif (high < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip PID\\n\");\n\t\t\treturn;\n\t\t}\n\t\tlow = i2c_r(sd, 0x0b);\n\t\tif (low < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip VER\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (high == 0x76) {\n\t\t\tswitch (low) {\n\t\t\tcase 0x30:\n\t\t\t\tgspca_err(gspca_dev, \"Sensor is an OV7630/OV7635\\n\");\n\t\t\t\tgspca_err(gspca_dev, \"7630 is not supported by this driver\\n\");\n\t\t\t\treturn;\n\t\t\tcase 0x40:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640; /* FIXME */\n\t\t\t\tbreak;\n\t\t\tcase 0x45:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645B\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640; /* FIXME */\n\t\t\t\tbreak;\n\t\t\tcase 0x48:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7648\\n\");\n\t\t\t\tsd->sensor = SEN_OV7648;\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV7660\\n\");\n\t\t\t\tsd->sensor = SEN_OV7660;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgspca_err(gspca_dev, \"Unknown sensor: 0x76%02x\\n\",\n\t\t\t\t\t  low);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620\\n\");\n\t\t\tsd->sensor = SEN_OV7620;\n\t\t}\n\t} else {\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n\t}\n}\n\n/* This initializes the OV6620, OV6630, OV6630AE, or OV6630AF sensor. */\nstatic void ov6xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV6xx0 configuration\\n\");\n\n\t/* Detect sensor (sub)type */\n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\n\t/* Ugh. The first two bits are the version bits, but\n\t * the entire register value must be used. I guess OVT\n\t * underestimated how many variants they would make. */\n\tswitch (rc) {\n\tcase 0x00:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66308. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tcase 0x01:\n\t\tsd->sensor = SEN_OV6620;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV6620\\n\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsd->sensor = SEN_OV6630;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AE\\n\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsd->sensor = SEN_OV66308AF;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AF\\n\");\n\t\tbreak;\n\tcase 0x90:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66307. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tgspca_err(gspca_dev, \"FATAL: Unknown sensor version: 0x%02x\\n\",\n\t\t\t  rc);\n\t\treturn;\n\t}\n\n\t/* Set sensor-specific vars */\n\tsd->sif = 1;\n}\n\n/* Turns on or off the LED. Only has an effect with OV511+/OV518(+)/OV519 */\nstatic void ov51x_led_control(struct sd *sd, int on)\n{\n\tif (sd->invert_led)\n\t\ton = !on;\n\n\tswitch (sd->bridge) {\n\t/* OV511 has no LED control */\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R511_SYS_LED_CTL, on);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R518_GPIO_OUT, 0x02 * on, 0x02);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w_mask(sd, OV519_GPIO_DATA_OUT0, on, 1);\n\t\tbreak;\n\t}\n}\n\nstatic void sd_reset_snapshot(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->snapshot_needs_reset)\n\t\treturn;\n\n\t/* Note it is important that we clear sd->snapshot_needs_reset,\n\t   before actually clearing the snapshot state in the bridge\n\t   otherwise we might race with the pkt_scan interrupt handler */\n\tsd->snapshot_needs_reset = 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02);\n\t\treg_w(sd, R51x_SYS_SNAP, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02); /* Reset */\n\t\treg_w(sd, R51x_SYS_SNAP, 0x01); /* Enable */\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, R51x_SYS_RESET, 0x40);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_upload_quan_tables(struct sd *sd)\n{\n\tstatic const unsigned char yQuanTable511[] = {\n\t\t0, 1, 1, 2, 2, 3, 3, 4,\n\t\t1, 1, 1, 2, 2, 3, 4, 4,\n\t\t1, 1, 2, 2, 3, 4, 4, 4,\n\t\t2, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 5, 5, 5,\n\t\t3, 3, 4, 4, 5, 5, 5, 5,\n\t\t3, 4, 4, 4, 5, 5, 5, 5,\n\t\t4, 4, 4, 4, 5, 5, 5, 5\n\t};\n\n\tstatic const unsigned char uvQuanTable511[] = {\n\t\t0, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 2, 4, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 4, 4, 4,\n\t\t3, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4\n\t};\n\n\t/* OV518 quantization tables are 8x4 (instead of 8x8) */\n\tstatic const unsigned char yQuanTable518[] = {\n\t\t5, 4, 5, 6, 6, 7, 7, 7,\n\t\t5, 5, 5, 5, 6, 7, 7, 7,\n\t\t6, 6, 6, 6, 7, 7, 7, 8,\n\t\t7, 7, 6, 7, 7, 7, 8, 8\n\t};\n\tstatic const unsigned char uvQuanTable518[] = {\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 8,\n\t\t7, 7, 7, 7, 7, 7, 8, 8\n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tconst unsigned char *pYTable, *pUVTable;\n\tunsigned char val0, val1;\n\tint i, size, reg = R51x_COMP_LUT_BEGIN;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Uploading quantization tables\\n\");\n\n\tif (sd->bridge == BRIDGE_OV511 || sd->bridge == BRIDGE_OV511PLUS) {\n\t\tpYTable = yQuanTable511;\n\t\tpUVTable = uvQuanTable511;\n\t\tsize = 32;\n\t} else {\n\t\tpYTable = yQuanTable518;\n\t\tpUVTable = uvQuanTable518;\n\t\tsize = 16;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tval0 = *pYTable++;\n\t\tval1 = *pYTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg, val0);\n\n\t\tval0 = *pUVTable++;\n\t\tval1 = *pUVTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg + size, val0);\n\n\t\treg++;\n\t}\n}\n\n/* This initializes the OV511/OV511+ and the sensor */\nstatic void ov511_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* For 511 and 511+ */\n\tstatic const struct ov_regvals init_511[] = {\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3d },\n\t};\n\n\tstatic const struct ov_regvals norm_511[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0x01 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0x1f },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_511_p[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0xff },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0xff },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals compress_511[] = {\n\t\t{ 0x70, 0x1f },\n\t\t{ 0x71, 0x05 },\n\t\t{ 0x72, 0x06 },\n\t\t{ 0x73, 0x06 },\n\t\t{ 0x74, 0x14 },\n\t\t{ 0x75, 0x03 },\n\t\t{ 0x76, 0x04 },\n\t\t{ 0x77, 0x04 },\n\t};\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device custom id %x\\n\",\n\t\t  reg_r(sd, R51x_SYS_CUST_ID));\n\n\twrite_regvals(sd, init_511, ARRAY_SIZE(init_511));\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\t\twrite_regvals(sd, norm_511, ARRAY_SIZE(norm_511));\n\t\tbreak;\n\tcase BRIDGE_OV511PLUS:\n\t\twrite_regvals(sd, norm_511_p, ARRAY_SIZE(norm_511_p));\n\t\tbreak;\n\t}\n\n\t/* Init compression */\n\twrite_regvals(sd, compress_511, ARRAY_SIZE(compress_511));\n\n\tov51x_upload_quan_tables(sd);\n}\n\n/* This initializes the OV518/OV518+ and the sensor */\nstatic void ov518_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* For 518 and 518+ */\n\tstatic const struct ov_regvals init_518[] = {\n\t\t{ R51x_SYS_RESET,\t0x40 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x3e },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x00 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_518[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 }, /* Reset */\n\t\t{ R51x_SYS_SNAP,\t0x01 }, /* Enable */\n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x00 },\n\t\t{ 0x51,\t\t\t0x04 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\tstatic const struct ov_regvals norm_518_p[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 }, /* Reset */\n\t\t{ R51x_SYS_SNAP,\t0x01 }, /* Enable */\n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x60 },\n\t\t{ 0x51,\t\t\t0x02 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x40,\t\t\t0xff },\n\t\t{ 0x41,\t\t\t0x42 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x33,\t\t\t0x04 },\n\t\t{ 0x21,\t\t\t0x19 },\n\t\t{ 0x3f,\t\t\t0x10 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\t/* First 5 bits of custom ID reg are a revision ID on OV518 */\n\tsd->revision = reg_r(sd, R51x_SYS_CUST_ID) & 0x1f;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device revision %d\\n\", sd->revision);\n\n\twrite_regvals(sd, init_518, ARRAY_SIZE(init_518));\n\n\t/* Set LED GPIO pin to output mode */\n\treg_w_mask(sd, R518_GPIO_CTL, 0x00, 0x02);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV518:\n\t\twrite_regvals(sd, norm_518, ARRAY_SIZE(norm_518));\n\t\tbreak;\n\tcase BRIDGE_OV518PLUS:\n\t\twrite_regvals(sd, norm_518_p, ARRAY_SIZE(norm_518_p));\n\t\tbreak;\n\t}\n\n\tov51x_upload_quan_tables(sd);\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\nstatic void ov519_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_519[] = {\n\t\t{ 0x5a, 0x6d }, /* EnableSystem */\n\t\t{ 0x53, 0x9b }, /* don't enable the microcontroller */\n\t\t{ OV519_R54_EN_CLK1, 0xff }, /* set bit2 to enable jpeg */\n\t\t{ 0x5d, 0x03 },\n\t\t{ 0x49, 0x01 },\n\t\t{ 0x48, 0x00 },\n\t\t/* Set LED pin to output mode. Bit 4 must be cleared or sensor\n\t\t * detection will fail. This deserves further investigation. */\n\t\t{ OV519_GPIO_IO_CTRL0,   0xee },\n\t\t{ OV519_R51_RESET1, 0x0f },\n\t\t{ OV519_R51_RESET1, 0x00 },\n\t\t{ 0x22, 0x00 },\n\t\t/* windows reads 0x55 at this point*/\n\t};\n\n\twrite_regvals(sd, init_519, ARRAY_SIZE(init_519));\n}\n\nstatic void ovfx2_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_fx2[] = {\n\t\t{ 0x00, 0x60 },\n\t\t{ 0x02, 0x01 },\n\t\t{ 0x0f, 0x1d },\n\t\t{ 0xe9, 0x82 },\n\t\t{ 0xea, 0xc7 },\n\t\t{ 0xeb, 0x10 },\n\t\t{ 0xec, 0xf6 },\n\t};\n\n\tsd->stopped = 1;\n\n\twrite_regvals(sd, init_fx2, ARRAY_SIZE(init_fx2));\n}\n\n/* set the mode */\n/* This function works for ov7660 only */\nstatic void ov519_set_mode(struct sd *sd)\n{\n\tstatic const struct ov_regvals bridge_ov7660[2][10] = {\n\t\t{{0x10, 0x14}, {0x11, 0x1e}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x01}, {0x26, 0x00}},\n\t\t{{0x10, 0x28}, {0x11, 0x3c}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x03}, {0x26, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660[2][3] = {\n\t\t{{0x12, 0x00}, {0x24, 0x00}, {0x0c, 0x0c}},\n\t\t{{0x12, 0x00}, {0x04, 0x00}, {0x0c, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660_2[] = {\n\t\t{OV7670_R17_HSTART, 0x13},\n\t\t{OV7670_R18_HSTOP, 0x01},\n\t\t{OV7670_R32_HREF, 0x92},\n\t\t{OV7670_R19_VSTART, 0x02},\n\t\t{OV7670_R1A_VSTOP, 0x7a},\n\t\t{OV7670_R03_VREF, 0x00},\n/*\t\t{0x33, 0x00}, */\n/*\t\t{0x34, 0x07}, */\n/*\t\t{0x36, 0x00}, */\n/*\t\t{0x6b, 0x0a}, */\n\t};\n\n\twrite_regvals(sd, bridge_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(bridge_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(sensor_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660_2,\n\t\t\tARRAY_SIZE(sensor_ov7660_2));\n}\n\n/* set the frame rate */\n/* This function works for sensors ov7640, ov7648 ov7660 and ov7670 only */\nstatic void ov519_set_fr(struct sd *sd)\n{\n\tint fr;\n\tu8 clock;\n\t/* frame rate table with indices:\n\t *\t- mode = 0: 320x240, 1: 640x480\n\t *\t- fr rate = 0: 30, 1: 25, 2: 20, 3: 15, 4: 10, 5: 5\n\t *\t- reg = 0: bridge a4, 1: bridge 23, 2: sensor 11 (clock)\n\t */\n\tstatic const u8 fr_tb[2][6][3] = {\n\t\t{{0x04, 0xff, 0x00},\n\t\t {0x04, 0x1f, 0x00},\n\t\t {0x04, 0x1b, 0x00},\n\t\t {0x04, 0x15, 0x00},\n\t\t {0x04, 0x09, 0x00},\n\t\t {0x04, 0x01, 0x00}},\n\t\t{{0x0c, 0xff, 0x00},\n\t\t {0x0c, 0x1f, 0x00},\n\t\t {0x0c, 0x1b, 0x00},\n\t\t {0x04, 0xff, 0x01},\n\t\t {0x04, 0x1f, 0x01},\n\t\t {0x04, 0x1b, 0x01}},\n\t};\n\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\tif (sd->frame_rate >= 30)\n\t\tfr = 0;\n\telse if (sd->frame_rate >= 25)\n\t\tfr = 1;\n\telse if (sd->frame_rate >= 20)\n\t\tfr = 2;\n\telse if (sd->frame_rate >= 15)\n\t\tfr = 3;\n\telse if (sd->frame_rate >= 10)\n\t\tfr = 4;\n\telse\n\t\tfr = 5;\n\treg_w(sd, 0xa4, fr_tb[sd->gspca_dev.curr_mode][fr][0]);\n\treg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);\n\tclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];\n\tif (sd->sensor == SEN_OV7660)\n\t\tclock |= 0x80;\t\t/* enable double clock */\n\tov518_i2c_w(sd, OV7670_R11_CLKRC, clock);\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x13, val ? 0x05 : 0x00, 0x05);\n}\n\n/* this function is called at probe time */\nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tsd->bridge = id->driver_info & BRIDGE_MASK;\n\tsd->invert_led = (id->driver_info & BRIDGE_INVERT_LED) != 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tcam->cam_mode = ov511_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov511_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tcam->cam_mode = ov518_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov518_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tcam->bulk_size = OVFX2_BULK_SIZE;\n\t\tcam->bulk_nurbs = MAX_NURBS;\n\t\tcam->bulk = 1;\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tcam->cam_mode = w9968cf_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode);\n\t\tbreak;\n\t}\n\n\tsd->frame_rate = 15;\n\n\treturn 0;\n}\n\n/* this function is called at probe and resume time */\nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_configure(sd);\n\t\tbreak;\n\t}\n\n\t/* The OV519 must be more aggressive about sensor detection since\n\t * I2C write will never fail if the sensor is not present. We have\n\t * to try to initialize the sensor to detect its presence */\n\tsd->sensor = -1;\n\n\t/* Test for 76xx */\n\tif (init_ov_sensor(sd, OV7xx0_SID) >= 0) {\n\t\tov7xx0_configure(sd);\n\n\t/* Test for 6xx0 */\n\t} else if (init_ov_sensor(sd, OV6xx0_SID) >= 0) {\n\t\tov6xx0_configure(sd);\n\n\t/* Test for 8xx0 */\n\t} else if (init_ov_sensor(sd, OV8xx0_SID) >= 0) {\n\t\tov8xx0_configure(sd);\n\n\t/* Test for 3xxx / 2xxx */\n\t} else if (init_ov_sensor(sd, OV_HIRES_SID) >= 0) {\n\t\tov_hires_configure(sd);\n\t} else {\n\t\tgspca_err(gspca_dev, \"Can't determine sensor slave IDs\\n\");\n\t\tgoto error;\n\t}\n\n\tif (sd->sensor < 0)\n\t\tgoto error;\n\n\tov51x_led_control(sd, 0);\t/* turn LED off */\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov511_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov511_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov518_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov518_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV2610:\n\t\tcase SEN_OV2610AE:\n\t\t\tcam->cam_mode = ovfx2_ov2610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov2610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV3610:\n\t\t\tcam->cam_mode = ovfx2_ov3610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov3610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV9600:\n\t\t\tcam->cam_mode = ovfx2_ov9600_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov9600_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (sd->sif) {\n\t\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tif (sd->sif)\n\t\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode) - 1;\n\n\t\t/* w9968cf needs initialisation once the sensor is known */\n\t\tw9968cf_init(sd);\n\t\tbreak;\n\t}\n\n\t/* initialize the sensor */\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\twrite_i2c_regvals(sd, norm_2610, ARRAY_SIZE(norm_2610));\n\n\t\t/* Enable autogain, autoexpo, awb, bandfilter */\n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV2610AE:\n\t\twrite_i2c_regvals(sd, norm_2610ae, ARRAY_SIZE(norm_2610ae));\n\n\t\t/* enable autoexpo */\n\t\ti2c_w_mask(sd, 0x13, 0x05, 0x05);\n\t\tbreak;\n\tcase SEN_OV3610:\n\t\twrite_i2c_regvals(sd, norm_3620b, ARRAY_SIZE(norm_3620b));\n\n\t\t/* Enable autogain, autoexpo, awb, bandfilter */\n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\twrite_i2c_regvals(sd, norm_6x20, ARRAY_SIZE(norm_6x20));\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\twrite_i2c_regvals(sd, norm_6x30, ARRAY_SIZE(norm_6x30));\n\t\tbreak;\n\tdefault:\n/*\tcase SEN_OV7610: */\n/*\tcase SEN_OV76BE: */\n\t\twrite_i2c_regvals(sd, norm_7610, ARRAY_SIZE(norm_7610));\n\t\ti2c_w_mask(sd, 0x0e, 0x00, 0x40);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\twrite_i2c_regvals(sd, norm_7620, ARRAY_SIZE(norm_7620));\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\twrite_i2c_regvals(sd, norm_7640, ARRAY_SIZE(norm_7640));\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\ti2c_w(sd, OV7670_R12_COM7, OV7670_COM7_RESET);\n\t\tmsleep(14);\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n\t\twrite_regvals(sd, init_519_ov7660,\n\t\t\t\tARRAY_SIZE(init_519_ov7660));\n\t\twrite_i2c_regvals(sd, norm_7660, ARRAY_SIZE(norm_7660));\n\t\tsd->gspca_dev.curr_mode = 1;\t/* 640x480 */\n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\tsd_reset_snapshot(gspca_dev);\n\t\tov51x_restart(sd);\n\t\tov51x_stop(sd);\t\t\t/* not in win traces */\n\t\tov51x_led_control(sd, 0);\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\twrite_i2c_regvals(sd, norm_7670, ARRAY_SIZE(norm_7670));\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\twrite_i2c_regvals(sd, norm_8610, ARRAY_SIZE(norm_8610));\n\t\tbreak;\n\tcase SEN_OV9600:\n\t\twrite_i2c_regvals(sd, norm_9600, ARRAY_SIZE(norm_9600));\n\n\t\t/* enable autoexpo */\n/*\t\ti2c_w_mask(sd, 0x13, 0x05, 0x05); */\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\nerror:\n\tgspca_err(gspca_dev, \"OV519 Config failed\\n\");\n\treturn -EINVAL;\n}\n\n/* function called at start time before URB creation */\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\tif (gspca_dev->pixfmt.width != 800)\n\t\t\tgspca_dev->cam.bulk_size = OVFX2_BULK_SIZE;\n\t\telse\n\t\t\tgspca_dev->cam.bulk_size = 7 * 4096;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/* Set up the OV511/OV511+ with the given image parameters.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}\n\n/* Sets up the OV518/OV518+ with the given image parameters\n *\n * OV518 needs a completely different approach, until we can figure out what\n * the individual registers do. Also, only 15 FPS is supported now.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\n/* Sets up the OV519 with the given image parameters\n *\n * OV519 needs a completely different approach, until we can figure out what\n * the individual registers do.\n *\n * Do not put any sensor-specific code in here (including I2C I/O functions)\n */\nstatic void ov519_mode_init_regs(struct sd *sd)\n{\n\tstatic const struct ov_regvals mode_init_519_ov7670[] = {\n\t\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t\t{ 0x53,\t0x9f }, /* was 9b in 1.65-1.08 */\n\t\t{ OV519_R54_EN_CLK1, 0x0f }, /* bit2 (jpeg enable) */\n\t\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t\t{ 0x20,\t0x0c },\n\t\t{ 0x21,\t0x38 },\n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 }, /* undocumented */\n\t\t{ 0x37,\t0x00 }, /* undocumented */\n\t\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n\t\t{ 0x59,\t0x04 },\t/* new from windrv 090403 */\n\t\t{ 0xff,\t0x00 }, /* undocumented */\n\t\t/* windows reads 0x55 at this point, why? */\n\t};\n\n\tstatic const struct ov_regvals mode_init_519[] = {\n\t\t{ 0x5d,\t0x03 }, /* Turn off suspend mode */\n\t\t{ 0x53,\t0x9f }, /* was 9b in 1.65-1.08 */\n\t\t{ OV519_R54_EN_CLK1, 0x0f }, /* bit2 (jpeg enable) */\n\t\t{ 0xa2,\t0x20 }, /* a2-a5 are undocumented */\n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t/* SetUsbInit */\n\t\t{ 0x55,\t0x02 }, /* 4.096 Mhz audio clock */\n\t\t/* Enable both fields, YUV Input, disable defect comp (why?) */\n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 }, /* undocumented */\n\t\t{ 0x37,\t0x00 }, /* undocumented */\n\t\t{ 0x40,\t0xff }, /* I2C timeout counter */\n\t\t{ 0x46,\t0x00 }, /* I2C clock prescaler */\n\t\t{ 0x59,\t0x04 },\t/* new from windrv 090403 */\n\t\t{ 0xff,\t0x00 }, /* undocumented */\n\t\t/* windows reads 0x55 at this point, why? */\n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\t/******** Set the mode ********/\n\tswitch (sd->sensor) {\n\tdefault:\n\t\twrite_regvals(sd, mode_init_519, ARRAY_SIZE(mode_init_519));\n\t\tif (sd->sensor == SEN_OV7640 ||\n\t\t    sd->sensor == SEN_OV7648) {\n\t\t\t/* Select 8-bit input mode */\n\t\t\treg_w_mask(sd, OV519_R20_DFR, 0x10, 0x10);\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\treturn;\t\t/* done by ov519_set_mode/fr() */\n\tcase SEN_OV7670:\n\t\twrite_regvals(sd, mode_init_519_ov7670,\n\t\t\t\tARRAY_SIZE(mode_init_519_ov7670));\n\t\tbreak;\n\t}\n\n\treg_w(sd, OV519_R10_H_SIZE,\tsd->gspca_dev.pixfmt.width >> 4);\n\treg_w(sd, OV519_R11_V_SIZE,\tsd->gspca_dev.pixfmt.height >> 3);\n\tif (sd->sensor == SEN_OV7670 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x04);\n\telse if (sd->sensor == SEN_OV7648 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x01);\n\telse\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x00);\n\treg_w(sd, OV519_R13_X_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R14_Y_OFFSETL,\t0x00);\n\treg_w(sd, OV519_R15_Y_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R16_DIVIDER,\t0x00);\n\treg_w(sd, OV519_R25_FORMAT,\t0x03); /* YUV422 */\n\treg_w(sd, 0x26,\t\t\t0x00); /* Undocumented */\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n/* FIXME: These are only valid at the max resolution. */\n\tsd->clockdiv = 0;\n\tswitch (sd->sensor) {\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\n/*\t\tcase 30: */\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\t/* 15 fps */\n/*\t\tcase 15: */\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7670:\t\t/* guesses, based on 7640 */\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Setting framerate to %d fps\\n\",\n\t\t\t  (sd->frame_rate == 0) ? 15 : sd->frame_rate);\n\t\treg_w(sd, 0xa4, 0x10);\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tdefault:\n/*\t\tcase 15: */\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mode_init_ov_sensor_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint qvga, xstart, xend, ystart, yend;\n\tu8 v;\n\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\n\t/******** Mode (VGA/QVGA) and sensor specific regs ********/\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\treturn;\n\tcase SEN_OV2610AE: {\n\t\tu8 v;\n\n\t\t/* frame rates:\n\t\t *\t10fps / 5 fps for 1600x1200\n\t\t *\t40fps / 20fps for 800x600\n\t\t */\n\t\tv = 80;\n\t\tif (qvga) {\n\t\t\tif (sd->frame_rate < 25)\n\t\t\t\tv = 0x81;\n\t\t} else {\n\t\t\tif (sd->frame_rate < 10)\n\t\t\t\tv = 0x81;\n\t\t}\n\t\ti2c_w(sd, 0x11, v);\n\t\ti2c_w(sd, 0x12, qvga ? 0x60 : 0x20);\n\t\treturn;\n\t    }\n\tcase SEN_OV3610:\n\t\tif (qvga) {\n\t\t\txstart = (1040 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x1f << 4);\n\t\t\tystart = (776 - gspca_dev->pixfmt.height) / 2;\n\t\t} else {\n\t\t\txstart = (2076 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x10 << 4);\n\t\t\tystart = (1544 - gspca_dev->pixfmt.height) / 2;\n\t\t}\n\t\txend = xstart + gspca_dev->pixfmt.width;\n\t\tyend = ystart + gspca_dev->pixfmt.height;\n\t\t/* Writing to the COMH register resets the other windowing regs\n\t\t   to their default values, so we must do this first. */\n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0xf0);\n\t\ti2c_w_mask(sd, 0x32,\n\t\t\t   (((xend >> 1) & 7) << 3) | ((xstart >> 1) & 7),\n\t\t\t   0x3f);\n\t\ti2c_w_mask(sd, 0x03,\n\t\t\t   (((yend >> 1) & 3) << 2) | ((ystart >> 1) & 3),\n\t\t\t   0x0f);\n\t\ti2c_w(sd, 0x17, xstart >> 4);\n\t\ti2c_w(sd, 0x18, xend >> 4);\n\t\ti2c_w(sd, 0x19, ystart >> 3);\n\t\ti2c_w(sd, 0x1a, yend >> 3);\n\t\treturn;\n\tcase SEN_OV8610:\n\t\t/* For OV8610 qvga means qsvga */\n\t\ti2c_w_mask(sd, OV7610_REG_COM_C, qvga ? (1 << 5) : 0, 1 << 5);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x40); /* from windrv 090403 */\n\t\ti2c_w_mask(sd, 0x28, 0x20, 0x20); /* progressive mode on */\n\t\tbreak;\n\tcase SEN_OV7610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV76BE:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xb0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tif (sd->sensor == SEN_OV76BE)\n\t\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\t/* Setting this undocumented bit in qvga mode removes a very\n\t\t   annoying vertical shaking of the image */\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\t/* Unknown */\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\t/* Allow higher automatic gain (to allow higher framerates) */\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x04); /* AWB: 1 */\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* set COM7_FMT_VGA or COM7_FMT_QVGA\n\t\t * do we need to set anything else?\n\t\t *\tHSTART etc are set in set_ov_sensor_window itself */\n\t\ti2c_w_mask(sd, OV7670_R12_COM7,\n\t\t\t qvga ? OV7670_COM7_FMT_QVGA : OV7670_COM7_FMT_VGA,\n\t\t\t OV7670_COM7_FMT_MASK);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_AWB,\n\t\t\t\tOV7670_COM8_AWB);\n\t\tif (qvga) {\t\t/* QVGA from ov7670.c by\n\t\t\t\t\t * Jonathan Corbet */\n\t\t\txstart = 164;\n\t\t\txend = 28;\n\t\t\tystart = 14;\n\t\t\tyend = 494;\n\t\t} else {\t\t/* VGA */\n\t\t\txstart = 158;\n\t\t\txend = 14;\n\t\t\tystart = 10;\n\t\t\tyend = 490;\n\t\t}\n\t\t/* OV7670 hardware window registers are split across\n\t\t * multiple locations */\n\t\ti2c_w(sd, OV7670_R17_HSTART, xstart >> 3);\n\t\ti2c_w(sd, OV7670_R18_HSTOP, xend >> 3);\n\t\tv = i2c_r(sd, OV7670_R32_HREF);\n\t\tv = (v & 0xc0) | ((xend & 0x7) << 3) | (xstart & 0x07);\n\t\tmsleep(10);\t/* need to sleep between read and write to\n\t\t\t\t * same reg! */\n\t\ti2c_w(sd, OV7670_R32_HREF, v);\n\n\t\ti2c_w(sd, OV7670_R19_VSTART, ystart >> 2);\n\t\ti2c_w(sd, OV7670_R1A_VSTOP, yend >> 2);\n\t\tv = i2c_r(sd, OV7670_R03_VREF);\n\t\tv = (v & 0xc0) | ((yend & 0x3) << 2) | (ystart & 0x03);\n\t\tmsleep(10);\t/* need to sleep between read and write to\n\t\t\t\t * same reg! */\n\t\ti2c_w(sd, OV7670_R03_VREF, v);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20); /* Select 16 bit data bus */\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06); /* AWB: 1 Test pattern: 0 */\n\t\tbreak;\n\tcase SEN_OV9600: {\n\t\tconst struct ov_i2c_regvals *vals;\n\t\tstatic const struct ov_i2c_regvals sxga_15[] = {\n\t\t\t{0x11, 0x80}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals sxga_7_5[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_30[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x7e}, {0x24, 0x70}, {0x25, 0x60}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_15[] = {\n\t\t\t{0x11, 0x83}, {0x14, 0x3e}, {0x24, 0x80}, {0x25, 0x70}\n\t\t};\n\n\t\t/* frame rates:\n\t\t *\t15fps / 7.5 fps for 1280x1024\n\t\t *\t30fps / 15fps for 640x480\n\t\t */\n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0x40);\n\t\tif (qvga)\n\t\t\tvals = sd->frame_rate < 30 ? vga_15 : vga_30;\n\t\telse\n\t\t\tvals = sd->frame_rate < 15 ? sxga_7_5 : sxga_15;\n\t\twrite_i2c_regvals(sd, vals, ARRAY_SIZE(sxga_15));\n\t\treturn;\n\t    }\n\tdefault:\n\t\treturn;\n\t}\n\n\t/******** Clock programming ********/\n\ti2c_w(sd, 0x11, sd->clockdiv);\n}\n\n/* this function works for bridge ov519 and sensors ov7660 and ov7670 only */\nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\t/* block stream */\n\ti2c_w_mask(sd, OV7670_R1E_MVFP,\n\t\tOV7670_MVFP_MIRROR * hflip | OV7670_MVFP_VFLIP * vflip,\n\t\tOV7670_MVFP_MIRROR | OV7670_MVFP_VFLIP);\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\t/* restart stream */\n}\n\nstatic void set_ov_sensor_window(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev;\n\tint qvga, crop;\n\tint hwsbase, hwebase, vwsbase, vwebase, hwscale, vwscale;\n\n\t/* mode setup is fully handled in mode_init_ov_sensor_regs for these */\n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\tcase SEN_OV2610AE:\n\tcase SEN_OV3610:\n\tcase SEN_OV7670:\n\tcase SEN_OV9600:\n\t\tmode_init_ov_sensor_regs(sd);\n\t\treturn;\n\tcase SEN_OV7660:\n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\treturn;\n\t}\n\n\tgspca_dev = &sd->gspca_dev;\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\tcrop = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 2;\n\n\t/* The different sensor ICs handle setting up of window differently.\n\t * IF YOU SET IT WRONG, YOU WILL GET ALL ZERO ISOC DATA FROM OV51x!! */\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\t\thwsbase = 0x1e;\n\t\thwebase = 0x1e;\n\t\tvwsbase = 0x02;\n\t\tvwebase = 0x02;\n\t\tbreak;\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = 0x05;\n\t\tvwebase = 0x06;\n\t\tif (sd->sensor == SEN_OV66308AF && qvga)\n\t\t\t/* HDG: this fixes U and V getting swapped */\n\t\t\thwsbase++;\n\t\tif (crop) {\n\t\t\thwsbase += 8;\n\t\t\thwebase += 8;\n\t\t\tvwsbase += 11;\n\t\t\tvwebase += 11;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\thwsbase = 0x2f;\t\t/* From 7620.SET (spec is wrong) */\n\t\thwebase = 0x2f;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\thwsbase = 0x1a;\n\t\thwebase = 0x1a;\n\t\tvwsbase = vwebase = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\tif (qvga) {\t\t/* QCIF */\n\t\t\thwscale = 0;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t/* CIF */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\t/* The datasheet says 0;\n\t\t\t\t\t * it's wrong */\n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tif (qvga) {\t\t/* QSVGA */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\n\t\t} else {\t\t/* SVGA */\n\t\t\thwscale = 2;\n\t\t\tvwscale = 2;\n\t\t}\n\t\tbreak;\n\tdefault:\t\t\t/* SEN_OV7xx0 */\n\t\tif (qvga) {\t\t/* QVGA */\n\t\t\thwscale = 1;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t/* VGA */\n\t\t\thwscale = 2;\n\t\t\tvwscale = 1;\n\t\t}\n\t}\n\n\tmode_init_ov_sensor_regs(sd);\n\n\ti2c_w(sd, 0x17, hwsbase);\n\ti2c_w(sd, 0x18, hwebase + (sd->sensor_width >> hwscale));\n\ti2c_w(sd, 0x19, vwsbase);\n\ti2c_w(sd, 0x1a, vwebase + (sd->sensor_height >> vwscale));\n}\n\n/* -- start the camera -- */\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Default for most bridges, allow bridge_mode_init_regs to override */\n\tsd->sensor_width = sd->gspca_dev.pixfmt.width;\n\tsd->sensor_height = sd->gspca_dev.pixfmt.height;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_mode_init_regs(sd);\n\t\tbreak;\n\t/* case BRIDGE_OVFX2: nothing to do */\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_mode_init_regs(sd);\n\t\tbreak;\n\t}\n\n\tset_ov_sensor_window(sd);\n\n\t/* Force clear snapshot state in case the snapshot button was\n\t   pressed while we weren't streaming */\n\tsd->snapshot_needs_reset = 1;\n\tsd_reset_snapshot(gspca_dev);\n\n\tsd->first_frame = 3;\n\n\tov51x_restart(sd);\n\tov51x_led_control(sd, 1);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tov51x_stop(sd);\n\tov51x_led_control(sd, 0);\n}\n\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->gspca_dev.present)\n\t\treturn;\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_stop0(sd);\n\n#if IS_ENABLED(CONFIG_INPUT)\n\t/* If the last button state is pressed, release it now! */\n\tif (sd->snapshot_pressed) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->snapshot_pressed = 0;\n\t}\n#endif\n\tif (sd->bridge == BRIDGE_OV519)\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n}\n\nstatic void ov51x_handle_button(struct gspca_dev *gspca_dev, u8 state)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->snapshot_pressed != state) {\n#if IS_ENABLED(CONFIG_INPUT)\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\n\t\tinput_sync(gspca_dev->input_dev);\n#endif\n\t\tif (state)\n\t\t\tsd->snapshot_needs_reset = 1;\n\n\t\tsd->snapshot_pressed = state;\n\t} else {\n\t\t/* On the ov511 / ov519 we need to reset the button state\n\t\t   multiple times, as resetting does not work as long as the\n\t\t   button stays pressed */\n\t\tswitch (sd->bridge) {\n\t\tcase BRIDGE_OV511:\n\t\tcase BRIDGE_OV511PLUS:\n\t\tcase BRIDGE_OV519:\n\t\t\tif (state)\n\t\t\t\tsd->snapshot_needs_reset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ov511_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *in,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* SOF/EOF packets have 1st to 8th bytes zeroed and the 9th\n\t * byte non-zero. The EOF packet has image width/height in the\n\t * 10th and 11th bytes. The 9th byte is given as follows:\n\t *\n\t * bit 7: EOF\n\t *     6: compression enabled\n\t *     5: 422/420/400 modes\n\t *     4: 422/420/400 modes\n\t *     3: 1\n\t *     2: snapshot button on\n\t *     1: snapshot frame\n\t *     0: even/odd field\n\t */\n\tif (!(in[0] | in[1] | in[2] | in[3] | in[4] | in[5] | in[6] | in[7]) &&\n\t    (in[8] & 0x08)) {\n\t\tov51x_handle_button(gspca_dev, (in[8] >> 2) & 1);\n\t\tif (in[8] & 0x80) {\n\t\t\t/* Frame end */\n\t\t\tif ((in[9] + 1) * 8 != gspca_dev->pixfmt.width ||\n\t\t\t    (in[10] + 1) * 8 != gspca_dev->pixfmt.height) {\n\t\t\t\tgspca_err(gspca_dev, \"Invalid frame size, got: %dx%d, requested: %dx%d\\n\",\n\t\t\t\t\t  (in[9] + 1) * 8, (in[10] + 1) * 8,\n\t\t\t\t\t  gspca_dev->pixfmt.width,\n\t\t\t\t\t  gspca_dev->pixfmt.height);\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Add 11 byte footer to frame, might be useful */\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, in, 11);\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* Frame start */\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, in, 0);\n\t\t\tsd->packet_nr = 0;\n\t\t}\n\t}\n\n\t/* Ignore the packet number */\n\tlen--;\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, in, len);\n}\n\nstatic void ov518_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* A false positive here is likely, until OVT gives me\n\t * the definitive SOF/EOF format */\n\tif ((!(data[0] | data[1] | data[2] | data[3] | data[5])) && data[6]) {\n\t\tov51x_handle_button(gspca_dev, (data[6] >> 1) & 1);\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\tsd->packet_nr = 0;\n\t}\n\n\tif (gspca_dev->last_packet_type == DISCARD_PACKET)\n\t\treturn;\n\n\t/* Does this device use packet numbers ? */\n\tif (len & 7) {\n\t\tlen--;\n\t\tif (sd->packet_nr == data[len])\n\t\t\tsd->packet_nr++;\n\t\t/* The last few packets of the frame (which are all 0's\n\t\t   except that they may contain part of the footer), are\n\t\t   numbered 0 */\n\t\telse if (sd->packet_nr == 0 || data[len]) {\n\t\t\tgspca_err(gspca_dev, \"Invalid packet nr: %d (expect: %d)\\n\",\n\t\t\t\t  (int)data[len], (int)sd->packet_nr);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ov519_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\t/* Header of ov519 is 16 bytes:\n\t *     Byte     Value      Description\n\t *\t0\t0xff\tmagic\n\t *\t1\t0xff\tmagic\n\t *\t2\t0xff\tmagic\n\t *\t3\t0xXX\t0x50 = SOF, 0x51 = EOF\n\t *\t9\t0xXX\t0x01 initial frame without data,\n\t *\t\t\t0x00 standard frame with image\n\t *\t14\tLo\tin EOF: length of image data / 8\n\t *\t15\tHi\n\t */\n\n\tif (data[0] == 0xff && data[1] == 0xff && data[2] == 0xff) {\n\t\tswitch (data[3]) {\n\t\tcase 0x50:\t\t/* start of frame */\n\t\t\t/* Don't check the button state here, as the state\n\t\t\t   usually (always ?) changes at EOF and checking it\n\t\t\t   here leads to unnecessary snapshot state resets. */\n#define HDRSZ 16\n\t\t\tdata += HDRSZ;\n\t\t\tlen -= HDRSZ;\n#undef HDRSZ\n\t\t\tif (data[0] == 0xff || data[1] == 0xd8)\n\t\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\t\tdata, len);\n\t\t\telse\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\tcase 0x51:\t\t/* end of frame */\n\t\t\tov51x_handle_button(gspca_dev, data[11] & 1);\n\t\t\tif (data[9] != 0)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* intermediate packet */\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ovfx2_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\n\t/* A short read signals EOF */\n\tif (len < gspca_dev->cam.bulk_size) {\n\t\t/* If the frame is short, and it is one of the first ones\n\t\t   the sensor and bridge are still syncing, so drop it. */\n\t\tif (sd->first_frame) {\n\t\t\tsd->first_frame--;\n\t\t\tif (gspca_dev->image_len <\n\t\t\t\t  sd->gspca_dev.pixfmt.width *\n\t\t\t\t\tsd->gspca_dev.pixfmt.height)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t}\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\t}\n}\n\n/* -- management routines -- */\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals brit_7660[][7] = {\n\t\t{{0x0f, 0x6a}, {0x24, 0x40}, {0x25, 0x2b}, {0x26, 0x90},\n\t\t\t{0x27, 0xe0}, {0x28, 0xe0}, {0x2c, 0xe0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x50}, {0x25, 0x40}, {0x26, 0xa1},\n\t\t\t{0x27, 0xc0}, {0x28, 0xc0}, {0x2c, 0xc0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x68}, {0x25, 0x58}, {0x26, 0xc2},\n\t\t\t{0x27, 0xa0}, {0x28, 0xa0}, {0x2c, 0xa0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x70}, {0x25, 0x68}, {0x26, 0xd3},\n\t\t\t{0x27, 0x80}, {0x28, 0x80}, {0x2c, 0x80}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x80}, {0x25, 0x70}, {0x26, 0xd3},\n\t\t\t{0x27, 0x20}, {0x28, 0x20}, {0x2c, 0x20}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x88}, {0x25, 0x78}, {0x26, 0xd3},\n\t\t\t{0x27, 0x40}, {0x28, 0x40}, {0x2c, 0x40}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x90}, {0x25, 0x80}, {0x26, 0xd4},\n\t\t\t{0x27, 0x60}, {0x28, 0x60}, {0x2c, 0x60}}\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, brit_7660[val],\n\t\t\t\tARRAY_SIZE(brit_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n/*win trace\n *\t\ti2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_AEC); */\n\t\ti2c_w(sd, OV7670_R55_BRIGHT, ov7670_abs_to_sm(val));\n\t\tbreak;\n\t}\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals contrast_7660[][31] = {\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0xa0},\n\t\t {0x70, 0x58}, {0x71, 0x38}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x24}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x65},\n\t\t {0x80, 0x70}, {0x81, 0x77}, {0x82, 0x7d}, {0x83, 0x83},\n\t\t {0x84, 0x88}, {0x85, 0x8d}, {0x86, 0x96}, {0x87, 0x9f},\n\t\t {0x88, 0xb0}, {0x89, 0xc4}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0x94},\n\t\t {0x70, 0x58}, {0x71, 0x40}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x30}, {0x75, 0x30}, {0x76, 0x2c}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x31},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x62},\n\t\t {0x80, 0x6d}, {0x81, 0x75}, {0x82, 0x7b}, {0x83, 0x81},\n\t\t {0x84, 0x87}, {0x85, 0x8d}, {0x86, 0x98}, {0x87, 0xa1},\n\t\t {0x88, 0xb2}, {0x89, 0xc6}, {0x8a, 0xdb}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x84},\n\t\t {0x70, 0x58}, {0x71, 0x48}, {0x72, 0x40}, {0x73, 0x40},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x28}, {0x77, 0x24},\n\t\t {0x78, 0x26}, {0x79, 0x28}, {0x7a, 0x28}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x5d},\n\t\t {0x80, 0x68}, {0x81, 0x71}, {0x82, 0x79}, {0x83, 0x81},\n\t\t {0x84, 0x86}, {0x85, 0x8b}, {0x86, 0x95}, {0x87, 0x9e},\n\t\t {0x88, 0xb1}, {0x89, 0xc5}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x70},\n\t\t {0x70, 0x58}, {0x71, 0x58}, {0x72, 0x48}, {0x73, 0x48},\n\t\t {0x74, 0x38}, {0x75, 0x40}, {0x76, 0x34}, {0x77, 0x34},\n\t\t {0x78, 0x2e}, {0x79, 0x28}, {0x7a, 0x24}, {0x7b, 0x22},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x58},\n\t\t {0x80, 0x63}, {0x81, 0x6e}, {0x82, 0x77}, {0x83, 0x80},\n\t\t {0x84, 0x87}, {0x85, 0x8f}, {0x86, 0x9c}, {0x87, 0xa9},\n\t\t {0x88, 0xc0}, {0x89, 0xd4}, {0x8a, 0xe6}},\n\t\t{{0x6c, 0xa0}, {0x6d, 0xf0}, {0x6e, 0x90}, {0x6f, 0x80},\n\t\t {0x70, 0x70}, {0x71, 0x80}, {0x72, 0x60}, {0x73, 0x60},\n\t\t {0x74, 0x58}, {0x75, 0x60}, {0x76, 0x4c}, {0x77, 0x38},\n\t\t {0x78, 0x38}, {0x79, 0x2a}, {0x7a, 0x20}, {0x7b, 0x0e},\n\t\t {0x7c, 0x0a}, {0x7d, 0x14}, {0x7e, 0x26}, {0x7f, 0x46},\n\t\t {0x80, 0x54}, {0x81, 0x64}, {0x82, 0x70}, {0x83, 0x7c},\n\t\t {0x84, 0x87}, {0x85, 0x93}, {0x86, 0xa6}, {0x87, 0xb4},\n\t\t {0x88, 0xd0}, {0x89, 0xe5}, {0x8a, 0xf5}},\n\t\t{{0x6c, 0x60}, {0x6d, 0x80}, {0x6e, 0x60}, {0x6f, 0x80},\n\t\t {0x70, 0x80}, {0x71, 0x80}, {0x72, 0x88}, {0x73, 0x30},\n\t\t {0x74, 0x70}, {0x75, 0x68}, {0x76, 0x64}, {0x77, 0x50},\n\t\t {0x78, 0x3c}, {0x79, 0x22}, {0x7a, 0x10}, {0x7b, 0x08},\n\t\t {0x7c, 0x06}, {0x7d, 0x0e}, {0x7e, 0x1a}, {0x7f, 0x3a},\n\t\t {0x80, 0x4a}, {0x81, 0x5a}, {0x82, 0x6b}, {0x83, 0x7b},\n\t\t {0x84, 0x89}, {0x85, 0x96}, {0x86, 0xaf}, {0x87, 0xc3},\n\t\t {0x88, 0xe1}, {0x89, 0xf2}, {0x8a, 0xfa}},\n\t\t{{0x6c, 0x20}, {0x6d, 0x40}, {0x6e, 0x20}, {0x6f, 0x60},\n\t\t {0x70, 0x88}, {0x71, 0xc8}, {0x72, 0xc0}, {0x73, 0xb8},\n\t\t {0x74, 0xa8}, {0x75, 0xb8}, {0x76, 0x80}, {0x77, 0x5c},\n\t\t {0x78, 0x26}, {0x79, 0x10}, {0x7a, 0x08}, {0x7b, 0x04},\n\t\t {0x7c, 0x02}, {0x7d, 0x06}, {0x7e, 0x0a}, {0x7f, 0x22},\n\t\t {0x80, 0x33}, {0x81, 0x4c}, {0x82, 0x64}, {0x83, 0x7b},\n\t\t {0x84, 0x90}, {0x85, 0xa7}, {0x86, 0xc7}, {0x87, 0xde},\n\t\t {0x88, 0xf1}, {0x89, 0xf9}, {0x8a, 0xfd}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV7610:\n\tcase SEN_OV6620:\n\t\ti2c_w(sd, OV7610_REG_CNT, val);\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, OV7610_REG_CNT, val >> 4, 0x0f);\n\t\tbreak;\n\tcase SEN_OV8610: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x03, 0x09, 0x0b, 0x0f, 0x53, 0x6f, 0x35, 0x7f\n\t\t};\n\n\t\t/* Use Y gamma control instead. Bit 0 enables it. */\n\t\ti2c_w(sd, 0x64, ctab[val >> 5]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x01, 0x05, 0x09, 0x11, 0x15, 0x35, 0x37, 0x57,\n\t\t\t0x5b, 0xa5, 0xa7, 0xc7, 0xc9, 0xcf, 0xef, 0xff\n\t\t};\n\n\t\t/* Use Y gamma control instead. Bit 0 enables it. */\n\t\ti2c_w(sd, 0x64, ctab[val >> 4]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, contrast_7660[val],\n\t\t\t\t\tARRAY_SIZE(contrast_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* check that this isn't just the same as ov7610 */\n\t\ti2c_w(sd, OV7670_R56_CONTRAS, val >> 1);\n\t\tbreak;\n\t}\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w(sd, 0x10, val);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals colors_7660[][6] = {\n\t\t{{0x4f, 0x28}, {0x50, 0x2a}, {0x51, 0x02}, {0x52, 0x0a},\n\t\t {0x53, 0x19}, {0x54, 0x23}},\n\t\t{{0x4f, 0x47}, {0x50, 0x4a}, {0x51, 0x03}, {0x52, 0x11},\n\t\t {0x53, 0x2c}, {0x54, 0x3e}},\n\t\t{{0x4f, 0x66}, {0x50, 0x6b}, {0x51, 0x05}, {0x52, 0x19},\n\t\t {0x53, 0x40}, {0x54, 0x59}},\n\t\t{{0x4f, 0x84}, {0x50, 0x8b}, {0x51, 0x06}, {0x52, 0x20},\n\t\t {0x53, 0x53}, {0x54, 0x73}},\n\t\t{{0x4f, 0xa3}, {0x50, 0xab}, {0x51, 0x08}, {0x52, 0x28},\n\t\t {0x53, 0x66}, {0x54, 0x8e}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\t/* Use UV gamma control instead. Bits 0 & 7 are reserved. */\n/*\t\trc = ov_i2c_write(sd->dev, 0x62, (val >> 9) & 0x7e);\n\t\tif (rc < 0)\n\t\t\tgoto out; */\n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_SAT, val & 0xf0);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, colors_7660[val],\n\t\t\t\t\tARRAY_SIZE(colors_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t/* supported later once I work out how to do it\n\t\t * transparently fail now! */\n\t\t/* set REG_COM13 values for UV sat auto mode */\n\t\tbreak;\n\t}\n}\n\nstatic void setautobright(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x2d, val ? 0x10 : 0x00, 0x10);\n}\n\nstatic void setfreq_i(struct sd *sd, s32 val)\n{\n\tif (sd->sensor == SEN_OV7660\n\t || sd->sensor == SEN_OV7670) {\n\t\tswitch (val) {\n\t\tcase 0: /* Banding filter disabled */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_BFILT);\n\t\t\tbreak;\n\t\tcase 1: /* 50 hz */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x08, 0x18);\n\t\t\tbreak;\n\t\tcase 2: /* 60 hz */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x00, 0x18);\n\t\t\tbreak;\n\t\tcase 3: /* Auto hz - ov7670 only */\n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, OV7670_COM11_HZAUTO,\n\t\t\t\t   0x18);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (val) {\n\t\tcase 0: /* Banding filter disabled */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\tbreak;\n\t\tcase 1: /* 50 hz (filter on and framerate adj) */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t/* 20 fps -> 16.667 fps */\n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF)\n\t\t\t\ti2c_w(sd, 0x2b, 0x5e);\n\t\t\telse\n\t\t\t\ti2c_w(sd, 0x2b, 0xac);\n\t\t\tbreak;\n\t\tcase 2: /* 60 hz (filter on, ...) */\n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF) {\n\t\t\t\t/* 20 fps -> 15 fps */\n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t\ti2c_w(sd, 0x2b, 0xa8);\n\t\t\t} else {\n\t\t\t\t/* no framerate adj. */\n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsetfreq_i(sd, val);\n\n\t/* Ugly but necessary */\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_set_crop_window(sd);\n}\n\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tmemset(jcomp, 0, sizeof *jcomp);\n\tjcomp->quality = v4l2_ctrl_g_ctrl(sd->jpegqual);\n\tjcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT |\n\t\t\t      V4L2_JPEG_MARKER_DRI;\n\treturn 0;\n}\n\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tv4l2_ctrl_s_ctrl(sd->jpegqual, jcomp->quality);\n\treturn 0;\n}\n\nstatic int sd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tgspca_dev->exposure->val = i2c_r(sd, 0x10);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOBRIGHTNESS:\n\t\tif (ctrl->is_new)\n\t\t\tsetautobright(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && sd->brightness->is_new)\n\t\t\tsetbrightness(gspca_dev, sd->brightness->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev, ctrl->val, sd->vflip->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (ctrl->is_new)\n\t\t\tsetautogain(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && gspca_dev->exposure->is_new)\n\t\t\tsetexposure(gspca_dev, gspca_dev->exposure->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\treturn -EBUSY; /* Should never happen, as we grab the ctrl */\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.g_volatile_ctrl = sd_g_volatile_ctrl,\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 10);\n\tif (valid_controls[sd->sensor].has_brightness)\n\t\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 6 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 3 : 127);\n\tif (valid_controls[sd->sensor].has_contrast) {\n\t\tif (sd->sensor == SEN_OV7660)\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 6, 1, 3);\n\t\telse\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 255, 1,\n\t\t\t\t(sd->sensor == SEN_OV6630 ||\n\t\t\t\t sd->sensor == SEN_OV66308AF) ? 200 : 127);\n\t}\n\tif (valid_controls[sd->sensor].has_sat)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 4 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 2 : 127);\n\tif (valid_controls[sd->sensor].has_exposure)\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 255, 1, 127);\n\tif (valid_controls[sd->sensor].has_hvflip) {\n\t\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\tif (valid_controls[sd->sensor].has_autobright)\n\t\tsd->autobright = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOBRIGHTNESS, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_autogain)\n\t\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_freq) {\n\t\tif (sd->sensor == SEN_OV7670)\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\t\telse\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0, 0);\n\t}\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\tQUALITY_MIN, QUALITY_MAX, 1, QUALITY_DEF);\n\n\tif (hdl->error) {\n\t\tgspca_err(gspca_dev, \"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tif (gspca_dev->autogain)\n\t\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, true);\n\tif (sd->autobright)\n\t\tv4l2_ctrl_auto_cluster(2, &sd->autobright, 0, false);\n\tif (sd->hflip)\n\t\tv4l2_ctrl_cluster(2, &sd->hflip);\n\treturn 0;\n}\n\n/* sub-driver description */\nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = sd_reset_snapshot,\n\t.get_jcomp = sd_get_jcomp,\n\t.set_jcomp = sd_set_jcomp,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\n\n/* -- module initialisation -- */\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x4003), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x041e, 0x4052),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x041e, 0x405f), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4060), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4061), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4064), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4067), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4068), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x045e, 0x028c),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x054c, 0x0154), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x054c, 0x0155), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x0511), .driver_info = BRIDGE_OV511 },\n\t{USB_DEVICE(0x05a9, 0x0518), .driver_info = BRIDGE_OV518 },\n\t{USB_DEVICE(0x05a9, 0x0519),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x0530),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x2800), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x05a9, 0x4519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x8519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0xa511), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x05a9, 0xa518), .driver_info = BRIDGE_OV518PLUS },\n\t{USB_DEVICE(0x0813, 0x0002), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x0b62, 0x0059), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x0e96, 0xc001), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x1046, 0x9967), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x8020, 0xef04), .driver_info = BRIDGE_OVFX2 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n/* -- device connect -- */\nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(frame_rate, int, 0644);\nMODULE_PARM_DESC(frame_rate, \"Frame rate (5, 10, 15, 20 or 30 fps)\");\n"], "filenames": ["drivers/media/usb/gspca/ov519.c"], "buggy_code_start_loc": [3479], "buggy_code_end_loc": [3602], "fixing_code_start_loc": [3480], "fixing_code_end_loc": [3613], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.", "other": {"cve": {"id": "CVE-2020-11608", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-07T14:15:14.090", "lastModified": "2020-06-13T09:15:12.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.6.1. El archivo drivers/media/usb/gspca/ov519.c, permite desreferencias del puntero NULL en las funciones ov511_mode_init_regs y ov518_mode_init_regs cuando hay cero endpoints, tambi\u00e9n se conoce como CID-998912346c0d."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.1", "matchCriteriaId": "BB94C1F6-38C4-44F6-93E8-199096A6F86A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.6.1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=998912346c0da53a6dbb71fab3a138586b596b30", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200430-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4345-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4364-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4368-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4369-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30"}}