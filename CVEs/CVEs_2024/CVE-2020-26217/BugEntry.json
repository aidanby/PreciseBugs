{"buggy_code": ["<html>\n<!--\n Copyright (C) 2005, 2006 Joe Walnes.\n Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 XStream committers.\n All rights reserved.\n \n The software in this package is published under the terms of the BSD\n style license a copy of which has been included with this distribution in\n the LICENSE.txt file.\n \n Created on 29. January 2005 by Joe Walnes\n -->\n<head>\n<title>Change History</title>\n</head>\n<body>\n\n\t<p>Changes are split into three categories:</p>\n\n\t<ul>\n\t\t<li><b>Major changes</b>: The major new features that all users should know about.</li>\n\t\t<li><b>Minor changes</b>: Any smaller changes, including bugfixes.</li>\n\t\t<li><b>API changes</b>: Any changes to the API that could impact existing users.</li>\n\t</ul>\n\n\t<p>\n\t\tFull details can be found in GitHub's <a href=\"https://github.com/x-stream/xstream/issues?q=is%3Aissue+is%3Aclosed\">Issues</a>,\n\t\tfilter for the appropriate milestone.\n\t</p>\n\n\t<h1 id=\"1.4.13\">1.4.13</h1>\n\n\t<p>Released September 6, 2020.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHPR:#218: Defer reflective access to Java core modules.</li>\n\t\t<li>GHI:#207: New predefined blacklist avoids vulnerability due to improper setup of the security framework.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.12\">1.4.12</h1>\n\n\t<p>Released April 12, 2020.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>XmlFriendlyNameCoder supports now XML parsers implementing only 4th edition of XML 1.0 specification.</li>\n\t\t<li>Fix support of CDATA events in StAX.</li>\n\t\t<li>GHI:#171: XStream.createObjectInputStream does not pass the DataHolder.</li>\n\t\t<li>GHI:#151: Use of SPDX license identifier in POM and Manifest.</li>\n\t\t<li>GHI:#152: Declare OSGi import of internal runtime packages as optional.</li>\n\t\t<li>Drop Require-Capability entry in manifest.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.11.1\">1.4.11.1</h1>\n\n\t<p>Released October 27, 2018.</p>\n\n\t<h2>Hot fix</h2>\n\n\t<ul>\n\t\t<li>GHI:#133: XStream 1.4.11 fails to run on a Java Runtime &lt; 8.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.11\">1.4.11</h1>\n\n\t<p>Released October 23, 2018.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses again the security vulnerability <a href=\"CVE-2013-7285.html\">\n\t    CVE-2013-7285</a>, an arbitrary execution of commands when unmarshalling for XStream instances with\n\t    uninitialized security framework. Only 1.4.10 uninitialized security framework was affected.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHPR:#91, GHPR:#106: Clean-up data stacks in UnmarshallingContext implementations in case of exception (by\n\t\tM&auml;rt Bakhoff).</li>\n\t\t<li>GHI:#2: Unneeded contention in DefaultConverterLookup.</li>\n\t\t<li>GHI:#94: Fix PathConverter containing absolute Windows paths.</li>\n\t\t<li>GHI:#105: XStream's ObjectInputStream returns wrong values for readUnsignedByte and readUnsignedShort.</li>\n\t\t<li>JIRA:XSTR-616 and GHPR:#93: Introduce StringCodec interface to support arbitrary Base64 codec\n\t\timplementations for EncodedByteArrayConverter. Prefer Base64 codec implementations of the Java runtime over\n\t\tXStream's own one.</li>\n\t\t<li>GHI:#97: Support to run out of the box in a Java 1.4 runtime is established again.</li>\n\t\t<li>Provide methods in AbstractCollectionConverter that read and write in a balanced way from and to the\n\t\thierarchical stream.</li>\n\t\t<li>New future-proof method JVM.isVersion to detect major version of Java runtime (incl. Java 10) as\n\t\treplacement for individual JVM.isXY methods.</li>\n\t\t<li>GHI:#115: Dom4JDriver ignores character set of Dom4J configuration creating a Writer.</li>\n\t\t<li>GHI:#116: Make converters null safe.</li>\n\t\t<li>GHI:#123 and GHPR:#124: Declare XPP dependencies for OSGi as optional.</li>\n\t\t<li>Add XppDriver.createDefaultParser for a simpler access to the default XmlPullParserFactory.</li>\n\t\t<li>Old BEA reference implementation of StAX is outdated, unmaintained and has security issues, therefore\n\t\tXStream's driver has been deprecated.</li>\n\t\t<li>Support for JaCoCo: FieldDictionary ignores synthetic fields starting with <em>$jacoco</em> as name.</li>\n\t\t<li>Add integration test for OSGi (by Wes Wannemacher).</li>\n\t</ul>\n\n\t<h2>Stream compatibility</h2>\n\n\t<ul>\n\t\t<li>The EncodedByteArrayConverter will now use an encoder by default that does no longer add line breaks as\n\t\tnormally required by the RFC 1521 after 76 characters, making it also easier to use the converter for\n\t\tattributes. This will not affect XStream's Base64 decoder.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.readBareItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.readCompleteItem(HierarchicalStreamReader, UnarshallingContext, Object).</li>\n\t\t<li>Deprecated c.t.x.converters.collection.AbstractCollectionConverter.readItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeBareItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeCompleteItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Deprecated c.t.x.converters.collection.AbstractCollectionConverter.writeItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeNullItem(MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.extended.EncodedByteArrayConverter(StingCodec).</li>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter.readBareItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Deprecated c.t.x.converters.extended.NamedCollectionConverter.readItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter.writeCompleteItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Deprecated c.t.x.converters.extended.NamedCollectionConverter.writeItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.core.DefaultConverterLookup(Map).</li>\n\t\t<li>Added c.t.x.core.util.JVM.getBase64Codec().</li>\n\t\t<li>Added c.t.x.core.util.JVM.isVersion().</li>\n\t\t<li>Deprecated c.t.x.core.util.JVM.is18().</li>\n\t\t<li>Deprecated c.t.x.core.util.JVM.is9().</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamReader.</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamWriter.</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamWriterHelper.</li>\n\t\t<li>Deprecated c.t.x.io.xml.BEAStaxDriver.</li>\n\t\t<li>Added c.t.x.io.xml.Dom4JReader.Dom4JReader(Branch).</li>\n\t\t<li>Added c.t.x.io.xml.XppDriver.createDefaultParser().</li>\n\t\t<li>Added c.t.x.core.util.StingCodec.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.10\">1.4.10</h1>\n\n\t<p>Released May 23, 2017.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses also the security vulnerability <a href=\"CVE-2017-7957.html\">\n\t    CVE-2017-7957</a>, used for a Denial of Service attack by crashing the Java runtime.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#84: New XStream artifact with <em>-java7</em> appended as version suffix for a library explicitly\n\t\twithout the Java 8 stuff (lambda expression support, converters for java.time.* package).</li>\n\t\t<li>Fix PrimitiveTypePermission to reject type <em>void</em> to prevent CVE-2017-7957 with an initialized\n\t\tsecurity framework.</li>\n\t\t<li>Improve performance by minimizing call stack of mapper chain.</li>\n\t\t<li>GHPR:#82, JIRA:XSTR-774: Add converters for types of java.time, java.time.chrono, and java.time.temporal\n\t\t\tpackages (converters for LocalDate, LocalDateTime, LocalTime, OffsetDateTime, and ZonedDateTime by Matej Cimbora).</li>\n\t\t<li>GHI:#29: JavaBeanConverter does not respect ignored unknown elements.</li>\n\t\t<li>Add XStream.setupDefaultSecurity to initialize security framework with defaults of XStream 1.5.x.</li>\n\t\t<li>Emit error warning if security framework has not been initialized and the XStream instance is vulnerable to\n\t\tknown exploits.</li>\n\t</ul>\n\n\t<h2>Stream Compatibility</h2>\n\n\t<ul>\n\t\t<li>The alias <em>duration</em> for type <em>javax.xml.datatype.Duration</em> has changed to <em>xml-duration</em>\n\t\t\tdue to the support of the classes in the java.time package. <em>duration</em> is now used for type <em>java.time.Duration</em>.\n\t\t\tSimply register the alias <em>duration</em> again for type <em>javax.xml.datatype.Duration</em> if backward\n\t\t\tcompatibility is required for this type.\n\t\t</li>\n\t\t<li>All types of the java.time packages that have been written with previous versions of XStream can still be\n\t\t\tdeserialized.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#54: Fix BeanProvider.canInstantiate(Class), method may not throw exception.</li>\n\t\t<li>GHI:#76 and GHPR:#77: Missing support for cascaded writeReplace calls.</li>\n\t\t<li>GHI:#61: Regression in 1.4.9: Performance drop in ImplicitCollectionMapper.</li>\n\t\t<li>GHI:#52: PathConverter fails for file paths with spaces.</li>\n\t\t<li>PathConverter uses always forward slashes as path separator.</li>\n\t\t<li>GHI:#53: SqlTimestampConverter cannot parse values without fraction.</li>\n\t\t<li>GHI:#45: Support different time zones for SqlTimestampConverter.</li>\n\t\t<li>GHI:#67 and GHPR:#68: Allow usage of DataHolder for createObjectInputStream and createObjectOutputStream.</li>\n\t\t<li>GHI:#75: Use java.time.* package instead of Joda-Time.</li>\n\t\t<li>Dom4JXmlWriter does not flush writer at endDocument().</li>\n\t\t<li>Path is an immutable type.</li>\n\t\t<li>GHPR:#65: Protect converter lookup against runtime errors.</li>\n\t\t<li>Current Java 9 implementation reports itself as version 9 now.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.util.JVM.is9().</li>\n\t\t<li>Added c.t.x.XStream.setupDefaultSecurity(XStream).</li>\n\t\t<li>Added c.t.x.XStream.createObjectInputStream(HierarchicalStreamReader, DataHolder) and\n\t\t\tc.t.x.XStream.createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder).</li>\n\t\t<li>Added c.t.x.converters.javabean.PropertyDictionary.propertyDescriptorOrNull(Class, String).</li>\n\t\t<li>Added method c.t.x.mapper.Mapper.IsIgnoredElement(String)</li>\n\t\t<li>Added c.t.x.mapper.ElementIgnoringMapper.</li>\n\t\t<li>Deprecated method c.t.x.mapper.FieldAliasingMapper.addFieldsToIgnore(Pattern).</li>\n\t\t<li>Deprecated method c.t.x.mapper.FieldAliasingMapper.omitField(Class, String).</li>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is17().</li>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is19().</li>\n\t</ul>\n\n\t<h1 id=\"1.4.9\">1.4.9</h1>\n\n\t<p>Released March 15, 2016.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses also the security vulnerability <a href=\"CVE-2016-3674.html\">\n\t    CVE-2016-3674</a>, known as XXE vulnerability that can be used to expose arbitrary data from the file system\n\t    when unmarshalling.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#25: Fix <a href=\"https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\">XXE\n\t\t\t\tvulnerability (CVE-2016-3674)</a>: Fixed affected drivers were Dom4JDriver, DomDriver, JDomDriver, JDom2Driver,\n\t\t\tSjsxpDriver, StandardStaxDriver and WstxDriver. Still vulnerable are BEAStaxDriver and XomDriver. Processing of\n\t\t\t(external) entities has been disabled. See <a href=\"faq.html#Security_XXEVulnerability\">FAQ</a> for more information.\n\t\t</li>\n\t\t<li>Benchmark module has been deprecated in favor of <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">\n\t\t\t\tJMH (Java Microbenchmarking Harness)</a>.\n\t\t</li>\n\t\t<li>GHI:#33 and GHPR:#38: Add converter for java.nio.file.Path (by Aaron Jonson).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#35: AnnotationMapper dropped silently constructor arguments for converters if they were equal.</li>\n\t\t<li>Fix: Possible concurrency problem with XomDriver.</li>\n\t\t<li>JIRA:XSTR-773, GHPR:#3: Minimize memory footprint by not keeping internal references to instances of\n\t\t\timmutable types.</li>\n\t\t<li>Drop automatic reference support at deserialization time for immutable types before version 1.4 (primitive\n\t\t\ttypes and their boxed counterpart, java.lang.Class, java.lang.String, java.math.BigDecimal, java.math.BigInteger,\n\t\t\tjava.io.File, java.net.URL, and java.awt.font.TextAttribute).</li>\n\t\t<li>Fix: Implicit collection declaration is erroneously inherited or propagated to hidden field of same name.</li>\n\t\t<li>XStreamConverter annotation supports null values as arguments for converter instantiation.</li>\n\t\t<li>GHI:#5: Support null values for JavaBean properties.</li>\n\t\t<li>GHI:#36: Fix NamedMapConverter, does not use SingleValueConverter of value if value is text of entry element.</li>\n\t\t<li>GHI:#13: Own converter for javax.activation.ActivationDataFlavor, because ExternalizableConverter cannot\n\t\t\thandle a type that violates the Java specification.</li>\n\t\t<li>GHPR:#18: Minimize synchronized block in FieldDictionary.</li>\n\t\t<li>JIRA:XSTR-769: Synthetic fields with references to outer class use compiler dependent names.</li>\n\t\t<li>JIRA:XSTR-771: UUID is an immutable type by default.</li>\n\t\t<li>GHPR:#23: Constructor of AbstractXppDriver swallows causing exception.</li>\n\t\t<li>GHI:#28: Fix functionality of ClassAliaslingMapper.itemTypeAsAttributes(Class).</li>\n\t\t<li>GHI:#37: Historical Java 1.3 support suppresses causing exception of a thrown InvocationTargetException.</li>\n\t\t<li>GHI:#41: Cannot instantiate ToAttributedValueConverter with null value for valueFieldName using\n\t\t\tXStreamConverter annotation.</li>\n\t\t<li>Fix example code in description of security framework.</li>\n\t\t<li>Clean-up usage of exceptions.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.XStream.addImmutableType(Class, boolean) and deprecated c.t.x.XStream.addImmutableType(Class).</li>\n\t\t<li>Added c.t.x.mapper.Mapper.isReferenceable(Class).</li>\n\t\t<li>Added c.t.x.mapper.ImmutableTypesMapper.addImmutableType(Class, boolean) and deprecated\n\t\t\tc.t.x.mapper.ImmutableTypesMapper.addImmutableType(Class).</li>\n\t\t<li>Added c.t.x.io.xml.Dom4JDriver.createReader().</li>\n\t\t<li>Added c.t.x.io.xml.DomDriver.createDocumentBuilderFactory().</li>\n\t\t<li>Added c.t.x.io.xml.JDomDriver.createBuilder().</li>\n\t\t<li>Added c.t.x.io.xml.JDom2Driver.createBuilder().</li>\n\t\t<li>Added c.t.x.io.xml.XomDriver.createBuilder().</li>\n\t\t<li>Added constructor c.t.x.converter.extended.ToAttributedValueConverter.ToAttributedValueConverter(Class,\n\t\t\tMapper, ReflectionProvider, ConverterLookup).</li>\n\t\t<li>Added abstract c.t.x.converter.ErrorWritingException as common base for c.t.x.converter.ConversionException\n\t\t\tand c.t.x.converter.reflection.ObjectAccessException.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XomDriver(Builder), c.t.x.io.xml.XomDriver(Builder, NameCoder) and\n\t\t\tc.t.x.io.xml.XomDriver.getBuilder().</li>\n\t\t<li>Deprecated c.t.x.mapper.ClassAliaslingMapper.itemTypeAsAttributes(Class) and\n\t\t\tc.t.x.mapper.ClassAliaslingMapper.aliasIsAttribute(String). Methods never called, left-over from old refactoring.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.8\">1.4.8</h1>\n\n\t<p>Released February 18, 2015.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support for serializable lambda expressions and handling of non-serializable ones.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Detect Java 9 runtime.</li>\n\t\t<li>JIRA:XSTR-767: Deserialization of referenced lambda expressions fail.</li>\n\t\t<li>JIRA:XSTR-762: Private method readResolve() called on base classes.</li>\n\t\t<li>JIRA:XSTR-761: Support ignored serialPersistentField at deserialization time.</li>\n\t\t<li>JIRA:XSTR-755: ExternalizableConverter does not respect writeReplace and readResolve.</li>\n\t\t<li>JIRA:XSTR-757: Deserialized TreeSet does not honor remove(Object) return value contract.</li>\n\t\t<li>JIRA:XSTR-759: Support deserialization of <a href=\"http://www.w3.org/TR/NOTE-datetime\">W3C datetime\n\t\t\t\tformat</a> in DateConverter with Java 7 runtime.\n\t\t</li>\n\t\t<li>Fix: DateConverter ignores provided locale.</li>\n\t\t<li>JIRA:XSTR-768: ISO8601GregorianCalendarConverter may set invalid time zone for Joda-Time.</li>\n\t\t<li>Fix: WeakCache.entrySet().iterator().next.setValue(value) returns the reference instead of the old value.</li>\n\t\t<li>Fix: SqlTimestampConverter throws IllegalArgumentException instead of ConversionException on fromString().</li>\n\t\t<li>Fix: CGLIBEnhancedConverter does not initialize transient members of parent after deserialization.</li>\n\t\t<li>JIRA:XSTR-763: Set scope of org.json:json to test instead declaring the dependency as optional.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.util.JVM.is19().</li>\n\t\t<li>Added c.t.x.converter.reflection.LambdaConverter and c.t.x.mapper.LambdaMapper.</li>\n\t\t<li>Declare c.t.x.XStream.ignoreUnknownElements(Pattern) as public.</li>\n\t\t<li>c.t.x.converters.reflection.AbstractReflectionConverter.readResolve() is protected now.</li>\n\t\t<li>c.t.x.mapper.AbstractAttributeAliasingMapper.readResolve() is protected now.</li>\n\t\t<li>Deprecated c.t.x.converters.extended.StackTraceElementFactory, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.SerializationMethodInvoker, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.io.AttributeNameIterator, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.XStream.useXStream11XmlFriendlyMapper(), corresponding\n\t\t\tc.t.x.mapper.XStream11XmlFriendlyMapper has been deprecated long ago.</li>\n\t\t<li>Deprecated c.t.x.converter.basic.BooleanConverter.shouldConvert(Class,Object), undetected remainder of\n\t\t\tancient XStream version.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.7\">1.4.7</h1>\n\n\t<p>Released February 8, 2014.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses mainly the security vulnerability <a href=\"CVE-2013-7285.html\">\n\t    CVE-2013-7285</a>, an arbitrary execution of commands when unmarshalling.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Add <a href=\"security.html#framework\">security framework</a> to limit handled types while unmarshalling.\n\t\t</li>\n\t\t<li>java.bean.EventHandler no longer handled automatically because of severe security vulnerability.</li>\n\t\t<li>JIRA:XSTR-751: New SunLimitedUnsafeReflectionProvider that uses undocumented features only to allocate new\n\t\t\tinstances as required on Dalvik.</li>\n\t\t<li>Fix instantiation of AnnotationMapper that requires ConverterLookup and ConverterRegistry to be the same\n\t\t\tinstance.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>XSTR-749: NPE if ReflectionConverter.canConvert(type) is called with null as argument.</li>\n\t\t<li>XSTR-753: NPE if SerializationConverter.canConvert(type) is called with an interface type as argument that\n\t\t\textends Serializable.</li>\n\t\t<li>Add constructor to ReflectionConverter taking an additional type to create an instance that is dedicated to a\n\t\t\tspecific type only.</li>\n\t\t<li>The ConverterLookup used by default cannot be casted to a ConverterRegistry anymore.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added package c.t.x.security with interface TypePermission, all its implementations and\n\t\t\tForbiddenClassException.</li>\n\t\t<li>Added c.t.x.mapper.SecurityMapper handling the new type permissions.</li>\n\t\t<li>Added methods addPermission, denyPermission, allowTypesXXX and denyTypesXXX to c.t.x.XStream to setup\n\t\t\tsecurity at unmarshalling time.</li>\n\t\t<li>Added c.t.x.converters.reflection.SunLimitedUnsafeReflectionProvider.</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.Sun14ReflectionProvider in favor of new\n\t\t\tc.t.x.converters.reflection.SunUnsafeReflectionProvider.</li>\n\t\t<li>Added c.t.x.converters.reflection.ReflectionConverter(Mapper,ReflectionProvider,Class).</li>\n\t</ul>\n\n\t<h1 id=\"1.4.6\">1.4.6</h1>\n\n\t<p>Released December 12, 2013.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-566 and JIRA:XSTR-200: Better compatibility with GAE and environments with active SecurityManager\n\t\t\t(i.e. in an Applet). XStream converters try now to ensure already in the canConvert methods that they can handle the\n\t\t\trequested type in practice and not only theoretically. Additionally the implementations even better take care, that\n\t\t\tthe initialization of a converter will not break the setup of XStream itself. Following modifications have been done\n\t\t\tfor these topics:\n\t\t\t<ul>\n\t\t\t\t<li>ReflectionConverter, SerializationConverter and LookAndFieldConverter will check if they can access the\n\t\t\t\t\tfields by reflection for a requested type.</li>\n\t\t\t\t<li>SerializationConverter and ExternalizableConverter will check if they can create an instance of a derived\n\t\t\t\t\tOutputObjectStream first.</li>\n\t\t\t\t<li>BeanProvider does no longer use reflection to locate default constructor.</li>\n\t\t\t\t<li>AbstractAttributedCharacterIteratorAttributeConverter (and therefore TextAttributeConverter) will check\n\t\t\t\t\tfirst if it can access the possible constants of the type by reflection.</li>\n\t\t\t\t<li>NoClassDefFoundError raised in GAE accessing the fields of restricted types by reflection will be handled.</li>\n\t\t\t\t<li>StackTraceElementConverter uses constructor for StackTraceElement instances in Java 5 and GEA.</li>\n\t\t\t</ul>\n\t\t</li>\n\t\t<li>JIRA:XSTR-739 and JIRA:XSTR-746: OrderRetainingMap fails if HashMap.putAll(Map) of Java Runtime is not\n\t\t\timplemented calling put for every element within the map.</li>\n\t\t<li>New NamedArrayConverter to define names of inner elements.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-747: All constructors of StaxDriver derived classes take erroneously a XmlFriendlyNameCoder instead\n\t\t\tof a plain NameCoder.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.extended.NamedArrayConverter for free element names in arrays.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.StandardStaxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.StandardStaxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.BEAStaxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.BEAStaxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.WstxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.WstxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added method canAccess to c.t.x.converter.reflection.AbstractReflectionConverter.</li>\n\t\t<li>Added static method canCreateDerivedObjectOutputStream to c.t.x.core.JVM.</li>\n\t\t<li>Deprecated unused member c.t.x.converter.javabean.BeanProvider.NO_PARAMS.</li>\n\t\t<li>Deprecated unused method c.t.x.converter.javabean.BeanProvider.getDefaultConstrutor(Class).</li>\n\t</ul>\n\n\n\t<h1 id=\"1.4.5\">1.4.5</h1>\n\n\t<p>Released September 18, 2013.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-732: Use a referencing implementation for the ClassLoader to support environments where no new\n\t\t\tClassLoader can be instantiated due to security restrictions.</li>\n\t\t<li>JIRA:XSTR-691: Allow unknown XML elements to be ignored using new method XStream.ignoreUnknownElements.</li>\n\t\t<li>JIRA:XSTR-728: XStream creates invalid JSON with JsonHierarchicalStreamDriver for custom converters since\n\t\t\tXStream 1.4.</li>\n\t\t<li>JIRA:XSTR-300: New EnumToStringConverter to support custom string representations of Enum values.</li>\n\t\t<li>JIRA:XSTR-292 and JIRA:XSTR-405: New NamedMapConverter and NamedCollectionConverter to define names of inner\n\t\t\telements.</li>\n\t\t<li>JIRA:XSTR-726: New annotation XStreamAliasType to support declarative definition of XStream.aliasType().</li>\n\t\t<li>JIRA:XSTR-735: Support for JDOM2 with JDom2Driver, JDom2Reader and JDom2Writer.</li>\n\t\t<li>Optimized XML structure for java.awt.Font.</li>\n\t\t<li>Fix: ToAttributedValueConverter silently appends fields without attribute support to the value producing\n\t\t\tmixed-mode XML.</li>\n\t\t<li>JIRA:XSTR-566 and JIRA:XSTR-249: Better compatibility with Google AppEngine and J2ME, setup no longer fails\n\t\t\tfor unavailable converters.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Fix missing manifest information.</li>\n\t\t<li>JIRA:XSTR-729: Add OSGi information to manifests.</li>\n\t\t<li>JIRA:XSTR-723: XStream will now detect a working enhanced mode dynamically instead using lists of known\n\t\t\tvendors. This allows enhanced support for JamVM if it is bundled with OpenJDK. It will currently fail on a runtime\n\t\t\tbased on GNU Classpath (at least up to version 0.98).</li>\n\t\t<li>JIRA:XSTR-541: JavaScript compatibility problem with 64-bit integers in JSON.</li>\n\t\t<li>JIRA:XSTR-719: Support replacement of default converter in any case.</li>\n\t\t<li>JIRA:XSTR-725: processAnnotation performance improvement in concurrent situation.</li>\n\t\t<li>JIRA:XSTR-721: EnumConverter is more lenient while parsing constants.</li>\n\t\t<li>New constructors for CollectionConverter and MapConverter to allow registration for an individual type.</li>\n\t\t<li>JIRA:XSTR-724: Cache class name lookup failures.</li>\n\t\t<li>Current IBM JDK for Java 1.4.2 no longer has a reverse field ordering.</li>\n\t\t<li>LongConverter supports now positive hex and octal numbers over Long.MAX_VALUE within 64 bit.</li>\n\t\t<li>Fix: Sun14RefectionProvider ignores a provided FieldDictionary.</li>\n\t\t<li>JIRA:XSTR-457: Do not write 'defined-in' attribute if not needed.</li>\n\t\t<li>JettisonMappedXmlDriver provides better support to overwrite its create methods.</li>\n\t\t<li>JIRA:XSTR-685: StAX based drivers (StaxDriver and JettisonMappedXmlDriver) are not closing internal input\n\t\t\tstream reading from file or URL.</li>\n\t\t<li>JIRA:XSTR-736: XStream.unmarshal may throw NPE if version info of manifest is missing.</li>\n\t\t<li>JIRA:XSTR-733: Implicit elements that match multiple defined implicit collections will be assigned to the map\n\t\t\twith the nearest matching element type.</li>\n\t\t<li>JIRA:XSTR-740: ISO8601GregorianCalendarConverter creates Calendar instance with wrong Locale in Java 7 if the\n\t\t\tLocale for the LocaleCategory.FORMAT is different to the global default Locale.</li>\n\t\t<li>JIRA:XSTR-578: Implement support for aliasing in JavaClasConverter, JavaFieldConverter and\n\t\t\tJavaMethodConverter. While it is not possible to enable this in general, new constructors have been added to these\n\t\t\tconverters and an example in the acceptance tests (AliasTest).</li>\n\t\t<li>JIRA:XSTR-742: Register CompositeClassLoader in Java 7 as parallel capable.</li>\n\t\t<li>JIRA:XSTR-743: Support proxy collections of Hibernate Envers.</li>\n\t\t<li>Fix NPE in AttributeMapper.shouldLookForSingleValueConverter if parameters fieldName and definedIn are null.</li>\n\t\t<li>Implicit type argument can be omitted when registering converters with @XStreamConverter annotation.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter for free element names in collections.</li>\n\t\t<li>Added c.t.x.converters.extended.NamedMapConverter for free element names in maps.</li>\n\t\t<li>Added c.t.x.io.xml.StandardStaxDriver to use the StAX implementation delivered with the Java 6 runtime.</li>\n\t\t<li>Deprecated c.t.x.io.xml.SjsxpStaxDriver to select the internal StAX implementation of Oracle.</li>\n\t\t<li>Added static methods getStaxInputFactory and getStaxOutputFactory to c.t.x.core.JVM as returning the\n\t\t\timplementations of javax.xml.stream.XMLInputFactory (resp. javax.xml.stream.XMLOutputFactory) delivered with the Java\n\t\t\tRuntime since Java 6.</li>\n\t\t<li>Added c.t.x.core.ClassLoaderReference.</li>\n\t\t<li>Added constructors taking an additional Class argument for c.t.x.converters.collections.CollectionConverter\n\t\t\tand c.t.x.converters.collections.MapConverter.</li>\n\t\t<li>Added constructors taking a ClassLoaderReference instead of a ClassLoader and deprecated the ones taking the\n\t\t\tClassLoader:\n\t\t\t<ul>\n\t\t\t\t<li>c.t.x.XStream</li>\n\t\t\t\t<li>c.t.x.converters.extended.DynamicProxyConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaClassConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaFieldConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaMethodConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.CGLIBEnhancedConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.ExternalizableConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.SerializableConverter</li>\n\t\t\t\t<li>c.t.x.mapper.AnnotationMapper</li>\n\t\t\t\t<li>c.t.x.mapper.DefaultMapper</li>\n\t\t\t</ul>\n\t\t</li>\n\t\t<li>Added static methods newReflectionProvider, isAWTAvailable, isSQLAvailable and isSwingAvailable to\n\t\t\tc.t.x.core.JVM as replacement for the deprecated non-static methods.</li>\n\t\t<li>Deprecated c.t.x.core.JVM() and all non-static methods.</li>\n\t\t<li>Added method useImplicitType to c.t.x.annotations.XStreamConverter.</li>\n\t\t<li>JIRA:XSTR-722: Added c.t.x.converters.reflection.ReflectionProvider.getFieldOrNull(Class, String).</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.ReflectionProvider.fieldDefinedInClass(Class, String) in favor of new\n\t\t\tc.t.x.converters.reflection.ReflectionProvider.getFieldOrNull(Class, String).</li>\n\t\t<li>Deprecated constructor c.t.x.converters.extended.RegexPatternConverter(Converter) in favor of\n\t\t\tc.t.x.converters.extended.RegexPatternConverter().</li>\n\t\t<li>Deprecated default constructor of c.t.x.converters.extended.FontConverter in favor of\n\t\t\tc.t.x.converters.extended.FontConverter(Mapper).</li>\n\t\t<li>Deprecated constructor c.t.x.converters.extended.ThrowableConverter(Converter) in favor of\n\t\t\tc.t.x.converters.extended.ThrowableConverter(ConverterLookup).</li>\n\t\t<li>Deprecated class c.t.x.converters.reflection.SelfStreamingInstanceChecker and moved original implementation\n\t\t\tinto c.t.x.core.util, since it is internal.</li>\n\t\t<li>Deprecated interface c.t.x.mapper.AnnotationConfiguration.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.4\">1.4.4</h1>\n\n\t<p>Released January 19, 2013.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-709: Locks up on Mac with Apple JVM due to unwanted initialization of AWT.</li>\n\t\t<li>JIRA:XSTR-711: DateConverter cannot handle dates in different era.</li>\n\t\t<li>JIRA:XSTR-741: ToAttributedValueConverter fails to write enums as attributes.</li>\n\t\t<li>JIRA:XSTR-712: HibernateMapper throws NPE if a collection contains null.</li>\n\t\t<li>DateConverter supports now localized formats.</li>\n\t\t<li>JIRA:XSTR-710: JsonWriter does not write BigInteger and BigDecimal as number values.</li>\n\t\t<li>JIRA:XSTR-708: SqlTimestampConverter does not ignore timezone.</li>\n\t\t<li>JIRA:XSTR-707: Creation of XmllPullParser with the XmlPullParserFactory may fail in OSGi environment.</li>\n\t\t<li>JIRA:XSTR-705: Unnecessary synchronization accessing the field cache decreases performance.</li>\n\t\t<li>JIRA:XSTR-714: Fields not found when XStream12FieldKeySorter used.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is14(), c.t.x.core.util.JVM.is15() and c.t.x.core.util.JVM.is16().</li>\n\t</ul>\n\n\t<h1 id=\"1.4.3\">1.4.3</h1>\n\n\t<p>Released July 17, 2012.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support java.util.concurrent.ConcurrentHashMap with the MapConverter. This will also avoid a bug in JRockit\n\t\t\tJDK reported in JIRA:XSTR-608.</li>\n\t\t<li>JIRA:XSTR-699: Support for Hibernate 4 with XStream's Hibernate module as default for Java 6 or higher.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JVM.loadClass will now also initialize the loaded class and ignore any occurring LinkageError.</li>\n\t\t<li>JIRA:XSTR-596: SubjectConverter will be no longer registered if initialization of javax.security.auth.Subject\n\t\t\tfails.</li>\n\t\t<li>JIRA:XSTR-683: Inheritance of implicit collections, arrays or maps is dependent on declaration sequence.</li>\n\t\t<li>Inherited implicit collections, arrays or maps can be overwritten with own definition in subtype.</li>\n\t\t<li>JIRA:XSTR-688: Cannot omit XML elements from derived fields.</li>\n\t\t<li>JIRA:XSTR-696: Ill-formed JSON generated, because JSON writer is fed with type of declaring field instead of\n\t\t\tthe real object's type.</li>\n\t\t<li>JIRA:XSTR-685: Deserialization from file or URL keeps stream open.</li>\n\t\t<li>JIRA:XSTR-684: XML 1.0 character validation fails for characters from 0x10 to 0x1f.</li>\n\t\t<li>JavaBeanConverter supports now instantiation for a specific type and can therefore be used in\n\t\t\t@XStreamConverter annotation.</li>\n\t\t<li>SerializableConverter is broken if the serialized type is the default implementation.</li>\n\t\t<li>Method marshalUnserializableParent of SerializableConverter is protected now to skip the default mechanism in\n\t\t\ta derived converter that uses the default constructor to create the original type (as an alternative for\n\t\t\tJIRA:XSTR-695).</li>\n\t\t<li>FieldDictionary may call sort of FieldKeySorter implementation with wrong type as key.</li>\n\t\t<li>Sometimes DependencyInjectionFactory tries to instantiate objects with mismatching constructor arguments.</li>\n\t\t<li>HSQLDB has to be a test dependency only for XStream's Hibernate module.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.2\">1.4.2</h1>\n\n\t<p>Released November 3, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>XStream libraries can be used now directly in Android, therefore support of Java 1.4.2 has been stopped with\n\t\t\tthe delivery. Anyone who needs a version for Java 1.4.2 can build it easily from source, this build is still\n\t\t\tsupported and part of CI.</li>\n\t\t<li>JIRA:XSTR-675: New extended HierarchicalStreamReader interface with peekNextChild method. All XStream readers\n\t\t\timplement the new interface (by Nikita Levyankov).</li>\n\t\t<li>JIRA:XSTR-673: Collections.EMPTY_LIST, Collections.EMPTY_SET and Collections.EMPTY_MAP supported with own\n\t\t\talias and defined as immutable.</li>\n\t\t<li>JIRA:XSTR-631: Collections.singletonList(), Collections.singletonSet() and Collections.singletonMap()\n\t\t\tsupported with own alias and own converters.</li>\n\t\t<li>JIRA:XSTR-406 + JIRA:XSTR-663: Support additional parameters for XStreamConverter annotation (e.g. to declare\n\t\t\ta ToAttributedValueConverter).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>WstxDriver did not trigger Woodstox, but BEA StAX implementation.</li>\n\t\t<li>JIRA:XSTR-260: PrettyPrintWriter does not handle tab and new line characters in attributes.</li>\n\t\t<li>JIRA:XSTR-667: Cannot serialize empty list with JsonHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-661: TreeMarshaller.CircularReference is not a ConversionException.</li>\n\t\t<li>JIRA:XSTR-562: StAX: Namespace attribute is not written in non-repairing mode for second sibling.</li>\n\t\t<li>JIRA:XSTR-664: ClassCastException in HibernatePersistentSortedSetConverter and\n\t\t\tHibernatePersistentSortedMapConverter.</li>\n\t\t<li>JIRA:XSTR-674: Recreate binary compatibility with 1.3.x series for method\n\t\t\tCustomObjectInputStream.getInstance(...).</li>\n\t\t<li>JIRA:XSTR-671: CannotResolveClassException should accept cause.</li>\n\t\t<li>JIRA:XSTR-672: Collections.EMPTY_LIST, Collections.EMPTY_SET and Collections.EMPTY_MAP used for in implicit\n\t\t\tcollection should not throw ReferencedImplicitElementException.</li>\n\t\t<li>JIRA:XSTR-676: Introduce MissingFieldException thrown at deserialization time indicating a missing field or\n\t\t\tproperty (by Nikita Levyankov).</li>\n\t\t<li>Add length limit for cached strings in StringConverter, 38 characters by default.</li>\n\t\t<li>The JsonHierarchicalStreamDriver and the JsonWriter did not support the inherited NameCoder instance.</li>\n\t\t<li>Add BinaryStreamDriver.</li>\n\t\t<li>NPE in XppDomComparator.</li>\n\t\t<li>Dom4JXmlWriter fails to flush the underlying writer.</li>\n\t\t<li>Known control characters are not encoded with JsonWriter as proposed at json.org.</li>\n\t\t<li>Detect duplicate property processing in JavaBeanConverter and throw DuplicatePropertyException instead of\n\t\t\tclobbering silently.</li>\n\t\t<li>Allow access to Mapper and JavaBeanProvider in derived instances of JavaBeanConverter.</li>\n\t\t<li>DependencyInjectionFactory failed to create instance when a matching constructor was found, but a default\n\t\t\tconstructor was also present.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added interface c.t.x.io.ExtendedHierarchicalStreamReader extending c.t.x.io.HierarchicalStreamReader. All\n\t\t\timplementations of c.t.x.io.HierarchicalStreamReader will implement also the extended interface.</li>\n\t\t<li>Added c.t.x.converters.reflection.MissingFieldException derived from\n\t\t\tc.t.x.converters.reflection.ObjectAccessException and used instead when the unmarshalling process should write a\n\t\t\tfield or property that is missing and does not exist.</li>\n\t\t<li>Added methods c.t.x.io.path.PathTracker.peekElement(), c.t.x.io.path.PathTracker.peekElement(int), and\n\t\t\tc.t.x.io.path.PathTracker.depth().</li>\n\t\t<li>Deprecated method c.t.x.core.ReferencingMarshallingContext.currentPath(). Wrong approach.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.1\">1.4.1</h1>\n\n\t<p>Released August 11, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-659: Use again Xpp3 as default parser, now with additional XmlPullParser API as regular dependency\n\t\t\tfor the XPP factory. Only standard kXML2 package contains the XPP factory, but not the minimal kXML2 version.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Add utility class c.t.x.io.xml.xppdom.XppFactory and a path tracking comparator for XppDom.</li>\n\t</ul>\n\n\t<h1 id=\"1.4\">1.4</h1>\n\n\t<p>Released August 6, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Java 7 is detected and supported.</li>\n\t\t<li>JIRA:XSTR-542: The XppDriver uses now the official XmlPullParser API to locate an available parser using the\n\t\t\tXmlPullParserFactory. This allows the usage of XPP technology with XStream in Android.</li>\n\t\t<li>Additional explicit XPP drivers for the Xpp3 and kXML2 implementations.</li>\n\t\t<li>Additional explicit XPP DOM drivers for the Xpp3 and kXML2 implementations.</li>\n\t\t<li>kXML2 is now the preferred parser implementation, Xpp3 is optional.</li>\n\t\t<li>Additional explicit StAX drivers for Woodstox, BEA StAX and SJSXP of the JDK 6 implementations.</li>\n\t\t<li>JDK 1.3 is no longer officially supported.</li>\n\t\t<li>JIRA:XSTR-377+JIRA:XSTR-226: New artifact xstream-hibernate with converters and mapper to process Hibernate\n\t\t\tobject graphs (by Costin Leau, Konstantin Pribluda and in special Jaime Metcher).</li>\n\t\t<li>New NameCoder interface and implementations to support a generic name translation between names from the\n\t\t\tobject graph and a target format. The new XmlFriendlyNameCoder replaces the XmlFriendlyReplacer used for XML only.</li>\n\t\t<li>JIRA:XSTR-553: Support annotations in Android.</li>\n\t\t<li>JIRA:XSTR-556: DateConverter uses format with 3-letter time zones that are ambiguous. Therefore it will now\n\t\t\talways use UTC to write dates. Unmarshalled dates are not affected as long as they contain a time zone.</li>\n\t\t<li>The type java.lang.reflect.Field is now handled by an own converter, that can still read the old format.</li>\n\t\t<li>JIRA:XSTR-490: Provide path in Converter for contexts that track the path.</li>\n\t\t<li>JIRA:XSTR-592+JIRA:XSTR-579: OmitField respected at deserialization time even for existing fields.</li>\n\t\t<li>JIRA:XSTR-593: Direct support for java.net.URI instances (by Carlos Roman).</li>\n\t\t<li>JIRA:XSTR-615+JIRA:XSTR-580: Dynamic proxies cannot be referenced recursively.</li>\n\t\t<li>JIRA:XSTR-547: Wrong class loader used for Serializable types deserialized with an ObjectInputStream.</li>\n\t\t<li>JIRA:XSTR-341: Support of implicit arrays.</li>\n\t\t<li>JIRA:XSTR-306+JIRA:XSTR-406: Support of implicit maps.</li>\n\t\t<li>JIRA:XSTR-344: New ToAttributedValueConverter to allow conversion of an element with string body and\n\t\t\tattributes.</li>\n\t\t<li>JIRA:XSTR-573: SortedSet added with TreeSet as the default implementation.</li>\n\t\t<li>JIRA:XSTR-576: TreeMap and TreeSet no longer add an element without comparator (by Jason Greanya), solves\n\t\t\talso invalid format with JSON for such objects (JIRA:XSTR-640).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-612: Improve extensibility of c.t.x.javabean.* package by reintroducing a PropertyDictionary with\n\t\t\tthe additional interface PropertySorter.</li>\n\t\t<li>JIRA:XSTR-591: EnumSingleValueConverter did use toString() instead of name() to create the String\n\t\t\trepresentation of an enum value.</li>\n\t\t<li>JIRA:XSTR-618: Add Oracle as vendor used for recent JRockit versions and former Sun JDK.</li>\n\t\t<li>JIRA:XSTR-656: DomReader and Dom4JReader do not escape attribute names retrieving their values.</li>\n\t\t<li>JIRA:XSTR-604: StringConverter's cache may cause an OutOfMemoryException.</li>\n\t\t<li>JIRA:XSTR-577: Skip UTF-8 BOM in XmlHeaderAwareReader.</li>\n\t\t<li>The XppReader no longer uses a BufferedReader.</li>\n\t\t<li>JIRA:XSTR-543: Better deserialization support of the defined-in system attribute in combination with field\n\t\t\taliases.</li>\n\t\t<li>JIRA:XSTR-551: Deprecated XStream.InitializationException still thrown instead of InitializationException.</li>\n\t\t<li>JIRA:XSTR-655: JsonWriter generates invalid JSON for Externalizable types.</li>\n\t\t<li>JIRA:XSTR-540: Support Jettison-based configuration of JettisonMappedXmlDriver (by Doug Daniels).</li>\n\t\t<li>JIRA:XSTR-633: JettisonMappedXmlDriver escaped property names according escape rules for XML tag names.</li>\n\t\t<li>JIRA:XSTR-625: Optionally ignore XStream's hints for Jettison to generate JSON arrays (by Dejan Bosanac).</li>\n\t\t<li>JIRA:XSTR-605: Upgrade to Jettison 1.2 (for Java 5 or higher).</li>\n\t\t<li>New JsonWriter.EXPLICIT_MODE generating JSON that enforces property sequence.</li>\n\t\t<li>JIRA:XSTR-552: Improve performance of ReflectionProvider (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-559: Improve performance of Sun14ReflectionProvider (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-564: Improve performance of AnnotationMapper (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-563: Use ReferenceQueue for cleaning-up WeakReferences in ObjectIdDictionary (by Keith\n\t\t\tKowalczykowski).</li>\n\t\t<li>JIRA:XSTR-646: Cache of Sun14ReflectionProvider consumes more PermGen space than necessary.</li>\n\t\t<li>JIRA:XSTR-636: Ineffective cache in FieldDictionary using WeakHashMap with WeakReference values.</li>\n\t\t<li>Ineffective cache for SerializationMethodInvoker (related to JIRA:XSTR-636).</li>\n\t\t<li>Introduction of Caching interface implemented by all types in XStream that create local caches that may have\n\t\t\tto be flushed manually.</li>\n\t\t<li>Avoid excessive creation of AbstractPullReader.Event objects by using a pool.</li>\n\t\t<li>Possibility to generate XPath expressions that select always a single node instead of a node list.</li>\n\t\t<li>Cannot reference replaced object using ID references.</li>\n\t\t<li>Implicit collection functionality will no longer use custom collection converters that may write tags that\n\t\t\tare not recognized at deserialization time again.</li>\n\t\t<li>JIRA:XSTR-654: Unmarshal fails when an implicit collection is defined and an element is named equal to the\n\t\t\tfield.</li>\n\t\t<li>JIRA:XSTR-574: AbstractReferenceUnmarshaller cannot handle null values for references.</li>\n\t\t<li>Improve exception output in case of a missing field.</li>\n\t\t<li>JIRA:XSTR-555: StAX driver tests do not honor repairing mode.</li>\n\t\t<li>JIRA:XSTR-570: The @XStreamConverter provides now also the current type as possible constructor argument.</li>\n\t\t<li>JIRA:XSTR-629: Deserialization of Externalizable with non-accessible default constructor fails.</li>\n\t\t<li>JIRA:XSTR-571: Cannot serialize synchronized RandomAccessList types.</li>\n\t\t<li>JIRA:XSTR-583: BinaryDriver fails to handle Strings with more than 64K bytes.</li>\n\t\t<li>JIRA:XSTR-639: Cannot omit field at deserialization if the field has a class attribute.</li>\n\t\t<li>JIRA:XSTR-599: EncodedByteArrayConverter should implement SingleValueConverter.</li>\n\t\t<li>JIRA:XSTR-584: Race condition in XmlFriendlyReplacer.</li>\n\t\t<li>JIRA:XSTR-623: XmlFriendlyReplacer may write illegal name characters (by Michael Schnell).</li>\n\t\t<li>The ConversionException hides information if its ErrorWriter contains the added key already.</li>\n\t\t<li>JIRA:XSTR-598: Attribute &quot;defined-in&quot; was wrongly evaluated for other attributes.</li>\n\t\t<li>JIRA:XSTR-650: Possible NullPointerException at initialization on platforms like Android that do not support\n\t\t\tall types of the JDK.</li>\n\t\t<li>JIRA:XSTR-652: Initialization of XStream fails if DurationConverter constructor throws a\n\t\t\tjavax.xml.datatype.DatatypeConfigurationException. Converter will no longer handle Duration types if no instance of\n\t\t\tthe internal DatatypeFactory can be created.</li>\n\t\t<li>Constructor DocumentWriter(Element) forgets the provided element.</li>\n\t\t<li>JIRA:XSTR-597: Optimize AbstractReflectionConverter.</li>\n\t\t<li>Introduce Caching interface to flush the internal cache of specific components.</li>\n\t\t<li>Support JIRA:XSTR-407 also for IBM JRE 1.6 and greater.</li>\n\t\t<li>java.nio.charset.Charset's converter was added as immutable type instead of the type itself.</li>\n\t\t<li>java.util.Currency added as immutable type.</li>\n\t\t<li>Fix selection of same parameter types in DependencyInjectionFactory.</li>\n\t\t<li>Deprecation of c.t.x.javabean.PropertyDictionary has been countermanded.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Any deprecated stuff of the 1.2.x releases has been removed.</li>\n\t\t<li>Deprecated constructors of c.t.x.converters.reflection.SerializableConverter,\n\t\t\tc.t.x.converters.reflection.ExternalizableConverter and c.t.x.converters.reflection.CGLIBEnhancedConverter; new\n\t\t\tversions take an additional argument for class loader (as a result for JIRA:XSTR-547).</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.XppReader, new versions take an additional argument for the\n\t\t\tXmlPullParser.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XppReader.createParser(), the XPP parser is now created by the driver.</li>\n\t\t<li>Package c.t.x.io.xml.xppdom is now part of the official API.</li>\n\t\t<li>c.t.x.io.xml.xppdom.Xpp3Dom and c.t.x.io.xmlxpp.dom.Xpp3DomBuilder have been deprecated. Functionality is\n\t\t\tmerged in c.t.x.io.xml.xppdom.XppDom.</li>\n\t\t<li>Deprecated c.t.x.mapper.XStream11XmlFriendlyMapper and c.t.x.mapper.AbstractXmlFriendlyMapper.</li>\n\t\t<li>Added interface c.t.x.core.ReferencingMarshallingContext which is implemented by all referencing marshallers.</li>\n\t\t<li>Added interface c.t.x.io.naming.NameCoder and implementations.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XmlFriendlyReplacer, c.t.x.io.xml.XmlFriendlyReader and\n\t\t\tc.t.x.io.xml.XmlFriendlyWriter.</li>\n\t\t<li>Deprecated c.t.x.io.xml.AbstractXmlDriver, c.t.x.io.xml.AbstractXmlReader and c.t.x.io.xml.AbstractXmlWriter,\n\t\t\tadded c.t.x.io.AbstractDriver, c.t.x.io.AbstractReader and c.t.x.io.AbstractWriter instead.</li>\n\t\t<li>Deprecated all constructors of Driver, Reader and Writer implementations that take a XmlFriendlyReplacer as\n\t\t\targument, added constructors taking a NameCoder instead.</li>\n\t\t<li>Added interface com.thoughtworks.xstream.converters.ErrorReporter to allow other types to report also errors\n\t\t\t(apart from a HierarchicalStreamReader). Any converter and the parent object of the currently deserialized element\n\t\t\tmay provide additional error information now.</li>\n\t</ul>\n\n\t<h1 id=\"1.3.1\">1.3.1</h1>\n\n\t<p>Released December 6, 2008.</p>\n\n\t<p class=\"highlight\">CGLIB support must be explicitly activated now. The decision has been made due to possible\n\t\tproblems using an own classloader and because of ongoing complaints about occurring exceptions in the\n\t\tCGLIBEnhancedConverter at XStream initialization although they are caused by incompatible ASM versions on the user's\n\t\tclasspath (JIRA:XSTR-469, JIRA:XSTR-513 and JIRA:XSTR-518).</p>\n\n\t<p class=\"highlight\">XStream uses some attributes on its own. Until now it was possible to use\n\t\tXStream.aliasAttribute to define a different name. This does still work but is deprecated for system attributes. Use\n\t\tthe new call XStream.aliasSystemAttribute for such an alias.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-515: CGLIB support is no longer activated automatically and has to be <a\n\t\t\thref=\"faq.html#Serialization_CGLIB\">explicitly turned on</a>.\n\t\t</li>\n\t\t<li>JIRA:XSTR-448: Separated system attributes and user defined attributes for aliases.</li>\n\t\t<li>JIRA:XSTR-55: Ability to alias a package name.</li>\n\t\t<li>JIRA:XSTR-434: New JsonWriter instead of JsonHierarchicalStreamWriter with mode to strip root node of\n\t\t\tgenerated JSON (by Paul Hammant).</li>\n\t\t<li>Support for Diablo JDK on FreeBSD (by Reto Bachmann-Gm&uuml;r).</li>\n\t\t<li>JIRA:XSTR-495: New PersistenceStrategy instead of StreamStrategy (based on the code and comments by Alexander\n\t\t\tRadzin).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Support special Jettison functionality for JSON to detect collections or arrays with one element introduced\n\t\t\twith Jettison 1.0.</li>\n\t\t<li>JIRA:XSTR-493: Using attributes for fields with XML-unfriendly names results in NPE at deserialization.</li>\n\t\t<li>JIRA:XSTR-497: Unsafe operation with WeakHashMap can raise a NPE in Sun14ReflectionProvider.</li>\n\t\t<li>JIRA:XSTR-423: Support of CGLIB enhanced proxies with multiple callbacks if the proxy uses a factory (CGLIB\n\t\t\tdefault).</li>\n\t\t<li>JIRA:XSTR-536: XStream silently ignores unknown elements.</li>\n\t\t<li>JIRA:XSTR-503: Omitted properties in JavaBeans are requested at serialization (by Kevin Conaway).</li>\n\t\t<li>Fix possible memory leak in ObjectIdMap for JVMs that provide real distinct identity hash codes (happened on\n\t\t\tamd64 system).</li>\n\t\t<li>JIRA:XSTR-480: Aliasing of array types.</li>\n\t\t<li>JIRA:XSTR-515: The SubjectConverter and DurationConverter are only registered if the converted class is part\n\t\t\tof the JDK, otherwise they must be registered now explicitly.</li>\n\t\t<li>JIRA:XSTR-504: XmlHeaderAwareReader fails with improper sized PushbackInputStream.</li>\n\t\t<li>JIRA:XSTR-489: @XStreamConverter supports now also SingleValueConverter implementations.</li>\n\t\t<li>JIRA:XSTR-481: @XStreamConverter and @XStreamAsAttribute can be used together (as a result of JIRA:XSTR-489).</li>\n\t\t<li>JIRA:XSTR-519: New annotation @XStreamInclude to force annotation detection of included types (by Seven\n\t\t\tSparling).</li>\n\t\t<li>JIRA:XSTR-469: Support custom converters for enum types.</li>\n\t\t<li>JIRA:XSTR-502: ClassNotFoundException even if writeReplace returns proper object.</li>\n\t\t<li>JIRA:XSTR-529: NullPointerException for null elements in implicit lists.</li>\n\t\t<li>JIRA:XSTR-517: Miscellaneous performance improvements (by Tatu Saloranta).</li>\n\t\t<li>JIRA:XSTR-525: JsonHierarchicalStreamDriver writes invalid JSON in case of system attribute.</li>\n\t\t<li>JIRA:XSTR-535: Mode to allow plain values as result for JSON without root node.</li>\n\t\t<li>JIRA:XSTR-531: Possibility to omit system attributes.</li>\n\t\t<li>JIRA:XSTR-508: Fix marshalling error for nested serializable objects with own writeReplace/readResolve\n\t\t\tmethods.</li>\n\t\t<li>JIRA:XSTR-507: Advanced ReferenceByIdMarshaller uses id of the current object if available.</li>\n\t\t<li>JIRA:XSTR-485: Check reference for valid object when deserializing.</li>\n\t\t<li>Fix classloader problem, Xpp3 parser cannot be loaded within a web application.</li>\n\t\t<li>Dependencies have been updated to latest versions of JDOM, Jettison, Joda Time, and Woodstox. Note for Maven\n\t\t\tbuilds that the <em>groupId</em> of JDOM has changed.\n\t\t</li>\n\t\t<li>Fix possible IndexOutOfBoundsException creating returning the message for a ConversionException.</li>\n\t\t<li>JIRA:XSTR-495: StreamStrategy cannot handle key with value <em>null</em>.\n\t\t</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecated c.t.x.io.json.JsonHierarchicalStreamWriter in favour of c.t.x.io.json.JsonWriter.</li>\n\t\t<li>c.t.x.mapper.EnumMapper no longer derives from the c.t.x.mapper.AttributeMapper as it has been before version\n\t\t\t1.3. Therefore the new constructor has been deprecated in favour of the old one.</li>\n\t\t<li>c.t.x.mapper.Mapper.getConverterFromAttribute(Class, String) has been deprecated in favour of\n\t\t\tc.t.x.mapper.Mapper.getConverterFromAttribute(Class, String, Class) taking the type as third argument that should be\n\t\t\thandled by the converter.</li>\n\t\t<li>c.t.x.core.ReferenceByIdMarshaller.IdGenerator.next() has now the current object as argument.</li>\n\t\t<li>New c.t.x.persistence.PersistenceStrategy and c.t.x.persistence.FilePersistenceStrategy.</li>\n\t\t<li>Deprecated c.t.x.persistence.StreamStrategy and c.t.x.persistence.FileStreamStrategy.</li>\n\t</ul>\n\n\t<h1 id=\"1.3\">1.3</h1>\n\n\t<p>Released February 27, 2008.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>ReflectionConverter writes now the fields of the parent classes first.</li>\n\t\t<li>Support for Converter definition at field level.</li>\n\t\t<li>Refactoring of Annotation support, invent auto-detection mode.</li>\n\t\t<li>Annotated converters are no longer detected automatically, all annotations are now handled in the same way.</li>\n\t\t<li>JIRA:XSTR-334: XStream will deserialize directly from a file or URL. Some parser take advantage of these\n\t\t\tobjects to define a SystemId used to resolve further references in XML, schema or DTD. Appropriate createReader\n\t\t\tmethods have been added to c.t.x.io.HierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-261: All c.t.x.io.HierarchicalStreamDriver implementations respect now the encoding of an XML\n\t\t\theader if read from an InputStream.</li>\n\t\t<li>DomDriver does no longer use explicitly UTF-8 by default, DomReader will therefore respect the encoding\n\t\t\tdefined in the XML header or use native encoding</li>\n\t\t<li>JIRA:XSTR-415: JavaBeanConverter uses now BeanIntrospection (by Hinse ter Schuur).</li>\n\t\t<li>JIRA:XSTR-424: DateConverter uses now by default SimpleDateFormat instances in non-lenient mode.</li>\n\t\t<li>JIRA:XSTR-386: SingleValueConverter that utilizes PropertyEditor implementations (by Jukka Lindstr&ouml;m).</li>\n\t\t<li>JIRA:XSTR-427: Converter for javax.xml.datatype.Duration (by John Kristian).</li>\n\t\t<li>JIRA:XSTR-305: Field alias inheritance (by David Blevins).</li>\n\t\t<li>XStream failed to initialize in environments without AWT or SQL classes.</li>\n\t\t<li>JIRA:XSTR-420: XPath of references are not XmlFriendly encoded.</li>\n\t\t<li>JIRA:XSTR-473: String &quot;\\0&quot; serialized as invalid XML, support compliant behaviour according XML\n\t\t\tversion.</li>\n\t\t<li>JIRA:XSTR-431: Direct support of enhanced mode for SAP JVM (thanks to Norbert Kuck by SAP).</li>\n\t\t<li>JIRA:XSTR-437: Static cache in annotation processing causes failing OSGi bundles.</li>\n\t\t<li>JIRA:XSTR-279+JIRA:XSTR-335: Annotations are not inherited from parent class.</li>\n\t\t<li>Fix StringConverter using a WeakHashMap with strong references in its value.</li>\n\t\t<li>JIRA:XSTR-403: Attributes are no longer written with JSONHierarchicalStreamDriver if current object is a\n\t\t\tcollection.</li>\n\t\t<li>JIRA:XSTR-456: New LookAndFeelConverter handling LookAndFeel implementations with reflection.</li>\n\t\t<li>JIRA:XSTR-462: CachingMapper keeps direct class references.</li>\n\t\t<li>JIRA:XSTR-411: JsonHierarchicalStreamDriver does not escape characters according RFC 4627.</li>\n\t\t<li>JsonHierarchicalStreamDriver writes wrong brackets around complex Java types with a single value.</li>\n\t\t<li>JsonHierarchicalStreamDriver writes attribute names with a leading '@'.</li>\n\t\t<li>JsonHierarchicalStreamDriver supports Map implementations.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added converter for java.lang.StringBuilder instances.</li>\n\t\t<li>Added converter for java.util.UUID instances.</li>\n\t\t<li>JIRA:XSTR-430: Fields written as attributes could not be omitted.</li>\n\t\t<li>JIRA:XSTR-407: Comparator might access uninitialized elements for TreeSet and TreeMap. A deserialized\n\t\t\tComparator is no longer called, the converters expect the elements now in a sorted order.</li>\n\t\t<li>JIRA:XSTR-404, @XStreamImplicit() for ArrayList&lt;ArrayList&lt;Type&gt;&gt; throws ClassCastException.</li>\n\t\t<li>@XStreamContainedType() for ArrayList&lt;ArrayList&lt;Type&gt;&gt; throws ClassCastException.</li>\n\t\t<li>XStreamer did not persist a FieldKeySorter instance.</li>\n\t\t<li>JIRA:XSTR-241: JavaBeanConverter now supports customized BeanProvider.</li>\n\t\t<li>JIRA:XSTR-280: JavaBeanConverter now supports aliasField and omitField (by Hinse ter Schuur).</li>\n\t\t<li>JIRA:XSTR-280: SerializationConverter now supports aliasField and omitField.</li>\n\t\t<li>JIRA:XSTR-429: XmlFriendlyReplacer support for SaxWriter and TraxSource (by Adrian Wilkens).</li>\n\t\t<li>JIRA:XSTR-421: Characters cannot be written as attribute.</li>\n\t\t<li>JIRA:XSTR-426: java.swt.KeyStroke not properly serialized because of a character undefined in unicode.</li>\n\t\t<li>JIRA:XSTR-352: Strings with arbitrary ISO control characters are not properly serialized.</li>\n\t\t<li>JIRA:XSTR-428: An attribute named like a transient field did abort deserialization of following fields.</li>\n\t\t<li>JIRA:XSTR-443: XStream.createObjectOutputStream does not use the given driver to create the\n\t\t\tHierarchicalStreamWriter.</li>\n\t\t<li>JIRA:XSTR-440: Implicit collections can be declared for fields that are not of Collection type.</li>\n\t\t<li>JIRA:XSTR-446: Handle all primitives and their boxed counterpart for JsonHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-447: Fix deserialization of Array class types in JDK 6 (see JDK bug 6500212).</li>\n\t\t<li>JIRA:XSTR-450: @XStreamAlias is ignored if attributes should be used for the field type.</li>\n\t\t<li>JIRA:XSTR-418: Inherited @XStreamAlias is ignored if field should be rendered as attribute.</li>\n\t\t<li>JIRA:XSTR-393: Annotation processing is not consistent.</li>\n\t\t<li>JIRA:XSTR-412: @XStreamImplicit throws NPE for untyped collections.</li>\n\t\t<li>JIRA:XSTR-463: Cannot provide own default Mapper chain.</li>\n\t\t<li>JIRA:XSTR-464: Cannot provide a ClassLoader that is used in all cases.</li>\n\t\t<li>JIRA:XSTR-394: Allow enums as attributes.</li>\n\t\t<li>JIRA:XSTR-413: Support @XStreamAsAttribute for enums.</li>\n\t\t<li>JIRA:XSTR-478: Cannot specify default implementation for polymorphic enum.</li>\n\t\t<li>JIRA:XSTR-419: Treat enums as immutable types.</li>\n\t\t<li>Update annotation tutorial, explain limitations of auto-detection mode.</li>\n\t\t<li>Added copyright notices to all files.</li>\n\t\t<li>StaxWriter.flush did close Stax' XMLStreamWriter instead of flushing it.</li>\n\t\t<li>JIRA:XSTR-471: XStream POMs do no longer declare a repository at all.</li>\n\t\t<li>Calendar object could not be rendered with JSONHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-476: Properties can be sorted by key.</li>\n\t\t<li>XStream.createObjectInputStream and XStream.createObjectOutputStream overloaded to support a binary\n\t\t\tInputStream or OutputStream.</li>\n\t\t<li>JIRA:XSTR-470: Allow transient fields to be optionally deserialized.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>c.t.x.annotation.Annotations, c.t.x.annotation.AnnotationReflectionConverter and\n\t\t\tc.t.x.annotation.AnnotationProvider deprecated. Functionality is integrated in new c.t.x.mapper.AnnotationMapper and\n\t\t\taccessible with new methods c.t.x.XStream.processAnnotations().</li>\n\t\t<li>New auto-detection mode for annotations, that can be turned on with c.t.x.XStream.autodetectAnnotations()</li>\n\t\t<li>c.t.x.annotation.@XStreamContainedType deprecated, the behaviour is now always active and the annotation\n\t\t\ttherefore superfluous.</li>\n\t\t<li>Due to JIRA:XSTR-421 null characters are no longer written as tag with an attribute (&lt;char\n\t\t\tnull=&quot;true&quot;/&gt;), but as empty tag. The old representation is still supported at deserialization.</li>\n\t\t<li>Characters that are not defined in unicode or ISO control characters (expect TAB and LF) are written as\n\t\t\tnumerical entity now.</li>\n\t\t<li>XPath references are now also XML-friendly encoded to match the path exactly. Unencoded references will\n\t\t\tnormally work anyway, but in special cases the exact behaviour of XStream 1.2.x might be necessary. See acceptance\n\t\t\ttests for XStream 1.2.x compatibility.</li>\n\t\t<li>c.t.x.core.BaseException deprecated in favour of c.t.x.XStreamException as base exception for all exceptions\n\t\t\tXStream throws.</li>\n\t\t<li>c.t.x.XStream.InitializerException deprecated in favour of c.t.x.InitializerException.</li>\n\t\t<li>New methods get() and keys() in interface c.t.x.converter.ErrorWriter.</li>\n\t\t<li>c.t.x.mapper.XmlFriendlyMapper deprecated, technology is replaced since version 1.2 by\n\t\t\tc.t.x.io.xml.XmlFriendlyReplacer as part of the different XmlWriter implementations.</li>\n\t\t<li>c.t.x.mapper.Mapper.aliasForAttribute() and c.t.x.mapper.Mapper.attributeForAlias() deprecated, since it\n\t\t\tprovided in reality the combined functionality of c.t.x.mapper.Mapper.serializedMember()/realMember() and\n\t\t\tc.t.x.mapper.Mapper.getConverterFromItemType().</li>\n\t\t<li>c.t.x.XStream(ReflectionProvider, Mapper, HierarchicalStreamDriver) deprecated, in favour of\n\t\t\tc.t.x.XStream(ReflectionProvider, HierarchicalStreamDriver, Mapper, ClassLoader).</li>\n\t\t<li>New interface c.t.x.converter.ConverterRegistry to express explicit functionality managing the converters.</li>\n\t\t<li>c.t.x.core.DefaultConverterLookup no longer uses a c.t.x.mapper.Mapper. Therefore the old constructor has\n\t\t\tbeen deprecated in favour of a default constructor.</li>\n\t\t<li>Overloaded methods of c.t.x.mapper.Mapper.getConverterFromItemType and\n\t\t\tc.t.x.mapper.Mapper.getConverterFromAttribute have been deprecated. Only one version has been kept, the\n\t\t\timplementation can handle all cases now at once and therefore multiple calls to the mapper chain are avoided.</li>\n\t\t<li>c.t.x.mapper.EnumMapper derives now from the c.t.x.mapper.AttributeMapper to support enums as attributes.\n\t\t\tTherefore the old constructor has been deprecated in favour of one taking an additional\n\t\t\tc.t.x.converters.ConverterLookup that has to be passed to the new parent.</li>\n\t</ul>\n\n\t<p class=\"highlight\">Note, to support a representation of null values in some way, it is absolutely necessary that\n\t\teach converter can handle a null value in its marshalling methods. If you have implemented your own custom converters,\n\t\ttry to handle such a case also to prevent incompatibilities in case XStream will provide such values with its next\n\t\tmajor version.</p>\n\n\t<h1 id=\"1.2.2\">Version 1.2.2</h1>\n\n\t<p>Released May 24, 2007.</p>\n\n\t<p class=\"hightlight\">Note, that next version of XStream will behave slightly different by default. XStream emits\n\t\tall fields in declaration order like Java serialization. But in contrast to Java it will omit the fields of parent\n\t\tclasses last while Java serialization emits them first. This makes it difficult to match a given XML schema that\n\t\tdefined inherited types or leads sometimes to obscure initialization problems. However, XStream itself will not be\n\t\taffected by the changed order of elements in the XML, any deserialization of current XML representations will work\n\t\tfine. Anyway we will provide with XStream 1.3 a FieldKeySorter implementation that mimics the old behaviour. In the\n\t\tmeanwhile you can enforce the new field sorting by installing the NaturalFieldKeySorter.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-391, Support for writing (and reading) JSON by the new JettisonMappedXmlDriver (by Dejan Bosanac).</li>\n\t\t<li>New FieldKeySorter interface allows a custom sort order of the XML elements.</li>\n\t\t<li>JIRA:XSTR-68 and JIRA:XSTR-210, OmitField is now respected at deserialization to ignore removed fields.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-387, Fix aliasing of inherited fields.</li>\n\t\t<li>JIRA:XSTR-395, Fix StringConverter allocating PermGen space.</li>\n\t\t<li>JIRA:XSTR-368, @XStreamConverter converters should be cached inside the AnnotationReflectionConverter.</li>\n\t\t<li>JIRA:XSTR-392, @XStreamOmitField can be used to omit fields from the resulting XML (contributed by Chung-Onn\n\t\t\tCheong).</li>\n\t\t<li>JIRA:XSTR-371, Fix JSONWriter that omits a closing bracket for for fields with null value.</li>\n\t\t<li>JIRA:XSTR-398, DomDriver ignores given XmlFriendlyReplacer.</li>\n\t\t<li>JIRA:XSTR-370, Buildable with JDK 6, fix FontConverter for JDK 6.</li>\n\t\t<li>JIRA:XSTR-382, Support hex and octal number values.</li>\n\t\t<li>DateConverter did not respect change in TimeZone after first usage.</li>\n\t\t<li>JIRA:XSTR-375, Support for aliasing native types.</li>\n\t\t<li>JIRA:XSTR-243 again, XML elements for transient fields are now ignored completely at deserialization.</li>\n\t\t<li>Release unused object references to keep memory print low.</li>\n\t\t<li>Support for AWT and SQL is now optional: XStream now works on embedded virtual machines lacking such APIs (by\n\t\t\tNicolas Gros d'Aillon).</li>\n\t\t<li>Support raw bytes read from the ObjectInputStream.</li>\n\t\t<li>JIRA:XSTR-373, Support for Hitachi JVM (tested by Yuji Yamano).</li>\n\t\t<li>JIRA:XSTR-378 and JIRA:XSTR-379, Fix TextAttributeConverter and EnumSetConverter failing on Apache Harmony.</li>\n\t\t<li>JIRA:XSTR-363, Support of native field order i.e. fields are processed in declaration order base classes\n\t\t\tfirst.</li>\n\t\t<li>JIRA:XSTR-320, Static field in child may hide non-static field in parent.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-365, Multiple implicit collections with annotations. Deprecated @XStreamImclicitCollection in\n\t\t\tfavour of @XStreamImplicit declared at field level.</li>\n\t</ul>\n\n\t<h1 id=\"1.2.1\">Version 1.2.1</h1>\n\n\t<p>Released November 11, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Introduced DocumentWriter interface and generalized functionality for all writer implementations creating a\n\t\t\tDOM structure (DOM4J, DOM, JDom, Xom, Xpp3Dom).</li>\n\t\t<li>Refactored build system to use Maven 2. Ant still supported on XStream Core.</li>\n\t\t<li>Created separate XStream Benchmark module</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-346, XStream.getClassMapper() does not return a ClassMapper for the current Mapper.</li>\n\t\t<li>Fix problem with fields containing a double underscore.</li>\n\t\t<li>JIRA:XSTR-345, Dom4JWriter adds up attributes.</li>\n\t\t<li>JIRA:XSTR-336, XStream fails to reference an implicit element.</li>\n\t\t<li>JIRA:XSTR-337, Annotation cycle bug.</li>\n\t\t<li>Fix packaging error for the resulting jar building with Maven2.</li>\n\t\t<li>JIRA:XSTR-339, NPE for attribute null values.</li>\n\t\t<li>JIRA:XSTR-338, NPE in JSON writer for converters using non-extended HierarchicalStreamWriter.</li>\n\t\t<li>JIRA:XSTR-357, Fix escaping of values in JSON writer.</li>\n\t\t<li>JIRA:XSTR-356, Fix unmarshaling error for fields containing proxies.</li>\n\t\t<li>JIRA:XSTR-349, Fix backward compatibility of Dom4jWriter.</li>\n\t\t<li>JIRA:XSTR-309, More versatile boolean conversion options (contributed by David Blevins).</li>\n\t\t<li>Add XStream.getReflectionProvider() to retrieve ReflectionProvider in use.</li>\n\t\t<li>JIRA:XSTR-358, @XStreamConverter annotation does not call converter constructor.</li>\n\t\t<li>Website generated using <a href=\"http://xsite.codehaus.org\">XSite</a></li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecate JDomWriter.getResult() in favour of DocumentWriter.getTopLevelNodes().</li>\n\t\t<li>Deprecate ThreadSafeSimpleDateFormat, since this is an internal helper and not part of XStream API.</li>\n\t</ul>\n\n\t<h1 id=\"1.2\">Version 1.2</h1>\n\n\t<p>Released August 18, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-269, Using attributes for fields (contributed by Paul Hammant and Ian Cartwright).</li>\n\t\t<li>Aliasing of arbitrary attributes.</li>\n\t\t<li>JIRA:XSTR-50, XStream can now serialize another XStream instance.</li>\n\t\t<li>JIRA:XSTR-227, XStream has now the XStreamer, that serializes an object together with its XStream instance.</li>\n\t\t<li>JIRA:XSTR-278, AnnotationConverter for fields (contributed by Guilherme Silveira).</li>\n\t\t<li>JIRA:XSTR-256, PureJavaReflectionProvider supports now final fields starting with JDK 1.5</li>\n\t\t<li>JIRA:XSTR-258, Any Collection type can now be declared implicit, the default implementation will be respected\n\t\t\tfor unmarshaling.</li>\n\t\t<li>JIRA:XSTR-88, XStream can now write all references as absolute XPath expression.</li>\n\t\t<li>JIRA:XSTR-62 and JIRA:XSTR-211, New SingeValueConverter allows light weight converters if the value can be\n\t\t\trepresented by a unique string.</li>\n\t\t<li>Aliasing of classes of a specific type.</li>\n\t\t<li>JIRA:XSTR-239, Support for certain types of proxies generated with the CGLIB Enhancer.</li>\n\t\t<li>JIRA:XSTR-90 and JIRA:XSTR-311, Support for BEA JRockit starting with R25.1.0 (contributed by Henrik\n\t\t\tSt&aring;hl of BEA).</li>\n\t</ul>\n\n\t<h2>Technology preview</h2>\n\n\t<ul>\n\t\t<li>Experimental binary reader and writer.</li>\n\t\t<li>Experimental HierarichicalStreamCopier allows streams to be copied from one format to another without the\n\t\t\toverhead of serialization.</li>\n\t\t<li>Experimental JSON support allows streams to be copied from one format to another without the overhead of\n\t\t\tserialization (contributed by Paul Hammant).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-266, XStream fails to serialize elements of a unserializable class, that is a base class of a\n\t\t\tderived class</li>\n\t\t<li>JIRA:XSTR-236, Priority constants for converter registration are now public</li>\n\t\t<li>JIRA:XSTR-215, XStream writes now fields in declaration order even for JVMs reporting them in reverse order\n\t\t\tlike IBM JDK.</li>\n\t\t<li>JIRA:XSTR-276 and JIRA:XSTR-283, XStream does no longer attempt to create references to implicit element.</li>\n\t\t<li>JIRA:XSTR-244, Closing a Writer can now be done twice, but any write attempt will later on fail.</li>\n\t\t<li>JIRA:XSTR-243, Transient fields were unmarshalled from XML.</li>\n\t\t<li>JIRA:XSTR-250, Providing a mapper to the XStream constructor will no longer result in a NPE.</li>\n\t\t<li>JIRA:XSTR-281, After registering a new converter, the internal converter cache is now cleared.</li>\n\t\t<li>JIRA:XSTR-284, XStream checks the object returned by a converter for compatibility.</li>\n\t\t<li>XStream no longer fails serializing a Throwable without cause when no references shall be written.</li>\n\t\t<li>Converter for java.awt.font.TextAttribute.</li>\n\t\t<li>Converter for java.nio.charset.Charset.</li>\n\t\t<li>JIRA:XSTR-286, XStream detects impossible self serialization and throws now an appropriate\n\t\t\tConversionException.</li>\n\t\t<li>JIRA:XSTR-291, XomDriver implementation added.</li>\n\t\t<li>JIRA:XSTR-299, Fix for implicit collections with items using the same name as the field name of the\n\t\t\tunderlying collection.</li>\n\t\t<li>JIRA:XSTR-245, Broken XML with custom serialization in certain cases (patch contributed by Cyrille Le Clerc).</li>\n\t\t<li>JIRA:XSTR-304, Bad handling of repairing namespace flag for StaxDriver (patch contributed by John Kristian).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-252, Refactored support for XML friendly character mapping.</li>\n\t\t<li>JIRA:XSTR-69, Refactored ReflectionConverter allows simpler subclassing.</li>\n\t\t<li>Unmarshalling context has now an overloaded version of the method convertAnother to provide the Converter\n\t\t\tdirectly.</li>\n\t\t<li>Deprecate ClassMapper for Mapper. All methods with a ClassMapper parameter have now a duplicate taking only a\n\t\t\tMapper. The variant with the ClassMapper is deprecated.</li>\n\t\t<li>Deprecate c.t.x.alias.CannotResolveClassException for c.t.x.mapper.CannotResolveClassException.</li>\n\t\t<li>Deprecate NameMapper (was not used within XStream anymore anyway).</li>\n\t\t<li>Deprecate constructor of DefaultMapper taking an alternative name for the class attribute. Use the\n\t\t\taliasAttribute method.</li>\n\t\t<li>Deprecate attributeForImplementationClass, attributeForClassDefiningField, attributeForReadResolveField, and\n\t\t\tattributeForEnumType in favour of the generalized aliasForAttribute in the Mapper interface.</li>\n\t\t<li>Removed all deprecated stuff from 1.1.x and 1.0.x</li>\n\t\t<li>JIRA:XSTR-211, A lot of existing (basic) Converters have been refactored to use the new SingleValueConverter\n\t\t\tinterface.</li>\n\t\t<li>Dom4JWriter uses now a DocumentFactory and a XMLWriter as constructor arguments.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.3\">Version 1.1.3</h1>\n\n\t<p>Released January 13, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Added XStream.toXML(OutputStream) and XStream.fromXML(InputStream).</li>\n\t\t<li>Ability to prevent fields from being serialized by calling XStream.omitField() or by implementing\n\t\t\tMapper.shouldSerializeMember().</li>\n\t\t<li>Added Converter for Enum, EnumMap and EnumSet</li>\n\t\t<li>JIRA:XSTR-186, Added BeanConverter (contributed by Andrea Aime)</li>\n\t\t<li>JIRA:XSTR-246, Added ISO8601SqlTimestampConverter (contributed by Cheong, Chung-Onn)</li>\n\t\t<li>Added ISO8601GregorianCaledarConverter</li>\n\t\t<li>JIRA:XSTR-215, Fixed support for IBM JVM (contributed by Gabor Liptak)</li>\n\t\t<li>Enhanced mode support for Blackdown JDK</li>\n\t\t<li>JIRA:XSTR-265, support for javax.security.auth.Subject</li>\n\t\t<li>JIRA:XSTR-233, support for Integer[] arrays</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Remove unnecessary PrintWriter wrapper in default writers (pointed out by Mathieu Champlon)</li>\n\t\t<li>Bugfix: EnumSet converter can now deal with empty sets (contributed by Baba Buehler)</li>\n\t\t<li>Update ISO8601DateConverter to use Joda 1.0</li>\n\t\t<li>JIRA:XSTR-242, GregorianCalenderConverter saves now the timezone</li>\n\t\t<li>JIRA:XSTR-247, ISO8601DateConverter now independent on timezone</li>\n\t\t<li>JIRA:XSTR-263, Circular references with Externalizable objects fail</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.2\">Version 1.1.2</h1>\n\n\t<p>Released April 30, 2005. Most popular feature requests implemented. Java 5 Enum support. Serialization of\n\t\tJavaBeans using accessors. Aliasing of fields. StAX integration, with namespaces. Improved support on JDK 1.3 and IBM\n\t\tJDK.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-186, Option to serialize JavaBeans using public accessors, rather than private fields (contributed\n\t\t\tby Andrea Aime).</li>\n\t\t<li>Ability to alias fields as well as classes, using XStream.addFieldAlias().</li>\n\t\t<li>JIRA:XSTR-70, JIRA:XSTR-204 Support for JDK 5 enums (contributed by Eric Snell and Bryan Coleman).</li>\n\t\t<li>JIRA:XSTR-206 Clean representation of JDK 5 EnumMap and EnumSet.</li>\n\t\t<li>XStream can now be built using JDK 1.3 (previously it required JDK 1.4 to compile, but 1.3 to run).</li>\n\t\t<li>JIRA:XSTR-215, Enhanced mode is now supported on the IBM 1.4 JDK.</li>\n\t\t<li>The default HierarchicalStreamWriter implementation is supplied by the HierarichicalStreamDriver (as well as\n\t\t\tthe reader).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-104 HierarchicalStreamReader now exposes all available attributes to the Converter implementations\n\t\t\t(contributed by Trygve Laugstol).</li>\n\t\t<li>Bugfix: Externalizable deserialization supported for objects not at the root of tree.</li>\n\t\t<li>JavaMethodConverter handles non public methods/constructors (contributed by Kevin Ring).</li>\n\t\t<li>PropertiesConverter also serializes default properties, if present (contributed by Kevin Ring).</li>\n\t\t<li>Bugfix: In some cases, XppReader and StaxReader would get confused when calling hasMoreChildren() and\n\t\t\tgetValue() on the same node.</li>\n\t\t<li>JIRA:XSTR-217, ISO8601DateConverter now requires joda-time-1.2.1</li>\n\t\t<li>PrettyPrintWriter and CompactWriter may have their text/attribute escaping rules customized by overriding\n\t\t\twriteText() and writeAttributeValue().</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>HierarchicalStreamDriver implementations now require a createWriter() method. The simplest implementation is\n\t\t\tto return a new PrettyPrintWriter.</li>\n\t\t<li>Introduced ReaderWrapper/WriterWrapper classes to make it easier to wrap (decorate)\n\t\t\tHierarchicalStreamReader/Writer instances.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.1\">Version 1.1.1</h1>\n\n\t<p>Released March 7, 2005. Mostly bugfixes and minor feature enhancements.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Converters can be registered with a priority, allowing more <i>generic</i> filters to handle classes that\n\t\t\tdon't have more specific converters.\n\t\t</li>\n\t\t<li>Converters can now access underlying HierarchicalStreamReader/Writer implementations to make implementation\n\t\t\tspecific calls.</li>\n\t\t<li>Improved support for classes using ObjectInputFields to follow the serialization specification.</li>\n\t\t<li>JIRA:XSTR-179 Support for ObjectInputStream.registerValidation(ObjectInputValidation).</li>\n\t\t<li>JIRA:XSTR-178 Serialized inner class now maintains reference to outer class.</li>\n\t\t<li>JIRA:XSTR-199 Default ClassLoader may be changed using XStream.setClassLoader().</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Bugfix: Thread context classloader is loaded by the correct thread. (Thanks to Padraic Renaghan for pointing\n\t\t\tthis out).</li>\n\t\t<li>Bugfix: Default implementations of aliased classes were not being deserialized by SerializableConverter.</li>\n\t\t<li>Bugfix: JIRA:XSTR-180 Serializable objects support defaultReadObject() even when no default fields available.</li>\n\t\t<li>Bugfix: For serialized objects class hierarchy is serialized starting with superclass (as per Java Object\n\t\t\tSerialization).</li>\n\t\t<li>Bugfix: readObject() is now called for classes containing only transient fields.</li>\n\t\t<li>Bugfix: Order of fields are maintained when calling ObjectOutputStream.putFields().</li>\n\t\t<li>Bugfix: FontConverter extended to support FontUIResource which does some awkward native calls.</li>\n\t\t<li>Bugfix: Deserialization of very complicated graphs (such as Swing components) sometimes resulted in broken\n\t\t\tobject references. Now fixed.</li>\n\t\t<li>Bugfix: JIRA:XSTR-188 Classes that use readResolve()/writeReplace() can now return different types.</li>\n\t\t<li>Bugfix: JIRA:XSTR-185, JIRA:XSTR-195 Support for loading of array classes for classes that have not yet been\n\t\t\tloaded. (Thanks to Henri Tremblay and Simon Daniel)</li>\n\t\t<li>Bugfix: JIRA:XSTR-190 PrettyPrintWriter and CompactWriter escape characters in XML attributes.</li>\n\t\t<li>Bugfix: JIRA:XSTR-176, JIRA:XSTR-196 The XStream ObjectInputStream and ObjectOutputStream implementations now\n\t\t\tpropegate the flush() and close() events to the underlying streams.</li>\n\t\t<li>Bugfix: JIRA:XSTR-192 Implicit collection mappings are now supported in inheritance hierarchies.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>ClassMapper is now deprecated. Replaced with MapperWrapper.</li>\n\t\t<li>HierarchicalStreamWriter implementations must now implement close(), flush() and underlyingWriter().</li>\n\t\t<li>HierarchicalStreamReader implementations must now implement close() and underlyingReader().</li>\n\t</ul>\n\n\t<h1 id=\"1.1\">Version 1.1</h1>\n\n\t<p>\n\t\tReleased January 15, 2005. Focus on support for objects defining custom serialization using the standard <a\n\t\t\thref=\"http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/serialTOC.html\">Java serialization</a> mechanism.\n\t</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Provides drop in replacement for ObjectInputStream and ObjectOutputStream, using\n\t\t\tXStream.createObjectInputStream() and XStream.createObjectOutputStream() and XStream.createObjectInputStream(). This\n\t\t\tprovides support for streaming objects.</li>\n\t\t<li>Support for objects that specify their own serialization schemes by implementing readObject() and\n\t\t\twriteObject() (as in Java serialization spec). This includes support for ObjectInputStream.getFields() and\n\t\t\tObjectOuputStream.putFields().</li>\n\t\t<li>Support for objects to serialize other objects to the stream by implementing writeReplace() (as in Java\n\t\t\tserialization spec).</li>\n\t\t<li>Support for any object that performs custom serialization by implementing java.io.Externalizable (as in Java\n\t\t\tserialization spec).</li>\n\t\t<li>Implicit collections can be specified for classes, allowing the element wrapping the collection to be\n\t\t\tskipped.</li>\n\t\t<li>New writer implementations to allow XStream to serialize directly to a SAX stream or TrAX pipeline.</li>\n\t\t<li>The MarshallingContext and UnmarshallingContext interfaces now extend DataHolder, allowing arbitrary data to\n\t\t\tbe stored by the user whilst walking the object graph and passed around to Converters. DataHolders can also be passed\n\t\t\tinto XStream from the outside.</li>\n\t\t<li>Includes new DomWriter implementation to serialize directly to a W3C DOM tree (to complement the existing\n\t\t\tDomReader).</li>\n\t\t<li>Better support for instantiating objects on non Sun 1.4+ JVMs, including non-public constructors, private\n\t\t\tstatic inner classes and ANY class that implements java.io.Serializable.</li>\n\t\t<li>DOM, DOM4J, JDOM, XOM, Electric-XML, SAX, STAX</li>\n\t\t<li>Specific ClassLoaders can be passed into XStream, to allow for greater compatibility in J2EE containers.</li>\n\t\t<li>Ability to change the default converter</li>\n\t\t<li>Added optional ISO8601DateConverter for full ISO8601 date format support. The converter is not registered by\n\t\t\tdefault as it requires the joda-time dependency (http://joda-time.sf.net). To use, ensure joda-time is in classpath\n\t\t\tand register explicitly.</li>\n\t\t<li>Enhanced mode is now supported on the Apple 1.4 JDK.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>PrettyPrintWriter only flushes stream when necessary - large performance improvement for serialization.</li>\n\t\t<li>Added XStream.fromXml(xml, root) convenience methods for deserializing into an existing root object.</li>\n\t\t<li>JDK 1.3 compatibility: Added mechanism for accessing nested exception.</li>\n\t\t<li>JDK 1.3 compatibility: GregorianCalendarConverter only calls Calendar.getTimeInMillis() the JDK supports it.</li>\n\t\t<li>Bugfix: All caches are now synchronized - there were some thread safety issues.</li>\n\t\t<li>Bugfix: Only <i>immutable</i> basic types will have references ignored in XML (for clarity).\n\t\t</li>\n\t\t<li>Bugfix: Class names can contain underscores.</li>\n\t\t<li>Bugfix: Support for '\\0' char.</li>\n\t\t<li>Bugfix: PropertyConverter no longer attempts to serialize subclasses of Properties.</li>\n\t\t<li>Bugfix: JVM detection uses system properties, which is more accurate than searching the classpath.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>XStream.addDefaultCollection() has been deprecated. Use XStream.addImplicitCollection() instead.</li>\n\t</ul>\n\n\t<h1 id=\"1.0.2\">Version 1.0.2</h1>\n\n\t<p>Released August 7, 2004. Focus on improving the converters bundled with XStream to support a wider range of\n\t\ttypes.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>XML elements are written in order they are defined in class, rather than alphabetical.</li>\n\t\t<li>Converters for java.io.File, java.sql.Timestamp, java.awt.Color, and dynamic proxies are now registered by\n\t\t\tdefault.</li>\n\t\t<li>EncodedByteArrayConverter is now registered by default and uses a single Base64 string to store the contents\n\t\t\tof a byte[]. This now works on all JVMs as it no longer relies on Sun specific classes. This converter will also\n\t\t\tunmarshal byte[] that have been serialized without it, for backwards compatability.</li>\n\t\t<li>New converters for java.sql.Time, java.sql.Date, java.util.Locale, java.util.Currency, java.util.Calendar and\n\t\t\tjava.awt.Font.</li>\n\t\t<li>All caching is done in XStream instance instead of statics, allowing applications that use hot redeployment\n\t\t\tof classes to use XStream in a parent classloader.</li>\n\t\t<li>XStream will fail fast if a field value is defined more than once in XML when deserializing.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>The &lt;entry&gt; element used in Maps can now be specified by creating an alias for java.util.Map.Entry.</li>\n\t\t<li>Bugfix: Fields with characters that generate invalid XML (such as $ signs) are now escaped.</li>\n\t\t<li>Bugfix: Pre-instantiated objects can be unmarshalled through multiple levels.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"1.0.1\">Version 1.0.1</h1>\n\n\t<p>Released May 30, 2004. Misc features and bugfixes.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support for multidimensional arrays.</li>\n\t\t<li>Object with readResolve() method will be treated the same way native serialization treats them.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>New converters for Throwable and StackTraceElement that retain stack trace (JDK 1.4 only)</li>\n\t\t<li>Bugfix: System.identityHashCode() is not guaranteed to be unique. Ensure reference checking is used as well.</li>\n\t\t<li>Bugfix: Allows user classes to be defined in WEB-INF/classes in Servlet environments. Tries to use context\n\t\t\tclassloader if available.</li>\n\t\t<li>Support for java.util.Currency (through readResolve()).</li>\n\t\t<li>Instances of Jakarta Commons Lang Enum are now reused (through readResolve()).</li>\n\t\t<li>Bugfix: JavaClassConverter handles primitive type classes (contributed by Matthew Sandoz).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Additional method: ConverterLookup.defaultConverter(). Custom implementations of this class should implement\n\t\t\tthis new method.</li>\n\t</ul>\n\n\t<h1 id=\"1.0\">Version 1.0</h1>\n\n\t<p>Released May 14, 2004. Focusses on finalizing the API for 1.0 release.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Supports fields of same name, hidden by inheritance.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JavaDoc for most important parts of API.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>The ReflectionConverter and ReflectionProviders have had an overhaul to support hidden fields. Most methods\n\t\t\tnow take an extra argument to specify which class a field is declared in.</li>\n\t</ul>\n\n\t<h1 id=\"1.0RC1\">Version 1.0 (release candidate 1)</h1>\n\n\t<p>Released May 9, 2004. Focusses on finalizing the API for 1.0 release.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JDK 1.3 compatibility.</li>\n\t\t<li>Informative error messages.</li>\n\t\t<li>Defaults to using faster XPP based parser.</li>\n\t\t<li>Serializes final field under JDK 1.4.</li>\n\t\t<li>Fail fast when trying to serialize final field if not Sun 1.4 JRE.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Misc performance improvements.</li>\n\t\t<li>Converters for TreeMap and TreeSet that store the Comparator.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Default constructor for XStream class uses XppDriver instead of DomDriver. To use DomDriver, explicitly pass\n\t\t\tit in to the constructor.</li>\n\t\t<li>Exception is thrown if trying to serialize an object that contains a final field if not Sun 1.4 JRE.</li>\n\t</ul>\n\n\t<p>\n\t\t<a href=\"versioning.html\">About XStream version numbers...</a>\n\t</p>\n\n\t<h1 id=\"0.6\">Version 0.6</h1>\n\n\t<p>Released May 7, 2004. Focusses on providing full object graph support.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Bugfix: Objects that had no children could not be derefenced properly (thanks to Brian Slesinsky and Nick\n\t\t\tPomfret).</li>\n\t\t<li>Bugfix: DateConverter is now thread safe.</li>\n\t\t<li>Optimization: String instances are reused as much as possible.</li>\n\t\t<li>Converters for BigInteger and BigDecimal.</li>\n\t\t<li>IntConverter now recognises hexadecimal and octal notations (thanks to Konstantin Pribluda).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"0.6RC1\">Version 0.6 (release candidate 1)</h1>\n\n\t<p>Released April 19, 2004. Focusses on providing full object graph support.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Full support for object graphs, including duplicate references of same object and circular references.</li>\n\t\t<li>References can be identified using XPath (default), unique-IDs or disabled.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Release includes Ant build file.</li>\n\t\t<li>Converters for non standard collections such as Collections.EMPTY_LIST, syncronizedList(), unmodifiableMap(),\n\t\t\tetc.</li>\n\t\t<li>Converter for nulls.</li>\n\t\t<li>Converter for dynamic proxies.</li>\n\t\t<li>Converter for java.net.URL.</li>\n\t\t<li>Converters for java.util.LinkedHashMap and java.util.LinkedHashSet.</li>\n\t\t<li>Converters for java.lang.reflect.Method and java.lang.reflect.Constructor.</li>\n\t\t<li>If duplicate reference support is disabled and a circular reference is encountered, an exception will be\n\t\t\tthrown.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"0.5\">Version 0.5</h1>\n\n\t<p>Released March 8, 2004. Focussed on performance.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Massive performance improvements. Up to 3 times faster for serialization and 22 times faster for\n\t\t\tdeserialization!</li>\n\t\t<li>Non-DOM building pull parser based reader. Results in much smaller memory footprint, particularly when\n\t\t\tdeserializing large object models.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Misc performance improvements.</li>\n\t\t<li>Misc bugfixes.</li>\n\t\t<li>Alternate encodings can be used with DomDriver.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Renamed XMLReader/Writer to HierarchicalStreamReader/Writer as XStream is not actually coupled to serializing\n\t\t\tjust to XML.</li>\n\t\t<li>Cleaned up the public API.</li>\n\t\t<li>Moved internal XStream implementation classes to core package.</li>\n\t\t<li>Misc package/class renames to make more sense. Dumped lots of dead code.</li>\n\t</ul>\n\n\t<h1 id=\"0.4\">Version 0.4</h1>\n\n\t<p>This version was never publicly released. All changes were made available in 0.5. Focussed on making it easier\n\t\tto create custom converters.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Overhaul of interface for Converters. Makes Converters much cleaner to write.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added custom converters for java.io.File, java.util.Properties, java.util.Vector, java.util.Hashtable,\n\t\t\tjava.util.BitSet byte[] (Base64 encoded), char[].</li>\n\t\t<li>Misc bugfixes.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>New interface to be implemented by custom converters.</li>\n\t</ul>\n\n\t<h1 id=\"0.3\">Version 0.3</h1>\n\n\t<p>Released January 1, 2004.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Added ElementMapper interface and default implementations to allow fine grained control over element name to\n\t\t\tclass mapper operations.</li>\n\t\t<li>Added an XPP based reader and writer that uses a pull-parser to create a lightweight DOM tree.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added XStream.fromXML(XMLReader xmlReader,Object root) method to allow the population of an object graph\n\t\t\tstarting with a live object root.</li>\n\t\t<li>Added XMLReader.peek() method to allow access to the underlying hierarchical object being unmarshalled.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Aligned the the methods in XStream to use the specified ObjectFactory in the constructor instead of creating\n\t\t\ta SunReflectionObjectFactory.</li>\n\t</ul>\n\n\t<h1 id=\"older\">Older versions</h1>\n\n\t<p>Changes in XStream prior to version 0.3 were not logged.</p>\n\n</body>\n</html>\n", "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2020 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Aliasing classes</h3>\n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code> method. For example, you\n * can shorten all occurrences of element <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by\n * registering an alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Converters</h3>\n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each of which acts as a\n * strategy for converting a particular type of class to XML and back again. Out of the box, XStream contains converters\n * for most basic types (String, Date, int, boolean, etc) and collections (Map, List, Set, Properties, etc). For other\n * objects reflection is used to serialize each field recursively.\n * </p>\n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some non-standard converters\n * are supplied in the {@link com.thoughtworks.xstream.converters.extended} package and you can create your own by\n * implementing the {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with\n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence they have been registered.\n * The default converter, i.e. the converter which will be used if no other registered converter is suitable, can be\n * registered with priority XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback converter.\n * </p>\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Object graphs</h3>\n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact, including circular\n * references.\n * </p>\n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML with the least\n * clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that a single node\n * only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references. The XPath expression ensures that a single node\n * only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using hand-written XML, this\n * is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate references are treated\n * as two separate objects and circular references cause an exception. This is slightly faster and uses less memory than\n * the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and configured, it may be\n * shared across multiple threads allowing objects to be serialized/deserialized concurrently. <em>Note, that this only\n * applies if annotations are not auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one of the\n * <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean securityInitialized;\n    private transient boolean securityWarningGiven;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n    private static final Pattern LAZY_ITERATORS = Pattern.compile(\".*\\\\$LazyIterator\");\n    private static final Pattern JAVAX_CRYPTO = Pattern.compile(\"javax\\\\.crypto\\\\..*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best match for the\n     * {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and a prepared\n     * {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and a\n     * {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and the\n     * {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain and the {@link ClassLoader} to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader,\n            Mapper mapper) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain and the {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n\n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain, the {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader,\n            Mapper mapper, ConverterLookup converterLookup, ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup,\n            converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain, the {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup should access the\n     * ConverterRegistry if you intent to register {@link Converter} instances with XStream facade or you are using\n     * annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em> to prevent any further\n     *            registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n            ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class, ClassLoaderReference.class,\n                ReflectionProvider.class}, new Object[]{\n                    mapper, converterRegistry, converterLookup, classLoaderReference, reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n            Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate mapper : \" + className,\n                e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate mapper : \" + className,\n                e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper.lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper.lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper.lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper.lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper.lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper.lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper.lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper.lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n\n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\"java.beans.EventHandler\"});\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (!xstream.securityInitialized) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n\n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n\n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class}, new Object[]{converterLookup});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority, Class[] constructorParamTypes,\n            Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className,\n                e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className,\n                e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[]{String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n\n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed afterwards and in case\n     * of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream will be flushed afterwards\n     * and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you want. If not present,\n     *            XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL. Depending on the parser implementation, some might take the file path as\n     * SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file. Depending on the parser implementation, some might take the file path as\n     * SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object instead of instantiating\n     * a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into\n     * the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object instead of instantiating\n     * a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into\n     * the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root object instead of instantiating a new\n     * one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care! Depending on the parser implementation, some might take the\n     * file path as SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root object instead of instantiating a new\n     * one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care! Depending on the parser implementation, some might take the\n     * file path as SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root object instead of\n     * instantiating a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write\n     * directly into the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With the ReflectionConverter\n     * XStream will write directly into the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed to XStream creating a new\n     *            instance. Note, that this is a special use case! With the ReflectionConverter XStream will write\n     *            directly into the raw memory area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you want. If not present,\n     *            XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (!securityInitialized && !securityWarningGiven) {\n                securityWarningGiven = true;\n                System.err\n                    .println(\n                        \"Security framework of XStream not explicitly initialized, using predefined black list on your own risk.\");\n            }\n            return marshallingStrategy.unmarshal(root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable to this type will be\n     * aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no {@link ClassAliasingMapper} is\n     *             available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no {@link PackageAliasingMapper} is\n     *             available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its alias is set to\n     * <code>null</code>. However, this is not reversible, i.e. deserialization of the result is likely to fail\n     * afterwards and will not produce an object equal to the originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters an instance of this\n     * type, it will use the default implementation instead. For example, java.util.ArrayList is the default\n     * implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, SingleValueConverter converter) {\n        registerLocalConverter(definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are <code>XPATH_ABSOLUTE_REFERENCES</code>,\n     * <code>XPATH_RELATIVE_REFERENCES</code>, <code>XStream.ID_REFERENCES</code> and\n     * <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(ReferenceByXPathMarshallingStrategy.RELATIVE\n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(ReferenceByXPathMarshallingStrategy.ABSOLUTE\n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName, Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the array type does not\n     *             match the itemType\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete map type or matching the\n     *            default implementation type of the map type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4\n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete map type or matching the\n     *            default implementation type of the map type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4\n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, Class itemType,\n            String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer) throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single root node, the stream must\n     * be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder)\n            throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, null, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority) throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will register for all kind\n     * of classes and types of the current JDK, but not for any 3rd party type. To ensure that all other types are\n     * loaded with your class loader, you should call this method as early as possible - or consider to provide the\n     * class loader directly in the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n\n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other XStream components (like\n     * converters) to ensure that they will use a changed ClassLoader instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the declaring type and not\n     * necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n\n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \" + ANNOTATION_MAPPER_TYPE + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this method will automatically\n     * turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies that the XStream is\n     * configured while it is processing the XML steams. This is a potential concurrency problem. Also is it technically\n     * not possible to detect all class aliases at deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n\n    /**\n     * Add a new security permission.\n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            securityInitialized |= permission.equals(NoTypePermission.NONE) || permission.equals(AnyTypePermission.ANY);\n            securityMapper.addPermission(permission);\n        }\n    }\n\n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n\n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n\n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like\n     * 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and\n     * subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n\n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n\n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n\n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n\n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like\n     * 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and\n     * subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    private Object readResolve() {\n        securityWarningGiven = true;\n        return this;\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException} instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)} instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n}\n", "/*\n * Copyright (C) 2013, 2014, 2017, 2018, 2020 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n * \n * Created on 23. December 2013 by Joerg Schaible\n */\npackage com.thoughtworks.acceptance;\n\nimport java.beans.EventHandler;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.XStreamException;\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ForbiddenClassException;\nimport com.thoughtworks.xstream.security.NoTypePermission;\n\n\n/**\n * @author J&ouml;rg Schaible\n */\npublic class SecurityVulnerabilityTest extends AbstractAcceptanceTest {\n\n    private final static StringBuffer BUFFER = new StringBuffer();\n\n    protected void setUp() throws Exception {\n        super.setUp();\n        BUFFER.setLength(0);\n        xstream.alias(\"runnable\", Runnable.class);\n    }\n\n    protected void setupSecurity(XStream xstream) {\n    }\n\n    public void testCannotInjectEventHandler() {\n        final String xml = \"\"\n                + \"<string class='runnable-array'>\\n\"\n                + \"  <dynamic-proxy>\\n\"\n                + \"    <interface>java.lang.Runnable</interface>\\n\"\n                + \"    <handler class='java.beans.EventHandler'>\\n\"\n                + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n                + \"      <action>exec</action>\\n\"\n                + \"    </handler>\\n\"\n                + \"  </dynamic-proxy>\\n\"\n                + \"</string>\";\n\n        try {\n            xstream.fromXML(xml);\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            assertTrue(e.getMessage().indexOf(EventHandler.class.getName()) > 0);\n        }\n        assertEquals(0, BUFFER.length());\n    }\n\n    public void testCannotInjectEventHandlerWithUnconfiguredSecurityFramework() {\n        xstream.alias(\"runnable\", Runnable.class);\n        final String xml = \"\"\n            + \"<string class='runnable-array'>\\n\"\n            + \"  <dynamic-proxy>\\n\"\n            + \"    <interface>java.lang.Runnable</interface>\\n\"\n            + \"    <handler class='java.beans.EventHandler'>\\n\"\n            + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n            + \"      <action>exec</action>\\n\"\n            + \"    </handler>\\n\"\n            + \"  </dynamic-proxy>\\n\"\n            + \"</string>\";\n\n        try {\n            xstream.fromXML(xml);\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            assertTrue(e.getMessage().indexOf(EventHandler.class.getName())>=0);\n        }\n        assertEquals(0, BUFFER.length());\n    }\n\n    public void testExplicitlyConvertEventHandler() {\n        final String xml = \"\"\n                + \"<string class='runnable-array'>\\n\"\n                + \"  <dynamic-proxy>\\n\"\n                + \"    <interface>java.lang.Runnable</interface>\\n\"\n                + \"    <handler class='java.beans.EventHandler'>\\n\"\n                + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n                + \"      <action>exec</action>\\n\"\n                + \"    </handler>\\n\"\n                + \"  </dynamic-proxy>\\n\"\n                + \"</string>\";\n\n        xstream.allowTypes(new Class[]{EventHandler.class});\n        xstream.registerConverter(new ReflectionConverter(xstream.getMapper(), xstream\n            .getReflectionProvider(), EventHandler.class));\n\n        final Runnable[] array = (Runnable[])xstream.fromXML(xml);\n        assertEquals(0, BUFFER.length());\n        array[0].run();\n        assertEquals(\"Executed!\", BUFFER.toString());\n    }\n\n    public static class Exec {\n\n        public void exec() {\n            BUFFER.append(\"Executed!\");\n        }\n    }\n\n    public void testInstanceOfVoid() {\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ConversionException.class.getName() + \" expected\");\n        } catch (final ConversionException e) {\n            assertEquals(\"void\", e.get(\"construction-type\"));\n        }\n    }\n\n    public void testDeniedInstanceOfVoid() {\n        xstream.addPermission(AnyTypePermission.ANY); // clear out defaults\n        xstream.denyTypes(new Class[] { void.class, Void.class });\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ForbiddenClassException.class.getName() + \" expected\");\n        } catch (final ForbiddenClassException e) {\n            // OK\n        }\n    }\n\n    public void testAllowedInstanceOfVoid() {\n        xstream.allowTypes(new Class[] { void.class, Void.class });\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ConversionException.class.getName() + \" expected\");\n        } catch (final ConversionException e) {\n            assertEquals(\"void\", e.get(\"construction-type\"));\n        }\n    }\n    \n    public static class LazyIterator {\n    }\n\n    public void testInstanceOfLazyIterator() {\n        xstream.alias(\"lazy-iterator\", LazyIterator.class);\n        try {\n            xstream.fromXML(\"<lazy-iterator/>\");\n            fail(\"Thrown \" + ForbiddenClassException.class.getName() + \" expected\");\n        } catch (final ForbiddenClassException e) {\n            // OK\n        }\n    }\n}\n"], "fixing_code": ["<html>\n<!--\n Copyright (C) 2005, 2006 Joe Walnes.\n Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 XStream committers.\n All rights reserved.\n \n The software in this package is published under the terms of the BSD\n style license a copy of which has been included with this distribution in\n the LICENSE.txt file.\n \n Created on 29. January 2005 by Joe Walnes\n -->\n<head>\n<title>Change History</title>\n</head>\n<body>\n\n\t<p>Changes are split into three categories:</p>\n\n\t<ul>\n\t\t<li><b>Major changes</b>: The major new features that all users should know about.</li>\n\t\t<li><b>Minor changes</b>: Any smaller changes, including bugfixes.</li>\n\t\t<li><b>API changes</b>: Any changes to the API that could impact existing users.</li>\n\t</ul>\n\n\t<p>\n\t\tFull details can be found in GitHub's <a href=\"https://github.com/x-stream/xstream/issues?q=is%3Aissue+is%3Aclosed\">Issues</a>,\n\t\tfilter for the appropriate milestone.\n\t</p>\n\n\t<h1 id=\"upcoming-1.4.x\">Upcoming 1.4.x maintenance release</h1>\n\n\t<p>Not yet released.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses the security vulnerability CVE-2017-9805 reported\n\toriginally for Struts' XStream Plugin, an arbitrary execution of commands when unmarshalling for XStream instances\n\twith uninitialized security framework.</p>\n\n\t<h1 id=\"1.4.13\">1.4.13</h1>\n\n\t<p>Released September 6, 2020.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHPR:#218: Defer reflective access to Java core modules.</li>\n\t\t<li>GHI:#207: New predefined blacklist avoids vulnerability due to improper setup of the security framework.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.12\">1.4.12</h1>\n\n\t<p>Released April 12, 2020.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>XmlFriendlyNameCoder supports now XML parsers implementing only 4th edition of XML 1.0 specification.</li>\n\t\t<li>Fix support of CDATA events in StAX.</li>\n\t\t<li>GHI:#171: XStream.createObjectInputStream does not pass the DataHolder.</li>\n\t\t<li>GHI:#151: Use of SPDX license identifier in POM and Manifest.</li>\n\t\t<li>GHI:#152: Declare OSGi import of internal runtime packages as optional.</li>\n\t\t<li>Drop Require-Capability entry in manifest.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.11.1\">1.4.11.1</h1>\n\n\t<p>Released October 27, 2018.</p>\n\n\t<h2>Hot fix</h2>\n\n\t<ul>\n\t\t<li>GHI:#133: XStream 1.4.11 fails to run on a Java Runtime &lt; 8.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.11\">1.4.11</h1>\n\n\t<p>Released October 23, 2018.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses again the security vulnerability <a href=\"CVE-2013-7285.html\">\n\t    CVE-2013-7285</a>, an arbitrary execution of commands when unmarshalling for XStream instances with\n\t    uninitialized security framework. Only 1.4.10 uninitialized security framework was affected.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHPR:#91, GHPR:#106: Clean-up data stacks in UnmarshallingContext implementations in case of exception (by\n\t\tM&auml;rt Bakhoff).</li>\n\t\t<li>GHI:#2: Unneeded contention in DefaultConverterLookup.</li>\n\t\t<li>GHI:#94: Fix PathConverter containing absolute Windows paths.</li>\n\t\t<li>GHI:#105: XStream's ObjectInputStream returns wrong values for readUnsignedByte and readUnsignedShort.</li>\n\t\t<li>JIRA:XSTR-616 and GHPR:#93: Introduce StringCodec interface to support arbitrary Base64 codec\n\t\timplementations for EncodedByteArrayConverter. Prefer Base64 codec implementations of the Java runtime over\n\t\tXStream's own one.</li>\n\t\t<li>GHI:#97: Support to run out of the box in a Java 1.4 runtime is established again.</li>\n\t\t<li>Provide methods in AbstractCollectionConverter that read and write in a balanced way from and to the\n\t\thierarchical stream.</li>\n\t\t<li>New future-proof method JVM.isVersion to detect major version of Java runtime (incl. Java 10) as\n\t\treplacement for individual JVM.isXY methods.</li>\n\t\t<li>GHI:#115: Dom4JDriver ignores character set of Dom4J configuration creating a Writer.</li>\n\t\t<li>GHI:#116: Make converters null safe.</li>\n\t\t<li>GHI:#123 and GHPR:#124: Declare XPP dependencies for OSGi as optional.</li>\n\t\t<li>Add XppDriver.createDefaultParser for a simpler access to the default XmlPullParserFactory.</li>\n\t\t<li>Old BEA reference implementation of StAX is outdated, unmaintained and has security issues, therefore\n\t\tXStream's driver has been deprecated.</li>\n\t\t<li>Support for JaCoCo: FieldDictionary ignores synthetic fields starting with <em>$jacoco</em> as name.</li>\n\t\t<li>Add integration test for OSGi (by Wes Wannemacher).</li>\n\t</ul>\n\n\t<h2>Stream compatibility</h2>\n\n\t<ul>\n\t\t<li>The EncodedByteArrayConverter will now use an encoder by default that does no longer add line breaks as\n\t\tnormally required by the RFC 1521 after 76 characters, making it also easier to use the converter for\n\t\tattributes. This will not affect XStream's Base64 decoder.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.readBareItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.readCompleteItem(HierarchicalStreamReader, UnarshallingContext, Object).</li>\n\t\t<li>Deprecated c.t.x.converters.collection.AbstractCollectionConverter.readItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeBareItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeCompleteItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Deprecated c.t.x.converters.collection.AbstractCollectionConverter.writeItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.collection.AbstractCollectionConverter.writeNullItem(MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.converters.extended.EncodedByteArrayConverter(StingCodec).</li>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter.readBareItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Deprecated c.t.x.converters.extended.NamedCollectionConverter.readItem(HierarchicalStreamReader, UnmarshallingContext, Object).</li>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter.writeCompleteItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Deprecated c.t.x.converters.extended.NamedCollectionConverter.writeItem(Object, MarshallingContext, HierarchicalStreamWriter).</li>\n\t\t<li>Added c.t.x.core.DefaultConverterLookup(Map).</li>\n\t\t<li>Added c.t.x.core.util.JVM.getBase64Codec().</li>\n\t\t<li>Added c.t.x.core.util.JVM.isVersion().</li>\n\t\t<li>Deprecated c.t.x.core.util.JVM.is18().</li>\n\t\t<li>Deprecated c.t.x.core.util.JVM.is9().</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamReader.</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamWriter.</li>\n\t\t<li>Deprecated c.t.x.io.ExtendedHierarchicalStreamWriterHelper.</li>\n\t\t<li>Deprecated c.t.x.io.xml.BEAStaxDriver.</li>\n\t\t<li>Added c.t.x.io.xml.Dom4JReader.Dom4JReader(Branch).</li>\n\t\t<li>Added c.t.x.io.xml.XppDriver.createDefaultParser().</li>\n\t\t<li>Added c.t.x.core.util.StingCodec.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.10\">1.4.10</h1>\n\n\t<p>Released May 23, 2017.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses also the security vulnerability <a href=\"CVE-2017-7957.html\">\n\t    CVE-2017-7957</a>, used for a Denial of Service attack by crashing the Java runtime.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#84: New XStream artifact with <em>-java7</em> appended as version suffix for a library explicitly\n\t\twithout the Java 8 stuff (lambda expression support, converters for java.time.* package).</li>\n\t\t<li>Fix PrimitiveTypePermission to reject type <em>void</em> to prevent CVE-2017-7957 with an initialized\n\t\tsecurity framework.</li>\n\t\t<li>Improve performance by minimizing call stack of mapper chain.</li>\n\t\t<li>GHPR:#82, JIRA:XSTR-774: Add converters for types of java.time, java.time.chrono, and java.time.temporal\n\t\t\tpackages (converters for LocalDate, LocalDateTime, LocalTime, OffsetDateTime, and ZonedDateTime by Matej Cimbora).</li>\n\t\t<li>GHI:#29: JavaBeanConverter does not respect ignored unknown elements.</li>\n\t\t<li>Add XStream.setupDefaultSecurity to initialize security framework with defaults of XStream 1.5.x.</li>\n\t\t<li>Emit error warning if security framework has not been initialized and the XStream instance is vulnerable to\n\t\tknown exploits.</li>\n\t</ul>\n\n\t<h2>Stream Compatibility</h2>\n\n\t<ul>\n\t\t<li>The alias <em>duration</em> for type <em>javax.xml.datatype.Duration</em> has changed to <em>xml-duration</em>\n\t\t\tdue to the support of the classes in the java.time package. <em>duration</em> is now used for type <em>java.time.Duration</em>.\n\t\t\tSimply register the alias <em>duration</em> again for type <em>javax.xml.datatype.Duration</em> if backward\n\t\t\tcompatibility is required for this type.\n\t\t</li>\n\t\t<li>All types of the java.time packages that have been written with previous versions of XStream can still be\n\t\t\tdeserialized.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#54: Fix BeanProvider.canInstantiate(Class), method may not throw exception.</li>\n\t\t<li>GHI:#76 and GHPR:#77: Missing support for cascaded writeReplace calls.</li>\n\t\t<li>GHI:#61: Regression in 1.4.9: Performance drop in ImplicitCollectionMapper.</li>\n\t\t<li>GHI:#52: PathConverter fails for file paths with spaces.</li>\n\t\t<li>PathConverter uses always forward slashes as path separator.</li>\n\t\t<li>GHI:#53: SqlTimestampConverter cannot parse values without fraction.</li>\n\t\t<li>GHI:#45: Support different time zones for SqlTimestampConverter.</li>\n\t\t<li>GHI:#67 and GHPR:#68: Allow usage of DataHolder for createObjectInputStream and createObjectOutputStream.</li>\n\t\t<li>GHI:#75: Use java.time.* package instead of Joda-Time.</li>\n\t\t<li>Dom4JXmlWriter does not flush writer at endDocument().</li>\n\t\t<li>Path is an immutable type.</li>\n\t\t<li>GHPR:#65: Protect converter lookup against runtime errors.</li>\n\t\t<li>Current Java 9 implementation reports itself as version 9 now.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.util.JVM.is9().</li>\n\t\t<li>Added c.t.x.XStream.setupDefaultSecurity(XStream).</li>\n\t\t<li>Added c.t.x.XStream.createObjectInputStream(HierarchicalStreamReader, DataHolder) and\n\t\t\tc.t.x.XStream.createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder).</li>\n\t\t<li>Added c.t.x.converters.javabean.PropertyDictionary.propertyDescriptorOrNull(Class, String).</li>\n\t\t<li>Added method c.t.x.mapper.Mapper.IsIgnoredElement(String)</li>\n\t\t<li>Added c.t.x.mapper.ElementIgnoringMapper.</li>\n\t\t<li>Deprecated method c.t.x.mapper.FieldAliasingMapper.addFieldsToIgnore(Pattern).</li>\n\t\t<li>Deprecated method c.t.x.mapper.FieldAliasingMapper.omitField(Class, String).</li>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is17().</li>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is19().</li>\n\t</ul>\n\n\t<h1 id=\"1.4.9\">1.4.9</h1>\n\n\t<p>Released March 15, 2016.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses also the security vulnerability <a href=\"CVE-2016-3674.html\">\n\t    CVE-2016-3674</a>, known as XXE vulnerability that can be used to expose arbitrary data from the file system\n\t    when unmarshalling.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#25: Fix <a href=\"https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\">XXE\n\t\t\t\tvulnerability (CVE-2016-3674)</a>: Fixed affected drivers were Dom4JDriver, DomDriver, JDomDriver, JDom2Driver,\n\t\t\tSjsxpDriver, StandardStaxDriver and WstxDriver. Still vulnerable are BEAStaxDriver and XomDriver. Processing of\n\t\t\t(external) entities has been disabled. See <a href=\"faq.html#Security_XXEVulnerability\">FAQ</a> for more information.\n\t\t</li>\n\t\t<li>Benchmark module has been deprecated in favor of <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">\n\t\t\t\tJMH (Java Microbenchmarking Harness)</a>.\n\t\t</li>\n\t\t<li>GHI:#33 and GHPR:#38: Add converter for java.nio.file.Path (by Aaron Jonson).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>GHI:#35: AnnotationMapper dropped silently constructor arguments for converters if they were equal.</li>\n\t\t<li>Fix: Possible concurrency problem with XomDriver.</li>\n\t\t<li>JIRA:XSTR-773, GHPR:#3: Minimize memory footprint by not keeping internal references to instances of\n\t\t\timmutable types.</li>\n\t\t<li>Drop automatic reference support at deserialization time for immutable types before version 1.4 (primitive\n\t\t\ttypes and their boxed counterpart, java.lang.Class, java.lang.String, java.math.BigDecimal, java.math.BigInteger,\n\t\t\tjava.io.File, java.net.URL, and java.awt.font.TextAttribute).</li>\n\t\t<li>Fix: Implicit collection declaration is erroneously inherited or propagated to hidden field of same name.</li>\n\t\t<li>XStreamConverter annotation supports null values as arguments for converter instantiation.</li>\n\t\t<li>GHI:#5: Support null values for JavaBean properties.</li>\n\t\t<li>GHI:#36: Fix NamedMapConverter, does not use SingleValueConverter of value if value is text of entry element.</li>\n\t\t<li>GHI:#13: Own converter for javax.activation.ActivationDataFlavor, because ExternalizableConverter cannot\n\t\t\thandle a type that violates the Java specification.</li>\n\t\t<li>GHPR:#18: Minimize synchronized block in FieldDictionary.</li>\n\t\t<li>JIRA:XSTR-769: Synthetic fields with references to outer class use compiler dependent names.</li>\n\t\t<li>JIRA:XSTR-771: UUID is an immutable type by default.</li>\n\t\t<li>GHPR:#23: Constructor of AbstractXppDriver swallows causing exception.</li>\n\t\t<li>GHI:#28: Fix functionality of ClassAliaslingMapper.itemTypeAsAttributes(Class).</li>\n\t\t<li>GHI:#37: Historical Java 1.3 support suppresses causing exception of a thrown InvocationTargetException.</li>\n\t\t<li>GHI:#41: Cannot instantiate ToAttributedValueConverter with null value for valueFieldName using\n\t\t\tXStreamConverter annotation.</li>\n\t\t<li>Fix example code in description of security framework.</li>\n\t\t<li>Clean-up usage of exceptions.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.XStream.addImmutableType(Class, boolean) and deprecated c.t.x.XStream.addImmutableType(Class).</li>\n\t\t<li>Added c.t.x.mapper.Mapper.isReferenceable(Class).</li>\n\t\t<li>Added c.t.x.mapper.ImmutableTypesMapper.addImmutableType(Class, boolean) and deprecated\n\t\t\tc.t.x.mapper.ImmutableTypesMapper.addImmutableType(Class).</li>\n\t\t<li>Added c.t.x.io.xml.Dom4JDriver.createReader().</li>\n\t\t<li>Added c.t.x.io.xml.DomDriver.createDocumentBuilderFactory().</li>\n\t\t<li>Added c.t.x.io.xml.JDomDriver.createBuilder().</li>\n\t\t<li>Added c.t.x.io.xml.JDom2Driver.createBuilder().</li>\n\t\t<li>Added c.t.x.io.xml.XomDriver.createBuilder().</li>\n\t\t<li>Added constructor c.t.x.converter.extended.ToAttributedValueConverter.ToAttributedValueConverter(Class,\n\t\t\tMapper, ReflectionProvider, ConverterLookup).</li>\n\t\t<li>Added abstract c.t.x.converter.ErrorWritingException as common base for c.t.x.converter.ConversionException\n\t\t\tand c.t.x.converter.reflection.ObjectAccessException.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XomDriver(Builder), c.t.x.io.xml.XomDriver(Builder, NameCoder) and\n\t\t\tc.t.x.io.xml.XomDriver.getBuilder().</li>\n\t\t<li>Deprecated c.t.x.mapper.ClassAliaslingMapper.itemTypeAsAttributes(Class) and\n\t\t\tc.t.x.mapper.ClassAliaslingMapper.aliasIsAttribute(String). Methods never called, left-over from old refactoring.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.8\">1.4.8</h1>\n\n\t<p>Released February 18, 2015.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support for serializable lambda expressions and handling of non-serializable ones.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Detect Java 9 runtime.</li>\n\t\t<li>JIRA:XSTR-767: Deserialization of referenced lambda expressions fail.</li>\n\t\t<li>JIRA:XSTR-762: Private method readResolve() called on base classes.</li>\n\t\t<li>JIRA:XSTR-761: Support ignored serialPersistentField at deserialization time.</li>\n\t\t<li>JIRA:XSTR-755: ExternalizableConverter does not respect writeReplace and readResolve.</li>\n\t\t<li>JIRA:XSTR-757: Deserialized TreeSet does not honor remove(Object) return value contract.</li>\n\t\t<li>JIRA:XSTR-759: Support deserialization of <a href=\"http://www.w3.org/TR/NOTE-datetime\">W3C datetime\n\t\t\t\tformat</a> in DateConverter with Java 7 runtime.\n\t\t</li>\n\t\t<li>Fix: DateConverter ignores provided locale.</li>\n\t\t<li>JIRA:XSTR-768: ISO8601GregorianCalendarConverter may set invalid time zone for Joda-Time.</li>\n\t\t<li>Fix: WeakCache.entrySet().iterator().next.setValue(value) returns the reference instead of the old value.</li>\n\t\t<li>Fix: SqlTimestampConverter throws IllegalArgumentException instead of ConversionException on fromString().</li>\n\t\t<li>Fix: CGLIBEnhancedConverter does not initialize transient members of parent after deserialization.</li>\n\t\t<li>JIRA:XSTR-763: Set scope of org.json:json to test instead declaring the dependency as optional.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.util.JVM.is19().</li>\n\t\t<li>Added c.t.x.converter.reflection.LambdaConverter and c.t.x.mapper.LambdaMapper.</li>\n\t\t<li>Declare c.t.x.XStream.ignoreUnknownElements(Pattern) as public.</li>\n\t\t<li>c.t.x.converters.reflection.AbstractReflectionConverter.readResolve() is protected now.</li>\n\t\t<li>c.t.x.mapper.AbstractAttributeAliasingMapper.readResolve() is protected now.</li>\n\t\t<li>Deprecated c.t.x.converters.extended.StackTraceElementFactory, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.SerializationMethodInvoker, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.io.AttributeNameIterator, it is an internal helper class.</li>\n\t\t<li>Deprecated c.t.x.XStream.useXStream11XmlFriendlyMapper(), corresponding\n\t\t\tc.t.x.mapper.XStream11XmlFriendlyMapper has been deprecated long ago.</li>\n\t\t<li>Deprecated c.t.x.converter.basic.BooleanConverter.shouldConvert(Class,Object), undetected remainder of\n\t\t\tancient XStream version.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.7\">1.4.7</h1>\n\n\t<p>Released February 8, 2014.</p>\n\n\t<p class=\"highlight\">This maintenance release addresses mainly the security vulnerability <a href=\"CVE-2013-7285.html\">\n\t    CVE-2013-7285</a>, an arbitrary execution of commands when unmarshalling.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Add <a href=\"security.html#framework\">security framework</a> to limit handled types while unmarshalling.\n\t\t</li>\n\t\t<li>java.bean.EventHandler no longer handled automatically because of severe security vulnerability.</li>\n\t\t<li>JIRA:XSTR-751: New SunLimitedUnsafeReflectionProvider that uses undocumented features only to allocate new\n\t\t\tinstances as required on Dalvik.</li>\n\t\t<li>Fix instantiation of AnnotationMapper that requires ConverterLookup and ConverterRegistry to be the same\n\t\t\tinstance.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>XSTR-749: NPE if ReflectionConverter.canConvert(type) is called with null as argument.</li>\n\t\t<li>XSTR-753: NPE if SerializationConverter.canConvert(type) is called with an interface type as argument that\n\t\t\textends Serializable.</li>\n\t\t<li>Add constructor to ReflectionConverter taking an additional type to create an instance that is dedicated to a\n\t\t\tspecific type only.</li>\n\t\t<li>The ConverterLookup used by default cannot be casted to a ConverterRegistry anymore.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added package c.t.x.security with interface TypePermission, all its implementations and\n\t\t\tForbiddenClassException.</li>\n\t\t<li>Added c.t.x.mapper.SecurityMapper handling the new type permissions.</li>\n\t\t<li>Added methods addPermission, denyPermission, allowTypesXXX and denyTypesXXX to c.t.x.XStream to setup\n\t\t\tsecurity at unmarshalling time.</li>\n\t\t<li>Added c.t.x.converters.reflection.SunLimitedUnsafeReflectionProvider.</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.Sun14ReflectionProvider in favor of new\n\t\t\tc.t.x.converters.reflection.SunUnsafeReflectionProvider.</li>\n\t\t<li>Added c.t.x.converters.reflection.ReflectionConverter(Mapper,ReflectionProvider,Class).</li>\n\t</ul>\n\n\t<h1 id=\"1.4.6\">1.4.6</h1>\n\n\t<p>Released December 12, 2013.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-566 and JIRA:XSTR-200: Better compatibility with GAE and environments with active SecurityManager\n\t\t\t(i.e. in an Applet). XStream converters try now to ensure already in the canConvert methods that they can handle the\n\t\t\trequested type in practice and not only theoretically. Additionally the implementations even better take care, that\n\t\t\tthe initialization of a converter will not break the setup of XStream itself. Following modifications have been done\n\t\t\tfor these topics:\n\t\t\t<ul>\n\t\t\t\t<li>ReflectionConverter, SerializationConverter and LookAndFieldConverter will check if they can access the\n\t\t\t\t\tfields by reflection for a requested type.</li>\n\t\t\t\t<li>SerializationConverter and ExternalizableConverter will check if they can create an instance of a derived\n\t\t\t\t\tOutputObjectStream first.</li>\n\t\t\t\t<li>BeanProvider does no longer use reflection to locate default constructor.</li>\n\t\t\t\t<li>AbstractAttributedCharacterIteratorAttributeConverter (and therefore TextAttributeConverter) will check\n\t\t\t\t\tfirst if it can access the possible constants of the type by reflection.</li>\n\t\t\t\t<li>NoClassDefFoundError raised in GAE accessing the fields of restricted types by reflection will be handled.</li>\n\t\t\t\t<li>StackTraceElementConverter uses constructor for StackTraceElement instances in Java 5 and GEA.</li>\n\t\t\t</ul>\n\t\t</li>\n\t\t<li>JIRA:XSTR-739 and JIRA:XSTR-746: OrderRetainingMap fails if HashMap.putAll(Map) of Java Runtime is not\n\t\t\timplemented calling put for every element within the map.</li>\n\t\t<li>New NamedArrayConverter to define names of inner elements.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-747: All constructors of StaxDriver derived classes take erroneously a XmlFriendlyNameCoder instead\n\t\t\tof a plain NameCoder.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.extended.NamedArrayConverter for free element names in arrays.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.StandardStaxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.StandardStaxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.BEAStaxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.BEAStaxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added constructors to c.t.x.io.xml.WstxDriver taking NameCoder instead of XmlFriendlyNameCoder.</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.WstxDriver taking a XmlFriendlyNameCoder.</li>\n\t\t<li>Added method canAccess to c.t.x.converter.reflection.AbstractReflectionConverter.</li>\n\t\t<li>Added static method canCreateDerivedObjectOutputStream to c.t.x.core.JVM.</li>\n\t\t<li>Deprecated unused member c.t.x.converter.javabean.BeanProvider.NO_PARAMS.</li>\n\t\t<li>Deprecated unused method c.t.x.converter.javabean.BeanProvider.getDefaultConstrutor(Class).</li>\n\t</ul>\n\n\n\t<h1 id=\"1.4.5\">1.4.5</h1>\n\n\t<p>Released September 18, 2013.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-732: Use a referencing implementation for the ClassLoader to support environments where no new\n\t\t\tClassLoader can be instantiated due to security restrictions.</li>\n\t\t<li>JIRA:XSTR-691: Allow unknown XML elements to be ignored using new method XStream.ignoreUnknownElements.</li>\n\t\t<li>JIRA:XSTR-728: XStream creates invalid JSON with JsonHierarchicalStreamDriver for custom converters since\n\t\t\tXStream 1.4.</li>\n\t\t<li>JIRA:XSTR-300: New EnumToStringConverter to support custom string representations of Enum values.</li>\n\t\t<li>JIRA:XSTR-292 and JIRA:XSTR-405: New NamedMapConverter and NamedCollectionConverter to define names of inner\n\t\t\telements.</li>\n\t\t<li>JIRA:XSTR-726: New annotation XStreamAliasType to support declarative definition of XStream.aliasType().</li>\n\t\t<li>JIRA:XSTR-735: Support for JDOM2 with JDom2Driver, JDom2Reader and JDom2Writer.</li>\n\t\t<li>Optimized XML structure for java.awt.Font.</li>\n\t\t<li>Fix: ToAttributedValueConverter silently appends fields without attribute support to the value producing\n\t\t\tmixed-mode XML.</li>\n\t\t<li>JIRA:XSTR-566 and JIRA:XSTR-249: Better compatibility with Google AppEngine and J2ME, setup no longer fails\n\t\t\tfor unavailable converters.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Fix missing manifest information.</li>\n\t\t<li>JIRA:XSTR-729: Add OSGi information to manifests.</li>\n\t\t<li>JIRA:XSTR-723: XStream will now detect a working enhanced mode dynamically instead using lists of known\n\t\t\tvendors. This allows enhanced support for JamVM if it is bundled with OpenJDK. It will currently fail on a runtime\n\t\t\tbased on GNU Classpath (at least up to version 0.98).</li>\n\t\t<li>JIRA:XSTR-541: JavaScript compatibility problem with 64-bit integers in JSON.</li>\n\t\t<li>JIRA:XSTR-719: Support replacement of default converter in any case.</li>\n\t\t<li>JIRA:XSTR-725: processAnnotation performance improvement in concurrent situation.</li>\n\t\t<li>JIRA:XSTR-721: EnumConverter is more lenient while parsing constants.</li>\n\t\t<li>New constructors for CollectionConverter and MapConverter to allow registration for an individual type.</li>\n\t\t<li>JIRA:XSTR-724: Cache class name lookup failures.</li>\n\t\t<li>Current IBM JDK for Java 1.4.2 no longer has a reverse field ordering.</li>\n\t\t<li>LongConverter supports now positive hex and octal numbers over Long.MAX_VALUE within 64 bit.</li>\n\t\t<li>Fix: Sun14RefectionProvider ignores a provided FieldDictionary.</li>\n\t\t<li>JIRA:XSTR-457: Do not write 'defined-in' attribute if not needed.</li>\n\t\t<li>JettisonMappedXmlDriver provides better support to overwrite its create methods.</li>\n\t\t<li>JIRA:XSTR-685: StAX based drivers (StaxDriver and JettisonMappedXmlDriver) are not closing internal input\n\t\t\tstream reading from file or URL.</li>\n\t\t<li>JIRA:XSTR-736: XStream.unmarshal may throw NPE if version info of manifest is missing.</li>\n\t\t<li>JIRA:XSTR-733: Implicit elements that match multiple defined implicit collections will be assigned to the map\n\t\t\twith the nearest matching element type.</li>\n\t\t<li>JIRA:XSTR-740: ISO8601GregorianCalendarConverter creates Calendar instance with wrong Locale in Java 7 if the\n\t\t\tLocale for the LocaleCategory.FORMAT is different to the global default Locale.</li>\n\t\t<li>JIRA:XSTR-578: Implement support for aliasing in JavaClasConverter, JavaFieldConverter and\n\t\t\tJavaMethodConverter. While it is not possible to enable this in general, new constructors have been added to these\n\t\t\tconverters and an example in the acceptance tests (AliasTest).</li>\n\t\t<li>JIRA:XSTR-742: Register CompositeClassLoader in Java 7 as parallel capable.</li>\n\t\t<li>JIRA:XSTR-743: Support proxy collections of Hibernate Envers.</li>\n\t\t<li>Fix NPE in AttributeMapper.shouldLookForSingleValueConverter if parameters fieldName and definedIn are null.</li>\n\t\t<li>Implicit type argument can be omitted when registering converters with @XStreamConverter annotation.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added c.t.x.converters.extended.NamedCollectionConverter for free element names in collections.</li>\n\t\t<li>Added c.t.x.converters.extended.NamedMapConverter for free element names in maps.</li>\n\t\t<li>Added c.t.x.io.xml.StandardStaxDriver to use the StAX implementation delivered with the Java 6 runtime.</li>\n\t\t<li>Deprecated c.t.x.io.xml.SjsxpStaxDriver to select the internal StAX implementation of Oracle.</li>\n\t\t<li>Added static methods getStaxInputFactory and getStaxOutputFactory to c.t.x.core.JVM as returning the\n\t\t\timplementations of javax.xml.stream.XMLInputFactory (resp. javax.xml.stream.XMLOutputFactory) delivered with the Java\n\t\t\tRuntime since Java 6.</li>\n\t\t<li>Added c.t.x.core.ClassLoaderReference.</li>\n\t\t<li>Added constructors taking an additional Class argument for c.t.x.converters.collections.CollectionConverter\n\t\t\tand c.t.x.converters.collections.MapConverter.</li>\n\t\t<li>Added constructors taking a ClassLoaderReference instead of a ClassLoader and deprecated the ones taking the\n\t\t\tClassLoader:\n\t\t\t<ul>\n\t\t\t\t<li>c.t.x.XStream</li>\n\t\t\t\t<li>c.t.x.converters.extended.DynamicProxyConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaClassConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaFieldConverter</li>\n\t\t\t\t<li>c.t.x.converters.extended.JavaMethodConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.CGLIBEnhancedConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.ExternalizableConverter</li>\n\t\t\t\t<li>c.t.x.converters.reflection.SerializableConverter</li>\n\t\t\t\t<li>c.t.x.mapper.AnnotationMapper</li>\n\t\t\t\t<li>c.t.x.mapper.DefaultMapper</li>\n\t\t\t</ul>\n\t\t</li>\n\t\t<li>Added static methods newReflectionProvider, isAWTAvailable, isSQLAvailable and isSwingAvailable to\n\t\t\tc.t.x.core.JVM as replacement for the deprecated non-static methods.</li>\n\t\t<li>Deprecated c.t.x.core.JVM() and all non-static methods.</li>\n\t\t<li>Added method useImplicitType to c.t.x.annotations.XStreamConverter.</li>\n\t\t<li>JIRA:XSTR-722: Added c.t.x.converters.reflection.ReflectionProvider.getFieldOrNull(Class, String).</li>\n\t\t<li>Deprecated c.t.x.converters.reflection.ReflectionProvider.fieldDefinedInClass(Class, String) in favor of new\n\t\t\tc.t.x.converters.reflection.ReflectionProvider.getFieldOrNull(Class, String).</li>\n\t\t<li>Deprecated constructor c.t.x.converters.extended.RegexPatternConverter(Converter) in favor of\n\t\t\tc.t.x.converters.extended.RegexPatternConverter().</li>\n\t\t<li>Deprecated default constructor of c.t.x.converters.extended.FontConverter in favor of\n\t\t\tc.t.x.converters.extended.FontConverter(Mapper).</li>\n\t\t<li>Deprecated constructor c.t.x.converters.extended.ThrowableConverter(Converter) in favor of\n\t\t\tc.t.x.converters.extended.ThrowableConverter(ConverterLookup).</li>\n\t\t<li>Deprecated class c.t.x.converters.reflection.SelfStreamingInstanceChecker and moved original implementation\n\t\t\tinto c.t.x.core.util, since it is internal.</li>\n\t\t<li>Deprecated interface c.t.x.mapper.AnnotationConfiguration.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.4\">1.4.4</h1>\n\n\t<p>Released January 19, 2013.</p>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-709: Locks up on Mac with Apple JVM due to unwanted initialization of AWT.</li>\n\t\t<li>JIRA:XSTR-711: DateConverter cannot handle dates in different era.</li>\n\t\t<li>JIRA:XSTR-741: ToAttributedValueConverter fails to write enums as attributes.</li>\n\t\t<li>JIRA:XSTR-712: HibernateMapper throws NPE if a collection contains null.</li>\n\t\t<li>DateConverter supports now localized formats.</li>\n\t\t<li>JIRA:XSTR-710: JsonWriter does not write BigInteger and BigDecimal as number values.</li>\n\t\t<li>JIRA:XSTR-708: SqlTimestampConverter does not ignore timezone.</li>\n\t\t<li>JIRA:XSTR-707: Creation of XmllPullParser with the XmlPullParserFactory may fail in OSGi environment.</li>\n\t\t<li>JIRA:XSTR-705: Unnecessary synchronization accessing the field cache decreases performance.</li>\n\t\t<li>JIRA:XSTR-714: Fields not found when XStream12FieldKeySorter used.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecated method c.t.x.core.util.JVM.is14(), c.t.x.core.util.JVM.is15() and c.t.x.core.util.JVM.is16().</li>\n\t</ul>\n\n\t<h1 id=\"1.4.3\">1.4.3</h1>\n\n\t<p>Released July 17, 2012.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support java.util.concurrent.ConcurrentHashMap with the MapConverter. This will also avoid a bug in JRockit\n\t\t\tJDK reported in JIRA:XSTR-608.</li>\n\t\t<li>JIRA:XSTR-699: Support for Hibernate 4 with XStream's Hibernate module as default for Java 6 or higher.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JVM.loadClass will now also initialize the loaded class and ignore any occurring LinkageError.</li>\n\t\t<li>JIRA:XSTR-596: SubjectConverter will be no longer registered if initialization of javax.security.auth.Subject\n\t\t\tfails.</li>\n\t\t<li>JIRA:XSTR-683: Inheritance of implicit collections, arrays or maps is dependent on declaration sequence.</li>\n\t\t<li>Inherited implicit collections, arrays or maps can be overwritten with own definition in subtype.</li>\n\t\t<li>JIRA:XSTR-688: Cannot omit XML elements from derived fields.</li>\n\t\t<li>JIRA:XSTR-696: Ill-formed JSON generated, because JSON writer is fed with type of declaring field instead of\n\t\t\tthe real object's type.</li>\n\t\t<li>JIRA:XSTR-685: Deserialization from file or URL keeps stream open.</li>\n\t\t<li>JIRA:XSTR-684: XML 1.0 character validation fails for characters from 0x10 to 0x1f.</li>\n\t\t<li>JavaBeanConverter supports now instantiation for a specific type and can therefore be used in\n\t\t\t@XStreamConverter annotation.</li>\n\t\t<li>SerializableConverter is broken if the serialized type is the default implementation.</li>\n\t\t<li>Method marshalUnserializableParent of SerializableConverter is protected now to skip the default mechanism in\n\t\t\ta derived converter that uses the default constructor to create the original type (as an alternative for\n\t\t\tJIRA:XSTR-695).</li>\n\t\t<li>FieldDictionary may call sort of FieldKeySorter implementation with wrong type as key.</li>\n\t\t<li>Sometimes DependencyInjectionFactory tries to instantiate objects with mismatching constructor arguments.</li>\n\t\t<li>HSQLDB has to be a test dependency only for XStream's Hibernate module.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.2\">1.4.2</h1>\n\n\t<p>Released November 3, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>XStream libraries can be used now directly in Android, therefore support of Java 1.4.2 has been stopped with\n\t\t\tthe delivery. Anyone who needs a version for Java 1.4.2 can build it easily from source, this build is still\n\t\t\tsupported and part of CI.</li>\n\t\t<li>JIRA:XSTR-675: New extended HierarchicalStreamReader interface with peekNextChild method. All XStream readers\n\t\t\timplement the new interface (by Nikita Levyankov).</li>\n\t\t<li>JIRA:XSTR-673: Collections.EMPTY_LIST, Collections.EMPTY_SET and Collections.EMPTY_MAP supported with own\n\t\t\talias and defined as immutable.</li>\n\t\t<li>JIRA:XSTR-631: Collections.singletonList(), Collections.singletonSet() and Collections.singletonMap()\n\t\t\tsupported with own alias and own converters.</li>\n\t\t<li>JIRA:XSTR-406 + JIRA:XSTR-663: Support additional parameters for XStreamConverter annotation (e.g. to declare\n\t\t\ta ToAttributedValueConverter).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>WstxDriver did not trigger Woodstox, but BEA StAX implementation.</li>\n\t\t<li>JIRA:XSTR-260: PrettyPrintWriter does not handle tab and new line characters in attributes.</li>\n\t\t<li>JIRA:XSTR-667: Cannot serialize empty list with JsonHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-661: TreeMarshaller.CircularReference is not a ConversionException.</li>\n\t\t<li>JIRA:XSTR-562: StAX: Namespace attribute is not written in non-repairing mode for second sibling.</li>\n\t\t<li>JIRA:XSTR-664: ClassCastException in HibernatePersistentSortedSetConverter and\n\t\t\tHibernatePersistentSortedMapConverter.</li>\n\t\t<li>JIRA:XSTR-674: Recreate binary compatibility with 1.3.x series for method\n\t\t\tCustomObjectInputStream.getInstance(...).</li>\n\t\t<li>JIRA:XSTR-671: CannotResolveClassException should accept cause.</li>\n\t\t<li>JIRA:XSTR-672: Collections.EMPTY_LIST, Collections.EMPTY_SET and Collections.EMPTY_MAP used for in implicit\n\t\t\tcollection should not throw ReferencedImplicitElementException.</li>\n\t\t<li>JIRA:XSTR-676: Introduce MissingFieldException thrown at deserialization time indicating a missing field or\n\t\t\tproperty (by Nikita Levyankov).</li>\n\t\t<li>Add length limit for cached strings in StringConverter, 38 characters by default.</li>\n\t\t<li>The JsonHierarchicalStreamDriver and the JsonWriter did not support the inherited NameCoder instance.</li>\n\t\t<li>Add BinaryStreamDriver.</li>\n\t\t<li>NPE in XppDomComparator.</li>\n\t\t<li>Dom4JXmlWriter fails to flush the underlying writer.</li>\n\t\t<li>Known control characters are not encoded with JsonWriter as proposed at json.org.</li>\n\t\t<li>Detect duplicate property processing in JavaBeanConverter and throw DuplicatePropertyException instead of\n\t\t\tclobbering silently.</li>\n\t\t<li>Allow access to Mapper and JavaBeanProvider in derived instances of JavaBeanConverter.</li>\n\t\t<li>DependencyInjectionFactory failed to create instance when a matching constructor was found, but a default\n\t\t\tconstructor was also present.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Added interface c.t.x.io.ExtendedHierarchicalStreamReader extending c.t.x.io.HierarchicalStreamReader. All\n\t\t\timplementations of c.t.x.io.HierarchicalStreamReader will implement also the extended interface.</li>\n\t\t<li>Added c.t.x.converters.reflection.MissingFieldException derived from\n\t\t\tc.t.x.converters.reflection.ObjectAccessException and used instead when the unmarshalling process should write a\n\t\t\tfield or property that is missing and does not exist.</li>\n\t\t<li>Added methods c.t.x.io.path.PathTracker.peekElement(), c.t.x.io.path.PathTracker.peekElement(int), and\n\t\t\tc.t.x.io.path.PathTracker.depth().</li>\n\t\t<li>Deprecated method c.t.x.core.ReferencingMarshallingContext.currentPath(). Wrong approach.</li>\n\t</ul>\n\n\t<h1 id=\"1.4.1\">1.4.1</h1>\n\n\t<p>Released August 11, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-659: Use again Xpp3 as default parser, now with additional XmlPullParser API as regular dependency\n\t\t\tfor the XPP factory. Only standard kXML2 package contains the XPP factory, but not the minimal kXML2 version.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Add utility class c.t.x.io.xml.xppdom.XppFactory and a path tracking comparator for XppDom.</li>\n\t</ul>\n\n\t<h1 id=\"1.4\">1.4</h1>\n\n\t<p>Released August 6, 2011.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Java 7 is detected and supported.</li>\n\t\t<li>JIRA:XSTR-542: The XppDriver uses now the official XmlPullParser API to locate an available parser using the\n\t\t\tXmlPullParserFactory. This allows the usage of XPP technology with XStream in Android.</li>\n\t\t<li>Additional explicit XPP drivers for the Xpp3 and kXML2 implementations.</li>\n\t\t<li>Additional explicit XPP DOM drivers for the Xpp3 and kXML2 implementations.</li>\n\t\t<li>kXML2 is now the preferred parser implementation, Xpp3 is optional.</li>\n\t\t<li>Additional explicit StAX drivers for Woodstox, BEA StAX and SJSXP of the JDK 6 implementations.</li>\n\t\t<li>JDK 1.3 is no longer officially supported.</li>\n\t\t<li>JIRA:XSTR-377+JIRA:XSTR-226: New artifact xstream-hibernate with converters and mapper to process Hibernate\n\t\t\tobject graphs (by Costin Leau, Konstantin Pribluda and in special Jaime Metcher).</li>\n\t\t<li>New NameCoder interface and implementations to support a generic name translation between names from the\n\t\t\tobject graph and a target format. The new XmlFriendlyNameCoder replaces the XmlFriendlyReplacer used for XML only.</li>\n\t\t<li>JIRA:XSTR-553: Support annotations in Android.</li>\n\t\t<li>JIRA:XSTR-556: DateConverter uses format with 3-letter time zones that are ambiguous. Therefore it will now\n\t\t\talways use UTC to write dates. Unmarshalled dates are not affected as long as they contain a time zone.</li>\n\t\t<li>The type java.lang.reflect.Field is now handled by an own converter, that can still read the old format.</li>\n\t\t<li>JIRA:XSTR-490: Provide path in Converter for contexts that track the path.</li>\n\t\t<li>JIRA:XSTR-592+JIRA:XSTR-579: OmitField respected at deserialization time even for existing fields.</li>\n\t\t<li>JIRA:XSTR-593: Direct support for java.net.URI instances (by Carlos Roman).</li>\n\t\t<li>JIRA:XSTR-615+JIRA:XSTR-580: Dynamic proxies cannot be referenced recursively.</li>\n\t\t<li>JIRA:XSTR-547: Wrong class loader used for Serializable types deserialized with an ObjectInputStream.</li>\n\t\t<li>JIRA:XSTR-341: Support of implicit arrays.</li>\n\t\t<li>JIRA:XSTR-306+JIRA:XSTR-406: Support of implicit maps.</li>\n\t\t<li>JIRA:XSTR-344: New ToAttributedValueConverter to allow conversion of an element with string body and\n\t\t\tattributes.</li>\n\t\t<li>JIRA:XSTR-573: SortedSet added with TreeSet as the default implementation.</li>\n\t\t<li>JIRA:XSTR-576: TreeMap and TreeSet no longer add an element without comparator (by Jason Greanya), solves\n\t\t\talso invalid format with JSON for such objects (JIRA:XSTR-640).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-612: Improve extensibility of c.t.x.javabean.* package by reintroducing a PropertyDictionary with\n\t\t\tthe additional interface PropertySorter.</li>\n\t\t<li>JIRA:XSTR-591: EnumSingleValueConverter did use toString() instead of name() to create the String\n\t\t\trepresentation of an enum value.</li>\n\t\t<li>JIRA:XSTR-618: Add Oracle as vendor used for recent JRockit versions and former Sun JDK.</li>\n\t\t<li>JIRA:XSTR-656: DomReader and Dom4JReader do not escape attribute names retrieving their values.</li>\n\t\t<li>JIRA:XSTR-604: StringConverter's cache may cause an OutOfMemoryException.</li>\n\t\t<li>JIRA:XSTR-577: Skip UTF-8 BOM in XmlHeaderAwareReader.</li>\n\t\t<li>The XppReader no longer uses a BufferedReader.</li>\n\t\t<li>JIRA:XSTR-543: Better deserialization support of the defined-in system attribute in combination with field\n\t\t\taliases.</li>\n\t\t<li>JIRA:XSTR-551: Deprecated XStream.InitializationException still thrown instead of InitializationException.</li>\n\t\t<li>JIRA:XSTR-655: JsonWriter generates invalid JSON for Externalizable types.</li>\n\t\t<li>JIRA:XSTR-540: Support Jettison-based configuration of JettisonMappedXmlDriver (by Doug Daniels).</li>\n\t\t<li>JIRA:XSTR-633: JettisonMappedXmlDriver escaped property names according escape rules for XML tag names.</li>\n\t\t<li>JIRA:XSTR-625: Optionally ignore XStream's hints for Jettison to generate JSON arrays (by Dejan Bosanac).</li>\n\t\t<li>JIRA:XSTR-605: Upgrade to Jettison 1.2 (for Java 5 or higher).</li>\n\t\t<li>New JsonWriter.EXPLICIT_MODE generating JSON that enforces property sequence.</li>\n\t\t<li>JIRA:XSTR-552: Improve performance of ReflectionProvider (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-559: Improve performance of Sun14ReflectionProvider (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-564: Improve performance of AnnotationMapper (by Keith Kowalczykowski).</li>\n\t\t<li>JIRA:XSTR-563: Use ReferenceQueue for cleaning-up WeakReferences in ObjectIdDictionary (by Keith\n\t\t\tKowalczykowski).</li>\n\t\t<li>JIRA:XSTR-646: Cache of Sun14ReflectionProvider consumes more PermGen space than necessary.</li>\n\t\t<li>JIRA:XSTR-636: Ineffective cache in FieldDictionary using WeakHashMap with WeakReference values.</li>\n\t\t<li>Ineffective cache for SerializationMethodInvoker (related to JIRA:XSTR-636).</li>\n\t\t<li>Introduction of Caching interface implemented by all types in XStream that create local caches that may have\n\t\t\tto be flushed manually.</li>\n\t\t<li>Avoid excessive creation of AbstractPullReader.Event objects by using a pool.</li>\n\t\t<li>Possibility to generate XPath expressions that select always a single node instead of a node list.</li>\n\t\t<li>Cannot reference replaced object using ID references.</li>\n\t\t<li>Implicit collection functionality will no longer use custom collection converters that may write tags that\n\t\t\tare not recognized at deserialization time again.</li>\n\t\t<li>JIRA:XSTR-654: Unmarshal fails when an implicit collection is defined and an element is named equal to the\n\t\t\tfield.</li>\n\t\t<li>JIRA:XSTR-574: AbstractReferenceUnmarshaller cannot handle null values for references.</li>\n\t\t<li>Improve exception output in case of a missing field.</li>\n\t\t<li>JIRA:XSTR-555: StAX driver tests do not honor repairing mode.</li>\n\t\t<li>JIRA:XSTR-570: The @XStreamConverter provides now also the current type as possible constructor argument.</li>\n\t\t<li>JIRA:XSTR-629: Deserialization of Externalizable with non-accessible default constructor fails.</li>\n\t\t<li>JIRA:XSTR-571: Cannot serialize synchronized RandomAccessList types.</li>\n\t\t<li>JIRA:XSTR-583: BinaryDriver fails to handle Strings with more than 64K bytes.</li>\n\t\t<li>JIRA:XSTR-639: Cannot omit field at deserialization if the field has a class attribute.</li>\n\t\t<li>JIRA:XSTR-599: EncodedByteArrayConverter should implement SingleValueConverter.</li>\n\t\t<li>JIRA:XSTR-584: Race condition in XmlFriendlyReplacer.</li>\n\t\t<li>JIRA:XSTR-623: XmlFriendlyReplacer may write illegal name characters (by Michael Schnell).</li>\n\t\t<li>The ConversionException hides information if its ErrorWriter contains the added key already.</li>\n\t\t<li>JIRA:XSTR-598: Attribute &quot;defined-in&quot; was wrongly evaluated for other attributes.</li>\n\t\t<li>JIRA:XSTR-650: Possible NullPointerException at initialization on platforms like Android that do not support\n\t\t\tall types of the JDK.</li>\n\t\t<li>JIRA:XSTR-652: Initialization of XStream fails if DurationConverter constructor throws a\n\t\t\tjavax.xml.datatype.DatatypeConfigurationException. Converter will no longer handle Duration types if no instance of\n\t\t\tthe internal DatatypeFactory can be created.</li>\n\t\t<li>Constructor DocumentWriter(Element) forgets the provided element.</li>\n\t\t<li>JIRA:XSTR-597: Optimize AbstractReflectionConverter.</li>\n\t\t<li>Introduce Caching interface to flush the internal cache of specific components.</li>\n\t\t<li>Support JIRA:XSTR-407 also for IBM JRE 1.6 and greater.</li>\n\t\t<li>java.nio.charset.Charset's converter was added as immutable type instead of the type itself.</li>\n\t\t<li>java.util.Currency added as immutable type.</li>\n\t\t<li>Fix selection of same parameter types in DependencyInjectionFactory.</li>\n\t\t<li>Deprecation of c.t.x.javabean.PropertyDictionary has been countermanded.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Any deprecated stuff of the 1.2.x releases has been removed.</li>\n\t\t<li>Deprecated constructors of c.t.x.converters.reflection.SerializableConverter,\n\t\t\tc.t.x.converters.reflection.ExternalizableConverter and c.t.x.converters.reflection.CGLIBEnhancedConverter; new\n\t\t\tversions take an additional argument for class loader (as a result for JIRA:XSTR-547).</li>\n\t\t<li>Deprecated constructors of c.t.x.io.xml.XppReader, new versions take an additional argument for the\n\t\t\tXmlPullParser.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XppReader.createParser(), the XPP parser is now created by the driver.</li>\n\t\t<li>Package c.t.x.io.xml.xppdom is now part of the official API.</li>\n\t\t<li>c.t.x.io.xml.xppdom.Xpp3Dom and c.t.x.io.xmlxpp.dom.Xpp3DomBuilder have been deprecated. Functionality is\n\t\t\tmerged in c.t.x.io.xml.xppdom.XppDom.</li>\n\t\t<li>Deprecated c.t.x.mapper.XStream11XmlFriendlyMapper and c.t.x.mapper.AbstractXmlFriendlyMapper.</li>\n\t\t<li>Added interface c.t.x.core.ReferencingMarshallingContext which is implemented by all referencing marshallers.</li>\n\t\t<li>Added interface c.t.x.io.naming.NameCoder and implementations.</li>\n\t\t<li>Deprecated c.t.x.io.xml.XmlFriendlyReplacer, c.t.x.io.xml.XmlFriendlyReader and\n\t\t\tc.t.x.io.xml.XmlFriendlyWriter.</li>\n\t\t<li>Deprecated c.t.x.io.xml.AbstractXmlDriver, c.t.x.io.xml.AbstractXmlReader and c.t.x.io.xml.AbstractXmlWriter,\n\t\t\tadded c.t.x.io.AbstractDriver, c.t.x.io.AbstractReader and c.t.x.io.AbstractWriter instead.</li>\n\t\t<li>Deprecated all constructors of Driver, Reader and Writer implementations that take a XmlFriendlyReplacer as\n\t\t\targument, added constructors taking a NameCoder instead.</li>\n\t\t<li>Added interface com.thoughtworks.xstream.converters.ErrorReporter to allow other types to report also errors\n\t\t\t(apart from a HierarchicalStreamReader). Any converter and the parent object of the currently deserialized element\n\t\t\tmay provide additional error information now.</li>\n\t</ul>\n\n\t<h1 id=\"1.3.1\">1.3.1</h1>\n\n\t<p>Released December 6, 2008.</p>\n\n\t<p class=\"highlight\">CGLIB support must be explicitly activated now. The decision has been made due to possible\n\t\tproblems using an own classloader and because of ongoing complaints about occurring exceptions in the\n\t\tCGLIBEnhancedConverter at XStream initialization although they are caused by incompatible ASM versions on the user's\n\t\tclasspath (JIRA:XSTR-469, JIRA:XSTR-513 and JIRA:XSTR-518).</p>\n\n\t<p class=\"highlight\">XStream uses some attributes on its own. Until now it was possible to use\n\t\tXStream.aliasAttribute to define a different name. This does still work but is deprecated for system attributes. Use\n\t\tthe new call XStream.aliasSystemAttribute for such an alias.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-515: CGLIB support is no longer activated automatically and has to be <a\n\t\t\thref=\"faq.html#Serialization_CGLIB\">explicitly turned on</a>.\n\t\t</li>\n\t\t<li>JIRA:XSTR-448: Separated system attributes and user defined attributes for aliases.</li>\n\t\t<li>JIRA:XSTR-55: Ability to alias a package name.</li>\n\t\t<li>JIRA:XSTR-434: New JsonWriter instead of JsonHierarchicalStreamWriter with mode to strip root node of\n\t\t\tgenerated JSON (by Paul Hammant).</li>\n\t\t<li>Support for Diablo JDK on FreeBSD (by Reto Bachmann-Gm&uuml;r).</li>\n\t\t<li>JIRA:XSTR-495: New PersistenceStrategy instead of StreamStrategy (based on the code and comments by Alexander\n\t\t\tRadzin).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Support special Jettison functionality for JSON to detect collections or arrays with one element introduced\n\t\t\twith Jettison 1.0.</li>\n\t\t<li>JIRA:XSTR-493: Using attributes for fields with XML-unfriendly names results in NPE at deserialization.</li>\n\t\t<li>JIRA:XSTR-497: Unsafe operation with WeakHashMap can raise a NPE in Sun14ReflectionProvider.</li>\n\t\t<li>JIRA:XSTR-423: Support of CGLIB enhanced proxies with multiple callbacks if the proxy uses a factory (CGLIB\n\t\t\tdefault).</li>\n\t\t<li>JIRA:XSTR-536: XStream silently ignores unknown elements.</li>\n\t\t<li>JIRA:XSTR-503: Omitted properties in JavaBeans are requested at serialization (by Kevin Conaway).</li>\n\t\t<li>Fix possible memory leak in ObjectIdMap for JVMs that provide real distinct identity hash codes (happened on\n\t\t\tamd64 system).</li>\n\t\t<li>JIRA:XSTR-480: Aliasing of array types.</li>\n\t\t<li>JIRA:XSTR-515: The SubjectConverter and DurationConverter are only registered if the converted class is part\n\t\t\tof the JDK, otherwise they must be registered now explicitly.</li>\n\t\t<li>JIRA:XSTR-504: XmlHeaderAwareReader fails with improper sized PushbackInputStream.</li>\n\t\t<li>JIRA:XSTR-489: @XStreamConverter supports now also SingleValueConverter implementations.</li>\n\t\t<li>JIRA:XSTR-481: @XStreamConverter and @XStreamAsAttribute can be used together (as a result of JIRA:XSTR-489).</li>\n\t\t<li>JIRA:XSTR-519: New annotation @XStreamInclude to force annotation detection of included types (by Seven\n\t\t\tSparling).</li>\n\t\t<li>JIRA:XSTR-469: Support custom converters for enum types.</li>\n\t\t<li>JIRA:XSTR-502: ClassNotFoundException even if writeReplace returns proper object.</li>\n\t\t<li>JIRA:XSTR-529: NullPointerException for null elements in implicit lists.</li>\n\t\t<li>JIRA:XSTR-517: Miscellaneous performance improvements (by Tatu Saloranta).</li>\n\t\t<li>JIRA:XSTR-525: JsonHierarchicalStreamDriver writes invalid JSON in case of system attribute.</li>\n\t\t<li>JIRA:XSTR-535: Mode to allow plain values as result for JSON without root node.</li>\n\t\t<li>JIRA:XSTR-531: Possibility to omit system attributes.</li>\n\t\t<li>JIRA:XSTR-508: Fix marshalling error for nested serializable objects with own writeReplace/readResolve\n\t\t\tmethods.</li>\n\t\t<li>JIRA:XSTR-507: Advanced ReferenceByIdMarshaller uses id of the current object if available.</li>\n\t\t<li>JIRA:XSTR-485: Check reference for valid object when deserializing.</li>\n\t\t<li>Fix classloader problem, Xpp3 parser cannot be loaded within a web application.</li>\n\t\t<li>Dependencies have been updated to latest versions of JDOM, Jettison, Joda Time, and Woodstox. Note for Maven\n\t\t\tbuilds that the <em>groupId</em> of JDOM has changed.\n\t\t</li>\n\t\t<li>Fix possible IndexOutOfBoundsException creating returning the message for a ConversionException.</li>\n\t\t<li>JIRA:XSTR-495: StreamStrategy cannot handle key with value <em>null</em>.\n\t\t</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecated c.t.x.io.json.JsonHierarchicalStreamWriter in favour of c.t.x.io.json.JsonWriter.</li>\n\t\t<li>c.t.x.mapper.EnumMapper no longer derives from the c.t.x.mapper.AttributeMapper as it has been before version\n\t\t\t1.3. Therefore the new constructor has been deprecated in favour of the old one.</li>\n\t\t<li>c.t.x.mapper.Mapper.getConverterFromAttribute(Class, String) has been deprecated in favour of\n\t\t\tc.t.x.mapper.Mapper.getConverterFromAttribute(Class, String, Class) taking the type as third argument that should be\n\t\t\thandled by the converter.</li>\n\t\t<li>c.t.x.core.ReferenceByIdMarshaller.IdGenerator.next() has now the current object as argument.</li>\n\t\t<li>New c.t.x.persistence.PersistenceStrategy and c.t.x.persistence.FilePersistenceStrategy.</li>\n\t\t<li>Deprecated c.t.x.persistence.StreamStrategy and c.t.x.persistence.FileStreamStrategy.</li>\n\t</ul>\n\n\t<h1 id=\"1.3\">1.3</h1>\n\n\t<p>Released February 27, 2008.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>ReflectionConverter writes now the fields of the parent classes first.</li>\n\t\t<li>Support for Converter definition at field level.</li>\n\t\t<li>Refactoring of Annotation support, invent auto-detection mode.</li>\n\t\t<li>Annotated converters are no longer detected automatically, all annotations are now handled in the same way.</li>\n\t\t<li>JIRA:XSTR-334: XStream will deserialize directly from a file or URL. Some parser take advantage of these\n\t\t\tobjects to define a SystemId used to resolve further references in XML, schema or DTD. Appropriate createReader\n\t\t\tmethods have been added to c.t.x.io.HierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-261: All c.t.x.io.HierarchicalStreamDriver implementations respect now the encoding of an XML\n\t\t\theader if read from an InputStream.</li>\n\t\t<li>DomDriver does no longer use explicitly UTF-8 by default, DomReader will therefore respect the encoding\n\t\t\tdefined in the XML header or use native encoding</li>\n\t\t<li>JIRA:XSTR-415: JavaBeanConverter uses now BeanIntrospection (by Hinse ter Schuur).</li>\n\t\t<li>JIRA:XSTR-424: DateConverter uses now by default SimpleDateFormat instances in non-lenient mode.</li>\n\t\t<li>JIRA:XSTR-386: SingleValueConverter that utilizes PropertyEditor implementations (by Jukka Lindstr&ouml;m).</li>\n\t\t<li>JIRA:XSTR-427: Converter for javax.xml.datatype.Duration (by John Kristian).</li>\n\t\t<li>JIRA:XSTR-305: Field alias inheritance (by David Blevins).</li>\n\t\t<li>XStream failed to initialize in environments without AWT or SQL classes.</li>\n\t\t<li>JIRA:XSTR-420: XPath of references are not XmlFriendly encoded.</li>\n\t\t<li>JIRA:XSTR-473: String &quot;\\0&quot; serialized as invalid XML, support compliant behaviour according XML\n\t\t\tversion.</li>\n\t\t<li>JIRA:XSTR-431: Direct support of enhanced mode for SAP JVM (thanks to Norbert Kuck by SAP).</li>\n\t\t<li>JIRA:XSTR-437: Static cache in annotation processing causes failing OSGi bundles.</li>\n\t\t<li>JIRA:XSTR-279+JIRA:XSTR-335: Annotations are not inherited from parent class.</li>\n\t\t<li>Fix StringConverter using a WeakHashMap with strong references in its value.</li>\n\t\t<li>JIRA:XSTR-403: Attributes are no longer written with JSONHierarchicalStreamDriver if current object is a\n\t\t\tcollection.</li>\n\t\t<li>JIRA:XSTR-456: New LookAndFeelConverter handling LookAndFeel implementations with reflection.</li>\n\t\t<li>JIRA:XSTR-462: CachingMapper keeps direct class references.</li>\n\t\t<li>JIRA:XSTR-411: JsonHierarchicalStreamDriver does not escape characters according RFC 4627.</li>\n\t\t<li>JsonHierarchicalStreamDriver writes wrong brackets around complex Java types with a single value.</li>\n\t\t<li>JsonHierarchicalStreamDriver writes attribute names with a leading '@'.</li>\n\t\t<li>JsonHierarchicalStreamDriver supports Map implementations.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added converter for java.lang.StringBuilder instances.</li>\n\t\t<li>Added converter for java.util.UUID instances.</li>\n\t\t<li>JIRA:XSTR-430: Fields written as attributes could not be omitted.</li>\n\t\t<li>JIRA:XSTR-407: Comparator might access uninitialized elements for TreeSet and TreeMap. A deserialized\n\t\t\tComparator is no longer called, the converters expect the elements now in a sorted order.</li>\n\t\t<li>JIRA:XSTR-404, @XStreamImplicit() for ArrayList&lt;ArrayList&lt;Type&gt;&gt; throws ClassCastException.</li>\n\t\t<li>@XStreamContainedType() for ArrayList&lt;ArrayList&lt;Type&gt;&gt; throws ClassCastException.</li>\n\t\t<li>XStreamer did not persist a FieldKeySorter instance.</li>\n\t\t<li>JIRA:XSTR-241: JavaBeanConverter now supports customized BeanProvider.</li>\n\t\t<li>JIRA:XSTR-280: JavaBeanConverter now supports aliasField and omitField (by Hinse ter Schuur).</li>\n\t\t<li>JIRA:XSTR-280: SerializationConverter now supports aliasField and omitField.</li>\n\t\t<li>JIRA:XSTR-429: XmlFriendlyReplacer support for SaxWriter and TraxSource (by Adrian Wilkens).</li>\n\t\t<li>JIRA:XSTR-421: Characters cannot be written as attribute.</li>\n\t\t<li>JIRA:XSTR-426: java.swt.KeyStroke not properly serialized because of a character undefined in unicode.</li>\n\t\t<li>JIRA:XSTR-352: Strings with arbitrary ISO control characters are not properly serialized.</li>\n\t\t<li>JIRA:XSTR-428: An attribute named like a transient field did abort deserialization of following fields.</li>\n\t\t<li>JIRA:XSTR-443: XStream.createObjectOutputStream does not use the given driver to create the\n\t\t\tHierarchicalStreamWriter.</li>\n\t\t<li>JIRA:XSTR-440: Implicit collections can be declared for fields that are not of Collection type.</li>\n\t\t<li>JIRA:XSTR-446: Handle all primitives and their boxed counterpart for JsonHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-447: Fix deserialization of Array class types in JDK 6 (see JDK bug 6500212).</li>\n\t\t<li>JIRA:XSTR-450: @XStreamAlias is ignored if attributes should be used for the field type.</li>\n\t\t<li>JIRA:XSTR-418: Inherited @XStreamAlias is ignored if field should be rendered as attribute.</li>\n\t\t<li>JIRA:XSTR-393: Annotation processing is not consistent.</li>\n\t\t<li>JIRA:XSTR-412: @XStreamImplicit throws NPE for untyped collections.</li>\n\t\t<li>JIRA:XSTR-463: Cannot provide own default Mapper chain.</li>\n\t\t<li>JIRA:XSTR-464: Cannot provide a ClassLoader that is used in all cases.</li>\n\t\t<li>JIRA:XSTR-394: Allow enums as attributes.</li>\n\t\t<li>JIRA:XSTR-413: Support @XStreamAsAttribute for enums.</li>\n\t\t<li>JIRA:XSTR-478: Cannot specify default implementation for polymorphic enum.</li>\n\t\t<li>JIRA:XSTR-419: Treat enums as immutable types.</li>\n\t\t<li>Update annotation tutorial, explain limitations of auto-detection mode.</li>\n\t\t<li>Added copyright notices to all files.</li>\n\t\t<li>StaxWriter.flush did close Stax' XMLStreamWriter instead of flushing it.</li>\n\t\t<li>JIRA:XSTR-471: XStream POMs do no longer declare a repository at all.</li>\n\t\t<li>Calendar object could not be rendered with JSONHierarchicalStreamDriver.</li>\n\t\t<li>JIRA:XSTR-476: Properties can be sorted by key.</li>\n\t\t<li>XStream.createObjectInputStream and XStream.createObjectOutputStream overloaded to support a binary\n\t\t\tInputStream or OutputStream.</li>\n\t\t<li>JIRA:XSTR-470: Allow transient fields to be optionally deserialized.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>c.t.x.annotation.Annotations, c.t.x.annotation.AnnotationReflectionConverter and\n\t\t\tc.t.x.annotation.AnnotationProvider deprecated. Functionality is integrated in new c.t.x.mapper.AnnotationMapper and\n\t\t\taccessible with new methods c.t.x.XStream.processAnnotations().</li>\n\t\t<li>New auto-detection mode for annotations, that can be turned on with c.t.x.XStream.autodetectAnnotations()</li>\n\t\t<li>c.t.x.annotation.@XStreamContainedType deprecated, the behaviour is now always active and the annotation\n\t\t\ttherefore superfluous.</li>\n\t\t<li>Due to JIRA:XSTR-421 null characters are no longer written as tag with an attribute (&lt;char\n\t\t\tnull=&quot;true&quot;/&gt;), but as empty tag. The old representation is still supported at deserialization.</li>\n\t\t<li>Characters that are not defined in unicode or ISO control characters (expect TAB and LF) are written as\n\t\t\tnumerical entity now.</li>\n\t\t<li>XPath references are now also XML-friendly encoded to match the path exactly. Unencoded references will\n\t\t\tnormally work anyway, but in special cases the exact behaviour of XStream 1.2.x might be necessary. See acceptance\n\t\t\ttests for XStream 1.2.x compatibility.</li>\n\t\t<li>c.t.x.core.BaseException deprecated in favour of c.t.x.XStreamException as base exception for all exceptions\n\t\t\tXStream throws.</li>\n\t\t<li>c.t.x.XStream.InitializerException deprecated in favour of c.t.x.InitializerException.</li>\n\t\t<li>New methods get() and keys() in interface c.t.x.converter.ErrorWriter.</li>\n\t\t<li>c.t.x.mapper.XmlFriendlyMapper deprecated, technology is replaced since version 1.2 by\n\t\t\tc.t.x.io.xml.XmlFriendlyReplacer as part of the different XmlWriter implementations.</li>\n\t\t<li>c.t.x.mapper.Mapper.aliasForAttribute() and c.t.x.mapper.Mapper.attributeForAlias() deprecated, since it\n\t\t\tprovided in reality the combined functionality of c.t.x.mapper.Mapper.serializedMember()/realMember() and\n\t\t\tc.t.x.mapper.Mapper.getConverterFromItemType().</li>\n\t\t<li>c.t.x.XStream(ReflectionProvider, Mapper, HierarchicalStreamDriver) deprecated, in favour of\n\t\t\tc.t.x.XStream(ReflectionProvider, HierarchicalStreamDriver, Mapper, ClassLoader).</li>\n\t\t<li>New interface c.t.x.converter.ConverterRegistry to express explicit functionality managing the converters.</li>\n\t\t<li>c.t.x.core.DefaultConverterLookup no longer uses a c.t.x.mapper.Mapper. Therefore the old constructor has\n\t\t\tbeen deprecated in favour of a default constructor.</li>\n\t\t<li>Overloaded methods of c.t.x.mapper.Mapper.getConverterFromItemType and\n\t\t\tc.t.x.mapper.Mapper.getConverterFromAttribute have been deprecated. Only one version has been kept, the\n\t\t\timplementation can handle all cases now at once and therefore multiple calls to the mapper chain are avoided.</li>\n\t\t<li>c.t.x.mapper.EnumMapper derives now from the c.t.x.mapper.AttributeMapper to support enums as attributes.\n\t\t\tTherefore the old constructor has been deprecated in favour of one taking an additional\n\t\t\tc.t.x.converters.ConverterLookup that has to be passed to the new parent.</li>\n\t</ul>\n\n\t<p class=\"highlight\">Note, to support a representation of null values in some way, it is absolutely necessary that\n\t\teach converter can handle a null value in its marshalling methods. If you have implemented your own custom converters,\n\t\ttry to handle such a case also to prevent incompatibilities in case XStream will provide such values with its next\n\t\tmajor version.</p>\n\n\t<h1 id=\"1.2.2\">Version 1.2.2</h1>\n\n\t<p>Released May 24, 2007.</p>\n\n\t<p class=\"hightlight\">Note, that next version of XStream will behave slightly different by default. XStream emits\n\t\tall fields in declaration order like Java serialization. But in contrast to Java it will omit the fields of parent\n\t\tclasses last while Java serialization emits them first. This makes it difficult to match a given XML schema that\n\t\tdefined inherited types or leads sometimes to obscure initialization problems. However, XStream itself will not be\n\t\taffected by the changed order of elements in the XML, any deserialization of current XML representations will work\n\t\tfine. Anyway we will provide with XStream 1.3 a FieldKeySorter implementation that mimics the old behaviour. In the\n\t\tmeanwhile you can enforce the new field sorting by installing the NaturalFieldKeySorter.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-391, Support for writing (and reading) JSON by the new JettisonMappedXmlDriver (by Dejan Bosanac).</li>\n\t\t<li>New FieldKeySorter interface allows a custom sort order of the XML elements.</li>\n\t\t<li>JIRA:XSTR-68 and JIRA:XSTR-210, OmitField is now respected at deserialization to ignore removed fields.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-387, Fix aliasing of inherited fields.</li>\n\t\t<li>JIRA:XSTR-395, Fix StringConverter allocating PermGen space.</li>\n\t\t<li>JIRA:XSTR-368, @XStreamConverter converters should be cached inside the AnnotationReflectionConverter.</li>\n\t\t<li>JIRA:XSTR-392, @XStreamOmitField can be used to omit fields from the resulting XML (contributed by Chung-Onn\n\t\t\tCheong).</li>\n\t\t<li>JIRA:XSTR-371, Fix JSONWriter that omits a closing bracket for for fields with null value.</li>\n\t\t<li>JIRA:XSTR-398, DomDriver ignores given XmlFriendlyReplacer.</li>\n\t\t<li>JIRA:XSTR-370, Buildable with JDK 6, fix FontConverter for JDK 6.</li>\n\t\t<li>JIRA:XSTR-382, Support hex and octal number values.</li>\n\t\t<li>DateConverter did not respect change in TimeZone after first usage.</li>\n\t\t<li>JIRA:XSTR-375, Support for aliasing native types.</li>\n\t\t<li>JIRA:XSTR-243 again, XML elements for transient fields are now ignored completely at deserialization.</li>\n\t\t<li>Release unused object references to keep memory print low.</li>\n\t\t<li>Support for AWT and SQL is now optional: XStream now works on embedded virtual machines lacking such APIs (by\n\t\t\tNicolas Gros d'Aillon).</li>\n\t\t<li>Support raw bytes read from the ObjectInputStream.</li>\n\t\t<li>JIRA:XSTR-373, Support for Hitachi JVM (tested by Yuji Yamano).</li>\n\t\t<li>JIRA:XSTR-378 and JIRA:XSTR-379, Fix TextAttributeConverter and EnumSetConverter failing on Apache Harmony.</li>\n\t\t<li>JIRA:XSTR-363, Support of native field order i.e. fields are processed in declaration order base classes\n\t\t\tfirst.</li>\n\t\t<li>JIRA:XSTR-320, Static field in child may hide non-static field in parent.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-365, Multiple implicit collections with annotations. Deprecated @XStreamImclicitCollection in\n\t\t\tfavour of @XStreamImplicit declared at field level.</li>\n\t</ul>\n\n\t<h1 id=\"1.2.1\">Version 1.2.1</h1>\n\n\t<p>Released November 11, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Introduced DocumentWriter interface and generalized functionality for all writer implementations creating a\n\t\t\tDOM structure (DOM4J, DOM, JDom, Xom, Xpp3Dom).</li>\n\t\t<li>Refactored build system to use Maven 2. Ant still supported on XStream Core.</li>\n\t\t<li>Created separate XStream Benchmark module</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-346, XStream.getClassMapper() does not return a ClassMapper for the current Mapper.</li>\n\t\t<li>Fix problem with fields containing a double underscore.</li>\n\t\t<li>JIRA:XSTR-345, Dom4JWriter adds up attributes.</li>\n\t\t<li>JIRA:XSTR-336, XStream fails to reference an implicit element.</li>\n\t\t<li>JIRA:XSTR-337, Annotation cycle bug.</li>\n\t\t<li>Fix packaging error for the resulting jar building with Maven2.</li>\n\t\t<li>JIRA:XSTR-339, NPE for attribute null values.</li>\n\t\t<li>JIRA:XSTR-338, NPE in JSON writer for converters using non-extended HierarchicalStreamWriter.</li>\n\t\t<li>JIRA:XSTR-357, Fix escaping of values in JSON writer.</li>\n\t\t<li>JIRA:XSTR-356, Fix unmarshaling error for fields containing proxies.</li>\n\t\t<li>JIRA:XSTR-349, Fix backward compatibility of Dom4jWriter.</li>\n\t\t<li>JIRA:XSTR-309, More versatile boolean conversion options (contributed by David Blevins).</li>\n\t\t<li>Add XStream.getReflectionProvider() to retrieve ReflectionProvider in use.</li>\n\t\t<li>JIRA:XSTR-358, @XStreamConverter annotation does not call converter constructor.</li>\n\t\t<li>Website generated using <a href=\"http://xsite.codehaus.org\">XSite</a></li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Deprecate JDomWriter.getResult() in favour of DocumentWriter.getTopLevelNodes().</li>\n\t\t<li>Deprecate ThreadSafeSimpleDateFormat, since this is an internal helper and not part of XStream API.</li>\n\t</ul>\n\n\t<h1 id=\"1.2\">Version 1.2</h1>\n\n\t<p>Released August 18, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-269, Using attributes for fields (contributed by Paul Hammant and Ian Cartwright).</li>\n\t\t<li>Aliasing of arbitrary attributes.</li>\n\t\t<li>JIRA:XSTR-50, XStream can now serialize another XStream instance.</li>\n\t\t<li>JIRA:XSTR-227, XStream has now the XStreamer, that serializes an object together with its XStream instance.</li>\n\t\t<li>JIRA:XSTR-278, AnnotationConverter for fields (contributed by Guilherme Silveira).</li>\n\t\t<li>JIRA:XSTR-256, PureJavaReflectionProvider supports now final fields starting with JDK 1.5</li>\n\t\t<li>JIRA:XSTR-258, Any Collection type can now be declared implicit, the default implementation will be respected\n\t\t\tfor unmarshaling.</li>\n\t\t<li>JIRA:XSTR-88, XStream can now write all references as absolute XPath expression.</li>\n\t\t<li>JIRA:XSTR-62 and JIRA:XSTR-211, New SingeValueConverter allows light weight converters if the value can be\n\t\t\trepresented by a unique string.</li>\n\t\t<li>Aliasing of classes of a specific type.</li>\n\t\t<li>JIRA:XSTR-239, Support for certain types of proxies generated with the CGLIB Enhancer.</li>\n\t\t<li>JIRA:XSTR-90 and JIRA:XSTR-311, Support for BEA JRockit starting with R25.1.0 (contributed by Henrik\n\t\t\tSt&aring;hl of BEA).</li>\n\t</ul>\n\n\t<h2>Technology preview</h2>\n\n\t<ul>\n\t\t<li>Experimental binary reader and writer.</li>\n\t\t<li>Experimental HierarichicalStreamCopier allows streams to be copied from one format to another without the\n\t\t\toverhead of serialization.</li>\n\t\t<li>Experimental JSON support allows streams to be copied from one format to another without the overhead of\n\t\t\tserialization (contributed by Paul Hammant).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-266, XStream fails to serialize elements of a unserializable class, that is a base class of a\n\t\t\tderived class</li>\n\t\t<li>JIRA:XSTR-236, Priority constants for converter registration are now public</li>\n\t\t<li>JIRA:XSTR-215, XStream writes now fields in declaration order even for JVMs reporting them in reverse order\n\t\t\tlike IBM JDK.</li>\n\t\t<li>JIRA:XSTR-276 and JIRA:XSTR-283, XStream does no longer attempt to create references to implicit element.</li>\n\t\t<li>JIRA:XSTR-244, Closing a Writer can now be done twice, but any write attempt will later on fail.</li>\n\t\t<li>JIRA:XSTR-243, Transient fields were unmarshalled from XML.</li>\n\t\t<li>JIRA:XSTR-250, Providing a mapper to the XStream constructor will no longer result in a NPE.</li>\n\t\t<li>JIRA:XSTR-281, After registering a new converter, the internal converter cache is now cleared.</li>\n\t\t<li>JIRA:XSTR-284, XStream checks the object returned by a converter for compatibility.</li>\n\t\t<li>XStream no longer fails serializing a Throwable without cause when no references shall be written.</li>\n\t\t<li>Converter for java.awt.font.TextAttribute.</li>\n\t\t<li>Converter for java.nio.charset.Charset.</li>\n\t\t<li>JIRA:XSTR-286, XStream detects impossible self serialization and throws now an appropriate\n\t\t\tConversionException.</li>\n\t\t<li>JIRA:XSTR-291, XomDriver implementation added.</li>\n\t\t<li>JIRA:XSTR-299, Fix for implicit collections with items using the same name as the field name of the\n\t\t\tunderlying collection.</li>\n\t\t<li>JIRA:XSTR-245, Broken XML with custom serialization in certain cases (patch contributed by Cyrille Le Clerc).</li>\n\t\t<li>JIRA:XSTR-304, Bad handling of repairing namespace flag for StaxDriver (patch contributed by John Kristian).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-252, Refactored support for XML friendly character mapping.</li>\n\t\t<li>JIRA:XSTR-69, Refactored ReflectionConverter allows simpler subclassing.</li>\n\t\t<li>Unmarshalling context has now an overloaded version of the method convertAnother to provide the Converter\n\t\t\tdirectly.</li>\n\t\t<li>Deprecate ClassMapper for Mapper. All methods with a ClassMapper parameter have now a duplicate taking only a\n\t\t\tMapper. The variant with the ClassMapper is deprecated.</li>\n\t\t<li>Deprecate c.t.x.alias.CannotResolveClassException for c.t.x.mapper.CannotResolveClassException.</li>\n\t\t<li>Deprecate NameMapper (was not used within XStream anymore anyway).</li>\n\t\t<li>Deprecate constructor of DefaultMapper taking an alternative name for the class attribute. Use the\n\t\t\taliasAttribute method.</li>\n\t\t<li>Deprecate attributeForImplementationClass, attributeForClassDefiningField, attributeForReadResolveField, and\n\t\t\tattributeForEnumType in favour of the generalized aliasForAttribute in the Mapper interface.</li>\n\t\t<li>Removed all deprecated stuff from 1.1.x and 1.0.x</li>\n\t\t<li>JIRA:XSTR-211, A lot of existing (basic) Converters have been refactored to use the new SingleValueConverter\n\t\t\tinterface.</li>\n\t\t<li>Dom4JWriter uses now a DocumentFactory and a XMLWriter as constructor arguments.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.3\">Version 1.1.3</h1>\n\n\t<p>Released January 13, 2006.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Added XStream.toXML(OutputStream) and XStream.fromXML(InputStream).</li>\n\t\t<li>Ability to prevent fields from being serialized by calling XStream.omitField() or by implementing\n\t\t\tMapper.shouldSerializeMember().</li>\n\t\t<li>Added Converter for Enum, EnumMap and EnumSet</li>\n\t\t<li>JIRA:XSTR-186, Added BeanConverter (contributed by Andrea Aime)</li>\n\t\t<li>JIRA:XSTR-246, Added ISO8601SqlTimestampConverter (contributed by Cheong, Chung-Onn)</li>\n\t\t<li>Added ISO8601GregorianCaledarConverter</li>\n\t\t<li>JIRA:XSTR-215, Fixed support for IBM JVM (contributed by Gabor Liptak)</li>\n\t\t<li>Enhanced mode support for Blackdown JDK</li>\n\t\t<li>JIRA:XSTR-265, support for javax.security.auth.Subject</li>\n\t\t<li>JIRA:XSTR-233, support for Integer[] arrays</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Remove unnecessary PrintWriter wrapper in default writers (pointed out by Mathieu Champlon)</li>\n\t\t<li>Bugfix: EnumSet converter can now deal with empty sets (contributed by Baba Buehler)</li>\n\t\t<li>Update ISO8601DateConverter to use Joda 1.0</li>\n\t\t<li>JIRA:XSTR-242, GregorianCalenderConverter saves now the timezone</li>\n\t\t<li>JIRA:XSTR-247, ISO8601DateConverter now independent on timezone</li>\n\t\t<li>JIRA:XSTR-263, Circular references with Externalizable objects fail</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.2\">Version 1.1.2</h1>\n\n\t<p>Released April 30, 2005. Most popular feature requests implemented. Java 5 Enum support. Serialization of\n\t\tJavaBeans using accessors. Aliasing of fields. StAX integration, with namespaces. Improved support on JDK 1.3 and IBM\n\t\tJDK.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-186, Option to serialize JavaBeans using public accessors, rather than private fields (contributed\n\t\t\tby Andrea Aime).</li>\n\t\t<li>Ability to alias fields as well as classes, using XStream.addFieldAlias().</li>\n\t\t<li>JIRA:XSTR-70, JIRA:XSTR-204 Support for JDK 5 enums (contributed by Eric Snell and Bryan Coleman).</li>\n\t\t<li>JIRA:XSTR-206 Clean representation of JDK 5 EnumMap and EnumSet.</li>\n\t\t<li>XStream can now be built using JDK 1.3 (previously it required JDK 1.4 to compile, but 1.3 to run).</li>\n\t\t<li>JIRA:XSTR-215, Enhanced mode is now supported on the IBM 1.4 JDK.</li>\n\t\t<li>The default HierarchicalStreamWriter implementation is supplied by the HierarichicalStreamDriver (as well as\n\t\t\tthe reader).</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JIRA:XSTR-104 HierarchicalStreamReader now exposes all available attributes to the Converter implementations\n\t\t\t(contributed by Trygve Laugstol).</li>\n\t\t<li>Bugfix: Externalizable deserialization supported for objects not at the root of tree.</li>\n\t\t<li>JavaMethodConverter handles non public methods/constructors (contributed by Kevin Ring).</li>\n\t\t<li>PropertiesConverter also serializes default properties, if present (contributed by Kevin Ring).</li>\n\t\t<li>Bugfix: In some cases, XppReader and StaxReader would get confused when calling hasMoreChildren() and\n\t\t\tgetValue() on the same node.</li>\n\t\t<li>JIRA:XSTR-217, ISO8601DateConverter now requires joda-time-1.2.1</li>\n\t\t<li>PrettyPrintWriter and CompactWriter may have their text/attribute escaping rules customized by overriding\n\t\t\twriteText() and writeAttributeValue().</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>HierarchicalStreamDriver implementations now require a createWriter() method. The simplest implementation is\n\t\t\tto return a new PrettyPrintWriter.</li>\n\t\t<li>Introduced ReaderWrapper/WriterWrapper classes to make it easier to wrap (decorate)\n\t\t\tHierarchicalStreamReader/Writer instances.</li>\n\t</ul>\n\n\t<h1 id=\"1.1.1\">Version 1.1.1</h1>\n\n\t<p>Released March 7, 2005. Mostly bugfixes and minor feature enhancements.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Converters can be registered with a priority, allowing more <i>generic</i> filters to handle classes that\n\t\t\tdon't have more specific converters.\n\t\t</li>\n\t\t<li>Converters can now access underlying HierarchicalStreamReader/Writer implementations to make implementation\n\t\t\tspecific calls.</li>\n\t\t<li>Improved support for classes using ObjectInputFields to follow the serialization specification.</li>\n\t\t<li>JIRA:XSTR-179 Support for ObjectInputStream.registerValidation(ObjectInputValidation).</li>\n\t\t<li>JIRA:XSTR-178 Serialized inner class now maintains reference to outer class.</li>\n\t\t<li>JIRA:XSTR-199 Default ClassLoader may be changed using XStream.setClassLoader().</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Bugfix: Thread context classloader is loaded by the correct thread. (Thanks to Padraic Renaghan for pointing\n\t\t\tthis out).</li>\n\t\t<li>Bugfix: Default implementations of aliased classes were not being deserialized by SerializableConverter.</li>\n\t\t<li>Bugfix: JIRA:XSTR-180 Serializable objects support defaultReadObject() even when no default fields available.</li>\n\t\t<li>Bugfix: For serialized objects class hierarchy is serialized starting with superclass (as per Java Object\n\t\t\tSerialization).</li>\n\t\t<li>Bugfix: readObject() is now called for classes containing only transient fields.</li>\n\t\t<li>Bugfix: Order of fields are maintained when calling ObjectOutputStream.putFields().</li>\n\t\t<li>Bugfix: FontConverter extended to support FontUIResource which does some awkward native calls.</li>\n\t\t<li>Bugfix: Deserialization of very complicated graphs (such as Swing components) sometimes resulted in broken\n\t\t\tobject references. Now fixed.</li>\n\t\t<li>Bugfix: JIRA:XSTR-188 Classes that use readResolve()/writeReplace() can now return different types.</li>\n\t\t<li>Bugfix: JIRA:XSTR-185, JIRA:XSTR-195 Support for loading of array classes for classes that have not yet been\n\t\t\tloaded. (Thanks to Henri Tremblay and Simon Daniel)</li>\n\t\t<li>Bugfix: JIRA:XSTR-190 PrettyPrintWriter and CompactWriter escape characters in XML attributes.</li>\n\t\t<li>Bugfix: JIRA:XSTR-176, JIRA:XSTR-196 The XStream ObjectInputStream and ObjectOutputStream implementations now\n\t\t\tpropegate the flush() and close() events to the underlying streams.</li>\n\t\t<li>Bugfix: JIRA:XSTR-192 Implicit collection mappings are now supported in inheritance hierarchies.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>ClassMapper is now deprecated. Replaced with MapperWrapper.</li>\n\t\t<li>HierarchicalStreamWriter implementations must now implement close(), flush() and underlyingWriter().</li>\n\t\t<li>HierarchicalStreamReader implementations must now implement close() and underlyingReader().</li>\n\t</ul>\n\n\t<h1 id=\"1.1\">Version 1.1</h1>\n\n\t<p>\n\t\tReleased January 15, 2005. Focus on support for objects defining custom serialization using the standard <a\n\t\t\thref=\"http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/serialTOC.html\">Java serialization</a> mechanism.\n\t</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Provides drop in replacement for ObjectInputStream and ObjectOutputStream, using\n\t\t\tXStream.createObjectInputStream() and XStream.createObjectOutputStream() and XStream.createObjectInputStream(). This\n\t\t\tprovides support for streaming objects.</li>\n\t\t<li>Support for objects that specify their own serialization schemes by implementing readObject() and\n\t\t\twriteObject() (as in Java serialization spec). This includes support for ObjectInputStream.getFields() and\n\t\t\tObjectOuputStream.putFields().</li>\n\t\t<li>Support for objects to serialize other objects to the stream by implementing writeReplace() (as in Java\n\t\t\tserialization spec).</li>\n\t\t<li>Support for any object that performs custom serialization by implementing java.io.Externalizable (as in Java\n\t\t\tserialization spec).</li>\n\t\t<li>Implicit collections can be specified for classes, allowing the element wrapping the collection to be\n\t\t\tskipped.</li>\n\t\t<li>New writer implementations to allow XStream to serialize directly to a SAX stream or TrAX pipeline.</li>\n\t\t<li>The MarshallingContext and UnmarshallingContext interfaces now extend DataHolder, allowing arbitrary data to\n\t\t\tbe stored by the user whilst walking the object graph and passed around to Converters. DataHolders can also be passed\n\t\t\tinto XStream from the outside.</li>\n\t\t<li>Includes new DomWriter implementation to serialize directly to a W3C DOM tree (to complement the existing\n\t\t\tDomReader).</li>\n\t\t<li>Better support for instantiating objects on non Sun 1.4+ JVMs, including non-public constructors, private\n\t\t\tstatic inner classes and ANY class that implements java.io.Serializable.</li>\n\t\t<li>DOM, DOM4J, JDOM, XOM, Electric-XML, SAX, STAX</li>\n\t\t<li>Specific ClassLoaders can be passed into XStream, to allow for greater compatibility in J2EE containers.</li>\n\t\t<li>Ability to change the default converter</li>\n\t\t<li>Added optional ISO8601DateConverter for full ISO8601 date format support. The converter is not registered by\n\t\t\tdefault as it requires the joda-time dependency (http://joda-time.sf.net). To use, ensure joda-time is in classpath\n\t\t\tand register explicitly.</li>\n\t\t<li>Enhanced mode is now supported on the Apple 1.4 JDK.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>PrettyPrintWriter only flushes stream when necessary - large performance improvement for serialization.</li>\n\t\t<li>Added XStream.fromXml(xml, root) convenience methods for deserializing into an existing root object.</li>\n\t\t<li>JDK 1.3 compatibility: Added mechanism for accessing nested exception.</li>\n\t\t<li>JDK 1.3 compatibility: GregorianCalendarConverter only calls Calendar.getTimeInMillis() the JDK supports it.</li>\n\t\t<li>Bugfix: All caches are now synchronized - there were some thread safety issues.</li>\n\t\t<li>Bugfix: Only <i>immutable</i> basic types will have references ignored in XML (for clarity).\n\t\t</li>\n\t\t<li>Bugfix: Class names can contain underscores.</li>\n\t\t<li>Bugfix: Support for '\\0' char.</li>\n\t\t<li>Bugfix: PropertyConverter no longer attempts to serialize subclasses of Properties.</li>\n\t\t<li>Bugfix: JVM detection uses system properties, which is more accurate than searching the classpath.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>XStream.addDefaultCollection() has been deprecated. Use XStream.addImplicitCollection() instead.</li>\n\t</ul>\n\n\t<h1 id=\"1.0.2\">Version 1.0.2</h1>\n\n\t<p>Released August 7, 2004. Focus on improving the converters bundled with XStream to support a wider range of\n\t\ttypes.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>XML elements are written in order they are defined in class, rather than alphabetical.</li>\n\t\t<li>Converters for java.io.File, java.sql.Timestamp, java.awt.Color, and dynamic proxies are now registered by\n\t\t\tdefault.</li>\n\t\t<li>EncodedByteArrayConverter is now registered by default and uses a single Base64 string to store the contents\n\t\t\tof a byte[]. This now works on all JVMs as it no longer relies on Sun specific classes. This converter will also\n\t\t\tunmarshal byte[] that have been serialized without it, for backwards compatability.</li>\n\t\t<li>New converters for java.sql.Time, java.sql.Date, java.util.Locale, java.util.Currency, java.util.Calendar and\n\t\t\tjava.awt.Font.</li>\n\t\t<li>All caching is done in XStream instance instead of statics, allowing applications that use hot redeployment\n\t\t\tof classes to use XStream in a parent classloader.</li>\n\t\t<li>XStream will fail fast if a field value is defined more than once in XML when deserializing.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>The &lt;entry&gt; element used in Maps can now be specified by creating an alias for java.util.Map.Entry.</li>\n\t\t<li>Bugfix: Fields with characters that generate invalid XML (such as $ signs) are now escaped.</li>\n\t\t<li>Bugfix: Pre-instantiated objects can be unmarshalled through multiple levels.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"1.0.1\">Version 1.0.1</h1>\n\n\t<p>Released May 30, 2004. Misc features and bugfixes.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Support for multidimensional arrays.</li>\n\t\t<li>Object with readResolve() method will be treated the same way native serialization treats them.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>New converters for Throwable and StackTraceElement that retain stack trace (JDK 1.4 only)</li>\n\t\t<li>Bugfix: System.identityHashCode() is not guaranteed to be unique. Ensure reference checking is used as well.</li>\n\t\t<li>Bugfix: Allows user classes to be defined in WEB-INF/classes in Servlet environments. Tries to use context\n\t\t\tclassloader if available.</li>\n\t\t<li>Support for java.util.Currency (through readResolve()).</li>\n\t\t<li>Instances of Jakarta Commons Lang Enum are now reused (through readResolve()).</li>\n\t\t<li>Bugfix: JavaClassConverter handles primitive type classes (contributed by Matthew Sandoz).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Additional method: ConverterLookup.defaultConverter(). Custom implementations of this class should implement\n\t\t\tthis new method.</li>\n\t</ul>\n\n\t<h1 id=\"1.0\">Version 1.0</h1>\n\n\t<p>Released May 14, 2004. Focusses on finalizing the API for 1.0 release.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Supports fields of same name, hidden by inheritance.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>JavaDoc for most important parts of API.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>The ReflectionConverter and ReflectionProviders have had an overhaul to support hidden fields. Most methods\n\t\t\tnow take an extra argument to specify which class a field is declared in.</li>\n\t</ul>\n\n\t<h1 id=\"1.0RC1\">Version 1.0 (release candidate 1)</h1>\n\n\t<p>Released May 9, 2004. Focusses on finalizing the API for 1.0 release.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>JDK 1.3 compatibility.</li>\n\t\t<li>Informative error messages.</li>\n\t\t<li>Defaults to using faster XPP based parser.</li>\n\t\t<li>Serializes final field under JDK 1.4.</li>\n\t\t<li>Fail fast when trying to serialize final field if not Sun 1.4 JRE.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Misc performance improvements.</li>\n\t\t<li>Converters for TreeMap and TreeSet that store the Comparator.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Default constructor for XStream class uses XppDriver instead of DomDriver. To use DomDriver, explicitly pass\n\t\t\tit in to the constructor.</li>\n\t\t<li>Exception is thrown if trying to serialize an object that contains a final field if not Sun 1.4 JRE.</li>\n\t</ul>\n\n\t<p>\n\t\t<a href=\"versioning.html\">About XStream version numbers...</a>\n\t</p>\n\n\t<h1 id=\"0.6\">Version 0.6</h1>\n\n\t<p>Released May 7, 2004. Focusses on providing full object graph support.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Bugfix: Objects that had no children could not be derefenced properly (thanks to Brian Slesinsky and Nick\n\t\t\tPomfret).</li>\n\t\t<li>Bugfix: DateConverter is now thread safe.</li>\n\t\t<li>Optimization: String instances are reused as much as possible.</li>\n\t\t<li>Converters for BigInteger and BigDecimal.</li>\n\t\t<li>IntConverter now recognises hexadecimal and octal notations (thanks to Konstantin Pribluda).</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"0.6RC1\">Version 0.6 (release candidate 1)</h1>\n\n\t<p>Released April 19, 2004. Focusses on providing full object graph support.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Full support for object graphs, including duplicate references of same object and circular references.</li>\n\t\t<li>References can be identified using XPath (default), unique-IDs or disabled.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Release includes Ant build file.</li>\n\t\t<li>Converters for non standard collections such as Collections.EMPTY_LIST, syncronizedList(), unmodifiableMap(),\n\t\t\tetc.</li>\n\t\t<li>Converter for nulls.</li>\n\t\t<li>Converter for dynamic proxies.</li>\n\t\t<li>Converter for java.net.URL.</li>\n\t\t<li>Converters for java.util.LinkedHashMap and java.util.LinkedHashSet.</li>\n\t\t<li>Converters for java.lang.reflect.Method and java.lang.reflect.Constructor.</li>\n\t\t<li>If duplicate reference support is disabled and a circular reference is encountered, an exception will be\n\t\t\tthrown.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>None.</li>\n\t</ul>\n\n\t<h1 id=\"0.5\">Version 0.5</h1>\n\n\t<p>Released March 8, 2004. Focussed on performance.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Massive performance improvements. Up to 3 times faster for serialization and 22 times faster for\n\t\t\tdeserialization!</li>\n\t\t<li>Non-DOM building pull parser based reader. Results in much smaller memory footprint, particularly when\n\t\t\tdeserializing large object models.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Misc performance improvements.</li>\n\t\t<li>Misc bugfixes.</li>\n\t\t<li>Alternate encodings can be used with DomDriver.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Renamed XMLReader/Writer to HierarchicalStreamReader/Writer as XStream is not actually coupled to serializing\n\t\t\tjust to XML.</li>\n\t\t<li>Cleaned up the public API.</li>\n\t\t<li>Moved internal XStream implementation classes to core package.</li>\n\t\t<li>Misc package/class renames to make more sense. Dumped lots of dead code.</li>\n\t</ul>\n\n\t<h1 id=\"0.4\">Version 0.4</h1>\n\n\t<p>This version was never publicly released. All changes were made available in 0.5. Focussed on making it easier\n\t\tto create custom converters.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Overhaul of interface for Converters. Makes Converters much cleaner to write.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added custom converters for java.io.File, java.util.Properties, java.util.Vector, java.util.Hashtable,\n\t\t\tjava.util.BitSet byte[] (Base64 encoded), char[].</li>\n\t\t<li>Misc bugfixes.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>New interface to be implemented by custom converters.</li>\n\t</ul>\n\n\t<h1 id=\"0.3\">Version 0.3</h1>\n\n\t<p>Released January 1, 2004.</p>\n\n\t<h2>Major changes</h2>\n\n\t<ul>\n\t\t<li>Added ElementMapper interface and default implementations to allow fine grained control over element name to\n\t\t\tclass mapper operations.</li>\n\t\t<li>Added an XPP based reader and writer that uses a pull-parser to create a lightweight DOM tree.</li>\n\t</ul>\n\n\t<h2>Minor changes</h2>\n\n\t<ul>\n\t\t<li>Added XStream.fromXML(XMLReader xmlReader,Object root) method to allow the population of an object graph\n\t\t\tstarting with a live object root.</li>\n\t\t<li>Added XMLReader.peek() method to allow access to the underlying hierarchical object being unmarshalled.</li>\n\t</ul>\n\n\t<h2>API changes</h2>\n\n\t<ul>\n\t\t<li>Aligned the the methods in XStream to use the specified ObjectFactory in the constructor instead of creating\n\t\t\ta SunReflectionObjectFactory.</li>\n\t</ul>\n\n\t<h1 id=\"older\">Older versions</h1>\n\n\t<p>Changes in XStream prior to version 0.3 were not logged.</p>\n\n</body>\n</html>\n", "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2020 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Aliasing classes</h3>\n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code> method. For example, you\n * can shorten all occurrences of element <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by\n * registering an alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Converters</h3>\n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each of which acts as a\n * strategy for converting a particular type of class to XML and back again. Out of the box, XStream contains converters\n * for most basic types (String, Date, int, boolean, etc) and collections (Map, List, Set, Properties, etc). For other\n * objects reflection is used to serialize each field recursively.\n * </p>\n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some non-standard converters\n * are supplied in the {@link com.thoughtworks.xstream.converters.extended} package and you can create your own by\n * implementing the {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with\n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence they have been registered.\n * The default converter, i.e. the converter which will be used if no other registered converter is suitable, can be\n * registered with priority XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback converter.\n * </p>\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <h3>Object graphs</h3>\n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact, including circular\n * references.\n * </p>\n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML with the least\n * clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that a single node\n * only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references. The XPath expression ensures that a single node\n * only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using hand-written XML, this\n * is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate references are treated\n * as two separate objects and circular references cause an exception. This is slightly faster and uses less memory than\n * the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and configured, it may be\n * shared across multiple threads allowing objects to be serialized/deserialized concurrently. <em>Note, that this only\n * applies if annotations are not auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one of the\n * <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean securityInitialized;\n    private transient boolean securityWarningGiven;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n    private static final Pattern LAZY_ITERATORS = Pattern.compile(\".*\\\\$LazyIterator\");\n    private static final Pattern JAVAX_CRYPTO = Pattern.compile(\"javax\\\\.crypto\\\\..*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best match for the\n     * {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and a prepared\n     * {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and a\n     * {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider} and the\n     * {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain and the {@link ClassLoader} to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader,\n            Mapper mapper) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain and the {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n\n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain, the {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader,\n            Mapper mapper, ConverterLookup converterLookup, ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup,\n            converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}, {@link ReflectionProvider}, a prepared\n     * {@link Mapper} chain, the {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup should access the\n     * ConverterRegistry if you intent to register {@link Converter} instances with XStream facade or you are using\n     * annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em> to prevent any further\n     *            registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n            ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n            ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class, ClassLoaderReference.class,\n                ReflectionProvider.class}, new Object[]{\n                    mapper, converterRegistry, converterLookup, classLoaderReference, reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n            Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate mapper : \" + className,\n                e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate mapper : \" + className,\n                e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper.lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper.lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper.lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper.lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper.lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper.lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper.lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper.lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n\n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\"java.beans.EventHandler\", \"javax.imageio.ImageIO$ContainsFilter\"});\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (!xstream.securityInitialized) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n\n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n\n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class}, new Object[]{converterLookup});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority, Class[] constructorParamTypes,\n            Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className,\n                e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className,\n                e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[]{String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n\n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed afterwards and in case\n     * of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream will be flushed afterwards\n     * and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you want. If not present,\n     *            XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL. Depending on the parser implementation, some might take the file path as\n     * SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file. Depending on the parser implementation, some might take the file path as\n     * SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object instead of instantiating\n     * a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into\n     * the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object instead of instantiating\n     * a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into\n     * the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root object instead of instantiating a new\n     * one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care! Depending on the parser implementation, some might take the\n     * file path as SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root object instead of instantiating a new\n     * one. Note, that this is a special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care! Depending on the parser implementation, some might take the\n     * file path as SystemId to resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root object instead of\n     * instantiating a new one. Note, that this is a special use case! With the ReflectionConverter XStream will write\n     * directly into the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With the ReflectionConverter\n     * XStream will write directly into the raw memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed to XStream creating a new\n     *            instance. Note, that this is a special use case! With the ReflectionConverter XStream will write\n     *            directly into the raw memory area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you want. If not present,\n     *            XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (!securityInitialized && !securityWarningGiven) {\n                securityWarningGiven = true;\n                System.err\n                    .println(\n                        \"Security framework of XStream not explicitly initialized, using predefined black list on your own risk.\");\n            }\n            return marshallingStrategy.unmarshal(root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable to this type will be\n     * aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no {@link ClassAliasingMapper} is\n     *             available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no {@link PackageAliasingMapper} is\n     *             available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its alias is set to\n     * <code>null</code>. However, this is not reversible, i.e. deserialization of the result is likely to fail\n     * afterwards and will not produce an object equal to the originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters an instance of this\n     * type, it will use the default implementation instead. For example, java.util.ArrayList is the default\n     * implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, SingleValueConverter converter) {\n        registerLocalConverter(definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are <code>XPATH_ABSOLUTE_REFERENCES</code>,\n     * <code>XPATH_RELATIVE_REFERENCES</code>, <code>XStream.ID_REFERENCES</code> and\n     * <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(ReferenceByXPathMarshallingStrategy.RELATIVE\n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(ReferenceByXPathMarshallingStrategy.ABSOLUTE\n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete collection type or matching\n     *            the default implementation type of the collection type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName, Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the array type does not\n     *             match the itemType\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4\n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete map type or matching the\n     *            default implementation type of the map type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4\n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete map type or matching the\n     *            default implementation type of the map type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4\n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, Class itemType,\n            String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer) throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName) throws IOException {\n        return createObjectOutputStream(hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single root node, the stream must\n     * be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder)\n            throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, null, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority) throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will register for all kind\n     * of classes and types of the current JDK, but not for any 3rd party type. To ensure that all other types are\n     * loaded with your class loader, you should call this method as early as possible - or consider to provide the\n     * class loader directly in the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n\n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other XStream components (like\n     * converters) to ensure that they will use a changed ClassLoader instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the declaring type and not\n     * necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n\n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \" + ANNOTATION_MAPPER_TYPE + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this method will automatically\n     * turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies that the XStream is\n     * configured while it is processing the XML steams. This is a potential concurrency problem. Also is it technically\n     * not possible to detect all class aliases at deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n\n    /**\n     * Add a new security permission.\n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            securityInitialized |= permission.equals(NoTypePermission.NONE) || permission.equals(AnyTypePermission.ANY);\n            securityMapper.addPermission(permission);\n        }\n    }\n\n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n\n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n\n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like\n     * 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and\n     * subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n\n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n\n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n\n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n\n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n\n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like\n     * 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and\n     * subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    private Object readResolve() {\n        securityWarningGiven = true;\n        return this;\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException} instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)} instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n}\n", "/*\n * Copyright (C) 2013, 2014, 2017, 2018, 2020 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n * \n * Created on 23. December 2013 by Joerg Schaible\n */\npackage com.thoughtworks.acceptance;\n\nimport java.beans.EventHandler;\nimport java.util.Iterator;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.XStreamException;\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ForbiddenClassException;\n\n\n/**\n * @author J&ouml;rg Schaible\n */\npublic class SecurityVulnerabilityTest extends AbstractAcceptanceTest {\n\n    private final static StringBuffer BUFFER = new StringBuffer();\n\n    protected void setUp() throws Exception {\n        super.setUp();\n        BUFFER.setLength(0);\n        xstream.alias(\"runnable\", Runnable.class);\n    }\n\n    protected void setupSecurity(XStream xstream) {\n    }\n\n    public void testCannotInjectEventHandler() {\n        final String xml = \"\"\n            + \"<string class='runnable-array'>\\n\"\n            + \"  <dynamic-proxy>\\n\"\n            + \"    <interface>java.lang.Runnable</interface>\\n\"\n            + \"    <handler class='java.beans.EventHandler'>\\n\"\n            + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n            + \"      <action>exec</action>\\n\"\n            + \"    </handler>\\n\"\n            + \"  </dynamic-proxy>\\n\"\n            + \"</string>\";\n\n        try {\n            xstream.fromXML(xml);\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            assertTrue(e.getMessage().indexOf(EventHandler.class.getName()) > 0);\n        }\n        assertEquals(0, BUFFER.length());\n    }\n\n    public void testCannotInjectEventHandlerWithUnconfiguredSecurityFramework() {\n        xstream.alias(\"runnable\", Runnable.class);\n        final String xml = \"\"\n            + \"<string class='runnable-array'>\\n\"\n            + \"  <dynamic-proxy>\\n\"\n            + \"    <interface>java.lang.Runnable</interface>\\n\"\n            + \"    <handler class='java.beans.EventHandler'>\\n\"\n            + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n            + \"      <action>exec</action>\\n\"\n            + \"    </handler>\\n\"\n            + \"  </dynamic-proxy>\\n\"\n            + \"</string>\";\n\n        try {\n            xstream.fromXML(xml);\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            assertTrue(e.getMessage().indexOf(EventHandler.class.getName()) >= 0);\n        }\n        assertEquals(0, BUFFER.length());\n    }\n\n    public void testExplicitlyConvertEventHandler() {\n        final String xml = \"\"\n            + \"<string class='runnable-array'>\\n\"\n            + \"  <dynamic-proxy>\\n\"\n            + \"    <interface>java.lang.Runnable</interface>\\n\"\n            + \"    <handler class='java.beans.EventHandler'>\\n\"\n            + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n            + \"      <action>exec</action>\\n\"\n            + \"    </handler>\\n\"\n            + \"  </dynamic-proxy>\\n\"\n            + \"</string>\";\n\n        xstream.allowTypes(new Class[]{EventHandler.class});\n\n        final Runnable[] array = (Runnable[])xstream.fromXML(xml);\n        assertEquals(0, BUFFER.length());\n        array[0].run();\n        assertEquals(\"Executed!\", BUFFER.toString());\n    }\n\n    public void testCannotInjectConvertImageIOContainsFilterWithUnconfiguredSecurityFramework() {\n        if (JVM.isVersion(7)) {\n            final String xml = \"\"\n                + \"<string class='javax.imageio.spi.FilterIterator'>\\n\"\n                + \" <iter class='java.util.ArrayList$Itr'>\\n\"\n                + \"   <cursor>0</cursor>\\n\"\n                + \"   <lastRet>1</lastRet>\\n\"\n                + \"   <expectedModCount>1</expectedModCount>\\n\"\n                + \"   <outer-class>\\n\"\n                + \"     <com.thoughtworks.acceptance.SecurityVulnerabilityTest_-Exec/>\\n\"\n                + \"   </outer-class>\\n\"\n                + \" </iter>\\n\"\n                + \" <filter class='javax.imageio.ImageIO$ContainsFilter'>\\n\"\n                + \"   <method>\\n\"\n                + \"     <class>com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec</class>\\n\"\n                + \"     <name>exec</name>\\n\"\n                + \"     <parameter-types/>\\n\"\n                + \"   </method>\\n\"\n                + \"   <name>exec</name>\\n\"\n                + \" </filter>\\n\"\n                + \" <next/>\\n\"\n                + \"</string>\";\n\n            try {\n                xstream.fromXML(xml);\n                fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n            } catch (final XStreamException e) {\n                assertTrue(e.getMessage().indexOf(\"javax.imageio.ImageIO$ContainsFilter\") >= 0);\n            }\n            assertEquals(0, BUFFER.length());\n        }\n    }\n\n    public void testExplicitlyConvertImageIOContainsFilter() {\n        if (JVM.isVersion(7)) {\n            final String xml = \"\"\n                + \"<string class='javax.imageio.spi.FilterIterator'>\\n\"\n                + \" <iter class='java.util.ArrayList$Itr'>\\n\"\n                + \"   <cursor>0</cursor>\\n\"\n                + \"   <lastRet>1</lastRet>\\n\"\n                + \"   <expectedModCount>1</expectedModCount>\\n\"\n                + \"   <outer-class>\\n\"\n                + \"     <com.thoughtworks.acceptance.SecurityVulnerabilityTest_-Exec/>\\n\"\n                + \"   </outer-class>\\n\"\n                + \" </iter>\\n\"\n                + \" <filter class='javax.imageio.ImageIO$ContainsFilter'>\\n\"\n                + \"   <method>\\n\"\n                + \"     <class>com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec</class>\\n\"\n                + \"     <name>exec</name>\\n\"\n                + \"     <parameter-types/>\\n\"\n                + \"   </method>\\n\"\n                + \"   <name>exec</name>\\n\"\n                + \" </filter>\\n\"\n                + \" <next/>\\n\"\n                + \"</string>\";\n\n            xstream.allowTypes(new String[]{\"javax.imageio.ImageIO$ContainsFilter\"});\n\n            final Iterator iterator = (Iterator)xstream.fromXML(xml);\n            assertEquals(0, BUFFER.length());\n            iterator.next();\n            assertEquals(\"Executed!\", BUFFER.toString());\n        }\n    }\n\n    public static class Exec {\n\n        public void exec() {\n            BUFFER.append(\"Executed!\");\n        }\n    }\n\n    public void testInstanceOfVoid() {\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ConversionException.class.getName() + \" expected\");\n        } catch (final ConversionException e) {\n            assertEquals(\"void\", e.get(\"construction-type\"));\n        }\n    }\n\n    public void testDeniedInstanceOfVoid() {\n        xstream.addPermission(AnyTypePermission.ANY); // clear out defaults\n        xstream.denyTypes(new Class[]{void.class, Void.class});\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ForbiddenClassException.class.getName() + \" expected\");\n        } catch (final ForbiddenClassException e) {\n            // OK\n        }\n    }\n\n    public void testAllowedInstanceOfVoid() {\n        xstream.allowTypes(new Class[]{void.class, Void.class});\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ConversionException.class.getName() + \" expected\");\n        } catch (final ConversionException e) {\n            assertEquals(\"void\", e.get(\"construction-type\"));\n        }\n    }\n\n    public static class LazyIterator {}\n\n    public void testInstanceOfLazyIterator() {\n        xstream.alias(\"lazy-iterator\", LazyIterator.class);\n        try {\n            xstream.fromXML(\"<lazy-iterator/>\");\n            fail(\"Thrown \" + ForbiddenClassException.class.getName() + \" expected\");\n        } catch (final ForbiddenClassException e) {\n            // OK\n        }\n    }\n}\n"], "filenames": ["xstream-distribution/src/content/changes.html", "xstream/src/java/com/thoughtworks/xstream/XStream.java", "xstream/src/test/com/thoughtworks/acceptance/SecurityVulnerabilityTest.java"], "buggy_code_start_loc": [29, 645, 13], "buggy_code_end_loc": [29, 646, 144], "fixing_code_start_loc": [30, 645, 14], "fixing_code_end_loc": [38, 646, 206], "type": "CWE-78", "message": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14.", "other": {"cve": {"id": "CVE-2020-26217", "sourceIdentifier": "security-advisories@github.com", "published": "2020-11-16T21:15:12.893", "lastModified": "2022-10-28T17:40:05.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14."}, {"lang": "es", "value": "XStream anterior a versi\u00f3n 1.4.14, es vulnerable a una ejecuci\u00f3n de c\u00f3digo remota. La vulnerabilidad puede permitir a un atacante remoto ejecutar comandos de shell arbitrarios solo manipulando el flujo de entrada procesado.&#xa0;Solo los usuarios que dependen de las listas de bloqueo est\u00e1n afectados.&#xa0;Cualquiera que utilice la lista de permitidos del Security Framework de XStream no estar\u00e1 afectado.&#xa0;El aviso vinculado proporciona soluciones de c\u00f3digo para usuarios que no pueden actualizar.&#xa0;El problema se corrigi\u00f3 en la versi\u00f3n 1.4.14"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xstream_project:xstream:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.14", "matchCriteriaId": "6CBAEE8A-07B9-4367-A98E-E03F33732D7E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapmanager:*:*:*:*:*:sap:*:*", "matchCriteriaId": "D8668AF8-DA10-45F2-AB8C-432640D52C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapmanager:-:-:*:*:*:oracle:*:*", "matchCriteriaId": "25BBBC1A-228F-45A6-AE95-DB915EDF84BD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:activemq:5.15.4:*:*:*:*:*:*:*", "matchCriteriaId": "5D873E55-2FE5-43B0-A994-0940F4A5008F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_cash_management:14.2:*:*:*:*:*:*:*", "matchCriteriaId": "3DBD5E57-CC8B-4180-ACBD-BD067D0801D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_cash_management:14.3:*:*:*:*:*:*:*", "matchCriteriaId": "071E67EC-DC5A-4BD1-AC8F-6266E6436FF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_cash_management:14.5:*:*:*:*:*:*:*", "matchCriteriaId": "626C6209-8BC3-4954-BF0C-51500582457E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.2:*:*:*:*:*:*:*", "matchCriteriaId": "55543515-BE87-4D88-8F9B-130FCE792642"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.3:*:*:*:*:*:*:*", "matchCriteriaId": "0D32FE52-C11F-40F0-943A-4FD1241AA599"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.5:*:*:*:*:*:*:*", "matchCriteriaId": "6EE231C5-8BF0-48F4-81EF-7186814664CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.2:*:*:*:*:*:*:*", "matchCriteriaId": "F9284BB0-343D-46DE-B45D-68081BC20225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.3:*:*:*:*:*:*:*", "matchCriteriaId": "821A1FAA-6475-4892-97A5-10D434BC2C9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.5:*:*:*:*:*:*:*", "matchCriteriaId": "2AA5FF83-B693-4DAB-B585-0FD641266231"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2BEE49E-A5AA-42D3-B422-460454505480"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "645AA3D1-C8B5-4CD2-8ACE-31541FA267F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "AB9FC9AB-1070-420F-870E-A5EC43A924A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_supply_chain_finance:14.2:*:*:*:*:*:*:*", "matchCriteriaId": "1D99F81D-61BB-4904-BE31-3367D4A98FD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_supply_chain_finance:14.3:*:*:*:*:*:*:*", "matchCriteriaId": "93866792-1AAE-40AE-84D0-21250A296BE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_supply_chain_finance:14.5:*:*:*:*:*:*:*", "matchCriteriaId": "45AB3A29-0994-46F4-8093-B4A9CE0BD95F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.2:*:*:*:*:*:*:*", "matchCriteriaId": "2CA1E217-7551-4718-A813-7F55927C7829"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.3:*:*:*:*:*:*:*", "matchCriteriaId": "DE39702F-0176-4C0E-96BA-A344319776B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.5:*:*:*:*:*:*:*", "matchCriteriaId": "AA4A9041-B9BC-451C-B1BD-4E2FD795BF27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_virtual_account_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "D1534C11-E3F5-49F3-8F8D-7C5C90951E69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_virtual_account_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D952E04D-DE2D-4AE0-BFE6-7D9B7E55AC80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_virtual_account_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1111BCFD-E336-4B31-A87E-76C684AC6DE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_activity_monitoring:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "CC723E79-8F35-417B-B9D9-6A707F74C1EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_activity_monitoring:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "5700C2E9-5FF2-48EF-AD85-3C03EDA76536"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_activity_monitoring:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "BA8461A2-428C-4817-92A9-0C671545698D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_policy_management:12.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "5312AC7A-3C16-4967-ACA6-317289A749D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:endeca_information_discovery_studio:3.2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0D7C6438-6E88-41CD-BE34-90341030E41F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:16.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "490B2C44-CECD-4551-B04F-4076D0E053C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:17.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "DEC41EB8-73B4-4BDF-9321-F34EC0BAF9E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:18.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "48EFC111-B01B-4C34-87E4-D6B2C40C0122"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:19.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "073FEA23-E46A-4C73-9D29-95CFF4F5A59D"}]}]}], "references": [{"url": "https://github.com/x-stream/xstream/commit/0fec095d534126931c99fd38e9c6d41f5c685c1a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/x-stream/xstream/security/advisories/GHSA-mw36-7c6c-q4q2", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2de526726e7f4db4a7cb91b7355070779f51a84fd985c6529c2f4e9e@%3Cissues.activemq.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r7c9fc255edc0b9cd9567093d131f6d33fde4c662aaf912460ef630e9@%3Ccommits.camel.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r826a006fda71cc96fc87b6eca4b5d195f19a292ad36cea501682c38c@%3Cissues.activemq.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/redde3609b89b2a4ff18b536a06ef9a77deb93d47fda8ed28086fa8c3@%3Cissues.activemq.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00001.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210409-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4811", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Not Applicable", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "security-advisories@github.com", "tags": ["Not Applicable", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://x-stream.github.io/CVE-2020-26217.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/x-stream/xstream/commit/0fec095d534126931c99fd38e9c6d41f5c685c1a"}}