{"buggy_code": ["#!/usr/bin/perl\n#\n#this is a test of many things, the perl interpreter being one of them.\n\nuse warnings;\nuse strict;\n\nuse CGI;\nuse DBI;\n\nrequire \"session.pl\";\nrequire \"main_menu.pl\";\nrequire \"cook.pl\";\nrequire \"styles.pl\";\nrequire \"db.pl\";\n\n# Log into the database,\n# Retrieve cgi buffer,\n# Check authentication,\n# Start a new session,\n# Jump to the main menu.\n\nmy $dbh = get_db();\n\nmy $q = new CGI;\nprint $q->header;\n\nmy $login = lc cook_word($q->param('login'));\nmy $pass = cook_word($q->param('pass'));\n\nprint <<EOT;\n<head><title>Universal Point System</title>\nEOT\n\nprint_styles();\n\nprint <<EOT;\n</head>\n\n<body>\nEOT\n\nprint \"<p>Trying to log in using login $login</p>\\n\";\n\n#User names always lowercased.\n#Check if login is an alias\nmy $sth = $dbh->prepare(\"select name from users where aliases like '%$login %'\");\n$sth->execute;\nif ($sth->rows) {\n  my ($name) = $sth->fetchrow_array;\n  print \"Cannot login using your alias, login with $name instead\";\n#  invalid_login($q);\n}\n\n#login is real, check the password\n$sth = $dbh->prepare(\"select id from users where name='$login' and pass=PASSWORD('$pass')\");\n$sth->execute;\n\nmy $valid_login = $sth->rows;\nmy ($uid) = $sth->fetchrow_array;\n\nif ($valid_login) {\n  # Login was valid, get the current time.\n  my $sth = $dbh->prepare(\"select unix_timestamp(now())\");\n  $sth->execute;\n  my ($time) = $sth->fetchrow_array;\n\n  my $magic = new_session($dbh, $uid);\n  my $CGI_params = $q->Vars;\n  $CGI_params->{'magic'} = $magic;\n  $CGI_params->{'uid'} = $uid;\n  #print \"<p>Adding to CGI buffer: magic, $magic; uid, $uid</p>\\n\";\n\n  main_menu($dbh, $q, time);\n}\nelse {\n  invalid_login($q);\n}\n\nsub invalid_login {\n  my ($q) = @_;\n\n  print <<EOT;\n  <p>You entered an invalid username/password pair.</p>\n  <p>If you haven't had your account password set, or if this problem continues,\n     speak to an administrator. </p>\n  <p><A HREF=\"/\">Back to the top</a></p>\nEOT\n\n  print $q->end_html;\n}\n", "#08/22/03 - JM - Changed some prepare/execute sql statements to $dbh->do.\n#                Fixed broken URL in session_expired.\n\nuse warnings;\nuse strict;\n\nuse DBI;\n\nrequire \"cook.pl\";\n\n# STACK: $dbh, $uid\nsub new_session {\n  my ($dbh, $uid) = @_;\n\n#  print \"<p>Starting new session for uid $uid.</p>\\n\";\n\n  # Make sequence numbers random.\n  my $magic = int rand(2147483648);\n\n  $dbh->do(\"update users set magic=$magic where id=$uid\");\n  $dbh->do(\"update users set session_stamp=now() where id=$uid\");\n\n  return $magic;\n}\n\n# STACK:  $dbh, $q, $time\n# RETURN: New session number on success, 0 on fail.\nsub get_session {\n  my ($dbh, $q, $view_time) = @_;\n  my $session_timeout = 60 * 60 * 24 * 7; # 7 day session timeout (in seconds)\n\n  my $uid = cook_int($q->param('uid'));\n  my $cgi_magic = cook_int($q->param('magic'));\n\n#  print \"<p>PASSED uid, magic: $uid, $cgi_magic</p>\";\n\n  my $sth = $dbh->prepare(\"select magic, UNIX_TIMESTAMP(now())-UNIX_TIMESTAMP(session_stamp) as elapsed from users where id=$uid\");\n  $sth->execute;\n  my ($db_magic, $elapsed) = $sth->fetchrow_array;\n\n#  print \"<p>FOUND magic, elapsed: $db_magic, $elapsed</p>\\n\";\n\n  if (($db_magic == $cgi_magic) and ($elapsed < $session_timeout)) {\n    # Set a new session timestamp, update magic.\n    my $new_magic = int rand(2147483648);\n    $dbh->do(\"update users set session_stamp=now(), magic=$new_magic where id=$uid\");\n\n    # Put magic into cgi query.\n#    my $vars = $q->Vars;\n#    $vars->{'magic'} = $new_magic;\n    # Successfully continued session...\n    return 1;\n  }\n  else {\n    # Couldn't get a session.\n    return 0;\n  }\n}\n\n# Stack: $dbh, $q, $view_time\n# Return: access string. 'user' 'gate' 'admin'\nsub get_access {\n  my ($dbh, $q, $view_time) = @_;\n  my $uid = cook_int($q->param('uid'));\n\n  my $sth = $dbh->prepare(\"select access from users where id=$uid\");\n  $sth->execute;\n  my ($access) = $sth->fetchrow_array;\n\n  return $access;\n}\n\nsub no_access {\n  my ($dbh, $q, $view_time) = @_;\n  my $uid = cook_int($q->param('uid'));\n  my $action = cook_word($q->param('action'));\n\n  # Log it.\n  my $sth = $dbh->prepare(\"insert into log (user,action,cdata1) values($uid,'accessdenied','$action')\");\n  $sth->execute;\n\n  # Notify the user.\n  print <<EOT;\n    <p> You do not have access to this page. Please let an\n    administrator know what you did to reach this message; you have\n    likely found a bug in the system. Your session has been reset;\n    return to the <a href=\"/ups/index.html\">top.</a></p>\nEOT\n}\n\n# Stack: $dbh, $q, $view_time\n# Return: String with hidden input tags for session tokens (uid, magic).\nsub get_session_info {\n  my ($dbh, $q, $view_time) = @_;\n\n  my $uid = cook_int($q->param('uid'));\n  my $magic = cook_int($q->param('magic'));\n\n  my $sth = $dbh->prepare(\"select magic from users where id=$uid\");\n  $sth->execute;\n  my ($nextmagic) = $sth->fetchrow_array;\n\n  return \"<input type='hidden' name='uid' value='$uid'>\\n<input type='hidden' name='magic' value='$nextmagic'>\\n\";\n}\n\nsub session_expired {\n  print <<EOT;\n  <p>Your session has expired.</p>\n  <p> While navigating this system\n    you must not use the back or forward buttons on your browser.\n    To keep your session current you must use only the links provided on any\n    page. There are a few things that will less commonly break your session: </p>\n\n  <ul>\n   <li>Clicking a submit button multiple times,\n   <li>Trying to load a bookmark to a previous query,\n   <li>Pressing the 'reload' button on your web browser,\n   <li>Printing, from some browsers.\n  </ul>\n\n  <p> Sorry for the inconvenience, but this system keeps malicious\n  users from hijacking your sessions and messing up your info. Please\n  <a href=\"/\">start over</a>.</p>\n\nEOT\n}\n\n1;\n\n"], "fixing_code": ["#!/usr/bin/perl\n#\n#this is a test of many things, the perl interpreter being one of them.\n\nuse warnings;\nuse strict;\n\nuse CGI;\nuse DBI;\n\nrequire \"session.pl\";\nrequire \"main_menu.pl\";\nrequire \"cook.pl\";\nrequire \"styles.pl\";\nrequire \"db.pl\";\n\n# Log into the database,\n# Retrieve cgi buffer,\n# Check authentication,\n# Start a new session,\n# Jump to the main menu.\n\nmy $dbh = get_db();\n\nmy $q = new CGI;\nprint $q->header;\n\nmy $login = lc cook_word($q->param('login'));\nmy $pass = cook_word($q->param('pass'));\n\nprint <<EOT;\n<head><title>Universal Point System</title>\nEOT\n\nprint_styles();\n\nprint <<EOT;\n</head>\n\n<body>\nEOT\n\nprint \"<p>Trying to log in using login $login</p>\\n\";\n\n#User names always lowercased.\n#Check if login is an alias\nmy $sth = $dbh->prepare(\"select name from users where aliases like '%$login %'\");\n$sth->execute;\nif ($sth->rows) {\n  my ($name) = $sth->fetchrow_array;\n  print \"Cannot login using your alias, login with $name instead\";\n#  invalid_login($q);\n}\n\n#login is real, check the password\nmy $login_sql = $dbh->prepare(\"select id from users where name=? and pass=PASSWORD(?)\");\n$login_sql->execute($login,$pass);\n\nmy $valid_login = $login_sql->rows;\nmy ($uid) = $login_sql->fetchrow_array;\n\nif ($valid_login) {\n  # Login was valid, get the current time.\n  my $time_sql = $dbh->prepare(\"select unix_timestamp(now())\");\n  $time_sql->execute;\n  my ($time) = $time_sql->fetchrow_array;\n\n  my $magic = new_session($dbh, $uid);\n  my $CGI_params = $q->Vars;\n  $CGI_params->{'magic'} = $magic;\n  $CGI_params->{'uid'} = $uid;\n  #print \"<p>Adding to CGI buffer: magic, $magic; uid, $uid</p>\\n\";\n\n  main_menu($dbh, $q, time);\n}\nelse {\n  invalid_login($q);\n}\n\nsub invalid_login {\n  my ($q) = @_;\n\n  print <<EOT;\n  <p>You entered an invalid username/password pair.</p>\n  <p>If you haven't had your account password set, or if this problem continues,\n     speak to an administrator. </p>\n  <p><A HREF=\"/\">Back to the top</a></p>\nEOT\n\n  print $q->end_html;\n}\n", "#08/22/03 - JM - Changed some prepare/execute sql statements to $dbh->do.\n#                Fixed broken URL in session_expired.\n\nuse warnings;\nuse strict;\n\nuse DBI;\n\nrequire \"cook.pl\";\n\n# STACK: $dbh, $uid\nsub new_session {\n  my ($dbh, $uid) = @_;\n\n#  print \"<p>Starting new session for uid $uid.</p>\\n\";\n\n  # Make sequence numbers random.\n  my $magic = int rand(2147483648);\n\n  my $sql = $dbh->prepare(\"update users set magic=? where id=?\");\n\t$sql->execute($magic,$uid);\n  $sql = $dbh->prepare(\"update users set session_stamp=now() where id=?\");\n\t$sql->execute($uid);\n\n  return $magic;\n}\n\n# STACK:  $dbh, $q, $time\n# RETURN: New session number on success, 0 on fail.\nsub get_session {\n  my ($dbh, $q, $view_time) = @_;\n  my $session_timeout = 60 * 60 * 24 * 7; # 7 day session timeout (in seconds)\n\n  my $uid = cook_int($q->param('uid'));\n  my $cgi_magic = cook_int($q->param('magic'));\n\n#  print \"<p>PASSED uid, magic: $uid, $cgi_magic</p>\";\n\n  my $sth = $dbh->prepare(\"select magic, UNIX_TIMESTAMP(now())-UNIX_TIMESTAMP(session_stamp) as elapsed from users where id=?\");\n  $sth->execute($uid);\n  my ($db_magic, $elapsed) = $sth->fetchrow_array;\n\n#  print \"<p>FOUND magic, elapsed: $db_magic, $elapsed</p>\\n\";\n\n  if (($db_magic == $cgi_magic) and ($elapsed < $session_timeout)) {\n    # Set a new session timestamp, update magic.\n    my $new_magic = int rand(2147483648);\n    my $sql = $dbh->prepare(\"update users set session_stamp=now(), magic=? where id=?\");\n\t\t$sql->execute($new_magic,$uid);\n\n    return 1;\n  }\n  else {\n    # Couldn't get a session.\n    return 0;\n  }\n}\n\n# Stack: $dbh, $q, $view_time\n# Return: access string. 'user' 'gate' 'admin'\nsub get_access {\n  my ($dbh, $q, $view_time) = @_;\n  my $uid = cook_int($q->param('uid'));\n\n  my $sth = $dbh->prepare(\"select access from users where id=?\");\n  $sth->execute($uid);\n  my ($access) = $sth->fetchrow_array;\n\n  return $access;\n}\n\nsub no_access {\n  my ($dbh, $q, $view_time) = @_;\n  my $uid = cook_int($q->param('uid'));\n  my $action = cook_word($q->param('action'));\n\n  # Log it.\n  my $sth = $dbh->prepare(\"insert into log (user,action,cdata1) values(?,'accessdenied','$action')\");\n  $sth->execute($uid);\n\n  # Notify the user.\n  print <<EOT;\n    <p> You do not have access to this page. Please let an\n    administrator know what you did to reach this message; you have\n    likely found a bug in the system. Your session has been reset;\n    return to the <a href=\"/ups/index.html\">top.</a></p>\nEOT\n}\n\n# Stack: $dbh, $q, $view_time\n# Return: String with hidden input tags for session tokens (uid, magic).\nsub get_session_info {\n  my ($dbh, $q, $view_time) = @_;\n\n  my $uid = cook_int($q->param('uid'));\n  my $magic = cook_int($q->param('magic'));\n\n  my $sth = $dbh->prepare(\"select magic from users where id=?\");\n  $sth->execute($uid);\n  my ($nextmagic) = $sth->fetchrow_array;\n\n  return \"<input type='hidden' name='uid' value='$uid'>\\n<input type='hidden' name='magic' value='$nextmagic'>\\n\";\n}\n\nsub session_expired {\n  print <<EOT;\n  <p>Your session has expired.</p>\n  <p> While navigating this system\n    you must not use the back or forward buttons on your browser.\n    To keep your session current you must use only the links provided on any\n    page. There are a few things that will less commonly break your session: </p>\n\n  <ul>\n   <li>Clicking a submit button multiple times,\n   <li>Trying to load a bookmark to a previous query,\n   <li>Pressing the 'reload' button on your web browser,\n   <li>Printing, from some browsers.\n  </ul>\n\n  <p> Sorry for the inconvenience, but this system keeps malicious\n  users from hijacking your sessions and messing up your info. Please\n  <a href=\"/\">start over</a>.</p>\n\nEOT\n}\n\n1;\n\n"], "filenames": ["www/cgi-bin/login.pl", "www/cgi-bin/session.pl"], "buggy_code_start_loc": [56, 20], "buggy_code_end_loc": [67, 101], "fixing_code_start_loc": [56, 20], "fixing_code_end_loc": [67, 100], "type": "CWE-89", "message": "A vulnerability, which was classified as critical, was found in antonbolling clan7ups. Affected is an unknown function of the component Login/Session. The manipulation leads to sql injection. The name of the patch is 25afad571c488291033958d845830ba0a1710764. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218388.", "other": {"cve": {"id": "CVE-2013-10012", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-16T11:15:10.037", "lastModified": "2023-01-24T15:14:10.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in antonbolling clan7ups. Affected is an unknown function of the component Login/Session. The manipulation leads to sql injection. The name of the patch is 25afad571c488291033958d845830ba0a1710764. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218388."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clan7ups_project:clan7ups:*:*:*:*:*:*:*:*", "versionEndExcluding": "2013-02-12", "matchCriteriaId": "12D82AEE-3A68-4121-811C-C3462BCEAF25"}]}]}], "references": [{"url": "https://github.com/antonbolling/clan7ups/commit/25afad571c488291033958d845830ba0a1710764", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218388", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218388", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antonbolling/clan7ups/commit/25afad571c488291033958d845830ba0a1710764"}}