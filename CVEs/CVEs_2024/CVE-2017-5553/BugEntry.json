{"buggy_code": ["<?php\n\n#\n#\n# Parsedown\n# http://parsedown.org\n#\n# (c) Emanuil Rusev\n# http://erusev.com\n#\n\n/*\nModifications by yura:\n\t1. Fix <li> with second line\n\t2. Fix to properly work with <table>\n\t3. Remove \"goto\" operator because it starts since PHP >= 5.3.0\n\t4. Fix to display title of images and links\n\t5. Don't apply <p> around item content separators: [teaserbreak] and [pagebreak]\n\t6. Support code block with ```, example:\n\t    ```php\n\t    $x = $obj->method();\n\t    ```\n\t7. Split a list in two lists by paragraph after list element\n\t8. Support additional params(id and class) for headers. Examples:\n\t    - ###header {#header-id-value}                     => <h3 id=\"header-id-value\">header</h3>\n\t    - ##header {.header-class-value}                   => <h2 class=\"header-class-value\">header</h2>\n\t    - #header {.header-class-value#header-id-value}    => <h1 id=\"header-id-value\" class=\"header-class-value\">header</h1>\n\t    - ####header {#header-id-value.header-class-value} => <h4 class=\"header-class-value\" id=\"header-id-value\">header</h4>\n\t9. Don't apply <p> around list and already existing paragraph tags\n\t10. Don't convert HTML entities inside <code> html tags because the \"Escape code\" plugin does this\n\t11. Fix the missed empty lines in code blocks which are started and ended with ```\n*/\n\nclass Parsedown\n{\n\t#\n\t# Multiton (http://en.wikipedia.org/wiki/Multiton_pattern)\n\t#\n\n\tstatic function instance($name = 'default')\n\t{\n\t\tif (isset(self::$instances[$name]))\n\t\t\treturn self::$instances[$name];\n\n\t\t$instance = new Parsedown();\n\n\t\tself::$instances[$name] = $instance;\n\n\t\treturn $instance;\n\t}\n\n\tprivate static $instances = array();\n\n\t#\n\t# Fields\n\t#\n\n\tprivate $reference_map = array();\n\tprivate $escape_sequence_map = array();\n\n\tpublic $parse_links = true;\n\tpublic $parse_images = true;\n\tpublic $parse_font_styles = true;\n\n\t#\n\t# Public Methods\n\t#\n\n\tfunction parse($text)\n\t{\n\t\t# Removes UTF-8 BOM and marker characters.\n\t\t$text = preg_replace('{^\\xEF\\xBB\\xBF|\\x1A}', '', $text);\n\n\t\t# Removes \\r characters.\n\t\t$text = str_replace(\"\\r\\n\", \"\\n\", $text);\n\t\t$text = str_replace(\"\\r\", \"\\n\", $text);\n\n\t\t# Replaces tabs with spaces.\n\t\t$text = str_replace(\"\\t\", '    ', $text);\n\n\t\t# Encodes escape sequences.\n\t\t/* erhsatingin> This is what causes the escaping issues later down the line\n\t\tif (strpos($text, '\\\\') !== FALSE)\n\t\t{\n\t\t\t$escape_sequences = array('\\\\\\\\', '\\`', '\\*', '\\_', '\\{', '\\}', '\\[', '\\]', '\\(', '\\)', '\\>', '\\#', '\\+', '\\-', '\\.', '\\!');\n\n\t\t\tforeach ($escape_sequences as $index => $escape_sequence)\n\t\t\t{\n\t\t\t\tif (strpos($text, $escape_sequence) !== FALSE)\n\t\t\t\t{\n\t\t\t\t\t$code = \"\\x1A\".'\\\\'.$index;\n\n\t\t\t\t\t$text = str_replace($escape_sequence, $code, $text);\n\n\t\t\t\t\t$this->escape_sequence_map[$code] = $escape_sequence;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\t# Extracts link references.\n\n\t\tif (preg_match_all('/^[ ]{0,3}\\[(.+)\\][ ]?:[ ]*\\n?[ ]*(.+)$/m', $text, $matches, PREG_SET_ORDER))\n\t\t{\n\t\t\tforeach ($matches as $matches)\n\t\t\t{\n\t\t\t\t$this->reference_map[strtolower($matches[1])] = $matches[2];\n\n\t\t\t\t$text = str_replace($matches[0], '', $text);\n\t\t\t}\n\t\t}\n\n\t\t# ~\n\n\t\t$text = preg_replace('/\\n\\s*\\n/', \"\\n\\n\", $text);\n\t\t$text = trim($text, \"\\n\");\n\n\t\t$lines = explode(\"\\n\", $text);\n\n\t\t$text = $this->parse_block_elements($lines);\n\n\t\t# Decodes escape sequences (leaves out backslashes).\n\n\t\tforeach ($this->escape_sequence_map as $code => $escape_sequence)\n\t\t{\n\t\t\t$text = str_replace($code, $escape_sequence[1], $text);\n\t\t}\n\n\t\t$text = rtrim($text, \"\\n\");\n\n\t\treturn $text;\n\t}\n\n\t#\n\t# Private Methods\n\t#\n\n\tprivate function parse_block_elements( array $lines, $context = '', & $return_data = NULL )\n\t{\n\t\t$elements = array();\n\n\t\t$element = array(\n\t\t\t'type' => '',\n\t\t);\n\n\t\tforeach ($lines as $line)\n\t\t{\n\t\t\t# Empty\n\n\t\t\tif( $line === '' )\n\t\t\t{\n\t\t\t\t$element['interrupted'] = true;\n\n\t\t\t\tif( $element['type'] === 'code' )\n\t\t\t\t{\t// Don't miss empty lines in code blocks where each line is started with 4 spaces:\n\t\t\t\t\t$element['text'] .= \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif( $element['type'] === 'codeblock' )\n\t\t\t\t{\t// Don't miss empty lines in code blocks which are started and ended with ```:\n\t\t\t\t\t$element['lines'][] = $line;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Codeblock\n\t\t\tif( $element['type'] != 'codeblock' && preg_match('/^```([a-z0-9]+)*$/i', $line, $matches ) )\n\t\t\t{ // Codeblock is opening\n\t\t\t\tif( ! empty( $element['type'] ) )\n\t\t\t\t{ // Save any previous element that has been started but not finished yet\n\t\t\t\t\t$elements[] = $element;\n\t\t\t\t}\n\t\t\t\t// Start new codeblock element\n\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'codeblock',\n\t\t\t\t\t\t'lang' => empty( $matches[1] ) ? '' : strtolower( $matches[1] ),\n\t\t\t\t\t\t'lines' => array(),\n\t\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( $element['type'] == 'codeblock' )\n\t\t\t{\n\t\t\t\tif( preg_match('/^```$/i', $line ) )\n\t\t\t\t{ // Codeblock is closing\n\t\t\t\t\t$elements[] = $element;\n\t\t\t\t\t$element = array( 'type' => '' );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{ // Save each line of codeblock\n\t\t\t\t\t$element['lines'][] = $line;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Lazy Blockquote\n\n\t\t\tif ($element['type'] === 'blockquote' and ! isset($element['interrupted']))\n\t\t\t{\n\t\t\t\t$line = preg_replace('/^[ ]*(>|&gt;)[ ]?/', '', $line);\n\n\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Lazy List Item\n\n\t\t\tif ($element['type'] === 'li')\n\t\t\t{\n\t\t\t\tif (preg_match('/^([ ]{0,3})(\\d+[.]|[*+-])[ ](.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['indentation'] !== $matches[1])\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= $line;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tunset($element['last']);\n\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'li',\n\t\t\t\t\t\t\t'indentation' => $matches[1],\n\t\t\t\t\t\t\t'last' => true,\n\t\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\t\tpreg_replace('/^[ ]{0,4}/', '', $matches[3]),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t{\n\t\t\t\t\tif ($line[0] === ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= '';\n\n\t\t\t\t\t\t$line = preg_replace('/^[ ]{0,4}/', '', $line);;\n\n\t\t\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif( ! preg_match( '/^[\\s\\t]*<\\//', $line ) )\n\t\t\t\t{ // Don't append the second line if it is an end of HTML tag\n\t\t\t\t\t$line = preg_replace('/^[ ]{0,4}/', '', $line);;\n\n\t\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Quick Paragraph\n\n\t\t\tif( ! ( $line[0] >= 'A' and $line['0'] !== '_' ) )\n\t\t\t{ //\n\n\t\t\t\t# Setext Header (---)\n\n\t\t\t\tif ($element['type'] === 'p' and ! isset($element['interrupted']) and preg_match('/^[-]+[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$element['type'] = 'h.';\n\t\t\t\t\t$element['level'] = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Horizontal Rule\n\n\t\t\t\tif (preg_match('/^[ ]{0,3}([-*_])([ ]{0,2}\\1){2,}[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'hr',\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# List Item\n\n\t\t\t\tif (preg_match('/^([ ]{0,3})(\\d+[.]|[*+-])[ ](.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'li',\n\t\t\t\t\t\t'ordered' => isset($matches[2][1]),\n\t\t\t\t\t\t'indentation' => $matches[1],\n\t\t\t\t\t\t'last' => true,\n\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\tpreg_replace('/^[ ]{0,4}/', '', $matches[3]),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Code\n\n\t\t\t\tif (preg_match('/^[ ]{4}(.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['type'] === 'code')\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['text'] .= \"\\n\".$matches[1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'code',\n\t\t\t\t\t\t\t'text' => $matches[1],\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Atx Header (#)\n\n\t\t\t\tif ($line[0] === '#' and preg_match('/^(#{1,6}) (.+?)[ ]*#*$/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$level = strlen($matches[1]);\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'h.',\n\t\t\t\t\t\t'text' => $matches[2],\n\t\t\t\t\t\t'level' => $level,\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Blockquote\n\n\t\t\t\tif (preg_match('/^[ ]*(>|&gt;)[ ]?(.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['type'] === 'blockquote')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$element['lines'] []= '';\n\n\t\t\t\t\t\t\tunset($element['interrupted']);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$element['lines'] []= $matches[2];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'blockquote',\n\t\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\t\t$matches[2],\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Setext Header (===)\n\n\t\t\t\tif ($element['type'] === 'p' and ! isset($element['interrupted']) and preg_match('/^[=]+[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$element['type'] = 'h.';\n\t\t\t\t\t$element['level'] = 1;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ($element['type'] === 'p')\n\t\t\t{\n\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element['text'] = $line;\n\n\t\t\t\t\tunset($element['interrupted']);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$element['text'] .= \"\\n\".$line;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$elements []= $element;\n\n\t\t\t\t$element = array(\n\t\t\t\t\t'type' => 'p',\n\t\t\t\t\t'text' => $line,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$elements []= $element;\n\n\t\tarray_shift($elements);\n\n\t\t#\n\t\t# ~\n\t\t#\n\n\t\t$markup = '';\n\n\t\tforeach ($elements as $index => $element)\n\t\t{\n\t\t\tswitch ($element['type'])\n\t\t\t{\n\t\t\t\tcase 'li':\n\n\t\t\t\t\tif( isset( $element['ordered'] ) || isset( $return_data['last'] ) ) # first\n\t\t\t\t\t{ // Start new list if it is new list or if previous was interrupted with paragraph\n\t\t\t\t\t\t$list_type = ! empty( $element['ordered'] ) ? 'ol' : 'ul';\n\n\t\t\t\t\t\t$markup .= '<'.$list_type.'>'.\"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\tif( isset( $element['interrupted'] ) && ! isset( $element['last'] ) )\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= '';\n\t\t\t\t\t}\n\n\t\t\t\t\t$return_data = array();\n\t\t\t\t\t$text = $this->parse_block_elements( $element['lines'], 'li', $return_data );\n\n\t\t\t\t\t$markup .= '<li>'.$text.'</li>'.\"\\n\";\n\n\t\t\t\t\tif( isset( $element['last'] ) || isset( $return_data['last'] ) )\n\t\t\t\t\t{ // End list tag if it is last item or it is interrupted list with paragraph\n\t\t\t\t\t\t$markup .= '</'.$list_type.'>'.\"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'p':\n\n\t\t\t\t\t$text = $this->parse_inline_elements($element['text']);\n\n\t\t\t\t\t$text = preg_replace('/[ ]{2}\\n/', '<br />'.\"\\n\", $text);\n\n\t\t\t\t\tif( $text == '[teaserbreak]' || $text == '[pagebreak]' )\n\t\t\t\t\t{ // Don't apply <p> around item content separators\n\t\t\t\t\t\t$markup .= $text.\"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\telseif( preg_match( '~^<(ul|ol|li|p)~i', $text ) || preg_match( '~</(ul|ol|li|p)>$~i', $text ) )\n\t\t\t\t\t{ // Don't apply <p> around list and already existing paragraph tags\n\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t}\n\t\t\t\t\telseif( $context === 'li' && $index === 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t\tif( isset( $element['interrupted'] ) )\n\t\t\t\t\t\t{ // End current list instead of <p> inside <li>\n\t\t\t\t\t\t\t$return_data = array( 'last' => true );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif( preg_match( '/^<table.+<\\\\/table>$/is', $text ) )\n\t\t\t\t\t\t{ // Apply <p> tag around full table\n\t\t\t\t\t\t\t$markup .= '<p>'.$text.'</p>'.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif( preg_match( '/(.*<td>)(.+)/is', $text, $text_match ) &&\n\t\t\t\t\t\t      ! preg_match( '#(</?table|</?tr|</?th|</?td)#is', $text_match[2] ) )\n\t\t\t\t\t\t{ // Apply <p> tag for content of <td>\n\t\t\t\t\t\t\t$markup .= $text_match[1].'<p>'.$text_match[2].'</p>'.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif( ! preg_match( '#(</?table|</?tr|</?th|</?td)#i', $text ) )\n\t\t\t\t\t\t{ // Apply <p> tag for text that is not a part of a <table>\n\t\t\t\t\t\t\tif( count( $elements ) > 1 )\n\t\t\t\t\t\t\t{ // Only if a content contains many elements\n\t\t\t\t\t\t\t\t$markup .= '<p>'.$text.'</p>'.\"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{ // Don't add <p> tag around whole content\n\t\t\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ // Don't apply <p> tag\n\t\t\t\t\t\t\t$markup .= $text.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'code':\n\n\t\t\t\t\t$text = rtrim($element['text'], \"\\n\");\n\n\t\t\t\t\tstrpos($text, \"\\x1A\\\\\") !== FALSE and $text = strtr($text, $this->escape_sequence_map);\n\n\t\t\t\t\t$markup .= '<pre class=\"codeblock\"><code>'.$text.'</code></pre>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'blockquote':\n\n\t\t\t\t\t$text = $this->parse_block_elements($element['lines']);\n\n\t\t\t\t\t$markup .= '<blockquote>'.\"\\n\".$text.'</blockquote>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'codeblock':\n\t\t\t\t\t// Codeblock\n\t\t\t\t\t$attrs = empty( $element['lang'] ) ? '' : ' lang='.$element['lang'];\n\t\t\t\t\t$attrs .= ' line=1'; // set this param because codehighlight plugin doesn't detect language without this\n\t\t\t\t\t$text = implode( \"\\n\", $element['lines'] );\n\t\t\t\t\t$markup .= '<!-- codeblock '.$attrs.'--><pre class=\"codeblock\"><code>'.\"\\n\".$text.\"\\n\".'</code></pre><!-- /codeblock -->'.\"\\n\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'h.':\n\n\t\t\t\t\t$text = $this->parse_inline_elements($element['text']);\n\n\t\t\t\t\t$markup .= '<h'.$element['level'].'>'.$text.'</h'.$element['level'].'>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hr':\n\n\t\t\t\t\t$markup .= '<hr />'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $markup;\n\t}\n\n\tprivate function parse_inline_elements($text)\n\t{\n\t\t$map = array();\n\n\t\t$index = 0;\n\n\t\t# Code Span\n\n\t\tif (strpos($text, '`') !== FALSE and preg_match_all('/`(.+?)`/', $text, $matches, PREG_SET_ORDER))\n\t\t{\n\t\t\tforeach ($matches as $matches)\n\t\t\t{\n\t\t\t\t$element_text = $matches[1];\n\n\t\t\t\t# Decodes escape sequences.\n\n\t\t\t\t$this->escape_sequence_map\n\t\t\t\t\tand strpos($element_text, \"\\x1A\") !== FALSE\n\t\t\t\t\tand $element_text = strtr($element_text, $this->escape_sequence_map);\n\n\t\t\t\t# Composes element.\n\n\t\t\t\t$element = '<code class=\"codespan\">'.$element_text.'</code>';\n\n\t\t\t\t# Encodes element.\n\n\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t$index ++;\n\t\t\t}\n\t\t}\n\n\t\tif( $this->parse_images || $this->parse_links )\n\t\t{ // Parse images or links\n\n\t\t\t# Inline Link / Image\n\t\t\tif( strpos($text, '](') !== FALSE ) # inline\n\t\t\t{\n\t\t\t\t$text = str_replace( '&quot;', '\"', $text ); // revert from html entity\n\t\t\t\tif( preg_match_all( '/(!?)(\\[((?:[^][]+|(?2))*)\\])\\(([^\"]*?)( \"([^\"]+)\")?\\)/', $text, $matches, PREG_SET_ORDER ) )\n\t\t\t\t{\n\t\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($matches[1]) # image\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_images )\n\t\t\t\t\t\t\t{ // Parse images only if it is enabled\n\t\t\t\t\t\t\t\t$element = '<img src=\"'.$matches[4].'\" alt=\"'.$matches[3].'\"'.( ! empty( $matches[6] ) ? ' title=\"'.$matches[6].'\"' : '' ).'>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_links )\n\t\t\t\t\t\t\t{ // Parse links only if it is enabled\n\t\t\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[3]);\n\t\t\t\t\t\t\t\t$element = '<a href=\"'.$matches[4].'\"'.( ! empty( $matches[6] ) ? ' title=\"'.$matches[6].'\"' : '' ).'>'.$element_text.'</a>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( ! isset( $element ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[1]);\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t\tunset( $element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Reference(d) Link / Image\n\n\t\t\tif ($this->reference_map and strpos($text, '[') !== FALSE and preg_match_all('/(!?)\\[(.+?)\\](?:\\n?[ ]?\\[(.*?)\\])?/ms', $text, $matches, PREG_SET_ORDER))\n\t\t\t{\n\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t{\n\t\t\t\t\t$link_difinition = isset($matches[3]) && $matches[3]\n\t\t\t\t\t\t? $matches[3]\n\t\t\t\t\t\t: $matches[2]; # implicit\n\n\t\t\t\t\t$link_difinition = strtolower($link_difinition);\n\n\t\t\t\t\tif (isset($this->reference_map[$link_difinition]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$url = $this->reference_map[$link_difinition];\n\n\t\t\t\t\t\tif ($matches[1]) # image\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_images )\n\t\t\t\t\t\t\t{ // Parse images only if it is enabled\n\t\t\t\t\t\t\t\t$element = '<img alt=\"'.$matches[2].'\" src=\"'.$url.'\">';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse # anchor\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_links )\n\t\t\t\t\t\t\t{ // Parse links only if it is enabled\n\t\t\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[2]);\n\t\t\t\t\t\t\t\t$element = '<a href=\"'.$url.'\">'.$element_text.'</a>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( ! isset( $element ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t\tunset( $element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( $this->parse_links )\n\t\t\t{ // Parse links only if it is enabled\n\t\t\t\tif (strpos($text, '<') !== FALSE and preg_match_all('/<((https?|ftp|dict):[^\\^\\s]+?)>/i', $text, $matches, PREG_SET_ORDER))\n\t\t\t\t{\n\t\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t\t{\n\t\t\t\t\t\t$element = '<a href=\":href\">:text</a>';\n\t\t\t\t\t\t$element = str_replace(':text', $matches[1], $element);\n\t\t\t\t\t\t$element = str_replace(':href', $matches[1], $element);\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( $this->parse_font_styles )\n\t\t{ // Parse bold & italic styles only if it is enabled\n\t\t\t// Render the font style out side html tag attributes\n\t\t\t$text = callback_on_non_matching_blocks( $text,\n\t\t\t\t'~<[^>]+>~i',\n\t\t\t\tarray( $this, 'render_font_styles_callback' ) );\n\t\t}\n\n\t\t$text = strtr( $text, $map );\n\n\t\treturn $text;\n\t}\n\n\n\t/**\n\t * Callback functiob to render the font style out side html tag attributes\n\t *\n\t * @param string Text\n\t * @return string Text\n\t */\n\tfunction render_font_styles_callback( $text )\n\t{\n\t\t$text = preg_replace( '/(__|\\*\\*)(?=\\S)(.+?)(?<=\\S)\\1/', '<strong>$2</strong>', $text );\n\t\t$text = preg_replace( '/(_|\\*)(?=\\S)(.+?)(?<=\\S)\\1/', '<em>$2</em>', $text );\n\t\treturn $text;\n\t}\n}\n\n?>"], "fixing_code": ["<?php\n\n#\n#\n# Parsedown\n# http://parsedown.org\n#\n# (c) Emanuil Rusev\n# http://erusev.com\n#\n\n/*\nModifications by yura:\n\t1. Fix <li> with second line\n\t2. Fix to properly work with <table>\n\t3. Remove \"goto\" operator because it starts since PHP >= 5.3.0\n\t4. Fix to display title of images and links\n\t5. Don't apply <p> around item content separators: [teaserbreak] and [pagebreak]\n\t6. Support code block with ```, example:\n\t    ```php\n\t    $x = $obj->method();\n\t    ```\n\t7. Split a list in two lists by paragraph after list element\n\t8. Support additional params(id and class) for headers. Examples:\n\t    - ###header {#header-id-value}                     => <h3 id=\"header-id-value\">header</h3>\n\t    - ##header {.header-class-value}                   => <h2 class=\"header-class-value\">header</h2>\n\t    - #header {.header-class-value#header-id-value}    => <h1 id=\"header-id-value\" class=\"header-class-value\">header</h1>\n\t    - ####header {#header-id-value.header-class-value} => <h4 class=\"header-class-value\" id=\"header-id-value\">header</h4>\n\t9. Don't apply <p> around list and already existing paragraph tags\n\t10. Don't convert HTML entities inside <code> html tags because the \"Escape code\" plugin does this\n\t11. Fix the missed empty lines in code blocks which are started and ended with ```\n\t12. Ignore wrong URLs for links and images; Allow only which begin with http://, https:// or /\n*/\n\nclass Parsedown\n{\n\t#\n\t# Multiton (http://en.wikipedia.org/wiki/Multiton_pattern)\n\t#\n\n\tstatic function instance($name = 'default')\n\t{\n\t\tif (isset(self::$instances[$name]))\n\t\t\treturn self::$instances[$name];\n\n\t\t$instance = new Parsedown();\n\n\t\tself::$instances[$name] = $instance;\n\n\t\treturn $instance;\n\t}\n\n\tprivate static $instances = array();\n\n\t#\n\t# Fields\n\t#\n\n\tprivate $reference_map = array();\n\tprivate $escape_sequence_map = array();\n\n\tpublic $parse_links = true;\n\tpublic $parse_images = true;\n\tpublic $parse_font_styles = true;\n\n\t#\n\t# Public Methods\n\t#\n\n\tfunction parse($text)\n\t{\n\t\t# Removes UTF-8 BOM and marker characters.\n\t\t$text = preg_replace('{^\\xEF\\xBB\\xBF|\\x1A}', '', $text);\n\n\t\t# Removes \\r characters.\n\t\t$text = str_replace(\"\\r\\n\", \"\\n\", $text);\n\t\t$text = str_replace(\"\\r\", \"\\n\", $text);\n\n\t\t# Replaces tabs with spaces.\n\t\t$text = str_replace(\"\\t\", '    ', $text);\n\n\t\t# Encodes escape sequences.\n\t\t/* erhsatingin> This is what causes the escaping issues later down the line\n\t\tif (strpos($text, '\\\\') !== FALSE)\n\t\t{\n\t\t\t$escape_sequences = array('\\\\\\\\', '\\`', '\\*', '\\_', '\\{', '\\}', '\\[', '\\]', '\\(', '\\)', '\\>', '\\#', '\\+', '\\-', '\\.', '\\!');\n\n\t\t\tforeach ($escape_sequences as $index => $escape_sequence)\n\t\t\t{\n\t\t\t\tif (strpos($text, $escape_sequence) !== FALSE)\n\t\t\t\t{\n\t\t\t\t\t$code = \"\\x1A\".'\\\\'.$index;\n\n\t\t\t\t\t$text = str_replace($escape_sequence, $code, $text);\n\n\t\t\t\t\t$this->escape_sequence_map[$code] = $escape_sequence;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\t# Extracts link references.\n\n\t\tif (preg_match_all('/^[ ]{0,3}\\[(.+)\\][ ]?:[ ]*\\n?[ ]*((https?:\\/\\/|\\/).+)$/m', $text, $matches, PREG_SET_ORDER))\n\t\t{\n\t\t\tforeach ($matches as $matches)\n\t\t\t{\n\t\t\t\t$this->reference_map[strtolower($matches[1])] = $matches[2];\n\n\t\t\t\t$text = str_replace($matches[0], '', $text);\n\t\t\t}\n\t\t}\n\n\t\t# ~\n\n\t\t$text = preg_replace('/\\n\\s*\\n/', \"\\n\\n\", $text);\n\t\t$text = trim($text, \"\\n\");\n\n\t\t$lines = explode(\"\\n\", $text);\n\n\t\t$text = $this->parse_block_elements($lines);\n\n\t\t# Decodes escape sequences (leaves out backslashes).\n\n\t\tforeach ($this->escape_sequence_map as $code => $escape_sequence)\n\t\t{\n\t\t\t$text = str_replace($code, $escape_sequence[1], $text);\n\t\t}\n\n\t\t$text = rtrim($text, \"\\n\");\n\n\t\treturn $text;\n\t}\n\n\t#\n\t# Private Methods\n\t#\n\n\tprivate function parse_block_elements( array $lines, $context = '', & $return_data = NULL )\n\t{\n\t\t$elements = array();\n\n\t\t$element = array(\n\t\t\t'type' => '',\n\t\t);\n\n\t\tforeach ($lines as $line)\n\t\t{\n\t\t\t# Empty\n\n\t\t\tif( $line === '' )\n\t\t\t{\n\t\t\t\t$element['interrupted'] = true;\n\n\t\t\t\tif( $element['type'] === 'code' )\n\t\t\t\t{\t// Don't miss empty lines in code blocks where each line is started with 4 spaces:\n\t\t\t\t\t$element['text'] .= \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tif( $element['type'] === 'codeblock' )\n\t\t\t\t{\t// Don't miss empty lines in code blocks which are started and ended with ```:\n\t\t\t\t\t$element['lines'][] = $line;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Codeblock\n\t\t\tif( $element['type'] != 'codeblock' && preg_match('/^```([a-z0-9]+)*$/i', $line, $matches ) )\n\t\t\t{ // Codeblock is opening\n\t\t\t\tif( ! empty( $element['type'] ) )\n\t\t\t\t{ // Save any previous element that has been started but not finished yet\n\t\t\t\t\t$elements[] = $element;\n\t\t\t\t}\n\t\t\t\t// Start new codeblock element\n\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'codeblock',\n\t\t\t\t\t\t'lang' => empty( $matches[1] ) ? '' : strtolower( $matches[1] ),\n\t\t\t\t\t\t'lines' => array(),\n\t\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( $element['type'] == 'codeblock' )\n\t\t\t{\n\t\t\t\tif( preg_match('/^```$/i', $line ) )\n\t\t\t\t{ // Codeblock is closing\n\t\t\t\t\t$elements[] = $element;\n\t\t\t\t\t$element = array( 'type' => '' );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{ // Save each line of codeblock\n\t\t\t\t\t$element['lines'][] = $line;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Lazy Blockquote\n\n\t\t\tif ($element['type'] === 'blockquote' and ! isset($element['interrupted']))\n\t\t\t{\n\t\t\t\t$line = preg_replace('/^[ ]*(>|&gt;)[ ]?/', '', $line);\n\n\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t# Lazy List Item\n\n\t\t\tif ($element['type'] === 'li')\n\t\t\t{\n\t\t\t\tif (preg_match('/^([ ]{0,3})(\\d+[.]|[*+-])[ ](.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['indentation'] !== $matches[1])\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= $line;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tunset($element['last']);\n\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'li',\n\t\t\t\t\t\t\t'indentation' => $matches[1],\n\t\t\t\t\t\t\t'last' => true,\n\t\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\t\tpreg_replace('/^[ ]{0,4}/', '', $matches[3]),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t{\n\t\t\t\t\tif ($line[0] === ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= '';\n\n\t\t\t\t\t\t$line = preg_replace('/^[ ]{0,4}/', '', $line);;\n\n\t\t\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif( ! preg_match( '/^[\\s\\t]*<\\//', $line ) )\n\t\t\t\t{ // Don't append the second line if it is an end of HTML tag\n\t\t\t\t\t$line = preg_replace('/^[ ]{0,4}/', '', $line);;\n\n\t\t\t\t\t$element['lines'] []= $line;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Quick Paragraph\n\n\t\t\tif( ! ( $line[0] >= 'A' and $line['0'] !== '_' ) )\n\t\t\t{ //\n\n\t\t\t\t# Setext Header (---)\n\n\t\t\t\tif ($element['type'] === 'p' and ! isset($element['interrupted']) and preg_match('/^[-]+[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$element['type'] = 'h.';\n\t\t\t\t\t$element['level'] = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Horizontal Rule\n\n\t\t\t\tif (preg_match('/^[ ]{0,3}([-*_])([ ]{0,2}\\1){2,}[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'hr',\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# List Item\n\n\t\t\t\tif (preg_match('/^([ ]{0,3})(\\d+[.]|[*+-])[ ](.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'li',\n\t\t\t\t\t\t'ordered' => isset($matches[2][1]),\n\t\t\t\t\t\t'indentation' => $matches[1],\n\t\t\t\t\t\t'last' => true,\n\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\tpreg_replace('/^[ ]{0,4}/', '', $matches[3]),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Code\n\n\t\t\t\tif (preg_match('/^[ ]{4}(.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['type'] === 'code')\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['text'] .= \"\\n\".$matches[1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'code',\n\t\t\t\t\t\t\t'text' => $matches[1],\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Atx Header (#)\n\n\t\t\t\tif ($line[0] === '#' and preg_match('/^(#{1,6}) (.+?)[ ]*#*$/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$level = strlen($matches[1]);\n\n\t\t\t\t\t$element = array(\n\t\t\t\t\t\t'type' => 'h.',\n\t\t\t\t\t\t'text' => $matches[2],\n\t\t\t\t\t\t'level' => $level,\n\t\t\t\t\t);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Blockquote\n\n\t\t\t\tif (preg_match('/^[ ]*(>|&gt;)[ ]?(.*)/', $line, $matches))\n\t\t\t\t{\n\t\t\t\t\tif ($element['type'] === 'blockquote')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$element['lines'] []= '';\n\n\t\t\t\t\t\t\tunset($element['interrupted']);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$element['lines'] []= $matches[2];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t\t$element = array(\n\t\t\t\t\t\t\t'type' => 'blockquote',\n\t\t\t\t\t\t\t'lines' => array(\n\t\t\t\t\t\t\t\t$matches[2],\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t# Setext Header (===)\n\n\t\t\t\tif ($element['type'] === 'p' and ! isset($element['interrupted']) and preg_match('/^[=]+[ ]*$/', $line))\n\t\t\t\t{\n\t\t\t\t\t$element['type'] = 'h.';\n\t\t\t\t\t$element['level'] = 1;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ($element['type'] === 'p')\n\t\t\t{\n\t\t\t\tif (isset($element['interrupted']))\n\t\t\t\t{\n\t\t\t\t\t$elements []= $element;\n\n\t\t\t\t\t$element['text'] = $line;\n\n\t\t\t\t\tunset($element['interrupted']);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$element['text'] .= \"\\n\".$line;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$elements []= $element;\n\n\t\t\t\t$element = array(\n\t\t\t\t\t'type' => 'p',\n\t\t\t\t\t'text' => $line,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$elements []= $element;\n\n\t\tarray_shift($elements);\n\n\t\t#\n\t\t# ~\n\t\t#\n\n\t\t$markup = '';\n\n\t\tforeach ($elements as $index => $element)\n\t\t{\n\t\t\tswitch ($element['type'])\n\t\t\t{\n\t\t\t\tcase 'li':\n\n\t\t\t\t\tif( isset( $element['ordered'] ) || isset( $return_data['last'] ) ) # first\n\t\t\t\t\t{ // Start new list if it is new list or if previous was interrupted with paragraph\n\t\t\t\t\t\t$list_type = ! empty( $element['ordered'] ) ? 'ol' : 'ul';\n\n\t\t\t\t\t\t$markup .= '<'.$list_type.'>'.\"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\tif( isset( $element['interrupted'] ) && ! isset( $element['last'] ) )\n\t\t\t\t\t{\n\t\t\t\t\t\t$element['lines'] []= '';\n\t\t\t\t\t}\n\n\t\t\t\t\t$return_data = array();\n\t\t\t\t\t$text = $this->parse_block_elements( $element['lines'], 'li', $return_data );\n\n\t\t\t\t\t$markup .= '<li>'.$text.'</li>'.\"\\n\";\n\n\t\t\t\t\tif( isset( $element['last'] ) || isset( $return_data['last'] ) )\n\t\t\t\t\t{ // End list tag if it is last item or it is interrupted list with paragraph\n\t\t\t\t\t\t$markup .= '</'.$list_type.'>'.\"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'p':\n\n\t\t\t\t\t$text = $this->parse_inline_elements($element['text']);\n\n\t\t\t\t\t$text = preg_replace('/[ ]{2}\\n/', '<br />'.\"\\n\", $text);\n\n\t\t\t\t\tif( $text == '[teaserbreak]' || $text == '[pagebreak]' )\n\t\t\t\t\t{ // Don't apply <p> around item content separators\n\t\t\t\t\t\t$markup .= $text.\"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\telseif( preg_match( '~^<(ul|ol|li|p)~i', $text ) || preg_match( '~</(ul|ol|li|p)>$~i', $text ) )\n\t\t\t\t\t{ // Don't apply <p> around list and already existing paragraph tags\n\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t}\n\t\t\t\t\telseif( $context === 'li' && $index === 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t\tif( isset( $element['interrupted'] ) )\n\t\t\t\t\t\t{ // End current list instead of <p> inside <li>\n\t\t\t\t\t\t\t$return_data = array( 'last' => true );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif( preg_match( '/^<table.+<\\\\/table>$/is', $text ) )\n\t\t\t\t\t\t{ // Apply <p> tag around full table\n\t\t\t\t\t\t\t$markup .= '<p>'.$text.'</p>'.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif( preg_match( '/(.*<td>)(.+)/is', $text, $text_match ) &&\n\t\t\t\t\t\t      ! preg_match( '#(</?table|</?tr|</?th|</?td)#is', $text_match[2] ) )\n\t\t\t\t\t\t{ // Apply <p> tag for content of <td>\n\t\t\t\t\t\t\t$markup .= $text_match[1].'<p>'.$text_match[2].'</p>'.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif( ! preg_match( '#(</?table|</?tr|</?th|</?td)#i', $text ) )\n\t\t\t\t\t\t{ // Apply <p> tag for text that is not a part of a <table>\n\t\t\t\t\t\t\tif( count( $elements ) > 1 )\n\t\t\t\t\t\t\t{ // Only if a content contains many elements\n\t\t\t\t\t\t\t\t$markup .= '<p>'.$text.'</p>'.\"\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{ // Don't add <p> tag around whole content\n\t\t\t\t\t\t\t\t$markup .= $text;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ // Don't apply <p> tag\n\t\t\t\t\t\t\t$markup .= $text.\"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'code':\n\n\t\t\t\t\t$text = rtrim($element['text'], \"\\n\");\n\n\t\t\t\t\tstrpos($text, \"\\x1A\\\\\") !== FALSE and $text = strtr($text, $this->escape_sequence_map);\n\n\t\t\t\t\t$markup .= '<pre class=\"codeblock\"><code>'.$text.'</code></pre>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'blockquote':\n\n\t\t\t\t\t$text = $this->parse_block_elements($element['lines']);\n\n\t\t\t\t\t$markup .= '<blockquote>'.\"\\n\".$text.'</blockquote>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'codeblock':\n\t\t\t\t\t// Codeblock\n\t\t\t\t\t$attrs = empty( $element['lang'] ) ? '' : ' lang='.$element['lang'];\n\t\t\t\t\t$attrs .= ' line=1'; // set this param because codehighlight plugin doesn't detect language without this\n\t\t\t\t\t$text = implode( \"\\n\", $element['lines'] );\n\t\t\t\t\t$markup .= '<!-- codeblock '.$attrs.'--><pre class=\"codeblock\"><code>'.\"\\n\".$text.\"\\n\".'</code></pre><!-- /codeblock -->'.\"\\n\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'h.':\n\n\t\t\t\t\t$text = $this->parse_inline_elements($element['text']);\n\n\t\t\t\t\t$markup .= '<h'.$element['level'].'>'.$text.'</h'.$element['level'].'>'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hr':\n\n\t\t\t\t\t$markup .= '<hr />'.\"\\n\";\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $markup;\n\t}\n\n\tprivate function parse_inline_elements($text)\n\t{\n\t\t$map = array();\n\n\t\t$index = 0;\n\n\t\t# Code Span\n\n\t\tif (strpos($text, '`') !== FALSE and preg_match_all('/`(.+?)`/', $text, $matches, PREG_SET_ORDER))\n\t\t{\n\t\t\tforeach ($matches as $matches)\n\t\t\t{\n\t\t\t\t$element_text = $matches[1];\n\n\t\t\t\t# Decodes escape sequences.\n\n\t\t\t\t$this->escape_sequence_map\n\t\t\t\t\tand strpos($element_text, \"\\x1A\") !== FALSE\n\t\t\t\t\tand $element_text = strtr($element_text, $this->escape_sequence_map);\n\n\t\t\t\t# Composes element.\n\n\t\t\t\t$element = '<code class=\"codespan\">'.$element_text.'</code>';\n\n\t\t\t\t# Encodes element.\n\n\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t$index ++;\n\t\t\t}\n\t\t}\n\n\t\tif( $this->parse_images || $this->parse_links )\n\t\t{ // Parse images or links\n\n\t\t\t# Inline Link / Image\n\t\t\tif( strpos($text, '](') !== FALSE ) # inline\n\t\t\t{\n\t\t\t\t$text = str_replace( '&quot;', '\"', $text ); // revert from html entity\n\t\t\t\tif( preg_match_all( '/(!?)(\\[((?:[^][]+|(?2))*)\\])\\((https?:\\/\\/|\\/)([^\"]*?)( \"([^\"]+)\")?\\)/', $text, $matches, PREG_SET_ORDER ) )\n\t\t\t\t{\n\t\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($matches[1]) # image\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_images )\n\t\t\t\t\t\t\t{ // Parse images only if it is enabled\n\t\t\t\t\t\t\t\t$element = '<img src=\"'.$matches[4].$matches[5].'\" alt=\"'.$matches[3].'\"'.( ! empty( $matches[7] ) ? ' title=\"'.$matches[7].'\"' : '' ).'>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_links )\n\t\t\t\t\t\t\t{ // Parse links only if it is enabled\n\t\t\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[3]);\n\t\t\t\t\t\t\t\t$element = '<a href=\"'.$matches[4].$matches[5].'\"'.( ! empty( $matches[7] ) ? ' title=\"'.$matches[7].'\"' : '' ).'>'.$element_text.'</a>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( ! isset( $element ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[1]);\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t\tunset( $element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Reference(d) Link / Image\n\n\t\t\tif ($this->reference_map and strpos($text, '[') !== FALSE and preg_match_all('/(!?)\\[(.+?)\\](?:\\n?[ ]?\\[(.*?)\\])?/ms', $text, $matches, PREG_SET_ORDER))\n\t\t\t{\n\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t{\n\t\t\t\t\t$link_difinition = isset($matches[3]) && $matches[3]\n\t\t\t\t\t\t? $matches[3]\n\t\t\t\t\t\t: $matches[2]; # implicit\n\n\t\t\t\t\t$link_difinition = strtolower($link_difinition);\n\n\t\t\t\t\tif (isset($this->reference_map[$link_difinition]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$url = $this->reference_map[$link_difinition];\n\n\t\t\t\t\t\tif ($matches[1]) # image\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_images )\n\t\t\t\t\t\t\t{ // Parse images only if it is enabled\n\t\t\t\t\t\t\t\t$element = '<img alt=\"'.$matches[2].'\" src=\"'.$url.'\">';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse # anchor\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( $this->parse_links )\n\t\t\t\t\t\t\t{ // Parse links only if it is enabled\n\t\t\t\t\t\t\t\t$element_text = $this->parse_inline_elements($matches[2]);\n\t\t\t\t\t\t\t\t$element = '<a href=\"'.$url.'\">'.$element_text.'</a>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( ! isset( $element ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t\tunset( $element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( $this->parse_links )\n\t\t\t{ // Parse links only if it is enabled\n\t\t\t\tif (strpos($text, '<') !== FALSE and preg_match_all('/<((https?|ftp|dict):[^\\^\\s]+?)>/i', $text, $matches, PREG_SET_ORDER))\n\t\t\t\t{\n\t\t\t\t\tforeach ($matches as $matches)\n\t\t\t\t\t{\n\t\t\t\t\t\t$element = '<a href=\":href\">:text</a>';\n\t\t\t\t\t\t$element = str_replace(':text', $matches[1], $element);\n\t\t\t\t\t\t$element = str_replace(':href', $matches[1], $element);\n\n\t\t\t\t\t\t# ~\n\n\t\t\t\t\t\t$code = \"\\x1A\".'$'.$index;\n\n\t\t\t\t\t\t$text = str_replace($matches[0], $code, $text);\n\n\t\t\t\t\t\t$map[$code] = $element;\n\n\t\t\t\t\t\t$index ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( $this->parse_font_styles )\n\t\t{ // Parse bold & italic styles only if it is enabled\n\t\t\t// Render the font style out side html tag attributes\n\t\t\t$text = callback_on_non_matching_blocks( $text,\n\t\t\t\t'~<[^>]+>~i',\n\t\t\t\tarray( $this, 'render_font_styles_callback' ) );\n\t\t}\n\n\t\t$text = strtr( $text, $map );\n\n\t\treturn $text;\n\t}\n\n\n\t/**\n\t * Callback functiob to render the font style out side html tag attributes\n\t *\n\t * @param string Text\n\t * @return string Text\n\t */\n\tfunction render_font_styles_callback( $text )\n\t{\n\t\t$text = preg_replace( '/(__|\\*\\*)(?=\\S)(.+?)(?<=\\S)\\1/', '<strong>$2</strong>', $text );\n\t\t$text = preg_replace( '/(_|\\*)(?=\\S)(.+?)(?<=\\S)\\1/', '<em>$2</em>', $text );\n\t\treturn $text;\n\t}\n}\n\n?>"], "filenames": ["plugins/markdown_plugin/_parsedown.inc.php"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [609], "fixing_code_start_loc": [32], "fixing_code_end_loc": [610], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in plugins/markdown_plugin/_markdown.plugin.php in b2evolution before 6.8.5 allows remote authenticated users to inject arbitrary web script or HTML via a javascript: URL.", "other": {"cve": {"id": "CVE-2017-5553", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-23T07:59:00.580", "lastModified": "2017-01-26T15:01:15.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in plugins/markdown_plugin/_markdown.plugin.php in b2evolution before 6.8.5 allows remote authenticated users to inject arbitrary web script or HTML via a javascript: URL."}, {"lang": "es", "value": "Vulnerabilidad de XSS en plugins/markdown_plugin/_markdown.plugin.php en b2evolution en versiones anteriores a 6.8.5 permite a usuarios remotos autenticados inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de una URL javascript:."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:b2evolution:b2evolution:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.8.4", "matchCriteriaId": "14A848D5-3D72-484C-800F-A66AC941A094"}]}]}], "references": [{"url": "http://b2evolution.net/downloads/6-8-5", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/95704", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/b2evolution/b2evolution/commit/ce5b36e44b714b18b0bcd34c6db0187b8d13bab8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/b2evolution/b2evolution/commit/ce5b36e44b714b18b0bcd34c6db0187b8d13bab8"}}