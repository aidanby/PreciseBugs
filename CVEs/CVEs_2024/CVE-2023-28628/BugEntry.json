{"buggy_code": ["# Unreleased\n\n## Added\n\n## Fixed\n\n## Changed\n\n# 1.13.95 (2022-01-28 / a9cbeff)\n\n## Fixed\n\n- Fix a stack overflow in `normalize/char-seq` for really large query parameter\n  values\n\n# 1.12.89 (2021-11-29 / 2118a75)\n\n## Changed\n\n- Support `toString` on Babashka (requires recent `bb`)\n\n# 1.11.86 (2021-10-28 / 22c27af)\n\n## Fixed\n\n- Fixed an issue in `lambdaisland.uri.normalize/normalize-query` which did\nnot take into account utf-16 encoding.\n\n# 1.10.79 (2021-10-12 / d90c6a8)\n\n## Changed\n\n- `lambdaisland.uri.normalize/normalize` now also normalizes the fragment.\n\n# 1.4.74 (2021-09-06 / e07f9fd)\n\n## Added\n\n- `uri-str` as an explicit `lambdaisland.uri.URI` to string conversion\n\n## Fixed\n\n- Fixed compatibility with Babashka/SCI. Note that on babashka we can't\n  implement IFn or toString, so converting a `URI` back to a string needs to be\n  done explicitly with `uri-str`, and it is not possible to use a URI as a\n  function. (`(:path uri)` is ok, `(uri :path)` is not).\n\n# 1.4.70 (2021-05-31 / 76999dc)\n\n## Added\n\n- Add `uri?` predicate.\n\n# 1.4.54 (2020-06-16 / 05a8a19)\n\n## Fixed\n\n- Make query decoding handle `+` as space, so the conversion between maps and\n  query strings correctly round trips.\n- Handle percent encoding of control characters (codepoints < 16)\n- make `lambdaisland.uri.platform/string->byte-seq` return unsigned bytes on\n  both plaforms (clj/cljs)\n\n# 1.4.49 (2020-06-11 / ee48e58)\n\n## Changed\n\n- Make `assoc-query` / `query-encode` encode spaces as \"+\" rather than \"%20\",\n  which brings it in line to how most languages/libraries do it.\n\n# 1.3.45 (2020-05-01 / a04368b)\n\n## Added\n\n- Added function for dealing with query strings as maps: `query-string->map`,\n  `map->query-string`, `query-map`, `query-encode`, `assoc-query`,\n  `assoc-query*`.\n\n## Fixed\n\n- Fix query string normalization, for delimiter characters like `=` and `+`\n  there is a semantic difference between the encoded and decoded form, when they\n  are encoded in the input normalization should not decode them and vice versa\n\n# 1.2.1 (2020-02-23 / a992787)\n\n## Changed\n\n- Remove dependencies on ClojureScript and data.json.\n\n# 1.2.0 (2020-02-17 / c0e1f1a)\n\n## Added\n\n- `lambdaisland.uri.normalize/normalize`, for normalizing URI instances.\n\n## Changed\n\n- Added type hints to avoid reflection (thanks @totakke!)\n\n# 1.1.0 (2017-04-25)\n\n## Added\n\n- Predicate functions `absolute?` and `relative?`\n\n# 1.0.0 (2017-02-23)\n\n## Added\n\n- Initial release, public vars: `uri`, `join`, `coerce`, `parse`, `edn-readers`", "(ns lambdaisland.uri\n  (:refer-clojure :exclude [uri?])\n  (:require [clojure.string :as str]\n            [lambdaisland.uri.normalize :as normalize])\n  #?(:clj (:import clojure.lang.IFn)))\n\n(def uri-regex #?(:clj #\"\\A(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)?(\\?([^#]*))?(#(.*))?\\z\"\n                  :cljs #\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)?(\\?([^#]*))?(#(.*))?$\"))\n(def authority-regex #?(:clj #\"\\A(([^:]*)(:(.*))?@)?([^:]*)(:(\\d*))?\\z\"\n                        :cljs #\"^(([^:]*)(:(.*))?@)?([^:]*)(:(\\d*))?$\"))\n\n(defn- authority-string  [user password host port]\n  (when host\n    (cond-> user\n      (and user password) (str \":\" password)\n      user                (str \"@\")\n      true                (str host)\n      port                (str \":\" port))))\n\n(defn uri-str\n  \"Convert the URI instance back to a string\"\n  [{:keys [scheme user password host port path query fragment]}]\n  (let [authority (authority-string user password host port)]\n    (cond-> \"\"\n      scheme    (str scheme \":\")\n      authority (str \"//\" authority)\n      true      (str path)\n      query     (str \"?\" query)\n      fragment  (str \"#\" fragment))))\n\n(defrecord URI [scheme user password host port path query fragment]\n  #?@(:bb []\n      :default\n      [IFn\n       (#?(:clj invoke :cljs -invoke) [this kw]\n                                      (get this kw))])\n  Object\n  (toString [this]\n    (uri-str this)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; parse\n\n(defn- match-uri [uri]\n  (let [matches (re-matches uri-regex uri)\n        [_ _ scheme _ authority path _ query _ fragment] matches]\n    [scheme authority (when (seq path) path) query fragment]))\n\n(defn- match-authority [authority]\n  (let [matches (re-matches authority-regex authority)\n        [_ _ user _ password host _ port] matches]\n    [user password host port]))\n\n(defn parse\n  \"Parse a URI string into a lambadisland.uri.URI record.\"\n  [uri]\n  (let [[scheme authority path query fragment] (match-uri uri)]\n    (if authority\n      (let [[user password host port] (match-authority authority)]\n        (URI. scheme user password host port path query fragment))\n      (URI. scheme nil nil nil nil path query fragment))))\n\n(defn uri\n  \"Turn the given value into a lambdaisland.uri.URI record, if it isn't one\n  already. Supports String, java.net.URI, and other URI-like objects that return\n  a valid URI string with `str`.\"\n  [uri-like]\n  (if (instance? URI uri-like)\n    uri-like\n    (parse (str uri-like))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; join / resolve\n\n;; This section is based on RFC 3986\n\n(defn- absolute-path? [path]\n  (= (first path) \\/))\n\n(defn- remove-dot-segments\n  \"As per RFC 3986 section 5.2.4\"\n  [path]\n  (when path\n    (loop [in (str/split path #\"(?=/)\")\n           out []]\n      (case (first in)\n        \"/.\" (if (next in)\n               (recur (next in) out)\n               (recur nil (conj out \"/\")))\n        \"/..\" (if (next in)\n                (recur (next in) (vec (butlast out)))\n                (recur nil (conj (vec (butlast out)) \"/\")))\n        nil (str/join out)\n        (recur (next in) (conj out (first in)))))))\n\n(defn- merge-paths [a b]\n  (if (some #{\\/} a)\n    (str (re-find #?(:clj #\"\\A.*/\"\n                     :cljs #\"^.*/\") a) b)\n    (if (absolute-path? b)\n      b\n      (str \"/\" b))))\n\n(defn join*\n  \"Join two URI records as per RFC 3986. Handles relative URIs.\"\n  [base ref]\n  (if (:scheme ref)\n    (update ref :path remove-dot-segments)\n    (-> (if (:host ref)\n          (assoc ref\n                 :scheme (:scheme base)\n                 :query  (:query ref))\n          (if (nil? (:path ref))\n            (assoc base :query (some :query [ref base]))\n            (assoc base :path\n                   (remove-dot-segments\n                    (if (absolute-path? (:path ref))\n                      (:path ref)\n                      (merge-paths (:path base) (:path ref))))\n                   :query (:query ref))))\n        (assoc :fragment (:fragment ref)))))\n\n(defn join\n  \"Joins any number of URIs as per RFC3986. Arguments can be strings, they will\n  be coerced to URI records.\"\n  [& uris]\n  (reduce join* (map uri uris)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Query strings\n\n(defn- decode-param-pair [param]\n  (let [[k v] (str/split param #\"=\")]\n    [(if k (normalize/percent-decode k) \"\")\n     (if v (normalize/percent-decode (str/replace v #\"\\+\" \" \")) \"\")]))\n\n(defn query-string->map\n  \"Parse a query string, consisting of key=value pairs, separated by \\\"&\\\". Takes\n  the following options:\n\n  - `:keywordize?` whether to turn return keys as keywords. Defaults to `true`.\n  - `:multikeys` how to handle the same key occuring multiple times, defaults to\n    `:duplicates`\n\n  The possible values for `:multikeys` are\n\n  - `:never` always return a single value for a key. The rightmost value\n    \\\"wins\\\"\n  - `:always` return a map with vectors as values, with successive\n    values of the same key in order\n  - `:duplicates` return a vector for keys that occur multiple times, or a\n    string otherwise\"\n  ([q]\n   (query-string->map q nil))\n  ([q {:keys [multikeys keywordize?]\n       :or {multikeys :duplicates\n            keywordize? true}}]\n   (when (not (str/blank? q))\n     (->> (str/split q #\"&\")\n          (map decode-param-pair)\n          (reduce\n           (fn [m [k v]]\n             (let [k (if keywordize? (keyword k) k)]\n               (case multikeys\n                 :never\n                 (assoc m k v)\n                 :always\n                 (if (contains? m k)\n                   (update m k conj v)\n                   (assoc m k [v]))\n                 :duplicates\n                 (if (contains? m k)\n                   (if (vector? (m k))\n                     (update m k conj v)\n                     (assoc m k [(m k) v]))\n                   (assoc m k v)))))\n           {})))))\n\n(defn query-map\n  \"Return the query section of a URI as a map. Will coerce its argument\n  with [[uri]]. Takes an options map, see [[query-string->map]] for options.\"\n  ([uri]\n   (query-map uri nil))\n  ([u opts]\n   (query-string->map (:query (uri u)) opts)))\n\n(defn query-encode\n  \"Percent encoding for query strings. Will percent-encode values that are\n  reserved in query strings only. Encodes spaces as +.\"\n  [s]\n  (let [encode-char #(cond\n                       (= \" \" %)\n                       \"+\"\n                       (re-find #\"[^a-zA-Z0-9\\-\\._~@\\/]\" %)\n                       (normalize/percent-encode %)\n                       :else\n                       %)]\n    (->> (normalize/char-seq s)\n         (map encode-char)\n         (apply str))))\n\n(defn- encode-param-pair [k v]\n  (str (query-encode\n        (cond\n          (simple-ident? k)\n          (name k)\n          (qualified-ident? k)\n          (str (namespace k) \"/\" (name k))\n          :else (str k)))\n       \"=\"\n       (query-encode (str v))))\n\n(defn map->query-string\n  \"Convert a map into a query string, consisting of key=value pairs separated by\n  `&`. The result is percent-encoded so it is always safe to use. Keys can be\n  strings or keywords. If values are collections then this results in multiple\n  entries for the same key. `nil` values are ignored. Values are stringified.\"\n  [m]\n  (when (seq m)\n    (->> m\n         (mapcat (fn [[k v]]\n                   (cond\n                     (nil? v)\n                     []\n                     (coll? v)\n                     (map (partial encode-param-pair k) v)\n                     :else\n                     [(encode-param-pair k v)])))\n         (interpose \"&\")\n         (apply str))))\n\n(defn assoc-query*\n  \"Add additional query parameters to a URI. Takes a URI (or coercible to URI) and\n  a map of query params.\"\n  [u m]\n  (let [u (uri u)]\n    (assoc u :query (map->query-string (merge (query-map u) m)))))\n\n(defn assoc-query\n  \"Add additional query parameters to a URI. Takes a URI (or coercible to URI)\n  followed key value pairs.\n\n  (assoc-query \\\"http://example.com?id=1&name=John\\\" :name \\\"Jack\\\" :style \\\"goth\\\")\n  ;;=> #lambdaisland/uri \\\"http://example.com?id=1&name=Jack&style=goth\\\" \"\n  [u & {:as kvs}]\n  (assoc-query* u kvs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Predicates\n\n(defn relative?\n  \"Is the URI relative? Returns true if the URI does not have a scheme (protocol).\"\n  [uri]\n  (nil? (:scheme uri)))\n\n(def\n  ^{:doc\n    \"Is the URI absolute? Returns true if the URI has a scheme (protocol), and hence also an origin.\"}\n  absolute? (complement relative?))\n\n(defn uri?\n  \"Check if `o` is URI instance.\"\n  [o]\n  (instance? URI o))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; EDN\n\n(def edn-tag 'lambdaisland/uri)\n\n#?(:clj\n   (defmethod print-method URI [^URI this ^java.io.Writer writer]\n     (.write writer \"#\")\n     (.write writer (str edn-tag))\n     (.write writer \" \")\n     (.write writer (prn-str (.toString this))))\n\n   :cljs\n   (extend-type URI\n     IPrintWithWriter\n     (-pr-writer [this writer _opts]\n       (write-all writer \"#\" (str edn-tag) \" \" (prn-str (.toString this))))))\n\n(def\n  ^{:doc\n    \"A map that can be passed to clojure.edn/read, so tagged URI literals are\n     read back correctly.\"}\n  edn-readers {edn-tag parse})\n", "(ns lambdaisland.uri-test\n  (:require [clojure.test :as t :refer [are deftest is testing]]\n            [lambdaisland.uri :as uri]\n            [lambdaisland.uri.normalize :as norm]\n            [lambdaisland.uri.platform :as platform]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.clojure-test :as tc]\n            [clojure.string :as str])\n  #?(:clj (:import lambdaisland.uri.URI)))\n\n(deftest parsing\n  (testing \"happy path\"\n    (are [x y] (= y (uri/parse x))\n      \"http://user:password@example.com:8080/path?query=value#fragment\"\n      (uri/URI. \"http\" \"user\" \"password\" \"example.com\" \"8080\" \"/path\" \"query=value\" \"fragment\")\n\n      \"/happy/path\"\n      (uri/URI. nil nil nil nil nil \"/happy/path\" nil nil)\n\n      \"relative/path\"\n      (uri/URI. nil nil nil nil nil \"relative/path\" nil nil)\n\n      \"http://example.com\"\n      (uri/URI. \"http\" nil nil \"example.com\" nil nil nil nil)\n      )))\n\n(deftest joining\n  (are [x y] (= (uri/parse y) (apply uri/join (map uri/parse x)))\n    [\"http://foo.bar\"              \"https://baz.com\"]   \"https://baz.com\"\n    [\"http://example.com\"          \"/a/path\"]           \"http://example.com/a/path\"\n    [\"http://example.com/foo/bar\"  \"/a/path\"]           \"http://example.com/a/path\"\n    [\"http://example.com/foo/bar\"  \"a/relative/path\"]   \"http://example.com/foo/a/relative/path\"\n    [\"http://example.com/foo/bar/\" \"a/relative/path\"]   \"http://example.com/foo/bar/a/relative/path\"\n    [\"/foo/bar/\"                   \"a/relative/path\"]   \"/foo/bar/a/relative/path\"\n    [\"http://example.com\"          \"a/relative/path\"]   \"http://example.com/a/relative/path\"\n    [\"http://example.com/a/b/c/d/\" \"../../x/y\"]         \"http://example.com/a/b/x/y\")\n\n  (testing \"https://www.w3.org/2004/04/uri-rel-test.html\"\n    (are [x y] (= y (str (uri/join (uri/parse \"http://a/b/c/d;p?q\") (uri/parse x))))\n      \"g\" \"http://a/b/c/g\"\n      \"./g\" \"http://a/b/c/g\"\n      \"g/\" \"http://a/b/c/g/\"\n      \"/g\" \"http://a/g\"\n      \"//g\" \"http://g\"\n      \"?y\" \"http://a/b/c/d;p?y\"\n      \"g?y\" \"http://a/b/c/g?y\"\n      \"#s\" \"http://a/b/c/d;p?q#s\"\n      \"g#s\" \"http://a/b/c/g#s\"\n      \"g?y#s\" \"http://a/b/c/g?y#s\"\n      \";x\" \"http://a/b/c/;x\"\n      \"g;x\" \"http://a/b/c/g;x\"\n      \"g;x?y#s\" \"http://a/b/c/g;x?y#s\"\n      \"\" \"http://a/b/c/d;p?q\"\n      \".\" \"http://a/b/c/\"\n      \"./\" \"http://a/b/c/\"\n      \"..\" \"http://a/b/\"\n      \"../\" \"http://a/b/\"\n      \"../g\" \"http://a/b/g\"\n      \"../..\" \"http://a/\"\n      \"../../\" \"http://a/\"\n      \"../../g\" \"http://a/g\"\n      \"../../../g\" \"http://a/g\"\n      \"../../../../g\" \"http://a/g\"\n      \"/./g\" \"http://a/g\"\n      \"/g\" \"http://a/g\"\n      \"g.\" \"http://a/b/c/g.\"\n      \".g\" \"http://a/b/c/.g\"\n      \"g..\" \"http://a/b/c/g..\"\n      \"..g\" \"http://a/b/c/..g\"\n      \"./../g\" \"http://a/b/g\"\n      \"./g/\" \"http://a/b/c/g/\"\n      \"g/h\" \"http://a/b/c/g/h\"\n      \"h\" \"http://a/b/c/h\"\n      \"g;x=1/./y\" \"http://a/b/c/g;x=1/y\"\n      \"g;x=1/../y\" \"http://a/b/c/y\"\n      \"g?y/./x\" \"http://a/b/c/g?y/./x\"\n      \"g?y/../x\" \"http://a/b/c/g?y/../x\"\n      \"g#s/./x\" \"http://a/b/c/g#s/./x\"\n      \"g#s/../x\" \"http://a/b/c/g#s/../x\"\n      \"http:g\" \"http:g\"))\n\n  (testing \"coerces its arguments\"\n    (is (= (uri/join \"http://x/y/z\" \"/a/b/c\") (uri/parse \"http://x/a/b/c\")))\n    #?(:clj\n       (is (= (uri/join (java.net.URI. \"http://x/y/z\") \"/a/b/c\") (uri/parse \"http://x/a/b/c\"))))))\n\n(deftest lambdaisland-uri-URI\n  (let [example \"http://usr:pwd@example.com:8080/path?query=value#fragment\"\n        parsed (uri/uri example)]\n    (testing \"it allows keyword based access\"\n      (is (= (:scheme parsed) \"http\"))\n      (is (= (:user parsed) \"usr\"))\n      (is (= (:password parsed) \"pwd\"))\n      (is (= (:host parsed) \"example.com\"))\n      (is (= (:port parsed) \"8080\"))\n      (is (= (:path parsed) \"/path\"))\n      (is (= (:query parsed) \"query=value\"))\n      (is (= (:fragment parsed) \"fragment\")))\n    #?(:bb nil\n       :default\n       (testing \"it allows map-style access\"\n         (is (= (parsed :scheme) \"http\"))\n         (is (= (parsed :user) \"usr\"))\n         (is (= (parsed :password) \"pwd\"))\n         (is (= (parsed :host) \"example.com\"))\n         (is (= (parsed :port) \"8080\"))\n         (is (= (parsed :path) \"/path\"))\n         (is (= (parsed :query) \"query=value\"))\n         (is (= (parsed :fragment) \"fragment\"))))\n    (testing \"it converts correctly to string\"\n      (is (= (str parsed) example)))))\n\n(deftest lambdaisland-uri-relative?\n  (are [x] (uri/relative? (uri/parse x))\n    \"//example.com\"\n    \"/some/path\"\n    \"?only=a-query\"\n    \"#only-a-fragment\"\n    \"//example.com:8080/foo/bar?baz#baq\")\n  (are [x] (uri/absolute? (uri/parse x))\n    \"http://example.com\"\n    \"https://example.com:8080/foo/bar?baz#baq\"))\n\n(deftest query-map-test\n  (is (= {:foo \"bar\", :aaa \"bbb\"}\n         (uri/query-map \"http://example.com?foo=bar&aaa=bbb\")))\n\n  (is (= {\"foo\" \"bar\", \"aaa\" \"bbb\"}\n         (uri/query-map \"http://example.com?foo=bar&aaa=bbb\" {:keywordize? false})))\n\n  (is (= {:id [\"1\" \"2\"]}\n         (uri/query-map \"?id=1&id=2\")))\n\n  (is (= {:id \"2\"}\n         (uri/query-map \"?id=1&id=2\" {:multikeys :never})))\n\n  (is (= {:foo [\"bar\"], :id [\"2\"]}\n         (uri/query-map \"?foo=bar&id=2\" {:multikeys :always})))\n\n  (is (= {:foo \" +&xxx=123\"}\n         (uri/query-map \"?foo=%20%2B%26xxx%3D123\"))))\n\n(deftest assoc-query-test\n  (is (= (uri/uri \"http://example.com?foo=baq&aaa=bbb&hello=world\")\n         (uri/assoc-query \"http://example.com?foo=bar&aaa=bbb\"\n                          :foo \"baq\"\n                          :hello \"world\")))\n\n  (is (= (uri/uri \"http://example.com?foo=baq&aaa=bbb&hello=world\")\n         (uri/assoc-query* \"http://example.com?foo=bar&aaa=bbb\"\n                           {:foo \"baq\"\n                            :hello \"world\"})))\n\n  (is (= (uri/uri \"?id=1&id=2\")\n         (uri/assoc-query* \"\" (uri/query-map \"?id=1&id=2\"))))\n\n  (is (= (uri/uri \"?id=1\")\n         (uri/assoc-query \"?id=1&name=jack\" :name nil)))\n\n  (is (= (uri/uri \"?foo=+%2B%26%3D\")\n         (uri/assoc-query \"\" :foo \" +&=\")))\n\n  (is (= \"a=a+b&b=b+c\"\n         (-> \"/foo\"\n             (uri/assoc-query* {:a \"a b\"})\n             (uri/assoc-query* {:b \"b c\"})\n             :query)))\n\n  (is (= {:a \"a b\"}\n         (-> \"/foo\"\n             (uri/assoc-query* {:a \"a b\"})\n             uri/query-map))))\n\n(deftest uri-predicate-test\n  (is (true? (uri/uri? (uri/uri \"/foo\")))))\n\n(def query-map-gen\n  (gen/map (gen/such-that #(not= \":/\" (str %)) gen/keyword)\n           gen/string))\n\n(tc/defspec query-string-round-trips 100\n  (prop/for-all [q query-map-gen]\n    (let [res (-> q\n                  uri/map->query-string\n                  uri/query-string->map)]\n      (or (and (empty? q) (empty? res)) ;; (= nil {})\n          (= q res)))))\n"], "fixing_code": ["# Unreleased\n\n## Fixed\n\n- Treat a backslash in the authority section as a delimiter which starts the\n  path section (CVE-2023-28628, with thanks to @luigigubello for the report)\n\n# 1.13.95 (2022-01-28 / a9cbeff)\n\n## Fixed\n\n- Fix a stack overflow in `normalize/char-seq` for really large query parameter\n  values\n\n# 1.12.89 (2021-11-29 / 2118a75)\n\n## Changed\n\n- Support `toString` on Babashka (requires recent `bb`)\n\n# 1.11.86 (2021-10-28 / 22c27af)\n\n## Fixed\n\n- Fixed an issue in `lambdaisland.uri.normalize/normalize-query` which did\nnot take into account utf-16 encoding.\n\n# 1.10.79 (2021-10-12 / d90c6a8)\n\n## Changed\n\n- `lambdaisland.uri.normalize/normalize` now also normalizes the fragment.\n\n# 1.4.74 (2021-09-06 / e07f9fd)\n\n## Added\n\n- `uri-str` as an explicit `lambdaisland.uri.URI` to string conversion\n\n## Fixed\n\n- Fixed compatibility with Babashka/SCI. Note that on babashka we can't\n  implement IFn or toString, so converting a `URI` back to a string needs to be\n  done explicitly with `uri-str`, and it is not possible to use a URI as a\n  function. (`(:path uri)` is ok, `(uri :path)` is not).\n\n# 1.4.70 (2021-05-31 / 76999dc)\n\n## Added\n\n- Add `uri?` predicate.\n\n# 1.4.54 (2020-06-16 / 05a8a19)\n\n## Fixed\n\n- Make query decoding handle `+` as space, so the conversion between maps and\n  query strings correctly round trips.\n- Handle percent encoding of control characters (codepoints < 16)\n- make `lambdaisland.uri.platform/string->byte-seq` return unsigned bytes on\n  both plaforms (clj/cljs)\n\n# 1.4.49 (2020-06-11 / ee48e58)\n\n## Changed\n\n- Make `assoc-query` / `query-encode` encode spaces as \"+\" rather than \"%20\",\n  which brings it in line to how most languages/libraries do it.\n\n# 1.3.45 (2020-05-01 / a04368b)\n\n## Added\n\n- Added function for dealing with query strings as maps: `query-string->map`,\n  `map->query-string`, `query-map`, `query-encode`, `assoc-query`,\n  `assoc-query*`.\n\n## Fixed\n\n- Fix query string normalization, for delimiter characters like `=` and `+`\n  there is a semantic difference between the encoded and decoded form, when they\n  are encoded in the input normalization should not decode them and vice versa\n\n# 1.2.1 (2020-02-23 / a992787)\n\n## Changed\n\n- Remove dependencies on ClojureScript and data.json.\n\n# 1.2.0 (2020-02-17 / c0e1f1a)\n\n## Added\n\n- `lambdaisland.uri.normalize/normalize`, for normalizing URI instances.\n\n## Changed\n\n- Added type hints to avoid reflection (thanks @totakke!)\n\n# 1.1.0 (2017-04-25)\n\n## Added\n\n- Predicate functions `absolute?` and `relative?`\n\n# 1.0.0 (2017-02-23)\n\n## Added\n\n- Initial release, public vars: `uri`, `join`, `coerce`, `parse`, `edn-readers`\n", "(ns lambdaisland.uri\n  (:refer-clojure :exclude [uri?])\n  (:require [clojure.string :as str]\n            [lambdaisland.uri.normalize :as normalize])\n  #?(:clj (:import clojure.lang.IFn)))\n\n(def uri-regex #?(:clj #\"\\A(([^:/?#]+):)?(//([^/?#\\\\]*))?([^?#]*)?(\\?([^#]*))?(#(.*))?\\z\"\n                  :cljs #\"^(([^:/?#]+):)?(//([^/?#\\\\]*))?([^?#]*)?(\\?([^#]*))?(#(.*))?$\"))\n(def authority-regex #?(:clj #\"\\A(([^:]*)(:(.*))?@)?([^:]*)(:(\\d*))?\\z\"\n                        :cljs #\"^(([^:]*)(:(.*))?@)?([^:]*)(:(\\d*))?$\"))\n\n(defn- authority-string  [user password host port]\n  (when host\n    (cond-> user\n      (and user password) (str \":\" password)\n      user                (str \"@\")\n      true                (str host)\n      port                (str \":\" port))))\n\n(defn uri-str\n  \"Convert the URI instance back to a string\"\n  [{:keys [scheme user password host port path query fragment]}]\n  (let [authority (authority-string user password host port)]\n    (cond-> \"\"\n      scheme    (str scheme \":\")\n      authority (str \"//\" authority)\n      true      (str path)\n      query     (str \"?\" query)\n      fragment  (str \"#\" fragment))))\n\n(defrecord URI [scheme user password host port path query fragment]\n  #?@(:bb []\n      :default\n      [IFn\n       (#?(:clj invoke :cljs -invoke) [this kw]\n                                      (get this kw))])\n  Object\n  (toString [this]\n    (uri-str this)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; parse\n\n(defn- match-uri [uri]\n  (let [matches (re-matches uri-regex uri)\n        [_ _ scheme _ authority path _ query _ fragment] matches]\n    [scheme authority (when (seq path) path) query fragment]))\n\n(defn- match-authority [authority]\n  (let [matches (re-matches authority-regex authority)\n        [_ _ user _ password host _ port] matches]\n    [user password host port]))\n\n(defn parse\n  \"Parse a URI string into a lambadisland.uri.URI record.\"\n  [uri]\n  (let [[scheme authority path query fragment] (match-uri uri)]\n    (if authority\n      (let [[user password host port] (match-authority authority)]\n        (URI. scheme user password host port path query fragment))\n      (URI. scheme nil nil nil nil path query fragment))))\n\n(defn uri\n  \"Turn the given value into a lambdaisland.uri.URI record, if it isn't one\n  already. Supports String, java.net.URI, and other URI-like objects that return\n  a valid URI string with `str`.\"\n  [uri-like]\n  (if (instance? URI uri-like)\n    uri-like\n    (parse (str uri-like))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; join / resolve\n\n;; This section is based on RFC 3986\n\n(defn- absolute-path? [path]\n  (= (first path) \\/))\n\n(defn- remove-dot-segments\n  \"As per RFC 3986 section 5.2.4\"\n  [path]\n  (when path\n    (loop [in (str/split path #\"(?=/)\")\n           out []]\n      (case (first in)\n        \"/.\" (if (next in)\n               (recur (next in) out)\n               (recur nil (conj out \"/\")))\n        \"/..\" (if (next in)\n                (recur (next in) (vec (butlast out)))\n                (recur nil (conj (vec (butlast out)) \"/\")))\n        nil (str/join out)\n        (recur (next in) (conj out (first in)))))))\n\n(defn- merge-paths [a b]\n  (if (some #{\\/} a)\n    (str (re-find #?(:clj #\"\\A.*/\"\n                     :cljs #\"^.*/\") a) b)\n    (if (absolute-path? b)\n      b\n      (str \"/\" b))))\n\n(defn join*\n  \"Join two URI records as per RFC 3986. Handles relative URIs.\"\n  [base ref]\n  (if (:scheme ref)\n    (update ref :path remove-dot-segments)\n    (-> (if (:host ref)\n          (assoc ref\n                 :scheme (:scheme base)\n                 :query  (:query ref))\n          (if (nil? (:path ref))\n            (assoc base :query (some :query [ref base]))\n            (assoc base :path\n                   (remove-dot-segments\n                    (if (absolute-path? (:path ref))\n                      (:path ref)\n                      (merge-paths (:path base) (:path ref))))\n                   :query (:query ref))))\n        (assoc :fragment (:fragment ref)))))\n\n(defn join\n  \"Joins any number of URIs as per RFC3986. Arguments can be strings, they will\n  be coerced to URI records.\"\n  [& uris]\n  (reduce join* (map uri uris)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Query strings\n\n(defn- decode-param-pair [param]\n  (let [[k v] (str/split param #\"=\")]\n    [(if k (normalize/percent-decode k) \"\")\n     (if v (normalize/percent-decode (str/replace v #\"\\+\" \" \")) \"\")]))\n\n(defn query-string->map\n  \"Parse a query string, consisting of key=value pairs, separated by \\\"&\\\". Takes\n  the following options:\n\n  - `:keywordize?` whether to turn return keys as keywords. Defaults to `true`.\n  - `:multikeys` how to handle the same key occuring multiple times, defaults to\n    `:duplicates`\n\n  The possible values for `:multikeys` are\n\n  - `:never` always return a single value for a key. The rightmost value\n    \\\"wins\\\"\n  - `:always` return a map with vectors as values, with successive\n    values of the same key in order\n  - `:duplicates` return a vector for keys that occur multiple times, or a\n    string otherwise\"\n  ([q]\n   (query-string->map q nil))\n  ([q {:keys [multikeys keywordize?]\n       :or {multikeys :duplicates\n            keywordize? true}}]\n   (when (not (str/blank? q))\n     (->> (str/split q #\"&\")\n          (map decode-param-pair)\n          (reduce\n           (fn [m [k v]]\n             (let [k (if keywordize? (keyword k) k)]\n               (case multikeys\n                 :never\n                 (assoc m k v)\n                 :always\n                 (if (contains? m k)\n                   (update m k conj v)\n                   (assoc m k [v]))\n                 :duplicates\n                 (if (contains? m k)\n                   (if (vector? (m k))\n                     (update m k conj v)\n                     (assoc m k [(m k) v]))\n                   (assoc m k v)))))\n           {})))))\n\n(defn query-map\n  \"Return the query section of a URI as a map. Will coerce its argument\n  with [[uri]]. Takes an options map, see [[query-string->map]] for options.\"\n  ([uri]\n   (query-map uri nil))\n  ([u opts]\n   (query-string->map (:query (uri u)) opts)))\n\n(defn query-encode\n  \"Percent encoding for query strings. Will percent-encode values that are\n  reserved in query strings only. Encodes spaces as +.\"\n  [s]\n  (let [encode-char #(cond\n                       (= \" \" %)\n                       \"+\"\n                       (re-find #\"[^a-zA-Z0-9\\-\\._~@\\/]\" %)\n                       (normalize/percent-encode %)\n                       :else\n                       %)]\n    (->> (normalize/char-seq s)\n         (map encode-char)\n         (apply str))))\n\n(defn- encode-param-pair [k v]\n  (str (query-encode\n        (cond\n          (simple-ident? k)\n          (name k)\n          (qualified-ident? k)\n          (str (namespace k) \"/\" (name k))\n          :else (str k)))\n       \"=\"\n       (query-encode (str v))))\n\n(defn map->query-string\n  \"Convert a map into a query string, consisting of key=value pairs separated by\n  `&`. The result is percent-encoded so it is always safe to use. Keys can be\n  strings or keywords. If values are collections then this results in multiple\n  entries for the same key. `nil` values are ignored. Values are stringified.\"\n  [m]\n  (when (seq m)\n    (->> m\n         (mapcat (fn [[k v]]\n                   (cond\n                     (nil? v)\n                     []\n                     (coll? v)\n                     (map (partial encode-param-pair k) v)\n                     :else\n                     [(encode-param-pair k v)])))\n         (interpose \"&\")\n         (apply str))))\n\n(defn assoc-query*\n  \"Add additional query parameters to a URI. Takes a URI (or coercible to URI) and\n  a map of query params.\"\n  [u m]\n  (let [u (uri u)]\n    (assoc u :query (map->query-string (merge (query-map u) m)))))\n\n(defn assoc-query\n  \"Add additional query parameters to a URI. Takes a URI (or coercible to URI)\n  followed key value pairs.\n\n  (assoc-query \\\"http://example.com?id=1&name=John\\\" :name \\\"Jack\\\" :style \\\"goth\\\")\n  ;;=> #lambdaisland/uri \\\"http://example.com?id=1&name=Jack&style=goth\\\" \"\n  [u & {:as kvs}]\n  (assoc-query* u kvs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Predicates\n\n(defn relative?\n  \"Is the URI relative? Returns true if the URI does not have a scheme (protocol).\"\n  [uri]\n  (nil? (:scheme uri)))\n\n(def\n  ^{:doc\n    \"Is the URI absolute? Returns true if the URI has a scheme (protocol), and hence also an origin.\"}\n  absolute? (complement relative?))\n\n(defn uri?\n  \"Check if `o` is URI instance.\"\n  [o]\n  (instance? URI o))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; EDN\n\n(def edn-tag 'lambdaisland/uri)\n\n#?(:clj\n   (defmethod print-method URI [^URI this ^java.io.Writer writer]\n     (.write writer \"#\")\n     (.write writer (str edn-tag))\n     (.write writer \" \")\n     (.write writer (prn-str (.toString this))))\n\n   :cljs\n   (extend-type URI\n     IPrintWithWriter\n     (-pr-writer [this writer _opts]\n       (write-all writer \"#\" (str edn-tag) \" \" (prn-str (.toString this))))))\n\n(def\n  ^{:doc\n    \"A map that can be passed to clojure.edn/read, so tagged URI literals are\n     read back correctly.\"}\n  edn-readers {edn-tag parse})\n", "(ns lambdaisland.uri-test\n  (:require [clojure.test :as t :refer [are deftest is testing]]\n            [lambdaisland.uri :as uri]\n            [lambdaisland.uri.normalize :as norm]\n            [lambdaisland.uri.platform :as platform]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.clojure-test :as tc]\n            [clojure.string :as str])\n  #?(:clj (:import lambdaisland.uri.URI)))\n\n(deftest parsing\n  (testing \"happy path\"\n    (are [x y] (= y (uri/parse x))\n      \"http://user:password@example.com:8080/path?query=value#fragment\"\n      (uri/URI. \"http\" \"user\" \"password\" \"example.com\" \"8080\" \"/path\" \"query=value\" \"fragment\")\n\n      \"/happy/path\"\n      (uri/URI. nil nil nil nil nil \"/happy/path\" nil nil)\n\n      \"relative/path\"\n      (uri/URI. nil nil nil nil nil \"relative/path\" nil nil)\n\n      \"http://example.com\"\n      (uri/URI. \"http\" nil nil \"example.com\" nil nil nil nil)\n      )))\n\n(deftest joining\n  (are [x y] (= (uri/parse y) (apply uri/join (map uri/parse x)))\n    [\"http://foo.bar\"              \"https://baz.com\"]   \"https://baz.com\"\n    [\"http://example.com\"          \"/a/path\"]           \"http://example.com/a/path\"\n    [\"http://example.com/foo/bar\"  \"/a/path\"]           \"http://example.com/a/path\"\n    [\"http://example.com/foo/bar\"  \"a/relative/path\"]   \"http://example.com/foo/a/relative/path\"\n    [\"http://example.com/foo/bar/\" \"a/relative/path\"]   \"http://example.com/foo/bar/a/relative/path\"\n    [\"/foo/bar/\"                   \"a/relative/path\"]   \"/foo/bar/a/relative/path\"\n    [\"http://example.com\"          \"a/relative/path\"]   \"http://example.com/a/relative/path\"\n    [\"http://example.com/a/b/c/d/\" \"../../x/y\"]         \"http://example.com/a/b/x/y\")\n\n  (testing \"https://www.w3.org/2004/04/uri-rel-test.html\"\n    (are [x y] (= y (str (uri/join (uri/parse \"http://a/b/c/d;p?q\") (uri/parse x))))\n      \"g\" \"http://a/b/c/g\"\n      \"./g\" \"http://a/b/c/g\"\n      \"g/\" \"http://a/b/c/g/\"\n      \"/g\" \"http://a/g\"\n      \"//g\" \"http://g\"\n      \"?y\" \"http://a/b/c/d;p?y\"\n      \"g?y\" \"http://a/b/c/g?y\"\n      \"#s\" \"http://a/b/c/d;p?q#s\"\n      \"g#s\" \"http://a/b/c/g#s\"\n      \"g?y#s\" \"http://a/b/c/g?y#s\"\n      \";x\" \"http://a/b/c/;x\"\n      \"g;x\" \"http://a/b/c/g;x\"\n      \"g;x?y#s\" \"http://a/b/c/g;x?y#s\"\n      \"\" \"http://a/b/c/d;p?q\"\n      \".\" \"http://a/b/c/\"\n      \"./\" \"http://a/b/c/\"\n      \"..\" \"http://a/b/\"\n      \"../\" \"http://a/b/\"\n      \"../g\" \"http://a/b/g\"\n      \"../..\" \"http://a/\"\n      \"../../\" \"http://a/\"\n      \"../../g\" \"http://a/g\"\n      \"../../../g\" \"http://a/g\"\n      \"../../../../g\" \"http://a/g\"\n      \"/./g\" \"http://a/g\"\n      \"/g\" \"http://a/g\"\n      \"g.\" \"http://a/b/c/g.\"\n      \".g\" \"http://a/b/c/.g\"\n      \"g..\" \"http://a/b/c/g..\"\n      \"..g\" \"http://a/b/c/..g\"\n      \"./../g\" \"http://a/b/g\"\n      \"./g/\" \"http://a/b/c/g/\"\n      \"g/h\" \"http://a/b/c/g/h\"\n      \"h\" \"http://a/b/c/h\"\n      \"g;x=1/./y\" \"http://a/b/c/g;x=1/y\"\n      \"g;x=1/../y\" \"http://a/b/c/y\"\n      \"g?y/./x\" \"http://a/b/c/g?y/./x\"\n      \"g?y/../x\" \"http://a/b/c/g?y/../x\"\n      \"g#s/./x\" \"http://a/b/c/g#s/./x\"\n      \"g#s/../x\" \"http://a/b/c/g#s/../x\"\n      \"http:g\" \"http:g\"))\n\n  (testing \"coerces its arguments\"\n    (is (= (uri/join \"http://x/y/z\" \"/a/b/c\") (uri/parse \"http://x/a/b/c\")))\n    #?(:clj\n       (is (= (uri/join (java.net.URI. \"http://x/y/z\") \"/a/b/c\") (uri/parse \"http://x/a/b/c\"))))))\n\n(deftest lambdaisland-uri-URI\n  (let [example \"http://usr:pwd@example.com:8080/path?query=value#fragment\"\n        parsed (uri/uri example)]\n    (testing \"it allows keyword based access\"\n      (is (= (:scheme parsed) \"http\"))\n      (is (= (:user parsed) \"usr\"))\n      (is (= (:password parsed) \"pwd\"))\n      (is (= (:host parsed) \"example.com\"))\n      (is (= (:port parsed) \"8080\"))\n      (is (= (:path parsed) \"/path\"))\n      (is (= (:query parsed) \"query=value\"))\n      (is (= (:fragment parsed) \"fragment\")))\n    #?(:bb nil\n       :default\n       (testing \"it allows map-style access\"\n         (is (= (parsed :scheme) \"http\"))\n         (is (= (parsed :user) \"usr\"))\n         (is (= (parsed :password) \"pwd\"))\n         (is (= (parsed :host) \"example.com\"))\n         (is (= (parsed :port) \"8080\"))\n         (is (= (parsed :path) \"/path\"))\n         (is (= (parsed :query) \"query=value\"))\n         (is (= (parsed :fragment) \"fragment\"))))\n    (testing \"it converts correctly to string\"\n      (is (= (str parsed) example)))))\n\n(deftest lambdaisland-uri-relative?\n  (are [x] (uri/relative? (uri/parse x))\n    \"//example.com\"\n    \"/some/path\"\n    \"?only=a-query\"\n    \"#only-a-fragment\"\n    \"//example.com:8080/foo/bar?baz#baq\")\n  (are [x] (uri/absolute? (uri/parse x))\n    \"http://example.com\"\n    \"https://example.com:8080/foo/bar?baz#baq\"))\n\n(deftest query-map-test\n  (is (= {:foo \"bar\", :aaa \"bbb\"}\n         (uri/query-map \"http://example.com?foo=bar&aaa=bbb\")))\n\n  (is (= {\"foo\" \"bar\", \"aaa\" \"bbb\"}\n         (uri/query-map \"http://example.com?foo=bar&aaa=bbb\" {:keywordize? false})))\n\n  (is (= {:id [\"1\" \"2\"]}\n         (uri/query-map \"?id=1&id=2\")))\n\n  (is (= {:id \"2\"}\n         (uri/query-map \"?id=1&id=2\" {:multikeys :never})))\n\n  (is (= {:foo [\"bar\"], :id [\"2\"]}\n         (uri/query-map \"?foo=bar&id=2\" {:multikeys :always})))\n\n  (is (= {:foo \" +&xxx=123\"}\n         (uri/query-map \"?foo=%20%2B%26xxx%3D123\"))))\n\n(deftest assoc-query-test\n  (is (= (uri/uri \"http://example.com?foo=baq&aaa=bbb&hello=world\")\n         (uri/assoc-query \"http://example.com?foo=bar&aaa=bbb\"\n                          :foo \"baq\"\n                          :hello \"world\")))\n\n  (is (= (uri/uri \"http://example.com?foo=baq&aaa=bbb&hello=world\")\n         (uri/assoc-query* \"http://example.com?foo=bar&aaa=bbb\"\n                           {:foo \"baq\"\n                            :hello \"world\"})))\n\n  (is (= (uri/uri \"?id=1&id=2\")\n         (uri/assoc-query* \"\" (uri/query-map \"?id=1&id=2\"))))\n\n  (is (= (uri/uri \"?id=1\")\n         (uri/assoc-query \"?id=1&name=jack\" :name nil)))\n\n  (is (= (uri/uri \"?foo=+%2B%26%3D\")\n         (uri/assoc-query \"\" :foo \" +&=\")))\n\n  (is (= \"a=a+b&b=b+c\"\n         (-> \"/foo\"\n             (uri/assoc-query* {:a \"a b\"})\n             (uri/assoc-query* {:b \"b c\"})\n             :query)))\n\n  (is (= {:a \"a b\"}\n         (-> \"/foo\"\n             (uri/assoc-query* {:a \"a b\"})\n             uri/query-map))))\n\n(deftest uri-predicate-test\n  (is (true? (uri/uri? (uri/uri \"/foo\")))))\n\n(def query-map-gen\n  (gen/map (gen/such-that #(not= \":/\" (str %)) gen/keyword)\n           gen/string))\n\n(tc/defspec query-string-round-trips 100\n  (prop/for-all [q query-map-gen]\n                (let [res (-> q\n                              uri/map->query-string\n                              uri/query-string->map)]\n                  (or (and (empty? q) (empty? res)) ;; (= nil {})\n                      (= q res)))))\n\n(deftest backslash-in-authority-test\n  ;; A backslash is not technically a valid character in a URI (see RFC 3986\n  ;; section 2), and so should always be percent encoded. The problem is that\n  ;; user-facing software (e.g. browsers) rarely if ever rejects invalid\n  ;; URIs/URLs, leading to ad-hoc rules about how to map the set of invalid URIs\n  ;; to valid URIs. All modern browsers now interpret a backslash as a forward\n  ;; slash, which changes the interpretation of the URI. For this test (and\n  ;; accompanying patch) we only care about the specific case of a backslash\n  ;; appearing inside the authority section, since this authority or _origin_ is\n  ;; regularly used to inform security policies, e.g. to check if code served\n  ;; from a certain origin has access to resources with the same origin. In this\n  ;; case we partially mimic what browsers do, by treating the backslash as a\n  ;; delimiter which starts the path section, even though we don't replace it\n  ;; with a forward slash, but leave it as-is in the parsed result.\n  (let [{:keys [host path user]}\n        (uri/uri \"https://example.com\\\\@gaiwan.co\")]\n    (is (= \"example.com\" host))\n    (is (= nil user))\n    (is (= \"\\\\@gaiwan.co\" path))))\n"], "filenames": ["CHANGELOG.md", "src/lambdaisland/uri.cljc", "test/lambdaisland/uri_test.cljc"], "buggy_code_start_loc": [2, 7, 184], "buggy_code_end_loc": [112, 9, 189], "fixing_code_start_loc": [1, 7, 184], "fixing_code_end_loc": [111, 9, 209], "type": "CWE-601", "message": "lambdaisland/uri is a pure Clojure/ClojureScript URI library. In versions prior to 1.14.120 `authority-regex` allows an attacker to send malicious URLs to be parsed by the `lambdaisland/uri` and return the wrong authority. This issue is similar to but distinct from CVE-2020-8910. The regex in question doesn't handle the backslash (`\\`) character in the username correctly, leading to a wrong output. ex. a payload of `https://example.com\\\\@google.com` would return that the host is `google.com`, but the correct host should be `example.com`. Given that the library returns the wrong authority this may be abused to bypass host restrictions depending on how the library is used in an application. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-28628", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-27T21:15:12.367", "lastModified": "2023-04-04T16:55:02.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lambdaisland/uri is a pure Clojure/ClojureScript URI library. In versions prior to 1.14.120 `authority-regex` allows an attacker to send malicious URLs to be parsed by the `lambdaisland/uri` and return the wrong authority. This issue is similar to but distinct from CVE-2020-8910. The regex in question doesn't handle the backslash (`\\`) character in the username correctly, leading to a wrong output. ex. a payload of `https://example.com\\\\@google.com` would return that the host is `google.com`, but the correct host should be `example.com`. Given that the library returns the wrong authority this may be abused to bypass host restrictions depending on how the library is used in an application. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-706"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lambdaisland:uri:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.120", "matchCriteriaId": "FB4E4DCA-E6F9-4482-AB74-DFB3AC4A09D7"}]}]}], "references": [{"url": "https://github.com/lambdaisland/uri/commit/f46db3e84846f79e14bfee0101d9c7a872321820", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/lambdaisland/uri/security/advisories/GHSA-cp4w-6x4w-v2h5", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lambdaisland/uri/commit/f46db3e84846f79e14bfee0101d9c7a872321820"}}