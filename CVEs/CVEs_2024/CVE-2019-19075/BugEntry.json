{"buggy_code": ["/*\n * http://www.cascoda.com/products/ca-821x/\n * Copyright (c) 2016, Cascoda, Ltd.\n * All rights reserved.\n *\n * This code is dual-licensed under both GPLv2 and 3-clause BSD. What follows is\n * the license notice for both respectively.\n *\n *******************************************************************************\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n *******************************************************************************\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/cdev.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/ieee802154.h>\n#include <linux/io.h>\n#include <linux/kfifo.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n\n#define DRIVER_NAME \"ca8210\"\n\n/* external clock frequencies */\n#define ONE_MHZ      1000000\n#define TWO_MHZ      (2 * ONE_MHZ)\n#define FOUR_MHZ     (4 * ONE_MHZ)\n#define EIGHT_MHZ    (8 * ONE_MHZ)\n#define SIXTEEN_MHZ  (16 * ONE_MHZ)\n\n/* spi constants */\n#define CA8210_SPI_BUF_SIZE 256\n#define CA8210_SYNC_TIMEOUT 1000     /* Timeout for synchronous commands [ms] */\n\n/* test interface constants */\n#define CA8210_TEST_INT_FILE_NAME \"ca8210_test\"\n#define CA8210_TEST_INT_FIFO_SIZE 256\n\n/* MAC status enumerations */\n#define MAC_SUCCESS                     (0x00)\n#define MAC_ERROR                       (0x01)\n#define MAC_CANCELLED                   (0x02)\n#define MAC_READY_FOR_POLL              (0x03)\n#define MAC_COUNTER_ERROR               (0xDB)\n#define MAC_IMPROPER_KEY_TYPE           (0xDC)\n#define MAC_IMPROPER_SECURITY_LEVEL     (0xDD)\n#define MAC_UNSUPPORTED_LEGACY          (0xDE)\n#define MAC_UNSUPPORTED_SECURITY        (0xDF)\n#define MAC_BEACON_LOST                 (0xE0)\n#define MAC_CHANNEL_ACCESS_FAILURE      (0xE1)\n#define MAC_DENIED                      (0xE2)\n#define MAC_DISABLE_TRX_FAILURE         (0xE3)\n#define MAC_SECURITY_ERROR              (0xE4)\n#define MAC_FRAME_TOO_LONG              (0xE5)\n#define MAC_INVALID_GTS                 (0xE6)\n#define MAC_INVALID_HANDLE              (0xE7)\n#define MAC_INVALID_PARAMETER           (0xE8)\n#define MAC_NO_ACK                      (0xE9)\n#define MAC_NO_BEACON                   (0xEA)\n#define MAC_NO_DATA                     (0xEB)\n#define MAC_NO_SHORT_ADDRESS            (0xEC)\n#define MAC_OUT_OF_CAP                  (0xED)\n#define MAC_PAN_ID_CONFLICT             (0xEE)\n#define MAC_REALIGNMENT                 (0xEF)\n#define MAC_TRANSACTION_EXPIRED         (0xF0)\n#define MAC_TRANSACTION_OVERFLOW        (0xF1)\n#define MAC_TX_ACTIVE                   (0xF2)\n#define MAC_UNAVAILABLE_KEY             (0xF3)\n#define MAC_UNSUPPORTED_ATTRIBUTE       (0xF4)\n#define MAC_INVALID_ADDRESS             (0xF5)\n#define MAC_ON_TIME_TOO_LONG            (0xF6)\n#define MAC_PAST_TIME                   (0xF7)\n#define MAC_TRACKING_OFF                (0xF8)\n#define MAC_INVALID_INDEX               (0xF9)\n#define MAC_LIMIT_REACHED               (0xFA)\n#define MAC_READ_ONLY                   (0xFB)\n#define MAC_SCAN_IN_PROGRESS            (0xFC)\n#define MAC_SUPERFRAME_OVERLAP          (0xFD)\n#define MAC_SYSTEM_ERROR                (0xFF)\n\n/* HWME attribute IDs */\n#define HWME_EDTHRESHOLD       (0x04)\n#define HWME_EDVALUE           (0x06)\n#define HWME_SYSCLKOUT         (0x0F)\n#define HWME_LQILIMIT          (0x11)\n\n/* TDME attribute IDs */\n#define TDME_CHANNEL          (0x00)\n#define TDME_ATM_CONFIG       (0x06)\n\n#define MAX_HWME_ATTRIBUTE_SIZE  16\n#define MAX_TDME_ATTRIBUTE_SIZE  2\n\n/* PHY/MAC PIB Attribute Enumerations */\n#define PHY_CURRENT_CHANNEL               (0x00)\n#define PHY_TRANSMIT_POWER                (0x02)\n#define PHY_CCA_MODE                      (0x03)\n#define MAC_ASSOCIATION_PERMIT            (0x41)\n#define MAC_AUTO_REQUEST                  (0x42)\n#define MAC_BATT_LIFE_EXT                 (0x43)\n#define MAC_BATT_LIFE_EXT_PERIODS         (0x44)\n#define MAC_BEACON_PAYLOAD                (0x45)\n#define MAC_BEACON_PAYLOAD_LENGTH         (0x46)\n#define MAC_BEACON_ORDER                  (0x47)\n#define MAC_GTS_PERMIT                    (0x4d)\n#define MAC_MAX_CSMA_BACKOFFS             (0x4e)\n#define MAC_MIN_BE                        (0x4f)\n#define MAC_PAN_ID                        (0x50)\n#define MAC_PROMISCUOUS_MODE              (0x51)\n#define MAC_RX_ON_WHEN_IDLE               (0x52)\n#define MAC_SHORT_ADDRESS                 (0x53)\n#define MAC_SUPERFRAME_ORDER              (0x54)\n#define MAC_ASSOCIATED_PAN_COORD          (0x56)\n#define MAC_MAX_BE                        (0x57)\n#define MAC_MAX_FRAME_RETRIES             (0x59)\n#define MAC_RESPONSE_WAIT_TIME            (0x5A)\n#define MAC_SECURITY_ENABLED              (0x5D)\n\n#define MAC_AUTO_REQUEST_SECURITY_LEVEL   (0x78)\n#define MAC_AUTO_REQUEST_KEY_ID_MODE      (0x79)\n\n#define NS_IEEE_ADDRESS                   (0xFF) /* Non-standard IEEE address */\n\n/* MAC Address Mode Definitions */\n#define MAC_MODE_NO_ADDR                (0x00)\n#define MAC_MODE_SHORT_ADDR             (0x02)\n#define MAC_MODE_LONG_ADDR              (0x03)\n\n/* MAC constants */\n#define MAX_BEACON_OVERHEAD        (75)\n#define MAX_BEACON_PAYLOAD_LENGTH  (IEEE802154_MTU - MAX_BEACON_OVERHEAD)\n\n#define MAX_ATTRIBUTE_SIZE              (122)\n#define MAX_DATA_SIZE                   (114)\n\n#define CA8210_VALID_CHANNELS                 (0x07FFF800)\n\n/* MAC workarounds for V1.1 and MPW silicon (V0.x) */\n#define CA8210_MAC_WORKAROUNDS (0)\n#define CA8210_MAC_MPW         (0)\n\n/* memory manipulation macros */\n#define LS_BYTE(x)     ((u8)((x) & 0xFF))\n#define MS_BYTE(x)     ((u8)(((x) >> 8) & 0xFF))\n\n/* message ID codes in SPI commands */\n/* downstream */\n#define MCPS_DATA_REQUEST                     (0x00)\n#define MLME_ASSOCIATE_REQUEST                (0x02)\n#define MLME_ASSOCIATE_RESPONSE               (0x03)\n#define MLME_DISASSOCIATE_REQUEST             (0x04)\n#define MLME_GET_REQUEST                      (0x05)\n#define MLME_ORPHAN_RESPONSE                  (0x06)\n#define MLME_RESET_REQUEST                    (0x07)\n#define MLME_RX_ENABLE_REQUEST                (0x08)\n#define MLME_SCAN_REQUEST                     (0x09)\n#define MLME_SET_REQUEST                      (0x0A)\n#define MLME_START_REQUEST                    (0x0B)\n#define MLME_POLL_REQUEST                     (0x0D)\n#define HWME_SET_REQUEST                      (0x0E)\n#define HWME_GET_REQUEST                      (0x0F)\n#define TDME_SETSFR_REQUEST                   (0x11)\n#define TDME_GETSFR_REQUEST                   (0x12)\n#define TDME_SET_REQUEST                      (0x14)\n/* upstream */\n#define MCPS_DATA_INDICATION                  (0x00)\n#define MCPS_DATA_CONFIRM                     (0x01)\n#define MLME_RESET_CONFIRM                    (0x0A)\n#define MLME_SET_CONFIRM                      (0x0E)\n#define MLME_START_CONFIRM                    (0x0F)\n#define HWME_SET_CONFIRM                      (0x12)\n#define HWME_GET_CONFIRM                      (0x13)\n#define HWME_WAKEUP_INDICATION\t\t      (0x15)\n#define TDME_SETSFR_CONFIRM                   (0x17)\n\n/* SPI command IDs */\n/* bit indicating a confirm or indication from slave to master */\n#define SPI_S2M                            (0x20)\n/* bit indicating a synchronous message */\n#define SPI_SYN                            (0x40)\n\n/* SPI command definitions */\n#define SPI_IDLE                           (0xFF)\n#define SPI_NACK                           (0xF0)\n\n#define SPI_MCPS_DATA_REQUEST          (MCPS_DATA_REQUEST)\n#define SPI_MCPS_DATA_INDICATION       (MCPS_DATA_INDICATION + SPI_S2M)\n#define SPI_MCPS_DATA_CONFIRM          (MCPS_DATA_CONFIRM + SPI_S2M)\n\n#define SPI_MLME_ASSOCIATE_REQUEST     (MLME_ASSOCIATE_REQUEST)\n#define SPI_MLME_RESET_REQUEST         (MLME_RESET_REQUEST + SPI_SYN)\n#define SPI_MLME_SET_REQUEST           (MLME_SET_REQUEST + SPI_SYN)\n#define SPI_MLME_START_REQUEST         (MLME_START_REQUEST + SPI_SYN)\n#define SPI_MLME_RESET_CONFIRM         (MLME_RESET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_SET_CONFIRM           (MLME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_START_CONFIRM         (MLME_START_CONFIRM + SPI_S2M + SPI_SYN)\n\n#define SPI_HWME_SET_REQUEST           (HWME_SET_REQUEST + SPI_SYN)\n#define SPI_HWME_GET_REQUEST           (HWME_GET_REQUEST + SPI_SYN)\n#define SPI_HWME_SET_CONFIRM           (HWME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_GET_CONFIRM           (HWME_GET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_WAKEUP_INDICATION     (HWME_WAKEUP_INDICATION + SPI_S2M)\n\n#define SPI_TDME_SETSFR_REQUEST        (TDME_SETSFR_REQUEST + SPI_SYN)\n#define SPI_TDME_SET_REQUEST           (TDME_SET_REQUEST + SPI_SYN)\n#define SPI_TDME_SETSFR_CONFIRM        (TDME_SETSFR_CONFIRM + SPI_S2M + SPI_SYN)\n\n/* TDME SFR addresses */\n/* Page 0 */\n#define CA8210_SFR_PACFG                   (0xB1)\n#define CA8210_SFR_MACCON                  (0xD8)\n#define CA8210_SFR_PACFGIB                 (0xFE)\n/* Page 1 */\n#define CA8210_SFR_LOTXCAL                 (0xBF)\n#define CA8210_SFR_PTHRH                   (0xD1)\n#define CA8210_SFR_PRECFG                  (0xD3)\n#define CA8210_SFR_LNAGX40                 (0xE1)\n#define CA8210_SFR_LNAGX41                 (0xE2)\n#define CA8210_SFR_LNAGX42                 (0xE3)\n#define CA8210_SFR_LNAGX43                 (0xE4)\n#define CA8210_SFR_LNAGX44                 (0xE5)\n#define CA8210_SFR_LNAGX45                 (0xE6)\n#define CA8210_SFR_LNAGX46                 (0xE7)\n#define CA8210_SFR_LNAGX47                 (0xE9)\n\n#define PACFGIB_DEFAULT_CURRENT            (0x3F)\n#define PTHRH_DEFAULT_THRESHOLD            (0x5A)\n#define LNAGX40_DEFAULT_GAIN               (0x29) /* 10dB */\n#define LNAGX41_DEFAULT_GAIN               (0x54) /* 21dB */\n#define LNAGX42_DEFAULT_GAIN               (0x6C) /* 27dB */\n#define LNAGX43_DEFAULT_GAIN               (0x7A) /* 30dB */\n#define LNAGX44_DEFAULT_GAIN               (0x84) /* 33dB */\n#define LNAGX45_DEFAULT_GAIN               (0x8B) /* 34dB */\n#define LNAGX46_DEFAULT_GAIN               (0x92) /* 36dB */\n#define LNAGX47_DEFAULT_GAIN               (0x96) /* 37dB */\n\n#define CA8210_IOCTL_HARD_RESET            (0x00)\n\n/* Structs/Enums */\n\n/**\n * struct cas_control - spi transfer structure\n * @msg:                  spi_message for each exchange\n * @transfer:             spi_transfer for each exchange\n * @tx_buf:               source array for transmission\n * @tx_in_buf:            array storing bytes received during transmission\n * @priv:                 pointer to private data\n *\n * This structure stores all the necessary data passed around during a single\n * spi exchange.\n */\nstruct cas_control {\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\n\tu8 tx_buf[CA8210_SPI_BUF_SIZE];\n\tu8 tx_in_buf[CA8210_SPI_BUF_SIZE];\n\n\tstruct ca8210_priv *priv;\n};\n\n/**\n * struct ca8210_test - ca8210 test interface structure\n * @ca8210_dfs_spi_int: pointer to the entry in the debug fs for this device\n * @up_fifo:            fifo for upstream messages\n *\n * This structure stores all the data pertaining to the debug interface\n */\nstruct ca8210_test {\n\tstruct dentry *ca8210_dfs_spi_int;\n\tstruct kfifo up_fifo;\n\twait_queue_head_t readq;\n};\n\n/**\n * struct ca8210_priv - ca8210 private data structure\n * @spi:                    pointer to the ca8210 spi device object\n * @hw:                     pointer to the ca8210 ieee802154_hw object\n * @hw_registered:          true if hw has been registered with ieee802154\n * @lock:                   spinlock protecting the private data area\n * @mlme_workqueue:           workqueue for triggering MLME Reset\n * @irq_workqueue:          workqueue for irq processing\n * @tx_skb:                 current socket buffer to transmit\n * @nextmsduhandle:         msdu handle to pass to the 15.4 MAC layer for the\n *                           next transmission\n * @clk:                    external clock provided by the ca8210\n * @last_dsn:               sequence number of last data packet received, for\n *                           resend detection\n * @test:                   test interface data section for this instance\n * @async_tx_pending:       true if an asynchronous transmission was started and\n *                           is not complete\n * @sync_command_response:  pointer to buffer to fill with sync response\n * @ca8210_is_awake:        nonzero if ca8210 is initialised, ready for comms\n * @sync_down:              counts number of downstream synchronous commands\n * @sync_up:                counts number of upstream synchronous commands\n * @spi_transfer_complete   completion object for a single spi_transfer\n * @sync_exchange_complete  completion object for a complete synchronous API\n *                           exchange\n * @promiscuous             whether the ca8210 is in promiscuous mode or not\n * @retries:                records how many times the current pending spi\n *                           transfer has been retried\n */\nstruct ca8210_priv {\n\tstruct spi_device *spi;\n\tstruct ieee802154_hw *hw;\n\tbool hw_registered;\n\tspinlock_t lock;\n\tstruct workqueue_struct *mlme_workqueue;\n\tstruct workqueue_struct *irq_workqueue;\n\tstruct sk_buff *tx_skb;\n\tu8 nextmsduhandle;\n\tstruct clk *clk;\n\tint last_dsn;\n\tstruct ca8210_test test;\n\tbool async_tx_pending;\n\tu8 *sync_command_response;\n\tstruct completion ca8210_is_awake;\n\tint sync_down, sync_up;\n\tstruct completion spi_transfer_complete, sync_exchange_complete;\n\tbool promiscuous;\n\tint retries;\n};\n\n/**\n * struct work_priv_container - link between a work object and the relevant\n *                              device's private data\n * @work: work object being executed\n * @priv: device's private data section\n *\n */\nstruct work_priv_container {\n\tstruct work_struct work;\n\tstruct ca8210_priv *priv;\n};\n\n/**\n * struct ca8210_platform_data - ca8210 platform data structure\n * @extclockenable: true if the external clock is to be enabled\n * @extclockfreq:   frequency of the external clock\n * @extclockgpio:   ca8210 output gpio of the external clock\n * @gpio_reset:     gpio number of ca8210 reset line\n * @gpio_irq:       gpio number of ca8210 interrupt line\n * @irq_id:         identifier for the ca8210 irq\n *\n */\nstruct ca8210_platform_data {\n\tbool extclockenable;\n\tunsigned int extclockfreq;\n\tunsigned int extclockgpio;\n\tint gpio_reset;\n\tint gpio_irq;\n\tint irq_id;\n};\n\n/**\n * struct fulladdr - full MAC addressing information structure\n * @mode:    address mode (none, short, extended)\n * @pan_id:  16-bit LE pan id\n * @address: LE address, variable length as specified by mode\n *\n */\nstruct fulladdr {\n\tu8         mode;\n\tu8         pan_id[2];\n\tu8         address[8];\n};\n\n/**\n * union macaddr: generic MAC address container\n * @short_addr:   16-bit short address\n * @ieee_address: 64-bit extended address as LE byte array\n *\n */\nunion macaddr {\n\tu16        short_address;\n\tu8         ieee_address[8];\n};\n\n/**\n * struct secspec: security specification for SAP commands\n * @security_level: 0-7, controls level of authentication & encryption\n * @key_id_mode:    0-3, specifies how to obtain key\n * @key_source:     extended key retrieval data\n * @key_index:      single-byte key identifier\n *\n */\nstruct secspec {\n\tu8         security_level;\n\tu8         key_id_mode;\n\tu8         key_source[8];\n\tu8         key_index;\n};\n\n/* downlink functions parameter set definitions */\nstruct mcps_data_request_pset {\n\tu8              src_addr_mode;\n\tstruct fulladdr dst;\n\tu8              msdu_length;\n\tu8              msdu_handle;\n\tu8              tx_options;\n\tu8              msdu[MAX_DATA_SIZE];\n};\n\nstruct mlme_set_request_pset {\n\tu8         pib_attribute;\n\tu8         pib_attribute_index;\n\tu8         pib_attribute_length;\n\tu8         pib_attribute_value[MAX_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_set_request_pset {\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_get_request_pset {\n\tu8         hw_attribute;\n};\n\nstruct tdme_setsfr_request_pset {\n\tu8         sfr_page;\n\tu8         sfr_address;\n\tu8         sfr_value;\n};\n\n/* uplink functions parameter set definitions */\nstruct hwme_set_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n};\n\nstruct hwme_get_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct tdme_setsfr_confirm_pset {\n\tu8         status;\n\tu8         sfr_page;\n\tu8         sfr_address;\n};\n\nstruct mac_message {\n\tu8      command_id;\n\tu8      length;\n\tunion {\n\t\tstruct mcps_data_request_pset       data_req;\n\t\tstruct mlme_set_request_pset        set_req;\n\t\tstruct hwme_set_request_pset        hwme_set_req;\n\t\tstruct hwme_get_request_pset        hwme_get_req;\n\t\tstruct tdme_setsfr_request_pset     tdme_set_sfr_req;\n\t\tstruct hwme_set_confirm_pset        hwme_set_cnf;\n\t\tstruct hwme_get_confirm_pset        hwme_get_cnf;\n\t\tstruct tdme_setsfr_confirm_pset     tdme_set_sfr_cnf;\n\t\tu8                                  u8param;\n\t\tu8                                  status;\n\t\tu8                                  payload[148];\n\t} pdata;\n};\n\nunion pa_cfg_sfr {\n\tstruct {\n\t\tu8 bias_current_trim     : 3;\n\t\tu8 /* reserved */        : 1;\n\t\tu8 buffer_capacitor_trim : 3;\n\t\tu8 boost                 : 1;\n\t};\n\tu8 paib;\n};\n\nstruct preamble_cfg_sfr {\n\tu8 timeout_symbols      : 3;\n\tu8 acquisition_symbols  : 3;\n\tu8 search_symbols       : 2;\n};\n\nstatic int (*cascoda_api_upstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tvoid *device_ref\n);\n\n/**\n * link_to_linux_err() - Translates an 802.15.4 return code into the closest\n *                       linux error\n * @link_status:  802.15.4 status code\n *\n * Return: 0 or Linux error code\n */\nstatic int link_to_linux_err(int link_status)\n{\n\tif (link_status < 0) {\n\t\t/* status is already a Linux code */\n\t\treturn link_status;\n\t}\n\tswitch (link_status) {\n\tcase MAC_SUCCESS:\n\tcase MAC_REALIGNMENT:\n\t\treturn 0;\n\tcase MAC_IMPROPER_KEY_TYPE:\n\t\treturn -EKEYREJECTED;\n\tcase MAC_IMPROPER_SECURITY_LEVEL:\n\tcase MAC_UNSUPPORTED_LEGACY:\n\tcase MAC_DENIED:\n\t\treturn -EACCES;\n\tcase MAC_BEACON_LOST:\n\tcase MAC_NO_ACK:\n\tcase MAC_NO_BEACON:\n\t\treturn -ENETUNREACH;\n\tcase MAC_CHANNEL_ACCESS_FAILURE:\n\tcase MAC_TX_ACTIVE:\n\tcase MAC_SCAN_IN_PROGRESS:\n\t\treturn -EBUSY;\n\tcase MAC_DISABLE_TRX_FAILURE:\n\tcase MAC_OUT_OF_CAP:\n\t\treturn -EAGAIN;\n\tcase MAC_FRAME_TOO_LONG:\n\t\treturn -EMSGSIZE;\n\tcase MAC_INVALID_GTS:\n\tcase MAC_PAST_TIME:\n\t\treturn -EBADSLT;\n\tcase MAC_INVALID_HANDLE:\n\t\treturn -EBADMSG;\n\tcase MAC_INVALID_PARAMETER:\n\tcase MAC_UNSUPPORTED_ATTRIBUTE:\n\tcase MAC_ON_TIME_TOO_LONG:\n\tcase MAC_INVALID_INDEX:\n\t\treturn -EINVAL;\n\tcase MAC_NO_DATA:\n\t\treturn -ENODATA;\n\tcase MAC_NO_SHORT_ADDRESS:\n\t\treturn -EFAULT;\n\tcase MAC_PAN_ID_CONFLICT:\n\t\treturn -EADDRINUSE;\n\tcase MAC_TRANSACTION_EXPIRED:\n\t\treturn -ETIME;\n\tcase MAC_TRANSACTION_OVERFLOW:\n\t\treturn -ENOBUFS;\n\tcase MAC_UNAVAILABLE_KEY:\n\t\treturn -ENOKEY;\n\tcase MAC_INVALID_ADDRESS:\n\t\treturn -ENXIO;\n\tcase MAC_TRACKING_OFF:\n\tcase MAC_SUPERFRAME_OVERLAP:\n\t\treturn -EREMOTEIO;\n\tcase MAC_LIMIT_REACHED:\n\t\treturn -EDQUOT;\n\tcase MAC_READ_ONLY:\n\t\treturn -EROFS;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\n/**\n * ca8210_test_int_driver_write() - Writes a message to the test interface to be\n *                                  read by the userspace\n * @buf:  Buffer containing upstream message\n * @len:  length of message to write\n * @spi:  SPI device of message originator\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_int_driver_write(\n\tconst u8       *buf,\n\tsize_t          len,\n\tvoid           *spi\n)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_test *test = &priv->test;\n\tchar *fifo_buffer;\n\tint i;\n\n\tdev_dbg(\n\t\t&priv->spi->dev,\n\t\t\"test_interface: Buffering upstream message:\\n\"\n\t);\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", buf[i]);\n\n\tfifo_buffer = kmemdup(buf, len, GFP_KERNEL);\n\tif (!fifo_buffer)\n\t\treturn -ENOMEM;\n\tkfifo_in(&test->up_fifo, &fifo_buffer, 4);\n\twake_up_interruptible(&priv->test.readq);\n\n\treturn 0;\n}\n\n/* SPI Operation */\n\nstatic int ca8210_net_rx(\n\tstruct ieee802154_hw  *hw,\n\tu8                    *command,\n\tsize_t                 len\n);\nstatic u8 mlme_reset_request_sync(\n\tu8       set_default_pib,\n\tvoid    *device_ref\n);\nstatic int ca8210_spi_transfer(\n\tstruct spi_device *spi,\n\tconst u8          *buf,\n\tsize_t             len\n);\n\n/**\n * ca8210_reset_send() - Hard resets the ca8210 for a given time\n * @spi:  Pointer to target ca8210 spi device\n * @ms:   Milliseconds to hold the reset line low for\n */\nstatic void ca8210_reset_send(struct spi_device *spi, unsigned int ms)\n{\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tlong status;\n\n\tgpio_set_value(pdata->gpio_reset, 0);\n\treinit_completion(&priv->ca8210_is_awake);\n\tmsleep(ms);\n\tgpio_set_value(pdata->gpio_reset, 1);\n\tpriv->promiscuous = false;\n\n\t/* Wait until wakeup indication seen */\n\tstatus = wait_for_completion_interruptible_timeout(\n\t\t&priv->ca8210_is_awake,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (status == 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Fatal: No wakeup from ca8210 after reset!\\n\"\n\t\t);\n\t}\n\n\tdev_dbg(&spi->dev, \"Reset the device\\n\");\n}\n\n/**\n * ca8210_mlme_reset_worker() - Resets the MLME, Called when the MAC OVERFLOW\n *                              condition happens.\n * @work:  Pointer to work being executed\n */\nstatic void ca8210_mlme_reset_worker(struct work_struct *work)\n{\n\tstruct work_priv_container *wpc = container_of(\n\t\twork,\n\t\tstruct work_priv_container,\n\t\twork\n\t);\n\tstruct ca8210_priv *priv = wpc->priv;\n\n\tmlme_reset_request_sync(0, priv->spi);\n\tkfree(wpc);\n}\n\n/**\n * ca8210_rx_done() - Calls various message dispatches responding to a received\n *                    command\n * @arg:  Pointer to the cas_control object for the relevant spi transfer\n *\n * Presents a received SAP command from the ca8210 to the Cascoda EVBME, test\n * interface and network driver.\n */\nstatic void ca8210_rx_done(struct cas_control *cas_ctl)\n{\n\tu8 *buf;\n\tunsigned int len;\n\tstruct work_priv_container *mlme_reset_wpc;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\n\tbuf = cas_ctl->tx_in_buf;\n\tlen = buf[1] + 2;\n\tif (len > CA8210_SPI_BUF_SIZE) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Received packet len (%u) erroneously long\\n\",\n\t\t\tlen\n\t\t);\n\t\tgoto finish;\n\t}\n\n\tif (buf[0] & SPI_SYN) {\n\t\tif (priv->sync_command_response) {\n\t\t\tmemcpy(priv->sync_command_response, buf, len);\n\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t} else {\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t\t\tpriv->sync_up++;\n\t\t}\n\t} else {\n\t\tif (cascoda_api_upstream)\n\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t}\n\n\tca8210_net_rx(priv->hw, buf, len);\n\tif (buf[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tif (buf[3] == MAC_TRANSACTION_OVERFLOW) {\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Waiting for transaction overflow to stabilise...\\n\");\n\t\t\tmsleep(2000);\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Resetting MAC...\\n\");\n\n\t\t\tmlme_reset_wpc = kmalloc(sizeof(*mlme_reset_wpc),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!mlme_reset_wpc)\n\t\t\t\tgoto finish;\n\t\t\tINIT_WORK(\n\t\t\t\t&mlme_reset_wpc->work,\n\t\t\t\tca8210_mlme_reset_worker\n\t\t\t);\n\t\t\tmlme_reset_wpc->priv = priv;\n\t\t\tqueue_work(priv->mlme_workqueue, &mlme_reset_wpc->work);\n\t\t}\n\t} else if (buf[0] == SPI_HWME_WAKEUP_INDICATION) {\n\t\tdev_notice(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Wakeup indication received, reason:\\n\"\n\t\t);\n\t\tswitch (buf[2]) {\n\t\tcase 0:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power Up / System Reset\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Watchdog Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by Sleep Timer Time-Out\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by Sleep Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Sleep-Timer Time-Out in Active Mode\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&priv->spi->dev, \"Wakeup reason unknown\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcomplete(&priv->ca8210_is_awake);\n\t}\n\nfinish:;\n}\n\nstatic int ca8210_remove(struct spi_device *spi_device);\n\n/**\n * ca8210_spi_transfer_complete() - Called when a single spi transfer has\n *                                  completed\n * @context:  Pointer to the cas_control object for the finished transfer\n */\nstatic void ca8210_spi_transfer_complete(void *context)\n{\n\tstruct cas_control *cas_ctl = context;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\tbool duplex_rx = false;\n\tint i;\n\tu8 retry_buffer[CA8210_SPI_BUF_SIZE];\n\n\tif (\n\t\tcas_ctl->tx_in_buf[0] == SPI_NACK ||\n\t\t(cas_ctl->tx_in_buf[0] == SPI_IDLE &&\n\t\tcas_ctl->tx_in_buf[1] == SPI_NACK)\n\t) {\n\t\t/* ca8210 is busy */\n\t\tdev_info(&priv->spi->dev, \"ca8210 was busy during attempted write\\n\");\n\t\tif (cas_ctl->tx_buf[0] == SPI_IDLE) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"IRQ servicing NACKd, dropping transfer\\n\"\n\t\t\t);\n\t\t\tkfree(cas_ctl);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->retries > 3) {\n\t\t\tdev_err(&priv->spi->dev, \"too many retries!\\n\");\n\t\t\tkfree(cas_ctl);\n\t\t\tca8210_remove(priv->spi);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(retry_buffer, cas_ctl->tx_buf, CA8210_SPI_BUF_SIZE);\n\t\tkfree(cas_ctl);\n\t\tca8210_spi_transfer(\n\t\t\tpriv->spi,\n\t\t\tretry_buffer,\n\t\t\tCA8210_SPI_BUF_SIZE\n\t\t);\n\t\tpriv->retries++;\n\t\tdev_info(&priv->spi->dev, \"retried spi write\\n\");\n\t\treturn;\n\t} else if (\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_IDLE &&\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_NACK\n\t\t) {\n\t\tduplex_rx = true;\n\t}\n\n\tif (duplex_rx) {\n\t\tdev_dbg(&priv->spi->dev, \"READ CMD DURING TX\\n\");\n\t\tfor (i = 0; i < cas_ctl->tx_in_buf[1] + 2; i++)\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"%#03x\\n\",\n\t\t\t\tcas_ctl->tx_in_buf[i]\n\t\t\t);\n\t\tca8210_rx_done(cas_ctl);\n\t}\n\tcomplete(&priv->spi_transfer_complete);\n\tkfree(cas_ctl);\n\tpriv->retries = 0;\n}\n\n/**\n * ca8210_spi_transfer() - Initiate duplex spi transfer with ca8210\n * @spi: Pointer to spi device for transfer\n * @buf: Octet array to send\n * @len: length of the buffer being sent\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_spi_transfer(\n\tstruct spi_device  *spi,\n\tconst u8           *buf,\n\tsize_t              len\n)\n{\n\tint i, status = 0;\n\tstruct ca8210_priv *priv;\n\tstruct cas_control *cas_ctl;\n\n\tif (!spi) {\n\t\tpr_crit(\"NULL spi device passed to %s\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = spi_get_drvdata(spi);\n\treinit_completion(&priv->spi_transfer_complete);\n\n\tdev_dbg(&spi->dev, \"%s called\\n\", __func__);\n\n\tcas_ctl = kmalloc(sizeof(*cas_ctl), GFP_ATOMIC);\n\tif (!cas_ctl)\n\t\treturn -ENOMEM;\n\n\tcas_ctl->priv = priv;\n\tmemset(cas_ctl->tx_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemset(cas_ctl->tx_in_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemcpy(cas_ctl->tx_buf, buf, len);\n\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&spi->dev, \"%#03x\\n\", cas_ctl->tx_buf[i]);\n\n\tspi_message_init(&cas_ctl->msg);\n\n\tcas_ctl->transfer.tx_nbits = 1; /* 1 MOSI line */\n\tcas_ctl->transfer.rx_nbits = 1; /* 1 MISO line */\n\tcas_ctl->transfer.speed_hz = 0; /* Use device setting */\n\tcas_ctl->transfer.bits_per_word = 0; /* Use device setting */\n\tcas_ctl->transfer.tx_buf = cas_ctl->tx_buf;\n\tcas_ctl->transfer.rx_buf = cas_ctl->tx_in_buf;\n\tcas_ctl->transfer.delay_usecs = 0;\n\tcas_ctl->transfer.cs_change = 0;\n\tcas_ctl->transfer.len = sizeof(struct mac_message);\n\tcas_ctl->msg.complete = ca8210_spi_transfer_complete;\n\tcas_ctl->msg.context = cas_ctl;\n\n\tspi_message_add_tail(\n\t\t&cas_ctl->transfer,\n\t\t&cas_ctl->msg\n\t);\n\n\tstatus = spi_async(spi, &cas_ctl->msg);\n\tif (status < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"status %d from spi_sync in write\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * ca8210_spi_exchange() - Exchange API/SAP commands with the radio\n * @buf:         Octet array of command being sent downstream\n * @len:         length of buf\n * @response:    buffer for storing synchronous response\n * @device_ref:  spi_device pointer for ca8210\n *\n * Effectively calls ca8210_spi_transfer to write buf[] to the spi, then for\n * synchronous commands waits for the corresponding response to be read from\n * the spi before returning. The response is written to the response parameter.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_spi_exchange(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n)\n{\n\tint status = 0;\n\tstruct spi_device *spi = device_ref;\n\tstruct ca8210_priv *priv = spi->dev.driver_data;\n\tlong wait_remaining;\n\n\tif ((buf[0] & SPI_SYN) && response) { /* if sync wait for confirm */\n\t\treinit_completion(&priv->sync_exchange_complete);\n\t\tpriv->sync_command_response = response;\n\t}\n\n\tdo {\n\t\treinit_completion(&priv->spi_transfer_complete);\n\t\tstatus = ca8210_spi_transfer(priv->spi, buf, len);\n\t\tif (status) {\n\t\t\tdev_warn(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"spi write failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\tif (status == -EBUSY)\n\t\t\t\tcontinue;\n\t\t\tif (((buf[0] & SPI_SYN) && response))\n\t\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t\t&priv->spi_transfer_complete,\n\t\t\tmsecs_to_jiffies(1000)\n\t\t);\n\t\tif (wait_remaining == -ERESTARTSYS) {\n\t\t\tstatus = -ERESTARTSYS;\n\t\t} else if (wait_remaining == 0) {\n\t\t\tdev_err(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"SPI downstream transfer timed out!\\n\"\n\t\t\t);\n\t\t\tstatus = -ETIME;\n\t\t\tgoto cleanup;\n\t\t}\n\t} while (status < 0);\n\n\tif (!((buf[0] & SPI_SYN) && response))\n\t\tgoto cleanup;\n\n\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t&priv->sync_exchange_complete,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (wait_remaining == -ERESTARTSYS) {\n\t\tstatus = -ERESTARTSYS;\n\t} else if (wait_remaining == 0) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"Synchronous confirm timeout\\n\"\n\t\t);\n\t\tstatus = -ETIME;\n\t}\n\ncleanup:\n\tpriv->sync_command_response = NULL;\n\treturn status;\n}\n\n/**\n * ca8210_interrupt_handler() - Called when an irq is received from the ca8210\n * @irq:     Id of the irq being handled\n * @dev_id:  Pointer passed by the system, pointing to the ca8210's private data\n *\n * This function is called when the irq line from the ca8210 is asserted,\n * signifying that the ca8210 has a message to send upstream to us. Starts the\n * asynchronous spi read.\n *\n * Return: irq return code\n */\nstatic irqreturn_t ca8210_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct ca8210_priv *priv = dev_id;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"irq: Interrupt occurred\\n\");\n\tdo {\n\t\tstatus = ca8210_spi_transfer(priv->spi, NULL, 0);\n\t\tif (status && (status != -EBUSY)) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi read failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t} while (status == -EBUSY);\n\treturn IRQ_HANDLED;\n}\n\nstatic int (*cascoda_api_downstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n) = ca8210_spi_exchange;\n\n/* Cascoda API / 15.4 SAP Primitives */\n\n/**\n * tdme_setsfr_request_sync() - TDME_SETSFR_request/confirm according to API\n * @sfr_page:    SFR Page\n * @sfr_address: SFR Address\n * @sfr_value:   SFR Value\n * @device_ref:  Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of TDME-SETSFR.confirm\n */\nstatic u8 tdme_setsfr_request_sync(\n\tu8            sfr_page,\n\tu8            sfr_address,\n\tu8            sfr_value,\n\tvoid         *device_ref\n)\n{\n\tint ret;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_TDME_SETSFR_REQUEST;\n\tcommand.length = 3;\n\tcommand.pdata.tdme_set_sfr_req.sfr_page    = sfr_page;\n\tcommand.pdata.tdme_set_sfr_req.sfr_address = sfr_address;\n\tcommand.pdata.tdme_set_sfr_req.sfr_value   = sfr_value;\n\tresponse.command_id = SPI_IDLE;\n\tret = cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"cascoda_api_downstream returned %d\", ret);\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_TDME_SETSFR_CONFIRM) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"sync response to SPI_TDME_SETSFR_REQUEST was not SPI_TDME_SETSFR_CONFIRM, it was %d\\n\",\n\t\t\tresponse.command_id\n\t\t);\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\treturn response.pdata.tdme_set_sfr_cnf.status;\n}\n\n/**\n * tdme_chipinit() - TDME Chip Register Default Initialisation Macro\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of API calls\n */\nstatic u8 tdme_chipinit(void *device_ref)\n{\n\tu8 status = MAC_SUCCESS;\n\tu8 sfr_address;\n\tstruct spi_device *spi = device_ref;\n\tstruct preamble_cfg_sfr pre_cfg_value = {\n\t\t.timeout_symbols     = 3,\n\t\t.acquisition_symbols = 3,\n\t\t.search_symbols      = 1,\n\t};\n\t/* LNA Gain Settings */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX40),\n\t\tLNAGX40_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX41),\n\t\tLNAGX41_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX42),\n\t\tLNAGX42_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX43),\n\t\tLNAGX43_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX44),\n\t\tLNAGX44_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX45),\n\t\tLNAGX45_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX46),\n\t\tLNAGX46_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX47),\n\t\tLNAGX47_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Preamble Timing Config */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PRECFG),\n\t\t*((u8 *)&pre_cfg_value), device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Preamble Threshold High */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PTHRH),\n\t\tPTHRH_DEFAULT_THRESHOLD, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Tx Output Power 8 dBm */\n\tstatus = tdme_setsfr_request_sync(\n\t\t0, (sfr_address = CA8210_SFR_PACFGIB),\n\t\tPACFGIB_DEFAULT_CURRENT, device_ref);\n\tif (status)\n\t\tgoto finish;\n\nfinish:\n\tif (status != MAC_SUCCESS) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"failed to set sfr at %#03x, status = %#03x\\n\",\n\t\t\tsfr_address,\n\t\t\tstatus\n\t\t);\n\t}\n\treturn status;\n}\n\n/**\n * tdme_channelinit() - TDME Channel Register Default Initialisation Macro (Tx)\n * @channel:    802.15.4 channel to initialise chip for\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of API calls\n */\nstatic u8 tdme_channelinit(u8 channel, void *device_ref)\n{\n\t/* Transceiver front-end local oscillator tx two-point calibration\n\t * value. Tuned for the hardware.\n\t */\n\tu8 txcalval;\n\n\tif (channel >= 25)\n\t\ttxcalval = 0xA7;\n\telse if (channel >= 23)\n\t\ttxcalval = 0xA8;\n\telse if (channel >= 22)\n\t\ttxcalval = 0xA9;\n\telse if (channel >= 20)\n\t\ttxcalval = 0xAA;\n\telse if (channel >= 17)\n\t\ttxcalval = 0xAB;\n\telse if (channel >= 16)\n\t\ttxcalval = 0xAC;\n\telse if (channel >= 14)\n\t\ttxcalval = 0xAD;\n\telse if (channel >= 12)\n\t\ttxcalval = 0xAE;\n\telse\n\t\ttxcalval = 0xAF;\n\n\treturn tdme_setsfr_request_sync(\n\t\t1,\n\t\tCA8210_SFR_LOTXCAL,\n\t\ttxcalval,\n\t\tdevice_ref\n\t);  /* LO Tx Cal */\n}\n\n/**\n * tdme_checkpibattribute() - Checks Attribute Values that are not checked in\n *                            MAC\n * @pib_attribute:        Attribute Number\n * @pib_attribute_length: Attribute length\n * @pib_attribute_value:  Pointer to Attribute Value\n * @device_ref:           Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of checks\n */\nstatic u8 tdme_checkpibattribute(\n\tu8            pib_attribute,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value\n)\n{\n\tu8 status = MAC_SUCCESS;\n\tu8 value;\n\n\tvalue  = *((u8 *)pib_attribute_value);\n\n\tswitch (pib_attribute) {\n\t/* PHY */\n\tcase PHY_TRANSMIT_POWER:\n\t\tif (value > 0x3F)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase PHY_CCA_MODE:\n\t\tif (value > 0x03)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* MAC */\n\tcase MAC_BATT_LIFE_EXT_PERIODS:\n\t\tif (value < 6 || value > 41)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD:\n\t\tif (pib_attribute_length > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD_LENGTH:\n\t\tif (value > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_BE:\n\t\tif (value < 3 || value > 8)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_CSMA_BACKOFFS:\n\t\tif (value > 5)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_FRAME_RETRIES:\n\t\tif (value > 7)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MIN_BE:\n\t\tif (value > 8)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_RESPONSE_WAIT_TIME:\n\t\tif (value < 2 || value > 64)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_SUPERFRAME_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* boolean */\n\tcase MAC_ASSOCIATED_PAN_COORD:\n\tcase MAC_ASSOCIATION_PERMIT:\n\tcase MAC_AUTO_REQUEST:\n\tcase MAC_BATT_LIFE_EXT:\n\tcase MAC_GTS_PERMIT:\n\tcase MAC_PROMISCUOUS_MODE:\n\tcase MAC_RX_ON_WHEN_IDLE:\n\tcase MAC_SECURITY_ENABLED:\n\t\tif (value > 1)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* MAC SEC */\n\tcase MAC_AUTO_REQUEST_SECURITY_LEVEL:\n\t\tif (value > 7)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_AUTO_REQUEST_KEY_ID_MODE:\n\t\tif (value > 3)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n/**\n * tdme_settxpower() - Sets the tx power for MLME_SET phyTransmitPower\n * @txp:        Transmit Power\n * @device_ref: Nondescript pointer to target device\n *\n * Normalised to 802.15.4 Definition (6-bit, signed):\n * Bit 7-6: not used\n * Bit 5-0: tx power (-32 - +31 dB)\n *\n * Return: 802.15.4 status code of api calls\n */\nstatic u8 tdme_settxpower(u8 txp, void *device_ref)\n{\n\tu8 status;\n\ts8 txp_val;\n\tu8 txp_ext;\n\tunion pa_cfg_sfr pa_cfg_val;\n\n\t/* extend from 6 to 8 bit */\n\ttxp_ext = 0x3F & txp;\n\tif (txp_ext & 0x20)\n\t\ttxp_ext += 0xC0;\n\ttxp_val = (s8)txp_ext;\n\n\tif (CA8210_MAC_MPW) {\n\t\tif (txp_val > 0) {\n\t\t\t/* 8 dBm: ptrim = 5, itrim = +3 => +4 dBm */\n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 5;\n\t\t\tpa_cfg_val.boost                 = 1;\n\t\t} else {\n\t\t\t/* 0 dBm: ptrim = 7, itrim = +3 => -6 dBm */\n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 7;\n\t\t\tpa_cfg_val.boost                 = 0;\n\t\t}\n\t\t/* write PACFG */\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFG,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t} else {\n\t\t/* Look-Up Table for Setting Current and Frequency Trim values\n\t\t * for desired Output Power\n\t\t */\n\t\tif (txp_val > 8) {\n\t\t\tpa_cfg_val.paib = 0x3F;\n\t\t} else if (txp_val == 8) {\n\t\t\tpa_cfg_val.paib = 0x32;\n\t\t} else if (txp_val == 7) {\n\t\t\tpa_cfg_val.paib = 0x22;\n\t\t} else if (txp_val == 6) {\n\t\t\tpa_cfg_val.paib = 0x18;\n\t\t} else if (txp_val == 5) {\n\t\t\tpa_cfg_val.paib = 0x10;\n\t\t} else if (txp_val == 4) {\n\t\t\tpa_cfg_val.paib = 0x0C;\n\t\t} else if (txp_val == 3) {\n\t\t\tpa_cfg_val.paib = 0x08;\n\t\t} else if (txp_val == 2) {\n\t\t\tpa_cfg_val.paib = 0x05;\n\t\t} else if (txp_val == 1) {\n\t\t\tpa_cfg_val.paib = 0x03;\n\t\t} else if (txp_val == 0) {\n\t\t\tpa_cfg_val.paib = 0x01;\n\t\t} else { /* < 0 */\n\t\t\tpa_cfg_val.paib = 0x00;\n\t\t}\n\t\t/* write PACFGIB */\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFGIB,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * mcps_data_request() - mcps_data_request (Send Data) according to API Spec\n * @src_addr_mode:    Source Addressing Mode\n * @dst_address_mode: Destination Addressing Mode\n * @dst_pan_id:       Destination PAN ID\n * @dst_addr:         Pointer to Destination Address\n * @msdu_length:      length of Data\n * @msdu:             Pointer to Data\n * @msdu_handle:      Handle of Data\n * @tx_options:       Tx Options Bit Field\n * @security:         Pointer to Security Structure or NULL\n * @device_ref:       Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of action\n */\nstatic u8 mcps_data_request(\n\tu8               src_addr_mode,\n\tu8               dst_address_mode,\n\tu16              dst_pan_id,\n\tunion macaddr   *dst_addr,\n\tu8               msdu_length,\n\tu8              *msdu,\n\tu8               msdu_handle,\n\tu8               tx_options,\n\tstruct secspec  *security,\n\tvoid            *device_ref\n)\n{\n\tstruct secspec *psec;\n\tstruct mac_message command;\n\n\tcommand.command_id = SPI_MCPS_DATA_REQUEST;\n\tcommand.pdata.data_req.src_addr_mode = src_addr_mode;\n\tcommand.pdata.data_req.dst.mode = dst_address_mode;\n\tif (dst_address_mode != MAC_MODE_NO_ADDR) {\n\t\tcommand.pdata.data_req.dst.pan_id[0] = LS_BYTE(dst_pan_id);\n\t\tcommand.pdata.data_req.dst.pan_id[1] = MS_BYTE(dst_pan_id);\n\t\tif (dst_address_mode == MAC_MODE_SHORT_ADDR) {\n\t\t\tcommand.pdata.data_req.dst.address[0] = LS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t\tcommand.pdata.data_req.dst.address[1] = MS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t} else {   /* MAC_MODE_LONG_ADDR*/\n\t\t\tmemcpy(\n\t\t\t\tcommand.pdata.data_req.dst.address,\n\t\t\t\tdst_addr->ieee_address,\n\t\t\t\t8\n\t\t\t);\n\t\t}\n\t}\n\tcommand.pdata.data_req.msdu_length = msdu_length;\n\tcommand.pdata.data_req.msdu_handle = msdu_handle;\n\tcommand.pdata.data_req.tx_options = tx_options;\n\tmemcpy(command.pdata.data_req.msdu, msdu, msdu_length);\n\tpsec = (struct secspec *)(command.pdata.data_req.msdu + msdu_length);\n\tcommand.length = sizeof(struct mcps_data_request_pset) -\n\t\tMAX_DATA_SIZE + msdu_length;\n\tif (!security || security->security_level == 0) {\n\t\tpsec->security_level = 0;\n\t\tcommand.length += 1;\n\t} else {\n\t\t*psec = *security;\n\t\tcommand.length += sizeof(struct secspec);\n\t}\n\n\tif (ca8210_spi_transfer(device_ref, &command.command_id,\n\t\t\t\tcommand.length + 2))\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn MAC_SUCCESS;\n}\n\n/**\n * mlme_reset_request_sync() - MLME_RESET_request/confirm according to API Spec\n * @set_default_pib: Set defaults in PIB\n * @device_ref:      Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of MLME-RESET.confirm\n */\nstatic u8 mlme_reset_request_sync(\n\tu8    set_default_pib,\n\tvoid *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_MLME_RESET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.u8param = set_default_pib;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\tdev_err(&spi->dev, \"cascoda_api_downstream failed\\n\");\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_RESET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\tstatus = response.pdata.status;\n\n\t/* reset COORD Bit for Channel Filtering as Coordinator */\n\tif (CA8210_MAC_WORKAROUNDS && set_default_pib && !status) {\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * mlme_set_request_sync() - MLME_SET_request/confirm according to API Spec\n * @pib_attribute:        Attribute Number\n * @pib_attribute_index:  Index within Attribute if an Array\n * @pib_attribute_length: Attribute length\n * @pib_attribute_value:  Pointer to Attribute Value\n * @device_ref:           Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of MLME-SET.confirm\n */\nstatic u8 mlme_set_request_sync(\n\tu8            pib_attribute,\n\tu8            pib_attribute_index,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value,\n\tvoid         *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\n\t/* pre-check the validity of pib_attribute values that are not checked\n\t * in MAC\n\t */\n\tif (tdme_checkpibattribute(\n\t\tpib_attribute, pib_attribute_length, pib_attribute_value)) {\n\t\treturn MAC_INVALID_PARAMETER;\n\t}\n\n\tif (pib_attribute == PHY_CURRENT_CHANNEL) {\n\t\tstatus = tdme_channelinit(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (pib_attribute == PHY_TRANSMIT_POWER) {\n\t\treturn tdme_settxpower(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\tcommand.command_id = SPI_MLME_SET_REQUEST;\n\tcommand.length = sizeof(struct mlme_set_request_pset) -\n\t\tMAX_ATTRIBUTE_SIZE + pib_attribute_length;\n\tcommand.pdata.set_req.pib_attribute = pib_attribute;\n\tcommand.pdata.set_req.pib_attribute_index = pib_attribute_index;\n\tcommand.pdata.set_req.pib_attribute_length = pib_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.set_req.pib_attribute_value,\n\t\tpib_attribute_value,\n\t\tpib_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_SET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn response.pdata.status;\n}\n\n/**\n * hwme_set_request_sync() - HWME_SET_request/confirm according to API Spec\n * @hw_attribute:        Attribute Number\n * @hw_attribute_length: Attribute length\n * @hw_attribute_value:  Pointer to Attribute Value\n * @device_ref:          Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of HWME-SET.confirm\n */\nstatic u8 hwme_set_request_sync(\n\tu8           hw_attribute,\n\tu8           hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_SET_REQUEST;\n\tcommand.length = 2 + hw_attribute_length;\n\tcommand.pdata.hwme_set_req.hw_attribute = hw_attribute;\n\tcommand.pdata.hwme_set_req.hw_attribute_length = hw_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.hwme_set_req.hw_attribute_value,\n\t\thw_attribute_value,\n\t\thw_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_SET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn response.pdata.hwme_set_cnf.status;\n}\n\n/**\n * hwme_get_request_sync() - HWME_GET_request/confirm according to API Spec\n * @hw_attribute:        Attribute Number\n * @hw_attribute_length: Attribute length\n * @hw_attribute_value:  Pointer to Attribute Value\n * @device_ref:          Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of HWME-GET.confirm\n */\nstatic u8 hwme_get_request_sync(\n\tu8           hw_attribute,\n\tu8          *hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_GET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.hwme_get_req.hw_attribute = hw_attribute;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_GET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\tif (response.pdata.hwme_get_cnf.status == MAC_SUCCESS) {\n\t\t*hw_attribute_length =\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_length;\n\t\tmemcpy(\n\t\t\thw_attribute_value,\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_value,\n\t\t\t*hw_attribute_length\n\t\t);\n\t}\n\n\treturn response.pdata.hwme_get_cnf.status;\n}\n\n/* Network driver operation */\n\n/**\n * ca8210_async_xmit_complete() - Called to announce that an asynchronous\n *                                transmission has finished\n * @hw:          ieee802154_hw of ca8210 that has finished exchange\n * @msduhandle:  Identifier of transmission that has completed\n * @status:      Returned 802.15.4 status code of the transmission\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_async_xmit_complete(\n\tstruct ieee802154_hw  *hw,\n\tu8                     msduhandle,\n\tu8                     status)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (priv->nextmsduhandle != msduhandle) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Unexpected msdu_handle on data confirm, Expected %d, got %d\\n\",\n\t\t\tpriv->nextmsduhandle,\n\t\t\tmsduhandle\n\t\t);\n\t\treturn -EIO;\n\t}\n\n\tpriv->async_tx_pending = false;\n\tpriv->nextmsduhandle++;\n\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Link transmission unsuccessful, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\tif (status != MAC_TRANSACTION_OVERFLOW) {\n\t\t\tieee802154_wake_queue(priv->hw);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tieee802154_xmit_complete(priv->hw, priv->tx_skb, true);\n\n\treturn 0;\n}\n\n/**\n * ca8210_skb_rx() - Contructs a properly framed socket buffer from a received\n *                   MCPS_DATA_indication\n * @hw:        ieee802154_hw that MCPS_DATA_indication was received by\n * @len:       length of MCPS_DATA_indication\n * @data_ind:  Octet array of MCPS_DATA_indication\n *\n * Called by the spi driver whenever a SAP command is received, this function\n * will ascertain whether the command is of interest to the network driver and\n * take necessary action.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_skb_rx(\n\tstruct ieee802154_hw  *hw,\n\tsize_t                 len,\n\tu8                    *data_ind\n)\n{\n\tstruct ieee802154_hdr hdr;\n\tint msdulen;\n\tint hlen;\n\tu8 mpdulinkquality = data_ind[23];\n\tstruct sk_buff *skb;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\t/* Allocate mtu size buffer for every rx packet */\n\tskb = dev_alloc_skb(IEEE802154_MTU + sizeof(hdr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, sizeof(hdr));\n\n\tmsdulen = data_ind[22]; /* msdu_length */\n\tif (msdulen > IEEE802154_MTU) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"received erroneously large msdu length!\\n\"\n\t\t);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\tdev_dbg(&priv->spi->dev, \"skb buffer length = %d\\n\", msdulen);\n\n\tif (priv->promiscuous)\n\t\tgoto copy_payload;\n\n\t/* Populate hdr */\n\thdr.sec.level = data_ind[29 + msdulen];\n\tdev_dbg(&priv->spi->dev, \"security level: %#03x\\n\", hdr.sec.level);\n\tif (hdr.sec.level > 0) {\n\t\thdr.sec.key_id_mode = data_ind[30 + msdulen];\n\t\tmemcpy(&hdr.sec.extended_src, &data_ind[31 + msdulen], 8);\n\t\thdr.sec.key_id = data_ind[39 + msdulen];\n\t}\n\thdr.source.mode = data_ind[0];\n\tdev_dbg(&priv->spi->dev, \"srcAddrMode: %#03x\\n\", hdr.source.mode);\n\thdr.source.pan_id = *(u16 *)&data_ind[1];\n\tdev_dbg(&priv->spi->dev, \"srcPanId: %#06x\\n\", hdr.source.pan_id);\n\tmemcpy(&hdr.source.extended_addr, &data_ind[3], 8);\n\thdr.dest.mode = data_ind[11];\n\tdev_dbg(&priv->spi->dev, \"dstAddrMode: %#03x\\n\", hdr.dest.mode);\n\thdr.dest.pan_id = *(u16 *)&data_ind[12];\n\tdev_dbg(&priv->spi->dev, \"dstPanId: %#06x\\n\", hdr.dest.pan_id);\n\tmemcpy(&hdr.dest.extended_addr, &data_ind[14], 8);\n\n\t/* Fill in FC implicitly */\n\thdr.fc.type = 1; /* Data frame */\n\tif (hdr.sec.level)\n\t\thdr.fc.security_enabled = 1;\n\telse\n\t\thdr.fc.security_enabled = 0;\n\tif (data_ind[1] != data_ind[12] || data_ind[2] != data_ind[13])\n\t\thdr.fc.intra_pan = 1;\n\telse\n\t\thdr.fc.intra_pan = 0;\n\thdr.fc.dest_addr_mode = hdr.dest.mode;\n\thdr.fc.source_addr_mode = hdr.source.mode;\n\n\t/* Add hdr to front of buffer */\n\thlen = ieee802154_hdr_push(skb, &hdr);\n\n\tif (hlen < 0) {\n\t\tdev_crit(&priv->spi->dev, \"failed to push mac hdr onto skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn hlen;\n\t}\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = hlen;\n\ncopy_payload:\n\t/* Add <msdulen> bytes of space to the back of the buffer */\n\t/* Copy msdu to skb */\n\tskb_put_data(skb, &data_ind[29], msdulen);\n\n\tieee802154_rx_irqsafe(hw, skb, mpdulinkquality);\n\treturn 0;\n}\n\n/**\n * ca8210_net_rx() - Acts upon received SAP commands relevant to the network\n *                   driver\n * @hw:       ieee802154_hw that command was received by\n * @command:  Octet array of received command\n * @len:      length of the received command\n *\n * Called by the spi driver whenever a SAP command is received, this function\n * will ascertain whether the command is of interest to the network driver and\n * take necessary action.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_net_rx(struct ieee802154_hw *hw, u8 *command, size_t len)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tunsigned long flags;\n\tu8 status;\n\n\tdev_dbg(&priv->spi->dev, \"%s: CmdID = %d\\n\", __func__, command[0]);\n\n\tif (command[0] == SPI_MCPS_DATA_INDICATION) {\n\t\t/* Received data */\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (command[26] == priv->last_dsn) {\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"DSN %d resend received, ignoring...\\n\",\n\t\t\t\tcommand[26]\n\t\t\t);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->last_dsn = command[26];\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn ca8210_skb_rx(hw, len - 2, command + 2);\n\t} else if (command[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tstatus = command[3];\n\t\tif (priv->async_tx_pending) {\n\t\t\treturn ca8210_async_xmit_complete(\n\t\t\t\thw,\n\t\t\t\tcommand[2],\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_skb_tx() - Transmits a given socket buffer using the ca8210\n * @skb:         Socket buffer to transmit\n * @msduhandle:  Data identifier to pass to the 802.15.4 MAC\n * @priv:        Pointer to private data section of target ca8210\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_skb_tx(\n\tstruct sk_buff      *skb,\n\tu8                   msduhandle,\n\tstruct ca8210_priv  *priv\n)\n{\n\tint status;\n\tstruct ieee802154_hdr header = { };\n\tstruct secspec secspec;\n\tunsigned int mac_len;\n\n\tdev_dbg(&priv->spi->dev, \"%s called\\n\", __func__);\n\n\t/* Get addressing info from skb - ieee802154 layer creates a full\n\t * packet\n\t */\n\tmac_len = ieee802154_hdr_peek_addrs(skb, &header);\n\n\tsecspec.security_level = header.sec.level;\n\tsecspec.key_id_mode = header.sec.key_id_mode;\n\tif (secspec.key_id_mode == 2)\n\t\tmemcpy(secspec.key_source, &header.sec.short_src, 4);\n\telse if (secspec.key_id_mode == 3)\n\t\tmemcpy(secspec.key_source, &header.sec.extended_src, 8);\n\tsecspec.key_index = header.sec.key_id;\n\n\t/* Pass to Cascoda API */\n\tstatus =  mcps_data_request(\n\t\theader.source.mode,\n\t\theader.dest.mode,\n\t\theader.dest.pan_id,\n\t\t(union macaddr *)&header.dest.extended_addr,\n\t\tskb->len - mac_len,\n\t\t&skb->data[mac_len],\n\t\tmsduhandle,\n\t\theader.fc.ack_request,\n\t\t&secspec,\n\t\tpriv->spi\n\t);\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_start() - Starts the network driver\n * @hw:  ieee802154_hw of ca8210 being started\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_start(struct ieee802154_hw *hw)\n{\n\tint status;\n\tu8 rx_on_when_idle;\n\tu8 lqi_threshold = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tpriv->last_dsn = -1;\n\t/* Turn receiver on when idle for now just to test rx */\n\trx_on_when_idle = 1;\n\tstatus = mlme_set_request_sync(\n\t\tMAC_RX_ON_WHEN_IDLE,\n\t\t0,\n\t\t1,\n\t\t&rx_on_when_idle,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting rx_on_when_idle failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = hwme_set_request_sync(\n\t\tHWME_LQILIMIT,\n\t\t1,\n\t\t&lqi_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting lqilimit failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_stop() - Stops the network driver\n * @hw:  ieee802154_hw of ca8210 being stopped\n *\n * Return: 0 or linux error code\n */\nstatic void ca8210_stop(struct ieee802154_hw *hw)\n{\n}\n\n/**\n * ca8210_xmit_async() - Asynchronously transmits a given socket buffer using\n *                       the ca8210\n * @hw:   ieee802154_hw of ca8210 to transmit from\n * @skb:  Socket buffer to transmit\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_xmit_async(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"calling %s\\n\", __func__);\n\n\tpriv->tx_skb = skb;\n\tpriv->async_tx_pending = true;\n\tstatus = ca8210_skb_tx(skb, priv->nextmsduhandle, priv);\n\treturn status;\n}\n\n/**\n * ca8210_get_ed() - Returns the measured energy on the current channel at this\n *                   instant in time\n * @hw:     ieee802154_hw of target ca8210\n * @level:  Measured Energy Detect level\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_get_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tu8 lenvar;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\treturn link_to_linux_err(\n\t\thwme_get_request_sync(HWME_EDVALUE, &lenvar, level, priv->spi)\n\t);\n}\n\n/**\n * ca8210_set_channel() - Sets the current operating 802.15.4 channel of the\n *                        ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @page:     Channel page to set\n * @channel:  Channel number to set\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_channel(\n\tstruct ieee802154_hw  *hw,\n\tu8                     page,\n\tu8                     channel\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CURRENT_CHANNEL,\n\t\t0,\n\t\t1,\n\t\t&channel,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting channel, MLME-SET.confirm status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_hw_addr_filt() - Sets the address filtering parameters of the\n *                             ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @filt:     Filtering parameters\n * @changed:  Bitmap representing which parameters to change\n *\n * Effectively just sets the actual addressing information identifying this node\n * as all filtering is performed by the ca8210 as detailed in the IEEE 802.15.4\n * 2006 specification.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_hw_addr_filt(\n\tstruct ieee802154_hw            *hw,\n\tstruct ieee802154_hw_addr_filt  *filt,\n\tunsigned long                    changed\n)\n{\n\tu8 status = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_PAN_ID,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->pan_id, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting pan id, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_SHORT_ADDRESS,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->short_addr, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting short address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tNS_IEEE_ADDRESS,\n\t\t\t0,\n\t\t\t8,\n\t\t\t&filt->ieee_addr,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting ieee address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\t/* TODO: Should use MLME_START to set coord bit? */\n\treturn 0;\n}\n\n/**\n * ca8210_set_tx_power() - Sets the transmit power of the ca8210\n * @hw:   ieee802154_hw of target ca8210\n * @mbm:  Transmit power in mBm (dBm*100)\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_tx_power(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tmbm /= 100;\n\treturn link_to_linux_err(\n\t\tmlme_set_request_sync(PHY_TRANSMIT_POWER, 0, 1, &mbm, priv->spi)\n\t);\n}\n\n/**\n * ca8210_set_cca_mode() - Sets the clear channel assessment mode of the ca8210\n * @hw:   ieee802154_hw of target ca8210\n * @cca:  CCA mode to set\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_cca_mode(\n\tstruct ieee802154_hw       *hw,\n\tconst struct wpan_phy_cca  *cca\n)\n{\n\tu8 status;\n\tu8 cca_mode;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tcca_mode = cca->mode & 3;\n\tif (cca_mode == 3 && cca->opt == NL802154_CCA_OPT_ENERGY_CARRIER_OR) {\n\t\t/* cca_mode 0 == CS OR ED, 3 == CS AND ED */\n\t\tcca_mode = 0;\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CCA_MODE,\n\t\t0,\n\t\t1,\n\t\t&cca_mode,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting cca mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_cca_ed_level() - Sets the CCA ED level of the ca8210\n * @hw:     ieee802154_hw of target ca8210\n * @level:  ED level to set (in mbm)\n *\n * Sets the minimum threshold of measured energy above which the ca8210 will\n * back off and retry a transmission.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_cca_ed_level(struct ieee802154_hw *hw, s32 level)\n{\n\tu8 status;\n\tu8 ed_threshold = (level / 100) * 2 + 256;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = hwme_set_request_sync(\n\t\tHWME_EDTHRESHOLD,\n\t\t1,\n\t\t&ed_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting ed threshold, HWME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_csma_params() - Sets the CSMA parameters of the ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @min_be:   Minimum backoff exponent when backing off a transmission\n * @max_be:   Maximum backoff exponent when backing off a transmission\n * @retries:  Number of times to retry after backing off\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_csma_params(\n\tstruct ieee802154_hw  *hw,\n\tu8                     min_be,\n\tu8                     max_be,\n\tu8                     retries\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(MAC_MIN_BE, 0, 1, &min_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting min be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(MAC_MAX_BE, 0, 1, &max_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_CSMA_BACKOFFS,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max csma backoffs, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_frame_retries() - Sets the maximum frame retries of the ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @retries:  Number of retries\n *\n * Sets the number of times to retry a transmission if no acknowledgment was\n * was received from the other end when one was requested.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_FRAME_RETRIES,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting frame retries, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic int ca8210_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_PROMISCUOUS_MODE,\n\t\t0,\n\t\t1,\n\t\t(const void *)&on,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting promiscuous mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t} else {\n\t\tpriv->promiscuous = on;\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic const struct ieee802154_ops ca8210_phy_ops = {\n\t.start = ca8210_start,\n\t.stop = ca8210_stop,\n\t.xmit_async = ca8210_xmit_async,\n\t.ed = ca8210_get_ed,\n\t.set_channel = ca8210_set_channel,\n\t.set_hw_addr_filt = ca8210_set_hw_addr_filt,\n\t.set_txpower = ca8210_set_tx_power,\n\t.set_cca_mode = ca8210_set_cca_mode,\n\t.set_cca_ed_level = ca8210_set_cca_ed_level,\n\t.set_csma_params = ca8210_set_csma_params,\n\t.set_frame_retries = ca8210_set_frame_retries,\n\t.set_promiscuous_mode = ca8210_set_promiscuous_mode\n};\n\n/* Test/EVBME Interface */\n\n/**\n * ca8210_test_int_open() - Opens the test interface to the userspace\n * @inodp:  inode representation of file interface\n * @filp:   file interface\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_int_open(struct inode *inodp, struct file *filp)\n{\n\tstruct ca8210_priv *priv = inodp->i_private;\n\n\tfilp->private_data = priv;\n\treturn 0;\n}\n\n/**\n * ca8210_test_check_upstream() - Checks a command received from the upstream\n *                                testing interface for required action\n * @buf:        Buffer containing command to check\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_check_upstream(u8 *buf, void *device_ref)\n{\n\tint ret;\n\tu8 response[CA8210_SPI_BUF_SIZE];\n\n\tif (buf[0] == SPI_MLME_SET_REQUEST) {\n\t\tret = tdme_checkpibattribute(buf[2], buf[4], buf + 5);\n\t\tif (ret) {\n\t\t\tresponse[0]  = SPI_MLME_SET_CONFIRM;\n\t\t\tresponse[1] = 3;\n\t\t\tresponse[2] = MAC_INVALID_PARAMETER;\n\t\t\tresponse[3] = buf[2];\n\t\t\tresponse[4] = buf[3];\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(response, 5, device_ref);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (buf[0] == SPI_MLME_ASSOCIATE_REQUEST) {\n\t\treturn tdme_channelinit(buf[2], device_ref);\n\t} else if (buf[0] == SPI_MLME_START_REQUEST) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_MLME_SET_REQUEST) &&\n\t\t(buf[2] == PHY_CURRENT_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[5], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_TDME_SET_REQUEST) &&\n\t\t(buf[2] == TDME_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(CA8210_MAC_WORKAROUNDS) &&\n\t\t(buf[0] == SPI_MLME_RESET_REQUEST) &&\n\t\t(buf[2] == 1)\n\t) {\n\t\t/* reset COORD Bit for Channel Filtering as Coordinator */\n\t\treturn tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\treturn 0;\n} /* End of EVBMECheckSerialCommand() */\n\n/**\n * ca8210_test_int_user_write() - Called by a process in userspace to send a\n *                                message to the ca8210 drivers\n * @filp:    file interface\n * @in_buf:  Buffer containing message to write\n * @len:     length of message\n * @off:     file offset\n *\n * Return: 0 or linux error code\n */\nstatic ssize_t ca8210_test_int_user_write(\n\tstruct file        *filp,\n\tconst char __user  *in_buf,\n\tsize_t              len,\n\tloff_t             *off\n)\n{\n\tint ret;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tu8 command[CA8210_SPI_BUF_SIZE];\n\n\tmemset(command, SPI_IDLE, 6);\n\tif (len > CA8210_SPI_BUF_SIZE || len < 2) {\n\t\tdev_warn(\n\t\t\t&priv->spi->dev,\n\t\t\t\"userspace requested erroneous write length (%zu)\\n\",\n\t\t\tlen\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = copy_from_user(command, in_buf, len);\n\tif (ret) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%d bytes could not be copied from userspace\\n\",\n\t\t\tret\n\t\t);\n\t\treturn -EIO;\n\t}\n\tif (len != command[1] + 2) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"write len does not match packet length field\\n\"\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = ca8210_test_check_upstream(command, priv->spi);\n\tif (ret == 0) {\n\t\tret = ca8210_spi_exchange(\n\t\t\tcommand,\n\t\t\tcommand[1] + 2,\n\t\t\tNULL,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (ret < 0) {\n\t\t\t/* effectively 0 bytes were written successfully */\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi exchange failed\\n\"\n\t\t\t);\n\t\t\treturn ret;\n\t\t}\n\t\tif (command[0] & SPI_SYN)\n\t\t\tpriv->sync_down++;\n\t}\n\n\treturn len;\n}\n\n/**\n * ca8210_test_int_user_read() - Called by a process in userspace to read a\n *                               message from the ca8210 drivers\n * @filp:  file interface\n * @buf:   Buffer to write message to\n * @len:   length of message to read (ignored)\n * @offp:  file offset\n *\n * If the O_NONBLOCK flag was set when opening the file then this function will\n * not block, i.e. it will return if the fifo is empty. Otherwise the function\n * will block, i.e. wait until new data arrives.\n *\n * Return: number of bytes read\n */\nstatic ssize_t ca8210_test_int_user_read(\n\tstruct file  *filp,\n\tchar __user  *buf,\n\tsize_t        len,\n\tloff_t       *offp\n)\n{\n\tint i, cmdlen;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tunsigned char *fifo_buffer;\n\tunsigned long bytes_not_copied;\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\t/* Non-blocking mode */\n\t\tif (kfifo_is_empty(&priv->test.up_fifo))\n\t\t\treturn 0;\n\t} else {\n\t\t/* Blocking mode */\n\t\twait_event_interruptible(\n\t\t\tpriv->test.readq,\n\t\t\t!kfifo_is_empty(&priv->test.up_fifo)\n\t\t);\n\t}\n\n\tif (kfifo_out(&priv->test.up_fifo, &fifo_buffer, 4) != 4) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"test_interface: Wrong number of elements popped from upstream fifo\\n\"\n\t\t);\n\t\treturn 0;\n\t}\n\tcmdlen = fifo_buffer[1];\n\tbytes_not_copied = cmdlen + 2;\n\n\tbytes_not_copied = copy_to_user(buf, fifo_buffer, bytes_not_copied);\n\tif (bytes_not_copied > 0) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%lu bytes could not be copied to user space!\\n\",\n\t\t\tbytes_not_copied\n\t\t);\n\t}\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Cmd len = %d\\n\", cmdlen);\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Read\\n\");\n\tfor (i = 0; i < cmdlen + 2; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", fifo_buffer[i]);\n\n\tkfree(fifo_buffer);\n\n\treturn cmdlen + 2;\n}\n\n/**\n * ca8210_test_int_ioctl() - Called by a process in userspace to enact an\n *                           arbitrary action\n * @filp:        file interface\n * @ioctl_num:   which action to enact\n * @ioctl_param: arbitrary parameter for the action\n *\n * Return: status\n */\nstatic long ca8210_test_int_ioctl(\n\tstruct file *filp,\n\tunsigned int ioctl_num,\n\tunsigned long ioctl_param\n)\n{\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tswitch (ioctl_num) {\n\tcase CA8210_IOCTL_HARD_RESET:\n\t\tca8210_reset_send(priv->spi, ioctl_param);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * ca8210_test_int_poll() - Called by a process in userspace to determine which\n *                          actions are currently possible for the file\n * @filp:   file interface\n * @ptable: poll table\n *\n * Return: set of poll return flags\n */\nstatic __poll_t ca8210_test_int_poll(\n\tstruct file *filp,\n\tstruct poll_table_struct *ptable\n)\n{\n\t__poll_t return_flags = 0;\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tpoll_wait(filp, &priv->test.readq, ptable);\n\tif (!kfifo_is_empty(&priv->test.up_fifo))\n\t\treturn_flags |= (EPOLLIN | EPOLLRDNORM);\n\tif (wait_event_interruptible(\n\t\tpriv->test.readq,\n\t\t!kfifo_is_empty(&priv->test.up_fifo))) {\n\t\treturn EPOLLERR;\n\t}\n\treturn return_flags;\n}\n\nstatic const struct file_operations test_int_fops = {\n\t.read =           ca8210_test_int_user_read,\n\t.write =          ca8210_test_int_user_write,\n\t.open =           ca8210_test_int_open,\n\t.release =        NULL,\n\t.unlocked_ioctl = ca8210_test_int_ioctl,\n\t.poll =           ca8210_test_int_poll\n};\n\n/* Init/Deinit */\n\n/**\n * ca8210_get_platform_data() - Populate a ca8210_platform_data object\n * @spi_device:  Pointer to ca8210 spi device object to get data for\n * @pdata:       Pointer to ca8210_platform_data object to populate\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_get_platform_data(\n\tstruct spi_device *spi_device,\n\tstruct ca8210_platform_data *pdata\n)\n{\n\tint ret = 0;\n\n\tif (!spi_device->dev.of_node)\n\t\treturn -EINVAL;\n\n\tpdata->extclockenable = of_property_read_bool(\n\t\tspi_device->dev.of_node,\n\t\t\"extclock-enable\"\n\t);\n\tif (pdata->extclockenable) {\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-freq\",\n\t\t\t&pdata->extclockfreq\n\t\t);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-gpio\",\n\t\t\t&pdata->extclockgpio\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_config_extern_clk() - Configure the external clock provided by the\n *                              ca8210\n * @pdata:  Pointer to ca8210_platform_data containing clock parameters\n * @spi:    Pointer to target ca8210 spi device\n * @on:\t    True to turn the clock on, false to turn off\n *\n * The external clock is configured with a frequency and output pin taken from\n * the platform data.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_config_extern_clk(\n\tstruct ca8210_platform_data *pdata,\n\tstruct spi_device *spi,\n\tbool on\n)\n{\n\tu8 clkparam[2];\n\n\tif (on) {\n\t\tdev_info(&spi->dev, \"Switching external clock on\\n\");\n\t\tswitch (pdata->extclockfreq) {\n\t\tcase SIXTEEN_MHZ:\n\t\t\tclkparam[0] = 1;\n\t\t\tbreak;\n\t\tcase EIGHT_MHZ:\n\t\t\tclkparam[0] = 2;\n\t\t\tbreak;\n\t\tcase FOUR_MHZ:\n\t\t\tclkparam[0] = 3;\n\t\t\tbreak;\n\t\tcase TWO_MHZ:\n\t\t\tclkparam[0] = 4;\n\t\t\tbreak;\n\t\tcase ONE_MHZ:\n\t\t\tclkparam[0] = 5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_crit(&spi->dev, \"Invalid extclock-freq\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclkparam[1] = pdata->extclockgpio;\n\t} else {\n\t\tdev_info(&spi->dev, \"Switching external clock off\\n\");\n\t\tclkparam[0] = 0; /* off */\n\t\tclkparam[1] = 0;\n\t}\n\treturn link_to_linux_err(\n\t\thwme_set_request_sync(HWME_SYSCLKOUT, 2, clkparam, spi)\n\t);\n}\n\n/**\n * ca8210_register_ext_clock() - Register ca8210's external clock with kernel\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_register_ext_clock(struct spi_device *spi)\n{\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\tint ret = 0;\n\n\tif (!np)\n\t\treturn -EFAULT;\n\n\tpriv->clk = clk_register_fixed_rate(\n\t\t&spi->dev,\n\t\tnp->name,\n\t\tNULL,\n\t\t0,\n\t\tpdata->extclockfreq\n\t);\n\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_crit(&spi->dev, \"Failed to register external clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\tret = of_clk_add_provider(np, of_clk_src_simple_get, priv->clk);\n\tif (ret) {\n\t\tclk_unregister(priv->clk);\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Failed to register external clock as clock provider\\n\"\n\t\t);\n\t} else {\n\t\tdev_info(&spi->dev, \"External clock set as clock provider\\n\");\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_unregister_ext_clock() - Unregister ca8210's external clock with\n *                                 kernel\n * @spi:  Pointer to target ca8210 spi device\n */\nstatic void ca8210_unregister_ext_clock(struct spi_device *spi)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\n\tif (!priv->clk)\n\t\treturn\n\n\tof_clk_del_provider(spi->dev.of_node);\n\tclk_unregister(priv->clk);\n\tdev_info(&spi->dev, \"External clock unregistered\\n\");\n}\n\n/**\n * ca8210_reset_init() - Initialise the reset input to the ca8210\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_reset_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_reset = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"reset-gpio\",\n\t\t0\n\t);\n\n\tret = gpio_direction_output(pdata->gpio_reset, 1);\n\tif (ret < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Reset GPIO %d did not set to output mode\\n\",\n\t\t\tpdata->gpio_reset\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_interrupt_init() - Initialise the irq output from the ca8210\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_interrupt_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_irq = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"irq-gpio\",\n\t\t0\n\t);\n\n\tpdata->irq_id = gpio_to_irq(pdata->gpio_irq);\n\tif (pdata->irq_id < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Could not get irq for gpio pin %d\\n\",\n\t\t\tpdata->gpio_irq\n\t\t);\n\t\tgpio_free(pdata->gpio_irq);\n\t\treturn pdata->irq_id;\n\t}\n\n\tret = request_irq(\n\t\tpdata->irq_id,\n\t\tca8210_interrupt_handler,\n\t\tIRQF_TRIGGER_FALLING,\n\t\t\"ca8210-irq\",\n\t\tspi_get_drvdata(spi)\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"request_irq %d failed\\n\", pdata->irq_id);\n\t\tgpio_unexport(pdata->gpio_irq);\n\t\tgpio_free(pdata->gpio_irq);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_dev_com_init() - Initialise the spi communication component\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_dev_com_init(struct ca8210_priv *priv)\n{\n\tpriv->mlme_workqueue = alloc_ordered_workqueue(\n\t\t\"MLME work queue\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->mlme_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of mlme_workqueue failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->irq_workqueue = alloc_ordered_workqueue(\n\t\t\"ca8210 irq worker\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->irq_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of irq_workqueue failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_dev_com_clear() - Deinitialise the spi communication component\n * @priv:  Pointer to private data structure\n */\nstatic void ca8210_dev_com_clear(struct ca8210_priv *priv)\n{\n\tflush_workqueue(priv->mlme_workqueue);\n\tdestroy_workqueue(priv->mlme_workqueue);\n\tflush_workqueue(priv->irq_workqueue);\n\tdestroy_workqueue(priv->irq_workqueue);\n}\n\n#define CA8210_MAX_TX_POWERS (9)\nstatic const s32 ca8210_tx_powers[CA8210_MAX_TX_POWERS] = {\n\t800, 700, 600, 500, 400, 300, 200, 100, 0\n};\n\n#define CA8210_MAX_ED_LEVELS (21)\nstatic const s32 ca8210_ed_levels[CA8210_MAX_ED_LEVELS] = {\n\t-10300, -10250, -10200, -10150, -10100, -10050, -10000, -9950, -9900,\n\t-9850, -9800, -9750, -9700, -9650, -9600, -9550, -9500, -9450, -9400,\n\t-9350, -9300\n};\n\n/**\n * ca8210_hw_setup() - Populate the ieee802154_hw phy attributes with the\n *                     ca8210's defaults\n * @ca8210_hw:  Pointer to ieee802154_hw to populate\n */\nstatic void ca8210_hw_setup(struct ieee802154_hw *ca8210_hw)\n{\n\t/* Support channels 11-26 */\n\tca8210_hw->phy->supported.channels[0] = CA8210_VALID_CHANNELS;\n\tca8210_hw->phy->supported.tx_powers_size = CA8210_MAX_TX_POWERS;\n\tca8210_hw->phy->supported.tx_powers = ca8210_tx_powers;\n\tca8210_hw->phy->supported.cca_ed_levels_size = CA8210_MAX_ED_LEVELS;\n\tca8210_hw->phy->supported.cca_ed_levels = ca8210_ed_levels;\n\tca8210_hw->phy->current_channel = 18;\n\tca8210_hw->phy->current_page = 0;\n\tca8210_hw->phy->transmit_power = 800;\n\tca8210_hw->phy->cca.mode = NL802154_CCA_ENERGY_CARRIER;\n\tca8210_hw->phy->cca.opt = NL802154_CCA_OPT_ENERGY_CARRIER_AND;\n\tca8210_hw->phy->cca_ed_level = -9800;\n\tca8210_hw->phy->symbol_duration = 16;\n\tca8210_hw->phy->lifs_period = 40;\n\tca8210_hw->phy->sifs_period = 12;\n\tca8210_hw->flags =\n\t\tIEEE802154_HW_AFILT |\n\t\tIEEE802154_HW_OMIT_CKSUM |\n\t\tIEEE802154_HW_FRAME_RETRIES |\n\t\tIEEE802154_HW_PROMISCUOUS |\n\t\tIEEE802154_HW_CSMA_PARAMS;\n\tca8210_hw->phy->flags =\n\t\tWPAN_PHY_FLAG_TXPOWER |\n\t\tWPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\tWPAN_PHY_FLAG_CCA_MODE;\n}\n\n/**\n * ca8210_test_interface_init() - Initialise the test file interface\n * @priv:  Pointer to private data structure\n *\n * Provided as an alternative to the standard linux network interface, the test\n * interface exposes a file in the filesystem (ca8210_test) that allows\n * 802.15.4 SAP Commands and Cascoda EVBME commands to be sent directly to\n * the stack.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_interface_init(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\tchar node_name[32];\n\n\tsnprintf(\n\t\tnode_name,\n\t\tsizeof(node_name),\n\t\t\"ca8210@%d_%d\",\n\t\tpriv->spi->master->bus_num,\n\t\tpriv->spi->chip_select\n\t);\n\n\ttest->ca8210_dfs_spi_int = debugfs_create_file(\n\t\tnode_name,\n\t\t0600, /* S_IRUSR | S_IWUSR */\n\t\tNULL,\n\t\tpriv,\n\t\t&test_int_fops\n\t);\n\tif (IS_ERR(test->ca8210_dfs_spi_int)) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Error %ld when creating debugfs node\\n\",\n\t\t\tPTR_ERR(test->ca8210_dfs_spi_int)\n\t\t);\n\t\treturn PTR_ERR(test->ca8210_dfs_spi_int);\n\t}\n\tdebugfs_create_symlink(\"ca8210\", NULL, node_name);\n\tinit_waitqueue_head(&test->readq);\n\treturn kfifo_alloc(\n\t\t&test->up_fifo,\n\t\tCA8210_TEST_INT_FIFO_SIZE,\n\t\tGFP_KERNEL\n\t);\n}\n\n/**\n * ca8210_test_interface_clear() - Deinitialise the test file interface\n * @priv:  Pointer to private data structure\n */\nstatic void ca8210_test_interface_clear(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\n\tdebugfs_remove(test->ca8210_dfs_spi_int);\n\tkfifo_free(&test->up_fifo);\n\tdev_info(&priv->spi->dev, \"Test interface removed\\n\");\n}\n\n/**\n * ca8210_remove() - Shut down a ca8210 upon being disconnected\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_remove(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ca8210_platform_data *pdata;\n\n\tdev_info(&spi_device->dev, \"Removing ca8210\\n\");\n\n\tpdata = spi_device->dev.platform_data;\n\tif (pdata) {\n\t\tif (pdata->extclockenable) {\n\t\t\tca8210_unregister_ext_clock(spi_device);\n\t\t\tca8210_config_extern_clk(pdata, spi_device, 0);\n\t\t}\n\t\tfree_irq(pdata->irq_id, spi_device->dev.driver_data);\n\t\tkfree(pdata);\n\t\tspi_device->dev.platform_data = NULL;\n\t}\n\t/* get spi_device private data */\n\tpriv = spi_get_drvdata(spi_device);\n\tif (priv) {\n\t\tdev_info(\n\t\t\t&spi_device->dev,\n\t\t\t\"sync_down = %d, sync_up = %d\\n\",\n\t\t\tpriv->sync_down,\n\t\t\tpriv->sync_up\n\t\t);\n\t\tca8210_dev_com_clear(spi_device->dev.driver_data);\n\t\tif (priv->hw) {\n\t\t\tif (priv->hw_registered)\n\t\t\t\tieee802154_unregister_hw(priv->hw);\n\t\t\tieee802154_free_hw(priv->hw);\n\t\t\tpriv->hw = NULL;\n\t\t\tdev_info(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"Unregistered & freed ieee802154_hw.\\n\"\n\t\t\t);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS))\n\t\t\tca8210_test_interface_clear(priv);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_probe() - Set up a connected ca8210 upon being detected by the system\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_probe(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ieee802154_hw *hw;\n\tstruct ca8210_platform_data *pdata;\n\tint ret;\n\n\tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n\n\t/* allocate ieee802154_hw and private data */\n\thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->spi = spi_device;\n\thw->parent = &spi_device->dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->async_tx_pending = false;\n\tpriv->hw_registered = false;\n\tpriv->sync_up = 0;\n\tpriv->sync_down = 0;\n\tpriv->promiscuous = false;\n\tpriv->retries = 0;\n\tinit_completion(&priv->ca8210_is_awake);\n\tinit_completion(&priv->spi_transfer_complete);\n\tinit_completion(&priv->sync_exchange_complete);\n\tspi_set_drvdata(priv->spi, priv);\n\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n\t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n\t\tca8210_test_interface_init(priv);\n\t} else {\n\t\tcascoda_api_upstream = NULL;\n\t}\n\tca8210_hw_setup(hw);\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = ca8210_get_platform_data(priv->spi, pdata);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->spi->dev.platform_data = pdata;\n\n\tret = ca8210_dev_com_init(priv);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n\t\tgoto error;\n\t}\n\tret = ca8210_reset_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_interrupt_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmsleep(100);\n\n\tca8210_reset_send(priv->spi, 1);\n\n\tret = tdme_chipinit(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (pdata->extclockenable) {\n\t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t\tret = ca8210_register_ext_clock(priv->spi);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->hw_registered = true;\n\n\treturn 0;\nerror:\n\tmsleep(100); /* wait for pending spi transfers to complete */\n\tca8210_remove(spi_device);\n\treturn link_to_linux_err(ret);\n}\n\nstatic const struct of_device_id ca8210_of_ids[] = {\n\t{.compatible = \"cascoda,ca8210\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ca8210_of_ids);\n\nstatic struct spi_driver ca8210_spi_driver = {\n\t.driver = {\n\t\t.name =                 DRIVER_NAME,\n\t\t.owner =                THIS_MODULE,\n\t\t.of_match_table =       of_match_ptr(ca8210_of_ids),\n\t},\n\t.probe  =                       ca8210_probe,\n\t.remove =                       ca8210_remove\n};\n\nmodule_spi_driver(ca8210_spi_driver);\n\nMODULE_AUTHOR(\"Harry Morris <h.morris@cascoda.com>\");\nMODULE_DESCRIPTION(\"CA-8210 SoftMAC driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(\"1.0\");\n"], "fixing_code": ["/*\n * http://www.cascoda.com/products/ca-821x/\n * Copyright (c) 2016, Cascoda, Ltd.\n * All rights reserved.\n *\n * This code is dual-licensed under both GPLv2 and 3-clause BSD. What follows is\n * the license notice for both respectively.\n *\n *******************************************************************************\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n *******************************************************************************\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/cdev.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/ieee802154.h>\n#include <linux/io.h>\n#include <linux/kfifo.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n\n#define DRIVER_NAME \"ca8210\"\n\n/* external clock frequencies */\n#define ONE_MHZ      1000000\n#define TWO_MHZ      (2 * ONE_MHZ)\n#define FOUR_MHZ     (4 * ONE_MHZ)\n#define EIGHT_MHZ    (8 * ONE_MHZ)\n#define SIXTEEN_MHZ  (16 * ONE_MHZ)\n\n/* spi constants */\n#define CA8210_SPI_BUF_SIZE 256\n#define CA8210_SYNC_TIMEOUT 1000     /* Timeout for synchronous commands [ms] */\n\n/* test interface constants */\n#define CA8210_TEST_INT_FILE_NAME \"ca8210_test\"\n#define CA8210_TEST_INT_FIFO_SIZE 256\n\n/* MAC status enumerations */\n#define MAC_SUCCESS                     (0x00)\n#define MAC_ERROR                       (0x01)\n#define MAC_CANCELLED                   (0x02)\n#define MAC_READY_FOR_POLL              (0x03)\n#define MAC_COUNTER_ERROR               (0xDB)\n#define MAC_IMPROPER_KEY_TYPE           (0xDC)\n#define MAC_IMPROPER_SECURITY_LEVEL     (0xDD)\n#define MAC_UNSUPPORTED_LEGACY          (0xDE)\n#define MAC_UNSUPPORTED_SECURITY        (0xDF)\n#define MAC_BEACON_LOST                 (0xE0)\n#define MAC_CHANNEL_ACCESS_FAILURE      (0xE1)\n#define MAC_DENIED                      (0xE2)\n#define MAC_DISABLE_TRX_FAILURE         (0xE3)\n#define MAC_SECURITY_ERROR              (0xE4)\n#define MAC_FRAME_TOO_LONG              (0xE5)\n#define MAC_INVALID_GTS                 (0xE6)\n#define MAC_INVALID_HANDLE              (0xE7)\n#define MAC_INVALID_PARAMETER           (0xE8)\n#define MAC_NO_ACK                      (0xE9)\n#define MAC_NO_BEACON                   (0xEA)\n#define MAC_NO_DATA                     (0xEB)\n#define MAC_NO_SHORT_ADDRESS            (0xEC)\n#define MAC_OUT_OF_CAP                  (0xED)\n#define MAC_PAN_ID_CONFLICT             (0xEE)\n#define MAC_REALIGNMENT                 (0xEF)\n#define MAC_TRANSACTION_EXPIRED         (0xF0)\n#define MAC_TRANSACTION_OVERFLOW        (0xF1)\n#define MAC_TX_ACTIVE                   (0xF2)\n#define MAC_UNAVAILABLE_KEY             (0xF3)\n#define MAC_UNSUPPORTED_ATTRIBUTE       (0xF4)\n#define MAC_INVALID_ADDRESS             (0xF5)\n#define MAC_ON_TIME_TOO_LONG            (0xF6)\n#define MAC_PAST_TIME                   (0xF7)\n#define MAC_TRACKING_OFF                (0xF8)\n#define MAC_INVALID_INDEX               (0xF9)\n#define MAC_LIMIT_REACHED               (0xFA)\n#define MAC_READ_ONLY                   (0xFB)\n#define MAC_SCAN_IN_PROGRESS            (0xFC)\n#define MAC_SUPERFRAME_OVERLAP          (0xFD)\n#define MAC_SYSTEM_ERROR                (0xFF)\n\n/* HWME attribute IDs */\n#define HWME_EDTHRESHOLD       (0x04)\n#define HWME_EDVALUE           (0x06)\n#define HWME_SYSCLKOUT         (0x0F)\n#define HWME_LQILIMIT          (0x11)\n\n/* TDME attribute IDs */\n#define TDME_CHANNEL          (0x00)\n#define TDME_ATM_CONFIG       (0x06)\n\n#define MAX_HWME_ATTRIBUTE_SIZE  16\n#define MAX_TDME_ATTRIBUTE_SIZE  2\n\n/* PHY/MAC PIB Attribute Enumerations */\n#define PHY_CURRENT_CHANNEL               (0x00)\n#define PHY_TRANSMIT_POWER                (0x02)\n#define PHY_CCA_MODE                      (0x03)\n#define MAC_ASSOCIATION_PERMIT            (0x41)\n#define MAC_AUTO_REQUEST                  (0x42)\n#define MAC_BATT_LIFE_EXT                 (0x43)\n#define MAC_BATT_LIFE_EXT_PERIODS         (0x44)\n#define MAC_BEACON_PAYLOAD                (0x45)\n#define MAC_BEACON_PAYLOAD_LENGTH         (0x46)\n#define MAC_BEACON_ORDER                  (0x47)\n#define MAC_GTS_PERMIT                    (0x4d)\n#define MAC_MAX_CSMA_BACKOFFS             (0x4e)\n#define MAC_MIN_BE                        (0x4f)\n#define MAC_PAN_ID                        (0x50)\n#define MAC_PROMISCUOUS_MODE              (0x51)\n#define MAC_RX_ON_WHEN_IDLE               (0x52)\n#define MAC_SHORT_ADDRESS                 (0x53)\n#define MAC_SUPERFRAME_ORDER              (0x54)\n#define MAC_ASSOCIATED_PAN_COORD          (0x56)\n#define MAC_MAX_BE                        (0x57)\n#define MAC_MAX_FRAME_RETRIES             (0x59)\n#define MAC_RESPONSE_WAIT_TIME            (0x5A)\n#define MAC_SECURITY_ENABLED              (0x5D)\n\n#define MAC_AUTO_REQUEST_SECURITY_LEVEL   (0x78)\n#define MAC_AUTO_REQUEST_KEY_ID_MODE      (0x79)\n\n#define NS_IEEE_ADDRESS                   (0xFF) /* Non-standard IEEE address */\n\n/* MAC Address Mode Definitions */\n#define MAC_MODE_NO_ADDR                (0x00)\n#define MAC_MODE_SHORT_ADDR             (0x02)\n#define MAC_MODE_LONG_ADDR              (0x03)\n\n/* MAC constants */\n#define MAX_BEACON_OVERHEAD        (75)\n#define MAX_BEACON_PAYLOAD_LENGTH  (IEEE802154_MTU - MAX_BEACON_OVERHEAD)\n\n#define MAX_ATTRIBUTE_SIZE              (122)\n#define MAX_DATA_SIZE                   (114)\n\n#define CA8210_VALID_CHANNELS                 (0x07FFF800)\n\n/* MAC workarounds for V1.1 and MPW silicon (V0.x) */\n#define CA8210_MAC_WORKAROUNDS (0)\n#define CA8210_MAC_MPW         (0)\n\n/* memory manipulation macros */\n#define LS_BYTE(x)     ((u8)((x) & 0xFF))\n#define MS_BYTE(x)     ((u8)(((x) >> 8) & 0xFF))\n\n/* message ID codes in SPI commands */\n/* downstream */\n#define MCPS_DATA_REQUEST                     (0x00)\n#define MLME_ASSOCIATE_REQUEST                (0x02)\n#define MLME_ASSOCIATE_RESPONSE               (0x03)\n#define MLME_DISASSOCIATE_REQUEST             (0x04)\n#define MLME_GET_REQUEST                      (0x05)\n#define MLME_ORPHAN_RESPONSE                  (0x06)\n#define MLME_RESET_REQUEST                    (0x07)\n#define MLME_RX_ENABLE_REQUEST                (0x08)\n#define MLME_SCAN_REQUEST                     (0x09)\n#define MLME_SET_REQUEST                      (0x0A)\n#define MLME_START_REQUEST                    (0x0B)\n#define MLME_POLL_REQUEST                     (0x0D)\n#define HWME_SET_REQUEST                      (0x0E)\n#define HWME_GET_REQUEST                      (0x0F)\n#define TDME_SETSFR_REQUEST                   (0x11)\n#define TDME_GETSFR_REQUEST                   (0x12)\n#define TDME_SET_REQUEST                      (0x14)\n/* upstream */\n#define MCPS_DATA_INDICATION                  (0x00)\n#define MCPS_DATA_CONFIRM                     (0x01)\n#define MLME_RESET_CONFIRM                    (0x0A)\n#define MLME_SET_CONFIRM                      (0x0E)\n#define MLME_START_CONFIRM                    (0x0F)\n#define HWME_SET_CONFIRM                      (0x12)\n#define HWME_GET_CONFIRM                      (0x13)\n#define HWME_WAKEUP_INDICATION\t\t      (0x15)\n#define TDME_SETSFR_CONFIRM                   (0x17)\n\n/* SPI command IDs */\n/* bit indicating a confirm or indication from slave to master */\n#define SPI_S2M                            (0x20)\n/* bit indicating a synchronous message */\n#define SPI_SYN                            (0x40)\n\n/* SPI command definitions */\n#define SPI_IDLE                           (0xFF)\n#define SPI_NACK                           (0xF0)\n\n#define SPI_MCPS_DATA_REQUEST          (MCPS_DATA_REQUEST)\n#define SPI_MCPS_DATA_INDICATION       (MCPS_DATA_INDICATION + SPI_S2M)\n#define SPI_MCPS_DATA_CONFIRM          (MCPS_DATA_CONFIRM + SPI_S2M)\n\n#define SPI_MLME_ASSOCIATE_REQUEST     (MLME_ASSOCIATE_REQUEST)\n#define SPI_MLME_RESET_REQUEST         (MLME_RESET_REQUEST + SPI_SYN)\n#define SPI_MLME_SET_REQUEST           (MLME_SET_REQUEST + SPI_SYN)\n#define SPI_MLME_START_REQUEST         (MLME_START_REQUEST + SPI_SYN)\n#define SPI_MLME_RESET_CONFIRM         (MLME_RESET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_SET_CONFIRM           (MLME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_START_CONFIRM         (MLME_START_CONFIRM + SPI_S2M + SPI_SYN)\n\n#define SPI_HWME_SET_REQUEST           (HWME_SET_REQUEST + SPI_SYN)\n#define SPI_HWME_GET_REQUEST           (HWME_GET_REQUEST + SPI_SYN)\n#define SPI_HWME_SET_CONFIRM           (HWME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_GET_CONFIRM           (HWME_GET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_WAKEUP_INDICATION     (HWME_WAKEUP_INDICATION + SPI_S2M)\n\n#define SPI_TDME_SETSFR_REQUEST        (TDME_SETSFR_REQUEST + SPI_SYN)\n#define SPI_TDME_SET_REQUEST           (TDME_SET_REQUEST + SPI_SYN)\n#define SPI_TDME_SETSFR_CONFIRM        (TDME_SETSFR_CONFIRM + SPI_S2M + SPI_SYN)\n\n/* TDME SFR addresses */\n/* Page 0 */\n#define CA8210_SFR_PACFG                   (0xB1)\n#define CA8210_SFR_MACCON                  (0xD8)\n#define CA8210_SFR_PACFGIB                 (0xFE)\n/* Page 1 */\n#define CA8210_SFR_LOTXCAL                 (0xBF)\n#define CA8210_SFR_PTHRH                   (0xD1)\n#define CA8210_SFR_PRECFG                  (0xD3)\n#define CA8210_SFR_LNAGX40                 (0xE1)\n#define CA8210_SFR_LNAGX41                 (0xE2)\n#define CA8210_SFR_LNAGX42                 (0xE3)\n#define CA8210_SFR_LNAGX43                 (0xE4)\n#define CA8210_SFR_LNAGX44                 (0xE5)\n#define CA8210_SFR_LNAGX45                 (0xE6)\n#define CA8210_SFR_LNAGX46                 (0xE7)\n#define CA8210_SFR_LNAGX47                 (0xE9)\n\n#define PACFGIB_DEFAULT_CURRENT            (0x3F)\n#define PTHRH_DEFAULT_THRESHOLD            (0x5A)\n#define LNAGX40_DEFAULT_GAIN               (0x29) /* 10dB */\n#define LNAGX41_DEFAULT_GAIN               (0x54) /* 21dB */\n#define LNAGX42_DEFAULT_GAIN               (0x6C) /* 27dB */\n#define LNAGX43_DEFAULT_GAIN               (0x7A) /* 30dB */\n#define LNAGX44_DEFAULT_GAIN               (0x84) /* 33dB */\n#define LNAGX45_DEFAULT_GAIN               (0x8B) /* 34dB */\n#define LNAGX46_DEFAULT_GAIN               (0x92) /* 36dB */\n#define LNAGX47_DEFAULT_GAIN               (0x96) /* 37dB */\n\n#define CA8210_IOCTL_HARD_RESET            (0x00)\n\n/* Structs/Enums */\n\n/**\n * struct cas_control - spi transfer structure\n * @msg:                  spi_message for each exchange\n * @transfer:             spi_transfer for each exchange\n * @tx_buf:               source array for transmission\n * @tx_in_buf:            array storing bytes received during transmission\n * @priv:                 pointer to private data\n *\n * This structure stores all the necessary data passed around during a single\n * spi exchange.\n */\nstruct cas_control {\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\n\tu8 tx_buf[CA8210_SPI_BUF_SIZE];\n\tu8 tx_in_buf[CA8210_SPI_BUF_SIZE];\n\n\tstruct ca8210_priv *priv;\n};\n\n/**\n * struct ca8210_test - ca8210 test interface structure\n * @ca8210_dfs_spi_int: pointer to the entry in the debug fs for this device\n * @up_fifo:            fifo for upstream messages\n *\n * This structure stores all the data pertaining to the debug interface\n */\nstruct ca8210_test {\n\tstruct dentry *ca8210_dfs_spi_int;\n\tstruct kfifo up_fifo;\n\twait_queue_head_t readq;\n};\n\n/**\n * struct ca8210_priv - ca8210 private data structure\n * @spi:                    pointer to the ca8210 spi device object\n * @hw:                     pointer to the ca8210 ieee802154_hw object\n * @hw_registered:          true if hw has been registered with ieee802154\n * @lock:                   spinlock protecting the private data area\n * @mlme_workqueue:           workqueue for triggering MLME Reset\n * @irq_workqueue:          workqueue for irq processing\n * @tx_skb:                 current socket buffer to transmit\n * @nextmsduhandle:         msdu handle to pass to the 15.4 MAC layer for the\n *                           next transmission\n * @clk:                    external clock provided by the ca8210\n * @last_dsn:               sequence number of last data packet received, for\n *                           resend detection\n * @test:                   test interface data section for this instance\n * @async_tx_pending:       true if an asynchronous transmission was started and\n *                           is not complete\n * @sync_command_response:  pointer to buffer to fill with sync response\n * @ca8210_is_awake:        nonzero if ca8210 is initialised, ready for comms\n * @sync_down:              counts number of downstream synchronous commands\n * @sync_up:                counts number of upstream synchronous commands\n * @spi_transfer_complete   completion object for a single spi_transfer\n * @sync_exchange_complete  completion object for a complete synchronous API\n *                           exchange\n * @promiscuous             whether the ca8210 is in promiscuous mode or not\n * @retries:                records how many times the current pending spi\n *                           transfer has been retried\n */\nstruct ca8210_priv {\n\tstruct spi_device *spi;\n\tstruct ieee802154_hw *hw;\n\tbool hw_registered;\n\tspinlock_t lock;\n\tstruct workqueue_struct *mlme_workqueue;\n\tstruct workqueue_struct *irq_workqueue;\n\tstruct sk_buff *tx_skb;\n\tu8 nextmsduhandle;\n\tstruct clk *clk;\n\tint last_dsn;\n\tstruct ca8210_test test;\n\tbool async_tx_pending;\n\tu8 *sync_command_response;\n\tstruct completion ca8210_is_awake;\n\tint sync_down, sync_up;\n\tstruct completion spi_transfer_complete, sync_exchange_complete;\n\tbool promiscuous;\n\tint retries;\n};\n\n/**\n * struct work_priv_container - link between a work object and the relevant\n *                              device's private data\n * @work: work object being executed\n * @priv: device's private data section\n *\n */\nstruct work_priv_container {\n\tstruct work_struct work;\n\tstruct ca8210_priv *priv;\n};\n\n/**\n * struct ca8210_platform_data - ca8210 platform data structure\n * @extclockenable: true if the external clock is to be enabled\n * @extclockfreq:   frequency of the external clock\n * @extclockgpio:   ca8210 output gpio of the external clock\n * @gpio_reset:     gpio number of ca8210 reset line\n * @gpio_irq:       gpio number of ca8210 interrupt line\n * @irq_id:         identifier for the ca8210 irq\n *\n */\nstruct ca8210_platform_data {\n\tbool extclockenable;\n\tunsigned int extclockfreq;\n\tunsigned int extclockgpio;\n\tint gpio_reset;\n\tint gpio_irq;\n\tint irq_id;\n};\n\n/**\n * struct fulladdr - full MAC addressing information structure\n * @mode:    address mode (none, short, extended)\n * @pan_id:  16-bit LE pan id\n * @address: LE address, variable length as specified by mode\n *\n */\nstruct fulladdr {\n\tu8         mode;\n\tu8         pan_id[2];\n\tu8         address[8];\n};\n\n/**\n * union macaddr: generic MAC address container\n * @short_addr:   16-bit short address\n * @ieee_address: 64-bit extended address as LE byte array\n *\n */\nunion macaddr {\n\tu16        short_address;\n\tu8         ieee_address[8];\n};\n\n/**\n * struct secspec: security specification for SAP commands\n * @security_level: 0-7, controls level of authentication & encryption\n * @key_id_mode:    0-3, specifies how to obtain key\n * @key_source:     extended key retrieval data\n * @key_index:      single-byte key identifier\n *\n */\nstruct secspec {\n\tu8         security_level;\n\tu8         key_id_mode;\n\tu8         key_source[8];\n\tu8         key_index;\n};\n\n/* downlink functions parameter set definitions */\nstruct mcps_data_request_pset {\n\tu8              src_addr_mode;\n\tstruct fulladdr dst;\n\tu8              msdu_length;\n\tu8              msdu_handle;\n\tu8              tx_options;\n\tu8              msdu[MAX_DATA_SIZE];\n};\n\nstruct mlme_set_request_pset {\n\tu8         pib_attribute;\n\tu8         pib_attribute_index;\n\tu8         pib_attribute_length;\n\tu8         pib_attribute_value[MAX_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_set_request_pset {\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_get_request_pset {\n\tu8         hw_attribute;\n};\n\nstruct tdme_setsfr_request_pset {\n\tu8         sfr_page;\n\tu8         sfr_address;\n\tu8         sfr_value;\n};\n\n/* uplink functions parameter set definitions */\nstruct hwme_set_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n};\n\nstruct hwme_get_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct tdme_setsfr_confirm_pset {\n\tu8         status;\n\tu8         sfr_page;\n\tu8         sfr_address;\n};\n\nstruct mac_message {\n\tu8      command_id;\n\tu8      length;\n\tunion {\n\t\tstruct mcps_data_request_pset       data_req;\n\t\tstruct mlme_set_request_pset        set_req;\n\t\tstruct hwme_set_request_pset        hwme_set_req;\n\t\tstruct hwme_get_request_pset        hwme_get_req;\n\t\tstruct tdme_setsfr_request_pset     tdme_set_sfr_req;\n\t\tstruct hwme_set_confirm_pset        hwme_set_cnf;\n\t\tstruct hwme_get_confirm_pset        hwme_get_cnf;\n\t\tstruct tdme_setsfr_confirm_pset     tdme_set_sfr_cnf;\n\t\tu8                                  u8param;\n\t\tu8                                  status;\n\t\tu8                                  payload[148];\n\t} pdata;\n};\n\nunion pa_cfg_sfr {\n\tstruct {\n\t\tu8 bias_current_trim     : 3;\n\t\tu8 /* reserved */        : 1;\n\t\tu8 buffer_capacitor_trim : 3;\n\t\tu8 boost                 : 1;\n\t};\n\tu8 paib;\n};\n\nstruct preamble_cfg_sfr {\n\tu8 timeout_symbols      : 3;\n\tu8 acquisition_symbols  : 3;\n\tu8 search_symbols       : 2;\n};\n\nstatic int (*cascoda_api_upstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tvoid *device_ref\n);\n\n/**\n * link_to_linux_err() - Translates an 802.15.4 return code into the closest\n *                       linux error\n * @link_status:  802.15.4 status code\n *\n * Return: 0 or Linux error code\n */\nstatic int link_to_linux_err(int link_status)\n{\n\tif (link_status < 0) {\n\t\t/* status is already a Linux code */\n\t\treturn link_status;\n\t}\n\tswitch (link_status) {\n\tcase MAC_SUCCESS:\n\tcase MAC_REALIGNMENT:\n\t\treturn 0;\n\tcase MAC_IMPROPER_KEY_TYPE:\n\t\treturn -EKEYREJECTED;\n\tcase MAC_IMPROPER_SECURITY_LEVEL:\n\tcase MAC_UNSUPPORTED_LEGACY:\n\tcase MAC_DENIED:\n\t\treturn -EACCES;\n\tcase MAC_BEACON_LOST:\n\tcase MAC_NO_ACK:\n\tcase MAC_NO_BEACON:\n\t\treturn -ENETUNREACH;\n\tcase MAC_CHANNEL_ACCESS_FAILURE:\n\tcase MAC_TX_ACTIVE:\n\tcase MAC_SCAN_IN_PROGRESS:\n\t\treturn -EBUSY;\n\tcase MAC_DISABLE_TRX_FAILURE:\n\tcase MAC_OUT_OF_CAP:\n\t\treturn -EAGAIN;\n\tcase MAC_FRAME_TOO_LONG:\n\t\treturn -EMSGSIZE;\n\tcase MAC_INVALID_GTS:\n\tcase MAC_PAST_TIME:\n\t\treturn -EBADSLT;\n\tcase MAC_INVALID_HANDLE:\n\t\treturn -EBADMSG;\n\tcase MAC_INVALID_PARAMETER:\n\tcase MAC_UNSUPPORTED_ATTRIBUTE:\n\tcase MAC_ON_TIME_TOO_LONG:\n\tcase MAC_INVALID_INDEX:\n\t\treturn -EINVAL;\n\tcase MAC_NO_DATA:\n\t\treturn -ENODATA;\n\tcase MAC_NO_SHORT_ADDRESS:\n\t\treturn -EFAULT;\n\tcase MAC_PAN_ID_CONFLICT:\n\t\treturn -EADDRINUSE;\n\tcase MAC_TRANSACTION_EXPIRED:\n\t\treturn -ETIME;\n\tcase MAC_TRANSACTION_OVERFLOW:\n\t\treturn -ENOBUFS;\n\tcase MAC_UNAVAILABLE_KEY:\n\t\treturn -ENOKEY;\n\tcase MAC_INVALID_ADDRESS:\n\t\treturn -ENXIO;\n\tcase MAC_TRACKING_OFF:\n\tcase MAC_SUPERFRAME_OVERLAP:\n\t\treturn -EREMOTEIO;\n\tcase MAC_LIMIT_REACHED:\n\t\treturn -EDQUOT;\n\tcase MAC_READ_ONLY:\n\t\treturn -EROFS;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\n/**\n * ca8210_test_int_driver_write() - Writes a message to the test interface to be\n *                                  read by the userspace\n * @buf:  Buffer containing upstream message\n * @len:  length of message to write\n * @spi:  SPI device of message originator\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_int_driver_write(\n\tconst u8       *buf,\n\tsize_t          len,\n\tvoid           *spi\n)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_test *test = &priv->test;\n\tchar *fifo_buffer;\n\tint i;\n\n\tdev_dbg(\n\t\t&priv->spi->dev,\n\t\t\"test_interface: Buffering upstream message:\\n\"\n\t);\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", buf[i]);\n\n\tfifo_buffer = kmemdup(buf, len, GFP_KERNEL);\n\tif (!fifo_buffer)\n\t\treturn -ENOMEM;\n\tkfifo_in(&test->up_fifo, &fifo_buffer, 4);\n\twake_up_interruptible(&priv->test.readq);\n\n\treturn 0;\n}\n\n/* SPI Operation */\n\nstatic int ca8210_net_rx(\n\tstruct ieee802154_hw  *hw,\n\tu8                    *command,\n\tsize_t                 len\n);\nstatic u8 mlme_reset_request_sync(\n\tu8       set_default_pib,\n\tvoid    *device_ref\n);\nstatic int ca8210_spi_transfer(\n\tstruct spi_device *spi,\n\tconst u8          *buf,\n\tsize_t             len\n);\n\n/**\n * ca8210_reset_send() - Hard resets the ca8210 for a given time\n * @spi:  Pointer to target ca8210 spi device\n * @ms:   Milliseconds to hold the reset line low for\n */\nstatic void ca8210_reset_send(struct spi_device *spi, unsigned int ms)\n{\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tlong status;\n\n\tgpio_set_value(pdata->gpio_reset, 0);\n\treinit_completion(&priv->ca8210_is_awake);\n\tmsleep(ms);\n\tgpio_set_value(pdata->gpio_reset, 1);\n\tpriv->promiscuous = false;\n\n\t/* Wait until wakeup indication seen */\n\tstatus = wait_for_completion_interruptible_timeout(\n\t\t&priv->ca8210_is_awake,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (status == 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Fatal: No wakeup from ca8210 after reset!\\n\"\n\t\t);\n\t}\n\n\tdev_dbg(&spi->dev, \"Reset the device\\n\");\n}\n\n/**\n * ca8210_mlme_reset_worker() - Resets the MLME, Called when the MAC OVERFLOW\n *                              condition happens.\n * @work:  Pointer to work being executed\n */\nstatic void ca8210_mlme_reset_worker(struct work_struct *work)\n{\n\tstruct work_priv_container *wpc = container_of(\n\t\twork,\n\t\tstruct work_priv_container,\n\t\twork\n\t);\n\tstruct ca8210_priv *priv = wpc->priv;\n\n\tmlme_reset_request_sync(0, priv->spi);\n\tkfree(wpc);\n}\n\n/**\n * ca8210_rx_done() - Calls various message dispatches responding to a received\n *                    command\n * @arg:  Pointer to the cas_control object for the relevant spi transfer\n *\n * Presents a received SAP command from the ca8210 to the Cascoda EVBME, test\n * interface and network driver.\n */\nstatic void ca8210_rx_done(struct cas_control *cas_ctl)\n{\n\tu8 *buf;\n\tunsigned int len;\n\tstruct work_priv_container *mlme_reset_wpc;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\n\tbuf = cas_ctl->tx_in_buf;\n\tlen = buf[1] + 2;\n\tif (len > CA8210_SPI_BUF_SIZE) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Received packet len (%u) erroneously long\\n\",\n\t\t\tlen\n\t\t);\n\t\tgoto finish;\n\t}\n\n\tif (buf[0] & SPI_SYN) {\n\t\tif (priv->sync_command_response) {\n\t\t\tmemcpy(priv->sync_command_response, buf, len);\n\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t} else {\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t\t\tpriv->sync_up++;\n\t\t}\n\t} else {\n\t\tif (cascoda_api_upstream)\n\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t}\n\n\tca8210_net_rx(priv->hw, buf, len);\n\tif (buf[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tif (buf[3] == MAC_TRANSACTION_OVERFLOW) {\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Waiting for transaction overflow to stabilise...\\n\");\n\t\t\tmsleep(2000);\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Resetting MAC...\\n\");\n\n\t\t\tmlme_reset_wpc = kmalloc(sizeof(*mlme_reset_wpc),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!mlme_reset_wpc)\n\t\t\t\tgoto finish;\n\t\t\tINIT_WORK(\n\t\t\t\t&mlme_reset_wpc->work,\n\t\t\t\tca8210_mlme_reset_worker\n\t\t\t);\n\t\t\tmlme_reset_wpc->priv = priv;\n\t\t\tqueue_work(priv->mlme_workqueue, &mlme_reset_wpc->work);\n\t\t}\n\t} else if (buf[0] == SPI_HWME_WAKEUP_INDICATION) {\n\t\tdev_notice(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Wakeup indication received, reason:\\n\"\n\t\t);\n\t\tswitch (buf[2]) {\n\t\tcase 0:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power Up / System Reset\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Watchdog Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by Sleep Timer Time-Out\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by Sleep Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Sleep-Timer Time-Out in Active Mode\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&priv->spi->dev, \"Wakeup reason unknown\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcomplete(&priv->ca8210_is_awake);\n\t}\n\nfinish:;\n}\n\nstatic int ca8210_remove(struct spi_device *spi_device);\n\n/**\n * ca8210_spi_transfer_complete() - Called when a single spi transfer has\n *                                  completed\n * @context:  Pointer to the cas_control object for the finished transfer\n */\nstatic void ca8210_spi_transfer_complete(void *context)\n{\n\tstruct cas_control *cas_ctl = context;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\tbool duplex_rx = false;\n\tint i;\n\tu8 retry_buffer[CA8210_SPI_BUF_SIZE];\n\n\tif (\n\t\tcas_ctl->tx_in_buf[0] == SPI_NACK ||\n\t\t(cas_ctl->tx_in_buf[0] == SPI_IDLE &&\n\t\tcas_ctl->tx_in_buf[1] == SPI_NACK)\n\t) {\n\t\t/* ca8210 is busy */\n\t\tdev_info(&priv->spi->dev, \"ca8210 was busy during attempted write\\n\");\n\t\tif (cas_ctl->tx_buf[0] == SPI_IDLE) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"IRQ servicing NACKd, dropping transfer\\n\"\n\t\t\t);\n\t\t\tkfree(cas_ctl);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->retries > 3) {\n\t\t\tdev_err(&priv->spi->dev, \"too many retries!\\n\");\n\t\t\tkfree(cas_ctl);\n\t\t\tca8210_remove(priv->spi);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(retry_buffer, cas_ctl->tx_buf, CA8210_SPI_BUF_SIZE);\n\t\tkfree(cas_ctl);\n\t\tca8210_spi_transfer(\n\t\t\tpriv->spi,\n\t\t\tretry_buffer,\n\t\t\tCA8210_SPI_BUF_SIZE\n\t\t);\n\t\tpriv->retries++;\n\t\tdev_info(&priv->spi->dev, \"retried spi write\\n\");\n\t\treturn;\n\t} else if (\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_IDLE &&\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_NACK\n\t\t) {\n\t\tduplex_rx = true;\n\t}\n\n\tif (duplex_rx) {\n\t\tdev_dbg(&priv->spi->dev, \"READ CMD DURING TX\\n\");\n\t\tfor (i = 0; i < cas_ctl->tx_in_buf[1] + 2; i++)\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"%#03x\\n\",\n\t\t\t\tcas_ctl->tx_in_buf[i]\n\t\t\t);\n\t\tca8210_rx_done(cas_ctl);\n\t}\n\tcomplete(&priv->spi_transfer_complete);\n\tkfree(cas_ctl);\n\tpriv->retries = 0;\n}\n\n/**\n * ca8210_spi_transfer() - Initiate duplex spi transfer with ca8210\n * @spi: Pointer to spi device for transfer\n * @buf: Octet array to send\n * @len: length of the buffer being sent\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_spi_transfer(\n\tstruct spi_device  *spi,\n\tconst u8           *buf,\n\tsize_t              len\n)\n{\n\tint i, status = 0;\n\tstruct ca8210_priv *priv;\n\tstruct cas_control *cas_ctl;\n\n\tif (!spi) {\n\t\tpr_crit(\"NULL spi device passed to %s\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = spi_get_drvdata(spi);\n\treinit_completion(&priv->spi_transfer_complete);\n\n\tdev_dbg(&spi->dev, \"%s called\\n\", __func__);\n\n\tcas_ctl = kmalloc(sizeof(*cas_ctl), GFP_ATOMIC);\n\tif (!cas_ctl)\n\t\treturn -ENOMEM;\n\n\tcas_ctl->priv = priv;\n\tmemset(cas_ctl->tx_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemset(cas_ctl->tx_in_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemcpy(cas_ctl->tx_buf, buf, len);\n\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&spi->dev, \"%#03x\\n\", cas_ctl->tx_buf[i]);\n\n\tspi_message_init(&cas_ctl->msg);\n\n\tcas_ctl->transfer.tx_nbits = 1; /* 1 MOSI line */\n\tcas_ctl->transfer.rx_nbits = 1; /* 1 MISO line */\n\tcas_ctl->transfer.speed_hz = 0; /* Use device setting */\n\tcas_ctl->transfer.bits_per_word = 0; /* Use device setting */\n\tcas_ctl->transfer.tx_buf = cas_ctl->tx_buf;\n\tcas_ctl->transfer.rx_buf = cas_ctl->tx_in_buf;\n\tcas_ctl->transfer.delay_usecs = 0;\n\tcas_ctl->transfer.cs_change = 0;\n\tcas_ctl->transfer.len = sizeof(struct mac_message);\n\tcas_ctl->msg.complete = ca8210_spi_transfer_complete;\n\tcas_ctl->msg.context = cas_ctl;\n\n\tspi_message_add_tail(\n\t\t&cas_ctl->transfer,\n\t\t&cas_ctl->msg\n\t);\n\n\tstatus = spi_async(spi, &cas_ctl->msg);\n\tif (status < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"status %d from spi_sync in write\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * ca8210_spi_exchange() - Exchange API/SAP commands with the radio\n * @buf:         Octet array of command being sent downstream\n * @len:         length of buf\n * @response:    buffer for storing synchronous response\n * @device_ref:  spi_device pointer for ca8210\n *\n * Effectively calls ca8210_spi_transfer to write buf[] to the spi, then for\n * synchronous commands waits for the corresponding response to be read from\n * the spi before returning. The response is written to the response parameter.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_spi_exchange(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n)\n{\n\tint status = 0;\n\tstruct spi_device *spi = device_ref;\n\tstruct ca8210_priv *priv = spi->dev.driver_data;\n\tlong wait_remaining;\n\n\tif ((buf[0] & SPI_SYN) && response) { /* if sync wait for confirm */\n\t\treinit_completion(&priv->sync_exchange_complete);\n\t\tpriv->sync_command_response = response;\n\t}\n\n\tdo {\n\t\treinit_completion(&priv->spi_transfer_complete);\n\t\tstatus = ca8210_spi_transfer(priv->spi, buf, len);\n\t\tif (status) {\n\t\t\tdev_warn(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"spi write failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\tif (status == -EBUSY)\n\t\t\t\tcontinue;\n\t\t\tif (((buf[0] & SPI_SYN) && response))\n\t\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t\t&priv->spi_transfer_complete,\n\t\t\tmsecs_to_jiffies(1000)\n\t\t);\n\t\tif (wait_remaining == -ERESTARTSYS) {\n\t\t\tstatus = -ERESTARTSYS;\n\t\t} else if (wait_remaining == 0) {\n\t\t\tdev_err(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"SPI downstream transfer timed out!\\n\"\n\t\t\t);\n\t\t\tstatus = -ETIME;\n\t\t\tgoto cleanup;\n\t\t}\n\t} while (status < 0);\n\n\tif (!((buf[0] & SPI_SYN) && response))\n\t\tgoto cleanup;\n\n\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t&priv->sync_exchange_complete,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (wait_remaining == -ERESTARTSYS) {\n\t\tstatus = -ERESTARTSYS;\n\t} else if (wait_remaining == 0) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"Synchronous confirm timeout\\n\"\n\t\t);\n\t\tstatus = -ETIME;\n\t}\n\ncleanup:\n\tpriv->sync_command_response = NULL;\n\treturn status;\n}\n\n/**\n * ca8210_interrupt_handler() - Called when an irq is received from the ca8210\n * @irq:     Id of the irq being handled\n * @dev_id:  Pointer passed by the system, pointing to the ca8210's private data\n *\n * This function is called when the irq line from the ca8210 is asserted,\n * signifying that the ca8210 has a message to send upstream to us. Starts the\n * asynchronous spi read.\n *\n * Return: irq return code\n */\nstatic irqreturn_t ca8210_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct ca8210_priv *priv = dev_id;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"irq: Interrupt occurred\\n\");\n\tdo {\n\t\tstatus = ca8210_spi_transfer(priv->spi, NULL, 0);\n\t\tif (status && (status != -EBUSY)) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi read failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t} while (status == -EBUSY);\n\treturn IRQ_HANDLED;\n}\n\nstatic int (*cascoda_api_downstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n) = ca8210_spi_exchange;\n\n/* Cascoda API / 15.4 SAP Primitives */\n\n/**\n * tdme_setsfr_request_sync() - TDME_SETSFR_request/confirm according to API\n * @sfr_page:    SFR Page\n * @sfr_address: SFR Address\n * @sfr_value:   SFR Value\n * @device_ref:  Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of TDME-SETSFR.confirm\n */\nstatic u8 tdme_setsfr_request_sync(\n\tu8            sfr_page,\n\tu8            sfr_address,\n\tu8            sfr_value,\n\tvoid         *device_ref\n)\n{\n\tint ret;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_TDME_SETSFR_REQUEST;\n\tcommand.length = 3;\n\tcommand.pdata.tdme_set_sfr_req.sfr_page    = sfr_page;\n\tcommand.pdata.tdme_set_sfr_req.sfr_address = sfr_address;\n\tcommand.pdata.tdme_set_sfr_req.sfr_value   = sfr_value;\n\tresponse.command_id = SPI_IDLE;\n\tret = cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"cascoda_api_downstream returned %d\", ret);\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_TDME_SETSFR_CONFIRM) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"sync response to SPI_TDME_SETSFR_REQUEST was not SPI_TDME_SETSFR_CONFIRM, it was %d\\n\",\n\t\t\tresponse.command_id\n\t\t);\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\treturn response.pdata.tdme_set_sfr_cnf.status;\n}\n\n/**\n * tdme_chipinit() - TDME Chip Register Default Initialisation Macro\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of API calls\n */\nstatic u8 tdme_chipinit(void *device_ref)\n{\n\tu8 status = MAC_SUCCESS;\n\tu8 sfr_address;\n\tstruct spi_device *spi = device_ref;\n\tstruct preamble_cfg_sfr pre_cfg_value = {\n\t\t.timeout_symbols     = 3,\n\t\t.acquisition_symbols = 3,\n\t\t.search_symbols      = 1,\n\t};\n\t/* LNA Gain Settings */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX40),\n\t\tLNAGX40_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX41),\n\t\tLNAGX41_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX42),\n\t\tLNAGX42_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX43),\n\t\tLNAGX43_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX44),\n\t\tLNAGX44_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX45),\n\t\tLNAGX45_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX46),\n\t\tLNAGX46_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX47),\n\t\tLNAGX47_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Preamble Timing Config */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PRECFG),\n\t\t*((u8 *)&pre_cfg_value), device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Preamble Threshold High */\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PTHRH),\n\t\tPTHRH_DEFAULT_THRESHOLD, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t/* Tx Output Power 8 dBm */\n\tstatus = tdme_setsfr_request_sync(\n\t\t0, (sfr_address = CA8210_SFR_PACFGIB),\n\t\tPACFGIB_DEFAULT_CURRENT, device_ref);\n\tif (status)\n\t\tgoto finish;\n\nfinish:\n\tif (status != MAC_SUCCESS) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"failed to set sfr at %#03x, status = %#03x\\n\",\n\t\t\tsfr_address,\n\t\t\tstatus\n\t\t);\n\t}\n\treturn status;\n}\n\n/**\n * tdme_channelinit() - TDME Channel Register Default Initialisation Macro (Tx)\n * @channel:    802.15.4 channel to initialise chip for\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of API calls\n */\nstatic u8 tdme_channelinit(u8 channel, void *device_ref)\n{\n\t/* Transceiver front-end local oscillator tx two-point calibration\n\t * value. Tuned for the hardware.\n\t */\n\tu8 txcalval;\n\n\tif (channel >= 25)\n\t\ttxcalval = 0xA7;\n\telse if (channel >= 23)\n\t\ttxcalval = 0xA8;\n\telse if (channel >= 22)\n\t\ttxcalval = 0xA9;\n\telse if (channel >= 20)\n\t\ttxcalval = 0xAA;\n\telse if (channel >= 17)\n\t\ttxcalval = 0xAB;\n\telse if (channel >= 16)\n\t\ttxcalval = 0xAC;\n\telse if (channel >= 14)\n\t\ttxcalval = 0xAD;\n\telse if (channel >= 12)\n\t\ttxcalval = 0xAE;\n\telse\n\t\ttxcalval = 0xAF;\n\n\treturn tdme_setsfr_request_sync(\n\t\t1,\n\t\tCA8210_SFR_LOTXCAL,\n\t\ttxcalval,\n\t\tdevice_ref\n\t);  /* LO Tx Cal */\n}\n\n/**\n * tdme_checkpibattribute() - Checks Attribute Values that are not checked in\n *                            MAC\n * @pib_attribute:        Attribute Number\n * @pib_attribute_length: Attribute length\n * @pib_attribute_value:  Pointer to Attribute Value\n * @device_ref:           Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of checks\n */\nstatic u8 tdme_checkpibattribute(\n\tu8            pib_attribute,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value\n)\n{\n\tu8 status = MAC_SUCCESS;\n\tu8 value;\n\n\tvalue  = *((u8 *)pib_attribute_value);\n\n\tswitch (pib_attribute) {\n\t/* PHY */\n\tcase PHY_TRANSMIT_POWER:\n\t\tif (value > 0x3F)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase PHY_CCA_MODE:\n\t\tif (value > 0x03)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* MAC */\n\tcase MAC_BATT_LIFE_EXT_PERIODS:\n\t\tif (value < 6 || value > 41)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD:\n\t\tif (pib_attribute_length > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD_LENGTH:\n\t\tif (value > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_BE:\n\t\tif (value < 3 || value > 8)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_CSMA_BACKOFFS:\n\t\tif (value > 5)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_FRAME_RETRIES:\n\t\tif (value > 7)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MIN_BE:\n\t\tif (value > 8)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_RESPONSE_WAIT_TIME:\n\t\tif (value < 2 || value > 64)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_SUPERFRAME_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* boolean */\n\tcase MAC_ASSOCIATED_PAN_COORD:\n\tcase MAC_ASSOCIATION_PERMIT:\n\tcase MAC_AUTO_REQUEST:\n\tcase MAC_BATT_LIFE_EXT:\n\tcase MAC_GTS_PERMIT:\n\tcase MAC_PROMISCUOUS_MODE:\n\tcase MAC_RX_ON_WHEN_IDLE:\n\tcase MAC_SECURITY_ENABLED:\n\t\tif (value > 1)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\t/* MAC SEC */\n\tcase MAC_AUTO_REQUEST_SECURITY_LEVEL:\n\t\tif (value > 7)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_AUTO_REQUEST_KEY_ID_MODE:\n\t\tif (value > 3)\n\t\t\tstatus = MAC_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n/**\n * tdme_settxpower() - Sets the tx power for MLME_SET phyTransmitPower\n * @txp:        Transmit Power\n * @device_ref: Nondescript pointer to target device\n *\n * Normalised to 802.15.4 Definition (6-bit, signed):\n * Bit 7-6: not used\n * Bit 5-0: tx power (-32 - +31 dB)\n *\n * Return: 802.15.4 status code of api calls\n */\nstatic u8 tdme_settxpower(u8 txp, void *device_ref)\n{\n\tu8 status;\n\ts8 txp_val;\n\tu8 txp_ext;\n\tunion pa_cfg_sfr pa_cfg_val;\n\n\t/* extend from 6 to 8 bit */\n\ttxp_ext = 0x3F & txp;\n\tif (txp_ext & 0x20)\n\t\ttxp_ext += 0xC0;\n\ttxp_val = (s8)txp_ext;\n\n\tif (CA8210_MAC_MPW) {\n\t\tif (txp_val > 0) {\n\t\t\t/* 8 dBm: ptrim = 5, itrim = +3 => +4 dBm */\n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 5;\n\t\t\tpa_cfg_val.boost                 = 1;\n\t\t} else {\n\t\t\t/* 0 dBm: ptrim = 7, itrim = +3 => -6 dBm */\n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 7;\n\t\t\tpa_cfg_val.boost                 = 0;\n\t\t}\n\t\t/* write PACFG */\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFG,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t} else {\n\t\t/* Look-Up Table for Setting Current and Frequency Trim values\n\t\t * for desired Output Power\n\t\t */\n\t\tif (txp_val > 8) {\n\t\t\tpa_cfg_val.paib = 0x3F;\n\t\t} else if (txp_val == 8) {\n\t\t\tpa_cfg_val.paib = 0x32;\n\t\t} else if (txp_val == 7) {\n\t\t\tpa_cfg_val.paib = 0x22;\n\t\t} else if (txp_val == 6) {\n\t\t\tpa_cfg_val.paib = 0x18;\n\t\t} else if (txp_val == 5) {\n\t\t\tpa_cfg_val.paib = 0x10;\n\t\t} else if (txp_val == 4) {\n\t\t\tpa_cfg_val.paib = 0x0C;\n\t\t} else if (txp_val == 3) {\n\t\t\tpa_cfg_val.paib = 0x08;\n\t\t} else if (txp_val == 2) {\n\t\t\tpa_cfg_val.paib = 0x05;\n\t\t} else if (txp_val == 1) {\n\t\t\tpa_cfg_val.paib = 0x03;\n\t\t} else if (txp_val == 0) {\n\t\t\tpa_cfg_val.paib = 0x01;\n\t\t} else { /* < 0 */\n\t\t\tpa_cfg_val.paib = 0x00;\n\t\t}\n\t\t/* write PACFGIB */\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFGIB,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * mcps_data_request() - mcps_data_request (Send Data) according to API Spec\n * @src_addr_mode:    Source Addressing Mode\n * @dst_address_mode: Destination Addressing Mode\n * @dst_pan_id:       Destination PAN ID\n * @dst_addr:         Pointer to Destination Address\n * @msdu_length:      length of Data\n * @msdu:             Pointer to Data\n * @msdu_handle:      Handle of Data\n * @tx_options:       Tx Options Bit Field\n * @security:         Pointer to Security Structure or NULL\n * @device_ref:       Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of action\n */\nstatic u8 mcps_data_request(\n\tu8               src_addr_mode,\n\tu8               dst_address_mode,\n\tu16              dst_pan_id,\n\tunion macaddr   *dst_addr,\n\tu8               msdu_length,\n\tu8              *msdu,\n\tu8               msdu_handle,\n\tu8               tx_options,\n\tstruct secspec  *security,\n\tvoid            *device_ref\n)\n{\n\tstruct secspec *psec;\n\tstruct mac_message command;\n\n\tcommand.command_id = SPI_MCPS_DATA_REQUEST;\n\tcommand.pdata.data_req.src_addr_mode = src_addr_mode;\n\tcommand.pdata.data_req.dst.mode = dst_address_mode;\n\tif (dst_address_mode != MAC_MODE_NO_ADDR) {\n\t\tcommand.pdata.data_req.dst.pan_id[0] = LS_BYTE(dst_pan_id);\n\t\tcommand.pdata.data_req.dst.pan_id[1] = MS_BYTE(dst_pan_id);\n\t\tif (dst_address_mode == MAC_MODE_SHORT_ADDR) {\n\t\t\tcommand.pdata.data_req.dst.address[0] = LS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t\tcommand.pdata.data_req.dst.address[1] = MS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t} else {   /* MAC_MODE_LONG_ADDR*/\n\t\t\tmemcpy(\n\t\t\t\tcommand.pdata.data_req.dst.address,\n\t\t\t\tdst_addr->ieee_address,\n\t\t\t\t8\n\t\t\t);\n\t\t}\n\t}\n\tcommand.pdata.data_req.msdu_length = msdu_length;\n\tcommand.pdata.data_req.msdu_handle = msdu_handle;\n\tcommand.pdata.data_req.tx_options = tx_options;\n\tmemcpy(command.pdata.data_req.msdu, msdu, msdu_length);\n\tpsec = (struct secspec *)(command.pdata.data_req.msdu + msdu_length);\n\tcommand.length = sizeof(struct mcps_data_request_pset) -\n\t\tMAX_DATA_SIZE + msdu_length;\n\tif (!security || security->security_level == 0) {\n\t\tpsec->security_level = 0;\n\t\tcommand.length += 1;\n\t} else {\n\t\t*psec = *security;\n\t\tcommand.length += sizeof(struct secspec);\n\t}\n\n\tif (ca8210_spi_transfer(device_ref, &command.command_id,\n\t\t\t\tcommand.length + 2))\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn MAC_SUCCESS;\n}\n\n/**\n * mlme_reset_request_sync() - MLME_RESET_request/confirm according to API Spec\n * @set_default_pib: Set defaults in PIB\n * @device_ref:      Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of MLME-RESET.confirm\n */\nstatic u8 mlme_reset_request_sync(\n\tu8    set_default_pib,\n\tvoid *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_MLME_RESET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.u8param = set_default_pib;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\tdev_err(&spi->dev, \"cascoda_api_downstream failed\\n\");\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_RESET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\tstatus = response.pdata.status;\n\n\t/* reset COORD Bit for Channel Filtering as Coordinator */\n\tif (CA8210_MAC_WORKAROUNDS && set_default_pib && !status) {\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n/**\n * mlme_set_request_sync() - MLME_SET_request/confirm according to API Spec\n * @pib_attribute:        Attribute Number\n * @pib_attribute_index:  Index within Attribute if an Array\n * @pib_attribute_length: Attribute length\n * @pib_attribute_value:  Pointer to Attribute Value\n * @device_ref:           Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of MLME-SET.confirm\n */\nstatic u8 mlme_set_request_sync(\n\tu8            pib_attribute,\n\tu8            pib_attribute_index,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value,\n\tvoid         *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\n\t/* pre-check the validity of pib_attribute values that are not checked\n\t * in MAC\n\t */\n\tif (tdme_checkpibattribute(\n\t\tpib_attribute, pib_attribute_length, pib_attribute_value)) {\n\t\treturn MAC_INVALID_PARAMETER;\n\t}\n\n\tif (pib_attribute == PHY_CURRENT_CHANNEL) {\n\t\tstatus = tdme_channelinit(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (pib_attribute == PHY_TRANSMIT_POWER) {\n\t\treturn tdme_settxpower(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\tcommand.command_id = SPI_MLME_SET_REQUEST;\n\tcommand.length = sizeof(struct mlme_set_request_pset) -\n\t\tMAX_ATTRIBUTE_SIZE + pib_attribute_length;\n\tcommand.pdata.set_req.pib_attribute = pib_attribute;\n\tcommand.pdata.set_req.pib_attribute_index = pib_attribute_index;\n\tcommand.pdata.set_req.pib_attribute_length = pib_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.set_req.pib_attribute_value,\n\t\tpib_attribute_value,\n\t\tpib_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_SET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn response.pdata.status;\n}\n\n/**\n * hwme_set_request_sync() - HWME_SET_request/confirm according to API Spec\n * @hw_attribute:        Attribute Number\n * @hw_attribute_length: Attribute length\n * @hw_attribute_value:  Pointer to Attribute Value\n * @device_ref:          Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of HWME-SET.confirm\n */\nstatic u8 hwme_set_request_sync(\n\tu8           hw_attribute,\n\tu8           hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_SET_REQUEST;\n\tcommand.length = 2 + hw_attribute_length;\n\tcommand.pdata.hwme_set_req.hw_attribute = hw_attribute;\n\tcommand.pdata.hwme_set_req.hw_attribute_length = hw_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.hwme_set_req.hw_attribute_value,\n\t\thw_attribute_value,\n\t\thw_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_SET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\treturn response.pdata.hwme_set_cnf.status;\n}\n\n/**\n * hwme_get_request_sync() - HWME_GET_request/confirm according to API Spec\n * @hw_attribute:        Attribute Number\n * @hw_attribute_length: Attribute length\n * @hw_attribute_value:  Pointer to Attribute Value\n * @device_ref:          Nondescript pointer to target device\n *\n * Return: 802.15.4 status code of HWME-GET.confirm\n */\nstatic u8 hwme_get_request_sync(\n\tu8           hw_attribute,\n\tu8          *hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_GET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.hwme_get_req.hw_attribute = hw_attribute;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn MAC_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_GET_CONFIRM)\n\t\treturn MAC_SYSTEM_ERROR;\n\n\tif (response.pdata.hwme_get_cnf.status == MAC_SUCCESS) {\n\t\t*hw_attribute_length =\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_length;\n\t\tmemcpy(\n\t\t\thw_attribute_value,\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_value,\n\t\t\t*hw_attribute_length\n\t\t);\n\t}\n\n\treturn response.pdata.hwme_get_cnf.status;\n}\n\n/* Network driver operation */\n\n/**\n * ca8210_async_xmit_complete() - Called to announce that an asynchronous\n *                                transmission has finished\n * @hw:          ieee802154_hw of ca8210 that has finished exchange\n * @msduhandle:  Identifier of transmission that has completed\n * @status:      Returned 802.15.4 status code of the transmission\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_async_xmit_complete(\n\tstruct ieee802154_hw  *hw,\n\tu8                     msduhandle,\n\tu8                     status)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (priv->nextmsduhandle != msduhandle) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Unexpected msdu_handle on data confirm, Expected %d, got %d\\n\",\n\t\t\tpriv->nextmsduhandle,\n\t\t\tmsduhandle\n\t\t);\n\t\treturn -EIO;\n\t}\n\n\tpriv->async_tx_pending = false;\n\tpriv->nextmsduhandle++;\n\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Link transmission unsuccessful, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\tif (status != MAC_TRANSACTION_OVERFLOW) {\n\t\t\tieee802154_wake_queue(priv->hw);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tieee802154_xmit_complete(priv->hw, priv->tx_skb, true);\n\n\treturn 0;\n}\n\n/**\n * ca8210_skb_rx() - Contructs a properly framed socket buffer from a received\n *                   MCPS_DATA_indication\n * @hw:        ieee802154_hw that MCPS_DATA_indication was received by\n * @len:       length of MCPS_DATA_indication\n * @data_ind:  Octet array of MCPS_DATA_indication\n *\n * Called by the spi driver whenever a SAP command is received, this function\n * will ascertain whether the command is of interest to the network driver and\n * take necessary action.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_skb_rx(\n\tstruct ieee802154_hw  *hw,\n\tsize_t                 len,\n\tu8                    *data_ind\n)\n{\n\tstruct ieee802154_hdr hdr;\n\tint msdulen;\n\tint hlen;\n\tu8 mpdulinkquality = data_ind[23];\n\tstruct sk_buff *skb;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\t/* Allocate mtu size buffer for every rx packet */\n\tskb = dev_alloc_skb(IEEE802154_MTU + sizeof(hdr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, sizeof(hdr));\n\n\tmsdulen = data_ind[22]; /* msdu_length */\n\tif (msdulen > IEEE802154_MTU) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"received erroneously large msdu length!\\n\"\n\t\t);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\tdev_dbg(&priv->spi->dev, \"skb buffer length = %d\\n\", msdulen);\n\n\tif (priv->promiscuous)\n\t\tgoto copy_payload;\n\n\t/* Populate hdr */\n\thdr.sec.level = data_ind[29 + msdulen];\n\tdev_dbg(&priv->spi->dev, \"security level: %#03x\\n\", hdr.sec.level);\n\tif (hdr.sec.level > 0) {\n\t\thdr.sec.key_id_mode = data_ind[30 + msdulen];\n\t\tmemcpy(&hdr.sec.extended_src, &data_ind[31 + msdulen], 8);\n\t\thdr.sec.key_id = data_ind[39 + msdulen];\n\t}\n\thdr.source.mode = data_ind[0];\n\tdev_dbg(&priv->spi->dev, \"srcAddrMode: %#03x\\n\", hdr.source.mode);\n\thdr.source.pan_id = *(u16 *)&data_ind[1];\n\tdev_dbg(&priv->spi->dev, \"srcPanId: %#06x\\n\", hdr.source.pan_id);\n\tmemcpy(&hdr.source.extended_addr, &data_ind[3], 8);\n\thdr.dest.mode = data_ind[11];\n\tdev_dbg(&priv->spi->dev, \"dstAddrMode: %#03x\\n\", hdr.dest.mode);\n\thdr.dest.pan_id = *(u16 *)&data_ind[12];\n\tdev_dbg(&priv->spi->dev, \"dstPanId: %#06x\\n\", hdr.dest.pan_id);\n\tmemcpy(&hdr.dest.extended_addr, &data_ind[14], 8);\n\n\t/* Fill in FC implicitly */\n\thdr.fc.type = 1; /* Data frame */\n\tif (hdr.sec.level)\n\t\thdr.fc.security_enabled = 1;\n\telse\n\t\thdr.fc.security_enabled = 0;\n\tif (data_ind[1] != data_ind[12] || data_ind[2] != data_ind[13])\n\t\thdr.fc.intra_pan = 1;\n\telse\n\t\thdr.fc.intra_pan = 0;\n\thdr.fc.dest_addr_mode = hdr.dest.mode;\n\thdr.fc.source_addr_mode = hdr.source.mode;\n\n\t/* Add hdr to front of buffer */\n\thlen = ieee802154_hdr_push(skb, &hdr);\n\n\tif (hlen < 0) {\n\t\tdev_crit(&priv->spi->dev, \"failed to push mac hdr onto skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn hlen;\n\t}\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = hlen;\n\ncopy_payload:\n\t/* Add <msdulen> bytes of space to the back of the buffer */\n\t/* Copy msdu to skb */\n\tskb_put_data(skb, &data_ind[29], msdulen);\n\n\tieee802154_rx_irqsafe(hw, skb, mpdulinkquality);\n\treturn 0;\n}\n\n/**\n * ca8210_net_rx() - Acts upon received SAP commands relevant to the network\n *                   driver\n * @hw:       ieee802154_hw that command was received by\n * @command:  Octet array of received command\n * @len:      length of the received command\n *\n * Called by the spi driver whenever a SAP command is received, this function\n * will ascertain whether the command is of interest to the network driver and\n * take necessary action.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_net_rx(struct ieee802154_hw *hw, u8 *command, size_t len)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tunsigned long flags;\n\tu8 status;\n\n\tdev_dbg(&priv->spi->dev, \"%s: CmdID = %d\\n\", __func__, command[0]);\n\n\tif (command[0] == SPI_MCPS_DATA_INDICATION) {\n\t\t/* Received data */\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (command[26] == priv->last_dsn) {\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"DSN %d resend received, ignoring...\\n\",\n\t\t\t\tcommand[26]\n\t\t\t);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->last_dsn = command[26];\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn ca8210_skb_rx(hw, len - 2, command + 2);\n\t} else if (command[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tstatus = command[3];\n\t\tif (priv->async_tx_pending) {\n\t\t\treturn ca8210_async_xmit_complete(\n\t\t\t\thw,\n\t\t\t\tcommand[2],\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_skb_tx() - Transmits a given socket buffer using the ca8210\n * @skb:         Socket buffer to transmit\n * @msduhandle:  Data identifier to pass to the 802.15.4 MAC\n * @priv:        Pointer to private data section of target ca8210\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_skb_tx(\n\tstruct sk_buff      *skb,\n\tu8                   msduhandle,\n\tstruct ca8210_priv  *priv\n)\n{\n\tint status;\n\tstruct ieee802154_hdr header = { };\n\tstruct secspec secspec;\n\tunsigned int mac_len;\n\n\tdev_dbg(&priv->spi->dev, \"%s called\\n\", __func__);\n\n\t/* Get addressing info from skb - ieee802154 layer creates a full\n\t * packet\n\t */\n\tmac_len = ieee802154_hdr_peek_addrs(skb, &header);\n\n\tsecspec.security_level = header.sec.level;\n\tsecspec.key_id_mode = header.sec.key_id_mode;\n\tif (secspec.key_id_mode == 2)\n\t\tmemcpy(secspec.key_source, &header.sec.short_src, 4);\n\telse if (secspec.key_id_mode == 3)\n\t\tmemcpy(secspec.key_source, &header.sec.extended_src, 8);\n\tsecspec.key_index = header.sec.key_id;\n\n\t/* Pass to Cascoda API */\n\tstatus =  mcps_data_request(\n\t\theader.source.mode,\n\t\theader.dest.mode,\n\t\theader.dest.pan_id,\n\t\t(union macaddr *)&header.dest.extended_addr,\n\t\tskb->len - mac_len,\n\t\t&skb->data[mac_len],\n\t\tmsduhandle,\n\t\theader.fc.ack_request,\n\t\t&secspec,\n\t\tpriv->spi\n\t);\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_start() - Starts the network driver\n * @hw:  ieee802154_hw of ca8210 being started\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_start(struct ieee802154_hw *hw)\n{\n\tint status;\n\tu8 rx_on_when_idle;\n\tu8 lqi_threshold = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tpriv->last_dsn = -1;\n\t/* Turn receiver on when idle for now just to test rx */\n\trx_on_when_idle = 1;\n\tstatus = mlme_set_request_sync(\n\t\tMAC_RX_ON_WHEN_IDLE,\n\t\t0,\n\t\t1,\n\t\t&rx_on_when_idle,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting rx_on_when_idle failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = hwme_set_request_sync(\n\t\tHWME_LQILIMIT,\n\t\t1,\n\t\t&lqi_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting lqilimit failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_stop() - Stops the network driver\n * @hw:  ieee802154_hw of ca8210 being stopped\n *\n * Return: 0 or linux error code\n */\nstatic void ca8210_stop(struct ieee802154_hw *hw)\n{\n}\n\n/**\n * ca8210_xmit_async() - Asynchronously transmits a given socket buffer using\n *                       the ca8210\n * @hw:   ieee802154_hw of ca8210 to transmit from\n * @skb:  Socket buffer to transmit\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_xmit_async(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"calling %s\\n\", __func__);\n\n\tpriv->tx_skb = skb;\n\tpriv->async_tx_pending = true;\n\tstatus = ca8210_skb_tx(skb, priv->nextmsduhandle, priv);\n\treturn status;\n}\n\n/**\n * ca8210_get_ed() - Returns the measured energy on the current channel at this\n *                   instant in time\n * @hw:     ieee802154_hw of target ca8210\n * @level:  Measured Energy Detect level\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_get_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tu8 lenvar;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\treturn link_to_linux_err(\n\t\thwme_get_request_sync(HWME_EDVALUE, &lenvar, level, priv->spi)\n\t);\n}\n\n/**\n * ca8210_set_channel() - Sets the current operating 802.15.4 channel of the\n *                        ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @page:     Channel page to set\n * @channel:  Channel number to set\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_channel(\n\tstruct ieee802154_hw  *hw,\n\tu8                     page,\n\tu8                     channel\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CURRENT_CHANNEL,\n\t\t0,\n\t\t1,\n\t\t&channel,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting channel, MLME-SET.confirm status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_hw_addr_filt() - Sets the address filtering parameters of the\n *                             ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @filt:     Filtering parameters\n * @changed:  Bitmap representing which parameters to change\n *\n * Effectively just sets the actual addressing information identifying this node\n * as all filtering is performed by the ca8210 as detailed in the IEEE 802.15.4\n * 2006 specification.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_hw_addr_filt(\n\tstruct ieee802154_hw            *hw,\n\tstruct ieee802154_hw_addr_filt  *filt,\n\tunsigned long                    changed\n)\n{\n\tu8 status = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_PAN_ID,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->pan_id, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting pan id, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_SHORT_ADDRESS,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->short_addr, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting short address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tNS_IEEE_ADDRESS,\n\t\t\t0,\n\t\t\t8,\n\t\t\t&filt->ieee_addr,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting ieee address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\t/* TODO: Should use MLME_START to set coord bit? */\n\treturn 0;\n}\n\n/**\n * ca8210_set_tx_power() - Sets the transmit power of the ca8210\n * @hw:   ieee802154_hw of target ca8210\n * @mbm:  Transmit power in mBm (dBm*100)\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_tx_power(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tmbm /= 100;\n\treturn link_to_linux_err(\n\t\tmlme_set_request_sync(PHY_TRANSMIT_POWER, 0, 1, &mbm, priv->spi)\n\t);\n}\n\n/**\n * ca8210_set_cca_mode() - Sets the clear channel assessment mode of the ca8210\n * @hw:   ieee802154_hw of target ca8210\n * @cca:  CCA mode to set\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_cca_mode(\n\tstruct ieee802154_hw       *hw,\n\tconst struct wpan_phy_cca  *cca\n)\n{\n\tu8 status;\n\tu8 cca_mode;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tcca_mode = cca->mode & 3;\n\tif (cca_mode == 3 && cca->opt == NL802154_CCA_OPT_ENERGY_CARRIER_OR) {\n\t\t/* cca_mode 0 == CS OR ED, 3 == CS AND ED */\n\t\tcca_mode = 0;\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CCA_MODE,\n\t\t0,\n\t\t1,\n\t\t&cca_mode,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting cca mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_cca_ed_level() - Sets the CCA ED level of the ca8210\n * @hw:     ieee802154_hw of target ca8210\n * @level:  ED level to set (in mbm)\n *\n * Sets the minimum threshold of measured energy above which the ca8210 will\n * back off and retry a transmission.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_cca_ed_level(struct ieee802154_hw *hw, s32 level)\n{\n\tu8 status;\n\tu8 ed_threshold = (level / 100) * 2 + 256;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = hwme_set_request_sync(\n\t\tHWME_EDTHRESHOLD,\n\t\t1,\n\t\t&ed_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting ed threshold, HWME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_csma_params() - Sets the CSMA parameters of the ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @min_be:   Minimum backoff exponent when backing off a transmission\n * @max_be:   Maximum backoff exponent when backing off a transmission\n * @retries:  Number of times to retry after backing off\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_csma_params(\n\tstruct ieee802154_hw  *hw,\n\tu8                     min_be,\n\tu8                     max_be,\n\tu8                     retries\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(MAC_MIN_BE, 0, 1, &min_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting min be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(MAC_MAX_BE, 0, 1, &max_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_CSMA_BACKOFFS,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max csma backoffs, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n/**\n * ca8210_set_frame_retries() - Sets the maximum frame retries of the ca8210\n * @hw:       ieee802154_hw of target ca8210\n * @retries:  Number of retries\n *\n * Sets the number of times to retry a transmission if no acknowledgment was\n * was received from the other end when one was requested.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_FRAME_RETRIES,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting frame retries, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic int ca8210_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_PROMISCUOUS_MODE,\n\t\t0,\n\t\t1,\n\t\t(const void *)&on,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting promiscuous mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t} else {\n\t\tpriv->promiscuous = on;\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic const struct ieee802154_ops ca8210_phy_ops = {\n\t.start = ca8210_start,\n\t.stop = ca8210_stop,\n\t.xmit_async = ca8210_xmit_async,\n\t.ed = ca8210_get_ed,\n\t.set_channel = ca8210_set_channel,\n\t.set_hw_addr_filt = ca8210_set_hw_addr_filt,\n\t.set_txpower = ca8210_set_tx_power,\n\t.set_cca_mode = ca8210_set_cca_mode,\n\t.set_cca_ed_level = ca8210_set_cca_ed_level,\n\t.set_csma_params = ca8210_set_csma_params,\n\t.set_frame_retries = ca8210_set_frame_retries,\n\t.set_promiscuous_mode = ca8210_set_promiscuous_mode\n};\n\n/* Test/EVBME Interface */\n\n/**\n * ca8210_test_int_open() - Opens the test interface to the userspace\n * @inodp:  inode representation of file interface\n * @filp:   file interface\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_int_open(struct inode *inodp, struct file *filp)\n{\n\tstruct ca8210_priv *priv = inodp->i_private;\n\n\tfilp->private_data = priv;\n\treturn 0;\n}\n\n/**\n * ca8210_test_check_upstream() - Checks a command received from the upstream\n *                                testing interface for required action\n * @buf:        Buffer containing command to check\n * @device_ref: Nondescript pointer to target device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_check_upstream(u8 *buf, void *device_ref)\n{\n\tint ret;\n\tu8 response[CA8210_SPI_BUF_SIZE];\n\n\tif (buf[0] == SPI_MLME_SET_REQUEST) {\n\t\tret = tdme_checkpibattribute(buf[2], buf[4], buf + 5);\n\t\tif (ret) {\n\t\t\tresponse[0]  = SPI_MLME_SET_CONFIRM;\n\t\t\tresponse[1] = 3;\n\t\t\tresponse[2] = MAC_INVALID_PARAMETER;\n\t\t\tresponse[3] = buf[2];\n\t\t\tresponse[4] = buf[3];\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(response, 5, device_ref);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (buf[0] == SPI_MLME_ASSOCIATE_REQUEST) {\n\t\treturn tdme_channelinit(buf[2], device_ref);\n\t} else if (buf[0] == SPI_MLME_START_REQUEST) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_MLME_SET_REQUEST) &&\n\t\t(buf[2] == PHY_CURRENT_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[5], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_TDME_SET_REQUEST) &&\n\t\t(buf[2] == TDME_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(CA8210_MAC_WORKAROUNDS) &&\n\t\t(buf[0] == SPI_MLME_RESET_REQUEST) &&\n\t\t(buf[2] == 1)\n\t) {\n\t\t/* reset COORD Bit for Channel Filtering as Coordinator */\n\t\treturn tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\treturn 0;\n} /* End of EVBMECheckSerialCommand() */\n\n/**\n * ca8210_test_int_user_write() - Called by a process in userspace to send a\n *                                message to the ca8210 drivers\n * @filp:    file interface\n * @in_buf:  Buffer containing message to write\n * @len:     length of message\n * @off:     file offset\n *\n * Return: 0 or linux error code\n */\nstatic ssize_t ca8210_test_int_user_write(\n\tstruct file        *filp,\n\tconst char __user  *in_buf,\n\tsize_t              len,\n\tloff_t             *off\n)\n{\n\tint ret;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tu8 command[CA8210_SPI_BUF_SIZE];\n\n\tmemset(command, SPI_IDLE, 6);\n\tif (len > CA8210_SPI_BUF_SIZE || len < 2) {\n\t\tdev_warn(\n\t\t\t&priv->spi->dev,\n\t\t\t\"userspace requested erroneous write length (%zu)\\n\",\n\t\t\tlen\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = copy_from_user(command, in_buf, len);\n\tif (ret) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%d bytes could not be copied from userspace\\n\",\n\t\t\tret\n\t\t);\n\t\treturn -EIO;\n\t}\n\tif (len != command[1] + 2) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"write len does not match packet length field\\n\"\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = ca8210_test_check_upstream(command, priv->spi);\n\tif (ret == 0) {\n\t\tret = ca8210_spi_exchange(\n\t\t\tcommand,\n\t\t\tcommand[1] + 2,\n\t\t\tNULL,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (ret < 0) {\n\t\t\t/* effectively 0 bytes were written successfully */\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi exchange failed\\n\"\n\t\t\t);\n\t\t\treturn ret;\n\t\t}\n\t\tif (command[0] & SPI_SYN)\n\t\t\tpriv->sync_down++;\n\t}\n\n\treturn len;\n}\n\n/**\n * ca8210_test_int_user_read() - Called by a process in userspace to read a\n *                               message from the ca8210 drivers\n * @filp:  file interface\n * @buf:   Buffer to write message to\n * @len:   length of message to read (ignored)\n * @offp:  file offset\n *\n * If the O_NONBLOCK flag was set when opening the file then this function will\n * not block, i.e. it will return if the fifo is empty. Otherwise the function\n * will block, i.e. wait until new data arrives.\n *\n * Return: number of bytes read\n */\nstatic ssize_t ca8210_test_int_user_read(\n\tstruct file  *filp,\n\tchar __user  *buf,\n\tsize_t        len,\n\tloff_t       *offp\n)\n{\n\tint i, cmdlen;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tunsigned char *fifo_buffer;\n\tunsigned long bytes_not_copied;\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\t/* Non-blocking mode */\n\t\tif (kfifo_is_empty(&priv->test.up_fifo))\n\t\t\treturn 0;\n\t} else {\n\t\t/* Blocking mode */\n\t\twait_event_interruptible(\n\t\t\tpriv->test.readq,\n\t\t\t!kfifo_is_empty(&priv->test.up_fifo)\n\t\t);\n\t}\n\n\tif (kfifo_out(&priv->test.up_fifo, &fifo_buffer, 4) != 4) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"test_interface: Wrong number of elements popped from upstream fifo\\n\"\n\t\t);\n\t\treturn 0;\n\t}\n\tcmdlen = fifo_buffer[1];\n\tbytes_not_copied = cmdlen + 2;\n\n\tbytes_not_copied = copy_to_user(buf, fifo_buffer, bytes_not_copied);\n\tif (bytes_not_copied > 0) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%lu bytes could not be copied to user space!\\n\",\n\t\t\tbytes_not_copied\n\t\t);\n\t}\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Cmd len = %d\\n\", cmdlen);\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Read\\n\");\n\tfor (i = 0; i < cmdlen + 2; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", fifo_buffer[i]);\n\n\tkfree(fifo_buffer);\n\n\treturn cmdlen + 2;\n}\n\n/**\n * ca8210_test_int_ioctl() - Called by a process in userspace to enact an\n *                           arbitrary action\n * @filp:        file interface\n * @ioctl_num:   which action to enact\n * @ioctl_param: arbitrary parameter for the action\n *\n * Return: status\n */\nstatic long ca8210_test_int_ioctl(\n\tstruct file *filp,\n\tunsigned int ioctl_num,\n\tunsigned long ioctl_param\n)\n{\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tswitch (ioctl_num) {\n\tcase CA8210_IOCTL_HARD_RESET:\n\t\tca8210_reset_send(priv->spi, ioctl_param);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * ca8210_test_int_poll() - Called by a process in userspace to determine which\n *                          actions are currently possible for the file\n * @filp:   file interface\n * @ptable: poll table\n *\n * Return: set of poll return flags\n */\nstatic __poll_t ca8210_test_int_poll(\n\tstruct file *filp,\n\tstruct poll_table_struct *ptable\n)\n{\n\t__poll_t return_flags = 0;\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tpoll_wait(filp, &priv->test.readq, ptable);\n\tif (!kfifo_is_empty(&priv->test.up_fifo))\n\t\treturn_flags |= (EPOLLIN | EPOLLRDNORM);\n\tif (wait_event_interruptible(\n\t\tpriv->test.readq,\n\t\t!kfifo_is_empty(&priv->test.up_fifo))) {\n\t\treturn EPOLLERR;\n\t}\n\treturn return_flags;\n}\n\nstatic const struct file_operations test_int_fops = {\n\t.read =           ca8210_test_int_user_read,\n\t.write =          ca8210_test_int_user_write,\n\t.open =           ca8210_test_int_open,\n\t.release =        NULL,\n\t.unlocked_ioctl = ca8210_test_int_ioctl,\n\t.poll =           ca8210_test_int_poll\n};\n\n/* Init/Deinit */\n\n/**\n * ca8210_get_platform_data() - Populate a ca8210_platform_data object\n * @spi_device:  Pointer to ca8210 spi device object to get data for\n * @pdata:       Pointer to ca8210_platform_data object to populate\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_get_platform_data(\n\tstruct spi_device *spi_device,\n\tstruct ca8210_platform_data *pdata\n)\n{\n\tint ret = 0;\n\n\tif (!spi_device->dev.of_node)\n\t\treturn -EINVAL;\n\n\tpdata->extclockenable = of_property_read_bool(\n\t\tspi_device->dev.of_node,\n\t\t\"extclock-enable\"\n\t);\n\tif (pdata->extclockenable) {\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-freq\",\n\t\t\t&pdata->extclockfreq\n\t\t);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-gpio\",\n\t\t\t&pdata->extclockgpio\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_config_extern_clk() - Configure the external clock provided by the\n *                              ca8210\n * @pdata:  Pointer to ca8210_platform_data containing clock parameters\n * @spi:    Pointer to target ca8210 spi device\n * @on:\t    True to turn the clock on, false to turn off\n *\n * The external clock is configured with a frequency and output pin taken from\n * the platform data.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_config_extern_clk(\n\tstruct ca8210_platform_data *pdata,\n\tstruct spi_device *spi,\n\tbool on\n)\n{\n\tu8 clkparam[2];\n\n\tif (on) {\n\t\tdev_info(&spi->dev, \"Switching external clock on\\n\");\n\t\tswitch (pdata->extclockfreq) {\n\t\tcase SIXTEEN_MHZ:\n\t\t\tclkparam[0] = 1;\n\t\t\tbreak;\n\t\tcase EIGHT_MHZ:\n\t\t\tclkparam[0] = 2;\n\t\t\tbreak;\n\t\tcase FOUR_MHZ:\n\t\t\tclkparam[0] = 3;\n\t\t\tbreak;\n\t\tcase TWO_MHZ:\n\t\t\tclkparam[0] = 4;\n\t\t\tbreak;\n\t\tcase ONE_MHZ:\n\t\t\tclkparam[0] = 5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_crit(&spi->dev, \"Invalid extclock-freq\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclkparam[1] = pdata->extclockgpio;\n\t} else {\n\t\tdev_info(&spi->dev, \"Switching external clock off\\n\");\n\t\tclkparam[0] = 0; /* off */\n\t\tclkparam[1] = 0;\n\t}\n\treturn link_to_linux_err(\n\t\thwme_set_request_sync(HWME_SYSCLKOUT, 2, clkparam, spi)\n\t);\n}\n\n/**\n * ca8210_register_ext_clock() - Register ca8210's external clock with kernel\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_register_ext_clock(struct spi_device *spi)\n{\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\tint ret = 0;\n\n\tif (!np)\n\t\treturn -EFAULT;\n\n\tpriv->clk = clk_register_fixed_rate(\n\t\t&spi->dev,\n\t\tnp->name,\n\t\tNULL,\n\t\t0,\n\t\tpdata->extclockfreq\n\t);\n\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_crit(&spi->dev, \"Failed to register external clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\tret = of_clk_add_provider(np, of_clk_src_simple_get, priv->clk);\n\tif (ret) {\n\t\tclk_unregister(priv->clk);\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Failed to register external clock as clock provider\\n\"\n\t\t);\n\t} else {\n\t\tdev_info(&spi->dev, \"External clock set as clock provider\\n\");\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_unregister_ext_clock() - Unregister ca8210's external clock with\n *                                 kernel\n * @spi:  Pointer to target ca8210 spi device\n */\nstatic void ca8210_unregister_ext_clock(struct spi_device *spi)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\n\tif (!priv->clk)\n\t\treturn\n\n\tof_clk_del_provider(spi->dev.of_node);\n\tclk_unregister(priv->clk);\n\tdev_info(&spi->dev, \"External clock unregistered\\n\");\n}\n\n/**\n * ca8210_reset_init() - Initialise the reset input to the ca8210\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_reset_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_reset = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"reset-gpio\",\n\t\t0\n\t);\n\n\tret = gpio_direction_output(pdata->gpio_reset, 1);\n\tif (ret < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Reset GPIO %d did not set to output mode\\n\",\n\t\t\tpdata->gpio_reset\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_interrupt_init() - Initialise the irq output from the ca8210\n * @spi:  Pointer to target ca8210 spi device\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_interrupt_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_irq = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"irq-gpio\",\n\t\t0\n\t);\n\n\tpdata->irq_id = gpio_to_irq(pdata->gpio_irq);\n\tif (pdata->irq_id < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Could not get irq for gpio pin %d\\n\",\n\t\t\tpdata->gpio_irq\n\t\t);\n\t\tgpio_free(pdata->gpio_irq);\n\t\treturn pdata->irq_id;\n\t}\n\n\tret = request_irq(\n\t\tpdata->irq_id,\n\t\tca8210_interrupt_handler,\n\t\tIRQF_TRIGGER_FALLING,\n\t\t\"ca8210-irq\",\n\t\tspi_get_drvdata(spi)\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"request_irq %d failed\\n\", pdata->irq_id);\n\t\tgpio_unexport(pdata->gpio_irq);\n\t\tgpio_free(pdata->gpio_irq);\n\t}\n\n\treturn ret;\n}\n\n/**\n * ca8210_dev_com_init() - Initialise the spi communication component\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_dev_com_init(struct ca8210_priv *priv)\n{\n\tpriv->mlme_workqueue = alloc_ordered_workqueue(\n\t\t\"MLME work queue\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->mlme_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of mlme_workqueue failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->irq_workqueue = alloc_ordered_workqueue(\n\t\t\"ca8210 irq worker\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->irq_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of irq_workqueue failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_dev_com_clear() - Deinitialise the spi communication component\n * @priv:  Pointer to private data structure\n */\nstatic void ca8210_dev_com_clear(struct ca8210_priv *priv)\n{\n\tflush_workqueue(priv->mlme_workqueue);\n\tdestroy_workqueue(priv->mlme_workqueue);\n\tflush_workqueue(priv->irq_workqueue);\n\tdestroy_workqueue(priv->irq_workqueue);\n}\n\n#define CA8210_MAX_TX_POWERS (9)\nstatic const s32 ca8210_tx_powers[CA8210_MAX_TX_POWERS] = {\n\t800, 700, 600, 500, 400, 300, 200, 100, 0\n};\n\n#define CA8210_MAX_ED_LEVELS (21)\nstatic const s32 ca8210_ed_levels[CA8210_MAX_ED_LEVELS] = {\n\t-10300, -10250, -10200, -10150, -10100, -10050, -10000, -9950, -9900,\n\t-9850, -9800, -9750, -9700, -9650, -9600, -9550, -9500, -9450, -9400,\n\t-9350, -9300\n};\n\n/**\n * ca8210_hw_setup() - Populate the ieee802154_hw phy attributes with the\n *                     ca8210's defaults\n * @ca8210_hw:  Pointer to ieee802154_hw to populate\n */\nstatic void ca8210_hw_setup(struct ieee802154_hw *ca8210_hw)\n{\n\t/* Support channels 11-26 */\n\tca8210_hw->phy->supported.channels[0] = CA8210_VALID_CHANNELS;\n\tca8210_hw->phy->supported.tx_powers_size = CA8210_MAX_TX_POWERS;\n\tca8210_hw->phy->supported.tx_powers = ca8210_tx_powers;\n\tca8210_hw->phy->supported.cca_ed_levels_size = CA8210_MAX_ED_LEVELS;\n\tca8210_hw->phy->supported.cca_ed_levels = ca8210_ed_levels;\n\tca8210_hw->phy->current_channel = 18;\n\tca8210_hw->phy->current_page = 0;\n\tca8210_hw->phy->transmit_power = 800;\n\tca8210_hw->phy->cca.mode = NL802154_CCA_ENERGY_CARRIER;\n\tca8210_hw->phy->cca.opt = NL802154_CCA_OPT_ENERGY_CARRIER_AND;\n\tca8210_hw->phy->cca_ed_level = -9800;\n\tca8210_hw->phy->symbol_duration = 16;\n\tca8210_hw->phy->lifs_period = 40;\n\tca8210_hw->phy->sifs_period = 12;\n\tca8210_hw->flags =\n\t\tIEEE802154_HW_AFILT |\n\t\tIEEE802154_HW_OMIT_CKSUM |\n\t\tIEEE802154_HW_FRAME_RETRIES |\n\t\tIEEE802154_HW_PROMISCUOUS |\n\t\tIEEE802154_HW_CSMA_PARAMS;\n\tca8210_hw->phy->flags =\n\t\tWPAN_PHY_FLAG_TXPOWER |\n\t\tWPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\tWPAN_PHY_FLAG_CCA_MODE;\n}\n\n/**\n * ca8210_test_interface_init() - Initialise the test file interface\n * @priv:  Pointer to private data structure\n *\n * Provided as an alternative to the standard linux network interface, the test\n * interface exposes a file in the filesystem (ca8210_test) that allows\n * 802.15.4 SAP Commands and Cascoda EVBME commands to be sent directly to\n * the stack.\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_test_interface_init(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\tchar node_name[32];\n\n\tsnprintf(\n\t\tnode_name,\n\t\tsizeof(node_name),\n\t\t\"ca8210@%d_%d\",\n\t\tpriv->spi->master->bus_num,\n\t\tpriv->spi->chip_select\n\t);\n\n\ttest->ca8210_dfs_spi_int = debugfs_create_file(\n\t\tnode_name,\n\t\t0600, /* S_IRUSR | S_IWUSR */\n\t\tNULL,\n\t\tpriv,\n\t\t&test_int_fops\n\t);\n\tif (IS_ERR(test->ca8210_dfs_spi_int)) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Error %ld when creating debugfs node\\n\",\n\t\t\tPTR_ERR(test->ca8210_dfs_spi_int)\n\t\t);\n\t\treturn PTR_ERR(test->ca8210_dfs_spi_int);\n\t}\n\tdebugfs_create_symlink(\"ca8210\", NULL, node_name);\n\tinit_waitqueue_head(&test->readq);\n\treturn kfifo_alloc(\n\t\t&test->up_fifo,\n\t\tCA8210_TEST_INT_FIFO_SIZE,\n\t\tGFP_KERNEL\n\t);\n}\n\n/**\n * ca8210_test_interface_clear() - Deinitialise the test file interface\n * @priv:  Pointer to private data structure\n */\nstatic void ca8210_test_interface_clear(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\n\tdebugfs_remove(test->ca8210_dfs_spi_int);\n\tkfifo_free(&test->up_fifo);\n\tdev_info(&priv->spi->dev, \"Test interface removed\\n\");\n}\n\n/**\n * ca8210_remove() - Shut down a ca8210 upon being disconnected\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_remove(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ca8210_platform_data *pdata;\n\n\tdev_info(&spi_device->dev, \"Removing ca8210\\n\");\n\n\tpdata = spi_device->dev.platform_data;\n\tif (pdata) {\n\t\tif (pdata->extclockenable) {\n\t\t\tca8210_unregister_ext_clock(spi_device);\n\t\t\tca8210_config_extern_clk(pdata, spi_device, 0);\n\t\t}\n\t\tfree_irq(pdata->irq_id, spi_device->dev.driver_data);\n\t\tkfree(pdata);\n\t\tspi_device->dev.platform_data = NULL;\n\t}\n\t/* get spi_device private data */\n\tpriv = spi_get_drvdata(spi_device);\n\tif (priv) {\n\t\tdev_info(\n\t\t\t&spi_device->dev,\n\t\t\t\"sync_down = %d, sync_up = %d\\n\",\n\t\t\tpriv->sync_down,\n\t\t\tpriv->sync_up\n\t\t);\n\t\tca8210_dev_com_clear(spi_device->dev.driver_data);\n\t\tif (priv->hw) {\n\t\t\tif (priv->hw_registered)\n\t\t\t\tieee802154_unregister_hw(priv->hw);\n\t\t\tieee802154_free_hw(priv->hw);\n\t\t\tpriv->hw = NULL;\n\t\t\tdev_info(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"Unregistered & freed ieee802154_hw.\\n\"\n\t\t\t);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS))\n\t\t\tca8210_test_interface_clear(priv);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ca8210_probe() - Set up a connected ca8210 upon being detected by the system\n * @priv:  Pointer to private data structure\n *\n * Return: 0 or linux error code\n */\nstatic int ca8210_probe(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ieee802154_hw *hw;\n\tstruct ca8210_platform_data *pdata;\n\tint ret;\n\n\tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n\n\t/* allocate ieee802154_hw and private data */\n\thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->spi = spi_device;\n\thw->parent = &spi_device->dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->async_tx_pending = false;\n\tpriv->hw_registered = false;\n\tpriv->sync_up = 0;\n\tpriv->sync_down = 0;\n\tpriv->promiscuous = false;\n\tpriv->retries = 0;\n\tinit_completion(&priv->ca8210_is_awake);\n\tinit_completion(&priv->spi_transfer_complete);\n\tinit_completion(&priv->sync_exchange_complete);\n\tspi_set_drvdata(priv->spi, priv);\n\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n\t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n\t\tca8210_test_interface_init(priv);\n\t} else {\n\t\tcascoda_api_upstream = NULL;\n\t}\n\tca8210_hw_setup(hw);\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv->spi->dev.platform_data = pdata;\n\tret = ca8210_get_platform_data(priv->spi, pdata);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_dev_com_init(priv);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n\t\tgoto error;\n\t}\n\tret = ca8210_reset_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_interrupt_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmsleep(100);\n\n\tca8210_reset_send(priv->spi, 1);\n\n\tret = tdme_chipinit(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (pdata->extclockenable) {\n\t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t\tret = ca8210_register_ext_clock(priv->spi);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->hw_registered = true;\n\n\treturn 0;\nerror:\n\tmsleep(100); /* wait for pending spi transfers to complete */\n\tca8210_remove(spi_device);\n\treturn link_to_linux_err(ret);\n}\n\nstatic const struct of_device_id ca8210_of_ids[] = {\n\t{.compatible = \"cascoda,ca8210\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ca8210_of_ids);\n\nstatic struct spi_driver ca8210_spi_driver = {\n\t.driver = {\n\t\t.name =                 DRIVER_NAME,\n\t\t.owner =                THIS_MODULE,\n\t\t.of_match_table =       of_match_ptr(ca8210_of_ids),\n\t},\n\t.probe  =                       ca8210_probe,\n\t.remove =                       ca8210_remove\n};\n\nmodule_spi_driver(ca8210_spi_driver);\n\nMODULE_AUTHOR(\"Harry Morris <h.morris@cascoda.com>\");\nMODULE_DESCRIPTION(\"CA-8210 SoftMAC driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(\"1.0\");\n"], "filenames": ["drivers/net/ieee802154/ca8210.c"], "buggy_code_start_loc": [3154], "buggy_code_end_loc": [3161], "fixing_code_start_loc": [3155], "fixing_code_end_loc": [3160], "type": "CWE-401", "message": "A memory leak in the ca8210_probe() function in drivers/net/ieee802154/ca8210.c in the Linux kernel before 5.3.8 allows attackers to cause a denial of service (memory consumption) by triggering ca8210_get_platform_data() failures, aka CID-6402939ec86e.", "other": {"cve": {"id": "CVE-2019-19075", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.343", "lastModified": "2023-01-17T21:32:01.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the ca8210_probe() function in drivers/net/ieee802154/ca8210.c in the Linux kernel before 5.3.8 allows attackers to cause a denial of service (memory consumption) by triggering ca8210_get_platform_data() failures, aka CID-6402939ec86e."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n ca8210_probe() en el archivo drivers/net/ieee802154/ca8210.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.8, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n la funci\u00f3n ca8210_get_platform_data(), tambi\u00e9n se conoce como CID-6402939ec86e."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.12", "versionEndExcluding": "4.14.151", "matchCriteriaId": "B2D3E0A7-4B52-4E4A-9F83-139865406927"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.81", "matchCriteriaId": "AD6A6AF5-0D02-4C31-8D58-6F1E761A5EDA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.3.8", "matchCriteriaId": "6565D881-E407-4758-A217-2857C6A12DC5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6402939ec86eaf226c8b8ae00ed983936b164908", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4208-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4210-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6402939ec86eaf226c8b8ae00ed983936b164908"}}