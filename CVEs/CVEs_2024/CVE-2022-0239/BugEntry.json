{"buggy_code": ["package edu.stanford.nlp.util;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\nimport edu.stanford.nlp.io.IOUtils;\nimport edu.stanford.nlp.util.logging.Redwood;\n\n\n/**\n * Provides some utilities for dealing with XML files, both by properly\n * parsing them and by using the methods of a desperate Perl hacker.\n *\n * @author Teg Grenager\n * @author Grace Muzny\n */\npublic class XMLUtils  {\n\n  /** A logger for this class */\n  private static final Redwood.RedwoodChannels log = Redwood.channels(XMLUtils.class);\n\n  private XMLUtils() {} // only static methods\n\n  public static DocumentBuilderFactory safeDocumentBuilderFactory() {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    try {\n      dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n      dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n      dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n      dbf.setFeature(\"http://apache.org/xml/features/dom/create-entity-ref-nodes\", false);\n      dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    } catch (ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return dbf;\n  }\n    \n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   *\n   * @return List of String text contents of tags.\n   */\n  public static List<String> getTextContentFromTagsFromFile(File f, String tag) {\n    List<String> sents = Generics.newArrayList();\n    try {\n      sents = getTextContentFromTagsFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   * If the text contents contains embedded tags, strips the embedded tags out\n   * of the returned text. E.g., {@code <s>This is a <s>sentence</s> with embedded tags\n   * </s>} would return the list containing [\"This is a sentence with embedded\n   * tags\", \"sentence\"].\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of String text contents of tags.\n   */\n  private static List<String> getTextContentFromTagsFromFileSAXException(\n          File f, String tag) throws SAXException {\n    List<String> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Element element = (Element)nodeList.item(i);\n        String raw = element.getTextContent();\n        StringBuilder builtUp = new StringBuilder();\n        boolean inTag = false;\n        for (int j = 0; j < raw.length(); j++) {\n          if (raw.charAt(j) == '<') {\n            inTag = true;\n          }\n          if (!inTag) {\n            builtUp.append(raw.charAt(j));\n          }\n          if (raw.charAt(j) == '>') {\n            inTag = false;\n          }\n        }\n        sents.add(builtUp.toString());\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   *\n   * @return List of String text contents of tags.\n   */\n  public static List<Element> getTagElementsFromFile(File f, String tag) {\n    List<Element> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementsFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   * If the text contents contains embedded tags, strips the embedded tags out\n   * of the returned text. E.g., {@code <s>This is a <s>sentence</s> with embedded tags\n   * </s>} would return the list containing [\"This is a sentence with embedded\n   * tags\", \"sentence\"].\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of String text contents of tags.\n   */\n  private static List<Element> getTagElementsFromFileSAXException(\n          File f, String tag) throws SAXException {\n    List<Element> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Element element = (Element)nodeList.item(i);\n        sents.add(element);\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the two previous siblings and two next siblings.\n   *\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFile(File f, String tag) {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementTriplesFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the previous and next siblings up to max numIncludedSiblings.\n   *\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileNumBounded(File f,\n                                                                                             String tag,\n                                                                                             int num) {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementTriplesFromFileNumBoundedSAXException(f, tag, num);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the two previous siblings and two next siblings.\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileSAXException(\n      File f, String tag) throws SAXException {\n    return  getTagElementTriplesFromFileNumBoundedSAXException(f, tag, 2);\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the previous and next siblings up to max numIncludedSiblings.\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileNumBoundedSAXException(\n      File f, String tag, int numIncludedSiblings) throws SAXException {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Node prevNode = nodeList.item(i).getPreviousSibling();\n        String prev = \"\";\n        int count = 0;\n        while (prevNode != null && count <= numIncludedSiblings) {\n          prev = prevNode.getTextContent() + prev;\n          prevNode = prevNode.getPreviousSibling();\n          count++;\n        }\n\n        Node nextNode = nodeList.item(i).getNextSibling();\n        String next = \"\";\n        count = 0;\n        while (nextNode != null && count <= numIncludedSiblings) {\n          next = next + nextNode.getTextContent();\n          nextNode = nextNode.getNextSibling();\n          count++;\n        }\n        Element element = (Element)nodeList.item(i);\n        Triple<String, Element, String> t = new Triple<>(prev, element, next);\n        sents.add(t);\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n\n  /**\n   * Returns a non-validating XML parser. The parser ignores both DTDs and XSDs.\n   *\n   * @return An XML parser in the form of a DocumentBuilder\n   */\n  public static DocumentBuilder getXmlParser() {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      dbf.setValidating(false);\n\n      //Disable DTD loading and validation\n      //See http://stackoverflow.com/questions/155101/make-documentbuilder-parse-ignore-dtd-references\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }\n\n  /**\n   * Returns a validating XML parser given an XSD (not DTD!).\n   *\n   * @param schemaFile File wit hXML schema\n   * @return An XML parser in the form of a DocumentBuilder\n   */\n  public static DocumentBuilder getValidatingXmlParser(File schemaFile) {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n\n      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n      Schema schema = factory.newSchema(schemaFile);\n      dbf.setSchema(schema);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch (SAXException e) {\n      log.warnf(\"%s: XML parsing exception while loading schema %s\\n\", XMLUtils.class.getName(),schemaFile.getPath());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }\n\n  /**\n   * Block-level HTML tags that are rendered with surrounding line breaks.\n   */\n  private static final Set<String> breakingTags = Generics.newHashSet(Arrays.asList(new String[] {\"blockquote\", \"br\", \"div\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"tr\", \"td\"}));\n\n  /**\n   * @param r       the reader to read the XML/HTML from\n   * @param mapBack a List of Integers mapping the positions in the result buffer\n   *                to positions in the original Reader, will be cleared on receipt\n   * @return the String containing the resulting text\n   */\n  public static String stripTags(Reader r, List<Integer> mapBack, boolean markLineBreaks) {\n    if (mapBack != null) {\n      mapBack.clear(); // just in case it has something in it!\n    }\n    StringBuilder result = new StringBuilder();\n    try {\n      int position = 0;\n      do {\n        String text = XMLUtils.readUntilTag(r);\n        if (text.length() > 0) {\n          // add offsets to the map back\n          for (int i = 0; i < text.length(); i++) {\n            result.append(text.charAt(i));\n            if (mapBack != null) {\n              mapBack.add(Integer.valueOf(position + i));\n            }\n          }\n          position += text.length();\n        }\n        //        System.err.println(position + \" got text: \" + text);\n        String tag = XMLUtils.readTag(r);\n        if (tag == null) {\n          break;\n        }\n        if (markLineBreaks && XMLUtils.isBreaking(parseTag(tag))) {\n          result.append(\"\\n\");\n          if (mapBack != null) {\n            mapBack.add(Integer.valueOf(-position));\n          }\n        }\n        position += tag.length();\n        //        System.err.println(position + \" got tag: \" + tag);\n      } while (true);\n    } catch (IOException e) {\n      log.warn(\"Error reading string\");\n      log.warn(e);\n    }\n    return result.toString();\n  }\n\n  public static boolean isBreaking(String tag) {\n    return breakingTags.contains(tag);\n  }\n\n  public static boolean isBreaking(XMLTag tag) {\n    return breakingTags.contains(tag.name);\n  }\n\n  /**\n   * Reads all text up to next XML tag and returns it as a String.\n   *\n   * @return the String of the text read, which may be empty.\n   */\n  public static String readUntilTag(Reader r) throws IOException {\n    if (!r.ready()) {\n      return \"\";\n    }\n    StringBuilder b = new StringBuilder();\n    int c = r.read();\n    while (c >= 0 && c != '<') {\n      b.append((char) c);\n      c = r.read();\n    }\n    return b.toString();\n  }\n\n  /**\n   * @return the new XMLTag object, or null if couldn't be created\n   */\n  public static XMLTag readAndParseTag(Reader r) throws IOException {\n    String s = readTag(r);\n    if (s == null) {\n      return null;\n    }\n    XMLTag ret = null;\n    try {\n      ret = new XMLTag(s);\n    } catch (Exception e) {\n      log.warn(\"Failed to handle |\" + s + \"|\");\n    }\n    return ret;\n  }\n\n  // Pattern is reentrant, going by the statement \"many matchers can share the same pattern\"\n  // on the Pattern javadoc.  Therefore, this should be safe as a static final variable.\n  private static final Pattern xmlEscapingPattern = Pattern.compile(\"&.+?;\");\n\n  public static String unescapeStringForXML(String s) {\n    StringBuilder result = new StringBuilder();\n    Matcher m = xmlEscapingPattern.matcher(s);\n    int end = 0;\n    while (m.find()) {\n      int start = m.start();\n      result.append(s, end, start);\n      end = m.end();\n      result.append(translate(s.substring(start, end)));\n    }\n    result.append(s, end, s.length());\n    return result.toString();\n  }\n\n  private static char translate(String s) {\n    switch (s) {\n      case \"&amp;\":\n        return '&';\n      case \"&lt;\":\n      case \"&Lt;\":\n        return '<';\n      case \"&gt;\":\n      case \"&Gt;\":\n        return '>';\n      case \"&quot;\":\n        return '\\\"';\n      case \"&apos;\":\n        return '\\'';\n      case \"&ast;\":\n        return '*';\n      case \"&sharp;\":\n        return '\\u266F';\n      case \"&equals;\":\n        return '=';\n      case \"&nbsp;\":\n        return (char) 0xA0;\n      case \"&iexcl;\":\n        return (char) 0xA1;\n      case \"&cent;\":\n      case \"&shilling;\":\n        return (char) 0xA2;\n      case \"&pound;\":\n        return (char) 0xA3;\n      case \"&curren;\":\n        return (char) 0xA4;\n      case \"&yen;\":\n        return (char) 0xA5;\n      case \"&brvbar;\":\n        return (char) 0xA6;\n      case \"&sect;\":\n        return (char) 0xA7;\n      case \"&uml;\":\n        return (char) 0xA8;\n      case \"&copy;\":\n        return (char) 0xA9;\n      case \"&ordf;\":\n        return (char) 0xAA;\n      case \"&laquo; \":\n        return (char) 0xAB;\n      case \"&not;\":\n        return (char) 0xAC;\n      case \"&shy; \":\n        return (char) 0xAD;\n      case \"&reg;\":\n        return (char) 0xAE;\n      case \"&macr;\":\n        return (char) 0xAF;\n      case \"&deg;\":\n        return (char) 0xB0;\n      case \"&plusmn;\":\n        return (char) 0xB1;\n      case \"&sup2;\":\n        return (char) 0xB2;\n      case \"&sup3;\":\n        return (char) 0xB3;\n      case \"&acute;\":\n        return (char) 0xB4;\n      case \"&micro;\":\n        return (char) 0xB5;\n      case \"&middot;\":\n        return (char) 0xB7;\n      case \"&cedil;\":\n        return (char) 0xB8;\n      case \"&sup1;\":\n        return (char) 0xB9;\n      case \"&ordm;\":\n        return (char) 0xBA;\n      case \"&raquo;\":\n        return (char) 0xBB;\n      case \"&frac14; \":\n        return (char) 0xBC;\n      case \"&frac12;\":\n        return (char) 0xBD;\n      case \"&frac34; \":\n        return (char) 0xBE;\n      case \"&iquest;\":\n        return (char) 0xBF;\n      case \"&Agrave;\":\n        return (char) 0xC0;\n      case \"&Aacute;\":\n        return (char) 0xC1;\n      case \"&Acirc;\":\n        return (char) 0xC2;\n      case \"&Atilde;\":\n        return (char) 0xC3;\n      case \"&Auml;\":\n        return (char) 0xC4;\n      case \"&Aring;\":\n        return (char) 0xC5;\n      case \"&AElig;\":\n        return (char) 0xC6;\n      case \"&Ccedil;\":\n        return (char) 0xC7;\n      case \"&Egrave;\":\n        return (char) 0xC8;\n      case \"&Eacute;\":\n        return (char) 0xC9;\n      case \"&Ecirc;\":\n        return (char) 0xCA;\n      case \"&Euml;\":\n        return (char) 0xCB;\n      case \"&Igrave;\":\n        return (char) 0xCC;\n      case \"&Iacute;\":\n        return (char) 0xCD;\n      case \"&Icirc;\":\n        return (char) 0xCE;\n      case \"&Iuml;\":\n        return (char) 0xCF;\n      case \"&ETH;\":\n        return (char) 0xD0;\n      case \"&Ntilde;\":\n        return (char) 0xD1;\n      case \"&Ograve;\":\n        return (char) 0xD2;\n      case \"&Oacute;\":\n        return (char) 0xD3;\n      case \"&Ocirc;\":\n        return (char) 0xD4;\n      case \"&Otilde;\":\n        return (char) 0xD5;\n      case \"&Ouml;\":\n        return (char) 0xD6;\n      case \"&times;\":\n        return (char) 0xD7;\n      case \"&Oslash;\":\n        return (char) 0xD8;\n      case \"&Ugrave;\":\n        return (char) 0xD9;\n      case \"&Uacute;\":\n        return (char) 0xDA;\n      case \"&Ucirc;\":\n        return (char) 0xDB;\n      case \"&Uuml;\":\n        return (char) 0xDC;\n      case \"&Yacute;\":\n        return (char) 0xDD;\n      case \"&THORN;\":\n        return (char) 0xDE;\n      case \"&szlig;\":\n        return (char) 0xDF;\n      case \"&agrave;\":\n        return (char) 0xE0;\n      case \"&aacute;\":\n        return (char) 0xE1;\n      case \"&acirc;\":\n        return (char) 0xE2;\n      case \"&atilde;\":\n        return (char) 0xE3;\n      case \"&auml;\":\n        return (char) 0xE4;\n      case \"&aring;\":\n        return (char) 0xE5;\n      case \"&aelig;\":\n        return (char) 0xE6;\n      case \"&ccedil;\":\n        return (char) 0xE7;\n      case \"&egrave;\":\n        return (char) 0xE8;\n      case \"&eacute;\":\n        return (char) 0xE9;\n      case \"&ecirc;\":\n        return (char) 0xEA;\n      case \"&euml; \":\n        return (char) 0xEB;\n      case \"&igrave;\":\n        return (char) 0xEC;\n      case \"&iacute;\":\n        return (char) 0xED;\n      case \"&icirc;\":\n        return (char) 0xEE;\n      case \"&iuml;\":\n        return 0xEF;\n      case \"&eth;\":\n        return (char) 0xF0;\n      case \"&ntilde;\":\n        return (char) 0xF1;\n      case \"&ograve;\":\n        return (char) 0xF2;\n      case \"&oacute;\":\n        return (char) 0xF3;\n      case \"&ocirc;\":\n        return (char) 0xF4;\n      case \"&otilde;\":\n        return (char) 0xF5;\n      case \"&ouml;\":\n        return (char) 0xF6;\n      case \"&divide;\":\n        return (char) 0xF7;\n      case \"&oslash;\":\n        return (char) 0xF8;\n      case \"&ugrave;\":\n        return (char) 0xF9;\n      case \"&uacute;\":\n        return (char) 0xFA;\n      case \"&ucirc;\":\n        return (char) 0xFB;\n      case \"&uuml;\":\n        return (char) 0xFC;\n      case \"&yacute;\":\n        return (char) 0xFD;\n      case \"&thorn;\":\n        return (char) 0xFE;\n      case \"&yuml;\":\n        return (char) 0xFF;\n      case \"&OElig;\":\n        return (char) 0x152;\n      case \"&oelig;\":\n        return (char) 0x153;\n      case \"&Scaron;\":\n        return (char) 0x160;\n      case \"&scaron;\":\n        return (char) 0x161;\n      case \"&Yuml;\":\n        return (char) 0x178;\n      case \"&circ;\":\n        return (char) 0x2C6;\n      case \"&tilde;\":\n        return (char) 0x2DC;\n      case \"&lrm;\":\n        return (char) 0x200E;\n      case \"&rlm;\":\n        return (char) 0x200F;\n      case \"&ndash;\":\n        return (char) 0x2013;\n      case \"&mdash;\":\n        return (char) 0x2014;\n      case \"&lsquo;\":\n        return (char) 0x2018;\n      case \"&rsquo;\":\n        return (char) 0x2019;\n      case \"&sbquo;\":\n        return (char) 0x201A;\n      case \"&ldquo;\":\n      case \"&bquo;\":\n      case \"&bq;\":\n        return (char) 0x201C;\n      case \"&rdquo;\":\n      case \"&equo;\":\n        return (char) 0X201D;\n      case \"&bdquo;\":\n        return (char) 0x201E;\n      case \"&sim;\":\n        return (char) 0x223C;\n      case \"&radic;\":\n        return (char) 0x221A;\n      case \"&le;\":\n        return (char) 0x2264;\n      case \"&ge;\":\n        return (char) 0x2265;\n      case \"&larr;\":\n        return (char) 0x2190;\n      case \"&darr;\":\n        return (char) 0x2193;\n      case \"&rarr;\":\n        return (char) 0x2192;\n      case \"&hellip;\":\n        return (char) 0x2026;\n      case \"&prime;\":\n        return (char) 0x2032;\n      case \"&Prime;\":\n      case \"&ins;\":\n        return (char) 0x2033;\n      case \"&trade;\":\n        return (char) 0x2122;\n      case \"&Alpha;\":\n      case \"&Agr;\":\n        return (char) 0x391;\n      case \"&Beta;\":\n      case \"&Bgr;\":\n        return (char) 0x392;\n      case \"&Gamma;\":\n      case \"&Ggr;\":\n        return (char) 0x393;\n      case \"&Delta;\":\n      case \"&Dgr;\":\n        return (char) 0x394;\n      case \"&Epsilon;\":\n      case \"&Egr;\":\n        return (char) 0x395;\n      case \"&Zeta;\":\n      case \"&Zgr;\":\n        return (char) 0x396;\n      case \"&Eta;\":\n        return (char) 0x397;\n      case \"&Theta;\":\n      case \"&THgr;\":\n        return (char) 0x398;\n      case \"&Iota;\":\n      case \"&Igr;\":\n        return (char) 0x399;\n      case \"&Kappa;\":\n      case \"&Kgr;\":\n        return (char) 0x39A;\n      case \"&Lambda;\":\n      case \"&Lgr;\":\n        return (char) 0x39B;\n      case \"&Mu;\":\n      case \"&Mgr;\":\n        return (char) 0x39C;\n      case \"&Nu;\":\n      case \"&Ngr;\":\n        return (char) 0x39D;\n      case \"&Xi;\":\n      case \"&Xgr;\":\n        return (char) 0x39E;\n      case \"&Omicron;\":\n      case \"&Ogr;\":\n        return (char) 0x39F;\n      case \"&Pi;\":\n      case \"&Pgr;\":\n        return (char) 0x3A0;\n      case \"&Rho;\":\n      case \"&Rgr;\":\n        return (char) 0x3A1;\n      case \"&Sigma;\":\n      case \"&Sgr;\":\n        return (char) 0x3A3;\n      case \"&Tau;\":\n      case \"&Tgr;\":\n        return (char) 0x3A4;\n      case \"&Upsilon;\":\n      case \"&Ugr;\":\n        return (char) 0x3A5;\n      case \"&Phi;\":\n      case \"&PHgr;\":\n        return (char) 0x3A6;\n      case \"&Chi;\":\n      case \"&KHgr;\":\n        return (char) 0x3A7;\n      case \"&Psi;\":\n      case \"&PSgr;\":\n        return (char) 0x3A8;\n      case \"&Omega;\":\n      case \"&OHgr;\":\n        return (char) 0x3A9;\n      case \"&alpha;\":\n      case \"&agr;\":\n        return (char) 0x3B1;\n      case \"&beta;\":\n      case \"&bgr;\":\n        return (char) 0x3B2;\n      case \"&gamma;\":\n      case \"&ggr;\":\n        return (char) 0x3B3;\n      case \"&delta;\":\n      case \"&dgr;\":\n        return (char) 0x3B4;\n      case \"&epsilon;\":\n      case \"&egr;\":\n        return (char) 0x3B5;\n      case \"&zeta;\":\n      case \"&zgr;\":\n        return (char) 0x3B6;\n      case \"&eta;\":\n      case \"&eegr;\":\n        return (char) 0x3B7;\n      case \"&theta;\":\n      case \"&thgr;\":\n        return (char) 0x3B8;\n      case \"&iota;\":\n      case \"&igr;\":\n        return (char) 0x3B9;\n      case \"&kappa;\":\n      case \"&kgr;\":\n        return (char) 0x3BA;\n      case \"&lambda;\":\n      case \"&lgr;\":\n        return (char) 0x3BB;\n      case \"&mu;\":\n      case \"&mgr;\":\n        return (char) 0x3BC;\n      case \"&nu;\":\n      case \"&ngr;\":\n        return (char) 0x3BD;\n      case \"&xi;\":\n      case \"&xgr;\":\n        return (char) 0x3BE;\n      case \"&omicron;\":\n      case \"&ogr;\":\n        return (char) 0x3BF;\n      case \"&pi;\":\n      case \"&pgr;\":\n        return (char) 0x3C0;\n      case \"&rho;\":\n      case \"&rgr;\":\n        return (char) 0x3C1;\n      case \"&sigma;\":\n      case \"&sgr;\":\n        return (char) 0x3C3;\n      case \"&tau;\":\n      case \"&tgr;\":\n        return (char) 0x3C4;\n      case \"&upsilon;\":\n      case \"&ugr;\":\n        return (char) 0x3C5;\n      case \"&phi;\":\n      case \"&phgr;\":\n        return (char) 0x3C6;\n      case \"&chi;\":\n      case \"&khgr;\":\n        return (char) 0x3C7;\n      case \"&psi;\":\n      case \"&psgr;\":\n        return (char) 0x3C8;\n      case \"&omega;\":\n      case \"&ohgr;\":\n        return (char) 0x3C9;\n      case \"&bull;\":\n        return (char) 0x2022;\n      case \"&percnt;\":\n        return '%';\n      case \"&plus;\":\n        return '+';\n      case \"&dash;\":\n        return '-';\n      case \"&abreve;\":\n      case \"&amacr;\":\n      case \"&ape;\":\n      case \"&aogon;\":\n        return 'a';\n      case \"&Amacr;\":\n        return 'A';\n      case \"&cacute;\":\n      case \"&ccaron;\":\n      case \"&ccirc;\":\n        return 'c';\n      case \"&Ccaron;\":\n        return 'C';\n      case \"&dcaron;\":\n        return 'd';\n      case \"&ecaron;\":\n      case \"&emacr;\":\n      case \"&eogon;\":\n        return 'e';\n      case \"&Emacr;\":\n      case \"&Ecaron;\":\n        return 'E';\n      case \"&lacute;\":\n        return 'l';\n      case \"&Lacute;\":\n        return 'L';\n      case \"&nacute;\":\n      case \"&ncaron;\":\n      case \"&ncedil;\":\n        return 'n';\n      case \"&rcaron;\":\n      case \"&racute;\":\n        return 'r';\n      case \"&Rcaron;\":\n        return 'R';\n      case \"&omacr;\":\n        return 'o';\n      case \"&imacr;\":\n        return 'i';\n      case \"&sacute;\":\n      case \"&scedil;\":\n      case \"&scirc;\":\n        return 's';\n      case \"&Sacute\":\n      case \"&Scedil;\":\n        return 'S';\n      case \"&tcaron;\":\n      case \"&tcedil;\":\n        return 't';\n      case \"&umacr;\":\n      case \"&uring;\":\n        return 'u';\n      case \"&wcirc;\":\n        return 'w';\n      case \"&Ycirc;\":\n        return 'Y';\n      case \"&ycirc;\":\n        return 'y';\n      case \"&zcaron;\":\n      case \"&zacute;\":\n        return 'z';\n      case \"&Zcaron;\":\n        return 'Z';\n      case \"&hearts;\":\n        return (char) 0x2665;\n      case \"&infin;\":\n        return (char) 0x221E;\n      case \"&dollar;\":\n        return '$';\n      case \"&sub;\":\n      case \"&lcub;\":\n        return (char) 0x2282;\n      case \"&sup;\":\n      case \"&rcub;\":\n        return (char) 0x2283;\n      case \"&lsqb;\":\n        return '[';\n      case \"&rsqb;\":\n        return ']';\n      default:\n        return ' ';\n    }\n  }\n\n\n  /** Returns a String in which all the XML special characters have been\n   *  escaped. The resulting String is valid to print in an XML file as an\n   *  attribute or element value in all circumstances.  (Note that it may\n   *  escape characters that didn't need to be escaped.)\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '<') {\n        sb.append(\"&lt;\");\n      } else if (c == '>') {\n        sb.append(\"&gt;\");\n      } else if (c == '\"') {\n        sb.append(\"&quot;\");\n      } else if (c == '\\'') {\n        sb.append(\"&apos;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  /** Returns a String in which some the XML special characters have been\n   *  escaped: just the ones that need escaping in an element content.\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeElementXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '<') {\n        sb.append(\"&lt;\");\n      } else if (c == '>') {\n        sb.append(\"&gt;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  /** Returns a String in which some XML special characters have been\n   *  escaped. This just escapes attribute value ones, assuming that\n   *  you're going to quote with double quotes.\n   *  That is, only \" and & are escaped.\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeAttributeXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '\"') {\n        sb.append(\"&quot;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  public static String escapeTextAroundXMLTags(String s) {\n    StringBuilder result = new StringBuilder();\n    Reader r = new StringReader(s);\n    try {\n      do {\n        String text = readUntilTag(r);\n        //      System.err.println(\"got text: \" + text);\n        result.append(escapeXML(text));\n        XMLTag tag = readAndParseTag(r);\n        //      System.err.println(\"got tag: \" + tag);\n        if (tag == null) {\n          break;\n        }\n        result.append(tag);\n      } while (true);\n    } catch (IOException e) {\n      log.warn(\"Error reading string\");\n      log.warn(e);\n    }\n    return result.toString();\n  }\n\n  /**\n   * return either the first space or the first nbsp\n   */\n  public static int findSpace(String haystack, int begin) {\n    int space = haystack.indexOf(' ', begin);\n    int nbsp = haystack.indexOf('\\u00A0', begin);\n    if (space == -1 && nbsp == -1) {\n      return -1;\n    } else if (space >= 0 && nbsp >= 0) {\n      return Math.min(space, nbsp);\n    } else {\n      // eg one is -1, and the other is >= 0\n      return Math.max(space, nbsp);\n    }\n  }\n\n  public static class XMLTag {\n\n    /** Stores the complete string passed in as the tag on construction. */\n    public String text;\n\n    /** Stores the element name, such as \"doc\". */\n    public String name;\n\n    /** Stores attributes as a Map from keys to values. */\n    public Map<String,String> attributes;\n\n    /** Whether this is an ending tag or not. */\n    public boolean isEndTag;\n\n    /** Whether this is an empty element expressed as a single empty element tag like {@code <p/>}. */\n    public boolean isSingleTag;\n\n    /**\n     * Assumes that String contains an XML tag.\n     *\n     * @param tag String to turn into an XMLTag object\n     */\n    public XMLTag(String tag) {\n      if (tag == null || tag.isEmpty()) {\n        throw new NullPointerException(\"Attempted to parse empty/null tag\");\n      }\n      if (tag.charAt(0) != '<') {\n        throw new IllegalArgumentException(\"Tag did not start with <\");\n      }\n      if (tag.charAt(tag.length() - 1) != '>') {\n        throw new IllegalArgumentException(\"Tag did not end with >\");\n      }\n      text = tag;\n      int begin = 1;\n      if (tag.charAt(1) == '/') {\n        begin = 2;\n        isEndTag = true;\n      } else {\n        isEndTag = false;\n      }\n      int end = tag.length() - 1;\n      if (tag.charAt(tag.length() - 2) == '/') {\n        end = tag.length() - 2;\n        isSingleTag = true;\n      } else {\n        isSingleTag = false;\n      }\n      tag = tag.substring(begin, end);\n      attributes = Generics.newHashMap();\n      begin = 0;\n      end = findSpace(tag, 0);\n\n      if (end < 0) {\n        name = tag;\n      } else {\n        name = tag.substring(begin, end);\n        do {\n          begin = end + 1;\n          while (begin < tag.length() && tag.charAt(begin) < 0x21) {\n            begin++; // get rid of leading whitespace\n          }\n          if (begin == tag.length()) {\n            break;\n          }\n          end = tag.indexOf('=', begin);\n          if (end < 0) {\n            String att = tag.substring(begin);\n            attributes.put(att, \"\");\n            break;\n          }\n          String att = tag.substring(begin, end).trim();\n          begin = end + 1;\n          String value = null;\n          if (tag.length() > begin) {\n            while (begin < tag.length() && tag.charAt(begin) < 0x21) {\n              begin++;\n            }\n            if (begin < tag.length() && tag.charAt(begin) == '\\\"') {\n              // get quoted expression\n              begin++;\n              end = tag.indexOf('\\\"', begin);\n              if (end < 0) {\n                break; // this is a problem\n              }\n              value = tag.substring(begin, end);\n              end++;\n            } else {\n              // get unquoted expression\n              end = findSpace(tag, begin);\n              if (end < 0) {\n                end = tag.length();\n              }\n//              System.err.println(begin + \" \" + end);\n              value = tag.substring(begin, end);\n            }\n          }\n          attributes.put(att, value);\n        } while (end < tag.length() - 3);\n      }\n    }\n\n    public String toString() {\n      return text;\n    }\n\n    /**\n     * Given a list of attributes, return the first one that is non-null\n     */\n    public String getFirstNonNullAttributeFromList(List<String> attributesList) {\n      for (String attribute : attributesList) {\n        if (attributes.get(attribute) != null) {\n          return attributes.get(attribute);\n        }\n      }\n      return null;\n    }\n  } // end static class XMLTag\n\n\n  /**\n   * Reads all text of the XML tag and returns it as a String.\n   * Assumes that a '<' character has already been read.\n   *\n   * @param r The reader to read from\n   * @return The String representing the tag, or null if one couldn't be read\n   *         (i.e., EOF).  The returned item is a complete tag including angle\n   *         brackets, such as {@code <TXT>}\n   */\n  public static String readTag(Reader r) throws IOException {\n    if ( ! r.ready()) {\n      return null;\n    }\n    StringBuilder b = new StringBuilder(\"<\");\n    int c = r.read();\n    while (c >= 0) {\n      b.append((char) c);\n      if (c == '>') {\n        break;\n      }\n      c = r.read();\n    }\n    if (b.length() == 1) {\n      return null;\n    }\n    return b.toString();\n  }\n\n  public static XMLTag parseTag(String tagString) {\n    if (tagString == null || tagString.isEmpty()) {\n      return null;\n    }\n    if (tagString.charAt(0) != '<' ||\n        tagString.charAt(tagString.length() - 1) != '>') {\n      return null;\n    }\n    return new XMLTag(tagString);\n  }\n\n  public static Document readDocumentFromFile(String filename) throws Exception {\n    InputSource in = new InputSource(new FileReader(filename));\n    DocumentBuilderFactory factory = safeDocumentBuilderFactory();\n\n    factory.setNamespaceAware(false);\n    DocumentBuilder db = factory.newDocumentBuilder();\n    db.setErrorHandler(new SAXErrorHandler());\n    return db.parse(in);\n  }\n\n  private static class SAXErrorHandler implements ErrorHandler {\n\n    public static String makeBetterErrorString(String msg,\n                                               SAXParseException ex) {\n      StringBuilder sb = new StringBuilder(msg);\n      sb.append(\": \");\n      String str = ex.getMessage();\n      if (str.lastIndexOf('.') == str.length() - 1) {\n        str = str.substring(0, str.length() - 1);\n      }\n      sb.append(str);\n      sb.append(\" at document line \").append(ex.getLineNumber());\n      sb.append(\", column \").append(ex.getColumnNumber());\n      if (ex.getSystemId() != null) {\n        sb.append(\" in entity from systemID \").append(ex.getSystemId());\n      } else if (ex.getPublicId() != null) {\n        sb.append(\" in entity from publicID \").append(ex.getPublicId());\n      }\n      sb.append('.');\n      return sb.toString();\n    }\n\n    @Override\n    public void warning(SAXParseException exception) {\n      log.warn(makeBetterErrorString(\"Warning\", exception));\n    }\n\n    @Override\n    public void error(SAXParseException exception) {\n      log.error(makeBetterErrorString(\"Error\", exception));\n    }\n\n    @Override\n    public void fatalError(SAXParseException ex) throws SAXParseException {\n      throw new SAXParseException(makeBetterErrorString(\"Fatal Error\", ex),\n              ex.getPublicId(), ex.getSystemId(), ex.getLineNumber(), ex.getColumnNumber());\n      // throw new RuntimeException(makeBetterErrorString(\"Fatal Error\", ex));\n    }\n\n  } // end class SAXErrorHandler\n\n  public static Document readDocumentFromString(String s) throws Exception {\n    InputSource in = new InputSource(new StringReader(s));\n    DocumentBuilderFactory factory = safeDocumentBuilderFactory();\n    factory.setNamespaceAware(false);\n    return factory.newDocumentBuilder().parse(in);\n  }\n\n  /** Tests a few methods.\n   *  If the first arg is -readDoc then this method tests\n   *  readDocumentFromFile.\n   *  Otherwise, it tests readTag/readUntilTag and slurpFile.\n   */\n  public static void main(String[] args) throws Exception {\n    if (args[0].equals(\"-readDoc\")) {\n      Document doc = readDocumentFromFile(args[1]);\n      System.out.println(doc);\n    } else {\n      String s = IOUtils.slurpFile(args[0]);\n      Reader r = new StringReader(s);\n      String tag = readTag(r);\n      while (tag != null && ! tag.isEmpty()) {\n        readUntilTag(r);\n        tag = readTag(r);\n        if (tag == null || tag.isEmpty()) {\n          break;\n        }\n        System.out.println(\"got tag=\" + new XMLTag(tag));\n      }\n    }\n  }\n\n}\n"], "fixing_code": ["package edu.stanford.nlp.util;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\nimport edu.stanford.nlp.io.IOUtils;\nimport edu.stanford.nlp.util.logging.Redwood;\n\n\n/**\n * Provides some utilities for dealing with XML files, both by properly\n * parsing them and by using the methods of a desperate Perl hacker.\n *\n * @author Teg Grenager\n * @author Grace Muzny\n */\npublic class XMLUtils  {\n\n  /** A logger for this class */\n  private static final Redwood.RedwoodChannels log = Redwood.channels(XMLUtils.class);\n\n  private XMLUtils() {} // only static methods\n\n  public static DocumentBuilderFactory safeDocumentBuilderFactory() {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    try {\n      dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n      dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n      dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n      dbf.setFeature(\"http://apache.org/xml/features/dom/create-entity-ref-nodes\", false);\n      dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    } catch (ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return dbf;\n  }\n    \n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   *\n   * @return List of String text contents of tags.\n   */\n  public static List<String> getTextContentFromTagsFromFile(File f, String tag) {\n    List<String> sents = Generics.newArrayList();\n    try {\n      sents = getTextContentFromTagsFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   * If the text contents contains embedded tags, strips the embedded tags out\n   * of the returned text. E.g., {@code <s>This is a <s>sentence</s> with embedded tags\n   * </s>} would return the list containing [\"This is a sentence with embedded\n   * tags\", \"sentence\"].\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of String text contents of tags.\n   */\n  private static List<String> getTextContentFromTagsFromFileSAXException(\n          File f, String tag) throws SAXException {\n    List<String> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Element element = (Element)nodeList.item(i);\n        String raw = element.getTextContent();\n        StringBuilder builtUp = new StringBuilder();\n        boolean inTag = false;\n        for (int j = 0; j < raw.length(); j++) {\n          if (raw.charAt(j) == '<') {\n            inTag = true;\n          }\n          if (!inTag) {\n            builtUp.append(raw.charAt(j));\n          }\n          if (raw.charAt(j) == '>') {\n            inTag = false;\n          }\n        }\n        sents.add(builtUp.toString());\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   *\n   * @return List of String text contents of tags.\n   */\n  public static List<Element> getTagElementsFromFile(File f, String tag) {\n    List<Element> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementsFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the text content of all nodes in the given file with the given tag.\n   * If the text contents contains embedded tags, strips the embedded tags out\n   * of the returned text. E.g., {@code <s>This is a <s>sentence</s> with embedded tags\n   * </s>} would return the list containing [\"This is a sentence with embedded\n   * tags\", \"sentence\"].\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of String text contents of tags.\n   */\n  private static List<Element> getTagElementsFromFileSAXException(\n          File f, String tag) throws SAXException {\n    List<Element> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Element element = (Element)nodeList.item(i);\n        sents.add(element);\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the two previous siblings and two next siblings.\n   *\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFile(File f, String tag) {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementTriplesFromFileSAXException(f, tag);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the previous and next siblings up to max numIncludedSiblings.\n   *\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileNumBounded(File f,\n                                                                                             String tag,\n                                                                                             int num) {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      sents = getTagElementTriplesFromFileNumBoundedSAXException(f, tag, num);\n    } catch (SAXException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the two previous siblings and two next siblings.\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileSAXException(\n      File f, String tag) throws SAXException {\n    return  getTagElementTriplesFromFileNumBoundedSAXException(f, tag, 2);\n  }\n\n  /**\n   * Returns the elements in the given file with the given tag associated with\n   * the text content of the previous and next siblings up to max numIncludedSiblings.\n   *\n   * @throws SAXException if tag doesn't exist in the file.\n   * @return List of {@code Triple<String, Element, String>} Targeted elements surrounded\n   * by the text content of the two previous siblings and two next siblings.\n   */\n  public static List<Triple<String, Element, String>> getTagElementTriplesFromFileNumBoundedSAXException(\n      File f, String tag, int numIncludedSiblings) throws SAXException {\n    List<Triple<String, Element, String>> sents = Generics.newArrayList();\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document doc = db.parse(f);\n      doc.getDocumentElement().normalize();\n\n      NodeList nodeList=doc.getElementsByTagName(tag);\n      for (int i = 0; i < nodeList.getLength(); i++) {\n        // Get element\n        Node prevNode = nodeList.item(i).getPreviousSibling();\n        String prev = \"\";\n        int count = 0;\n        while (prevNode != null && count <= numIncludedSiblings) {\n          prev = prevNode.getTextContent() + prev;\n          prevNode = prevNode.getPreviousSibling();\n          count++;\n        }\n\n        Node nextNode = nodeList.item(i).getNextSibling();\n        String next = \"\";\n        count = 0;\n        while (nextNode != null && count <= numIncludedSiblings) {\n          next = next + nextNode.getTextContent();\n          nextNode = nextNode.getNextSibling();\n          count++;\n        }\n        Element element = (Element)nodeList.item(i);\n        Triple<String, Element, String> t = new Triple<>(prev, element, next);\n        sents.add(t);\n      }\n    } catch (IOException | ParserConfigurationException e) {\n      log.warn(e);\n    }\n    return sents;\n  }\n\n\n  /**\n   * Returns a non-validating XML parser. The parser ignores both DTDs and XSDs.\n   *\n   * @return An XML parser in the form of a DocumentBuilder\n   */\n  public static DocumentBuilder getXmlParser() {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n      dbf.setValidating(false);\n\n      //Disable DTD loading and validation\n      //See http://stackoverflow.com/questions/155101/make-documentbuilder-parse-ignore-dtd-references\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }\n\n  /**\n   * Returns a validating XML parser given an XSD (not DTD!).\n   *\n   * @param schemaFile File wit hXML schema\n   * @return An XML parser in the form of a DocumentBuilder\n   */\n  public static DocumentBuilder getValidatingXmlParser(File schemaFile) {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n\n      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n      Schema schema = factory.newSchema(schemaFile);\n      dbf.setSchema(schema);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch (SAXException e) {\n      log.warnf(\"%s: XML parsing exception while loading schema %s\\n\", XMLUtils.class.getName(),schemaFile.getPath());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }\n\n  /**\n   * Block-level HTML tags that are rendered with surrounding line breaks.\n   */\n  private static final Set<String> breakingTags = Generics.newHashSet(Arrays.asList(new String[] {\"blockquote\", \"br\", \"div\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"tr\", \"td\"}));\n\n  /**\n   * @param r       the reader to read the XML/HTML from\n   * @param mapBack a List of Integers mapping the positions in the result buffer\n   *                to positions in the original Reader, will be cleared on receipt\n   * @return the String containing the resulting text\n   */\n  public static String stripTags(Reader r, List<Integer> mapBack, boolean markLineBreaks) {\n    if (mapBack != null) {\n      mapBack.clear(); // just in case it has something in it!\n    }\n    StringBuilder result = new StringBuilder();\n    try {\n      int position = 0;\n      do {\n        String text = XMLUtils.readUntilTag(r);\n        if (text.length() > 0) {\n          // add offsets to the map back\n          for (int i = 0; i < text.length(); i++) {\n            result.append(text.charAt(i));\n            if (mapBack != null) {\n              mapBack.add(Integer.valueOf(position + i));\n            }\n          }\n          position += text.length();\n        }\n        //        System.err.println(position + \" got text: \" + text);\n        String tag = XMLUtils.readTag(r);\n        if (tag == null) {\n          break;\n        }\n        if (markLineBreaks && XMLUtils.isBreaking(parseTag(tag))) {\n          result.append(\"\\n\");\n          if (mapBack != null) {\n            mapBack.add(Integer.valueOf(-position));\n          }\n        }\n        position += tag.length();\n        //        System.err.println(position + \" got tag: \" + tag);\n      } while (true);\n    } catch (IOException e) {\n      log.warn(\"Error reading string\");\n      log.warn(e);\n    }\n    return result.toString();\n  }\n\n  public static boolean isBreaking(String tag) {\n    return breakingTags.contains(tag);\n  }\n\n  public static boolean isBreaking(XMLTag tag) {\n    return breakingTags.contains(tag.name);\n  }\n\n  /**\n   * Reads all text up to next XML tag and returns it as a String.\n   *\n   * @return the String of the text read, which may be empty.\n   */\n  public static String readUntilTag(Reader r) throws IOException {\n    if (!r.ready()) {\n      return \"\";\n    }\n    StringBuilder b = new StringBuilder();\n    int c = r.read();\n    while (c >= 0 && c != '<') {\n      b.append((char) c);\n      c = r.read();\n    }\n    return b.toString();\n  }\n\n  /**\n   * @return the new XMLTag object, or null if couldn't be created\n   */\n  public static XMLTag readAndParseTag(Reader r) throws IOException {\n    String s = readTag(r);\n    if (s == null) {\n      return null;\n    }\n    XMLTag ret = null;\n    try {\n      ret = new XMLTag(s);\n    } catch (Exception e) {\n      log.warn(\"Failed to handle |\" + s + \"|\");\n    }\n    return ret;\n  }\n\n  // Pattern is reentrant, going by the statement \"many matchers can share the same pattern\"\n  // on the Pattern javadoc.  Therefore, this should be safe as a static final variable.\n  private static final Pattern xmlEscapingPattern = Pattern.compile(\"&.+?;\");\n\n  public static String unescapeStringForXML(String s) {\n    StringBuilder result = new StringBuilder();\n    Matcher m = xmlEscapingPattern.matcher(s);\n    int end = 0;\n    while (m.find()) {\n      int start = m.start();\n      result.append(s, end, start);\n      end = m.end();\n      result.append(translate(s.substring(start, end)));\n    }\n    result.append(s, end, s.length());\n    return result.toString();\n  }\n\n  private static char translate(String s) {\n    switch (s) {\n      case \"&amp;\":\n        return '&';\n      case \"&lt;\":\n      case \"&Lt;\":\n        return '<';\n      case \"&gt;\":\n      case \"&Gt;\":\n        return '>';\n      case \"&quot;\":\n        return '\\\"';\n      case \"&apos;\":\n        return '\\'';\n      case \"&ast;\":\n        return '*';\n      case \"&sharp;\":\n        return '\\u266F';\n      case \"&equals;\":\n        return '=';\n      case \"&nbsp;\":\n        return (char) 0xA0;\n      case \"&iexcl;\":\n        return (char) 0xA1;\n      case \"&cent;\":\n      case \"&shilling;\":\n        return (char) 0xA2;\n      case \"&pound;\":\n        return (char) 0xA3;\n      case \"&curren;\":\n        return (char) 0xA4;\n      case \"&yen;\":\n        return (char) 0xA5;\n      case \"&brvbar;\":\n        return (char) 0xA6;\n      case \"&sect;\":\n        return (char) 0xA7;\n      case \"&uml;\":\n        return (char) 0xA8;\n      case \"&copy;\":\n        return (char) 0xA9;\n      case \"&ordf;\":\n        return (char) 0xAA;\n      case \"&laquo; \":\n        return (char) 0xAB;\n      case \"&not;\":\n        return (char) 0xAC;\n      case \"&shy; \":\n        return (char) 0xAD;\n      case \"&reg;\":\n        return (char) 0xAE;\n      case \"&macr;\":\n        return (char) 0xAF;\n      case \"&deg;\":\n        return (char) 0xB0;\n      case \"&plusmn;\":\n        return (char) 0xB1;\n      case \"&sup2;\":\n        return (char) 0xB2;\n      case \"&sup3;\":\n        return (char) 0xB3;\n      case \"&acute;\":\n        return (char) 0xB4;\n      case \"&micro;\":\n        return (char) 0xB5;\n      case \"&middot;\":\n        return (char) 0xB7;\n      case \"&cedil;\":\n        return (char) 0xB8;\n      case \"&sup1;\":\n        return (char) 0xB9;\n      case \"&ordm;\":\n        return (char) 0xBA;\n      case \"&raquo;\":\n        return (char) 0xBB;\n      case \"&frac14; \":\n        return (char) 0xBC;\n      case \"&frac12;\":\n        return (char) 0xBD;\n      case \"&frac34; \":\n        return (char) 0xBE;\n      case \"&iquest;\":\n        return (char) 0xBF;\n      case \"&Agrave;\":\n        return (char) 0xC0;\n      case \"&Aacute;\":\n        return (char) 0xC1;\n      case \"&Acirc;\":\n        return (char) 0xC2;\n      case \"&Atilde;\":\n        return (char) 0xC3;\n      case \"&Auml;\":\n        return (char) 0xC4;\n      case \"&Aring;\":\n        return (char) 0xC5;\n      case \"&AElig;\":\n        return (char) 0xC6;\n      case \"&Ccedil;\":\n        return (char) 0xC7;\n      case \"&Egrave;\":\n        return (char) 0xC8;\n      case \"&Eacute;\":\n        return (char) 0xC9;\n      case \"&Ecirc;\":\n        return (char) 0xCA;\n      case \"&Euml;\":\n        return (char) 0xCB;\n      case \"&Igrave;\":\n        return (char) 0xCC;\n      case \"&Iacute;\":\n        return (char) 0xCD;\n      case \"&Icirc;\":\n        return (char) 0xCE;\n      case \"&Iuml;\":\n        return (char) 0xCF;\n      case \"&ETH;\":\n        return (char) 0xD0;\n      case \"&Ntilde;\":\n        return (char) 0xD1;\n      case \"&Ograve;\":\n        return (char) 0xD2;\n      case \"&Oacute;\":\n        return (char) 0xD3;\n      case \"&Ocirc;\":\n        return (char) 0xD4;\n      case \"&Otilde;\":\n        return (char) 0xD5;\n      case \"&Ouml;\":\n        return (char) 0xD6;\n      case \"&times;\":\n        return (char) 0xD7;\n      case \"&Oslash;\":\n        return (char) 0xD8;\n      case \"&Ugrave;\":\n        return (char) 0xD9;\n      case \"&Uacute;\":\n        return (char) 0xDA;\n      case \"&Ucirc;\":\n        return (char) 0xDB;\n      case \"&Uuml;\":\n        return (char) 0xDC;\n      case \"&Yacute;\":\n        return (char) 0xDD;\n      case \"&THORN;\":\n        return (char) 0xDE;\n      case \"&szlig;\":\n        return (char) 0xDF;\n      case \"&agrave;\":\n        return (char) 0xE0;\n      case \"&aacute;\":\n        return (char) 0xE1;\n      case \"&acirc;\":\n        return (char) 0xE2;\n      case \"&atilde;\":\n        return (char) 0xE3;\n      case \"&auml;\":\n        return (char) 0xE4;\n      case \"&aring;\":\n        return (char) 0xE5;\n      case \"&aelig;\":\n        return (char) 0xE6;\n      case \"&ccedil;\":\n        return (char) 0xE7;\n      case \"&egrave;\":\n        return (char) 0xE8;\n      case \"&eacute;\":\n        return (char) 0xE9;\n      case \"&ecirc;\":\n        return (char) 0xEA;\n      case \"&euml; \":\n        return (char) 0xEB;\n      case \"&igrave;\":\n        return (char) 0xEC;\n      case \"&iacute;\":\n        return (char) 0xED;\n      case \"&icirc;\":\n        return (char) 0xEE;\n      case \"&iuml;\":\n        return 0xEF;\n      case \"&eth;\":\n        return (char) 0xF0;\n      case \"&ntilde;\":\n        return (char) 0xF1;\n      case \"&ograve;\":\n        return (char) 0xF2;\n      case \"&oacute;\":\n        return (char) 0xF3;\n      case \"&ocirc;\":\n        return (char) 0xF4;\n      case \"&otilde;\":\n        return (char) 0xF5;\n      case \"&ouml;\":\n        return (char) 0xF6;\n      case \"&divide;\":\n        return (char) 0xF7;\n      case \"&oslash;\":\n        return (char) 0xF8;\n      case \"&ugrave;\":\n        return (char) 0xF9;\n      case \"&uacute;\":\n        return (char) 0xFA;\n      case \"&ucirc;\":\n        return (char) 0xFB;\n      case \"&uuml;\":\n        return (char) 0xFC;\n      case \"&yacute;\":\n        return (char) 0xFD;\n      case \"&thorn;\":\n        return (char) 0xFE;\n      case \"&yuml;\":\n        return (char) 0xFF;\n      case \"&OElig;\":\n        return (char) 0x152;\n      case \"&oelig;\":\n        return (char) 0x153;\n      case \"&Scaron;\":\n        return (char) 0x160;\n      case \"&scaron;\":\n        return (char) 0x161;\n      case \"&Yuml;\":\n        return (char) 0x178;\n      case \"&circ;\":\n        return (char) 0x2C6;\n      case \"&tilde;\":\n        return (char) 0x2DC;\n      case \"&lrm;\":\n        return (char) 0x200E;\n      case \"&rlm;\":\n        return (char) 0x200F;\n      case \"&ndash;\":\n        return (char) 0x2013;\n      case \"&mdash;\":\n        return (char) 0x2014;\n      case \"&lsquo;\":\n        return (char) 0x2018;\n      case \"&rsquo;\":\n        return (char) 0x2019;\n      case \"&sbquo;\":\n        return (char) 0x201A;\n      case \"&ldquo;\":\n      case \"&bquo;\":\n      case \"&bq;\":\n        return (char) 0x201C;\n      case \"&rdquo;\":\n      case \"&equo;\":\n        return (char) 0X201D;\n      case \"&bdquo;\":\n        return (char) 0x201E;\n      case \"&sim;\":\n        return (char) 0x223C;\n      case \"&radic;\":\n        return (char) 0x221A;\n      case \"&le;\":\n        return (char) 0x2264;\n      case \"&ge;\":\n        return (char) 0x2265;\n      case \"&larr;\":\n        return (char) 0x2190;\n      case \"&darr;\":\n        return (char) 0x2193;\n      case \"&rarr;\":\n        return (char) 0x2192;\n      case \"&hellip;\":\n        return (char) 0x2026;\n      case \"&prime;\":\n        return (char) 0x2032;\n      case \"&Prime;\":\n      case \"&ins;\":\n        return (char) 0x2033;\n      case \"&trade;\":\n        return (char) 0x2122;\n      case \"&Alpha;\":\n      case \"&Agr;\":\n        return (char) 0x391;\n      case \"&Beta;\":\n      case \"&Bgr;\":\n        return (char) 0x392;\n      case \"&Gamma;\":\n      case \"&Ggr;\":\n        return (char) 0x393;\n      case \"&Delta;\":\n      case \"&Dgr;\":\n        return (char) 0x394;\n      case \"&Epsilon;\":\n      case \"&Egr;\":\n        return (char) 0x395;\n      case \"&Zeta;\":\n      case \"&Zgr;\":\n        return (char) 0x396;\n      case \"&Eta;\":\n        return (char) 0x397;\n      case \"&Theta;\":\n      case \"&THgr;\":\n        return (char) 0x398;\n      case \"&Iota;\":\n      case \"&Igr;\":\n        return (char) 0x399;\n      case \"&Kappa;\":\n      case \"&Kgr;\":\n        return (char) 0x39A;\n      case \"&Lambda;\":\n      case \"&Lgr;\":\n        return (char) 0x39B;\n      case \"&Mu;\":\n      case \"&Mgr;\":\n        return (char) 0x39C;\n      case \"&Nu;\":\n      case \"&Ngr;\":\n        return (char) 0x39D;\n      case \"&Xi;\":\n      case \"&Xgr;\":\n        return (char) 0x39E;\n      case \"&Omicron;\":\n      case \"&Ogr;\":\n        return (char) 0x39F;\n      case \"&Pi;\":\n      case \"&Pgr;\":\n        return (char) 0x3A0;\n      case \"&Rho;\":\n      case \"&Rgr;\":\n        return (char) 0x3A1;\n      case \"&Sigma;\":\n      case \"&Sgr;\":\n        return (char) 0x3A3;\n      case \"&Tau;\":\n      case \"&Tgr;\":\n        return (char) 0x3A4;\n      case \"&Upsilon;\":\n      case \"&Ugr;\":\n        return (char) 0x3A5;\n      case \"&Phi;\":\n      case \"&PHgr;\":\n        return (char) 0x3A6;\n      case \"&Chi;\":\n      case \"&KHgr;\":\n        return (char) 0x3A7;\n      case \"&Psi;\":\n      case \"&PSgr;\":\n        return (char) 0x3A8;\n      case \"&Omega;\":\n      case \"&OHgr;\":\n        return (char) 0x3A9;\n      case \"&alpha;\":\n      case \"&agr;\":\n        return (char) 0x3B1;\n      case \"&beta;\":\n      case \"&bgr;\":\n        return (char) 0x3B2;\n      case \"&gamma;\":\n      case \"&ggr;\":\n        return (char) 0x3B3;\n      case \"&delta;\":\n      case \"&dgr;\":\n        return (char) 0x3B4;\n      case \"&epsilon;\":\n      case \"&egr;\":\n        return (char) 0x3B5;\n      case \"&zeta;\":\n      case \"&zgr;\":\n        return (char) 0x3B6;\n      case \"&eta;\":\n      case \"&eegr;\":\n        return (char) 0x3B7;\n      case \"&theta;\":\n      case \"&thgr;\":\n        return (char) 0x3B8;\n      case \"&iota;\":\n      case \"&igr;\":\n        return (char) 0x3B9;\n      case \"&kappa;\":\n      case \"&kgr;\":\n        return (char) 0x3BA;\n      case \"&lambda;\":\n      case \"&lgr;\":\n        return (char) 0x3BB;\n      case \"&mu;\":\n      case \"&mgr;\":\n        return (char) 0x3BC;\n      case \"&nu;\":\n      case \"&ngr;\":\n        return (char) 0x3BD;\n      case \"&xi;\":\n      case \"&xgr;\":\n        return (char) 0x3BE;\n      case \"&omicron;\":\n      case \"&ogr;\":\n        return (char) 0x3BF;\n      case \"&pi;\":\n      case \"&pgr;\":\n        return (char) 0x3C0;\n      case \"&rho;\":\n      case \"&rgr;\":\n        return (char) 0x3C1;\n      case \"&sigma;\":\n      case \"&sgr;\":\n        return (char) 0x3C3;\n      case \"&tau;\":\n      case \"&tgr;\":\n        return (char) 0x3C4;\n      case \"&upsilon;\":\n      case \"&ugr;\":\n        return (char) 0x3C5;\n      case \"&phi;\":\n      case \"&phgr;\":\n        return (char) 0x3C6;\n      case \"&chi;\":\n      case \"&khgr;\":\n        return (char) 0x3C7;\n      case \"&psi;\":\n      case \"&psgr;\":\n        return (char) 0x3C8;\n      case \"&omega;\":\n      case \"&ohgr;\":\n        return (char) 0x3C9;\n      case \"&bull;\":\n        return (char) 0x2022;\n      case \"&percnt;\":\n        return '%';\n      case \"&plus;\":\n        return '+';\n      case \"&dash;\":\n        return '-';\n      case \"&abreve;\":\n      case \"&amacr;\":\n      case \"&ape;\":\n      case \"&aogon;\":\n        return 'a';\n      case \"&Amacr;\":\n        return 'A';\n      case \"&cacute;\":\n      case \"&ccaron;\":\n      case \"&ccirc;\":\n        return 'c';\n      case \"&Ccaron;\":\n        return 'C';\n      case \"&dcaron;\":\n        return 'd';\n      case \"&ecaron;\":\n      case \"&emacr;\":\n      case \"&eogon;\":\n        return 'e';\n      case \"&Emacr;\":\n      case \"&Ecaron;\":\n        return 'E';\n      case \"&lacute;\":\n        return 'l';\n      case \"&Lacute;\":\n        return 'L';\n      case \"&nacute;\":\n      case \"&ncaron;\":\n      case \"&ncedil;\":\n        return 'n';\n      case \"&rcaron;\":\n      case \"&racute;\":\n        return 'r';\n      case \"&Rcaron;\":\n        return 'R';\n      case \"&omacr;\":\n        return 'o';\n      case \"&imacr;\":\n        return 'i';\n      case \"&sacute;\":\n      case \"&scedil;\":\n      case \"&scirc;\":\n        return 's';\n      case \"&Sacute\":\n      case \"&Scedil;\":\n        return 'S';\n      case \"&tcaron;\":\n      case \"&tcedil;\":\n        return 't';\n      case \"&umacr;\":\n      case \"&uring;\":\n        return 'u';\n      case \"&wcirc;\":\n        return 'w';\n      case \"&Ycirc;\":\n        return 'Y';\n      case \"&ycirc;\":\n        return 'y';\n      case \"&zcaron;\":\n      case \"&zacute;\":\n        return 'z';\n      case \"&Zcaron;\":\n        return 'Z';\n      case \"&hearts;\":\n        return (char) 0x2665;\n      case \"&infin;\":\n        return (char) 0x221E;\n      case \"&dollar;\":\n        return '$';\n      case \"&sub;\":\n      case \"&lcub;\":\n        return (char) 0x2282;\n      case \"&sup;\":\n      case \"&rcub;\":\n        return (char) 0x2283;\n      case \"&lsqb;\":\n        return '[';\n      case \"&rsqb;\":\n        return ']';\n      default:\n        return ' ';\n    }\n  }\n\n\n  /** Returns a String in which all the XML special characters have been\n   *  escaped. The resulting String is valid to print in an XML file as an\n   *  attribute or element value in all circumstances.  (Note that it may\n   *  escape characters that didn't need to be escaped.)\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '<') {\n        sb.append(\"&lt;\");\n      } else if (c == '>') {\n        sb.append(\"&gt;\");\n      } else if (c == '\"') {\n        sb.append(\"&quot;\");\n      } else if (c == '\\'') {\n        sb.append(\"&apos;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  /** Returns a String in which some the XML special characters have been\n   *  escaped: just the ones that need escaping in an element content.\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeElementXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '<') {\n        sb.append(\"&lt;\");\n      } else if (c == '>') {\n        sb.append(\"&gt;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  /** Returns a String in which some XML special characters have been\n   *  escaped. This just escapes attribute value ones, assuming that\n   *  you're going to quote with double quotes.\n   *  That is, only \" and & are escaped.\n   *\n   *  @param in The String to escape\n   *  @return The escaped String\n   */\n  public static String escapeAttributeXML(String in) {\n    int leng = in.length();\n    StringBuilder sb = new StringBuilder(leng);\n    for (int i = 0; i < leng; i++) {\n      char c = in.charAt(i);\n      if (c == '&') {\n        sb.append(\"&amp;\");\n      } else if (c == '\"') {\n        sb.append(\"&quot;\");\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n\n\n  public static String escapeTextAroundXMLTags(String s) {\n    StringBuilder result = new StringBuilder();\n    Reader r = new StringReader(s);\n    try {\n      do {\n        String text = readUntilTag(r);\n        //      System.err.println(\"got text: \" + text);\n        result.append(escapeXML(text));\n        XMLTag tag = readAndParseTag(r);\n        //      System.err.println(\"got tag: \" + tag);\n        if (tag == null) {\n          break;\n        }\n        result.append(tag);\n      } while (true);\n    } catch (IOException e) {\n      log.warn(\"Error reading string\");\n      log.warn(e);\n    }\n    return result.toString();\n  }\n\n  /**\n   * return either the first space or the first nbsp\n   */\n  public static int findSpace(String haystack, int begin) {\n    int space = haystack.indexOf(' ', begin);\n    int nbsp = haystack.indexOf('\\u00A0', begin);\n    if (space == -1 && nbsp == -1) {\n      return -1;\n    } else if (space >= 0 && nbsp >= 0) {\n      return Math.min(space, nbsp);\n    } else {\n      // eg one is -1, and the other is >= 0\n      return Math.max(space, nbsp);\n    }\n  }\n\n  public static class XMLTag {\n\n    /** Stores the complete string passed in as the tag on construction. */\n    public String text;\n\n    /** Stores the element name, such as \"doc\". */\n    public String name;\n\n    /** Stores attributes as a Map from keys to values. */\n    public Map<String,String> attributes;\n\n    /** Whether this is an ending tag or not. */\n    public boolean isEndTag;\n\n    /** Whether this is an empty element expressed as a single empty element tag like {@code <p/>}. */\n    public boolean isSingleTag;\n\n    /**\n     * Assumes that String contains an XML tag.\n     *\n     * @param tag String to turn into an XMLTag object\n     */\n    public XMLTag(String tag) {\n      if (tag == null || tag.isEmpty()) {\n        throw new NullPointerException(\"Attempted to parse empty/null tag\");\n      }\n      if (tag.charAt(0) != '<') {\n        throw new IllegalArgumentException(\"Tag did not start with <\");\n      }\n      if (tag.charAt(tag.length() - 1) != '>') {\n        throw new IllegalArgumentException(\"Tag did not end with >\");\n      }\n      text = tag;\n      int begin = 1;\n      if (tag.charAt(1) == '/') {\n        begin = 2;\n        isEndTag = true;\n      } else {\n        isEndTag = false;\n      }\n      int end = tag.length() - 1;\n      if (tag.charAt(tag.length() - 2) == '/') {\n        end = tag.length() - 2;\n        isSingleTag = true;\n      } else {\n        isSingleTag = false;\n      }\n      tag = tag.substring(begin, end);\n      attributes = Generics.newHashMap();\n      begin = 0;\n      end = findSpace(tag, 0);\n\n      if (end < 0) {\n        name = tag;\n      } else {\n        name = tag.substring(begin, end);\n        do {\n          begin = end + 1;\n          while (begin < tag.length() && tag.charAt(begin) < 0x21) {\n            begin++; // get rid of leading whitespace\n          }\n          if (begin == tag.length()) {\n            break;\n          }\n          end = tag.indexOf('=', begin);\n          if (end < 0) {\n            String att = tag.substring(begin);\n            attributes.put(att, \"\");\n            break;\n          }\n          String att = tag.substring(begin, end).trim();\n          begin = end + 1;\n          String value = null;\n          if (tag.length() > begin) {\n            while (begin < tag.length() && tag.charAt(begin) < 0x21) {\n              begin++;\n            }\n            if (begin < tag.length() && tag.charAt(begin) == '\\\"') {\n              // get quoted expression\n              begin++;\n              end = tag.indexOf('\\\"', begin);\n              if (end < 0) {\n                break; // this is a problem\n              }\n              value = tag.substring(begin, end);\n              end++;\n            } else {\n              // get unquoted expression\n              end = findSpace(tag, begin);\n              if (end < 0) {\n                end = tag.length();\n              }\n//              System.err.println(begin + \" \" + end);\n              value = tag.substring(begin, end);\n            }\n          }\n          attributes.put(att, value);\n        } while (end < tag.length() - 3);\n      }\n    }\n\n    public String toString() {\n      return text;\n    }\n\n    /**\n     * Given a list of attributes, return the first one that is non-null\n     */\n    public String getFirstNonNullAttributeFromList(List<String> attributesList) {\n      for (String attribute : attributesList) {\n        if (attributes.get(attribute) != null) {\n          return attributes.get(attribute);\n        }\n      }\n      return null;\n    }\n  } // end static class XMLTag\n\n\n  /**\n   * Reads all text of the XML tag and returns it as a String.\n   * Assumes that a '<' character has already been read.\n   *\n   * @param r The reader to read from\n   * @return The String representing the tag, or null if one couldn't be read\n   *         (i.e., EOF).  The returned item is a complete tag including angle\n   *         brackets, such as {@code <TXT>}\n   */\n  public static String readTag(Reader r) throws IOException {\n    if ( ! r.ready()) {\n      return null;\n    }\n    StringBuilder b = new StringBuilder(\"<\");\n    int c = r.read();\n    while (c >= 0) {\n      b.append((char) c);\n      if (c == '>') {\n        break;\n      }\n      c = r.read();\n    }\n    if (b.length() == 1) {\n      return null;\n    }\n    return b.toString();\n  }\n\n  public static XMLTag parseTag(String tagString) {\n    if (tagString == null || tagString.isEmpty()) {\n      return null;\n    }\n    if (tagString.charAt(0) != '<' ||\n        tagString.charAt(tagString.length() - 1) != '>') {\n      return null;\n    }\n    return new XMLTag(tagString);\n  }\n\n  public static Document readDocumentFromFile(String filename) throws Exception {\n    InputSource in = new InputSource(new FileReader(filename));\n    DocumentBuilderFactory factory = safeDocumentBuilderFactory();\n\n    factory.setNamespaceAware(false);\n    DocumentBuilder db = factory.newDocumentBuilder();\n    db.setErrorHandler(new SAXErrorHandler());\n    return db.parse(in);\n  }\n\n  private static class SAXErrorHandler implements ErrorHandler {\n\n    public static String makeBetterErrorString(String msg,\n                                               SAXParseException ex) {\n      StringBuilder sb = new StringBuilder(msg);\n      sb.append(\": \");\n      String str = ex.getMessage();\n      if (str.lastIndexOf('.') == str.length() - 1) {\n        str = str.substring(0, str.length() - 1);\n      }\n      sb.append(str);\n      sb.append(\" at document line \").append(ex.getLineNumber());\n      sb.append(\", column \").append(ex.getColumnNumber());\n      if (ex.getSystemId() != null) {\n        sb.append(\" in entity from systemID \").append(ex.getSystemId());\n      } else if (ex.getPublicId() != null) {\n        sb.append(\" in entity from publicID \").append(ex.getPublicId());\n      }\n      sb.append('.');\n      return sb.toString();\n    }\n\n    @Override\n    public void warning(SAXParseException exception) {\n      log.warn(makeBetterErrorString(\"Warning\", exception));\n    }\n\n    @Override\n    public void error(SAXParseException exception) {\n      log.error(makeBetterErrorString(\"Error\", exception));\n    }\n\n    @Override\n    public void fatalError(SAXParseException ex) throws SAXParseException {\n      throw new SAXParseException(makeBetterErrorString(\"Fatal Error\", ex),\n              ex.getPublicId(), ex.getSystemId(), ex.getLineNumber(), ex.getColumnNumber());\n      // throw new RuntimeException(makeBetterErrorString(\"Fatal Error\", ex));\n    }\n\n  } // end class SAXErrorHandler\n\n  public static Document readDocumentFromString(String s) throws Exception {\n    InputSource in = new InputSource(new StringReader(s));\n    DocumentBuilderFactory factory = safeDocumentBuilderFactory();\n    factory.setNamespaceAware(false);\n    return factory.newDocumentBuilder().parse(in);\n  }\n\n  /** Tests a few methods.\n   *  If the first arg is -readDoc then this method tests\n   *  readDocumentFromFile.\n   *  Otherwise, it tests readTag/readUntilTag and slurpFile.\n   */\n  public static void main(String[] args) throws Exception {\n    if (args[0].equals(\"-readDoc\")) {\n      Document doc = readDocumentFromFile(args[1]);\n      System.out.println(doc);\n    } else {\n      String s = IOUtils.slurpFile(args[0]);\n      Reader r = new StringReader(s);\n      String tag = readTag(r);\n      while (tag != null && ! tag.isEmpty()) {\n        readUntilTag(r);\n        tag = readTag(r);\n        if (tag == null || tag.isEmpty()) {\n          break;\n        }\n        System.out.println(\"got tag=\" + new XMLTag(tag));\n      }\n    }\n  }\n\n}\n"], "filenames": ["src/edu/stanford/nlp/util/XMLUtils.java"], "buggy_code_start_loc": [304], "buggy_code_end_loc": [304], "fixing_code_start_loc": [305], "fixing_code_end_loc": [306], "type": "CWE-611", "message": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference", "other": {"cve": {"id": "CVE-2022-0239", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-17T07:15:06.867", "lastModified": "2022-01-22T03:45:26.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference"}, {"lang": "es", "value": "corenlp es vulnerable a una Restricci\u00f3n Inapropiada de una Referencia a Entidades Externas XML"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stanford:corenlp:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.2", "matchCriteriaId": "4A81475F-1CFF-435A-8F67-870478C33758"}]}]}], "references": [{"url": "https://github.com/stanfordnlp/corenlp/commit/1940ffb938dc4f3f5bc5f2a2fd8b35aabbbae3dd", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a717aec2-5646-4a5f-ade0-dadc25736ae3", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stanfordnlp/corenlp/commit/1940ffb938dc4f3f5bc5f2a2fd8b35aabbbae3dd"}}