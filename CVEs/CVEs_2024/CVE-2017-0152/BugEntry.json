{"buggy_code": ["//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n#include \"ParserPch.h\"\n#include \"FormalsUtil.h\"\n#include \"../Runtime/Language/SourceDynamicProfileManager.h\"\n\n#if DBG_DUMP\nvoid PrintPnodeWIndent(ParseNode *pnode,int indentAmt);\n#endif\n\nconst char* const nopNames[knopLim]= {\n#define PTNODE(nop,sn,pc,nk,grfnop,json) sn,\n#include \"ptlist.h\"\n};\nvoid printNop(int nop) {\n  printf(\"%s\\n\",nopNames[nop]);\n}\n\nconst uint ParseNode::mpnopgrfnop[knopLim] =\n{\n#define PTNODE(nop,sn,pc,nk,grfnop,json) grfnop,\n#include \"ptlist.h\"\n};\n\nbool Parser::IsES6DestructuringEnabled() const\n{\n    return m_scriptContext->GetConfig()->IsES6DestructuringEnabled();\n}\n\nstruct DeferredFunctionStub\n{\n    RestorePoint restorePoint;\n    uint fncFlags;\n    uint nestedCount;\n    DeferredFunctionStub *deferredStubs;\n    charcount_t ichMin;\n};\n\nstruct StmtNest\n{\n    union\n    {\n        struct\n        {\n            ParseNodePtr pnodeStmt; // This statement node.\n            ParseNodePtr pnodeLab;  // Labels for this statement.\n        };\n        struct\n        {\n            bool isDeferred : 1;\n            OpCode op;              // This statement operation.\n            LabelId* pLabelId;      // Labels for this statement.\n        };\n    };\n    StmtNest *pstmtOuter;           // Enclosing statement.\n\n    OpCode GetNop() const \n    { \n        AnalysisAssert(isDeferred || pnodeStmt != nullptr);\n        return isDeferred ? op : pnodeStmt->nop; \n    }\n};\n\nstruct BlockInfoStack\n{\n    StmtNest pstmt;\n    ParseNode *pnodeBlock;\n    ParseNodePtr *m_ppnodeLex;              // lexical variable list tail\n    BlockInfoStack *pBlockInfoOuter;        // containing block's BlockInfoStack\n    BlockInfoStack *pBlockInfoFunction;     // nearest function's BlockInfoStack (if pnodeBlock is a function, this points to itself)\n};\n\n#if DEBUG\nParser::Parser(Js::ScriptContext* scriptContext, BOOL strictMode, PageAllocator *alloc, bool isBackground, size_t size)\n#else\nParser::Parser(Js::ScriptContext* scriptContext, BOOL strictMode, PageAllocator *alloc, bool isBackground)\n#endif\n    : m_nodeAllocator(_u(\"Parser\"), alloc ? alloc : scriptContext->GetThreadContext()->GetPageAllocator(), Parser::OutOfMemory),\n    // use the GuestArena directly for keeping the RegexPattern* alive during byte code generation\n    m_registeredRegexPatterns(scriptContext->GetGuestArena())\n{\n    AssertMsg(size == sizeof(Parser), \"verify conditionals affecting the size of Parser agree\");\n    Assert(scriptContext != nullptr);\n    m_isInBackground = isBackground;\n    m_phtbl = nullptr;\n    m_pscan = nullptr;\n    m_deferringAST = FALSE;\n    m_stoppedDeferredParse = FALSE;\n    m_hasParallelJob = false;\n    m_doingFastScan = false;\n    m_scriptContext = scriptContext;\n    m_pCurrentAstSize = nullptr;\n    m_arrayDepth = 0;\n    m_funcInArrayDepth = 0;\n    m_parenDepth = 0;\n    m_funcInArray = 0;\n    m_tryCatchOrFinallyDepth = 0;\n    m_UsesArgumentsAtGlobal = false;\n    m_currentNodeFunc = nullptr;\n    m_currentNodeDeferredFunc = nullptr;\n    m_currentNodeNonLambdaFunc = nullptr;\n    m_currentNodeNonLambdaDeferredFunc = nullptr;\n    m_currentNodeProg = nullptr;\n    m_currDeferredStub = nullptr;\n    m_prevSiblingDeferredStub = nullptr;\n    m_pstmtCur = nullptr;\n    m_currentBlockInfo = nullptr;\n    m_currentScope = nullptr;\n    m_currentDynamicBlock = nullptr;\n    m_grfscr = fscrNil;\n    m_length = 0;\n    m_originalLength = 0;\n    m_nextFunctionId = nullptr;\n    m_errorCallback = nullptr;\n    m_uncertainStructure = FALSE;\n    m_reparsingLambdaParams = false;\n    m_inFIB = false;\n    currBackgroundParseItem = nullptr;\n    backgroundParseItems = nullptr;\n    fastScannedRegExpNodes = nullptr;\n\n    m_fUseStrictMode = strictMode;\n    m_InAsmMode = false;\n    m_deferAsmJs = true;\n    m_scopeCountNoAst = 0;\n    m_fExpectExternalSource = 0;\n\n    m_parseType = ParseType_Upfront;\n\n    m_deferEllipsisError = false;\n    m_hasDeferredShorthandInitError = false;\n    m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperDisallowed;\n}\n\nParser::~Parser(void)\n{\n    if (m_scriptContext == nullptr || m_scriptContext->GetGuestArena() == nullptr)\n    {\n        // If the scriptContext or guestArena have gone away, there is no point clearing each item of this list.\n        // Just reset it so that destructor of the SList will be no-op\n        m_registeredRegexPatterns.Reset();\n    }\n\n    if (this->m_hasParallelJob)\n    {\n#if ENABLE_BACKGROUND_PARSING\n        // Let the background threads know that they can decommit their arena pages.\n        BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n        Assert(bgp);\n        if (bgp->Processor()->ProcessesInBackground())\n        {\n            JsUtil::BackgroundJobProcessor *processor = static_cast<JsUtil::BackgroundJobProcessor*>(bgp->Processor());\n\n            bool result = processor->IterateBackgroundThreads([&](JsUtil::ParallelThreadData *threadData)->bool {\n                threadData->canDecommit = true;\n                return false;\n            });\n            Assert(result);\n        }\n#endif\n    }\n\n    Release();\n\n}\n\nvoid Parser::OutOfMemory()\n{\n    throw ParseExceptionObject(ERRnoMemory);\n}\n\nvoid Parser::Error(HRESULT hr)\n{\n    Assert(FAILED(hr));\n    m_err.Throw(hr);\n}\n\nvoid Parser::Error(HRESULT hr, ParseNodePtr pnode)\n{\n    if (pnode && pnode->ichLim)\n    {\n        Error(hr, pnode->ichMin, pnode->ichLim);\n    }\n    else\n    {\n        Error(hr);\n    }\n}\n\nvoid Parser::Error(HRESULT hr, charcount_t ichMin, charcount_t ichLim)\n{\n    m_pscan->SetErrorPosition(ichMin, ichLim);\n    Error(hr);\n}\n\nvoid Parser::IdentifierExpectedError(const Token& token)\n{\n    Assert(token.tk != tkID);\n\n    HRESULT hr;\n    if (token.IsReservedWord())\n    {\n        if (token.IsKeyword())\n        {\n            hr = ERRKeywordNotId;\n        }\n        else\n        {\n            Assert(token.IsFutureReservedWord(true));\n            if (token.IsFutureReservedWord(false))\n            {\n                // Future reserved word in strict and non-strict modes\n                hr = ERRFutureReservedWordNotId;\n            }\n            else\n            {\n                // Future reserved word only in strict mode. The token would have been converted to tkID by the scanner if not\n                // in strict mode.\n                Assert(IsStrictMode());\n                hr = ERRFutureReservedWordInStrictModeNotId;\n            }\n        }\n    }\n    else\n    {\n        hr = ERRnoIdent;\n    }\n\n    Error(hr);\n}\n\nHRESULT Parser::ValidateSyntax(LPCUTF8 pszSrc, size_t encodedCharCount, bool isGenerator, bool isAsync, CompileScriptException *pse, void (Parser::*validateFunction)())\n{\n    AssertPsz(pszSrc);\n    AssertMemN(pse);\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n\n    HRESULT hr;\n    SmartFPUControl smartFpuControl;\n\n    DebugOnly( m_err.fInited = TRUE; )\n    BOOL fDeferSave = m_deferringAST;\n    try\n    {\n        hr = NOERROR;\n\n        this->PrepareScanner(false);\n\n        m_length = encodedCharCount;\n        m_originalLength = encodedCharCount;\n\n        // make sure deferred parsing is turned off\n        ULONG grfscr = fscrNil;\n\n        // Give the scanner the source and get the first token\n        m_pscan->SetText(pszSrc, 0, encodedCharCount, 0, grfscr);\n        m_pscan->SetYieldIsKeyword(isGenerator);\n        m_pscan->SetAwaitIsKeyword(isAsync);\n        m_pscan->Scan();\n\n        uint nestedCount = 0;\n        m_pnestedCount = &nestedCount;\n\n        ParseNodePtr pnodeScope = nullptr;\n        m_ppnodeScope = &pnodeScope;\n        m_ppnodeExprScope = nullptr;\n\n        uint nextFunctionId = 0;\n        m_nextFunctionId = &nextFunctionId;\n\n        m_inDeferredNestedFunc = false;\n        m_deferringAST = true;\n\n\n\n        m_nextBlockId = 0;\n\n        ParseNode *pnodeFnc = CreateNode(knopFncDecl);\n        pnodeFnc->sxFnc.ClearFlags();\n        pnodeFnc->sxFnc.SetDeclaration(false);\n        pnodeFnc->sxFnc.functionId   = 0;\n        pnodeFnc->sxFnc.astSize      = 0;\n        pnodeFnc->sxFnc.pnodeVars    = nullptr;\n        pnodeFnc->sxFnc.pnodeParams  = nullptr;\n        pnodeFnc->sxFnc.pnodeBody    = nullptr;\n        pnodeFnc->sxFnc.pnodeName    = nullptr;\n        pnodeFnc->sxFnc.pnodeRest    = nullptr;\n        pnodeFnc->sxFnc.deferredStub = nullptr;\n        pnodeFnc->sxFnc.SetIsGenerator(isGenerator);\n        pnodeFnc->sxFnc.SetIsAsync(isAsync);\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n        m_currentNodeFunc = pnodeFnc;\n        m_currentNodeDeferredFunc = NULL;\n        m_sourceContextInfo = nullptr;\n        AssertMsg(m_pstmtCur == NULL, \"Statement stack should be empty when we start parse function body\");\n\n        ParseNodePtr block = StartParseBlock<false>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        (this->*validateFunction)();\n        FinishParseBlock(block);\n\n        pnodeFnc->ichLim = m_pscan->IchLimTok();\n        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        pnodeFnc->sxFnc.pnodeVars = nullptr;\n\n        // there should be nothing after successful parsing for a given construct\n        if (m_token.tk != tkEOF)\n            Error(ERRsyntax);\n\n        RELEASEPTR(m_pscan);\n        m_deferringAST = fDeferSave;\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_deferringAST = fDeferSave;\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan,  m_err.m_hr, /* pnodeBase */ NULL);\n    }\n\n    return hr;\n}\n\nHRESULT Parser::ParseSourceInternal(\n    __out ParseNodePtr* parseTree, LPCUTF8 pszSrc, size_t offsetInBytes, size_t encodedCharCount, charcount_t offsetInChars,\n    bool fromExternal, ULONG grfscr, CompileScriptException *pse, Js::LocalFunctionId * nextFunctionId, ULONG lineNumber, SourceContextInfo * sourceContextInfo)\n{\n    AssertMem(parseTree);\n    AssertPsz(pszSrc);\n    AssertMemN(pse);\n   \n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n\n#ifdef PROFILE_EXEC\n    m_scriptContext->ProfileBegin(Js::ParsePhase);\n#endif\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_START(m_scriptContext,0));\n\n    *parseTree = NULL;\n    m_sourceLim = 0;\n\n    m_grfscr = grfscr;\n    m_sourceContextInfo = sourceContextInfo;\n\n    ParseNodePtr pnodeBase = NULL;\n    HRESULT hr;\n    SmartFPUControl smartFpuControl;\n\n    DebugOnly( m_err.fInited = TRUE; )\n\n    try\n    {\n        this->PrepareScanner(fromExternal);\n\n        if ((grfscr & fscrEvalCode) != 0)\n        {\n            this->m_parsingSuperRestrictionState = Parser::ParsingSuperRestrictionState_SuperPropertyAllowed;\n        }\n\n        if ((grfscr & fscrIsModuleCode) != 0)\n        {\n            // Module source flag should not be enabled unless module is enabled\n            Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n\n            // Module code is always strict mode code.\n            this->m_fUseStrictMode = TRUE;\n        }\n\n        // parse the source\n        pnodeBase = Parse(pszSrc, offsetInBytes, encodedCharCount, offsetInChars, grfscr, lineNumber, nextFunctionId, pse);\n\n        AssertNodeMem(pnodeBase);\n\n        // Record the actual number of words parsed.\n        m_sourceLim = pnodeBase->ichLim - offsetInChars;\n\n        // TODO: The assert can be false positive in some scenarios and chuckj to fix it later\n        // Assert(utf8::ByteIndexIntoCharacterIndex(pszSrc + offsetInBytes, encodedCharCount, fromExternal ? utf8::doDefault : utf8::doAllowThreeByteSurrogates) == m_sourceLim);\n\n#if DBG_DUMP\n        if (Js::Configuration::Global.flags.Trace.IsEnabled(Js::ParsePhase))\n        {\n            PrintPnodeWIndent(pnodeBase,4);\n            fflush(stdout);\n        }\n#endif\n\n        *parseTree = pnodeBase;\n\n        hr = NOERROR;\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan, m_err.m_hr, pnodeBase);\n    }\n\n    if (this->m_hasParallelJob)\n    {\n#if ENABLE_BACKGROUND_PARSING\n        ///// Wait here for remaining jobs to finish. Then look for errors, do final const bindings.\n        // pleath TODO: If there are remaining jobs, let the main thread help finish them.\n        BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n        Assert(bgp);\n\n        CompileScriptException se;\n        this->WaitForBackgroundJobs(bgp, &se);\n\n        BackgroundParseItem *failedItem = bgp->GetFailedBackgroundParseItem();\n        if (failedItem)\n        {\n            CompileScriptException *bgPse = failedItem->GetPSE();\n            Assert(bgPse);\n            *pse = *bgPse;\n            hr = failedItem->GetHR();\n            bgp->SetFailedBackgroundParseItem(nullptr);\n        }\n\n        if (this->fastScannedRegExpNodes != nullptr)\n        {\n            this->FinishBackgroundRegExpNodes();\n        }\n\n        for (BackgroundParseItem *item = this->backgroundParseItems; item; item = item->GetNext())\n        {\n            Parser *parser = item->GetParser();\n            parser->FinishBackgroundPidRefs(item, this != parser);\n        }\n#endif\n    }\n\n    // done with the scanner\n    RELEASEPTR(m_pscan);\n\n#ifdef PROFILE_EXEC\n    m_scriptContext->ProfileEnd(Js::ParsePhase);\n#endif\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_STOP(m_scriptContext, 0));\n    \n    return hr;\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::WaitForBackgroundJobs(BackgroundParser *bgp, CompileScriptException *pse)\n{\n    // The scan of the script is done, but there may be unfinished background jobs in the queue.\n    // Enlist the main thread to help with those.\n    BackgroundParseItem *item;\n    if (!*bgp->GetPendingBackgroundItemsPtr())\n    {\n        // We're done.\n        return;\n    }\n\n    // Save parser state, since we'll need to restore it in order to bind references correctly later.\n    this->m_isInBackground = true;\n    this->SetCurrBackgroundParseItem(nullptr);\n    uint blockIdSave = this->m_nextBlockId;\n    uint functionIdSave = *this->m_nextFunctionId;\n    StmtNest *pstmtSave = this->m_pstmtCur;\n\n    if (!bgp->Processor()->ProcessesInBackground())\n    {\n        // No background thread. Just walk the jobs with no locking and process them.\n        for (item = bgp->GetNextUnprocessedItem(); item; item = bgp->GetNextUnprocessedItem())\n        {\n            bgp->Processor()->RemoveJob(item);\n            bool succeeded = bgp->Process(item, this, pse);\n            bgp->JobProcessed(item, succeeded);\n        }\n        Assert(!*bgp->GetPendingBackgroundItemsPtr());\n    }\n    else\n    {\n        // Background threads. We need to have the critical section in order to:\n        // - Check for unprocessed jobs;\n        // - Remove jobs from the processor queue;\n        // - Do JobsProcessed work (such as removing jobs from the BackgroundParser's unprocessed list).\n        CriticalSection *pcs = static_cast<JsUtil::BackgroundJobProcessor*>(bgp->Processor())->GetCriticalSection();\n        pcs->Enter();\n        for (;;)\n        {\n            // Grab a job (in lock)\n            item = bgp->GetNextUnprocessedItem();\n            if (item == nullptr)\n            {\n                break;\n            }\n            bgp->Processor()->RemoveJob(item);\n            pcs->Leave();\n\n            // Process job (if there is one) (outside lock)\n            bool succeeded = bgp->Process(item, this, pse);\n\n            pcs->Enter();\n            bgp->JobProcessed(item, succeeded);\n        }\n        pcs->Leave();\n\n        // Wait for the background threads to finish jobs they're already processing (if any).\n        // TODO: Replace with a proper semaphore.\n        while(*bgp->GetPendingBackgroundItemsPtr());\n    }\n\n    Assert(!*bgp->GetPendingBackgroundItemsPtr());\n\n    // Restore parser state.\n    this->m_pstmtCur = pstmtSave;\n    this->m_isInBackground = false;\n    this->m_nextBlockId = blockIdSave;\n    *this->m_nextFunctionId = functionIdSave;\n}\n\nvoid Parser::FinishBackgroundPidRefs(BackgroundParseItem *item, bool isOtherParser)\n{\n    for (BlockInfoStack *blockInfo = item->GetParseContext()->currentBlockInfo; blockInfo; blockInfo = blockInfo->pBlockInfoOuter)\n    {\n        if (isOtherParser)\n        {\n            this->BindPidRefs<true>(blockInfo, item->GetMaxBlockId());\n        }\n        else\n        {\n            this->BindPidRefs<false>(blockInfo, item->GetMaxBlockId());\n        }\n    }\n}\n\nvoid Parser::FinishBackgroundRegExpNodes()\n{\n    // We have a list of RegExp nodes that we saw on the UI thread in functions we're parallel parsing,\n    // and for each background job we have a list of RegExp nodes for which we couldn't allocate patterns.\n    // We need to copy the pattern pointers from the UI thread nodes to the corresponding nodes on the\n    // background nodes.\n    // There may be UI thread nodes for which there are no background thread equivalents, because the UI thread\n    // has to assume that the background thread won't defer anything.\n\n    // Note that because these lists (and the list of background jobs) are SList's built by prepending, they are\n    // all in reverse lexical order.\n\n    Assert(!this->IsBackgroundParser());\n    Assert(this->fastScannedRegExpNodes);\n    Assert(this->backgroundParseItems != nullptr);\n\n    BackgroundParseItem *currBackgroundItem;\n\n#if DBG\n    for (currBackgroundItem = this->backgroundParseItems;\n         currBackgroundItem;\n         currBackgroundItem = currBackgroundItem->GetNext())\n    {\n        if (currBackgroundItem->RegExpNodeList())\n        {\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnode, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnode->sxPid.regexPattern == nullptr);\n            }\n            NEXT_DLIST_ENTRY;\n        }\n    }\n#endif\n\n    // Hook up the patterns allocated on the main thread to the nodes created on the background thread.\n    // Walk the list of foreground nodes, advancing through the work items and looking up each item.\n    // Note that the background thread may have chosen to defer a given RegEx literal, so not every foreground\n    // node will have a matching background node. Doesn't matter for correctness.\n    // (It's inefficient, of course, to have to restart the inner loop from the beginning of the work item's\n    // list, but it should be unusual to have many RegExes in a single work item's chunk of code. Figure out how\n    // to start the inner loop from a known internal node within the list if that turns out to be important.)\n    currBackgroundItem = this->backgroundParseItems;\n    FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnodeFgnd, this->fastScannedRegExpNodes)\n    {\n        Assert(pnodeFgnd->nop == knopRegExp);\n        Assert(pnodeFgnd->sxPid.regexPattern != nullptr);\n        bool quit = false;\n\n        while (!quit)\n        {\n            // Find the next work item with a RegEx in it.\n            while (currBackgroundItem && currBackgroundItem->RegExpNodeList() == nullptr)\n            {\n                currBackgroundItem = currBackgroundItem->GetNext();\n            }\n            if (!currBackgroundItem)\n            {\n                break;\n            }\n\n            // Walk the RegExps in the work item.\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnodeBgnd, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnodeBgnd->nop == knopRegExp);\n\n                if (pnodeFgnd->ichMin <= pnodeBgnd->ichMin)\n                {\n                    // Either we found a match, or the next background node is past the foreground node.\n                    // In any case, we can stop searching.\n                    if (pnodeFgnd->ichMin == pnodeBgnd->ichMin)\n                    {\n                        Assert(pnodeFgnd->ichLim == pnodeBgnd->ichLim);\n                        pnodeBgnd->sxPid.regexPattern = pnodeFgnd->sxPid.regexPattern;\n                    }\n                    quit = true;\n                    break;\n                }\n            }\n            NEXT_DLIST_ENTRY;\n\n            if (!quit)\n            {\n                // Need to advance to the next work item.\n                currBackgroundItem = currBackgroundItem->GetNext();\n            }\n        }\n    }\n    NEXT_DLIST_ENTRY;\n\n#if DBG\n    for (currBackgroundItem = this->backgroundParseItems;\n         currBackgroundItem;\n         currBackgroundItem = currBackgroundItem->GetNext())\n    {\n        if (currBackgroundItem->RegExpNodeList())\n        {\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnode, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnode->sxPid.regexPattern != nullptr);\n            }\n            NEXT_DLIST_ENTRY;\n        }\n    }\n#endif\n}\n#endif\n\nLabelId* Parser::CreateLabelId(IdentToken* pToken)\n{\n    LabelId* pLabelId;\n\n    pLabelId = (LabelId*)m_nodeAllocator.Alloc(sizeof(LabelId));\n    if (NULL == pLabelId)\n        Error(ERRnoMemory);\n    pLabelId->pid = pToken->pid;\n    pLabelId->next = NULL;\n\n    return pLabelId;\n}\n\n/*****************************************************************************\nThe following set of routines allocate parse tree nodes of various kinds.\nThey catch an exception on out of memory.\n*****************************************************************************/\nstatic const int g_mpnopcbNode[] =\n{\n#define PTNODE(nop,sn,pc,nk,ok,json) kcbPn##nk,\n#include \"ptlist.h\"\n};\n\nconst Js::RegSlot NoRegister = (Js::RegSlot)-1;\nconst Js::RegSlot OneByteRegister = (Js::RegSlot_OneByte)-1;\n\nvoid Parser::InitNode(OpCode nop,ParseNodePtr pnode) {\n    pnode->nop = nop;\n    pnode->grfpn = PNodeFlags::fpnNone;\n    pnode->location = NoRegister;\n    pnode->emitLabels = false;\n    pnode->isUsed = true;\n    pnode->notEscapedUse = false;\n    pnode->isInList = false;\n    pnode->isCallApplyTargetLoad = false;\n}\n\n// Create nodes using Arena\nParseNodePtr\nParser::StaticCreateBlockNode(ArenaAllocator* alloc, charcount_t ichMin , charcount_t ichLim, int blockId, PnodeBlockType blockType)\n{\n    ParseNodePtr pnode = StaticCreateNodeT<knopBlock>(alloc, ichMin, ichLim);\n    InitBlockNode(pnode, blockId, blockType);\n    return pnode;\n}\n\nvoid Parser::InitBlockNode(ParseNodePtr pnode, int blockId, PnodeBlockType blockType)\n{\n    Assert(pnode->nop == knopBlock);\n    pnode->sxBlock.pnodeScopes = nullptr;\n    pnode->sxBlock.pnodeNext = nullptr;\n    pnode->sxBlock.scope = nullptr;\n    pnode->sxBlock.enclosingBlock = nullptr;\n    pnode->sxBlock.pnodeLexVars = nullptr;\n    pnode->sxBlock.pnodeStmt = nullptr;\n    pnode->sxBlock.pnodeLastValStmt = nullptr;\n\n    pnode->sxBlock.callsEval = false;\n    pnode->sxBlock.childCallsEval = false;\n    pnode->sxBlock.blockType = blockType;\n    pnode->sxBlock.blockId = blockId;\n\n    if (blockType != PnodeBlockType::Regular)\n    {\n        pnode->grfpn |= PNodeFlags::fpnSyntheticNode;\n    }\n}\n\n// Create Node with limit\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeT(charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = StaticCreateNodeT<nop>(&m_nodeAllocator, ichMin, ichLim);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += GetNodeSize<nop>();\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateDeclNode(OpCode nop, IdentPtr pid, SymbolType symbolType, bool errorOnRedecl, bool *isRedecl)\n{\n    ParseNodePtr pnode = CreateNode(nop);\n\n    pnode->sxVar.InitDeclNode(pid, NULL);\n\n    if (symbolType != STUnknown)\n    {\n        pnode->sxVar.sym = AddDeclForPid(pnode, pid, symbolType, errorOnRedecl, isRedecl);\n    }\n\n    return pnode;\n}\n\nSymbol* Parser::AddDeclForPid(ParseNodePtr pnode, IdentPtr pid, SymbolType symbolType, bool errorOnRedecl, bool *isRedecl)\n{\n    Assert(pnode->IsVarLetOrConst());\n\n    PidRefStack *refForUse = nullptr, *refForDecl = nullptr;\n\n    if (isRedecl)\n    {\n        *isRedecl = false;\n    }\n\n    BlockInfoStack *blockInfo;\n    bool fBlockScope = false;\n    if (pnode->nop != knopVarDecl || symbolType == STFunction)\n    {\n        Assert(m_pstmtCur);\n        if (m_pstmtCur->GetNop() != knopBlock)\n        {\n            // Let/const declared in a bare statement context.\n            Error(ERRDeclOutOfStmt);\n        }\n\n        if (m_pstmtCur->pstmtOuter && m_pstmtCur->pstmtOuter->GetNop() == knopSwitch)\n        {\n            // Let/const declared inside a switch block (requiring conservative use-before-decl check).\n            pnode->sxVar.isSwitchStmtDecl = true;\n        }\n\n        fBlockScope = pnode->nop != knopVarDecl ||\n            (\n                !GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope ||\n                GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock\n                );\n    }\n    if (fBlockScope)\n    {\n        blockInfo = GetCurrentBlockInfo();\n    }\n    else\n    {\n        blockInfo = GetCurrentFunctionBlockInfo();\n    }\n\n    // If we are creating an 'arguments' Sym at function block scope, create it in\n    // the parameter scope instead. That way, if we need to reuse the Sym for the\n    // actual arguments object at the end of the function, we don't need to move it\n    // into the parameter scope.\n    if (pid == wellKnownPropertyPids.arguments\n        && pnode->nop == knopVarDecl\n        && blockInfo->pnodeBlock->sxBlock.blockType == PnodeBlockType::Function\n        && blockInfo->pBlockInfoOuter != nullptr\n        && blockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter\n        && blockInfo->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_FuncExpr\n        && blockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.scope->GetCanMergeWithBodyScope())\n    {\n        blockInfo = blockInfo->pBlockInfoOuter;\n    }\n\n    refForDecl = this->FindOrAddPidRef(pid, blockInfo->pnodeBlock->sxBlock.blockId, GetCurrentFunctionNode()->sxFnc.functionId);\n\n    if (refForDecl == nullptr)\n    {\n        Error(ERRnoMemory);\n    }\n\n    if (refForDecl->funcId != GetCurrentFunctionNode()->sxFnc.functionId)\n    {\n        // Fix up the function id, which is incorrect if we're reparsing lambda parameters\n        Assert(this->m_reparsingLambdaParams);\n        refForDecl->funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    }\n    \n    if (blockInfo == GetCurrentBlockInfo())\n    {\n        refForUse = refForDecl;\n    }\n    else\n    {\n        refForUse = this->PushPidRef(pid);\n    }\n    pnode->sxVar.symRef = refForUse->GetSymRef();\n    Symbol *sym = refForDecl->GetSym();\n    if (sym != nullptr)\n    {\n        if (isRedecl)\n        {\n            *isRedecl = true;\n        }\n        // Multiple declarations in the same scope. 3 possibilities: error, existing one wins, new one wins.\n        switch (pnode->nop)\n        {\n        case knopLetDecl:\n        case knopConstDecl:\n            if (!sym->GetDecl()->sxVar.isBlockScopeFncDeclVar)\n            {\n                Assert(errorOnRedecl);\n                // Redeclaration error.\n                Error(ERRRedeclaration);\n            }\n            else\n            {\n                // (New) let/const hides the (old) var\n                sym->SetSymbolType(symbolType);\n                sym->SetDecl(pnode);\n            }\n            break;\n        case knopVarDecl:\n            if (m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                // If this is a parameter list, mark the scope to indicate that it has duplicate definition.\n                // If later this turns out to be a non-simple param list (like function f(a, a, c = 1) {}) then it is a SyntaxError to have duplicate formals.\n                m_currentScope->SetHasDuplicateFormals();\n            }\n\n            if (sym->GetDecl() == nullptr)\n            {\n                Assert(symbolType == STFunction);\n                sym->SetDecl(pnode);\n                break;\n            }\n            switch (sym->GetDecl()->nop)\n            {\n            case knopLetDecl:\n            case knopConstDecl:\n                // Destructuring made possible to have the formals to be the let bind. But that shouldn't throw the error.\n                if (errorOnRedecl && (!IsES6DestructuringEnabled() || sym->GetSymbolType() != STFormal))\n                {\n                    Error(ERRRedeclaration);\n                }\n                // If !errorOnRedecl, (old) let/const hides the (new) var, so do nothing.\n                break;\n            case knopVarDecl:\n                // Legal redeclaration. Who wins?\n                if (errorOnRedecl || sym->GetDecl()->sxVar.isBlockScopeFncDeclVar)\n                {\n                    if (symbolType == STFormal ||\n                        (symbolType == STFunction && sym->GetSymbolType() != STFormal) ||\n                        sym->GetSymbolType() == STVariable)\n                    {\n                        // New decl wins.\n                        sym->SetSymbolType(symbolType);\n                        sym->SetDecl(pnode);\n                    }\n                }\n                break;\n            }\n            break;\n        }\n    }\n    else\n    {\n        Scope *scope = blockInfo->pnodeBlock->sxBlock.scope;\n        if (scope == nullptr)\n        {\n            Assert(blockInfo->pnodeBlock->sxBlock.blockType == PnodeBlockType::Regular);\n            scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, ScopeType_Block);\n            if (this->IsCurBlockInLoop())\n            {\n                scope->SetIsBlockInLoop();\n            }\n            blockInfo->pnodeBlock->sxBlock.scope = scope;\n            PushScope(scope);\n        }\n\n        if (scope->GetScopeType() == ScopeType_GlobalEvalBlock)\n        {\n            Assert(fBlockScope);\n            Assert(scope->GetEnclosingScope() == m_currentNodeProg->sxProg.scope);\n            // Check for same-named decl in Global scope.\n            PidRefStack *pidRefOld = pid->GetPidRefForScopeId(0);\n            if (pidRefOld && pidRefOld->GetSym())\n            {\n                Error(ERRRedeclaration);\n            }\n        }\n        else if (scope->GetScopeType() == ScopeType_Global && (this->m_grfscr & fscrEvalCode) &&\n                 !(m_functionBody && m_functionBody->GetScopeInfo()))\n        {\n            // Check for same-named decl in GlobalEvalBlock scope. Note that this is not necessary\n            // if we're compiling a deferred nested function and the global scope was restored from cached info,\n            // because in that case we don't need a GlobalEvalScope.\n            Assert(!fBlockScope || (this->m_grfscr & fscrConsoleScopeEval) == fscrConsoleScopeEval);\n            PidRefStack *pidRefOld = pid->GetPidRefForScopeId(1);\n            if (pidRefOld && pidRefOld->GetSym())\n            {\n                Error(ERRRedeclaration);\n            }\n        }\n\n        if ((scope->GetScopeType() == ScopeType_FunctionBody || scope->GetScopeType() == ScopeType_Parameter) && symbolType != STFunction)\n        {\n            ParseNodePtr pnodeFnc = GetCurrentFunctionNode();\n            AnalysisAssert(pnodeFnc);\n            if (pnodeFnc->sxFnc.pnodeName &&\n                pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl &&\n                pnodeFnc->sxFnc.pnodeName->sxVar.pid == pid)\n            {\n                // Named function expression has its name hidden by a local declaration.\n                // This is important to know if we don't know whether nested deferred functions refer to it,\n                // because if the name has a non-local reference then we have to create a scope object.\n                m_currentNodeFunc->sxFnc.SetNameIsHidden();\n            }\n        }\n\n        if (!sym)\n        {\n            const char16 *name = reinterpret_cast<const char16*>(pid->Psz());\n            int nameLength = pid->Cch();\n            SymbolName const symName(name, nameLength);\n\n            Assert(!scope->FindLocalSymbol(symName));\n            sym = Anew(&m_nodeAllocator, Symbol, symName, pnode, symbolType);\n            scope->AddNewSymbol(sym);\n            sym->SetPid(pid);\n        }\n        refForDecl->SetSym(sym);\n    }\n    return sym;\n}\n\nbool Parser::IsCurBlockInLoop() const\n{\n    for (StmtNest *stmt = this->m_pstmtCur; stmt != nullptr; stmt = stmt->pstmtOuter)\n    {\n        OpCode nop = stmt->GetNop();\n        if (ParseNode::Grfnop(nop) & fnopContinue)\n        {\n            return true;\n        }\n        if (nop == knopFncDecl)\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nvoid Parser::RestorePidRefForSym(Symbol *sym)\n{\n    IdentPtr pid = m_pscan->m_phtbl->PidHashNameLen(sym->GetName().GetBuffer(), sym->GetName().GetLength());\n    Assert(pid);\n    sym->SetPid(pid);\n    PidRefStack *ref = this->PushPidRef(pid);\n    ref->SetSym(sym);\n}\n\nIdentPtr Parser::PidFromNode(ParseNodePtr pnode)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return pnode->sxPid.pid;\n\n        case knopVarDecl:\n            return pnode->sxVar.pid;\n\n        case knopDot:\n            Assert(pnode->sxBin.pnode2->nop == knopName);\n            return pnode->sxBin.pnode2->sxPid.pid;\n\n        case knopComma:\n            // Advance to the RHS and iterate.\n            pnode = pnode->sxBin.pnode2;\n            break;\n\n        default:\n            return nullptr;\n        }\n    }\n}\n\n#if DBG\nvoid VerifyNodeSize(OpCode nop, int size)\n{\n    Assert(nop >= 0 && nop < knopLim);\n    __analysis_assume(nop < knopLim);\n    Assert(g_mpnopcbNode[nop] == size);\n}\n#endif\n\nParseNodePtr Parser::StaticCreateBinNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2,ArenaAllocator* alloc)\n{\n    DebugOnly(VerifyNodeSize(nop, kcbPnBin));\n    ParseNodePtr pnode = (ParseNodePtr)alloc->Alloc(kcbPnBin);\n    InitNode(nop, pnode);\n\n    pnode->sxBin.pnodeNext = nullptr;\n    pnode->sxBin.pnode1 = pnode1;\n    pnode->sxBin.pnode2 = pnode2;\n\n    // Statically detect if the add is a concat\n    if (!PHASE_OFF1(Js::ByteCodeConcatExprOptPhase))\n    {\n        // We can't flatten the concat expression if the LHS is not a flatten concat already\n        // e.g.  a + (<str> + b)\n        //      Side effect of ToStr(b) need to happen first before ToStr(a)\n        //      If we flatten the concat expression, we will do ToStr(a) before ToStr(b)\n        if ((nop == knopAdd) && (pnode1->CanFlattenConcatExpr() || pnode2->nop == knopStr))\n        {\n            pnode->grfpn |= fpnCanFlattenConcatExpr;\n        }\n    }\n\n    return pnode;\n}\n\n// Create nodes using parser allocator\n\nParseNodePtr Parser::CreateNode(OpCode nop, charcount_t ichMin)\n{\n    bool nodeAllowed = IsNodeAllowedInCurrentDeferralState(nop);\n    Assert(nodeAllowed);\n\n    Assert(nop >= 0 && nop < knopLim);\n    ParseNodePtr pnode;\n    int cb = (nop >= knopNone && nop < knopLim) ? g_mpnopcbNode[nop] : g_mpnopcbNode[knopEmpty];\n\n    pnode = (ParseNodePtr)m_nodeAllocator.Alloc(cb);\n    Assert(pnode != nullptr);\n\n    if (!m_deferringAST)\n    {\n        Assert(m_pCurrentAstSize != nullptr);\n        *m_pCurrentAstSize += cb;\n    }\n\n    InitNode(nop,pnode);\n\n    // default - may be changed\n    pnode->ichMin = ichMin;\n    if (m_pscan!= nullptr) {\n      pnode->ichLim = m_pscan->IchLimTok();\n    }\n    else pnode->ichLim=0;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateUniNode(OpCode nop, ParseNodePtr pnode1)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnUni));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnUni);\n\n    Assert(m_pCurrentAstSize != nullptr);\n    *m_pCurrentAstSize += kcbPnUni;\n\n    InitNode(nop, pnode);\n\n    pnode->sxUni.pnode1 = pnode1;\n    if (nullptr == pnode1)\n    {\n        // no ops\n        pnode->ichMin = m_pscan->IchMinTok();\n        pnode->ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        // 1 op\n        pnode->ichMin = pnode1->ichMin;\n        pnode->ichLim = pnode1->ichLim;\n        this->CheckArguments(pnode);\n    }\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBinNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2)\n{\n    Assert(!this->m_deferringAST);\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        // no ops\n        Assert(nullptr == pnode2);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        if (nullptr == pnode2)\n        {\n            // 1 op\n            ichMin = pnode1->ichMin;\n            ichLim = pnode1->ichLim;\n        }\n        else\n        {\n            // 2 ops\n            ichMin = pnode1->ichMin;\n            ichLim = pnode2->ichLim;\n            if (nop != knopDot && nop != knopIndex)\n            {\n                this->CheckArguments(pnode2);\n            }\n        }\n        if (nop != knopDot && nop != knopIndex)\n        {\n            this->CheckArguments(pnode1);\n        }\n    }\n\n    return CreateBinNode(nop, pnode1, pnode2, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateTriNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2, ParseNodePtr pnode3)\n{\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        // no ops\n        Assert(nullptr == pnode2);\n        Assert(nullptr == pnode3);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else if (nullptr == pnode2)\n    {\n        // 1 op\n        Assert(nullptr == pnode3);\n        ichMin = pnode1->ichMin;\n        ichLim = pnode1->ichLim;\n    }\n    else if (nullptr == pnode3)\n    {\n        // 2 op\n        ichMin = pnode1->ichMin;\n        ichLim = pnode2->ichLim;\n    }\n    else\n    {\n        // 3 ops\n        ichMin = pnode1->ichMin;\n        ichLim = pnode3->ichLim;\n    }\n\n    return CreateTriNode(nop, pnode1, pnode2, pnode3, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateBlockNode(charcount_t ichMin,charcount_t ichLim, PnodeBlockType blockType)\n{\n    return StaticCreateBlockNode(&m_nodeAllocator, ichMin, ichLim, this->m_nextBlockId++, blockType);\n}\n\nParseNodePtr\nParser::CreateCallNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2,charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnCall));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnCall);\n\n    Assert(m_pCurrentAstSize != nullptr);\n    *m_pCurrentAstSize += kcbPnCall;\n\n    InitNode(nop, pnode);\n\n    pnode->sxCall.pnodeTarget = pnode1;\n    pnode->sxCall.pnodeArgs = pnode2;\n    pnode->sxCall.argCount = 0;\n    pnode->sxCall.spreadArgCount = 0;\n    pnode->sxCall.callOfConstants = false;\n    pnode->sxCall.isApplyCall = false;\n    pnode->sxCall.isEvalCall = false;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateStrNode(IdentPtr pid)\n{\n    Assert(!this->m_deferringAST);\n\n    ParseNodePtr pnode = CreateNode(knopStr);\n    pnode->sxPid.pid=pid;\n    pnode->grfpn |= PNodeFlags::fpnCanFlattenConcatExpr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateIntNode(int32 lw)\n{\n    ParseNodePtr pnode = CreateNode(knopInt);\n    pnode->sxInt.lw = lw;\n    return pnode;\n}\n\n// Create Node with scanner limit\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeWithScanner()\n{\n    Assert(m_pscan != nullptr);\n    return CreateNodeWithScanner<nop>(m_pscan->IchMinTok());\n}\n\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeWithScanner(charcount_t ichMin)\n{\n    Assert(m_pscan != nullptr);\n    return CreateNodeT<nop>(ichMin, m_pscan->IchLimTok());\n}\n\nParseNodePtr Parser::CreateProgNodeWithScanner(bool isModuleSource)\n{\n    ParseNodePtr pnodeProg;\n\n    if (isModuleSource)\n    {\n        pnodeProg = CreateNodeWithScanner<knopModule>();\n\n        // knopModule is not actually handled anywhere since we would need to handle it everywhere we could\n        // have knopProg and it would be treated exactly the same except for import/export statements.\n        // We are only using it as a way to get the correct size for PnModule.\n        // Consider: Should we add a flag to PnProg which is false but set to true in PnModule?\n        //           If we do, it can't be a virtual method since the parse nodes are all in a union.\n        pnodeProg->nop = knopProg;\n    }\n    else\n    {\n        pnodeProg = CreateNodeWithScanner<knopProg>();\n    }\n\n    return pnodeProg;\n}\n\nParseNodePtr Parser::CreateCallNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2)\n{\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        Assert(nullptr == pnode2);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        if (nullptr == pnode2)\n        {\n            ichMin = pnode1->ichMin;\n            ichLim = pnode1->ichLim;\n        }\n        else\n        {\n            ichMin = pnode1->ichMin;\n            ichLim = pnode2->ichLim;\n        }\n        if (pnode1->nop == knopDot || pnode1->nop == knopIndex)\n        {\n            this->CheckArguments(pnode1->sxBin.pnode1);\n        }\n    }\n    return CreateCallNode(nop, pnode1, pnode2, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateStrNodeWithScanner(IdentPtr pid)\n{\n    Assert(!this->m_deferringAST);\n\n    ParseNodePtr pnode = CreateNodeWithScanner<knopStr>();\n    pnode->sxPid.pid=pid;\n    pnode->grfpn |= PNodeFlags::fpnCanFlattenConcatExpr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateIntNodeWithScanner(int32 lw)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = CreateNodeWithScanner<knopInt>();\n    pnode->sxInt.lw = lw;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTempNode(ParseNode* initExpr)\n{\n    ParseNodePtr pnode = CreateNode(knopTemp, (charcount_t)0);\n    pnode->sxVar.pnodeInit =initExpr;\n    pnode->sxVar.pnodeNext = nullptr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTempRef(ParseNode* tempNode)\n{\n    ParseNodePtr pnode = CreateUniNode(knopTempRef, tempNode);\n    return pnode;\n}\n\nvoid Parser::CheckPidIsValid(IdentPtr pid, bool autoArgumentsObject)\n{\n    if (IsStrictMode())\n    {\n        // in strict mode, variable named 'eval' cannot be created\n        if (pid == wellKnownPropertyPids.eval)\n        {\n            Error(ERREvalUsage);\n        }\n        else if (pid == wellKnownPropertyPids.arguments && !autoArgumentsObject)\n        {\n            Error(ERRArgsUsage);\n        }\n    }\n}\n\n// CreateVarDecl needs m_ppnodeVar to be pointing to the right function.\n// Post-parsing rewriting during bytecode gen may have m_ppnodeVar pointing to the last parsed function.\n// This function sets up m_ppnodeVar to point to the given pnodeFnc and creates the new var declaration.\n// This prevents accidentally adding var declarations to the last parsed function.\nParseNodePtr Parser::AddVarDeclNode(IdentPtr pid, ParseNodePtr pnodeFnc)\n{\n    AnalysisAssert(pnodeFnc);\n\n    ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n\n    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n    while (*m_ppnodeVar != nullptr)\n    {\n        m_ppnodeVar = &(*m_ppnodeVar)->sxVar.pnodeNext;\n    }\n\n    ParseNodePtr pnode = CreateVarDeclNode(pid, STUnknown, false, 0, /* checkReDecl = */ false);\n\n    m_ppnodeVar = ppnodeVarSave;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateModuleImportDeclNode(IdentPtr localName)\n{\n    ParseNodePtr declNode = CreateBlockScopedDeclNode(localName, knopConstDecl);\n    Symbol* sym = declNode->sxVar.sym;\n\n    sym->SetIsModuleExportStorage(true);\n    sym->SetIsModuleImport(true);\n\n    return declNode;\n}\n\nParseNodePtr Parser::CreateVarDeclNode(IdentPtr pid, SymbolType symbolType, bool autoArgumentsObject, ParseNodePtr pnodeFnc, bool errorOnRedecl, bool *isRedecl)\n{\n    ParseNodePtr pnode = CreateDeclNode(knopVarDecl, pid, symbolType, errorOnRedecl, isRedecl);\n\n    // Append the variable to the end of the current variable list.\n    AssertMem(m_ppnodeVar);\n    pnode->sxVar.pnodeNext = *m_ppnodeVar;\n    *m_ppnodeVar = pnode;\n    if (nullptr != pid)\n    {\n        // this is not a temp - make sure temps go after this node\n        AssertMem(pid);\n        m_ppnodeVar = &pnode->sxVar.pnodeNext;\n        CheckPidIsValid(pid, autoArgumentsObject);\n    }\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBlockScopedDeclNode(IdentPtr pid, OpCode nodeType)\n{\n    Assert(nodeType == knopConstDecl || nodeType == knopLetDecl);\n\n    ParseNodePtr pnode = CreateDeclNode(nodeType, pid, STVariable, true);\n\n    if (nullptr != pid)\n    {\n        AssertMem(pid);\n        pid->SetIsLetOrConst();\n        AddVarDeclToBlock(pnode);\n        CheckPidIsValid(pid);\n    }\n\n    return pnode;\n}\n\nvoid Parser::AddVarDeclToBlock(ParseNode *pnode)\n{\n    Assert(pnode->nop == knopConstDecl || pnode->nop == knopLetDecl);\n\n    // Maintain a combined list of let and const declarations to keep\n    // track of declaration order.\n\n    AssertMem(m_currentBlockInfo->m_ppnodeLex);\n    *m_currentBlockInfo->m_ppnodeLex = pnode;\n    m_currentBlockInfo->m_ppnodeLex = &pnode->sxVar.pnodeNext;\n    pnode->sxVar.pnodeNext = nullptr;\n}\n\nvoid Parser::SetCurrentStatement(StmtNest *stmt)\n{\n    m_pstmtCur = stmt;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlockWithCapacity(PnodeBlockType blockType, ScopeType scopeType, int capacity)\n{\n    Scope *scope = nullptr;\n    // Block scopes are created lazily when we discover block-scoped content.\n    if (scopeType != ScopeType_Unknown && scopeType != ScopeType_Block)\n    {\n        scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, scopeType, capacity);\n        PushScope(scope);\n    }\n\n    return StartParseBlockHelper<buildAST>(blockType, scope, nullptr, nullptr);\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlock(PnodeBlockType blockType, ScopeType scopeType, ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    Scope *scope = nullptr;\n    // Block scopes are created lazily when we discover block-scoped content.\n    if (scopeType != ScopeType_Unknown && scopeType != ScopeType_Block)\n    {\n        scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, scopeType);\n        PushScope(scope);\n    }\n\n    return StartParseBlockHelper<buildAST>(blockType, scope, pnodeLabel, pLabelId);\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlockHelper(PnodeBlockType blockType, Scope *scope, ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    ParseNodePtr pnodeBlock = CreateBlockNode(blockType);\n    pnodeBlock->sxBlock.scope = scope;\n    BlockInfoStack *newBlockInfo = PushBlockInfo(pnodeBlock);\n\n    PushStmt<buildAST>(&newBlockInfo->pstmt, pnodeBlock, knopBlock, pnodeLabel, pLabelId);\n\n    return pnodeBlock;\n}\n\nvoid Parser::PushScope(Scope *scope)\n{\n    Assert(scope);\n    scope->SetEnclosingScope(m_currentScope);\n    m_currentScope = scope;\n}\n\nvoid Parser::PopScope(Scope *scope)\n{\n    Assert(scope == m_currentScope);\n    m_currentScope = scope->GetEnclosingScope();\n    scope->SetEnclosingScope(nullptr);\n}\n\nvoid Parser::PushFuncBlockScope(ParseNodePtr pnodeBlock, ParseNodePtr **ppnodeScopeSave, ParseNodePtr **ppnodeExprScopeSave)\n{\n    // Maintain the scope tree.\n\n    pnodeBlock->sxBlock.pnodeScopes = nullptr;\n    pnodeBlock->sxBlock.pnodeNext = nullptr;\n\n    // Insert this block into the active list of scopes (m_ppnodeExprScope or m_ppnodeScope).\n    // Save the current block's \"next\" pointer as the new endpoint of that list.\n    if (m_ppnodeExprScope)\n    {\n        *ppnodeScopeSave = m_ppnodeScope;\n\n        Assert(*m_ppnodeExprScope == nullptr);\n        *m_ppnodeExprScope = pnodeBlock;\n        *ppnodeExprScopeSave = &pnodeBlock->sxBlock.pnodeNext;\n    }\n    else\n    {\n        Assert(m_ppnodeScope);\n        Assert(*m_ppnodeScope == nullptr);\n        *m_ppnodeScope = pnodeBlock;\n        *ppnodeScopeSave = &pnodeBlock->sxBlock.pnodeNext;\n\n        *ppnodeExprScopeSave = m_ppnodeExprScope;\n    }\n\n    // Advance the global scope list pointer to the new block's child list.\n    m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n    // Set m_ppnodeExprScope to NULL to make that list inactive.\n    m_ppnodeExprScope = nullptr;\n}\n\nvoid Parser::PopFuncBlockScope(ParseNodePtr *ppnodeScopeSave, ParseNodePtr *ppnodeExprScopeSave)\n{\n    Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n    m_ppnodeExprScope = ppnodeExprScopeSave;\n\n    AssertMem(m_ppnodeScope);\n    Assert(nullptr == *m_ppnodeScope);\n    m_ppnodeScope = ppnodeScopeSave;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseBlock(ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    ParseNodePtr pnodeBlock = nullptr;\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n    pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block, pnodeLabel, pLabelId);\n\n    BlockInfoStack* outerBlockInfo = m_currentBlockInfo->pBlockInfoOuter;\n    if (outerBlockInfo != nullptr && outerBlockInfo->pnodeBlock != nullptr\n        && outerBlockInfo->pnodeBlock->sxBlock.scope != nullptr\n        && outerBlockInfo->pnodeBlock->sxBlock.scope->GetScopeType() == ScopeType_CatchParamPattern)\n    {\n        // If we are parsing the catch block then destructured params can have let declrations. Let's add them to the new block.\n        for (ParseNodePtr pnode = m_currentBlockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            PidRefStack* ref = PushPidRef(pnode->sxVar.sym->GetPid());\n            ref->SetSym(pnode->sxVar.sym);\n        }\n    }\n\n    ChkCurTok(tkLCurly, ERRnoLcurly);\n    ParseNodePtr * ppnodeList = nullptr;\n    if (buildAST)\n    {\n        PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        ppnodeList = &pnodeBlock->sxBlock.pnodeStmt;\n    }\n\n    ParseStmtList<buildAST>(ppnodeList);\n\n    if (buildAST)\n    {\n        PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n    }\n\n    FinishParseBlock(pnodeBlock);\n\n    ChkCurTok(tkRCurly, ERRnoRcurly);\n\n\n    return pnodeBlock;\n}\n\nvoid Parser::FinishParseBlock(ParseNode *pnodeBlock, bool needScanRCurly)\n{\n    Assert(m_currentBlockInfo != nullptr && pnodeBlock == m_currentBlockInfo->pnodeBlock);\n\n    if (needScanRCurly)\n    {\n        // Only update the ichLim if we were expecting an RCurly. If there is an\n        // expression body without a necessary RCurly, the correct ichLim will\n        // have been set already.\n        pnodeBlock->ichLim = m_pscan->IchLimTok();\n    }\n\n    BindPidRefs<false>(GetCurrentBlockInfo(), m_nextBlockId - 1);\n\n    PopStmt(&m_currentBlockInfo->pstmt);\n\n    PopBlockInfo();\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (scope)\n    {\n        PopScope(scope);\n    }\n}\n\nvoid Parser::FinishParseFncExprScope(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncExprScope)\n{\n    int fncExprScopeId = pnodeFncExprScope->sxBlock.blockId;\n    ParseNodePtr pnodeName = pnodeFnc->sxFnc.pnodeName;\n    if (pnodeName)\n    {\n        Assert(pnodeName->nop == knopVarDecl);\n        BindPidRefsInScope(pnodeName->sxVar.pid, pnodeName->sxVar.sym, fncExprScopeId);\n    }\n    FinishParseBlock(pnodeFncExprScope);\n}\n\ntemplate <const bool backgroundPidRef>\nvoid Parser::BindPidRefs(BlockInfoStack *blockInfo, uint maxBlockId)\n{\n    // We need to bind all assignments in order to emit assignment to 'const' error\n    int blockId = blockInfo->pnodeBlock->sxBlock.blockId;\n\n    Scope *scope = blockInfo->pnodeBlock->sxBlock.scope;\n    if (scope)\n    {\n        auto bindPidRefs = [blockId, maxBlockId, this](Symbol *sym)\n        {\n            ParseNodePtr pnode = sym->GetDecl();\n            IdentPtr pid;\n#if PROFILE_DICTIONARY\n            int depth = 0;\n#endif\n            Assert(pnode);\n            switch (pnode->nop)\n            {\n            case knopVarDecl:\n            case knopLetDecl:\n            case knopConstDecl:\n                pid = pnode->sxVar.pid;\n                if (backgroundPidRef)\n                {\n                    pid = this->m_pscan->m_phtbl->FindExistingPid(pid->Psz(), pid->Psz() + pid->Cch(), pid->Cch(), pid->Hash(), nullptr, nullptr\n#if PROFILE_DICTIONARY\n                                                                  , depth\n#endif\n                        );\n                    if (pid == nullptr)\n                    {\n                        break;\n                    }\n                }\n                this->BindPidRefsInScope(pid, sym, blockId, maxBlockId);\n                break;\n            case knopName:\n                pid = pnode->sxPid.pid;\n                if (backgroundPidRef)\n                {\n                    pid = this->m_pscan->m_phtbl->FindExistingPid(pid->Psz(), pid->Psz() + pid->Cch(), pid->Cch(), pid->Hash(), nullptr, nullptr\n#if PROFILE_DICTIONARY\n                                                                  , depth\n#endif\n                        );\n                    if (pid == nullptr)\n                    {\n                        break;\n                    }\n                }\n                this->BindPidRefsInScope(pid, sym, blockId, maxBlockId);\n                break;\n            default:\n                Assert(0);\n                break;\n            }\n        };\n\n        scope->ForEachSymbol(bindPidRefs);\n    }\n}\n\nvoid Parser::BindPidRefsInScope(IdentPtr pid, Symbol *sym, int blockId, uint maxBlockId)\n{\n    PidRefStack *ref, *nextRef, *lastRef = nullptr;\n    Js::LocalFunctionId funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    Assert(sym);\n\n    if (pid->GetIsModuleExport())\n    {\n        sym->SetIsModuleExportStorage(true);\n    }\n\n    bool hasFuncAssignment = sym->GetHasFuncAssignment();\n    bool doesEscape = false;\n\n    for (ref = pid->GetTopRef(); ref && ref->GetScopeId() >= blockId; ref = nextRef)\n    {\n        // Fix up sym* on PID ref.\n        Assert(!ref->GetSym() || ref->GetSym() == sym);\n        nextRef = ref->prev;\n        Assert(ref->GetScopeId() >= 0);\n        if ((uint)ref->GetScopeId() > maxBlockId)\n        {\n            lastRef = ref;\n            continue;\n        }\n        ref->SetSym(sym);\n        this->RemovePrevPidRef(pid, lastRef);\n\n        if (ref->IsAssignment())\n        {\n            sym->PromoteAssignmentState();\n            if (m_currentNodeFunc && sym->GetIsFormal())\n            {\n                m_currentNodeFunc->sxFnc.SetHasAnyWriteToFormals(true);                \n            }\n        }\n\n        if (ref->GetFuncScopeId() != funcId && !sym->GetIsGlobal() && !sym->GetIsModuleExportStorage())\n        {\n            Assert(ref->GetFuncScopeId() > funcId);\n            sym->SetHasNonLocalReference();\n        }\n\n        if (ref->IsFuncAssignment())\n        {\n            hasFuncAssignment = true;\n        }\n\n        if (ref->IsEscape())\n        {\n            doesEscape = true;\n        }\n\n        if (m_currentNodeFunc && doesEscape && hasFuncAssignment)\n        {\n            if (m_sourceContextInfo ? \n                    !PHASE_OFF_RAW(Js::DisableStackFuncOnDeferredEscapePhase, m_sourceContextInfo->sourceContextId, m_currentNodeFunc->sxFnc.functionId) :\n                    !PHASE_OFF1(Js::DisableStackFuncOnDeferredEscapePhase))\n            {\n                m_currentNodeFunc->sxFnc.SetNestedFuncEscapes();\n            }\n        }\n\n        if (ref->GetScopeId() == blockId)\n        {\n            break;\n        }\n    }\n}\n\nvoid Parser::MarkEscapingRef(ParseNodePtr pnode, IdentToken *pToken)\n{\n    if (m_currentNodeFunc == nullptr)\n    {\n        return;\n    }\n    if (pnode && pnode->nop == knopFncDecl)\n    {\n        this->SetNestedFuncEscapes();\n    }\n    else if (pToken->pid)\n    {\n        PidRefStack *pidRef = pToken->pid->GetTopRef();\n        if (pidRef->sym)\n        {\n            if (pidRef->sym->GetSymbolType() == STFunction)\n            {\n                this->SetNestedFuncEscapes();\n            }\n        }\n        else\n        {\n            pidRef->isEscape = true;\n        }\n    }\n}\n\nvoid Parser::SetNestedFuncEscapes() const\n{\n    if (m_sourceContextInfo ? \n            !PHASE_OFF_RAW(Js::DisableStackFuncOnDeferredEscapePhase, m_sourceContextInfo->sourceContextId, m_currentNodeFunc->sxFnc.functionId) :\n            !PHASE_OFF1(Js::DisableStackFuncOnDeferredEscapePhase))\n    {\n        m_currentNodeFunc->sxFnc.SetNestedFuncEscapes();\n    }\n}\n\nvoid Parser::PopStmt(StmtNest *pStmt)\n{\n    Assert(pStmt == m_pstmtCur);\n    SetCurrentStatement(m_pstmtCur->pstmtOuter);\n}\n\nBlockInfoStack *Parser::PushBlockInfo(ParseNodePtr pnodeBlock)\n{\n    BlockInfoStack *newBlockInfo = (BlockInfoStack *)m_nodeAllocator.Alloc(sizeof(BlockInfoStack));\n    Assert(nullptr != newBlockInfo);\n\n    newBlockInfo->pnodeBlock = pnodeBlock;\n    newBlockInfo->pBlockInfoOuter = m_currentBlockInfo;\n    newBlockInfo->m_ppnodeLex = &pnodeBlock->sxBlock.pnodeLexVars;\n\n    if (pnodeBlock->sxBlock.blockType != PnodeBlockType::Regular)\n    {\n        newBlockInfo->pBlockInfoFunction = newBlockInfo;\n    }\n    else\n    {\n        Assert(m_currentBlockInfo);\n        newBlockInfo->pBlockInfoFunction = m_currentBlockInfo->pBlockInfoFunction;\n    }\n\n    m_currentBlockInfo = newBlockInfo;\n    return newBlockInfo;\n}\n\nvoid Parser::PopBlockInfo()\n{\n    Assert(m_currentBlockInfo);\n    PopDynamicBlock();\n    m_currentBlockInfo = m_currentBlockInfo->pBlockInfoOuter;\n}\n\nvoid Parser::PushDynamicBlock()\n{\n    Assert(GetCurrentBlock());\n    int blockId = GetCurrentBlock()->sxBlock.blockId;\n    if (m_currentDynamicBlock && m_currentDynamicBlock->id == blockId)\n    {\n        return;\n    }\n    BlockIdsStack *info = (BlockIdsStack *)m_nodeAllocator.Alloc(sizeof(BlockIdsStack));\n    if (nullptr == info)\n    {\n        Error(ERRnoMemory);\n    }\n\n    info->id = blockId;\n    info->prev = m_currentDynamicBlock;\n    m_currentDynamicBlock = info;\n}\n\nvoid Parser::PopDynamicBlock()\n{\n    int blockId = GetCurrentDynamicBlockId();\n    if (GetCurrentBlock()->sxBlock.blockId != blockId || blockId == -1)\n    {\n        return;\n    }\n    Assert(m_currentDynamicBlock);\n    for (BlockInfoStack *blockInfo = m_currentBlockInfo; blockInfo; blockInfo = blockInfo->pBlockInfoOuter)\n    {\n        for (ParseNodePtr pnodeDecl = blockInfo->pnodeBlock->sxBlock.pnodeLexVars;\n             pnodeDecl;\n             pnodeDecl = pnodeDecl->sxVar.pnodeNext)\n        {\n            this->SetPidRefsInScopeDynamic(pnodeDecl->sxVar.pid, blockId);\n        }\n    }\n\n    m_currentDynamicBlock = m_currentDynamicBlock->prev;\n}\n\nint Parser::GetCurrentDynamicBlockId() const\n{\n    return m_currentDynamicBlock ? m_currentDynamicBlock->id : -1;\n}\n\nParseNode *Parser::GetCurrentFunctionNode()\n{\n    if (m_currentNodeDeferredFunc != nullptr)\n    {\n        return m_currentNodeDeferredFunc;\n    }\n    else if (m_currentNodeFunc != nullptr)\n    {\n        return m_currentNodeFunc;\n    }\n    else\n    {\n        AssertMsg(GetFunctionBlock()->sxBlock.blockType == PnodeBlockType::Global,\n            \"Most likely we are trying to find a syntax error, related to 'let' or 'const' in deferred parsing mode with disabled support of 'let' and 'const'\");\n        return m_currentNodeProg;\n    }\n}\n\nParseNode *Parser::GetCurrentNonLambdaFunctionNode()\n{\n    if (m_currentNodeNonLambdaDeferredFunc != nullptr)\n    {\n        return m_currentNodeNonLambdaDeferredFunc;\n    }\n    return m_currentNodeNonLambdaFunc;\n\n}\nvoid Parser::RegisterRegexPattern(UnifiedRegex::RegexPattern *const regexPattern)\n{\n    Assert(regexPattern);\n\n    // ensure a no-throw add behavior here, to catch out of memory exceptions, using the guest arena allocator\n    if (!m_registeredRegexPatterns.PrependNoThrow(m_scriptContext->GetGuestArena(), regexPattern))\n    {\n        Parser::Error(ERRnoMemory);\n    }\n}\n\nvoid Parser::CaptureState(ParserState *state)\n{\n    Assert(state != nullptr);\n\n    state->m_funcInArraySave = m_funcInArray;\n    state->m_funcInArrayDepthSave = m_funcInArrayDepth;\n    state->m_nestedCountSave = *m_pnestedCount;\n    state->m_ppnodeScopeSave = m_ppnodeScope;\n    state->m_ppnodeExprScopeSave = m_ppnodeExprScope;\n    state->m_pCurrentAstSizeSave = m_pCurrentAstSize;\n    state->m_nextBlockId = m_nextBlockId;\n\n    Assert(state->m_ppnodeScopeSave == nullptr || *state->m_ppnodeScopeSave == nullptr);\n    Assert(state->m_ppnodeExprScopeSave == nullptr || *state->m_ppnodeExprScopeSave == nullptr);\n\n#if DEBUG\n    state->m_currentBlockInfo = m_currentBlockInfo;\n#endif\n}\n\nvoid Parser::RestoreStateFrom(ParserState *state)\n{\n    Assert(state != nullptr);\n    Assert(state->m_currentBlockInfo == m_currentBlockInfo);\n\n    m_funcInArray = state->m_funcInArraySave;\n    m_funcInArrayDepth = state->m_funcInArrayDepthSave;\n    *m_pnestedCount = state->m_nestedCountSave;\n    m_pCurrentAstSize = state->m_pCurrentAstSizeSave;\n    m_nextBlockId = state->m_nextBlockId;\n\n    if (state->m_ppnodeScopeSave != nullptr)\n    {\n        *state->m_ppnodeScopeSave = nullptr;\n    }\n\n    if (state->m_ppnodeExprScopeSave != nullptr)\n    {\n        *state->m_ppnodeExprScopeSave = nullptr;\n    }\n\n    m_ppnodeScope = state->m_ppnodeScopeSave;\n    m_ppnodeExprScope = state->m_ppnodeExprScopeSave;\n}\n\nvoid Parser::AddToNodeListEscapedUse(ParseNode ** ppnodeList, ParseNode *** pppnodeLast,\n                           ParseNode * pnodeAdd)\n{\n    AddToNodeList(ppnodeList, pppnodeLast, pnodeAdd);\n    pnodeAdd->SetIsInList();\n}\n\nvoid Parser::AddToNodeList(ParseNode ** ppnodeList, ParseNode *** pppnodeLast,\n                           ParseNode * pnodeAdd)\n{\n    Assert(!this->m_deferringAST);\n    if (nullptr == *pppnodeLast)\n    {\n        // should be an empty list\n        Assert(nullptr == *ppnodeList);\n\n        *ppnodeList = pnodeAdd;\n        *pppnodeLast = ppnodeList;\n    }\n    else\n    {\n        //\n        AssertNodeMem(*ppnodeList);\n        AssertNodeMem(**pppnodeLast);\n\n        ParseNode *pnodeT = CreateBinNode(knopList, **pppnodeLast, pnodeAdd);\n        **pppnodeLast = pnodeT;\n        *pppnodeLast = &pnodeT->sxBin.pnode2;\n    }\n}\n\n// Check reference to \"arguments\" that indicates the object may escape.\nvoid Parser::CheckArguments(ParseNodePtr pnode)\n{\n    if (m_currentNodeFunc && this->NodeIsIdent(pnode, wellKnownPropertyPids.arguments))\n    {\n        m_currentNodeFunc->sxFnc.SetHasHeapArguments();\n    }\n}\n\n// Check use of \"arguments\" that requires instantiation of the object.\nvoid Parser::CheckArgumentsUse(IdentPtr pid, ParseNodePtr pnodeFnc)\n{\n    if (pid == wellKnownPropertyPids.arguments)\n    {\n        if (pnodeFnc != nullptr && pnodeFnc != m_currentNodeProg)\n        {\n            pnodeFnc->sxFnc.SetUsesArguments(TRUE);\n        }\n        else\n        {\n            m_UsesArgumentsAtGlobal = true;\n        }\n    }\n}\n\nvoid Parser::CheckStrictModeEvalArgumentsUsage(IdentPtr pid, ParseNodePtr pnode)\n{\n    if (pid != nullptr)\n    {\n        // In strict mode, 'eval' / 'arguments' cannot be assigned to.\n        if ( pid == wellKnownPropertyPids.eval)\n        {\n            Error(ERREvalUsage, pnode);\n        }\n\n        if (pid == wellKnownPropertyPids.arguments)\n        {\n            Error(ERRArgsUsage, pnode);\n        }\n    }\n}\n\nvoid Parser::ReduceDeferredScriptLength(size_t chars)\n{\n    // If we're in deferred mode, subtract the given char count from the total length,\n    // and see if this puts us under the deferral threshold.\n    if ((m_grfscr & fscrDeferFncParse) &&\n        (\n            PHASE_OFF1(Js::DeferEventHandlersPhase) ||\n            (m_grfscr & fscrGlobalCode)\n        )\n    )\n    {\n        if (m_length > chars)\n        {\n            m_length -= chars;\n        }\n        else\n        {\n            m_length = 0;\n        }\n        if (m_length < Parser::GetDeferralThreshold(this->m_sourceContextInfo->IsSourceProfileLoaded()))\n        {\n            // Stop deferring.\n            m_grfscr &= ~fscrDeferFncParse;\n            m_stoppedDeferredParse = TRUE;\n        }\n    }\n}\n\n/***************************************************************************\nLook for an existing label with the given name.\n***************************************************************************/\nBOOL Parser::PnodeLabelNoAST(IdentToken* pToken, LabelId* pLabelIdList)\n{\n    StmtNest* pStmt;\n    LabelId* pLabelId;\n\n    // Look in the label stack.\n    for (pStmt = m_pstmtCur; pStmt != nullptr; pStmt = pStmt->pstmtOuter)\n    {\n        for (pLabelId = pStmt->pLabelId; pLabelId != nullptr; pLabelId = pLabelId->next)\n        {\n            if (pLabelId->pid == pToken->pid)\n                return TRUE;\n        }\n    }\n\n    // Also look in the pnodeLabels list.\n    for (pLabelId = pLabelIdList; pLabelId != nullptr; pLabelId = pLabelId->next)\n    {\n        if (pLabelId->pid == pToken->pid)\n            return TRUE;\n    }\n\n    return FALSE;\n}\n\nvoid Parser::EnsureStackAvailable()\n{\n    if (!m_scriptContext->GetThreadContext()->IsStackAvailable(Js::Constants::MinStackCompile))\n    {\n        Error(ERRnoMemory);\n    }\n}\n\nvoid Parser::ThrowNewTargetSyntaxErrForGlobalScope()\n{\n    if (GetCurrentNonLambdaFunctionNode() != nullptr)\n    {\n        return;\n    }\n\n    if ((this->m_grfscr & fscrEval) != 0)\n    {\n        Js::JavascriptFunction * caller = nullptr;\n        if (Js::JavascriptStackWalker::GetCaller(&caller, m_scriptContext))\n        {\n            Js::FunctionBody * callerBody = caller->GetFunctionBody();\n            Assert(callerBody);\n            if (!callerBody->GetIsGlobalFunc() && !(callerBody->IsLambda() && callerBody->GetEnclosedByGlobalFunc()))\n            {\n                return;\n            }\n        }\n    }\n\n    Error(ERRInvalidNewTarget);\n }\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMetaProperty(tokens metaParentKeyword, charcount_t ichMin, _Out_opt_ BOOL* pfCanAssign)\n{\n    AssertMsg(metaParentKeyword == tkNEW, \"Only supported for tkNEW parent keywords\");\n    AssertMsg(this->m_token.tk == tkDot, \"We must be currently sitting on the dot after the parent keyword\");\n\n    m_pscan->Scan();\n\n    if (this->m_token.tk == tkID && this->m_token.GetIdentifier(m_phtbl) == this->GetTargetPid())\n    {\n        ThrowNewTargetSyntaxErrForGlobalScope();\n        if (pfCanAssign)\n        {\n            *pfCanAssign = FALSE;\n        }\n        if (buildAST)\n        {\n            return CreateNodeWithScanner<knopNewTarget>(ichMin);\n        }\n    }\n    else\n    {\n        Error(ERRsyntax);\n    }\n\n    return nullptr;\n}\n\ntemplate<bool buildAST> \nvoid Parser::ParseNamedImportOrExportClause(ModuleImportOrExportEntryList* importOrExportEntryList, bool isExportClause)\n{\n    Assert(m_token.tk == tkLCurly);\n    Assert(importOrExportEntryList != nullptr);\n\n    m_pscan->Scan();\n\n    while (m_token.tk != tkRCurly && m_token.tk != tkEOF)\n    {\n        tokens firstToken = m_token.tk;\n\n        if (!(m_token.IsIdentifier() || m_token.IsReservedWord()))\n        {\n            Error(ERRsyntax);\n        }\n\n        IdentPtr identifierName = m_token.GetIdentifier(m_phtbl);\n        IdentPtr identifierAs = identifierName;\n\n        m_pscan->Scan();\n\n        if (m_token.tk == tkID)\n        {\n            // We have the pattern \"IdentifierName as\"\n            if (wellKnownPropertyPids.as != m_token.GetIdentifier(m_phtbl))\n            {\n                Error(ERRsyntax);\n            }\n\n            m_pscan->Scan();\n\n            // If we are parsing an import statement, the token after 'as' must be a BindingIdentifier.\n            if (!isExportClause)\n            {\n                ChkCurTokNoScan(tkID, ERRsyntax);\n            }\n\n            if (!(m_token.IsIdentifier() || m_token.IsReservedWord()))\n            {\n                Error(ERRsyntax);\n            }\n\n            identifierAs = m_token.GetIdentifier(m_phtbl);\n\n            // Scan to the next token.\n            m_pscan->Scan();\n        }\n        else if (!isExportClause && firstToken != tkID)\n        {\n            // If we are parsing an import statement and this ImportSpecifier clause did not have\n            // 'as ImportedBinding' at the end of it, identifierName must be a BindingIdentifier.\n            Error(ERRsyntax);\n        }\n\n        if (m_token.tk == tkComma)\n        {\n            // Consume a trailing comma\n            m_pscan->Scan();\n        }\n\n        if (buildAST)\n        {\n            // The name we will use 'as' this import/export is a binding identifier in import statements.\n            if (!isExportClause)\n            {\n                CreateModuleImportDeclNode(identifierAs);\n                AddModuleImportOrExportEntry(importOrExportEntryList, identifierName, identifierAs, nullptr, nullptr);\n            }\n            else\n            {\n                identifierName->SetIsModuleExport();\n                AddModuleImportOrExportEntry(importOrExportEntryList, nullptr, identifierName, identifierAs, nullptr);\n            }\n        }\n    }\n\n    // Final token in a named import or export clause must be a '}'\n    ChkCurTokNoScan(tkRCurly, ERRsyntax);\n}\n\nIdentPtrList* Parser::GetRequestedModulesList()\n{\n    return m_currentNodeProg->sxModule.requestedModules;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleImportEntryList()\n{\n    return m_currentNodeProg->sxModule.importEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleLocalExportEntryList()\n{\n    return m_currentNodeProg->sxModule.localExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleIndirectExportEntryList()\n{\n    return m_currentNodeProg->sxModule.indirectExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleStarExportEntryList()\n{\n    return m_currentNodeProg->sxModule.starExportEntries;\n}\n\nIdentPtrList* Parser::EnsureRequestedModulesList()\n{\n    if (m_currentNodeProg->sxModule.requestedModules == nullptr)\n    {\n        m_currentNodeProg->sxModule.requestedModules = Anew(&m_nodeAllocator, IdentPtrList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.requestedModules;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleImportEntryList()\n{\n    if (m_currentNodeProg->sxModule.importEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.importEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.importEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleLocalExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.localExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.localExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.localExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleIndirectExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.indirectExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.indirectExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.indirectExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleStarExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.starExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.starExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.starExportEntries;\n}\n\nvoid Parser::AddModuleSpecifier(IdentPtr moduleRequest)\n{\n    IdentPtrList* requestedModulesList = EnsureRequestedModulesList();\n\n    if (!requestedModulesList->Has(moduleRequest))\n    {\n        requestedModulesList->Prepend(moduleRequest);\n    }\n}\n\nModuleImportOrExportEntry* Parser::AddModuleImportOrExportEntry(ModuleImportOrExportEntryList* importOrExportEntryList, ModuleImportOrExportEntry* importOrExportEntry)\n{\n    if (importOrExportEntry->exportName != nullptr)\n    {\n        CheckForDuplicateExportEntry(importOrExportEntryList, importOrExportEntry->exportName);\n    }\n\n    importOrExportEntryList->Prepend(*importOrExportEntry);\n\n    return importOrExportEntry;\n}\n\nModuleImportOrExportEntry* Parser::AddModuleImportOrExportEntry(ModuleImportOrExportEntryList* importOrExportEntryList, IdentPtr importName, IdentPtr localName, IdentPtr exportName, IdentPtr moduleRequest)\n{\n    ModuleImportOrExportEntry* importOrExportEntry = Anew(&m_nodeAllocator, ModuleImportOrExportEntry);\n\n    importOrExportEntry->importName = importName;\n    importOrExportEntry->localName = localName;\n    importOrExportEntry->exportName = exportName;\n    importOrExportEntry->moduleRequest = moduleRequest;\n\n    return AddModuleImportOrExportEntry(importOrExportEntryList, importOrExportEntry);\n}\n\nvoid Parser::AddModuleLocalExportEntry(ParseNodePtr varDeclNode)\n{\n    Assert(varDeclNode->nop == knopVarDecl || varDeclNode->nop == knopLetDecl || varDeclNode->nop == knopConstDecl);\n\n    IdentPtr localName = varDeclNode->sxVar.pid;\n    varDeclNode->sxVar.sym->SetIsModuleExportStorage(true);\n\n    AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, localName, nullptr);\n}\n\nvoid Parser::CheckForDuplicateExportEntry(ModuleImportOrExportEntryList* exportEntryList, IdentPtr exportName)\n{\n    ModuleImportOrExportEntry* findResult = exportEntryList->Find([&](ModuleImportOrExportEntry exportEntry)\n    {\n        if (exportName == exportEntry.exportName)\n        {\n            return true;\n        }\n        return false;\n    });\n\n    if (findResult != nullptr)\n    {\n        Error(ERRsyntax);\n    }\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseImportClause(ModuleImportOrExportEntryList* importEntryList, bool parsingAfterComma)\n{\n    bool parsedNamespaceOrNamedImport = false;\n\n    switch (m_token.tk)\n    {\n    case tkID:\n        // This is the default binding identifier.\n\n        // If we already saw a comma in the import clause, this is a syntax error.\n        if (parsingAfterComma)\n        {\n            Error(ERRsyntax);\n        }\n\n        if (buildAST)\n        {\n            IdentPtr localName = m_token.GetIdentifier(m_phtbl);\n            IdentPtr importName = wellKnownPropertyPids._default;\n\n            CreateModuleImportDeclNode(localName);\n            AddModuleImportOrExportEntry(importEntryList, importName, localName, nullptr, nullptr);\n        }\n\n        break;\n\n    case tkLCurly:\n        // This begins a list of named imports.\n        ParseNamedImportOrExportClause<buildAST>(importEntryList, false);\n\n        parsedNamespaceOrNamedImport = true;\n        break;\n\n    case tkStar:\n        // This begins a namespace import clause.\n        // \"* as ImportedBinding\"\n\n        // Token following * must be the identifier 'as'\n        m_pscan->Scan();\n        if (m_token.tk != tkID || wellKnownPropertyPids.as != m_token.GetIdentifier(m_phtbl))\n        {\n            Error(ERRsyntax);\n        }\n\n        // Token following 'as' must be a binding identifier.\n        m_pscan->Scan();\n        ChkCurTokNoScan(tkID, ERRsyntax);\n\n        if (buildAST)\n        {\n            IdentPtr localName = m_token.GetIdentifier(m_phtbl);\n            IdentPtr importName = wellKnownPropertyPids._star;\n\n            CreateModuleImportDeclNode(localName);\n            AddModuleImportOrExportEntry(importEntryList, importName, localName, nullptr, nullptr);\n        }\n\n        parsedNamespaceOrNamedImport = true;\n        break;\n\n    default:\n        Error(ERRsyntax);\n    }\n\n    m_pscan->Scan();\n\n    if (m_token.tk == tkComma)\n    {\n        // There cannot be more than one comma in a module import clause.\n        // There cannot be a namespace import or named imports list on the left of the comma in a module import clause.\n        if (parsingAfterComma || parsedNamespaceOrNamedImport)\n        {\n            Error(ERRsyntax);\n        }\n\n        m_pscan->Scan();\n\n        ParseImportClause<buildAST>(importEntryList, true);\n    }\n}\n\nbool Parser::IsImportOrExportStatementValidHere()\n{\n    ParseNodePtr curFunc = GetCurrentFunctionNode();\n\n    // Import must be located in the top scope of the module body.\n    return curFunc->nop == knopFncDecl\n        && curFunc->sxFnc.IsModule()\n        && this->m_currentBlockInfo->pnodeBlock == curFunc->sxFnc.pnodeBodyScope\n        && (this->m_grfscr & fscrEvalCode) != fscrEvalCode\n        && this->m_tryCatchOrFinallyDepth == 0;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseImportDeclaration()\n{\n    Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n    Assert(m_token.tk == tkIMPORT);\n\n    if (!IsImportOrExportStatementValidHere())\n    {\n        Error(ERRInvalidModuleImportOrExport);\n    }\n\n    // We just parsed an import token. Next valid token is *, {, string constant, or binding identifier.\n    m_pscan->Scan();\n\n    if (m_token.tk == tkStrCon)\n    {\n        // This import declaration has no import clause.\n        // \"import ModuleSpecifier;\"\n        if (buildAST)\n        {\n            AddModuleSpecifier(m_token.GetStr());\n        }\n\n        // Scan past the module identifier.\n        m_pscan->Scan();\n    }\n    else\n    {\n        ModuleImportOrExportEntryList importEntryList(&m_nodeAllocator);\n\n        // Parse the import clause (default binding can only exist before the comma).\n        ParseImportClause<buildAST>(&importEntryList);\n\n        // Token following import clause must be the identifier 'from'\n        IdentPtr moduleSpecifier = ParseImportOrExportFromClause<buildAST>(true);\n\n        if (buildAST)\n        {\n            Assert(moduleSpecifier != nullptr);\n\n            AddModuleSpecifier(moduleSpecifier);\n\n            importEntryList.Map([this, moduleSpecifier](ModuleImportOrExportEntry& importEntry) {\n                importEntry.moduleRequest = moduleSpecifier;\n                AddModuleImportOrExportEntry(EnsureModuleImportEntryList(), &importEntry);\n            });\n        }\n\n        importEntryList.Clear();\n    }\n\n    // Import statement is actually a nop, we hoist all the imported bindings to the top of the module.\n    return nullptr;\n}\n\ntemplate<bool buildAST>\nIdentPtr Parser::ParseImportOrExportFromClause(bool throwIfNotFound)\n{\n    IdentPtr moduleSpecifier = nullptr;\n\n    if (m_token.tk == tkID && wellKnownPropertyPids.from == m_token.GetIdentifier(m_phtbl))\n    {\n        m_pscan->Scan();\n\n        // Token following the 'from' token must be a string constant - the module specifier.\n        ChkCurTokNoScan(tkStrCon, ERRsyntax);\n\n        if (buildAST)\n        {\n            moduleSpecifier = m_token.GetStr();\n        }\n\n        m_pscan->Scan();\n    }\n    else if (throwIfNotFound)\n    {\n        Error(ERRsyntax);\n    }\n\n    return moduleSpecifier;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseDefaultExportClause()\n{\n    Assert(m_token.tk == tkDEFAULT);\n\n    m_pscan->Scan();\n    ParseNodePtr pnode = nullptr;\n    ushort flags = fFncNoFlgs;\n\n    switch (m_token.tk)\n    {\n    case tkCLASS:\n        {\n            if (!m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n            {\n                goto LDefault;\n            }\n\n            // Before we parse the class itself we need to know if the class has an identifier name.\n            // If it does, we'll treat this class as an ordinary class declaration which will bind\n            // it to that name. Otherwise the class should parse as a nameless class expression and\n            // bind only to the export binding.\n            BOOL classHasName = false;\n            RestorePoint parsedClass;\n            m_pscan->Capture(&parsedClass);\n            m_pscan->Scan();\n\n            if (m_token.tk == tkID)\n            {\n                classHasName = true;\n            }\n\n            m_pscan->SeekTo(parsedClass);\n            pnode = ParseClassDecl<buildAST>(classHasName, nullptr, nullptr, nullptr);\n\n            if (buildAST)\n            {\n                AnalysisAssert(pnode != nullptr);\n                Assert(pnode->nop == knopClassDecl);\n\n                pnode->sxClass.SetIsDefaultModuleExport(true);\n            }\n\n            break;\n        }\n    case tkID:\n        // If we parsed an async token, it could either modify the next token (if it is a\n        // function token) or it could be an identifier (let async = 0; export default async;).\n        // To handle both cases, when we parse an async token we need to keep the parser state\n        // and rewind if the next token is not function.\n        if (wellKnownPropertyPids.async == m_token.GetIdentifier(m_phtbl))\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            m_pscan->Scan();\n            if (m_token.tk == tkFUNCTION)\n            {\n                // Token after async is function, consume the async token and continue to parse the\n                // function as an async function.\n                flags |= fFncAsync;\n                goto LFunction;\n            }\n            // Token after async is not function, no idea what the async token is supposed to mean\n            // so rewind and let the default case handle it.\n            m_pscan->SeekTo(parsedAsync);\n        }\n        goto LDefault;\n        break;\n    case tkFUNCTION:\n        {\nLFunction:\n            // We just parsed a function token but we need to figure out if the function\n            // has an identifier name or not before we call the helper.\n            RestorePoint parsedFunction;\n            m_pscan->Capture(&parsedFunction);\n            m_pscan->Scan();\n\n            if (m_token.tk == tkStar)\n            {\n                // If we saw 'function*' that indicates we are going to parse a generator,\n                // but doesn't tell us if the generator has an identifier or not.\n                // Skip the '*' token for now as it doesn't matter yet.\n                m_pscan->Scan();\n            }\n\n            // We say that if the function has an identifier name, it is a 'normal' declaration\n            // and should create a binding to that identifier as well as one for our default export.\n            if (m_token.tk == tkID)\n            {\n                flags |= fFncDeclaration;\n            }\n            else\n            {\n                flags |= fFncNoName;\n            }\n\n            // Rewind back to the function token and let the helper handle the parsing.\n            m_pscan->SeekTo(parsedFunction);\n            pnode = ParseFncDecl<buildAST>(flags);\n            \n            if (buildAST)\n            {\n                AnalysisAssert(pnode != nullptr);\n                Assert(pnode->nop == knopFncDecl);\n\n                pnode->sxFnc.SetIsDefaultModuleExport(true);\n            }\n            break;\n        }\n    default:\nLDefault:\n        {\n            ParseNodePtr pnodeExpression = ParseExpr<buildAST>();\n\n            // Consider: Can we detect this syntax error earlier?\n            if (pnodeExpression && pnodeExpression->nop == knopComma)\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                AnalysisAssert(pnodeExpression != nullptr);\n\n                // Mark this node as the default module export. We need to make sure it is put into the correct\n                // module export slot when we emit the node.\n                pnode = CreateNode(knopExportDefault);\n                pnode->sxExportDefault.pnodeExpr = pnodeExpression;\n            }\n            break;\n        }\n    }\n\n    IdentPtr exportName = wellKnownPropertyPids._default;\n    IdentPtr localName = wellKnownPropertyPids._starDefaultStar;\n    AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, exportName, nullptr);\n\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseExportDeclaration()\n{\n    Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n    Assert(m_token.tk == tkEXPORT);\n\n    if (!IsImportOrExportStatementValidHere())\n    {\n        Error(ERRInvalidModuleImportOrExport);\n    }\n\n    ParseNodePtr pnode = nullptr;\n    IdentPtr moduleIdentifier = nullptr;\n    tokens declarationType;\n\n    // We just parsed an export token. Next valid tokens are *, {, var, let, const, async, function, class, default.\n    m_pscan->Scan();\n\n    switch (m_token.tk)\n    {\n    case tkStar:\n        m_pscan->Scan();\n\n        // A star token in an export declaration must be followed by a from clause which begins with a token 'from'.\n        moduleIdentifier = ParseImportOrExportFromClause<buildAST>(true);\n\n        if (buildAST)\n        {\n            Assert(moduleIdentifier != nullptr);\n\n            AddModuleSpecifier(moduleIdentifier);\n            IdentPtr importName = wellKnownPropertyPids._star;\n\n            AddModuleImportOrExportEntry(EnsureModuleStarExportEntryList(), importName, nullptr, nullptr, moduleIdentifier);\n        }\n\n        break;\n\n    case tkLCurly:\n        {\n            ModuleImportOrExportEntryList exportEntryList(&m_nodeAllocator);\n\n            ParseNamedImportOrExportClause<buildAST>(&exportEntryList, true);\n\n            m_pscan->Scan();\n\n            // Export clause may be followed by a from clause.\n            moduleIdentifier = ParseImportOrExportFromClause<buildAST>(false);\n\n            if (buildAST)\n            {\n                if (moduleIdentifier != nullptr)\n                {\n                    AddModuleSpecifier(moduleIdentifier);\n                }\n\n                exportEntryList.Map([this, moduleIdentifier](ModuleImportOrExportEntry& exportEntry) {\n                    if (moduleIdentifier != nullptr)\n                    {\n                        exportEntry.moduleRequest = moduleIdentifier;\n\n                        // We need to swap localname and importname when this is a re-export.\n                        exportEntry.importName = exportEntry.localName;\n                        exportEntry.localName = nullptr;\n\n                        AddModuleImportOrExportEntry(EnsureModuleIndirectExportEntryList(), &exportEntry);\n                    }\n                    else\n                    {\n                        AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), &exportEntry);\n                    }\n                });\n\n                exportEntryList.Clear();\n            }\n        }\n        break;\n\n    case tkID:\n        {\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n\n            if (wellKnownPropertyPids.let == pid)\n            {\n                declarationType = tkLET;\n                goto ParseVarDecl;\n            }\n            if (wellKnownPropertyPids.async == pid && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n            {\n                // In module export statements, async token is only valid if it's followed by function.\n                // We need to check here because ParseStatement would think 'async = 20' is a var decl.\n                RestorePoint parsedAsync;\n                m_pscan->Capture(&parsedAsync);\n                m_pscan->Scan();\n                if (m_token.tk == tkFUNCTION)\n                {\n                    // Token after async is function, rewind to the async token and let ParseStatement handle it.\n                    m_pscan->SeekTo(parsedAsync);\n                    goto ParseFunctionDecl;\n                }\n                // Token after async is not function, it's a syntax error.\n            }\n            goto ErrorToken;\n        }\n    case tkVAR:\n    case tkLET:\n    case tkCONST:\n        {\n            declarationType = m_token.tk;\n\nParseVarDecl:\n            m_pscan->Scan();\n\n            pnode = ParseVariableDeclaration<buildAST>(declarationType, m_pscan->IchMinTok());\n\n            if (buildAST)\n            {\n                ParseNodePtr temp = pnode;\n                while (temp->nop == knopList)\n                {\n                    ParseNodePtr varDeclNode = temp->sxBin.pnode1;\n                    temp = temp->sxBin.pnode2;\n\n                    AddModuleLocalExportEntry(varDeclNode);\n                }\n                AddModuleLocalExportEntry(temp);\n            }\n        }\n        break;\n\n    case tkFUNCTION:\n    case tkCLASS:\n        {\nParseFunctionDecl:\n            pnode = ParseStatement<buildAST>();\n\n            if (buildAST)\n            {\n                IdentPtr localName;\n                if (pnode->nop == knopClassDecl)\n                {\n                    pnode->sxClass.pnodeName->sxVar.sym->SetIsModuleExportStorage(true);\n                    pnode->sxClass.pnodeDeclName->sxVar.sym->SetIsModuleExportStorage(true);\n                    localName = pnode->sxClass.pnodeName->sxVar.pid;\n                }\n                else\n                {\n                    Assert(pnode->nop == knopFncDecl);\n\n                    pnode->sxFnc.GetFuncSymbol()->SetIsModuleExportStorage(true);\n                    localName = pnode->sxFnc.pid;\n                }\n                Assert(localName != nullptr);\n\n                AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, localName, nullptr);\n            }\n        }\n        break;\n\n    case tkDEFAULT:\n        {\n            pnode = ParseDefaultExportClause<buildAST>();\n        }\n        break;\n\n    default:\n        {\nErrorToken:\n            Error(ERRsyntax);\n        }\n    }\n\n    return pnode;\n}\n\n/***************************************************************************\nParse an expression term.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken /*= nullptr*/,\n    bool fUnaryOrParen /*= false*/,\n    _Out_opt_ BOOL* pfCanAssign /*= nullptr*/,\n    _Inout_opt_ BOOL* pfLikelyPattern /*= nullptr*/,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr*/,\n    _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    PidRefStack *savedTopAsyncRef = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    size_t iuMin;\n    IdentToken term;\n    BOOL fInNew = FALSE;\n    BOOL fCanAssign = TRUE;\n    bool isAsyncExpr = false;\n    bool isLambdaExpr = false;\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (m_token.tk)\n    {\n    case tkID:\n    {\n        PidRefStack *ref = nullptr;\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        charcount_t ichLim = m_pscan->IchLimTok();\n        size_t iecpLim = m_pscan->IecpLimTok();\n        ichMin = m_pscan->IchMinTok();\n        iecpMin  = m_pscan->IecpMinTok();\n\n        if (pid == wellKnownPropertyPids.async &&\n            m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            isAsyncExpr = true;\n        }\n\n        bool previousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(isAsyncExpr);\n        m_pscan->Scan();\n        m_pscan->SetAwaitIsKeyword(previousAwaitIsKeyword);\n\n        // We search for an Async expression (a function declaration or an async lambda expression)\n        if (isAsyncExpr && !m_pscan->FHadNewLine())\n        {\n            if (m_token.tk == tkFUNCTION)\n            {\n                goto LFunction;\n            }\n            else if (m_token.tk == tkID || m_token.tk == tkAWAIT)\n            {\n                isLambdaExpr = true;\n                goto LFunction;\n            }\n            else if (m_token.tk == tkLParen)\n            {\n                // This is potentially an async arrow function. Save the state of the async references\n                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s\n                // is detected upstream and need not be handled here.)\n                savedTopAsyncRef = pid->GetTopRef();\n            }\n        }\n\n        // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n        // a correct function ID.\n        if (m_token.tk != tkDArrow)\n        {\n            ref = this->PushPidRef(pid);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNameNode(pid);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = ichLim;\n            pnode->sxPid.SetSymRef(ref);\n        }\n        else\n        {\n            // Remember the identifier start and end in case it turns out to be a statement label.\n            term.tk = tkID;\n            term.pid = pid; // Record the identifier for detection of eval\n            term.ichMin = static_cast<charcount_t>(iecpMin);\n            term.ichLim = static_cast<charcount_t>(iecpLim);\n        }\n        CheckArgumentsUse(pid, GetCurrentFunctionNode());\n        break;\n    }\n\n    case tkTHIS:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopThis>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkLParen:\n    {\n        ichMin = m_pscan->IchMinTok();\n        iuMin = m_pscan->IecpMinTok();\n        m_pscan->Scan();\n        if (m_token.tk == tkRParen)\n        {\n            // Empty parens can only be legal as an empty parameter list to a lambda declaration.\n            // We're in a lambda if the next token is =>.\n            fAllowCall = FALSE;\n            m_pscan->Scan();\n\n            // If the token after the right paren is not => or if there was a newline between () and => this is a syntax error\n            if (!m_doingFastScan && (m_token.tk != tkDArrow || m_pscan->FHadNewLine()))\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopEmpty>();\n            }\n            break;\n        }\n\n        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n        // up function ID's.\n        uint saveNextBlockId = m_nextBlockId;\n        uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n\n        this->m_parenDepth++;\n        pnode = ParseExpr<buildAST>(koplNo, &fCanAssign, TRUE, FALSE, nullptr, nullptr /*nameLength*/, nullptr  /*pShortNameOffset*/, &term, true, nullptr, plastRParen);\n        this->m_parenDepth--;\n\n        if (buildAST && plastRParen)\n        {\n            *plastRParen = m_pscan->IchLimTok();\n        }\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n        if (m_token.tk == tkDArrow)\n        {\n            // We're going to rewind and reinterpret the expression as a parameter list.\n            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n            m_nextBlockId = saveNextBlockId;\n        }\n\n        // Emit a deferred ... error if one was parsed.\n        if (m_deferEllipsisError && m_token.tk != tkDArrow)\n        {\n            m_pscan->SeekTo(m_EllipsisErrLoc);\n            Error(ERRInvalidSpreadUse);\n        }\n        else\n        {\n            m_deferEllipsisError = false;\n        }\n        break;\n    }\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateIntNodeWithScanner(m_token.GetLong());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFlt>();\n            pnode->sxFlt.dbl = m_token.GetDouble();\n            pnode->sxFlt.maybeInt = m_token.GetDoubleMayBeInt();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateStrNodeWithScanner(m_token.GetStr());\n        }\n        else\n        {\n            // Subtract the string literal length from the total char count for the purpose\n            // of deciding whether to defer parsing and byte code generation.\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - m_pscan->IchMinTok());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkTRUE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopTrue>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFALSE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFalse>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNULL:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopNull>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkDiv:\n    case tkAsgDiv:\n        pnode = ParseRegExp<buildAST>();\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNEW:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n\n        if (m_token.tk == tkDot && m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseMetaProperty<buildAST>(tkNEW, ichMin, &fCanAssign);\n\n            m_pscan->Scan();\n        }\n        else\n        {\n            ParseNodePtr pnodeExpr = ParseTerm<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n            if (buildAST)\n            {\n                pnode = CreateCallNode(knopNew, pnodeExpr, nullptr);\n                pnode->ichMin = ichMin;\n            }\n            fInNew = TRUE;\n            fCanAssign = FALSE;\n        }\n        break;\n    }\n\n    case tkLBrack:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n        pnode = ParseArrayLiteral<buildAST>();\n        if (buildAST)\n        {\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(m_pscan->IchLimTok() - ichMin > m_funcInArray);\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - ichMin - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(tkRBrack, ERRnoRbrack);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkLCurly:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->ScanForcingPid();\n        ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(pNameHint, pHintLength);\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopObject, pnodeMemberList);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkFUNCTION:\n    {\nLFunction :\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            //\n            // Normally, deferred functions will be parsed in ParseStatement upon encountering the 'function' token. The first\n            // token of the source code of the function may not a 'function' token though, so we still need to reset this flag\n            // for the first function we parse. This can happen in compat modes, for instance, for a function expression enclosed\n            // in parentheses, where the legacy behavior was to include the parentheses in the function's source code.\n            m_grfscr &= ~fscrDeferredFncExpression;\n        }\n        ushort flags = fFncNoFlgs;\n        if (isLambdaExpr)\n        {\n            flags |= fFncLambda;\n        }\n        if (isAsyncExpr)\n        {\n            flags |= fFncAsync;\n        }\n        pnode = ParseFncDecl<buildAST>(flags, pNameHint, false, true, fUnaryOrParen);\n        if (isAsyncExpr)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        fCanAssign = FALSE;\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        fCanAssign = FALSE;\n        break;\n\n    case tkStrTmplBasic:\n    case tkStrTmplBegin:\n        pnode = ParseStringTemplateDecl<buildAST>(nullptr);\n        fCanAssign = FALSE;\n        break;\n\n    case tkSUPER:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseSuper<buildAST>(pnode, !!fAllowCall);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case tkCASE:\n    {\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr pnodeUnused;\n        pnode = ParseCase<buildAST>(&pnodeUnused);\n        break;\n    }\n\n    case tkELSE:\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        m_pscan->Scan();\n        ParseStatement<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(ERRsyntax);\n        break;\n    }\n\n    pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n\n    if (savedTopAsyncRef != nullptr &&\n        this->m_token.tk == tkDArrow)\n    {\n        // This is an async arrow function; we're going to back up and reparse it.\n        // Make sure we don't leave behind a bogus reference to the 'async' identifier.\n        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)\n        {\n            Assert(pid->GetTopRef() != nullptr);\n            pid->RemovePrevPidRef(nullptr);\n        }\n    }\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    if (pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    return pnode;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseRegExp()\n{\n    ParseNodePtr pnode = nullptr;\n\n    if (buildAST || m_doingFastScan)\n    {\n        m_pscan->RescanRegExp();\n\n        BOOL saveDeferringAST = this->m_deferringAST;\n        if (m_doingFastScan)\n        {\n            this->m_deferringAST = false;\n        }\n        pnode = CreateNodeWithScanner<knopRegExp>();\n        pnode->sxPid.regexPattern = m_token.GetRegex();\n        if (m_doingFastScan)\n        {\n            this->m_deferringAST = saveDeferringAST;\n            this->AddFastScannedRegExpNode(pnode);\n            if (!buildAST)\n            {\n                pnode = nullptr;\n            }\n        }\n#if ENABLE_BACKGROUND_PARSING\n        else if (this->IsBackgroundParser())\n        {\n            Assert(pnode->sxPid.regexPattern == nullptr);\n            this->AddBackgroundRegExpNode(pnode);\n        }\n#endif\n    }\n    else\n    {\n        m_pscan->RescanRegExpNoAST();\n    }\n    Assert(m_token.tk == tkRegExp);\n\n    return pnode;\n}\n\nBOOL Parser::NodeIsEvalName(ParseNodePtr pnode)\n{\n    //WOOB 1107758 Special case of indirect eval binds to local scope in standards mode\n    return pnode->nop == knopName && (pnode->sxPid.pid == wellKnownPropertyPids.eval);\n}\n\nBOOL Parser::NodeEqualsName(ParseNodePtr pnode, LPCOLESTR sz, uint32 cch)\n{\n    return pnode->nop == knopName &&\n        pnode->sxPid.pid->Cch() == cch &&\n        !wmemcmp(pnode->sxPid.pid->Psz(), sz, cch);\n}\n\nBOOL Parser::NodeIsIdent(ParseNodePtr pnode, IdentPtr pid)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return (pnode->sxPid.pid == pid);\n\n        case knopComma:\n            pnode = pnode->sxBin.pnode2;\n            break;\n\n        default:\n            return FALSE;\n        }\n    }\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParsePostfixOperators(\n    ParseNodePtr pnode,\n    BOOL fAllowCall,\n    BOOL fInNew,\n    BOOL isAsyncExpr,\n    BOOL *pfCanAssign,\n    _Inout_ IdentToken* pToken,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr */)\n{\n    uint16 count = 0;\n    bool callOfConstants = false;\n    if (pfIsDotOrIndex)\n    {\n        *pfIsDotOrIndex = false;\n    }\n\n    for (;;)\n    {\n        uint16 spreadArgCount = 0;\n        switch (m_token.tk)\n        {\n        case tkLParen:\n            {\n                if (fInNew)\n                {\n                    ParseNodePtr pnodeArgs = ParseArgList<buildAST>(&callOfConstants, &spreadArgCount, &count);\n                    if (buildAST)\n                    {\n                        Assert(pnode->nop == knopNew);\n                        Assert(pnode->sxCall.pnodeArgs == nullptr);\n                        pnode->sxCall.pnodeArgs = pnodeArgs;\n                        pnode->sxCall.callOfConstants = callOfConstants;\n                        pnode->sxCall.isApplyCall = false;\n                        pnode->sxCall.isEvalCall = false;\n                        pnode->sxCall.argCount = count;\n                        pnode->sxCall.spreadArgCount = spreadArgCount;\n                        pnode->ichLim = m_pscan->IchLimTok();\n                    }\n                    else\n                    {\n                        pnode = nullptr;\n                        pToken->tk = tkNone; // This is no longer an identifier\n                    }\n                    fInNew = FALSE;\n                    ChkCurTok(tkRParen, ERRnoRparen);\n                }\n                else\n                {\n                    bool fCallIsEval = false;\n                    if (!fAllowCall)\n                    {\n                        return pnode;\n                    }\n\n                    uint saveNextBlockId = m_nextBlockId;\n                    uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n\n                    if (isAsyncExpr)\n                    {\n                        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n                        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n                        // up function ID's.\n                        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n                    }\n\n                    ParseNodePtr pnodeArgs = ParseArgList<buildAST>(&callOfConstants, &spreadArgCount, &count);\n                    // We used to un-defer a deferred function body here if it was called as part of the expression that declared it.\n                    // We now detect this case up front in ParseFncDecl, which is cheaper and simpler.\n                    if (buildAST)\n                    {\n                        pnode = CreateCallNode(knopCall, pnode, pnodeArgs);\n                        Assert(pnode);\n\n                        // Detect call to \"eval\" and record it on the function.\n                        // Note: we used to leave it up to the byte code generator to detect eval calls\n                        // at global scope, but now it relies on the flag the parser sets, so set it here.\n\n                        if (count > 0 && this->NodeIsEvalName(pnode->sxCall.pnodeTarget))\n                        {\n                            this->MarkEvalCaller();\n                            fCallIsEval = true;\n                        }\n\n                        pnode->sxCall.callOfConstants = callOfConstants;\n                        pnode->sxCall.spreadArgCount = spreadArgCount;\n                        pnode->sxCall.isApplyCall = false;\n                        pnode->sxCall.isEvalCall = fCallIsEval;\n                        pnode->sxCall.argCount = count;\n                        pnode->ichLim = m_pscan->IchLimTok();\n                    }\n                    else\n                    {\n                        pnode = nullptr;\n                        if (pToken->tk == tkID && pToken->pid == wellKnownPropertyPids.eval && count > 0) // Detect eval\n                        {\n                            this->MarkEvalCaller();\n                        }\n                        pToken->tk = tkNone; // This is no longer an identifier\n                    }\n\n                    ChkCurTok(tkRParen, ERRnoRparen);\n\n                    if (isAsyncExpr)\n                    {\n                        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n                        if (m_token.tk == tkDArrow)\n                        {\n                            // We're going to rewind and reinterpret the expression as a parameter list.\n                            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n                            m_nextBlockId = saveNextBlockId;\n                        }\n                    }\n                }\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = FALSE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = false;\n                }\n                break;\n            }\n        case tkLBrack:\n            {\n                m_pscan->Scan();\n                ParseNodePtr pnodeExpr = ParseExpr<buildAST>();\n                if (buildAST)\n                {\n                    pnode = CreateBinNode(knopIndex, pnode, pnodeExpr);\n                    pnode->ichLim = m_pscan->IchLimTok();\n                }\n                else\n                {\n                    pnode = nullptr;\n                    pToken->tk = tkNone; // This is no longer an identifier\n                }\n                ChkCurTok(tkRBrack, ERRnoRbrack);\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = TRUE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = true;\n                }\n\n                if (!buildAST)\n                {\n                    break;\n                }\n\n                bool shouldConvertToDot = false;\n                if (pnode->sxBin.pnode2->nop == knopStr)\n                {\n                    // if the string is empty or contains escape character, we will not convert them to dot node\n                    shouldConvertToDot = pnode->sxBin.pnode2->sxPid.pid->Cch() > 0 && !m_pscan->IsEscapeOnLastTkStrCon();\n                }\n\n                if (shouldConvertToDot)\n                {\n                    LPCOLESTR str = pnode->sxBin.pnode2->sxPid.pid->Psz();\n                    // See if we can convert o[\"p\"] into o.p and o[\"0\"] into o[0] since they're equivalent and the latter forms\n                    // are faster\n                    uint32 uintValue;\n                    if(Js::JavascriptOperators::TryConvertToUInt32(\n                           str,\n                           pnode->sxBin.pnode2->sxPid.pid->Cch(),\n                           &uintValue) &&\n                       !Js::TaggedInt::IsOverflow(uintValue)) // the optimization is not very useful if the number can't be represented as a TaggedInt\n                    {\n                        // No need to verify that uintValue != JavascriptArray::InvalidIndex since all nonnegative TaggedInts are valid indexes\n                        auto intNode = CreateIntNodeWithScanner(uintValue); // implicit conversion from uint32 to int32\n                        pnode->sxBin.pnode2 = intNode;\n                    }\n                    // Field optimization (see GlobOpt::KillLiveElems) checks for value being a Number,\n                    // and since NaN/Infinity is a number it won't kill o.NaN/o.Infinity which would cause a problem\n                    // if we decide to hoist o.NaN/o.Infinity.\n                    // We need to keep o[\"NaN\"] and o[\"+/-Infinity\"] as array element access (we don't hoist that but we may hoist field access),\n                    // so no matter if it's killed by o[x] inside a loop, we make sure that we never hoist these.\n                    // We need to follow same logic for strings that convert to a floating point number.\n                    else\n                    {\n                        bool doConvertToProperty = false;    // Convert a[\"x\"] -> a.x.\n                        if (!Parser::IsNaNOrInfinityLiteral<true>(str))\n                        {\n                            const OLECHAR* terminalChar;\n                            double dbl = Js::NumberUtilities::StrToDbl(str, &terminalChar, m_scriptContext);\n                            bool convertsToFloat = !Js::NumberUtilities::IsNan(dbl);\n                            doConvertToProperty = !convertsToFloat;\n                        }\n\n                        if (doConvertToProperty)\n                        {\n                            pnode->sxBin.pnode2->nop = knopName;\n                            pnode->nop = knopDot;\n                            pnode->grfpn |= PNodeFlags::fpnIndexOperator;\n                        }\n                    }\n                }\n            }\n            break;\n\n        case tkDot:\n            {\n            ParseNodePtr name = nullptr;\n            OpCode opCode = knopDot;\n\n            m_pscan->Scan();\n            if (!m_token.IsIdentifier())\n            {\n                //allow reserved words in ES5 mode\n                if (!(m_token.IsReservedWord()))\n                {\n                    IdentifierExpectedError(m_token);\n                }\n            }\n            // Note: see comment above about field optimization WRT NaN/Infinity/-Infinity.\n            // Convert a.Nan, a.Infinity into a[\"NaN\"], a[\"Infinity\"].\n            // We don't care about -Infinity case here because x.-Infinity is invalid in JavaScript.\n            // Both NaN and Infinity are identifiers.\n            else if (buildAST && Parser::IsNaNOrInfinityLiteral<false>(m_token.GetIdentifier(m_phtbl)->Psz()))\n            {\n                opCode = knopIndex;\n            }\n\n            if (buildAST)\n            {\n                if (opCode == knopDot)\n                {\n                    name = CreateNameNode(m_token.GetIdentifier(m_phtbl));\n                }\n                else\n                {\n                    Assert(opCode == knopIndex);\n                    name = CreateStrNodeWithScanner(m_token.GetIdentifier(m_phtbl));\n                }\n                pnode = CreateBinNode(opCode, pnode, name);\n            }\n            else\n            {\n                pnode = nullptr;\n                pToken->tk = tkNone;\n            }\n\n            if (pfCanAssign)\n            {\n                *pfCanAssign = TRUE;\n            }\n            if (pfIsDotOrIndex)\n            {\n                *pfIsDotOrIndex = true;\n            }\n            m_pscan->Scan();\n\n            break;\n            }\n\n        case tkStrTmplBasic:\n        case tkStrTmplBegin:\n            {\n                ParseNode* templateNode = ParseStringTemplateDecl<buildAST>(pnode);\n\n                if (!buildAST)\n                {\n                    pToken->tk = tkNone; // This is no longer an identifier\n                }\n\n                pnode = templateNode;\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = FALSE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = false;\n                }\n                break;\n            }\n        default:\n            return pnode;\n        }\n    }\n}\n\n/***************************************************************************\nLook for an existing label with the given name.\n***************************************************************************/\nParseNodePtr Parser::PnodeLabel(IdentPtr pid, ParseNodePtr pnodeLabels)\n{\n    AssertMem(pid);\n    AssertNodeMemN(pnodeLabels);\n\n    StmtNest *pstmt;\n    ParseNodePtr pnodeT;\n\n    // Look in the statement stack.\n    for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n    {\n        AssertNodeMem(pstmt->pnodeStmt);\n        AssertNodeMemN(pstmt->pnodeLab);\n\n        for (pnodeT = pstmt->pnodeLab; nullptr != pnodeT;\n            pnodeT = pnodeT->sxLabel.pnodeNext)\n        {\n            Assert(knopLabel == pnodeT->nop);\n            if (pid == pnodeT->sxLabel.pid)\n                return pnodeT;\n        }\n    }\n\n    // Also look in the pnodeLabels list.\n    for (pnodeT = pnodeLabels; nullptr != pnodeT;\n        pnodeT = pnodeT->sxLabel.pnodeNext)\n    {\n        Assert(knopLabel == pnodeT->nop);\n        if (pid == pnodeT->sxLabel.pid)\n            return pnodeT;\n    }\n\n    return nullptr;\n}\n\n// Currently only ints and floats are treated as constants in function call\n// TODO: Check if we need for other constants as well\nBOOL Parser::IsConstantInFunctionCall(ParseNodePtr pnode)\n{\n    if (pnode->nop == knopInt && !Js::TaggedInt::IsOverflow(pnode->sxInt.lw))\n    {\n        return TRUE;\n    }\n\n    if (pnode->nop == knopFlt)\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\n/***************************************************************************\nParse a list of arguments.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArgList( bool *pCallOfConstants, uint16 *pSpreadArgCount, uint16 * pCount)\n{\n    ParseNodePtr pnodeArg;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    // Check for an empty list\n    Assert(m_token.tk == tkLParen);\n\n    if (m_pscan->Scan() == tkRParen)\n    {\n        return nullptr;\n    }\n\n    *pCallOfConstants = true;\n    *pSpreadArgCount = 0;\n\n    int count=0;\n    while (true)\n    {\n        // the count of arguments has to fit in an unsigned short\n        if (count > 0xffffU)\n            Error(ERRnoMemory);\n        // Allow spread in argument lists.\n        IdentToken token;\n        pnodeArg = ParseExpr<buildAST>(koplCma, nullptr, TRUE, /* fAllowEllipsis */TRUE, NULL, nullptr, nullptr, &token);\n        ++count;\n        this->MarkEscapingRef(pnodeArg, &token);\n\n        if (buildAST)\n        {\n            this->CheckArguments(pnodeArg);\n\n            if (*pCallOfConstants && !IsConstantInFunctionCall(pnodeArg))\n            {\n                *pCallOfConstants = false;\n            }\n\n            if (pnodeArg->nop == knopEllipsis)\n            {\n                (*pSpreadArgCount)++;\n            }\n\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n        if (m_token.tk != tkComma)\n        {\n            break;\n        }\n        m_pscan->Scan();\n\n        if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n        {\n            break;\n        }\n    }\n\n    if (pSpreadArgCount!=nullptr && (*pSpreadArgCount) > 0){\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(SpreadFeature, m_scriptContext);\n    }\n\n    *pCount = static_cast<uint16>(count);\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n    }\n\n    return pnodeList;\n}\n\n// Currently only ints are treated as constants in ArrayLiterals\nBOOL Parser::IsConstantInArrayLiteral(ParseNodePtr pnode)\n{\n    if (pnode->nop == knopInt && !Js::TaggedInt::IsOverflow(pnode->sxInt.lw))\n    {\n        return TRUE;\n    }\n    return FALSE;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArrayLiteral()\n{\n    ParseNodePtr pnode = nullptr;\n    bool arrayOfTaggedInts = false;\n    bool arrayOfInts = false;\n    bool arrayOfNumbers = false;\n    bool hasMissingValues = false;\n    uint count = 0;\n    uint spreadCount = 0;\n\n    ParseNodePtr pnode1 = ParseArrayList<buildAST>(&arrayOfTaggedInts, &arrayOfInts, &arrayOfNumbers, &hasMissingValues, &count, &spreadCount);\n\n    if (buildAST)\n    {\n        pnode = CreateNodeWithScanner<knopArray>();\n        pnode->sxArrLit.pnode1 = pnode1;\n        pnode->sxArrLit.arrayOfTaggedInts = arrayOfTaggedInts;\n        pnode->sxArrLit.arrayOfInts = arrayOfInts;\n        pnode->sxArrLit.arrayOfNumbers = arrayOfNumbers;\n        pnode->sxArrLit.hasMissingValues = hasMissingValues;\n        pnode->sxArrLit.count = count;\n        pnode->sxArrLit.spreadCount = spreadCount;\n\n        if (pnode->sxArrLit.pnode1)\n        {\n            this->CheckArguments(pnode->sxArrLit.pnode1);\n        }\n    }\n\n    return pnode;\n}\n\n/***************************************************************************\nCreate an ArrayLiteral node\nParse a list of array elements. [ a, b, , c, ]\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArrayList(bool *pArrayOfTaggedInts, bool *pArrayOfInts, bool *pArrayOfNumbers, bool *pHasMissingValues, uint *count, uint *spreadCount)\n{\n    ParseNodePtr pnodeArg = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    *count = 0;\n\n    // Check for an empty list\n    if (tkRBrack == m_token.tk)\n    {\n        return nullptr;\n    }\n\n    this->m_arrayDepth++;\n    bool arrayOfTaggedInts = buildAST;\n    bool arrayOfInts = buildAST;\n    bool arrayOfNumbers = buildAST;\n    bool arrayOfVarInts = false;\n    bool hasMissingValues = false;\n\n    for (;;)\n    {\n        (*count)++;\n        if (tkComma == m_token.tk || tkRBrack == m_token.tk)\n        {\n            hasMissingValues = true;\n            arrayOfTaggedInts = false;\n            arrayOfInts = false;\n            arrayOfNumbers = false;\n            if (buildAST)\n            {\n                pnodeArg = CreateNodeWithScanner<knopEmpty>();\n            }\n        }\n        else\n        {\n            // Allow Spread in array literals.\n            pnodeArg = ParseExpr<buildAST>(koplCma, nullptr, TRUE, /* fAllowEllipsis */ TRUE);\n            if (buildAST)\n            {\n                if (pnodeArg->nop == knopEllipsis)\n                {\n                    (*spreadCount)++;\n                }\n                this->CheckArguments(pnodeArg);\n            }\n        }\n\n#if DEBUG\n        if(m_grfscr & fscrEnforceJSON && !IsJSONValid(pnodeArg))\n        {\n            Error(ERRsyntax);\n        }\n#endif\n\n        if (buildAST)\n        {\n            if (arrayOfNumbers)\n            {\n                if (pnodeArg->nop != knopInt)\n                {\n                    arrayOfTaggedInts = false;\n                    if (pnodeArg->nop != knopFlt)\n                    {\n                        // Not an array of constants.\n                        arrayOfInts = false;\n                        arrayOfNumbers = false;\n                    }\n                    else if (arrayOfInts && Js::JavascriptNumber::IsInt32OrUInt32(pnodeArg->sxFlt.dbl) && (!Js::JavascriptNumber::IsInt32(pnodeArg->sxFlt.dbl) || pnodeArg->sxFlt.dbl == -2147483648.0))\n                    {\n                        // We've seen nothing but ints, and this is a uint32 but not an int32.\n                        // Unless we see an actual float at some point, we want an array of vars\n                        // so we can work with tagged ints.\n                        arrayOfVarInts = true;\n                    }\n                    else\n                    {\n                        // Not an int array, but it may still be a float array.\n                        arrayOfInts = false;\n                    }\n                }\n                else\n                {\n                    if (Js::SparseArraySegment<int32>::IsMissingItem((int32*)&pnodeArg->sxInt.lw))\n                    {\n                        arrayOfInts = false;\n                    }\n                    if (Js::TaggedInt::IsOverflow(pnodeArg->sxInt.lw))\n                    {\n                        arrayOfTaggedInts = false;\n                    }\n                }\n            }\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n\n        if (tkComma != m_token.tk)\n        {\n            break;\n        }\n        m_pscan->Scan();\n\n        if (tkRBrack == m_token.tk)\n        {\n            break;\n        }\n    }\n\n    if (spreadCount != nullptr && *spreadCount > 0){\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(SpreadFeature, m_scriptContext);\n    }\n\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n\n        if (arrayOfVarInts && arrayOfInts)\n        {\n            arrayOfInts = false;\n            arrayOfNumbers = false;\n        }\n        *pArrayOfTaggedInts = arrayOfTaggedInts;\n        *pArrayOfInts = arrayOfInts;\n        *pArrayOfNumbers = arrayOfNumbers;\n        *pHasMissingValues = hasMissingValues;\n    }\n    this->m_arrayDepth--;\n    return pnodeList;\n}\n\nParser::MemberNameToTypeMap* Parser::CreateMemberNameMap(ArenaAllocator* pAllocator)\n{\n    Assert(pAllocator);\n    return Anew(pAllocator, MemberNameToTypeMap, pAllocator, 5);\n}\n\ntemplate<bool buildAST> void Parser::ParseComputedName(ParseNodePtr* ppnodeName, LPCOLESTR* ppNameHint, LPCOLESTR* ppFullNameHint, uint32 *pNameLength, uint32 *pShortNameOffset)\n{\n    m_pscan->Scan();\n    ParseNodePtr pnodeNameExpr = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, *ppNameHint, pNameLength, pShortNameOffset);\n    if (buildAST)\n    {\n        *ppnodeName = CreateNodeT<knopComputedName>(pnodeNameExpr->ichMin, pnodeNameExpr->ichLim);\n        (*ppnodeName)->sxUni.pnode1 = pnodeNameExpr;\n    }\n\n    if (ppFullNameHint && buildAST && CONFIG_FLAG(UseFullName))\n    {\n        *ppFullNameHint = FormatPropertyString(*ppNameHint, pnodeNameExpr, pNameLength, pShortNameOffset);\n    }\n\n    ChkCurTokNoScan(tkRBrack, ERRnoRbrack);\n}\n\n/***************************************************************************\n    Parse a list of object set/get members, e.g.:\n    { get foo(){ ... }, set bar(arg) { ... } }\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMemberGetSet(OpCode nop, LPCOLESTR* ppNameHint)\n{\n    ParseNodePtr pnodeName = nullptr;\n    Assert(nop == knopGetMember || nop == knopSetMember);\n    AssertMem(ppNameHint);\n    IdentPtr pid = nullptr;\n    bool isComputedName = false;\n\n    *ppNameHint=nullptr;\n\n    switch(m_token.tk)\n    {\n    default:\n        if (!m_token.IsReservedWord())\n        {\n            Error(ERRnoMemberIdent);\n        }\n        // fall through\n    case tkID:\n        pid = m_token.GetIdentifier(m_phtbl);\n        *ppNameHint = pid->Psz();\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n        pid = m_token.GetStr();\n        *ppNameHint = pid->Psz();\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        pid = m_pscan->PidFromLong(m_token.GetLong());\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        pid = m_pscan->PidFromDbl(m_token.GetDouble());\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkLBrack:\n        // Computed property name: get|set [expr] () {  }\n        if (!m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            Error(ERRnoMemberIdent);\n        }\n        LPCOLESTR emptyHint = nullptr;\n        uint32 offset = 0;\n        ParseComputedName<buildAST>(&pnodeName, &emptyHint, ppNameHint, &offset);\n\n        isComputedName = true;\n        break;\n    }\n\n    MemberType memberType;\n    ushort flags = fFncMethod | fFncNoName;\n    if (nop == knopGetMember)\n    {\n        memberType = MemberTypeGetter;\n        flags |= fFncNoArg;\n    }\n    else\n    {\n        Assert(nop == knopSetMember);\n        memberType = MemberTypeSetter;\n        flags |= fFncOneArg;\n    }\n\n    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n    ParseNodePtr pnodeFnc = ParseFncDecl<buildAST>(flags, *ppNameHint,\n        /*needsPIDOnRCurlyScan*/ false, /*resetParsingSuperRestrictionState*/ false);\n\n    if (buildAST)\n    {\n        pnodeFnc->sxFnc.SetIsAccessor();\n        return CreateBinNode(nop, pnodeName, pnodeFnc);\n    }\n    else\n    {\n        return nullptr;\n    }\n}\n\n/***************************************************************************\nParse a list of object members. e.g. { x:foo, 'y me':bar }\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMemberList(LPCOLESTR pNameHint, uint32* pNameHintLength, tokens declarationType)\n{\n    ParseNodePtr pnodeArg = nullptr;\n    ParseNodePtr pnodeName = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    LPCOLESTR pFullNameHint = nullptr;       // A calculated full name\n    uint32 fullNameHintLength = pNameHintLength ? *pNameHintLength : 0;\n    uint32 shortNameOffset = 0;\n    bool isProtoDeclared = false;\n\n    // we get declaration tkLCurly - when the possible object pattern found under the expression.\n    bool isObjectPattern = (declarationType == tkVAR || declarationType == tkLET || declarationType == tkCONST || declarationType == tkLCurly) && IsES6DestructuringEnabled();\n\n    // Check for an empty list\n    if (tkRCurly == m_token.tk)\n    {\n        return nullptr;\n    }\n\n    ArenaAllocator tempAllocator(_u(\"MemberNames\"), m_nodeAllocator.GetPageAllocator(), Parser::OutOfMemory);\n\n    bool hasDeferredInitError = false;\n\n    for (;;)\n    {\n        bool isComputedName = false;\n#if DEBUG\n        if((m_grfscr & fscrEnforceJSON) && (tkStrCon != m_token.tk || !(m_pscan->IsDoubleQuoteOnLastTkStrCon())))\n        {\n            Error(ERRsyntax);\n        }\n#endif\n        bool isAsyncMethod = false;\n        charcount_t ichMin = 0;\n        size_t iecpMin = 0;\n        if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->ScanForcingPid();\n            if (m_token.tk == tkLParen || m_token.tk == tkColon || m_token.tk == tkRCurly || m_pscan->FHadNewLine())\n            {\n                m_pscan->SeekTo(parsedAsync);\n            }\n            else\n            {\n                isAsyncMethod = true;\n            }\n        }\n\n        bool isGenerator = m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n                           m_token.tk == tkStar;\n        ushort fncDeclFlags = fFncNoName | fFncMethod;\n        if (isGenerator)\n        {\n            if (isAsyncMethod)\n            {\n                Error(ERRsyntax);\n            }\n            m_pscan->ScanForcingPid();\n            fncDeclFlags |= fFncGenerator;\n        }\n\n        IdentPtr pidHint = nullptr;              // A name scoped to current expression\n        Token tkHint = m_token;\n        charcount_t idHintIchMin = static_cast<charcount_t>(m_pscan->IecpMinTok());\n        charcount_t idHintIchLim = static_cast< charcount_t >(m_pscan->IecpLimTok());\n        bool wrapInBrackets = false;\n        switch (m_token.tk)\n        {\n        default:\n            if (!m_token.IsReservedWord())\n            {\n                Error(ERRnoMemberIdent);\n            }\n            // allow reserved words\n            wrapInBrackets = true;\n            // fall-through\n        case tkID:\n            pidHint = m_token.GetIdentifier(m_phtbl);\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkStrCon:\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n            wrapInBrackets = true;\n            pidHint = m_token.GetStr();\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkIntCon:\n            // Object initializers with numeric labels allowed in JS6\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pidHint = m_pscan->PidFromLong(m_token.GetLong());\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkFltCon:\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pidHint = m_pscan->PidFromDbl(m_token.GetDouble());\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            wrapInBrackets = true;\n            break;\n\n        case tkLBrack:\n            // Computed property name: [expr] : value\n            if (!m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n            {\n                Error(ERRnoMemberIdent);\n            }\n\n            ParseComputedName<buildAST>(&pnodeName, &pNameHint, &pFullNameHint, &fullNameHintLength, &shortNameOffset);\n\n            isComputedName = true;\n            break;\n        }\n\n        if (pFullNameHint == nullptr)\n        {\n            if (CONFIG_FLAG(UseFullName))\n            {\n                pFullNameHint = AppendNameHints(pNameHint, pidHint, &fullNameHintLength, &shortNameOffset, false, wrapInBrackets);\n            }\n            else\n            {\n                pFullNameHint = pidHint? pidHint->Psz() : nullptr;\n                fullNameHintLength = pidHint ? pidHint->Cch() : 0;\n                shortNameOffset = 0;\n            }\n        }\n\n        RestorePoint atPid;\n        m_pscan->Capture(&atPid);\n\n        m_pscan->ScanForcingPid();\n\n        if (isGenerator && m_token.tk != tkLParen)\n        {\n            Error(ERRnoLparen);\n        }\n\n        if (tkColon == m_token.tk)\n        {\n            // It is a syntax error is the production of the form __proto__ : <> occurs more than once. From B.3.1 in spec.\n            // Note that previous scan is important because only after that we can determine we have a variable.\n            if (!isComputedName && pidHint == wellKnownPropertyPids.__proto__)\n            {\n                if (isProtoDeclared)\n                {\n                    Error(ERRsyntax);\n                }\n                else\n                {\n                    isProtoDeclared = true;\n                }\n            }\n\n            m_pscan->Scan();\n            ParseNodePtr pnodeExpr = nullptr;\n            if (isObjectPattern)\n            {\n                if (m_token.tk == tkEllipsis)\n                {\n                    Error(ERRUnexpectedEllipsis);\n                }\n                pnodeExpr = ParseDestructuredVarDecl<buildAST>(declarationType, declarationType != tkLCurly, nullptr/* *hasSeenRest*/, false /*topLevel*/, false /*allowEmptyExpression*/);\n\n                if (m_token.tk != tkComma && m_token.tk != tkRCurly)\n                {\n                    if (m_token.IsOperator())\n                    {\n                        Error(ERRDestructNoOper);\n                    }\n                    Error(ERRsyntax);\n                }\n            }\n            else\n            {\n                pnodeExpr = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, pFullNameHint, &fullNameHintLength, &shortNameOffset);\n            }\n#if DEBUG\n            if((m_grfscr & fscrEnforceJSON) && !IsJSONValid(pnodeExpr))\n            {\n                Error(ERRsyntax);\n            }\n#endif\n            if (buildAST)\n            {\n                pnodeArg = CreateBinNode(isObjectPattern ? knopObjectPatternMember : knopMember, pnodeName, pnodeExpr);\n                if (pnodeArg->sxBin.pnode1->nop == knopStr)\n                {\n                    pnodeArg->sxBin.pnode1->sxPid.pid->PromoteAssignmentState();\n                }\n            }\n        }\n        else if (m_token.tk == tkLParen && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            if (isObjectPattern)\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n            // Shorthand syntax: foo() {} -> foo: function() {}\n\n            // Rewind to the PID and parse a function expression.\n            m_pscan->SeekTo(atPid);\n            this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n            ParseNodePtr pnodeFunc = ParseFncDecl<buildAST>(fncDeclFlags | (isAsyncMethod ? fFncAsync : fFncNoFlgs), pFullNameHint,\n                /*needsPIDOnRCurlyScan*/ false, /*resetParsingSuperRestrictionState*/ false);\n\n            if (isAsyncMethod)\n            {\n                pnodeFunc->sxFnc.cbMin = iecpMin;\n                pnodeFunc->ichMin = ichMin;\n            }\n            if (buildAST)\n            {\n                pnodeArg = CreateBinNode(knopMember, pnodeName, pnodeFunc);\n            }\n        }\n        else if (nullptr != pidHint) //Its either tkID/tkStrCon/tkFloatCon/tkIntCon\n        {\n            Assert(pidHint->Psz() != nullptr);\n\n            if ((pidHint == wellKnownPropertyPids.get || pidHint == wellKnownPropertyPids.set) &&\n                // get/set are only pseudo keywords when they are identifiers (i.e. not strings)\n                tkHint.tk == tkID && NextTokenIsPropertyNameStart())\n            {\n                if (isObjectPattern)\n                {\n                    Error(ERRInvalidAssignmentTarget);\n                }\n\n                LPCOLESTR pNameGetOrSet = nullptr;\n                OpCode op = pidHint == wellKnownPropertyPids.get ? knopGetMember : knopSetMember;\n\n                pnodeArg = ParseMemberGetSet<buildAST>(op, &pNameGetOrSet);\n\n                if (CONFIG_FLAG(UseFullName) && buildAST && pnodeArg->sxBin.pnode2->nop == knopFncDecl)\n                {\n                    if (m_scriptContext->GetConfig()->IsES6FunctionNameEnabled())\n                    {\n                        // displays as \"get object.funcname\" or \"set object.funcname\"\n                        uint32 getOrSetOffset = 0;\n                        LPCOLESTR intermediateHint = AppendNameHints(pNameHint, pNameGetOrSet, &fullNameHintLength, &shortNameOffset);\n                        pFullNameHint = AppendNameHints(pidHint, intermediateHint, &fullNameHintLength, &getOrSetOffset, true);\n                        shortNameOffset += getOrSetOffset;\n                    }\n                    else\n                    {\n                        // displays as \"object.funcname.get\" or \"object.funcname.set\"\n                        LPCOLESTR intermediateHint = AppendNameHints(pNameGetOrSet, pidHint, &fullNameHintLength, &shortNameOffset);\n                        pFullNameHint = AppendNameHints(pNameHint, intermediateHint, &fullNameHintLength, &shortNameOffset);\n                    }\n                }\n            }\n            else if ((m_token.tk == tkRCurly || m_token.tk == tkComma || m_token.tk == tkAsg) && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n            {\n                // Shorthand {foo} -> {foo:foo} syntax.\n                // {foo = <initializer>} supported only when on object pattern rules are being applied\n                if (tkHint.tk != tkID)\n                {\n                    Assert(tkHint.IsReservedWord()\n                        || tkHint.tk == tkIntCon || tkHint.tk == tkFltCon || tkHint.tk == tkStrCon);\n                    // All keywords are banned in non-strict mode.\n                    // Future reserved words are banned in strict mode.\n                    if (IsStrictMode() || !tkHint.IsFutureReservedWord(true))\n                    {\n                        IdentifierExpectedError(tkHint);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    CheckArgumentsUse(pidHint, GetCurrentFunctionNode());\n                }\n\n                bool couldBeObjectPattern = !isObjectPattern && m_token.tk == tkAsg;\n\n                if (couldBeObjectPattern)\n                {\n                    declarationType = tkLCurly;\n                    isObjectPattern = true;\n\n                    // This may be an error but we are deferring for favouring destructuring.\n                    hasDeferredInitError = true;\n                }\n\n                ParseNodePtr pnodeIdent = nullptr;\n                if (isObjectPattern)\n                {\n                    m_pscan->SeekTo(atPid);\n                    pnodeIdent = ParseDestructuredVarDecl<buildAST>(declarationType, declarationType != tkLCurly, nullptr/* *hasSeenRest*/, false /*topLevel*/, false /*allowEmptyExpression*/);\n\n                    if (m_token.tk != tkComma && m_token.tk != tkRCurly)\n                    {\n                        if (m_token.IsOperator())\n                        {\n                            Error(ERRDestructNoOper);\n                        }\n                        Error(ERRsyntax);\n                    }\n                }\n                else\n                {\n                    // Add a reference to the hinted name so we can bind it properly.\n                    PidRefStack *ref = PushPidRef(pidHint);\n\n                    if (buildAST)\n                    {\n                        pnodeIdent = CreateNameNode(pidHint, idHintIchMin, idHintIchLim);\n                        pnodeIdent->sxPid.SetSymRef(ref);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    pnodeArg = CreateBinNode(isObjectPattern && !couldBeObjectPattern ? knopObjectPatternMember : knopMemberShort, pnodeName, pnodeIdent);\n                }\n            }\n            else\n            {\n                Error(ERRnoColon);\n            }\n        }\n        else\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            Assert(pnodeArg->sxBin.pnode2 != nullptr);\n            if (pnodeArg->sxBin.pnode2->nop == knopFncDecl)\n            {\n                Assert(fullNameHintLength >= shortNameOffset);\n                pnodeArg->sxBin.pnode2->sxFnc.hint = pFullNameHint;\n                pnodeArg->sxBin.pnode2->sxFnc.hintLength =  fullNameHintLength;\n                pnodeArg->sxBin.pnode2->sxFnc.hintOffset  = shortNameOffset;\n            }\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n        pidHint = nullptr;\n        pFullNameHint = nullptr;\n        if (tkComma != m_token.tk)\n        {\n            break;\n        }\n        m_pscan->ScanForcingPid();\n        if (tkRCurly == m_token.tk)\n        {\n            break;\n        }\n    }\n\n    m_hasDeferredShorthandInitError = m_hasDeferredShorthandInitError || hasDeferredInitError;\n\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n    }\n\n    return pnodeList;\n}\n\nBOOL Parser::DeferredParse(Js::LocalFunctionId functionId)\n{\n    if ((m_grfscr & fscrDeferFncParse) != 0)\n    {\n        if (m_stoppedDeferredParse)\n        {\n            return false;\n        }\n        if (PHASE_OFF_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, functionId))\n        {\n            return false;\n        }\n        if (PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, functionId))\n        {\n            return true;\n        }\n#if ENABLE_PROFILE_INFO\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n        if (m_sourceContextInfo->sourceDynamicProfileManager != nullptr)\n        {\n            Js::ExecutionFlags flags = m_sourceContextInfo->sourceDynamicProfileManager->IsFunctionExecuted(functionId);\n            return flags != Js::ExecutionFlags_Executed;\n        }\n#endif\n#endif\n        return true;\n    }\n\n    return false;\n}\n\n//\n// Call this in ParseFncDecl only to check (and reset) if ParseFncDecl is re-parsing a deferred\n// function body. If a deferred function is called and being re-parsed, it shouldn't be deferred again.\n//\nBOOL Parser::IsDeferredFnc()\n{\n    if (m_grfscr & fscrDeferredFnc)\n    {\n        m_grfscr &= ~fscrDeferredFnc;\n        return true;\n    }\n\n    return false;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseFncDecl(ushort flags, LPCOLESTR pNameHint, const bool needsPIDOnRCurlyScan, bool resetParsingSuperRestrictionState, bool fUnaryOrParen)\n{\n    AutoParsingSuperRestrictionStateRestorer restorer(this);\n    if (resetParsingSuperRestrictionState)\n    {\n        //  ParseFncDecl will always reset m_parsingSuperRestrictionState to super disallowed unless explicitly disabled\n        this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperDisallowed;\n    }\n\n    ParseNodePtr pnodeFnc = nullptr;\n    ParseNodePtr *ppnodeVarSave = nullptr;\n    ParseNodePtr pnodeFncBlockScope = nullptr;\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n    bool funcHasName = false;\n    bool fDeclaration = flags & fFncDeclaration;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    charcount_t ichMin = this->m_pscan->IchMinTok();\n    bool wasInDeferredNestedFunc = false;\n\n    uint tryCatchOrFinallyDepthSave = this->m_tryCatchOrFinallyDepth;\n    this->m_tryCatchOrFinallyDepth = 0;\n\n    if (this->m_arrayDepth)\n    {\n        this->m_funcInArrayDepth++; // Count function depth within array literal\n    }\n\n    // Update the count of functions nested in the current parent.\n    Assert(m_pnestedCount || !buildAST);\n    uint *pnestedCountSave = m_pnestedCount;\n    if (buildAST || m_pnestedCount)\n    {\n        (*m_pnestedCount)++;\n    }\n\n    uint scopeCountNoAstSave = m_scopeCountNoAst;\n    m_scopeCountNoAst = 0;\n\n    bool noStmtContext = false;\n\n    if (fDeclaration)\n    {\n        noStmtContext = m_pstmtCur->GetNop() != knopBlock;\n\n        if (noStmtContext)\n        {\n            // We have a function declaration like \"if (a) function f() {}\". We didn't see\n            // a block scope on the way in, so we need to pretend we did. Note that this is a syntax error\n            // in strict mode.\n            if (!this->FncDeclAllowedWithoutContext(flags))\n            {\n                Error(ERRsyntax);\n            }\n            pnodeFncBlockScope = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n            if (buildAST)\n            {\n                PushFuncBlockScope(pnodeFncBlockScope, &ppnodeScopeSave, &ppnodeExprScopeSave);\n            }\n        }\n    }\n\n    // Create the node.\n    pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetDeclaration(fDeclaration);\n    pnodeFnc->sxFnc.astSize             = 0;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFnc->sxFnc.functionId = (*m_nextFunctionId)++;\n\n    // Push new parser state with this new function node\n\n    AppendFunctionToScopeList(fDeclaration, pnodeFnc);\n\n    // Start the argument list.\n    ppnodeVarSave = m_ppnodeVar;\n\n    if (buildAST)\n    {\n        pnodeFnc->sxFnc.lineNumber = m_pscan->LineCur();\n        pnodeFnc->sxFnc.columnNumber = CalculateFunctionColumnNumber();\n        pnodeFnc->sxFnc.SetNested(m_currentNodeFunc != nullptr); // If there is a current function, then we're a nested function.\n        pnodeFnc->sxFnc.SetStrictMode(IsStrictMode()); // Inherit current strict mode -- may be overridden by the function itself if it contains a strict mode directive.\n        pnodeFnc->sxFnc.firstDefaultArg = 0;\n\n        m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n    }\n    else // if !buildAST\n    {\n        wasInDeferredNestedFunc = m_inDeferredNestedFunc;\n        m_inDeferredNestedFunc = true;\n    }\n\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    AnalysisAssert(pnodeFnc);\n    pnodeFnc->sxFnc.SetIsAsync((flags & fFncAsync) != 0);\n    pnodeFnc->sxFnc.SetIsLambda(fLambda);\n    pnodeFnc->sxFnc.SetIsMethod((flags & fFncMethod) != 0);\n    pnodeFnc->sxFnc.SetIsClassMember((flags & fFncClassMember) != 0);\n    pnodeFnc->sxFnc.SetIsModule(fModule);\n\n    bool needScanRCurly = true;\n    bool result = ParseFncDeclHelper<buildAST>(pnodeFnc, pNameHint, flags, &funcHasName, fUnaryOrParen, noStmtContext, &needScanRCurly, fModule);\n    if (!result)\n    {\n        Assert(!pnodeFncBlockScope);\n\n        return pnodeFnc;\n    }\n\n    AnalysisAssert(pnodeFnc);\n\n    *m_ppnodeVar = nullptr;\n    m_ppnodeVar = ppnodeVarSave;\n\n    if (m_currentNodeFunc && (pnodeFnc->sxFnc.CallsEval() || pnodeFnc->sxFnc.ChildCallsEval()))\n    {\n        GetCurrentFunctionNode()->sxFnc.SetChildCallsEval(true);\n    }\n\n    ParseNodePtr pnodeFncParent = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n\n    // Lambdas do not have \"arguments\" and instead capture their parent's\n    // binding of \"arguments.  To ensure the arguments object of the enclosing\n    // non-lambda function is loaded propagate the UsesArguments flag up to\n    // the parent function\n    if ((flags & fFncLambda) != 0 && pnodeFnc->sxFnc.UsesArguments())\n    {\n        if (pnodeFncParent != nullptr)\n        {\n            pnodeFncParent->sxFnc.SetUsesArguments();\n        }\n        else\n        {\n            m_UsesArgumentsAtGlobal = true;\n        }\n    }\n\n    if (needScanRCurly && !fModule)\n    {\n        // Consume the next token now that we're back in the enclosing function (whose strictness may be\n        // different from the function we just finished).\n#if DBG\n        bool expectedTokenValid = m_token.tk == tkRCurly;\n        AssertMsg(expectedTokenValid, \"Invalid token expected for RCurly match\");\n#endif\n        // The next token may need to have a PID created in !buildAST mode, as we may be parsing a method with a string name.\n        if (needsPIDOnRCurlyScan)\n        {\n            m_pscan->ScanForcingPid();\n        }\n        else\n        {\n            m_pscan->Scan();\n        }\n    }\n\n    m_pnestedCount = pnestedCountSave;\n    Assert(!buildAST || !wasInDeferredNestedFunc);\n    m_inDeferredNestedFunc = wasInDeferredNestedFunc;\n\n    if (this->m_arrayDepth)\n    {\n        this->m_funcInArrayDepth--;\n        if (this->m_funcInArrayDepth == 0)\n        {\n            // We disable deferred parsing if array literals dominate.\n            // But don't do this if the array literal is dominated by function bodies.\n            if (flags & (fFncMethod | fFncClassMember) && m_token.tk != tkSColon)\n            {\n                // Class member methods have optional separators. We need to check whether we are\n                // getting the IchLim of the correct token.\n                Assert(m_pscan->m_tkPrevious == tkRCurly && needScanRCurly);\n\n                this->m_funcInArray += m_pscan->IchMinTok() - /*tkRCurly*/ 1 - ichMin;\n            }\n            else\n            {\n                this->m_funcInArray += m_pscan->IchLimTok() - ichMin;\n            }\n        }\n    }\n\n    m_scopeCountNoAst = scopeCountNoAstSave;\n\n    if (buildAST && fDeclaration && !IsStrictMode())\n    {\n        if (pnodeFnc->sxFnc.pnodeName != nullptr && pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl &&\n            GetCurrentBlock()->sxBlock.blockType == PnodeBlockType::Regular)\n        {\n            // Add a function-scoped VarDecl with the same name as the function for\n            // back compat with pre-ES6 code that declares functions in blocks. The\n            // idea is that the last executed declaration wins at the function scope\n            // level and we accomplish this by having each block scoped function\n            // declaration assign to both the block scoped \"let\" binding, as well\n            // as the function scoped \"var\" binding.\n            bool isRedecl = false;\n            ParseNodePtr vardecl = CreateVarDeclNode(pnodeFnc->sxFnc.pnodeName->sxVar.pid, STVariable, false, nullptr, false, &isRedecl);\n            vardecl->sxVar.isBlockScopeFncDeclVar = true;\n            if (isRedecl)\n            {\n                vardecl->sxVar.sym->SetHasBlockFncVarRedecl();\n            }\n        }\n    }\n\n    if (pnodeFncBlockScope)\n    {\n        Assert(pnodeFncBlockScope->sxBlock.pnodeStmt == nullptr);\n        pnodeFncBlockScope->sxBlock.pnodeStmt = pnodeFnc;\n        if (buildAST)\n        {\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n        }\n        FinishParseBlock(pnodeFncBlockScope);\n        return pnodeFncBlockScope;\n    }\n\n    this->m_tryCatchOrFinallyDepth = tryCatchOrFinallyDepthSave;\n\n    return pnodeFnc;\n}\n\nbool Parser::FncDeclAllowedWithoutContext(ushort flags)\n{\n    // Statement context required for strict mode, async functions, and generators.\n    // Note that generators aren't detected yet when this method is called; they're checked elsewhere.\n    return !IsStrictMode() && !(flags & fFncAsync);\n}\n\nuint Parser::CalculateFunctionColumnNumber()\n{\n    uint columnNumber;\n\n    if (m_pscan->IchMinTok() >= m_pscan->IchMinLine())\n    {\n        // In scenarios involving defer parse IchMinLine() can be incorrect for the first line after defer parse\n        columnNumber = m_pscan->IchMinTok() - m_pscan->IchMinLine();\n        if (m_functionBody != nullptr && m_functionBody->GetRelativeLineNumber() == m_pscan->LineCur())\n        {\n            // Adjust the column if it falls on the first line, where the re-parse is happening.\n            columnNumber += m_functionBody->GetRelativeColumnNumber();\n        }\n    }\n    else if (m_currentNodeFunc)\n    {\n        // For the first line after defer parse, compute the column relative to the column number\n        // of the lexically parent function.\n        ULONG offsetFromCurrentFunction = m_pscan->IchMinTok() - m_currentNodeFunc->ichMin;\n        columnNumber = m_currentNodeFunc->sxFnc.columnNumber + offsetFromCurrentFunction ;\n    }\n    else\n    {\n        // if there is no current function, lets give a default of 0.\n        columnNumber = 0;\n    }\n\n    return columnNumber;\n}\n\nvoid Parser::AppendFunctionToScopeList(bool fDeclaration, ParseNodePtr pnodeFnc)\n{\n    if (!fDeclaration && m_ppnodeExprScope)\n    {\n        // We're tracking function expressions separately from declarations in this scope\n        // (e.g., inside a catch scope in standards mode).\n        Assert(*m_ppnodeExprScope == nullptr);\n        *m_ppnodeExprScope = pnodeFnc;\n        m_ppnodeExprScope = &pnodeFnc->sxFnc.pnodeNext;\n    }\n    else\n    {\n        Assert(*m_ppnodeScope == nullptr);\n        *m_ppnodeScope = pnodeFnc;\n        m_ppnodeScope = &pnodeFnc->sxFnc.pnodeNext;\n    }\n}\n\n/***************************************************************************\nParse a function definition.\n***************************************************************************/\ntemplate<bool buildAST>\nbool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)\n{\n    ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();\n    // is the following correct? When buildAST is false, m_currentNodeDeferredFunc can be nullptr on transition to deferred parse from non-deferred\n    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    bool fDeclaration = (flags & fFncDeclaration) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fDeferred = false;\n    StmtNest *pstmtSave;\n    ParseNodePtr *lastNodeRef = nullptr;\n    bool fFunctionInBlock = false;\n    if (buildAST)\n    {\n        fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);\n    }\n\n    // Save the position of the scanner in case we need to inspect the name hint later\n    RestorePoint beginNameHint;\n    m_pscan->Capture(&beginNameHint);\n\n    ParseNodePtr pnodeFncExprScope = nullptr;    \n    Scope *fncExprScope = nullptr;\n    if (!fDeclaration)\n    {\n        pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);\n        fncExprScope = pnodeFncExprScope->sxBlock.scope;\n\n        // Function expression: push the new function onto the stack now so that the name (if any) will be\n        // local to the new function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    *pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);\n\n    if (fDeclaration)\n    {\n        // Declaration statement: push the new function now, after parsing the name, so the name is local to the\n        // enclosing function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())\n    {\n        // Generator decl not allowed outside stmt context. (We have to wait until we've parsed the '*' to\n        // detect generator.)\n        Error(ERRsyntax, pnodeFnc);\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);\n\n    if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);\n    }\n\n    if (fncExprScope && !*pHasName)\n    {\n        FinishParseBlock(pnodeFncExprScope);\n        m_nextBlockId--;\n        Adelete(&m_nodeAllocator, fncExprScope);\n        fncExprScope = nullptr;\n        pnodeFncExprScope = nullptr;\n    }\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.scope = fncExprScope;\n    }\n\n    // Start a new statement stack.\n    bool topLevelStmt =\n        buildAST &&\n        !fFunctionInBlock &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);\n\n    pstmtSave = m_pstmtCur;\n    SetCurrentStatement(nullptr);\n\n    // Function definition is inside the parent function's parameter scope\n    bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;\n\n    if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)\n    {\n        // Or this is a function expression or class enclosed in a parameter scope\n        isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;\n    }\n\n    Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint beginFormals;\n    m_pscan->Capture(&beginFormals);\n    BOOL fWasAlreadyStrictMode = IsStrictMode();\n    BOOL oldStrictMode = this->m_fUseStrictMode;\n\n    if (fLambda)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);\n    }\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n    if ((!fDeclaration && m_ppnodeExprScope) ||\n        isEnclosedInParamScope ||\n        (flags & (fFncNoName | fFncLambda)))\n    {\n        // NOTE: Don't defer if this is a function expression inside a construct that induces\n        // a scope nested within the current function (like a with, or a catch in ES5 mode, or\n        // any function declared inside a nested lexical block or param scope in ES6 mode).\n        // We won't be able to reconstruct the scope chain properly when we come back and\n        // try to compile just the function expression.\n        // Also shut off deferring on getter/setter or other construct with unusual text bounds\n        // (fFncNoName|fFncLambda) as these are usually trivial, and re-parsing is problematic.\n        m_grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool saveInFIB = this->m_inFIB;\n    this->m_inFIB = fFunctionInBlock || this->m_inFIB;\n\n    bool isTopLevelDeferredFunc = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }\n        ~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }\n        Parser *m_parser;\n    } flag(this);\n\n    bool doParallel = false;\n    bool parallelJobStarted = false;\n    if (buildAST)\n    {\n        bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;\n\n        BOOL isDeferredFnc = IsDeferredFnc();\n        AnalysisAssert(isDeferredFnc || pnodeFnc);\n        // These are the conditions that prohibit upfront deferral *and* redeferral.\n        isTopLevelDeferredFunc =\n            (!fLambda\n             && pnodeFnc\n             && DeferredParse(pnodeFnc->sxFnc.functionId)\n             && (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))\n             && !m_InAsmMode\n            // Don't defer a module function wrapper because we need to do export resolution at parse time\n             && !fModule\n            );\n\n        if (pnodeFnc)\n        {\n            pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));\n            pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (isTopLevelDeferredFunc)\n            {\n                // Block-scoping is the only non-heuristic reason for not deferring this function up front.\n                // So on creating the full FunctionBody at byte code gen time, verify that there is no\n                // block-scoped content visible to this function so it can remain a redeferral candidate.\n                pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            isTopLevelDeferredFunc = false;\n        }        \n\n        // These are heuristic conditions that prohibit upfront deferral but not redeferral.\n        isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && \n            (!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));\n;\n        if (!fLambda &&\n            !isDeferredFnc &&\n            !isLikelyIIFE &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(pnodeFncSave && m_currDeferredStub) &&\n            !(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))\n        {\n            doParallel = DoParallelParse(pnodeFnc);\n#if ENABLE_BACKGROUND_PARSING\n            if (doParallel)\n            {\n                BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n                Assert(bgp);\n                if (bgp->HasFailedBackgroundParseItem())\n                {\n                    Error(ERRsyntax);\n                }\n                doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);\n                if (doParallel)\n                {\n                    parallelJobStarted = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    doParallel = FastScanFormalsAndBody();\n                    if (doParallel)\n                    {\n                        // Let the foreground thread take care of marking the limit on the function node,\n                        // because in some cases this function's caller will want to change that limit,\n                        // so we don't want the background thread to try and touch it.\n                        pnodeFnc->ichLim = m_pscan->IchLimTok();\n                        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!doParallel)\n    {\n        // We don't want to, or couldn't, let the main thread scan past this function body, so parse\n        // it for real.\n        ParseNodePtr pnodeRealFnc = pnodeFnc;\n        if (parallelJobStarted)\n        {\n            // We have to deal with a failure to fast-scan the function (due to syntax error? \"/\"?) when\n            // a background thread may already have begun to work on the job. Both threads can't be allowed to\n            // operate on the same node.\n            pnodeFnc = CreateDummyFuncNode(fDeclaration);\n        }\n\n        AnalysisAssert(pnodeFnc);\n        ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n        AnalysisAssert(pnodeBlock != nullptr);\n        pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ppnodeScopeSave = m_ppnodeScope;\n        if (pnodeBlock)\n        {\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n        }\n\n        // Keep nested function declarations and expressions in the same list at function scope.\n        // (Indicate this by nulling out the current function expressions list.)\n        ppnodeExprScopeSave = m_ppnodeExprScope;\n        m_ppnodeExprScope = nullptr;\n\n        if (!skipFormals)\n        {\n            bool fLambdaParamsSave = m_reparsingLambdaParams;\n            if (fLambda)\n            {\n                m_reparsingLambdaParams = true;\n            }\n            this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);\n            m_reparsingLambdaParams = fLambdaParamsSave;\n        }\n\n        // Create function body scope\n        ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        // Set the parameter block's child to the function body block.\n        // The pnodeFnc->sxFnc.pnodeScopes list is constructed in such a way that it includes all the scopes in this list.\n        // For example if the param scope has one function and body scope has one function then the list will look like below,\n        // param scope block -> function decl from param scope -> body socpe block -> function decl from body scope.\n        *m_ppnodeScope = pnodeInnerBlock;\n        pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n        // This synthetic block scope will contain all the nested scopes.\n        m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n        pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n        // DEFER: Begin deferral here (after names are parsed and name nodes created).\n        // Create no more AST nodes until we're done.\n\n        // Try to defer this func if all these are true:\n        //  0. We are not already in deferred parsing (i.e. buildAST is true)\n        //  1. We are not re-parsing a deferred func which is being invoked.\n        //  2. Dynamic profile suggests this func can be deferred (and deferred parse is on).\n        //  3. This func is top level or defer nested func is on.\n        //  4. Optionally, the function is non-nested and not in eval, or the deferral decision was based on cached profile info,\n        //     or the function is sufficiently long. (I.e., don't defer little nested functions unless we're\n        //     confident they'll never be executed, because un-deferring nested functions is more expensive.)\n        //     NOTE: I'm disabling #4 by default, because we've found other ways to reduce the cost of un-deferral,\n        //           and we don't want to create function bodies aggressively for little functions.\n\n        // We will also temporarily defer all asm.js functions, except for the asm.js\n        // module itself, which we will never defer\n        bool strictModeTurnedOn = false;\n\n        if (isTopLevelDeferredFunc &&\n            !(this->m_grfscr & fscrEvalCode) &&\n            pnodeFnc->sxFnc.IsNested() &&\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n            m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)\n            ))\n        {\n            // Try to scan ahead to the end of the function. If we get there before we've scanned a minimum\n            // number of tokens, don't bother deferring, because it's too small.\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))\n            {\n                isTopLevelDeferredFunc = false;\n            }\n        }\n\n        Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (paramScope != nullptr)\n        {\n            if (CONFIG_FLAG(ForceSplitScope))\n            {\n                paramScope->SetCannotMergeWithBodyScope();\n            }\n            else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())\n            {\n                if (paramScope->GetCanMergeWithBodyScope())\n                {\n                    paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {\n                        if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                        {\n                            // One of the symbol has non local reference. Mark the param scope as we can't merge it with body scope.\n                            paramScope->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        Assert(pnodeFnc->sxFnc.UsesArguments());\n                        // Arguments symbol is captured in the param scope\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n            }\n        }\n\n        if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()\n            && (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))\n        {\n            Error(ERRNonSimpleParamListArgumentsUse);\n        }\n\n        // If the param scope is merged with the body scope we want to use the param scope symbols in the body scope.\n        // So add a pid ref for the body using the param scope symbol. Note that in this case the same symbol will occur twice\n        // in the same pid ref stack.\n        if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())\n        {\n            paramScope->ForEachSymbol([this](Symbol* paramSym)\n            {\n                PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                ref->SetSym(paramSym);\n            });\n        }\n\n        if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))\n        {\n            AssertMsg(!fLambda, \"Deferring function parsing of a function does not handle lambda syntax\");\n            fDeferred = true;\n\n            this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);\n        }\n        else\n        {\n            if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda.\n            {\n                m_pscan->Scan();\n            }\n\n            if (fLambda)\n            {\n                BOOL hadNewLine = m_pscan->FHadNewLine();\n\n                // it can be the case we do not have a fat arrow here if there is a valid expression on the left hand side\n                // of the fat arrow, but that expression does not parse as a parameter list.  E.g.\n                //    a.x => { }\n                // Therefore check for it and error if not found.\n                // LS Mode : since this is a lambda we supposed to get the fat arrow, if not we will skip till we get that fat arrow.\n                ChkCurTok(tkDArrow, ERRnoDArrow);\n\n                // Newline character between arrow parameters and fat arrow is a syntax error but we want to check for\n                // this after verifying there was a => token. Otherwise we would throw the wrong error.\n                if (hadNewLine)\n                {\n                    Error(ERRsyntax);\n                }\n            }\n\n            AnalysisAssert(pnodeFnc);\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                // Add a new symbol reference for each formal in the param scope to the body scope.\n                // While inserting symbols into the symbol list we always insert at the front, so while traversing the list we will be visiting the last added\n                // formals first. Normal insertion of those into the body will reverse the order of symbols, which will eventually result in different order\n                // for scope slots allocation for the corresponding symbol in both param and body scope. Inserting them in the opposite order will help us\n                // have the same sequence for scope slots allocation in both scopes. This makes it easy to read the bytecode and may help in some optimization\n                // later.\n                paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n\n                    ParseNodePtr paramNode = nullptr;\n                    if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        m_ppnodeVar = ppnodeVarSave;\n                    }\n                    else\n                    {\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                    }\n\n                    Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                    paramNode->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!fLambda)\n                {\n                    // In split scope case ideally the arguments object should be in the param scope.\n                    // Right now referring to arguments in the param scope is a SyntaxError, so we have to\n                    // add a duplicate symbol in the body scope and copy over the value in BeginBodySope.\n                    ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);\n                    Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                }\n            }\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            m_ppnodeExprScope = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;\n                if (isEnclosedInParamScope)\n                {\n                    // if the enclosed scope is the param scope we would not have created the deferred stub.\n                    m_currDeferredStub = nullptr;\n                }\n                else if (pnodeFncSave && m_currDeferredStub)\n                {\n                    // the Deferred stub will not match for the function which are defined on lambda formals.\n                    // Since this is not determined upfront that the current function is a part of outer function or part of lambda formal until we have seen the Arrow token.\n                    // Due to that the current function may be fetching stubs from the outer function (outer of the lambda) - rather then the lambda function. The way to fix is to match\n                    // the function start with the stub. Because they should match. We need to have previous sibling concept as the lambda formals can have more than one\n                    // functions and we want to avoid getting wrong stub.\n\n                    if (pnodeFncSave->sxFnc.nestedCount == 1)\n                    {\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n\n                    if (m_prevSiblingDeferredStub == nullptr)\n                    {\n                        m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));\n                    }\n\n                    if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)\n                    {\n                        m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n                    else\n                    {\n                        m_currDeferredStub = nullptr;\n                    }\n                }\n\n                if (m_token.tk != tkLCurly && fLambda)\n                {\n                    ParseExpressionLambdaBody<true>(pnodeFnc);\n                    *pNeedScanRCurly = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);\n                }\n                m_currDeferredStub = saveCurrentStub;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);\n            }\n        }\n\n        if (pnodeInnerBlock)\n        {\n            FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);\n        }\n\n        if (!fModule && (m_token.tk == tkLCurly || !fLambda))\n        {\n            this->AddArgumentsNodeToVars(pnodeFnc);\n        }\n\n        // Restore the lists of scopes that contain function expressions.\n\n        Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n        m_ppnodeExprScope = ppnodeExprScopeSave;\n\n        AssertMem(m_ppnodeScope);\n        Assert(nullptr == *m_ppnodeScope);\n        m_ppnodeScope = ppnodeScopeSave;\n\n        if (pnodeBlock)\n        {\n            FinishParseBlock(pnodeBlock, *pNeedScanRCurly);\n        }\n\n        if (IsStrictMode() || strictModeTurnedOn)\n        {\n            this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode\n\n            if (!fWasAlreadyStrictMode)\n            {\n                // If this function turned on strict mode then we didn't check the formal\n                // parameters or function name hint for future reserved word usage. So do that now.\n                RestorePoint afterFnc;\n                m_pscan->Capture(&afterFnc);\n\n                if (*pHasName)\n                {\n                    // Rewind to the function name hint and check if the token is a reserved word.\n                    m_pscan->SeekTo(beginNameHint);\n                    m_pscan->Scan();\n                    if (pnodeFnc->sxFnc.IsGenerator())\n                    {\n                        Assert(m_token.tk == tkStar);\n                        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(flags & fFncClassMember));\n                        m_pscan->Scan();\n                    }\n                    if (m_token.IsReservedWord())\n                    {\n                        IdentifierExpectedError(m_token);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n                }\n\n                // Fast forward to formal parameter list, check for future reserved words,\n                // then restore scanner as it was.\n                m_pscan->SeekToForcingPid(beginFormals);\n                CheckStrictFormalParameters();\n                m_pscan->SeekTo(afterFnc);\n            }\n\n            if (buildAST)\n            {\n                if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = oldStrictMode;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);\n        }\n\n        if (fDeferred)\n        {\n            AnalysisAssert(pnodeFnc);\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (parallelJobStarted)\n        {\n            pnodeFnc = pnodeRealFnc;\n            m_currentNodeFunc = pnodeRealFnc;\n\n            // Let the foreground thread take care of marking the limit on the function node,\n            // because in some cases this function's caller will want to change that limit,\n            // so we don't want the background thread to try and touch it.\n            pnodeFnc->ichLim = m_pscan->IchLimTok();\n            pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        }\n    }\n\n    // after parsing asm.js module, we want to reset asm.js state before continuing\n    AnalysisAssert(pnodeFnc);\n    if (pnodeFnc->sxFnc.GetAsmjsMode())\n    {\n        m_InAsmMode = false;\n    }\n\n    // Restore the statement stack.\n    Assert(nullptr == m_pstmtCur);\n    SetCurrentStatement(pstmtSave);\n\n    if (pnodeFncExprScope)\n    {\n        FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);\n    }\n    if (!m_stoppedDeferredParse)\n    {\n        m_grfscr |= uDeferSave;\n    }\n    m_inFIB = saveInFIB;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n\n    // Restore the current function.\n    if (buildAST)\n    {\n        Assert(pnodeFnc == m_currentNodeFunc);\n\n        m_currentNodeFunc = pnodeFncSave;\n        m_pCurrentAstSize = pAstSizeSave;\n\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;\n        }\n    }\n    else\n    {\n        Assert(pnodeFnc == m_currentNodeDeferredFunc);\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);\n            m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;\n        }\n        m_currentNodeDeferredFunc = pnodeFncSave;\n    }\n\n    if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}\n\ntemplate<bool buildAST>\nvoid Parser::UpdateCurrentNodeFunc(ParseNodePtr pnodeFnc, bool fLambda)\n{\n    if (buildAST)\n    {\n        // Make this the current function and start its sub-function list.\n        m_currentNodeFunc = pnodeFnc;\n\n        Assert(m_currentNodeDeferredFunc == nullptr);\n\n        if (!fLambda)\n        {\n            m_currentNodeNonLambdaFunc = pnodeFnc;\n        }\n    }\n    else // if !buildAST\n    {\n        AnalysisAssert(pnodeFnc);\n\n        if (!fLambda)\n        {\n            m_currentNodeNonLambdaDeferredFunc = pnodeFnc;\n        }\n\n        m_currentNodeDeferredFunc = pnodeFnc;\n    }\n}\n\nvoid Parser::ParseTopLevelDeferredFunc(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncParent, LPCOLESTR pNameHint)\n{\n    // Parse a function body that is a transition point from building AST to doing fast syntax check.\n\n    pnodeFnc->sxFnc.pnodeVars = nullptr;\n    pnodeFnc->sxFnc.pnodeBody = nullptr;\n\n    this->m_deferringAST = TRUE;\n\n    // Put the scanner into \"no hashing\" mode.\n    BYTE deferFlags = m_pscan->SetDeferredParse(TRUE);\n\n    m_pscan->Scan();\n\n    ChkCurTok(tkLCurly, ERRnoLcurly);\n\n    ParseNodePtr *ppnodeVarSave = m_ppnodeVar;\n\n    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n    if (pnodeFncParent != nullptr\n        && m_currDeferredStub != nullptr\n        // We don't create stubs for function bodies in parameter scope.\n        && pnodeFnc->sxFnc.pnodeScopes->sxBlock.blockType != PnodeBlockType::Parameter)\n    {\n        // We've already parsed this function body for syntax errors on the initial parse of the script.\n        // We have information that allows us to skip it, so do so.\n\n        DeferredFunctionStub *stub = m_currDeferredStub + (pnodeFncParent->sxFnc.nestedCount - 1);\n        Assert(pnodeFnc->ichMin == stub->ichMin);\n        if (stub->fncFlags & kFunctionCallsEval)\n        {\n            this->MarkEvalCaller();\n        }\n        if (stub->fncFlags & kFunctionChildCallsEval)\n        {\n            pnodeFnc->sxFnc.SetChildCallsEval(true);\n        }\n        if (stub->fncFlags & kFunctionHasWithStmt)\n        {\n            pnodeFnc->sxFnc.SetHasWithStmt(true);\n        }\n\n        PHASE_PRINT_TRACE1(\n            Js::SkipNestedDeferredPhase,\n            _u(\"Skipping nested deferred function %d. %s: %d...%d\\n\"),\n            pnodeFnc->sxFnc.functionId, GetFunctionName(pnodeFnc, pNameHint), pnodeFnc->ichMin, stub->restorePoint.m_ichMinTok);\n\n        m_pscan->SeekTo(stub->restorePoint, m_nextFunctionId);\n        pnodeFnc->sxFnc.nestedCount = stub->nestedCount;\n        pnodeFnc->sxFnc.deferredStub = stub->deferredStubs;\n        if (stub->fncFlags & kFunctionStrictMode)\n        {\n            pnodeFnc->sxFnc.SetStrictMode(true);\n        }\n    }\n    else\n    {\n        ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true /* isSourceElementList */);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n    m_ppnodeVar = ppnodeVarSave;\n\n    // Restore the scanner's default hashing mode.\n    // Do this before we consume the next token.\n    m_pscan->SetDeferredParseFlags(deferFlags);\n\n    ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n\n#if DBG\n    pnodeFnc->sxFnc.deferredParseNextFunctionId = *this->m_nextFunctionId;\n#endif\n    this->m_deferringAST = FALSE;\n}\n\nbool Parser::DoParallelParse(ParseNodePtr pnodeFnc) const\n{\n#if ENABLE_BACKGROUND_PARSING\n    if (!PHASE_ON_RAW(Js::ParallelParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId))\n    {\n        return false;\n    }\n\n    BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n    return bgp != nullptr;\n#else\n    return false;\n#endif\n}\n\nbool Parser::ScanAheadToFunctionEnd(uint count)\n{\n    bool found = false;\n    uint curlyDepth = 0;\n\n    RestorePoint funcStart;\n    m_pscan->Capture(&funcStart);\n\n    for (uint i = 0; i < count; i++)\n    {\n        switch (m_token.tk)\n        {\n            case tkStrTmplBegin:\n            case tkStrTmplMid:\n            case tkStrTmplEnd:\n            case tkDiv:\n            case tkAsgDiv:\n            case tkScanError:\n            case tkEOF:\n                goto LEnd;\n\n            case tkLCurly:\n                UInt32Math::Inc(curlyDepth, Parser::OutOfMemory);\n                break;\n\n            case tkRCurly:\n                if (curlyDepth == 1)\n                {\n                    found = true;\n                    goto LEnd;\n                }\n                if (curlyDepth == 0)\n                {\n                    goto LEnd;\n                }\n                curlyDepth--;\n                break;\n        }\n\n        m_pscan->ScanAhead();\n    }\n\n LEnd:\n    m_pscan->SeekTo(funcStart);\n    return found;\n}\n\nbool Parser::FastScanFormalsAndBody()\n{\n    // The scanner is currently pointing just past the name of a function.\n    // The idea here is to find the end of the function body as quickly as possible,\n    // by tokenizing and tracking {}'s if possible.\n    // String templates require some extra logic but can be handled.\n\n    // The real wrinkle is \"/\" and \"/=\", which may indicate either a RegExp literal or a division, depending\n    // on the context.\n    // To handle this with minimal work, keep track of the last \";\" seen at each {} depth. If we see one of the\n    // difficult tokens, rewind to the last \";\" at the current {} depth and parse statements until we pass the\n    // point where we had to rewind. This will process the \"/\" as required.\n\n    RestorePoint funcStart;\n    m_pscan->Capture(&funcStart);\n\n    const int maxRestorePointDepth = 16;\n    struct FastScanRestorePoint\n    {\n        RestorePoint restorePoint;\n        uint parenDepth;\n        Js::LocalFunctionId functionId;\n        int blockId;\n\n        FastScanRestorePoint() : restorePoint(), parenDepth(0) {};\n    };\n    FastScanRestorePoint lastSColonAtCurlyDepth[maxRestorePointDepth];\n\n    charcount_t ichStart = m_pscan->IchMinTok();\n    uint blockIdSave = m_nextBlockId;\n    uint functionIdSave = *m_nextFunctionId;\n    uint curlyDepth = 0;\n    uint strTmplDepth = 0;\n    for (;;)\n    {\n        switch (m_token.tk)\n        {\n            case tkStrTmplBegin:\n                UInt32Math::Inc(strTmplDepth, Parser::OutOfMemory);\n                // Fall through\n\n            case tkStrTmplMid:\n            case tkLCurly:\n                UInt32Math::Inc(curlyDepth, Parser::OutOfMemory);\n                Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                break;\n\n            case tkStrTmplEnd:\n                // We can assert here, because the scanner will only return this token if we've told it we're\n                // in a string template.\n                Assert(strTmplDepth > 0);\n                strTmplDepth--;\n                break;\n\n            case tkRCurly:\n                if (curlyDepth == 1)\n                {\n                    Assert(strTmplDepth == 0);\n                    if (PHASE_TRACE1(Js::ParallelParsePhase))\n                    {\n                        Output::Print(_u(\"Finished fast seek: %d. %s -- %d...%d\\n\"),\n                                      m_currentNodeFunc->sxFnc.functionId,\n                                      GetFunctionName(m_currentNodeFunc, m_currentNodeFunc->sxFnc.hint),\n                                      ichStart, m_pscan->IchLimTok());\n                    }\n                    return true;\n                }\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    lastSColonAtCurlyDepth[curlyDepth].restorePoint.m_ichMinTok = (uint)-1;\n                }\n                curlyDepth--;\n                if (strTmplDepth > 0)\n                {\n                    m_pscan->SetScanState(Scanner_t::ScanState::ScanStateStringTemplateMiddleOrEnd);\n                }\n                break;\n\n            case tkSColon:\n                // Track the location of the \";\" (if it's outside parens, as we don't, for instance, want\n                // to track the \";\"'s in a for-loop header. If we find it's important to rewind within a paren\n                // expression, we can do something more sophisticated.)\n                if (curlyDepth < maxRestorePointDepth && lastSColonAtCurlyDepth[curlyDepth].parenDepth == 0)\n                {\n                    m_pscan->Capture(&lastSColonAtCurlyDepth[curlyDepth].restorePoint);\n                    lastSColonAtCurlyDepth[curlyDepth].functionId = *this->m_nextFunctionId;\n                    lastSColonAtCurlyDepth[curlyDepth].blockId = m_nextBlockId;\n                }\n                break;\n\n            case tkLParen:\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    UInt32Math::Inc(lastSColonAtCurlyDepth[curlyDepth].parenDepth);\n                }\n                break;\n\n            case tkRParen:\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    Assert(lastSColonAtCurlyDepth[curlyDepth].parenDepth != 0);\n                    lastSColonAtCurlyDepth[curlyDepth].parenDepth--;\n                }\n                break;\n\n            case tkID:\n            {\n                charcount_t tokLength = m_pscan->IchLimTok() - m_pscan->IchMinTok();\n                // Detect the function and class keywords so we can track function ID's.\n                // (In fast mode, the scanner doesn't distinguish keywords and doesn't point the token\n                // to a PID.)\n                // Detect try/catch/for to increment block count for them.\n                switch (tokLength)\n                {\n                case 3:\n                    if (!memcmp(m_pscan->PchMinTok(), \"try\", 3) || !memcmp(m_pscan->PchMinTok(), \"for\", 3))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                    }\n                    break;\n                case 5:\n                    if (!memcmp(m_pscan->PchMinTok(), \"catch\", 5))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                    }\n                    else if (!memcmp(m_pscan->PchMinTok(), \"class\", 5))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                        Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                    }\n                    break;\n                case 8:\n                    if (!memcmp(m_pscan->PchMinTok(), \"function\", 8))\n                    {\n                        // Account for the possible func expr scope or dummy block for missing {}'s around a declaration\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                        Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                    }\n                    break;\n                }\n                break;\n            }\n\n            case tkDArrow:\n                Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                break;\n\n            case tkDiv:\n            case tkAsgDiv:\n            {\n                int opl;\n                OpCode nop;\n                tokens tkPrev = m_pscan->m_tkPrevious;\n                if ((m_pscan->m_phtbl->TokIsBinop(tkPrev, &opl, &nop) && nop != knopNone) ||\n                    (m_pscan->m_phtbl->TokIsUnop(tkPrev, &opl, &nop) &&\n                     nop != knopNone &&\n                     tkPrev != tkInc &&\n                     tkPrev != tkDec) ||\n                    tkPrev == tkColon ||\n                    tkPrev == tkLParen ||\n                    tkPrev == tkLBrack ||\n                    tkPrev == tkRETURN)\n                {\n                    // Previous token indicates that we're starting an expression here and can't have a\n                    // binary operator now.\n                    // Assume this is a RegExp.\n                    ParseRegExp<false>();\n                    break;\n                }\n                uint tempCurlyDepth = curlyDepth < maxRestorePointDepth ? curlyDepth : maxRestorePointDepth - 1;\n                for (; tempCurlyDepth != (uint)-1; tempCurlyDepth--)\n                {\n                    // We don't know whether we've got a RegExp or a divide. Rewind to the last safe \";\"\n                    // if we can and parse statements until we pass this point.\n                    if (lastSColonAtCurlyDepth[tempCurlyDepth].restorePoint.m_ichMinTok != -1)\n                    {\n                        break;\n                    }\n                }\n                if (tempCurlyDepth != (uint)-1)\n                {\n                    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n                    int32 *pastSizeSave = m_pCurrentAstSize;\n                    uint *pnestedCountSave = m_pnestedCount;\n                    ParseNodePtr *ppnodeScopeSave = m_ppnodeScope;\n                    ParseNodePtr *ppnodeExprScopeSave = m_ppnodeExprScope;\n\n                    ParseNodePtr pnodeFnc = CreateDummyFuncNode(true);\n                    m_ppnodeScope = &pnodeFnc->sxFnc.pnodeScopes;\n                    m_ppnodeExprScope = nullptr;\n\n                    charcount_t ichStop = m_pscan->IchLimTok();\n                    curlyDepth = tempCurlyDepth;\n                    m_pscan->SeekTo(lastSColonAtCurlyDepth[tempCurlyDepth].restorePoint);\n                    m_nextBlockId = lastSColonAtCurlyDepth[tempCurlyDepth].blockId;\n                    *this->m_nextFunctionId = lastSColonAtCurlyDepth[tempCurlyDepth].functionId;\n\n                    ParseNodePtr pnodeBlock = StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n\n                    m_pscan->Scan();\n                    do\n                    {\n                        ParseStatement<false>();\n                    }\n                    while(m_pscan->IchMinTok() < ichStop);\n\n                    FinishParseBlock(pnodeBlock);\n\n                    m_currentNodeFunc = pnodeFncSave;\n                    m_pCurrentAstSize = pastSizeSave;\n                    m_pnestedCount = pnestedCountSave;\n                    m_ppnodeScope = ppnodeScopeSave;\n                    m_ppnodeExprScope = ppnodeExprScopeSave;\n\n                    // We've already consumed the first token of the next statement, so just continue\n                    // without a further scan.\n                    continue;\n                }\n            }\n\n                // fall through to rewind to function start\n            case tkScanError:\n            case tkEOF:\n                // Unexpected token.\n                if (PHASE_TRACE1(Js::ParallelParsePhase))\n                {\n                    Output::Print(_u(\"Failed fast seek: %d. %s -- %d...%d\\n\"),\n                                  m_currentNodeFunc->sxFnc.functionId,\n                                  GetFunctionName(m_currentNodeFunc, m_currentNodeFunc->sxFnc.hint),\n                                  ichStart, m_pscan->IchLimTok());\n                }\n                m_nextBlockId = blockIdSave;\n                *m_nextFunctionId = functionIdSave;\n                m_pscan->SeekTo(funcStart);\n                return false;\n        }\n\n        m_pscan->ScanNoKeywords();\n    }\n}\n\nParseNodePtr Parser::CreateDummyFuncNode(bool fDeclaration)\n{\n    // Create a dummy node and make it look like the current function declaration.\n    // Do this in situations where we want to parse statements without impacting\n    // the state of the \"real\" AST.\n\n    ParseNodePtr pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetDeclaration(fDeclaration);\n    pnodeFnc->sxFnc.astSize             = 0;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.SetNested(m_currentNodeFunc != nullptr); // If there is a current function, then we're a nested function.\n    pnodeFnc->sxFnc.SetStrictMode(IsStrictMode()); // Inherit current strict mode -- may be overridden by the function itself if it contains a strict mode directive.\n    pnodeFnc->sxFnc.firstDefaultArg = 0;\n\n    m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n    m_currentNodeFunc = pnodeFnc;\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    return pnodeFnc;\n}\n\nvoid Parser::ParseNestedDeferredFunc(ParseNodePtr pnodeFnc, bool fLambda, bool *pNeedScanRCurly, bool *pStrictModeTurnedOn)\n{\n    // Parse a function nested inside another deferred function.\n\n    size_t lengthBeforeBody = this->GetSourceLength();\n\n    if (m_token.tk != tkLCurly && fLambda)\n    {\n        ParseExpressionLambdaBody<false>(pnodeFnc);\n        *pNeedScanRCurly = false;\n    }\n    else\n    {\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        bool* detectStrictModeOn = IsStrictMode() ? nullptr : pStrictModeTurnedOn;\n        m_ppnodeVar = &m_currentNodeDeferredFunc->sxFnc.pnodeVars;\n\n        ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true /* isSourceElementList */, detectStrictModeOn);\n\n        ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n    if (*pStrictModeTurnedOn)\n    {\n        pnodeFnc->sxFnc.SetStrictMode(true);\n    }\n\n    if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n    {\n        // Record the end of the function and the function ID increment that happens inside the function.\n        // Byte code gen will use this to build stub information to allow us to skip this function when the\n        // enclosing function is fully parsed.\n        RestorePoint *restorePoint = Anew(&m_nodeAllocator, RestorePoint);\n        m_pscan->Capture(restorePoint,\n                         *m_nextFunctionId - pnodeFnc->sxFnc.functionId - 1,\n                         lengthBeforeBody - this->GetSourceLength());\n        pnodeFnc->sxFnc.pRestorePoint = restorePoint;\n    }\n}\n\ntemplate<bool buildAST>\nbool Parser::ParseFncNames(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncParent, ushort flags, ParseNodePtr **pLastNodeRef)\n{\n    BOOL fDeclaration = flags & fFncDeclaration;\n    BOOL fIsAsync = flags & fFncAsync;\n    ParseNodePtr pnodeT;\n    charcount_t ichMinNames, ichLimNames;\n\n    // Get the names to bind to.\n    /*\n    * KaushiS [5/15/08]:\n    * ECMAScript defines a FunctionExpression as follows:\n    *\n    * \"function\" [Identifier] ( [FormalParameterList] ) { FunctionBody }\n    *\n    * The function name being optional is omitted by most real world\n    * code that uses a FunctionExpression to define a function. This however\n    * is problematic for tools because there isn't a function name that\n    * the runtime can provide.\n    *\n    * To fix this (primarily for the profiler), I'm adding simple, static\n    * name inferencing logic to the parser. When it encounters the following\n    * productions\n    *\n    *   \"var\" Identifier \"=\" FunctionExpression\n    *   \"var\" IdentifierA.IdentifierB...Identifier \"=\" FunctionExpression\n    *   Identifier = FunctionExpression\n    *   \"{\" Identifier: FunctionExpression \"}\"\n    *\n    * it associates Identifier with the function created by the\n    * FunctionExpression. This identifier is *not* the function's name. It\n    * is ignored by the runtime and is only an additional piece of information\n    * about the function (function name hint) that tools could opt to\n    * surface.\n    */\n\n    m_pscan->Scan();\n\n    // If generators are enabled then we are in a recent enough version\n    // that deferred parsing will create a parse node for pnodeFnc and\n    // it is safe to assume it is not null.\n    if (flags & fFncGenerator)\n    {\n        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n        pnodeFnc->sxFnc.SetIsGenerator();\n    }\n    else if (m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n        m_token.tk == tkStar &&\n        !(flags & fFncClassMember))\n    {\n        if (!fDeclaration)\n        {\n            bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(!fDeclaration);\n            m_pscan->Scan();\n            m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n        }\n        else\n        {\n            m_pscan->Scan();\n        }\n\n        pnodeFnc->sxFnc.SetIsGenerator();\n    }\n\n    if (fIsAsync)\n    {\n        if (pnodeFnc->sxFnc.IsGenerator())\n        {\n            Error(ERRsyntax);\n        }\n        pnodeFnc->sxFnc.SetIsAsync();\n    }\n\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.pnodeName = nullptr;\n    }\n\n    if ((m_token.tk != tkID || flags & fFncNoName)\n        && (IsStrictMode() || (pnodeFnc && pnodeFnc->sxFnc.IsGenerator()) || m_token.tk != tkYIELD || fDeclaration)) // Function expressions can have the name yield even inside generator functions\n    {\n        if (fDeclaration  ||\n            m_token.IsReservedWord())  // For example:  var x = (function break(){});\n        {\n            IdentifierExpectedError(m_token);\n        }\n        return false;\n    }\n\n    ichMinNames = m_pscan->IchMinTok();\n\n\n    Assert(m_token.tk == tkID || (m_token.tk == tkYIELD && !fDeclaration));\n\n    if (IsStrictMode())\n    {\n        CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n    }\n    Token tokenBase = m_token;\n    charcount_t ichMinBase = m_pscan->IchMinTok();\n    charcount_t ichLimBase = m_pscan->IchLimTok();\n\n    m_pscan->Scan();\n\n    IdentPtr pidBase = tokenBase.GetIdentifier(m_phtbl);\n    pnodeT = CreateDeclNode(knopVarDecl, pidBase, STFunction);\n    pnodeT->ichMin = ichMinBase;\n    pnodeT->ichLim = ichLimBase;\n\n    if (fDeclaration &&\n        pnodeFncParent &&\n        pnodeFncParent->sxFnc.pnodeName &&\n        pnodeFncParent->sxFnc.pnodeName->nop == knopVarDecl &&\n        pnodeFncParent->sxFnc.pnodeName->sxVar.pid == pidBase)\n    {\n        pnodeFncParent->sxFnc.SetNameIsHidden();\n    }\n\n    if (buildAST)\n    {\n        AnalysisAssert(pnodeFnc);\n        ichLimNames = pnodeT->ichLim;\n        AddToNodeList(&pnodeFnc->sxFnc.pnodeName, pLastNodeRef, pnodeT);\n\n        pnodeFnc->sxFnc.pnodeName->ichMin = ichMinNames;\n        pnodeFnc->sxFnc.pnodeName->ichLim = ichLimNames;\n        if (knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n        {\n            // Only one name (the common case).\n            pnodeFnc->sxFnc.pid = pnodeFnc->sxFnc.pnodeName->sxVar.pid;\n        }\n        else\n        {\n            // Multiple names. Turn the source into an IdentPtr.\n            pnodeFnc->sxFnc.pid = m_phtbl->PidHashNameLen(\n                m_pscan->PchBase() + ichMinNames, \n                m_pscan->AdjustedLast(),\n                ichLimNames - ichMinNames);\n        }\n    }\n\n    return true;\n}\n\nvoid Parser::ValidateFormals()\n{\n    ParseFncFormals<false>(nullptr, nullptr, fFncNoFlgs);\n    // Eat the tkRParen. The ParseFncDeclHelper caller expects to see it.\n    m_pscan->Scan();\n}\n\nvoid Parser::ValidateSourceElementList()\n{\n    ParseStmtList<false>(nullptr, nullptr, SM_NotUsed, true);\n}\n\nvoid Parser::UpdateOrCheckForDuplicateInFormals(IdentPtr pid, SList<IdentPtr> *formals)\n{\n    bool isStrictMode = IsStrictMode();\n    if (isStrictMode)\n    {\n        CheckStrictModeEvalArgumentsUsage(pid);\n    }\n\n    if (formals->Has(pid))\n    {\n        if (isStrictMode)\n        {\n            Error(ERRES5ArgSame);\n        }\n        else\n        {\n            Error(ERRFormalSame);\n        }\n    }\n    else\n    {\n        formals->Prepend(pid);\n    }\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseFncFormals(ParseNodePtr pnodeFnc, ParseNodePtr pnodeParentFnc, ushort flags)\n{\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fMethod = (flags & fFncMethod) != 0;\n    bool fNoArg = (flags & fFncNoArg) != 0;\n    bool fOneArg = (flags & fFncOneArg) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n\n    bool fPreviousYieldIsKeyword = false;\n    bool fPreviousAwaitIsKeyword = false;\n\n    if (fLambda)\n    {\n        fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeParentFnc != nullptr && pnodeParentFnc->sxFnc.IsGenerator());\n        fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync || (pnodeParentFnc != nullptr && pnodeParentFnc->sxFnc.IsAsync()));\n    }\n\n    Assert(!fNoArg || !fOneArg); // fNoArg and fOneArg can never be true at the same time.\n\n    // strictFormals corresponds to the StrictFormalParameters grammar production\n    // in the ES spec which just means duplicate names are not allowed\n    bool fStrictFormals = IsStrictMode() || fLambda || fMethod;\n\n    // When detecting duplicated formals pids are needed so force PID creation (unless the function should take 0 or 1 arg).\n    bool forcePid = fStrictFormals && !fNoArg && !fOneArg;\n    AutoTempForcePid autoForcePid(m_pscan, forcePid);\n\n    // Lambda's allow single formal specified by a single binding identifier without parentheses, special case it.\n    if (fLambda && m_token.tk == tkID)\n    {\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n\n        CreateVarDeclNode(pid, STFormal, false, nullptr, false);\n        CheckPidIsValid(pid);\n\n        m_pscan->Scan();\n\n        if (m_token.tk != tkDArrow)\n        {\n            Error(ERRsyntax, m_pscan->IchMinTok(), m_pscan->IchLimTok());\n        }\n\n        if (fLambda)\n        {\n            m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n            m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n        }\n\n        return;\n    }\n    else if (fLambda && m_token.tk == tkAWAIT)\n    {\n        // async await => {}\n        IdentifierExpectedError(m_token);\n    }\n\n    // Otherwise, must have a parameter list within parens.\n    ChkCurTok(tkLParen, ERRnoLparen);\n\n    // Now parse the list of arguments, if present\n    if (m_token.tk == tkRParen)\n    {\n        if (fOneArg)\n        {\n            Error(ERRSetterMustHaveOneParameter);\n        }\n    }\n    else\n    {\n        if (fNoArg)\n        {\n            Error(ERRGetterMustHaveNoParameters);\n        }\n        SList<IdentPtr> formals(&m_nodeAllocator);\n        ParseNodePtr pnodeT = nullptr;\n        bool seenRestParameter = false;\n        bool isNonSimpleParameterList = false;\n        for (Js::ArgSlot argPos = 0; ; ++argPos)\n        {\n            bool isBindingPattern = false;\n            if (m_scriptContext->GetConfig()->IsES6RestEnabled() && m_token.tk == tkEllipsis)\n            {\n                // Possible rest parameter\n                m_pscan->Scan();\n                seenRestParameter = true;\n            }\n            if (m_token.tk != tkID)\n            {\n                if (IsES6DestructuringEnabled() && IsPossiblePatternStart())\n                {\n                    // Mark that the function has a non simple parameter list before parsing the pattern since the pattern can have function definitions.\n                    this->GetCurrentFunctionNode()->sxFnc.SetHasNonSimpleParameterList();\n\n                    ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n                    ParseNodePtr * ppNodeLex = m_currentBlockInfo->m_ppnodeLex;\n                    Assert(ppNodeLex != nullptr);\n\n                    ParseNodePtr paramPattern = nullptr;\n                    ParseNodePtr pnodePattern = ParseDestructuredLiteral<buildAST>(tkLET, true /*isDecl*/, false /*topLevel*/);\n\n                    // Instead of passing the STFormal all the way on many methods, it seems it is better to change the symbol type afterward.\n                    for (ParseNodePtr lexNode = *ppNodeLex; lexNode != nullptr; lexNode = lexNode->sxVar.pnodeNext)\n                    {\n                        Assert(lexNode->IsVarLetOrConst());\n                        UpdateOrCheckForDuplicateInFormals(lexNode->sxVar.pid, &formals);\n                        lexNode->sxVar.sym->SetSymbolType(STFormal);\n                        if (m_currentNodeFunc != nullptr && lexNode->sxVar.pid == wellKnownPropertyPids.arguments)\n                        {\n                            m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                        }\n                    }\n\n                    m_ppnodeVar = ppnodeVarSave;\n                    if (buildAST)\n                    {\n                        paramPattern = CreateParamPatternNode(pnodePattern);\n\n                        // Linking the current formal parameter (which is pattern parameter) with other formals.\n                        *m_ppnodeVar = paramPattern;\n                        paramPattern->sxParamPattern.pnodeNext = nullptr;\n                        m_ppnodeVar = &paramPattern->sxParamPattern.pnodeNext;\n                    }\n\n                    isBindingPattern = true;\n                    isNonSimpleParameterList = true;\n                }\n                else\n                {\n                    IdentifierExpectedError(m_token);\n                }\n            }\n\n            if (!isBindingPattern)\n            {\n                IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n                LPCOLESTR pNameHint = pid->Psz();\n                uint32 nameHintLength = pid->Cch();\n                uint32 nameHintOffset = 0;\n\n                if (seenRestParameter)\n                {\n                    this->GetCurrentFunctionNode()->sxFnc.SetHasNonSimpleParameterList();\n                    if (flags & fFncOneArg)\n                    {\n                        // The parameter of a setter cannot be a rest parameter.\n                        Error(ERRUnexpectedEllipsis);\n                    }\n                    pnodeT = CreateDeclNode(knopVarDecl, pid, STFormal, false);\n                    pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    if (buildAST)\n                    {\n                        // When only validating formals, we won't have a function node.\n                        pnodeFnc->sxFnc.pnodeRest = pnodeT;\n                        if (!isNonSimpleParameterList)\n                        {\n                            // This is the first non-simple parameter we've seen. We need to go back\n                            // and set the Symbols of all previous parameters.\n                            MapFormalsWithoutRest(m_currentNodeFunc, [&](ParseNodePtr pnodeArg) { pnodeArg->sxVar.sym->SetIsNonSimpleParameter(true); });\n                        }\n                    }\n\n                    isNonSimpleParameterList = true;\n                }\n                else\n                {\n                    pnodeT = CreateVarDeclNode(pid, STFormal, false, nullptr, false);\n                    if (isNonSimpleParameterList)\n                    {\n                        pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    }\n                }\n\n                if (buildAST && pid == wellKnownPropertyPids.arguments)\n                {\n                    // This formal parameter overrides the built-in 'arguments' object\n                    m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                }\n\n                if (fStrictFormals)\n                {\n                    UpdateOrCheckForDuplicateInFormals(pid, &formals);\n                }\n\n                m_pscan->Scan();\n\n                if (seenRestParameter && m_token.tk != tkRParen && m_token.tk != tkAsg)\n                {\n                    Error(ERRRestLastArg);\n                }\n\n                if (m_token.tk == tkAsg && m_scriptContext->GetConfig()->IsES6DefaultArgsEnabled())\n                {\n                    if (seenRestParameter && m_scriptContext->GetConfig()->IsES6RestEnabled())\n                    {\n                        Error(ERRRestWithDefault);\n                    }\n\n                    // In defer parse mode we have to flag the function node to indicate that it has default arguments\n                    // so that it will be considered for any syntax error scenario.\n                    // Also mark it before parsing the expression as it may contain functions.\n                    ParseNode* currentFncNode = GetCurrentFunctionNode();\n                    if (!currentFncNode->sxFnc.HasDefaultArguments())\n                    {\n                        currentFncNode->sxFnc.SetHasDefaultArguments();\n                        currentFncNode->sxFnc.SetHasNonSimpleParameterList();\n                        currentFncNode->sxFnc.firstDefaultArg = argPos;\n                    }\n\n                    m_pscan->Scan();\n                    ParseNodePtr pnodeInit = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, pNameHint, &nameHintLength, &nameHintOffset);\n\n                    if (buildAST && pnodeInit->nop == knopFncDecl)\n                    {\n                        Assert(nameHintLength >= nameHintOffset);\n                        pnodeInit->sxFnc.hint = pNameHint;\n                        pnodeInit->sxFnc.hintLength = nameHintLength;\n                        pnodeInit->sxFnc.hintOffset = nameHintOffset;\n                    }\n\n                    AnalysisAssert(pnodeT);\n                    pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    if (!isNonSimpleParameterList)\n                    {\n                        if (buildAST)\n                        {\n                            // This is the first non-simple parameter we've seen. We need to go back\n                            // and set the Symbols of all previous parameters.\n                            MapFormalsWithoutRest(m_currentNodeFunc, [&](ParseNodePtr pnodeArg) { pnodeArg->sxVar.sym->SetIsNonSimpleParameter(true); });\n                        }\n\n                        // There may be previous parameters that need to be checked for duplicates.\n                        isNonSimpleParameterList = true;\n                    }\n\n                    if (buildAST)\n                    {\n                        if (!m_currentNodeFunc->sxFnc.HasDefaultArguments())\n                        {\n                            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(DefaultArgFunction, m_scriptContext);\n                        }\n                        pnodeT->sxVar.pnodeInit = pnodeInit;\n                        pnodeT->ichLim = m_pscan->IchLimTok();\n                    }\n                }\n            }\n\n            if (isNonSimpleParameterList && m_currentScope->GetHasDuplicateFormals())\n            {\n                Error(ERRFormalSame);\n            }\n\n            if (flags & fFncOneArg)\n            {\n                if (m_token.tk != tkRParen)\n                {\n                    Error(ERRSetterMustHaveOneParameter);\n                }\n                break; //enforce only one arg\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n\n        if (seenRestParameter)\n        {\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Rest, m_scriptContext);\n        }\n\n        if (m_token.tk != tkRParen)\n        {\n            Error(ERRnoRparen);\n        }\n\n        if (this->GetCurrentFunctionNode()->sxFnc.CallsEval() || this->GetCurrentFunctionNode()->sxFnc.ChildCallsEval())\n        {\n            if (!m_scriptContext->GetConfig()->IsES6DefaultArgsSplitScopeEnabled())\n            {\n                Error(ERREvalNotSupportedInParamScope);\n            }\n            else\n            {\n                Assert(pnodeFnc->sxFnc.HasNonSimpleParameterList());\n                pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope->SetCannotMergeWithBodyScope();\n            }\n        }\n    }\n    Assert(m_token.tk == tkRParen);\n\n    if (fLambda)\n    {\n        m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n        m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n    }\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::GenerateModuleFunctionWrapper()\n{\n    ParseNodePtr pnodeFnc = ParseFncDecl<buildAST>(fFncModule, nullptr, false, true, true);\n    ParseNodePtr callNode = CreateCallNode(knopCall, pnodeFnc, nullptr);\n\n    return callNode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::GenerateEmptyConstructor(bool extends)\n{\n    ParseNodePtr pnodeFnc;\n\n    // Create the node.\n    pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetNested(NULL != m_currentNodeFunc);\n    pnodeFnc->sxFnc.SetStrictMode();\n    pnodeFnc->sxFnc.SetDeclaration(TRUE);\n    pnodeFnc->sxFnc.SetIsMethod(TRUE);\n    pnodeFnc->sxFnc.SetIsClassMember(TRUE);\n    pnodeFnc->sxFnc.SetIsClassConstructor(TRUE);\n    pnodeFnc->sxFnc.SetIsBaseClassConstructor(!extends);\n    pnodeFnc->sxFnc.SetHasNonThisStmt();\n    pnodeFnc->sxFnc.SetIsGeneratedDefault(TRUE);\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->ichMin = m_pscan->IchMinTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n    pnodeFnc->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFnc->sxFnc.astSize = 0;\n    pnodeFnc->sxFnc.lineNumber = m_pscan->LineCur();\n\n    pnodeFnc->sxFnc.functionId          = (*m_nextFunctionId);\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.pnodeBody           = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n\n    // In order to (re-)defer the default constructor, we need to, for instance, track\n    // deferred class expression the way we track function expression, since we lose the part of the source\n    // that tells us which we have.\n    pnodeFnc->sxFnc.canBeDeferred       = false;\n\n#ifdef DBG\n    pnodeFnc->sxFnc.deferredParseNextFunctionId = *(this->m_nextFunctionId);\n#endif\n\n    AppendFunctionToScopeList(true, pnodeFnc);\n\n    if (m_nextFunctionId)\n    {\n        (*m_nextFunctionId)++;\n    }\n\n    // Update the count of functions nested in the current parent.\n    if (m_pnestedCount)\n    {\n        (*m_pnestedCount)++;\n    }\n\n    if (!buildAST)\n    {\n        return NULL;\n    }\n\n    if (m_pscan->IchMinTok() >= m_pscan->IchMinLine())\n    {\n        // In scenarios involving defer parse IchMinLine() can be incorrect for the first line after defer parse\n        pnodeFnc->sxFnc.columnNumber = m_pscan->IchMinTok() - m_pscan->IchMinLine();\n    }\n    else if (m_currentNodeFunc)\n    {\n        // For the first line after defer parse, compute the column relative to the column number\n        // of the lexically parent function.\n        ULONG offsetFromCurrentFunction = m_pscan->IchMinTok() - m_currentNodeFunc->ichMin;\n        pnodeFnc->sxFnc.columnNumber = m_currentNodeFunc->sxFnc.columnNumber + offsetFromCurrentFunction;\n    }\n    else\n    {\n        // if there is no current function, lets give a default of 0.\n        pnodeFnc->sxFnc.columnNumber = 0;\n    }\n\n    int32 * pAstSizeSave = m_pCurrentAstSize;\n    m_pCurrentAstSize = &(pnodeFnc->sxFnc.astSize);\n\n    // Make this the current function.\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    m_currentNodeFunc = pnodeFnc;\n\n    ParseNodePtr argsId = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n\n    if (extends)\n    {\n        // constructor(...args) { super(...args); }\n        //             ^^^^^^^\n        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n        IdentPtr pidargs = m_phtbl->PidHashNameLen(_u(\"args\"), sizeof(\"args\") - 1);\n        ParseNodePtr pnodeT = CreateVarDeclNode(pidargs, STFormal);\n        pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n        pnodeFnc->sxFnc.pnodeRest = pnodeT;\n        PidRefStack *ref = this->PushPidRef(pidargs);\n\n        argsId = CreateNameNode(pidargs, pnodeFnc->ichMin, pnodeFnc->ichLim);\n\n        argsId->sxPid.symRef = ref->GetSymRef();\n        m_ppnodeVar = ppnodeVarSave;\n    }\n\n    ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n    pnodeBlock->sxBlock.pnodeScopes = pnodeInnerBlock;\n    pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n    pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n\n    if (extends)\n    {\n        // constructor(...args) { super(...args); }\n        //                        ^^^^^^^^^^^^^^^\n        Assert(argsId);\n        ParseNodePtr spreadArg = CreateUniNode(knopEllipsis, argsId, pnodeFnc->ichMin, pnodeFnc->ichLim);\n\n        ParseNodePtr superRef = CreateNodeWithScanner<knopSuper>();\n        pnodeFnc->sxFnc.SetHasSuperReference(TRUE);\n\n        ParseNodePtr callNode = CreateCallNode(knopCall, superRef, spreadArg);\n        callNode->sxCall.spreadArgCount = 1;\n        AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, callNode);\n    }\n\n    AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n\n    FinishParseBlock(pnodeInnerBlock);\n    FinishParseBlock(pnodeBlock);\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n\n    return pnodeFnc;\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseExpressionLambdaBody(ParseNodePtr pnodeLambda)\n{\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    // The lambda body is a single expression, the result of which is the return value.\n    ParseNodePtr pnodeRet = nullptr;\n\n    if (buildAST)\n    {\n        pnodeRet = CreateNodeWithScanner<knopReturn>();\n        pnodeRet->grfpn |= PNodeFlags::fpnSyntheticNode;\n        pnodeLambda->sxFnc.pnodeScopes->sxBlock.pnodeStmt = pnodeRet;\n    }\n\n    IdentToken token;\n    charcount_t lastRParen = 0;\n    ParseNodePtr result = ParseExpr<buildAST>(koplAsg, nullptr, TRUE, FALSE, nullptr, nullptr, nullptr, &token, false, nullptr, &lastRParen);\n\n    this->MarkEscapingRef(result, &token);\n\n    if (buildAST)\n    {\n        pnodeRet->sxReturn.pnodeExpr = result;\n\n        pnodeRet->ichMin = pnodeRet->sxReturn.pnodeExpr->ichMin;\n        pnodeRet->ichLim = pnodeRet->sxReturn.pnodeExpr->ichLim;\n\n        // Pushing a statement node with PushStmt<>() normally does this initialization\n        // but do it here manually since we know there is no outer statement node.\n        pnodeRet->sxStmt.grfnop = 0;\n        pnodeRet->sxStmt.pnodeOuter = nullptr;\n\n        pnodeLambda->ichLim = max(pnodeRet->ichLim, lastRParen);\n        pnodeLambda->sxFnc.cbLim = m_pscan->IecpLimTokPrevious();\n        pnodeLambda->sxFnc.pnodeScopes->ichLim = pnodeRet->ichLim;\n\n        pnodeLambda->sxFnc.pnodeBody = nullptr;\n        AddToNodeList(&pnodeLambda->sxFnc.pnodeBody, &lastNodeRef, pnodeLambda->sxFnc.pnodeScopes);\n\n        // Append an EndCode node.\n        ParseNodePtr end = CreateNodeWithScanner<knopEndCode>(pnodeRet->ichLim);\n        end->ichLim = end->ichMin; // make end code zero width at the immediate end of lambda body\n        AddToNodeList(&pnodeLambda->sxFnc.pnodeBody, &lastNodeRef, end);\n\n        // Lambda's do not have arguments binding\n        pnodeLambda->sxFnc.SetHasReferenceableBuiltInArguments(false);\n    }\n}\n\nvoid Parser::CheckStrictFormalParameters()\n{\n    if (m_token.tk == tkID)\n    {\n        // single parameter arrow function case\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        CheckStrictModeEvalArgumentsUsage(pid);\n        return;\n    }\n\n    Assert(m_token.tk == tkLParen);\n    m_pscan->ScanForcingPid();\n\n    if (m_token.tk != tkRParen)\n    {\n        SList<IdentPtr> formals(&m_nodeAllocator);\n        for (;;)\n        {\n            if (m_token.tk != tkID)\n            {\n                IdentifierExpectedError(m_token);\n            }\n\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n            CheckStrictModeEvalArgumentsUsage(pid);\n            if (formals.Has(pid))\n            {\n                Error(ERRES5ArgSame, m_pscan->IchMinTok(), m_pscan->IchLimTok());\n            }\n            else\n            {\n                formals.Prepend(pid);\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkAsg && m_scriptContext->GetConfig()->IsES6DefaultArgsEnabled())\n            {\n                m_pscan->Scan();\n                // We can avoid building the AST since we are just checking the default expression.\n                ParseNodePtr pnodeInit = ParseExpr<false>(koplCma);\n                Assert(pnodeInit == nullptr);\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n            m_pscan->ScanForcingPid();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n    }\n    Assert(m_token.tk == tkRParen);\n}\n\nvoid Parser::FinishFncNode(ParseNodePtr pnodeFnc)\n{\n    AnalysisAssert(pnodeFnc);\n\n    // Finish the AST for a function that was deferred earlier, but which we decided\n    // to finish after the fact.\n    // We assume that the name(s) and arg(s) have already got parse nodes, so\n    // we just have to do the function body.\n\n    // Save the current next function Id, and resume from the old one.\n    Js::LocalFunctionId * nextFunctionIdSave = m_nextFunctionId;\n    Js::LocalFunctionId tempNextFunctionId = pnodeFnc->sxFnc.functionId + 1;\n    this->m_nextFunctionId = &tempNextFunctionId;\n\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    uint *pnestedCountSave = m_pnestedCount;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    m_currentNodeFunc = pnodeFnc;\n    m_pCurrentAstSize = & (pnodeFnc->sxFnc.astSize);\n\n    pnodeFnc->sxFnc.nestedCount = 0;\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    // Cue up the parser to the start of the function body.\n    if (pnodeFnc->sxFnc.pnodeName)\n    {\n        // Skip the name(s).\n        m_pscan->SetCurrentCharacter(pnodeFnc->sxFnc.pnodeName->ichLim, pnodeFnc->sxFnc.lineNumber);\n    }\n    else\n    {\n        m_pscan->SetCurrentCharacter(pnodeFnc->ichMin, pnodeFnc->sxFnc.lineNumber);\n        if (pnodeFnc->sxFnc.IsAccessor())\n        {\n            // Getter/setter. The node text starts with the name, so eat that.\n            m_pscan->ScanNoKeywords();\n        }\n        else\n        {\n            // Anonymous function. Skip any leading \"(\"'s and \"function\".\n            for (;;)\n            {\n                m_pscan->Scan();\n                if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async)\n                {\n                    Assert(pnodeFnc->sxFnc.IsAsync());\n                    continue;\n                }\n                if (m_token.tk == tkFUNCTION)\n                {\n                    break;\n                }\n                Assert(m_token.tk == tkLParen || m_token.tk == tkStar);\n            }\n        }\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsAsync());\n\n    // Skip the arg list.\n    m_pscan->ScanNoKeywords();\n    if (m_token.tk == tkStar)\n    {\n        Assert(pnodeFnc->sxFnc.IsGenerator());\n        m_pscan->ScanNoKeywords();\n    }\n    Assert(m_token.tk == tkLParen);\n    m_pscan->ScanNoKeywords();\n\n    if (m_token.tk != tkRParen)\n    {\n        for (;;)\n        {\n            if (m_token.tk == tkEllipsis)\n            {\n                m_pscan->ScanNoKeywords();\n            }\n\n            if (m_token.tk == tkID)\n            {\n                m_pscan->ScanNoKeywords();\n\n                if (m_token.tk == tkAsg)\n                {\n                    // Eat the default expression\n                    m_pscan->Scan();\n                    ParseExpr<false>(koplCma);\n                }\n            }\n            else if (IsPossiblePatternStart())\n            {\n                ParseDestructuredLiteralWithScopeSave(tkLET, false/*isDecl*/, false /*topLevel*/);\n            }\n            else\n            {\n                AssertMsg(false, \"Unexpected identifier prefix while fast-scanning formals\");\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n            m_pscan->ScanNoKeywords();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n    }\n\n    if (m_token.tk == tkRParen) // This might be false due to a lambda => token.\n    {\n        m_pscan->Scan();\n    }\n\n    // Finish the function body.\n    {\n        // Note that in IE8- modes, surrounding parentheses are considered part of function body. e.g. \"( function x(){} )\".\n        // We lose that context here since we start from middle of function body. So save and restore source range info.\n        ParseNodePtr* lastNodeRef = NULL;\n        const charcount_t ichLim = pnodeFnc->ichLim;\n        const size_t cbLim = pnodeFnc->sxFnc.cbLim;\n        this->FinishFncDecl(pnodeFnc, NULL, lastNodeRef);\n\n#if DBG\n        // The pnode extent may not match the original extent.\n        // We expect this to happen only when there are trailing \")\"'s.\n        // Consume them and make sure that's all we've got.\n        if (pnodeFnc->ichLim != ichLim)\n        {\n            Assert(pnodeFnc->ichLim < ichLim);\n            m_pscan->SetCurrentCharacter(pnodeFnc->ichLim);\n            while (m_pscan->IchLimTok() != ichLim)\n            {\n                m_pscan->ScanNoKeywords();\n                Assert(m_token.tk == tkRParen);\n            }\n        }\n#endif\n        pnodeFnc->ichLim = ichLim;\n        pnodeFnc->sxFnc.cbLim = cbLim;\n    }\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n    m_pnestedCount = pnestedCountSave;\n    Assert(m_pnestedCount);\n\n    Assert(tempNextFunctionId == pnodeFnc->sxFnc.deferredParseNextFunctionId);\n    this->m_nextFunctionId = nextFunctionIdSave;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n}\n\nvoid Parser::FinishFncDecl(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ParseNodePtr *lastNodeRef, bool skipCurlyBraces)\n{\n    LPCOLESTR name = NULL;\n    JS_ETW(int32 startAstSize = *m_pCurrentAstSize);\n    if (IS_JS_ETW(EventEnabledJSCRIPT_PARSE_METHOD_START()) || PHASE_TRACE1(Js::DeferParsePhase))\n    {\n        name = GetFunctionName(pnodeFnc, pNameHint);\n        m_functionBody = NULL;  // for nested functions we do not want to get the name of the top deferred function return name;\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_START(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeFnc->sxFnc.functionId, 0, m_parseType, name));\n        OUTPUT_TRACE(Js::DeferParsePhase, _u(\"Parsing function (%s) : %s (%d)\\n\"), GetParseType(), name, pnodeFnc->sxFnc.functionId);\n    }\n\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_FUNC(GetScriptContext(), pnodeFnc->sxFnc.functionId, /*Undefer*/FALSE));\n\n\n    // Do the work of creating an AST for a function body.\n    // This is common to the un-deferred case and the case in which we un-defer late in the game.\n\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    if (!skipCurlyBraces)\n    {\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n    }\n\n    ParseStmtList<true>(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, SM_OnFunctionCode, true /* isSourceElementList */);\n    // Append an EndCode node.\n    AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n\n    if (!skipCurlyBraces)\n    {\n        ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n#ifdef ENABLE_JS_ETW\n    int32 astSize = *m_pCurrentAstSize - startAstSize;\n    EventWriteJSCRIPT_PARSE_METHOD_STOP(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeFnc->sxFnc.functionId, astSize, m_parseType, name);\n#endif\n}\n\nvoid Parser::AddArgumentsNodeToVars(ParseNodePtr pnodeFnc)\n{\n    if((pnodeFnc->grfpn & PNodeFlags::fpnArguments_overriddenByDecl) || pnodeFnc->sxFnc.IsLambda())\n    {\n        // In any of the following cases, there is no way to reference the built-in 'arguments' variable (in the order of checks\n        // above):\n        //     - A function parameter is named 'arguments'\n        //     - There is a nested function declaration (or named function expression in compat modes) named 'arguments'\n        //     - In compat modes, the function is named arguments, does not have a var declaration named 'arguments', and does\n        //       not call 'eval'\n        pnodeFnc->sxFnc.SetHasReferenceableBuiltInArguments(false);\n    }\n    else\n    {\n        ParseNodePtr argNode = nullptr;\n        if(m_ppnodeVar == &pnodeFnc->sxFnc.pnodeVars)\n        {\n            // There were no var declarations in the function\n            argNode = CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, pnodeFnc);\n        }\n        else\n        {\n            // There were var declarations in the function, so insert an 'arguments' local at the beginning of the var list.\n            // This is done because the built-in 'arguments' variable overrides an 'arguments' var declaration until the\n            // 'arguments' variable is assigned. By putting our built-in var declaration at the beginning, an 'arguments'\n            // identifier will resolve to this symbol, which has the fpnArguments flag set, and will be the built-in arguments\n            // object until it is replaced with something else.\n            ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n            argNode = CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, pnodeFnc);\n            m_ppnodeVar = ppnodeVarSave;\n        }\n\n        Assert(argNode);\n        argNode->grfpn |= PNodeFlags::fpnArguments;\n\n        // When a function definition with the name arguments occurs in the body the declaration of the arguments symbol will\n        // be set to that function declaration. We should change it to arguments declaration from the param scope as it may be\n        // used in the param scope and we have to load the arguments.\n        argNode->sxVar.sym->SetDecl(argNode);\n\n        pnodeFnc->sxFnc.SetHasReferenceableBuiltInArguments(true);\n    }\n}\n\nLPCOLESTR Parser::GetFunctionName(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint)\n{\n    LPCOLESTR name = nullptr;\n    if(pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n    {\n        name = pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz();\n    }\n    if(name == nullptr && pNameHint != nullptr)\n    {\n        name = pNameHint;\n    }\n    if(name == nullptr && m_functionBody != nullptr)\n    {\n        name = m_functionBody->GetExternalDisplayName();\n    }\n    else if(name == nullptr)\n    {\n        name = Js::Constants::AnonymousFunction;\n    }\n    return name;\n}\n\nIdentPtr Parser::ParseClassPropertyName(IdentPtr * pidHint)\n{\n    if (m_token.tk == tkID || m_token.tk == tkStrCon || m_token.IsReservedWord())\n    {\n        IdentPtr pid;\n        if (m_token.tk == tkStrCon)\n        {\n            if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pid = m_token.GetStr();\n        }\n        else\n        {\n            pid = m_token.GetIdentifier(m_phtbl);\n        }\n        *pidHint = pid;\n        return pid;\n    }\n    else if (m_token.tk == tkIntCon)\n    {\n        if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        return m_pscan->PidFromLong(m_token.GetLong());\n    }\n    else if (m_token.tk == tkFltCon)\n    {\n        if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        return m_pscan->PidFromDbl(m_token.GetDouble());\n    }\n\n    Error(ERRnoMemberIdent);\n}\n\nLPCOLESTR Parser::ConstructFinalHintNode(IdentPtr pClassName, IdentPtr pMemberName, IdentPtr pGetSet, bool isStatic, uint32* nameLength, uint32* pShortNameOffset, bool isComputedName, LPCOLESTR pMemberNameHint)\n{\n    if ((pMemberName == nullptr && !isComputedName) ||\n        (pMemberNameHint == nullptr && isComputedName) ||\n        !CONFIG_FLAG(UseFullName))\n    {\n        return nullptr;\n    }\n\n    LPCOLESTR pFinalName = isComputedName? pMemberNameHint : pMemberName->Psz();\n    uint32 fullNameHintLength = 0;\n    uint32 shortNameOffset = 0;\n    if (!isStatic)\n    {\n        // Add prototype.\n        pFinalName = AppendNameHints(wellKnownPropertyPids.prototype, pFinalName, &fullNameHintLength, &shortNameOffset);\n    }\n\n    if (pClassName)\n    {\n        uint32 classNameOffset = 0;\n        pFinalName = AppendNameHints(pClassName, pFinalName, &fullNameHintLength, &classNameOffset);\n        shortNameOffset += classNameOffset;\n    }\n\n    if (pGetSet)\n    {\n        if (m_scriptContext->GetConfig()->IsES6FunctionNameEnabled())\n        {\n            // displays as get/set prototype.funcname\n            uint32 getSetOffset = 0;\n            pFinalName = AppendNameHints(pGetSet, pFinalName, &fullNameHintLength, &getSetOffset, true);\n            shortNameOffset += getSetOffset;\n        }\n        else\n        {\n            pFinalName = AppendNameHints(pFinalName, pGetSet, &fullNameHintLength, &shortNameOffset);\n        }\n\n    }\n    if (fullNameHintLength > *nameLength)\n    {\n        *nameLength = fullNameHintLength;\n    }\n\n    if (shortNameOffset > *pShortNameOffset)\n    {\n        *pShortNameOffset = shortNameOffset;\n    }\n\n    return pFinalName;\n}\n\nclass AutoParsingSuperRestrictionStateRestorer\n{\npublic:\n    AutoParsingSuperRestrictionStateRestorer(Parser* parser) : m_parser(parser)\n    {\n        AssertMsg(this->m_parser != nullptr, \"This just should not happen\");\n        this->m_originalParsingSuperRestrictionState = this->m_parser->m_parsingSuperRestrictionState;\n    }\n    ~AutoParsingSuperRestrictionStateRestorer()\n    {\n        AssertMsg(this->m_parser != nullptr, \"This just should not happen\");\n        this->m_parser->m_parsingSuperRestrictionState = m_originalParsingSuperRestrictionState;\n    }\nprivate:\n    Parser* m_parser;\n    int m_originalParsingSuperRestrictionState;\n};\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseClassDecl(BOOL isDeclaration, LPCOLESTR pNameHint, uint32 *pHintLength, uint32 *pShortNameOffset)\n{\n    bool hasConstructor = false;\n    bool hasExtends = false;\n    IdentPtr name = nullptr;\n    ParseNodePtr pnodeName = nullptr;\n    ParseNodePtr pnodeConstructor = nullptr;\n    ParseNodePtr pnodeExtends = nullptr;\n    ParseNodePtr pnodeMembers = nullptr;\n    ParseNodePtr *lastMemberNodeRef = nullptr;\n    ParseNodePtr pnodeStaticMembers = nullptr;\n    ParseNodePtr *lastStaticMemberNodeRef = nullptr;\n    uint32 nameHintLength = pHintLength ? *pHintLength : 0;\n    uint32 nameHintOffset = pShortNameOffset ? *pShortNameOffset : 0;\n\n    ArenaAllocator tempAllocator(_u(\"ClassMemberNames\"), m_nodeAllocator.GetPageAllocator(), Parser::OutOfMemory);\n\n    ParseNodePtr pnodeClass = nullptr;\n    if (buildAST)\n    {\n        pnodeClass = CreateNode(knopClassDecl);\n\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Class, m_scriptContext);\n    }\n\n    m_pscan->Scan();\n    if (m_token.tk == tkID)\n    {\n        name = m_token.GetIdentifier(m_phtbl);\n        m_pscan->Scan();\n    }\n    else if (isDeclaration)\n    {\n        IdentifierExpectedError(m_token);\n    }\n\n    if (isDeclaration && name == wellKnownPropertyPids.arguments && GetCurrentBlockInfo()->pnodeBlock->sxBlock.blockType == Function)\n    {\n        GetCurrentFunctionNode()->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n    }\n\n    BOOL strictSave = m_fUseStrictMode;\n    m_fUseStrictMode = TRUE;\n\n    ParseNodePtr pnodeDeclName = nullptr;\n    if (isDeclaration)\n    {\n        pnodeDeclName = CreateBlockScopedDeclNode(name, knopLetDecl);\n    }\n\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n    ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n    if (buildAST)\n    {\n        PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        pnodeClass->sxClass.pnodeBlock = pnodeBlock;\n    }\n\n    if (name)\n    {\n        pnodeName = CreateBlockScopedDeclNode(name, knopConstDecl);\n    }\n\n    if (m_token.tk == tkEXTENDS)\n    {\n        m_pscan->Scan();\n        pnodeExtends = ParseExpr<buildAST>();\n        hasExtends = true;\n    }\n\n    if (m_token.tk != tkLCurly)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    OUTPUT_TRACE_DEBUGONLY(Js::ES6VerboseFlag, _u(\"Parsing class (%s) : %s\\n\"), GetParseType(), name ? name->Psz() : _u(\"anonymous class\"));\n\n    RestorePoint beginClass;\n    m_pscan->Capture(&beginClass);\n\n    m_pscan->ScanForcingPid();\n\n    IdentPtr pClassNamePid = pnodeName ? pnodeName->sxVar.pid : nullptr;\n\n    for (;;)\n    {\n        if (m_token.tk == tkSColon)\n        {\n            m_pscan->ScanForcingPid();\n            continue;\n        }\n        if (m_token.tk == tkRCurly)\n        {\n            break;\n        }\n\n        bool isStatic = m_token.tk == tkSTATIC;\n        if (isStatic)\n        {\n            m_pscan->ScanForcingPid();\n        }\n\n        ushort fncDeclFlags = fFncNoName | fFncMethod | fFncClassMember;\n        charcount_t ichMin = 0;\n        size_t iecpMin = 0;\n        ParseNodePtr pnodeMemberName = nullptr;\n        IdentPtr pidHint = nullptr;\n        IdentPtr memberPid = nullptr;\n        LPCOLESTR pMemberNameHint = nullptr;\n        uint32     memberNameHintLength = 0;\n        uint32     memberNameOffset = 0;\n        bool isComputedName = false;\n        bool isAsyncMethod = false;\n\n        if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->Scan();\n            if (m_token.tk == tkLParen || m_pscan->FHadNewLine())\n            {\n                m_pscan->SeekTo(parsedAsync);\n            }\n            else\n            {\n                isAsyncMethod = true;\n            }\n        }\n\n        bool isGenerator = m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n                           m_token.tk == tkStar;\n        if (isGenerator)\n        {\n            fncDeclFlags |= fFncGenerator;\n            m_pscan->ScanForcingPid();\n        }\n\n\n        if (m_token.tk == tkLBrack && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            // Computed member name: [expr] () { }\n            LPCOLESTR emptyHint = nullptr;\n            ParseComputedName<buildAST>(&pnodeMemberName, &emptyHint, &pMemberNameHint, &memberNameHintLength, &memberNameOffset);\n            isComputedName = true;\n        }\n        else // not computed name\n        {\n            memberPid = this->ParseClassPropertyName(&pidHint);\n            if (pidHint)\n            {\n                pMemberNameHint = pidHint->Psz();\n                memberNameHintLength = pidHint->Cch();\n            }\n        }\n\n        if (buildAST && memberPid)\n        {\n            pnodeMemberName = CreateStrNodeWithScanner(memberPid);\n        }\n\n        if (!isStatic && memberPid == wellKnownPropertyPids.constructor)\n        {\n            if (hasConstructor || isAsyncMethod)\n            {\n                Error(ERRsyntax);\n            }\n            hasConstructor = true;\n            LPCOLESTR pConstructorName = nullptr;\n            uint32  constructorNameLength = 0;\n            uint32  constructorShortNameHintOffset = 0;\n            if (pnodeName && pnodeName->sxVar.pid)\n            {\n                pConstructorName = pnodeName->sxVar.pid->Psz();\n                constructorNameLength = pnodeName->sxVar.pid->Cch();\n            }\n            else\n            {\n                pConstructorName = pNameHint;\n                constructorNameLength = nameHintLength;\n                constructorShortNameHintOffset = nameHintOffset;\n            }\n\n            {\n                AutoParsingSuperRestrictionStateRestorer restorer(this);\n                this->m_parsingSuperRestrictionState = hasExtends ? ParsingSuperRestrictionState_SuperCallAndPropertyAllowed : ParsingSuperRestrictionState_SuperPropertyAllowed;\n                pnodeConstructor = ParseFncDecl<buildAST>(fncDeclFlags, pConstructorName, /* needsPIDOnRCurlyScan */ true, /* resetParsingSuperRestrictionState = */false);\n            }\n\n            if (pnodeConstructor->sxFnc.IsGenerator())\n            {\n                Error(ERRConstructorCannotBeGenerator);\n            }\n\n            Assert(constructorNameLength >= constructorShortNameHintOffset);\n            // The constructor function will get the same name as class.\n            pnodeConstructor->sxFnc.hint = pConstructorName;\n            pnodeConstructor->sxFnc.hintLength = constructorNameLength;\n            pnodeConstructor->sxFnc.hintOffset = constructorShortNameHintOffset;\n            pnodeConstructor->sxFnc.pid = pnodeName && pnodeName->sxVar.pid ? pnodeName->sxVar.pid : wellKnownPropertyPids.constructor;\n            pnodeConstructor->sxFnc.SetIsClassConstructor(TRUE);\n            pnodeConstructor->sxFnc.SetHasNonThisStmt();\n            pnodeConstructor->sxFnc.SetIsBaseClassConstructor(pnodeExtends == nullptr);\n        }\n        else\n        {\n            ParseNodePtr pnodeMember = nullptr;\n\n            bool isMemberNamedGetOrSet = false;\n            RestorePoint beginMethodName;\n            m_pscan->Capture(&beginMethodName);\n            if (memberPid == wellKnownPropertyPids.get || memberPid == wellKnownPropertyPids.set)\n            {\n                m_pscan->ScanForcingPid();\n            }\n            if (m_token.tk == tkLParen)\n            {\n                m_pscan->SeekTo(beginMethodName);\n                isMemberNamedGetOrSet = true;\n            }\n\n            if ((memberPid == wellKnownPropertyPids.get || memberPid == wellKnownPropertyPids.set) && !isMemberNamedGetOrSet)\n            {\n                bool isGetter = (memberPid == wellKnownPropertyPids.get);\n\n                if (m_token.tk == tkLBrack && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n                {\n                    // Computed get/set member name: get|set [expr] () { }\n                    LPCOLESTR emptyHint = nullptr;\n                    ParseComputedName<buildAST>(&pnodeMemberName, &emptyHint, &pMemberNameHint, &memberNameHintLength, &memberNameOffset);\n                    isComputedName = true;\n                }\n                else // not computed name\n                {\n                    memberPid = this->ParseClassPropertyName(&pidHint);\n                }\n\n                if ((isStatic ? (memberPid == wellKnownPropertyPids.prototype) : (memberPid == wellKnownPropertyPids.constructor)) || isAsyncMethod)\n                {\n                    Error(ERRsyntax);\n                }\n                if (buildAST && memberPid && !isComputedName)\n                {\n                    pnodeMemberName = CreateStrNodeWithScanner(memberPid);\n                }\n\n                ParseNodePtr pnodeFnc = nullptr;\n                {\n                    AutoParsingSuperRestrictionStateRestorer restorer(this);\n                    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n                    pnodeFnc = ParseFncDecl<buildAST>(fncDeclFlags | (isGetter ? fFncNoArg : fFncOneArg),\n                        pidHint ? pidHint->Psz() : nullptr, /* needsPIDOnRCurlyScan */ true,\n                        /* resetParsingSuperRestrictionState */false);\n                }\n\n                pnodeFnc->sxFnc.SetIsStaticMember(isStatic);\n\n                if (buildAST)\n                {\n                    pnodeFnc->sxFnc.SetIsAccessor();\n                    pnodeMember = CreateBinNode(isGetter ? knopGetMember : knopSetMember, pnodeMemberName, pnodeFnc);\n                    pMemberNameHint = ConstructFinalHintNode(pClassNamePid, pidHint,\n                        isGetter ? wellKnownPropertyPids.get : wellKnownPropertyPids.set, isStatic,\n                        &memberNameHintLength, &memberNameOffset, isComputedName, pMemberNameHint);\n                }\n            }\n            else\n            {\n                if (isStatic && (memberPid == wellKnownPropertyPids.prototype))\n                {\n                    Error(ERRsyntax);\n                }\n\n                ParseNodePtr pnodeFnc = nullptr;\n                {\n                    AutoParsingSuperRestrictionStateRestorer restorer(this);\n                    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n\n                    if (isAsyncMethod)\n                    {\n                        fncDeclFlags |= fFncAsync;\n                    }\n                    pnodeFnc = ParseFncDecl<buildAST>(fncDeclFlags, pidHint ? pidHint->Psz() : nullptr, /* needsPIDOnRCurlyScan */ true, /* resetParsingSuperRestrictionState */false);\n                    if (isAsyncMethod)\n                    {\n                        pnodeFnc->sxFnc.cbMin = iecpMin;\n                        pnodeFnc->ichMin = ichMin;\n                    }\n                }\n                pnodeFnc->sxFnc.SetIsStaticMember(isStatic);\n\n                if (buildAST)\n                {\n                    pnodeMember = CreateBinNode(knopMember, pnodeMemberName, pnodeFnc);\n                    pMemberNameHint = ConstructFinalHintNode(pClassNamePid, pidHint, nullptr /*pgetset*/, isStatic, &memberNameHintLength, &memberNameOffset, isComputedName, pMemberNameHint);\n                }\n            }\n\n            if (buildAST)\n            {\n                Assert(memberNameHintLength >= memberNameOffset);\n                pnodeMember->sxBin.pnode2->sxFnc.hint = pMemberNameHint; // Fully qualified name\n                pnodeMember->sxBin.pnode2->sxFnc.hintLength = memberNameHintLength;\n                pnodeMember->sxBin.pnode2->sxFnc.hintOffset = memberNameOffset;\n                pnodeMember->sxBin.pnode2->sxFnc.pid = memberPid; // Short name\n\n                AddToNodeList(isStatic ? &pnodeStaticMembers : &pnodeMembers, isStatic ? &lastStaticMemberNodeRef : &lastMemberNodeRef, pnodeMember);\n            }\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeClass->ichLim = m_pscan->IchLimTok();\n    }\n\n    if (!hasConstructor)\n    {\n        OUTPUT_TRACE_DEBUGONLY(Js::ES6VerboseFlag, _u(\"Generating constructor (%s) : %s\\n\"), GetParseType(), name ? name->Psz() : _u(\"anonymous class\"));\n\n        RestorePoint endClass;\n        m_pscan->Capture(&endClass);\n        m_pscan->SeekTo(beginClass);\n\n        pnodeConstructor = GenerateEmptyConstructor<buildAST>(pnodeExtends != nullptr);\n        if (buildAST)\n        {\n            if (pClassNamePid)\n            {\n                pnodeConstructor->sxFnc.hint = pClassNamePid->Psz();\n                pnodeConstructor->sxFnc.hintLength = pClassNamePid->Cch();\n                pnodeConstructor->sxFnc.hintOffset = 0;\n            }\n            else\n            {\n                Assert(nameHintLength >= nameHintOffset);\n                pnodeConstructor->sxFnc.hint = pNameHint;\n                pnodeConstructor->sxFnc.hintLength = nameHintLength;\n                pnodeConstructor->sxFnc.hintOffset = nameHintOffset;\n            }\n            pnodeConstructor->sxFnc.pid = pClassNamePid;\n        }\n\n        m_pscan->SeekTo(endClass);\n    }\n\n    if (buildAST)\n    {\n        pnodeConstructor->sxFnc.cbMin = pnodeClass->ichMin;\n        pnodeConstructor->sxFnc.cbLim = pnodeClass->ichLim;\n        pnodeConstructor->ichMin = pnodeClass->ichMin;\n        pnodeConstructor->ichLim = pnodeClass->ichLim;\n\n        PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n\n        pnodeClass->sxClass.pnodeDeclName = pnodeDeclName;\n        pnodeClass->sxClass.pnodeName = pnodeName;\n        pnodeClass->sxClass.pnodeConstructor = pnodeConstructor;\n        pnodeClass->sxClass.pnodeExtends = pnodeExtends;\n        pnodeClass->sxClass.pnodeMembers = pnodeMembers;\n        pnodeClass->sxClass.pnodeStaticMembers = pnodeStaticMembers;\n        pnodeClass->sxClass.isDefaultModuleExport = false;\n    }\n    FinishParseBlock(pnodeBlock);\n\n    m_fUseStrictMode = strictSave;\n\n    m_pscan->Scan();\n\n    return pnodeClass;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseStringTemplateDecl(ParseNodePtr pnodeTagFnc)\n{\n    ParseNodePtr pnodeStringLiterals = nullptr;\n    ParseNodePtr* lastStringLiteralNodeRef = nullptr;\n    ParseNodePtr pnodeRawStringLiterals = nullptr;\n    ParseNodePtr* lastRawStringLiteralNodeRef = nullptr;\n    ParseNodePtr pnodeSubstitutionExpressions = nullptr;\n    ParseNodePtr* lastSubstitutionExpressionNodeRef = nullptr;\n    ParseNodePtr pnodeTagFncArgs = nullptr;\n    ParseNodePtr* lastTagFncArgNodeRef = nullptr;\n    ParseNodePtr stringLiteral = nullptr;\n    ParseNodePtr stringLiteralRaw = nullptr;\n    ParseNodePtr pnodeStringTemplate = nullptr;\n    bool templateClosed = false;\n    const bool isTagged = pnodeTagFnc != nullptr;\n    uint16 stringConstantCount = 0;\n    charcount_t ichMin = 0;\n\n    Assert(m_token.tk == tkStrTmplBasic || m_token.tk == tkStrTmplBegin);\n\n    if (buildAST)\n    {\n        pnodeStringTemplate = CreateNode(knopStrTemplate);\n        pnodeStringTemplate->sxStrTemplate.countStringLiterals = 0;\n        pnodeStringTemplate->sxStrTemplate.isTaggedTemplate = isTagged ? TRUE : FALSE;\n\n        // If this is a tagged string template, we need to start building the arg list for the call\n        if (isTagged)\n        {\n            ichMin = pnodeTagFnc->ichMin;\n            AddToNodeListEscapedUse(&pnodeTagFncArgs, &lastTagFncArgNodeRef, pnodeStringTemplate);\n        }\n\n    }\n    CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StringTemplates, m_scriptContext);\n\n    OUTPUT_TRACE_DEBUGONLY(\n        Js::StringTemplateParsePhase,\n        _u(\"Starting to parse a string template (%s)...\\n\\tis tagged = %s\\n\"),\n        GetParseType(),\n        isTagged ? _u(\"true\") : _u(\"false (Raw and cooked strings will not differ!)\"));\n\n    // String template grammar\n    // `...`   Simple string template\n    // `...${  String template beginning\n    // }...${  String template middle\n    // }...`   String template end\n    while (!templateClosed)\n    {\n        // First, extract the string constant part - we always have one\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        // We are not able to pass more than a ushort worth of arguments to the tag\n        // so use that as a logical limit on the number of string constant pieces.\n        if (stringConstantCount >= USHRT_MAX)\n        {\n            Error(ERRnoMemory);\n        }\n\n        // Keep track of the string literal count (must be the same for raw strings)\n        // We use this in code gen so we don't need to count the string literals list\n        stringConstantCount++;\n\n        // If we are not creating parse nodes, there is no need to create strings\n        if (buildAST)\n        {\n            stringLiteral = CreateStrNodeWithScanner(m_token.GetStr());\n\n            AddToNodeList(&pnodeStringLiterals, &lastStringLiteralNodeRef, stringLiteral);\n\n            // We only need to collect a raw string when we are going to pass the string template to a tag\n            if (isTagged)\n            {\n                // Make the scanner create a PID for the raw string constant for the preceding scan\n                IdentPtr pid = m_pscan->GetSecondaryBufferAsPid();\n\n                stringLiteralRaw = CreateStrNodeWithScanner(pid);\n\n                // Should have gotten a raw string literal above\n                AddToNodeList(&pnodeRawStringLiterals, &lastRawStringLiteralNodeRef, stringLiteralRaw);\n            }\n            else\n            {\n#if DBG\n                // Assign the raw string for debug tracing below\n                stringLiteralRaw = stringLiteral;\n#endif\n            }\n\n            OUTPUT_TRACE_DEBUGONLY(\n                Js::StringTemplateParsePhase,\n                _u(\"Parsed string constant: \\n\\tcooked = \\\"%s\\\" \\n\\traw = \\\"%s\\\" \\n\\tdiffer = %d\\n\"),\n                stringLiteral->sxPid.pid->Psz(),\n                stringLiteralRaw->sxPid.pid->Psz(),\n                stringLiteral->sxPid.pid->Psz() == stringLiteralRaw->sxPid.pid->Psz() ? 0 : 1);\n        }\n\n        switch (m_token.tk)\n        {\n        case tkStrTmplEnd:\n        case tkStrTmplBasic:\n            // We do not need to parse an expression for either the end or basic string template tokens\n            templateClosed = true;\n            break;\n        case tkStrTmplBegin:\n        case tkStrTmplMid:\n            {\n            // In the middle or begin string template token case, we need to parse an expression next\n            m_pscan->Scan();\n\n            // Parse the contents of the curly braces as an expression\n            ParseNodePtr expression = ParseExpr<buildAST>(0);\n\n            // After parsing expression, scan should leave us with an RCurly token.\n            // Use the NoScan version so we do not automatically perform a scan - we need to\n            // set the scan state before next scan but we don't want to set that state if\n            // the token is not as expected since we'll error in that case.\n            ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n\n            // Notify the scanner that it should scan for a middle or end string template token\n            m_pscan->SetScanState(Scanner_t::ScanState::ScanStateStringTemplateMiddleOrEnd);\n            m_pscan->Scan();\n\n            if (buildAST)\n            {\n                // If we are going to call the tag function, add this expression into the list of args\n                if (isTagged)\n                {\n                    AddToNodeListEscapedUse(&pnodeTagFncArgs, &lastTagFncArgNodeRef, expression);\n                }\n                else\n                {\n                    // Otherwise add it to the substitution expression list\n                    // TODO: Store the arguments and substitution expressions in a single list?\n                    AddToNodeList(&pnodeSubstitutionExpressions, &lastSubstitutionExpressionNodeRef, expression);\n                }\n            }\n\n            if (!(m_token.tk == tkStrTmplMid || m_token.tk == tkStrTmplEnd))\n            {\n                // Scan with ScanState ScanStateStringTemplateMiddleOrEnd should only return\n                // tkStrTmpMid/End unless it is EOF or tkScanError\n                Assert(m_token.tk == tkEOF || m_token.tk == tkScanError);\n                Error(ERRsyntax);\n            }\n\n            OUTPUT_TRACE_DEBUGONLY(Js::StringTemplateParsePhase, _u(\"Parsed expression\\n\"));\n            }\n            break;\n        default:\n            Assert(false);\n            break;\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeStringTemplate->sxStrTemplate.pnodeStringLiterals = pnodeStringLiterals;\n        pnodeStringTemplate->sxStrTemplate.pnodeStringRawLiterals = pnodeRawStringLiterals;\n        pnodeStringTemplate->sxStrTemplate.pnodeSubstitutionExpressions = pnodeSubstitutionExpressions;\n        pnodeStringTemplate->sxStrTemplate.countStringLiterals = stringConstantCount;\n\n        // We should still have the last string literal.\n        // Use the char offset of the end of that constant as the end of the string template.\n        pnodeStringTemplate->ichLim = stringLiteral->ichLim;\n\n        // If this is a tagged template, we now have the argument list and can construct a call node\n        if (isTagged)\n        {\n            // Return the call node here and let the byte code generator Emit the string template automagically\n            pnodeStringTemplate = CreateCallNode(knopCall, pnodeTagFnc, pnodeTagFncArgs, ichMin, pnodeStringTemplate->ichLim);\n\n            // We need to set the arg count explicitly\n            pnodeStringTemplate->sxCall.argCount = stringConstantCount;\n        }\n    }\n\n    m_pscan->Scan();\n\n    return pnodeStringTemplate;\n}\n\nParseNodePtr Parser::CreateAsyncSpawnGenerator()\n{\n    ParseNodePtr pnodeFncGenerator = nullptr;\n\n    pnodeFncGenerator = CreateDummyFuncNode(false);\n    pnodeFncGenerator->sxFnc.functionId = (*m_nextFunctionId)++;\n\n    pnodeFncGenerator->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFncGenerator->sxFnc.cbLim = m_pscan->IecpLimTok();\n    pnodeFncGenerator->sxFnc.lineNumber = m_pscan->LineCur();\n    pnodeFncGenerator->sxFnc.columnNumber = CalculateFunctionColumnNumber();\n    pnodeFncGenerator->sxFnc.SetNested(m_currentNodeFunc != nullptr);\n    pnodeFncGenerator->sxFnc.SetStrictMode(IsStrictMode());\n\n    pnodeFncGenerator->sxFnc.SetIsGenerator();\n    pnodeFncGenerator->sxFnc.SetIsLambda();\n    pnodeFncGenerator->sxFnc.scope = nullptr;\n\n    AppendFunctionToScopeList(false, pnodeFncGenerator);\n\n    return pnodeFncGenerator;\n}\n\nLPCOLESTR Parser::FormatPropertyString(LPCOLESTR propertyString, ParseNodePtr pNode, uint32 *fullNameHintLength, uint32 *pShortNameOffset)\n{\n    // propertyString could be null, such as 'this.foo' =\n    // propertyString could be empty, found in pattern as in (-1)[\"\"][(x = z)]\n\n    OpCode op = pNode->nop;\n    LPCOLESTR rightNode = nullptr;\n    if (propertyString == nullptr)\n    {\n        propertyString = _u(\"\");\n    }\n\n    if (op != knopInt && op != knopFlt && op != knopName && op != knopStr)\n    {\n        rightNode = _u(\"\");\n    }\n    else if (op == knopStr)\n    {\n        return AppendNameHints(propertyString, pNode->sxPid.pid, fullNameHintLength, pShortNameOffset, false, true/*add brackets*/);\n    }\n    else if(op == knopFlt)\n    {\n        rightNode = m_pscan->StringFromDbl(pNode->sxFlt.dbl);\n    }\n    else\n    {\n        rightNode = op == knopInt ? m_pscan->StringFromLong(pNode->sxInt.lw)\n            : pNode->sxPid.pid->Psz();\n    }\n\n    return AppendNameHints(propertyString, rightNode, fullNameHintLength, pShortNameOffset, false, true/*add brackets*/);\n}\n\nLPCOLESTR Parser::ConstructNameHint(ParseNodePtr pNode, uint32* fullNameHintLength, uint32 *pShortNameOffset)\n{\n    Assert(pNode != nullptr);\n    Assert(pNode->nop == knopDot || pNode->nop == knopIndex);\n    LPCOLESTR leftNode = nullptr;\n    if (pNode->sxBin.pnode1->nop == knopDot || pNode->sxBin.pnode1->nop == knopIndex)\n    {\n        leftNode = ConstructNameHint(pNode->sxBin.pnode1, fullNameHintLength, pShortNameOffset);\n    }\n    else if (pNode->sxBin.pnode1->nop == knopName)\n    {\n        leftNode = pNode->sxBin.pnode1->sxPid.pid->Psz();\n        *fullNameHintLength = pNode->sxBin.pnode1->sxPid.pid->Cch();\n        *pShortNameOffset = 0;\n    }\n\n    if (pNode->nop == knopIndex)\n    {\n        return FormatPropertyString(\n            leftNode ? leftNode : Js::Constants::AnonymousFunction, // e.g. f()[0] = function () {}\n            pNode->sxBin.pnode2, fullNameHintLength, pShortNameOffset);\n    }\n\n    Assert(pNode->sxBin.pnode2->nop == knopDot || pNode->sxBin.pnode2->nop == knopName);\n\n    LPCOLESTR rightNode = nullptr;\n    bool wrapWithBrackets = false;\n    if (pNode->sxBin.pnode2->nop == knopDot)\n    {\n        rightNode = ConstructNameHint(pNode->sxBin.pnode2, fullNameHintLength, pShortNameOffset);\n    }\n    else\n    {\n        rightNode = pNode->sxBin.pnode2->sxPid.pid->Psz();\n        wrapWithBrackets = PNodeFlags::fpnIndexOperator == (pNode->grfpn & PNodeFlags::fpnIndexOperator);\n    }\n    Assert(rightNode != nullptr);\n    return AppendNameHints(leftNode, rightNode, fullNameHintLength, pShortNameOffset, false, wrapWithBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR leftStr, uint32 leftLen, LPCOLESTR rightStr, uint32 rightLen, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    Assert(rightStr != nullptr);\n    Assert(leftLen  != 0 || wrapInBrackets);\n    Assert(rightLen != 0 || wrapInBrackets);\n\n    bool ignoreDot = rightStr[0] == _u('[') && !wrapInBrackets;//if we wrap in brackets it can be a string literal which can have brackets at the first char\n    uint32 totalLength = leftLen + rightLen + ((ignoreDot) ? 1 : 2); // 1 (for dot or [) + 1 (for null termination)\n\n    if (wrapInBrackets)\n    {\n        totalLength++; //1 for ']';\n    }\n    WCHAR * finalName = AllocateStringOfLength(totalLength);\n\n    if (leftStr != nullptr && leftLen != 0)\n    {\n        wcscpy_s(finalName, leftLen + 1, leftStr);\n    }\n\n    if (ignoreAddDotWithSpace)\n    {\n        finalName[leftLen++] = (OLECHAR)_u(' ');\n    }\n    // mutually exclusive from ignoreAddDotWithSpace which is used for getters/setters\n\n    else if (wrapInBrackets)\n    {\n        finalName[leftLen++] = (OLECHAR)_u('[');\n        finalName[totalLength-2] = (OLECHAR)_u(']');\n    }\n    else if (!ignoreDot)\n    {\n        finalName[leftLen++] = (OLECHAR)_u('.');\n    }\n    //ignore case falls through\n    js_wmemcpy_s(finalName + leftLen, rightLen, rightStr, rightLen);\n    finalName[totalLength-1] = (OLECHAR)_u('\\0');\n\n    if (pNameLength != nullptr)\n    {\n        *pNameLength = totalLength - 1;\n    }\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = leftLen;\n    }\n\n    return finalName;\n}\n\nWCHAR * Parser::AllocateStringOfLength(ULONG length)\n{\n    Assert(length > 0);\n    ULONG totalBytes;\n    if (ULongMult(length, sizeof(OLECHAR), &totalBytes) != S_OK)\n    {\n        Error(ERRnoMemory);\n    }\n    WCHAR* finalName = (WCHAR*)m_phtbl->GetAllocator()->Alloc(totalBytes);\n    if (finalName == nullptr)\n    {\n        Error(ERRnoMemory);\n    }\n    return finalName;\n}\n\nLPCOLESTR Parser::AppendNameHints(IdentPtr left, IdentPtr right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    if (left == nullptr && !wrapInBrackets)\n    {\n        if (right)\n        {\n            *pNameLength = right->Cch();\n            return right->Psz();\n        }\n        return nullptr;\n    }\n\n    uint32 leftLen = 0;\n    LPCOLESTR leftStr = _u(\"\");\n\n    if (left != nullptr) // if wrapInBrackets is true\n    {\n        leftStr = left->Psz();\n        leftLen = left->Cch();\n    }\n\n    if (right == nullptr)\n    {\n        *pNameLength = leftLen;\n        return left->Psz();\n    }\n    uint32 rightLen = right->Cch();\n\n    return AppendNameHints(leftStr, leftLen, right->Psz(), rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(IdentPtr left, LPCOLESTR right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 rightLen = (right == nullptr) ? 0 : (uint32) wcslen(right);\n\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    Assert(rightLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (left == nullptr && !wrapInBrackets)\n    {\n        *pNameLength = rightLen;\n        return right;\n    }\n\n    LPCOLESTR leftStr = _u(\"\");\n    uint32 leftLen = 0;\n\n    if (left != nullptr) // if wrapInBrackets is true\n    {\n        leftStr = left->Psz();\n        leftLen = left->Cch();\n    }\n\n    if (rightLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = leftLen;\n        return left->Psz();\n    }\n\n    return AppendNameHints(leftStr, leftLen, right, rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR left, IdentPtr right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 leftLen = (left == nullptr) ? 0 : (uint32) wcslen(left);\n\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    Assert(leftLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (left == nullptr || (leftLen == 0 && !wrapInBrackets))\n    {\n        if (right != nullptr)\n        {\n            *pNameLength = right->Cch();\n            return right->Psz();\n        }\n        return nullptr;\n    }\n\n    if (right == nullptr)\n    {\n        *pNameLength = leftLen;\n        return left;\n    }\n    uint32 rightLen = right->Cch();\n\n    return AppendNameHints(left, leftLen, right->Psz(), rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR left, LPCOLESTR right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 leftLen = (left == nullptr) ? 0 : (uint32) wcslen(left);\n    uint32 rightLen = (right == nullptr) ? 0 : (uint32) wcslen(right);\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n    Assert(rightLen <= ULONG_MAX && leftLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (leftLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = right ? rightLen : 0;\n        return right;\n    }\n\n    if (rightLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = leftLen;\n        return left;\n    }\n\n    return AppendNameHints(left, leftLen, right, rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\n/**\n * Emits a spread error if there is no ambiguity, or marks defers the error for\n * when we can determine if it is a rest error or a spread error.\n *\n * The ambiguity arises when we are parsing a lambda parameter list but we have\n * not seen the => token. At this point, we are either in a parenthesized\n * expression or a parameter list, and cannot issue an error until the matching\n * RParen has been scanned.\n *\n * The actual emission of the error happens in ParseExpr, when we first know if\n * the expression is a lambda parameter list or not.\n *\n */\nvoid Parser::DeferOrEmitPotentialSpreadError(ParseNodePtr pnodeT)\n{\n    if (m_parenDepth > 0)\n    {\n        if (m_token.tk == tkRParen)\n        {\n           if (!m_deferEllipsisError)\n            {\n                // Capture only the first error instance.\n                m_pscan->Capture(&m_EllipsisErrLoc);\n                m_deferEllipsisError = true;\n            }\n        }\n        else\n        {\n            Error(ERRUnexpectedEllipsis);\n        }\n    }\n    else\n    {\n        Error(ERRInvalidSpreadUse);\n    }\n}\n\n/***************************************************************************\nParse an optional sub expression returning null if there was no expression.\nChecks for no expression by looking for a token that can follow an\nExpression grammar production.\n***************************************************************************/\ntemplate<bool buildAST>\nbool Parser::ParseOptionalExpr(ParseNodePtr* pnode, bool fUnaryOrParen, int oplMin, BOOL *pfCanAssign, BOOL fAllowIn, BOOL fAllowEllipsis, _Inout_opt_ IdentToken* pToken)\n{\n    *pnode = nullptr;\n    if (m_token.tk == tkRCurly ||\n        m_token.tk == tkRBrack ||\n        m_token.tk == tkRParen ||\n        m_token.tk == tkSColon ||\n        m_token.tk == tkColon ||\n        m_token.tk == tkComma ||\n        m_token.tk == tkLimKwd ||\n        m_pscan->FHadNewLine())\n    {\n        return false;\n    }\n\n    IdentToken token;\n    ParseNodePtr pnodeT = ParseExpr<buildAST>(oplMin, pfCanAssign, fAllowIn, fAllowEllipsis, nullptr /*pNameHint*/, nullptr /*pHintLength*/, nullptr /*pShortNameOffset*/, &token, fUnaryOrParen);\n    // Detect nested function escapes of the pattern \"return function(){...}\" or \"yield function(){...}\".\n    // Doing so in the parser allows us to disable stack-nested-functions in common cases where an escape\n    // is not detected at byte code gen time because of deferred parsing.\n    this->MarkEscapingRef(pnodeT, &token);\n    if (pToken)\n    {\n        *pToken = token;\n    }\n    *pnode = pnodeT;\n    return true;\n}\n\n/***************************************************************************\nParse a sub expression.\n'fAllowIn' indicates if the 'in' operator should be allowed in the initializing\nexpression ( it is not allowed in the context of the first expression in a  'for' loop).\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseExpr(int oplMin,\n    BOOL *pfCanAssign,\n    BOOL fAllowIn,\n    BOOL fAllowEllipsis,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken,\n    bool fUnaryOrParen,\n    _Inout_opt_ bool* pfLikelyPattern,\n    _Inout_opt_ charcount_t *plastRParen)\n{\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n    int opl;\n    OpCode nop;\n    charcount_t ichMin;\n    ParseNodePtr pnode = nullptr;\n    ParseNodePtr pnodeT = nullptr;\n    BOOL fCanAssign = TRUE;\n    bool assignmentStmt = false;\n    bool fIsDotOrIndex = false;\n    IdentToken term;\n    RestorePoint termStart;\n    uint32 hintLength = 0;\n    uint32 hintOffset = 0;\n\n    ParserState parserState;\n\n    if (pHintLength != nullptr)\n    {\n        hintLength = *pHintLength;\n    }\n\n    if (pShortNameOffset != nullptr)\n    {\n        hintOffset = *pShortNameOffset;\n    }\n\n    EnsureStackAvailable();\n\n    // Storing the state here as we need to restore this state back when we need to reparse the grammar under lambda syntax.\n    CaptureState(&parserState);\n\n    m_pscan->Capture(&termStart);\n\n    bool deferredErrorFoundOnLeftSide = false;\n    bool savedDeferredInitError = m_hasDeferredShorthandInitError;\n    m_hasDeferredShorthandInitError = false;\n\n    // Is the current token a unary operator?\n    if (m_phtbl->TokIsUnop(m_token.tk, &opl, &nop) && nop != knopNone)\n    {\n        IdentToken operandToken;\n        ichMin = m_pscan->IchMinTok();\n\n        if (nop == knopYield)\n        {\n            if (!m_pscan->YieldIsKeyword() || oplMin > opl)\n            {\n                // The case where 'yield' is scanned as a keyword (tkYIELD) but the scanner\n                // is not treating yield as a keyword (!m_pscan->YieldIsKeyword()) occurs\n                // in strict mode non-generator function contexts.\n                //\n                // That is, 'yield' is a keyword because of strict mode, but YieldExpression\n                // is not a grammar production outside of generator functions.\n                //\n                // Otherwise it is an error for a yield to appear in the context of a higher level\n                // binding operator, be it unary or binary.\n                Error(ERRsyntax);\n            }\n            if (m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                Error(ERRsyntax);\n            }\n        }\n        else if (nop == knopAwait)\n        {\n            if (!m_pscan->AwaitIsKeyword() ||\n                m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                // As with the 'yield' keyword, the case where 'await' is scanned as a keyword (tkAWAIT)\n                // but the scanner is not treating await as a keyword (!m_pscan->AwaitIsKeyword())\n                // occurs in strict mode non-async function contexts.\n                //\n                // That is, 'await' is a keyword because of strict mode, but AwaitExpression\n                // is not a grammar production outside of async functions.\n                //\n                // Further, await expressions are disallowed within parameter scopes.\n                Error(ERRBadAwait);\n            }\n        }\n\n        m_pscan->Scan();\n\n        if (m_token.tk == tkEllipsis) {\n            // ... cannot have a unary prefix.\n            Error(ERRUnexpectedEllipsis);\n        }\n\n        if (nop == knopYield && !m_pscan->FHadNewLine() && m_token.tk == tkStar)\n        {\n            m_pscan->Scan();\n            nop = knopYieldStar;\n        }\n\n        if (nop == knopYield)\n        {\n            if (!ParseOptionalExpr<buildAST>(&pnodeT, false, opl, NULL, TRUE, fAllowEllipsis))\n            {\n                nop = knopYieldLeaf;\n                if (buildAST)\n                {\n                    pnode = CreateNodeT<knopYieldLeaf>(ichMin, m_pscan->IchLimTok());\n                }\n            }\n        }\n        else\n        {\n            // Disallow spread after a unary operator.\n            pnodeT = ParseExpr<buildAST>(opl, &fCanAssign, TRUE, FALSE, nullptr /*hint*/, nullptr /*hintLength*/, nullptr /*hintOffset*/, &operandToken, true);\n        }\n\n        if (nop != knopYieldLeaf)\n        {\n            if (nop == knopIncPre || nop == knopDecPre)\n            {\n                if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n                {\n                    Error(JSERR_CantAssignTo);\n                }\n                TrackAssignment<buildAST>(pnodeT, &operandToken);\n                if (buildAST)\n                {\n                    if (IsStrictMode() && pnodeT->nop == knopName)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(pnodeT->sxPid.pid);\n                    }\n                }\n                else\n                {\n                    if (IsStrictMode() && operandToken.tk == tkID)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(operandToken.pid);\n                    }\n                }\n            }\n            else if (nop == knopEllipsis)\n            {\n                if (!fAllowEllipsis)\n                {\n                    DeferOrEmitPotentialSpreadError(pnodeT);\n                }\n            }\n            else if (m_token.tk == tkExpo)\n            {\n                //Unary operator on the left hand-side of ** is unexpected, except ++, -- or ...\n                Error(ERRInvalidUseofExponentiationOperator);\n            }\n\n            if (buildAST)\n            {\n                //Do not do the folding for Asm in case of KnopPos as we need this to determine the type\n                if (nop == knopPos && (pnodeT->nop == knopInt || pnodeT->nop == knopFlt) && !this->m_InAsmMode)\n                {\n                    // Fold away a unary '+' on a number.\n                    pnode = pnodeT;\n                }\n                else if (nop == knopNeg &&\n                    ((pnodeT->nop == knopInt && pnodeT->sxInt.lw != 0) ||\n                    (pnodeT->nop == knopFlt && (pnodeT->sxFlt.dbl != 0 || this->m_InAsmMode))))\n                {\n                    // Fold a unary '-' on a number into the value of the number itself.\n                    pnode = pnodeT;\n                    if (pnode->nop == knopInt)\n                    {\n                        pnode->sxInt.lw = -pnode->sxInt.lw;\n                    }\n                    else\n                    {\n                        pnode->sxFlt.dbl = -pnode->sxFlt.dbl;\n                    }\n                }\n                else\n                {\n                    pnode = CreateUniNode(nop, pnodeT);\n                    this->CheckArguments(pnode->sxUni.pnode1);\n                }\n                pnode->ichMin = ichMin;\n            }\n\n            if (nop == knopDelete)\n            {\n                if (IsStrictMode())\n                {\n                    if ((buildAST && pnode->sxUni.pnode1->nop == knopName) ||\n                        (!buildAST && operandToken.tk == tkID))\n                    {\n                        Error(ERRInvalidDelete);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    ParseNodePtr pnode1 = pnode->sxUni.pnode1;\n                    if (m_currentNodeFunc)\n                    {\n                        if (pnode1->nop == knopDot || pnode1->nop == knopIndex)\n                        {\n                            // If we delete an arguments property, use the conservative,\n                            // heap-allocated arguments object.\n                            this->CheckArguments(pnode1->sxBin.pnode1);\n                        }\n                    }\n                }\n            }\n        }\n\n        fCanAssign = FALSE;\n    }\n    else\n    {\n        ichMin = m_pscan->IchMinTok();\n        BOOL fLikelyPattern = FALSE;\n        pnode = ParseTerm<buildAST>(TRUE, pNameHint, &hintLength, &hintOffset, &term, fUnaryOrParen, &fCanAssign, IsES6DestructuringEnabled() ? &fLikelyPattern : nullptr, &fIsDotOrIndex, plastRParen);\n        if (pfLikelyPattern != nullptr)\n        {\n            *pfLikelyPattern = !!fLikelyPattern;\n        }\n\n        if (m_token.tk == tkDArrow)\n        {\n            m_hasDeferredShorthandInitError = false;\n        }\n\n        if (m_token.tk == tkAsg && oplMin <= koplAsg && fLikelyPattern)\n        {\n            m_pscan->SeekTo(termStart);\n\n            // As we are reparsing from the beginning of the destructured literal we need to reset the Block IDs as well to make sure the Block IDs\n            // on the pidref stack match.\n            int saveNextBlockId = m_nextBlockId;\n            m_nextBlockId = parserState.m_nextBlockId;\n\n            ParseDestructuredLiteralWithScopeSave(tkLCurly, false/*isDecl*/, false /*topLevel*/, DIC_ShouldNotParseInitializer);\n\n            // Restore the Block ID at the end of the reparsing so it matches the one at the end of the first pass. We need to do this \n            // because we don't parse initializers during reparse and there may be additional blocks (e.g. a class declaration)\n            // in the initializers that will cause the next Block ID at the end of the reparsing to be different.\n            m_nextBlockId = saveNextBlockId;\n\n            if (buildAST)\n            {\n                pnode = ConvertToPattern(pnode);\n            }\n\n            // The left-hand side is found to be destructuring pattern - so the shorthand can have initializer.\n            m_hasDeferredShorthandInitError = false;\n        }\n\n        if (buildAST)\n        {\n            pNameHint = NULL;\n            if (pnode->nop == knopName)\n            {\n                pNameHint = pnode->sxPid.pid->Psz();\n                hintLength = pnode->sxPid.pid->Cch();\n                hintOffset = 0;\n            }\n            else if (pnode->nop == knopDot || pnode->nop == knopIndex)\n            {\n                if (CONFIG_FLAG(UseFullName))\n                {\n                    pNameHint = ConstructNameHint(pnode, &hintLength, &hintOffset);\n                }\n                else\n                {\n                    ParseNodePtr pnodeName = pnode;\n                    while (pnodeName->nop == knopDot)\n                    {\n                        pnodeName = pnodeName->sxBin.pnode2;\n                    }\n\n                    if (pnodeName->nop == knopName)\n                    {\n                        pNameHint = pnodeName->sxPid.pid->Psz();\n                        hintLength = pnodeName->sxPid.pid->Cch();\n                        hintOffset = 0;\n                    }\n                }\n            }\n        }\n\n        // Check for postfix unary operators.\n        if (!m_pscan->FHadNewLine() &&\n            (tkInc == m_token.tk || tkDec == m_token.tk))\n        {\n            if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n            }\n            TrackAssignment<buildAST>(pnode, &term);\n            fCanAssign = FALSE;\n            if (buildAST)\n            {\n                if (IsStrictMode() && pnode->nop == knopName)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnode->sxPid.pid);\n                }\n                this->CheckArguments(pnode);\n                pnode = CreateUniNode(tkInc == m_token.tk ? knopIncPost : knopDecPost, pnode);\n                pnode->ichLim = m_pscan->IchLimTok();\n            }\n            else\n            {\n                if (IsStrictMode() && term.tk == tkID)\n                {\n                    CheckStrictModeEvalArgumentsUsage(term.pid);\n                }\n                // This expression is not an identifier\n                term.tk = tkNone;\n            }\n            m_pscan->Scan();\n        }\n    }\n\n    deferredErrorFoundOnLeftSide = m_hasDeferredShorthandInitError;\n\n    // Process a sequence of operators and operands.\n    for (;;)\n    {\n        if (!m_phtbl->TokIsBinop(m_token.tk, &opl, &nop) || nop == knopNone)\n        {\n            break;\n        }\n        if ( ! fAllowIn && nop == knopIn )\n        {\n            break;\n        }\n        Assert(opl != koplNo);\n\n        if (opl == koplAsg)\n        {\n            if (m_token.tk != tkDArrow)\n            {\n                // Assignment operator. These are the only right associative\n                // binary operators. We also need to special case the left\n                // operand - it should only be a LeftHandSideExpression.\n                Assert(ParseNode::Grfnop(nop) & fnopAsg || nop == knopFncDecl);\n                TrackAssignment<buildAST>(pnode, &term);\n                if (buildAST)\n                {\n                    if (IsStrictMode() && pnode->nop == knopName)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(pnode->sxPid.pid);\n                    }\n\n                    // Assignment stmt of the form \"this.<id> = <expr>\"\n                    if (nop == knopAsg && pnode->nop == knopDot && pnode->sxBin.pnode1->nop == knopThis && pnode->sxBin.pnode2->nop == knopName)\n                    {\n                        if (pnode->sxBin.pnode2->sxPid.pid != wellKnownPropertyPids.__proto__)\n                        {\n                            assignmentStmt = true;\n                        }\n                    }\n                }\n                else\n                {\n                    if (IsStrictMode() && term.tk == tkID)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(term.pid);\n                    }\n                }\n            }\n\n            if (opl < oplMin)\n            {\n                break;\n            }\n            if (m_token.tk != tkDArrow && !fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n                // No recovery necessary since this is a semantic, not structural, error.\n            }\n        }\n        else if (opl == koplExpo)\n        {\n            // ** operator is right associative\n            if (opl < oplMin)\n            {\n                break;\n            }\n\n        }\n        else if (opl <= oplMin)\n        {\n            break;\n        }\n\n        // This expression is not an identifier\n        term.tk = tkNone;\n\n        // Precedence is high enough. Consume the operator token.\n        m_pscan->Scan();\n        fCanAssign = FALSE;\n\n        // Special case the \"?:\" operator\n        if (nop == knopQmark)\n        {\n            pnodeT = ParseExpr<buildAST>(koplAsg, NULL, fAllowIn);\n            ChkCurTok(tkColon, ERRnoColon);\n            ParseNodePtr pnodeT2 = ParseExpr<buildAST>(koplAsg, NULL, fAllowIn);\n            if (buildAST)\n            {\n                pnode = CreateTriNode(nop, pnode, pnodeT, pnodeT2);\n                this->CheckArguments(pnode->sxTri.pnode2);\n                this->CheckArguments(pnode->sxTri.pnode3);\n            }\n        }\n        else if (nop == knopFncDecl)\n        {\n            ushort flags = fFncLambda;\n            size_t iecpMin = 0;\n            bool isAsyncMethod = false;\n\n            RestoreStateFrom(&parserState);\n\n            m_pscan->SeekTo(termStart);\n            if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n            {\n                ichMin = m_pscan->IchMinTok();\n                iecpMin = m_pscan->IecpMinTok();\n\n                m_pscan->Scan();\n                if ((m_token.tk == tkID || m_token.tk == tkLParen) && !m_pscan->FHadNewLine())\n                {\n                    flags |= fFncAsync;\n                    isAsyncMethod = true;\n                }\n                else\n                {\n                    m_pscan->SeekTo(termStart);\n                }\n            }\n            pnode = ParseFncDecl<buildAST>(flags, nullptr, /* needsPIDOnRCurlyScan = */false, /* resetParsingSuperRestrictionState = */false);\n            if (isAsyncMethod)\n            {\n                pnode->sxFnc.cbMin = iecpMin;\n                pnode->ichMin = ichMin;\n            }\n        }\n        else\n        {\n            // Parse the operand, make a new node, and look for more\n            IdentToken token;\n            pnodeT = ParseExpr<buildAST>(opl, NULL, fAllowIn, FALSE, pNameHint, &hintLength, &hintOffset, &token);\n\n            // Detect nested function escapes of the pattern \"o.f = function(){...}\" or \"o[s] = function(){...}\".\n            // Doing so in the parser allows us to disable stack-nested-functions in common cases where an escape\n            // is not detected at byte code gen time because of deferred parsing.\n            if (fIsDotOrIndex && nop == knopAsg)\n            {\n                this->MarkEscapingRef(pnodeT, &token);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateBinNode(nop, pnode, pnodeT);\n                Assert(pnode->sxBin.pnode2 != NULL);\n                if (pnode->sxBin.pnode2->nop == knopFncDecl)\n                {\n                    Assert(hintLength >= hintOffset);\n                    pnode->sxBin.pnode2->sxFnc.hint = pNameHint;\n                    pnode->sxBin.pnode2->sxFnc.hintLength = hintLength;\n                    pnode->sxBin.pnode2->sxFnc.hintOffset = hintOffset;\n\n                    if (pnode->sxBin.pnode1->nop == knopDot)\n                    {\n                        pnode->sxBin.pnode2->sxFnc.isNameIdentifierRef  = false;\n                    }\n                    else if (pnode->sxBin.pnode1->nop == knopName)\n                    {\n                        PidRefStack *pidRef = pnode->sxBin.pnode1->sxPid.pid->GetTopRef();\n                        pidRef->isFuncAssignment = true;\n                    }\n                }\n                if (pnode->sxBin.pnode2->nop == knopClassDecl && pnode->sxBin.pnode1->nop == knopDot)\n                {\n                    Assert(pnode->sxBin.pnode2->sxClass.pnodeConstructor);\n                    pnode->sxBin.pnode2->sxClass.pnodeConstructor->sxFnc.isNameIdentifierRef  = false;\n                }\n            }\n            pNameHint = NULL;\n        }\n    }\n\n    if (buildAST)\n    {\n        if (!assignmentStmt)\n        {\n            // Don't set the flag for following nodes\n            switch (pnode->nop)\n            {\n            case knopName:\n            case knopInt:\n            case knopFlt:\n            case knopStr:\n            case knopRegExp:\n            case knopNull:\n            case knopFalse:\n            case knopTrue:\n                break;\n            default:\n                if (m_currentNodeFunc)\n                {\n                    m_currentNodeFunc->sxFnc.SetHasNonThisStmt();\n                }\n                else if (m_currentNodeProg)\n                {\n                    m_currentNodeProg->sxFnc.SetHasNonThisStmt();\n                }\n            }\n        }\n    }\n\n    if (m_hasDeferredShorthandInitError && !deferredErrorFoundOnLeftSide)\n    {\n        // Raise error only if it is found not on the right side of the expression.\n        // such as  <expr> = {x = 1}\n        Error(ERRnoColon);\n    }\n\n    m_hasDeferredShorthandInitError = m_hasDeferredShorthandInitError || savedDeferredInitError;\n\n    if (NULL != pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    //Track \"obj.a\" assignment patterns here - Promote the Assignment state for the property's PID.\n    // This includes =, += etc.\n    if (pnode != NULL)\n    {\n        uint nodeType = ParseNode::Grfnop(pnode->nop);\n        if (nodeType & fnopAsg)\n        {\n            if (nodeType & fnopBin)\n            {\n                ParseNodePtr lhs = pnode->sxBin.pnode1;\n\n                Assert(lhs);\n                if (lhs->nop == knopDot)\n                {\n                    ParseNodePtr propertyNode = lhs->sxBin.pnode2;\n                    if (propertyNode->nop == knopName)\n                    {\n                        propertyNode->sxPid.pid->PromoteAssignmentState();\n                    }\n                }\n            }\n            else if (nodeType & fnopUni)\n            {\n                // cases like obj.a++, ++obj.a\n                ParseNodePtr lhs = pnode->sxUni.pnode1;\n                if (lhs->nop == knopDot)\n                {\n                    ParseNodePtr propertyNode = lhs->sxBin.pnode2;\n                    if (propertyNode->nop == knopName)\n                    {\n                        propertyNode->sxPid.pid->PromoteAssignmentState();\n                    }\n                }\n            }\n        }\n    }\n    return pnode;\n}\n\ntemplate<bool buildAST>\nvoid Parser::TrackAssignment(ParseNodePtr pnodeT, IdentToken* pToken)\n{\n    if (buildAST)\n    {\n        Assert(pnodeT != nullptr);\n        if (pnodeT->nop == knopName)\n        {\n            PidRefStack *ref = pnodeT->sxPid.pid->GetTopRef();\n            Assert(ref);\n            ref->isAsg = true;\n        }\n    }\n    else\n    {\n        Assert(pToken != nullptr);\n        if (pToken->tk == tkID)\n        {\n            PidRefStack *ref = pToken->pid->GetTopRef();\n            Assert(ref);\n            ref->isAsg = true;\n        }\n    }\n}\n\nvoid PnPid::SetSymRef(PidRefStack *ref)\n{\n    Assert(symRef == nullptr);\n    this->symRef = ref->GetSymRef();\n}\n\nJs::PropertyId PnPid::PropertyIdFromNameNode() const\n{\n    Js::PropertyId propertyId;\n    Symbol *sym = this->sym;\n    if (sym)\n    {\n        propertyId = sym->GetPosition();\n    }\n    else\n    {\n        propertyId = this->pid->GetPropertyId();\n    }\n    return propertyId;\n}\n\nPidRefStack* Parser::PushPidRef(IdentPtr pid)\n{\n    if (PHASE_ON1(Js::ParallelParsePhase))\n    {\n        // NOTE: the phase check is here to protect perf. See OSG 1020424.\n        // In some LS AST-rewrite cases we lose a lot of perf searching the PID ref stack rather\n        // than just pushing on the top. This hasn't shown up as a perf issue in non-LS benchmarks.\n        return pid->FindOrAddPidRef(&m_nodeAllocator, GetCurrentBlock()->sxBlock.blockId, GetCurrentFunctionNode()->sxFnc.functionId);\n    }\n\n    Assert(GetCurrentBlock() != nullptr);\n    AssertMsg(pid != nullptr, \"PID should be created\");\n    PidRefStack *ref = pid->GetTopRef();\n    int blockId = GetCurrentBlock()->sxBlock.blockId;\n    int funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    if (!ref || (ref->GetScopeId() < blockId))\n    {\n        ref = Anew(&m_nodeAllocator, PidRefStack);\n        if (ref == nullptr)\n        {\n            Error(ERRnoMemory);\n        }\n        pid->PushPidRef(blockId, funcId, ref);\n    }\n    else if (m_reparsingLambdaParams)\n    {\n        // If we're reparsing params, then we may have pid refs left behind from the first pass. Make sure we're\n        // working with the right ref at this point.\n        ref = this->FindOrAddPidRef(pid, blockId, funcId);\n        // Fix up the function ID if we're reparsing lambda parameters.\n        ref->funcId = funcId;\n    }\n\n    return ref;\n}\n\nPidRefStack* Parser::FindOrAddPidRef(IdentPtr pid, int scopeId, Js::LocalFunctionId funcId)\n{\n    PidRefStack *ref = pid->FindOrAddPidRef(&m_nodeAllocator, scopeId, funcId);\n    if (ref == NULL)\n    {\n        Error(ERRnoMemory);\n    }\n    return ref;\n}\n\nvoid Parser::RemovePrevPidRef(IdentPtr pid, PidRefStack *ref)\n{\n    PidRefStack *prevRef = pid->RemovePrevPidRef(ref);\n    Assert(prevRef);\n    if (prevRef->GetSym() == nullptr)\n    {\n        AllocatorDelete(ArenaAllocator, &m_nodeAllocator, prevRef);\n    }\n}\n\nvoid Parser::SetPidRefsInScopeDynamic(IdentPtr pid, int blockId)\n{\n    PidRefStack *ref = pid->GetTopRef();\n    while (ref && ref->GetScopeId() >= blockId)\n    {\n        ref->SetDynamicBinding();\n        ref = ref->prev;\n    }\n}\n\nParseNode* Parser::GetFunctionBlock()\n{\n    Assert(m_currentBlockInfo != nullptr);\n    return m_currentBlockInfo->pBlockInfoFunction->pnodeBlock;\n}\n\n\nParseNode* Parser::GetCurrentBlock()\n{\n    return m_currentBlockInfo != nullptr ? m_currentBlockInfo->pnodeBlock : nullptr;\n}\n\nBlockInfoStack* Parser::GetCurrentBlockInfo()\n{\n    return m_currentBlockInfo;\n}\n\nBlockInfoStack* Parser::GetCurrentFunctionBlockInfo()\n{\n    return m_currentBlockInfo->pBlockInfoFunction;\n}\n\n/***************************************************************************\nParse a variable declaration.\n'fAllowIn' indicates if the 'in' operator should be allowed in the initializing\nexpression ( it is not allowed in the context of the first expression in a  'for' loop).\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseVariableDeclaration(\n    tokens declarationType, charcount_t ichMin,\n    BOOL fAllowIn/* = TRUE*/,\n    BOOL* pfForInOk/* = nullptr*/,\n    BOOL singleDefOnly/* = FALSE*/,\n    BOOL allowInit/* = TRUE*/,\n    BOOL isTopVarParse/* = TRUE*/,\n    BOOL isFor/* = FALSE*/,\n    BOOL* nativeForOk /*= nullptr*/)\n{\n    ParseNodePtr pnodeThis = nullptr;\n    ParseNodePtr pnodeInit;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    LPCOLESTR pNameHint = nullptr;\n    uint32     nameHintLength = 0;\n    uint32     nameHintOffset = 0;\n    Assert(declarationType == tkVAR || declarationType == tkCONST || declarationType == tkLET);\n\n    for (;;)\n    {\n        if (IsES6DestructuringEnabled() && IsPossiblePatternStart())\n        {\n            pnodeThis = ParseDestructuredLiteral<buildAST>(declarationType, true, !!isTopVarParse, DIC_None, !!fAllowIn, pfForInOk, nativeForOk);\n            if (pnodeThis != nullptr)\n            {\n                pnodeThis->ichMin = ichMin;\n            }\n        }\n        else\n        {\n            if (m_token.tk != tkID)\n            {\n                IdentifierExpectedError(m_token);\n            }\n\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n            Assert(pid);\n            pNameHint = pid->Psz();\n            nameHintLength = pid->Cch();\n            nameHintOffset = 0;\n\n            if (pid == wellKnownPropertyPids.let && (declarationType == tkCONST || declarationType == tkLET))\n            {\n                Error(ERRLetIDInLexicalDecl, pnodeThis);\n            }\n\n            if (declarationType == tkVAR)\n            {\n                pnodeThis = CreateVarDeclNode(pid, STVariable);\n            }\n            else if (declarationType == tkCONST)\n            {\n                pnodeThis = CreateBlockScopedDeclNode(pid, knopConstDecl);\n                CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Const, m_scriptContext);\n            }\n            else\n            {\n                pnodeThis = CreateBlockScopedDeclNode(pid, knopLetDecl);\n                CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Let, m_scriptContext);\n            }\n\n            if (pid == wellKnownPropertyPids.arguments && m_currentNodeFunc)\n            {\n                // This var declaration may change the way an 'arguments' identifier in the function is resolved\n                if (declarationType == tkVAR)\n                {\n                    m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_varDeclaration;\n                }\n                else\n                {\n                    if (GetCurrentBlockInfo()->pnodeBlock->sxBlock.blockType == Function)\n                    {\n                        // Only override arguments if we are at the function block level.\n                        m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                    }\n                }\n            }\n\n            if (pnodeThis)\n            {\n                pnodeThis->ichMin = ichMin;\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkAsg)\n            {\n                if (!allowInit)\n                {\n                    Error(ERRUnexpectedDefault);\n                }\n                if (pfForInOk && (declarationType == tkLET || declarationType == tkCONST || IsStrictMode()))\n                {\n                    *pfForInOk = FALSE;\n                }\n\n                m_pscan->Scan();\n                pnodeInit = ParseExpr<buildAST>(koplCma, nullptr, fAllowIn, FALSE, pNameHint, &nameHintLength, &nameHintOffset);\n                if (buildAST)\n                {\n                    AnalysisAssert(pnodeThis);\n                    pnodeThis->sxVar.pnodeInit = pnodeInit;\n                    pnodeThis->ichLim = pnodeInit->ichLim;\n\n                    if (pnodeInit->nop == knopFncDecl)\n                    {\n                        Assert(nameHintLength >= nameHintOffset);\n                        pnodeInit->sxFnc.hint = pNameHint;\n                        pnodeInit->sxFnc.hintLength = nameHintLength;\n                        pnodeInit->sxFnc.hintOffset = nameHintOffset;\n                        pnodeThis->sxVar.pid->GetTopRef()->isFuncAssignment = true;\n                    }\n                    else\n                    {\n                        this->CheckArguments(pnodeInit);\n                    }\n                    pNameHint = nullptr;\n                }\n\n                //Track var a =, let a= , const a =\n                // This is for FixedFields Constant Heuristics\n                if (pnodeThis && pnodeThis->sxVar.pnodeInit != nullptr)\n                {\n                    pnodeThis->sxVar.sym->PromoteAssignmentState();\n                    if (m_currentNodeFunc && pnodeThis->sxVar.sym->GetIsFormal())\n                    {\n                        m_currentNodeFunc->sxFnc.SetHasAnyWriteToFormals(true);\n                    }\n                }\n            }\n            else if (declarationType == tkCONST /*pnodeThis->nop == knopConstDecl*/\n                     && !singleDefOnly\n                     && !(isFor && TokIsForInOrForOf()))\n            {\n                Error(ERRUninitializedConst);\n            }\n        }\n\n        if (singleDefOnly)\n        {\n            return pnodeThis;\n        }\n\n        if (buildAST)\n        {\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeThis);\n        }\n\n        if (m_token.tk != tkComma)\n        {\n            return pnodeList;\n        }\n\n        if (pfForInOk)\n        {\n            // don't allow \"for (var a, b in c)\"\n            *pfForInOk = FALSE;\n        }\n        m_pscan->Scan();\n        ichMin = m_pscan->IchMinTok();\n    }\n}\n\n/***************************************************************************\nParse try-catch-finally statement\n***************************************************************************/\n\n// The try-catch-finally tree nests the try-catch within a try-finally.\n// This matches the new runtime implementation.\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTryCatchFinally()\n{\n    this->m_tryCatchOrFinallyDepth++;\n\n    ParseNodePtr pnodeT = ParseTry<buildAST>();\n    ParseNodePtr pnodeTC = nullptr;\n    StmtNest stmt;\n    bool hasCatch = false;\n\n    if (tkCATCH == m_token.tk)\n    {\n        hasCatch = true;\n        if (buildAST)\n        {\n            pnodeTC = CreateNodeWithScanner<knopTryCatch>();\n            pnodeT->sxStmt.pnodeOuter = pnodeTC;\n            pnodeTC->sxTryCatch.pnodeTry = pnodeT;\n        }\n        PushStmt<buildAST>(&stmt, pnodeTC, knopTryCatch, nullptr, nullptr);\n\n        ParseNodePtr pnodeCatch = ParseCatch<buildAST>();\n        if (buildAST)\n        {\n            pnodeTC->sxTryCatch.pnodeCatch = pnodeCatch;\n        }\n        PopStmt(&stmt);\n    }\n    if (tkFINALLY != m_token.tk)\n    {\n        if (!hasCatch)\n        {\n            Error(ERRnoCatch);\n        }\n        Assert(!buildAST || pnodeTC);\n        return pnodeTC;\n    }\n\n    ParseNodePtr pnodeTF = nullptr;\n    if (buildAST)\n    {\n        pnodeTF = CreateNode(knopTryFinally);\n    }\n    PushStmt<buildAST>(&stmt, pnodeTF, knopTryFinally, nullptr, nullptr);\n    ParseNodePtr pnodeFinally = ParseFinally<buildAST>();\n    if (buildAST)\n    {\n        if (!hasCatch)\n        {\n            pnodeTF->sxTryFinally.pnodeTry = pnodeT;\n            pnodeT->sxStmt.pnodeOuter = pnodeTF;\n        }\n        else\n        {\n            pnodeTF->sxTryFinally.pnodeTry = CreateNode(knopTry);\n            pnodeTF->sxTryFinally.pnodeTry->sxStmt.pnodeOuter = pnodeTF;\n            pnodeTF->sxTryFinally.pnodeTry->sxTry.pnodeBody = pnodeTC;\n            pnodeTC->sxStmt.pnodeOuter = pnodeTF->sxTryFinally.pnodeTry;\n        }\n        pnodeTF->sxTryFinally.pnodeFinally = pnodeFinally;\n    }\n    PopStmt(&stmt);\n    this->m_tryCatchOrFinallyDepth--;\n    return pnodeTF;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTry()\n{\n    ParseNodePtr pnode = nullptr;\n    StmtNest stmt;\n    Assert(tkTRY == m_token.tk);\n    if (buildAST)\n    {\n        pnode = CreateNode(knopTry);\n    }\n    m_pscan->Scan();\n    if (tkLCurly != m_token.tk)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    PushStmt<buildAST>(&stmt, pnode, knopTry, nullptr, nullptr);\n    ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n    if (buildAST)\n    {\n        pnode->sxTry.pnodeBody = pnodeBody;\n        if (pnode->sxTry.pnodeBody)\n            pnode->ichLim = pnode->sxTry.pnodeBody->ichLim;\n    }\n    PopStmt(&stmt);\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseFinally()\n{\n    ParseNodePtr pnode = nullptr;\n    StmtNest stmt;\n    Assert(tkFINALLY == m_token.tk);\n    if (buildAST)\n    {\n        pnode = CreateNode(knopFinally);\n    }\n    m_pscan->Scan();\n    if (tkLCurly != m_token.tk)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    PushStmt<buildAST>(&stmt, pnode, knopFinally, nullptr, nullptr);\n    ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n    if (buildAST)\n    {\n        pnode->sxFinally.pnodeBody = pnodeBody;\n        if (!pnode->sxFinally.pnodeBody)\n            // Will only occur due to error correction.\n            pnode->sxFinally.pnodeBody = CreateNodeWithScanner<knopEmpty>();\n        else\n            pnode->ichLim = pnode->sxFinally.pnodeBody->ichLim;\n    }\n    PopStmt(&stmt);\n\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseCatch()\n{\n    ParseNodePtr rootNode = nullptr;\n    ParseNodePtr* ppnode = &rootNode;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n    ParseNodePtr pnode = nullptr;\n    ParseNodePtr pnodeCatchScope = nullptr;\n    StmtNest stmt;\n    IdentPtr pidCatch = nullptr;\n    //while (tkCATCH == m_token.tk)\n    if (tkCATCH == m_token.tk)\n    {\n        charcount_t ichMin;\n        if (buildAST)\n        {\n            ichMin = m_pscan->IchMinTok();\n        }\n        m_pscan->Scan(); //catch\n        ChkCurTok(tkLParen, ERRnoLparen); //catch(\n\n        bool isPattern = false;\n        if (tkID != m_token.tk)\n        {\n            isPattern = IsES6DestructuringEnabled() && IsPossiblePatternStart();\n            if (!isPattern)\n            {\n                IdentifierExpectedError(m_token);\n            }\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopCatch>(ichMin);\n            PushStmt<buildAST>(&stmt, pnode, knopCatch, nullptr, nullptr);\n            *ppnode = pnode;\n            ppnode = &pnode->sxCatch.pnodeNext;\n            *ppnode = nullptr;\n        }\n\n        pnodeCatchScope = StartParseBlock<buildAST>(PnodeBlockType::Regular, isPattern ? ScopeType_CatchParamPattern : ScopeType_Catch);\n\n        if (buildAST)\n        {\n            // Add this catch to the current scope list.\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pnode;\n                m_ppnodeExprScope = &pnode->sxCatch.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pnode;\n                m_ppnodeScope = &pnode->sxCatch.pnodeNext;\n            }\n\n            // Keep a list of function expressions (not declarations) at this scope.\n\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = &pnode->sxCatch.pnodeScopes;\n            pnode->sxCatch.pnodeScopes = nullptr;\n        }\n\n        if (isPattern)\n        {\n            ParseNodePtr pnodePattern = ParseDestructuredLiteral<buildAST>(tkLET, true /*isDecl*/, true /*topLevel*/, DIC_ForceErrorOnInitializer);\n            if (buildAST)\n            {\n                pnode->sxCatch.pnodeParam = CreateParamPatternNode(pnodePattern);\n                Scope *scope = pnodeCatchScope->sxBlock.scope;\n                pnode->sxCatch.scope = scope;\n            }\n        }\n        else\n        {\n            if (IsStrictMode())\n            {\n                IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n                if (pid == wellKnownPropertyPids.eval)\n                {\n                    Error(ERREvalUsage);\n                }\n                else if (pid == wellKnownPropertyPids.arguments)\n                {\n                    Error(ERRArgsUsage);\n                }\n            }\n\n            pidCatch = m_token.GetIdentifier(m_phtbl);\n            PidRefStack *ref = this->PushPidRef(pidCatch);\n\n            ParseNodePtr pnodeParam = CreateNameNode(pidCatch);\n            pnodeParam->sxPid.symRef = ref->GetSymRef();\n\n            const char16 *name = reinterpret_cast<const char16*>(pidCatch->Psz());\n            int nameLength = pidCatch->Cch();\n            SymbolName const symName(name, nameLength);\n            Symbol *sym = Anew(&m_nodeAllocator, Symbol, symName, pnodeParam, STVariable);\n            sym->SetPid(pidCatch);\n            if (sym == nullptr)\n            {\n                Error(ERRnoMemory);\n            }\n            Assert(ref->GetSym() == nullptr);\n            ref->SetSym(sym);\n\n            Scope *scope = pnodeCatchScope->sxBlock.scope;\n            scope->AddNewSymbol(sym);\n\n            if (buildAST)\n            {\n                pnode->sxCatch.pnodeParam = pnodeParam;\n                pnode->sxCatch.scope = scope;\n            }\n\n            m_pscan->Scan();\n        }\n\n        charcount_t ichLim;\n        if (buildAST)\n        {\n            ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRParen, ERRnoRparen); //catch(id[:expr])\n\n        if (tkLCurly != m_token.tk)\n        {\n            Error(ERRnoLcurly);\n        }\n\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();  //catch(id[:expr]) {block}\n        if (buildAST)\n        {\n            pnode->sxCatch.pnodeBody = pnodeBody;\n            pnode->ichLim = ichLim;\n        }\n\n        if (pnodeCatchScope != nullptr)\n        {\n            FinishParseBlock(pnodeCatchScope);\n        }\n\n        if (buildAST)\n        {\n            PopStmt(&stmt);\n\n            // Restore the lists of function expression scopes.\n\n            AssertMem(m_ppnodeExprScope);\n            Assert(*m_ppnodeExprScope == nullptr);\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n        }\n    }\n    return rootNode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseCase(ParseNodePtr *ppnodeBody)\n{\n    ParseNodePtr pnodeT = nullptr;\n\n    charcount_t ichMinT = m_pscan->IchMinTok();\n    m_pscan->Scan();\n    ParseNodePtr pnodeExpr = ParseExpr<buildAST>();\n    charcount_t ichLim = m_pscan->IchLimTok();\n\n    ChkCurTok(tkColon, ERRnoColon);\n\n    if (buildAST)\n    {\n        pnodeT = CreateNodeWithScanner<knopCase>(ichMinT);\n        pnodeT->sxCase.pnodeExpr = pnodeExpr;\n        pnodeT->ichLim = ichLim;\n    }\n    ParseStmtList<buildAST>(ppnodeBody);\n\n    return pnodeT;\n}\n\n/***************************************************************************\nParse a single statement. Digest a trailing semicolon.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseStatement()\n{\n    ParseNodePtr *ppnodeT;\n    ParseNodePtr pnodeT;\n    ParseNodePtr pnode = nullptr;\n    LabelId* pLabelIdList = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    StmtNest stmt;\n    StmtNest *pstmt;\n    BOOL fForInOrOfOkay;\n    BOOL fCanAssign;\n    IdentPtr pid;\n    uint fnop;\n    ParseNodePtr pnodeLabel = nullptr;\n    bool expressionStmt = false;\n    bool isAsyncMethod = false;\n    tokens tok;\n#if EXCEPTION_RECOVERY\n    ParseNodePtr pParentTryCatch = nullptr;\n    ParseNodePtr pTryBlock = nullptr;\n    ParseNodePtr pTry = nullptr;\n    ParseNodePtr pParentTryCatchBlock = nullptr;\n\n    StmtNest stmtTryCatchBlock;\n    StmtNest stmtTryCatch;\n    StmtNest stmtTry;\n    StmtNest stmtTryBlock;\n#endif\n\n    if (buildAST)\n    {\n#if EXCEPTION_RECOVERY\n        if(Js::Configuration::Global.flags.SwallowExceptions)\n        {\n            // If we're swallowing exceptions, surround this statement with a try/catch block:\n            //\n            //   Before: x.y = 3;\n            //   After:  try { x.y = 3; } catch(__ehobj) { }\n            //\n            // This is done to force the runtime to recover from exceptions at the most granular\n            // possible point.  Recovering from EH dramatically improves coverage of testing via\n            // fault injection.\n\n\n            // create and push the try-catch node\n            pParentTryCatchBlock = CreateBlockNode();\n            PushStmt<buildAST>(&stmtTryCatchBlock, pParentTryCatchBlock, knopBlock, nullptr, nullptr);\n            pParentTryCatch = CreateNodeWithScanner<knopTryCatch>();\n            PushStmt<buildAST>(&stmtTryCatch, pParentTryCatch, knopTryCatch, nullptr, nullptr);\n\n            // create and push a try node\n            pTry = CreateNodeWithScanner<knopTry>();\n            PushStmt<buildAST>(&stmtTry, pTry, knopTry, nullptr, nullptr);\n            pTryBlock = CreateBlockNode();\n            PushStmt<buildAST>(&stmtTryBlock, pTryBlock, knopBlock, nullptr, nullptr);\n            // these nodes will be closed after the statement is parsed.\n        }\n#endif // EXCEPTION_RECOVERY\n    }\n\n    EnsureStackAvailable();\n\nLRestart:\n    tok = m_token.tk;\n\n    switch (tok)\n    {\n    case tkEOF:\n        if (buildAST)\n        {\n            pnode = nullptr;\n        }\n        break;\n\n    case tkFUNCTION:\n    {\nLFunctionStatement:\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            m_grfscr &= ~fscrDeferredFncExpression;\n            pnode = ParseFncDecl<buildAST>(isAsyncMethod ? fFncAsync : fFncNoFlgs, nullptr);\n        }\n        else\n        {\n            pnode = ParseFncDecl<buildAST>(fFncDeclaration | (isAsyncMethod ? fFncAsync : fFncNoFlgs), nullptr);\n        }\n        if (isAsyncMethod)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(TRUE, nullptr, nullptr, nullptr);\n        }\n        else\n        {\n            goto LDefaultToken;\n        }\n        break;\n\n    case tkID:\n        if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.let)\n        {\n            // We see \"let\" at the start of a statement. This could either be a declaration or an identifier\n            // reference. The next token determines which.\n            RestorePoint parsedLet;\n            m_pscan->Capture(&parsedLet);\n            ichMin = m_pscan->IchMinTok();\n\n            m_pscan->Scan();\n            if (this->NextTokenConfirmsLetDecl())\n            {\n                pnode = ParseVariableDeclaration<buildAST>(tkLET, ichMin);\n                goto LNeedTerminator;\n            }\n            m_pscan->SeekTo(parsedLet);\n        }\n        else if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->Scan();\n            if (m_token.tk == tkFUNCTION && !m_pscan->FHadNewLine())\n            {\n                isAsyncMethod = true;\n                goto LFunctionStatement;\n            }\n            m_pscan->SeekTo(parsedAsync);\n        }\n        goto LDefaultToken;\n\n    case tkCONST:\n    case tkLET:\n        ichMin = m_pscan->IchMinTok();\n\n        m_pscan->Scan();\n        pnode = ParseVariableDeclaration<buildAST>(tok, ichMin);\n        goto LNeedTerminator;\n\n    case tkVAR:\n        ichMin = m_pscan->IchMinTok();\n\n        m_pscan->Scan();\n        pnode = ParseVariableDeclaration<buildAST>(tok, ichMin);\n        goto LNeedTerminator;\n\n    case tkFOR:\n    {\n        ParseNodePtr pnodeBlock = nullptr;\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n        if (buildAST)\n        {\n            PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        }\n\n        RestorePoint startExprOrIdentifier;\n        fForInOrOfOkay = TRUE;\n        fCanAssign = TRUE;\n        tok = m_token.tk;\n        BOOL nativeForOkay = TRUE;\n\n        switch (tok)\n        {\n        case tkID:\n            if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.let)\n            {\n                // We see \"let\" in the init part of a for loop. This could either be a declaration or an identifier\n                // reference. The next token determines which.\n                RestorePoint parsedLet;\n                m_pscan->Capture(&parsedLet);\n                auto ichMinInner = m_pscan->IchMinTok();\n\n                m_pscan->Scan();\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                if (this->NextTokenConfirmsLetDecl() && m_token.tk != tkIN)\n                {\n                    pnodeT = ParseVariableDeclaration<buildAST>(tkLET, ichMinInner\n                                                                , /*fAllowIn = */FALSE\n                                                                , /*pfForInOk = */&fForInOrOfOkay\n                                                                , /*singleDefOnly*/FALSE\n                                                                , /*allowInit*/TRUE\n                                                                , /*isTopVarParse*/TRUE\n                                                                , /*isFor*/TRUE\n                                                                , &nativeForOkay);\n                    break;\n                }\n                m_pscan->SeekTo(parsedLet);\n            }\n            goto LDefaultTokenFor;\n        case tkLET:\n        case tkCONST:\n        case tkVAR:\n            {\n                auto ichMinInner = m_pscan->IchMinTok();\n\n                m_pscan->Scan();\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                pnodeT = ParseVariableDeclaration<buildAST>(tok, ichMinInner\n                                                            , /*fAllowIn = */FALSE\n                                                            , /*pfForInOk = */&fForInOrOfOkay\n                                                            , /*singleDefOnly*/FALSE\n                                                            , /*allowInit*/TRUE\n                                                            , /*isTopVarParse*/TRUE\n                                                            , /*isFor*/TRUE\n                                                            , &nativeForOkay);\n            }\n            break;\n        case tkSColon:\n            pnodeT = nullptr;\n            fForInOrOfOkay = FALSE;\n            break;\n        default:\n            {\nLDefaultTokenFor:\n                RestorePoint exprStart;\n                tokens beforeToken = tok;\n                m_pscan->Capture(&exprStart);\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                bool fLikelyPattern = false;\n                if (IsES6DestructuringEnabled() && (beforeToken == tkLBrack || beforeToken == tkLCurly))\n                {\n                    pnodeT = ParseExpr<buildAST>(koplNo,\n                        &fCanAssign,\n                        /*fAllowIn = */FALSE,\n                        /*fAllowEllipsis*/FALSE,\n                        /*pHint*/nullptr,\n                        /*pHintLength*/nullptr,\n                        /*pShortNameOffset*/nullptr,\n                        /*pToken*/nullptr,\n                        /**fUnaryOrParen*/false,\n                        &fLikelyPattern);\n                }\n                else\n                {\n                    pnodeT = ParseExpr<buildAST>(koplNo, &fCanAssign, /*fAllowIn = */FALSE);\n                }\n\n                // We would veryfiy the grammar as destructuring grammar only when  for..in/of case. As in the native for loop case the above ParseExpr call\n                // has already converted them appropriately.\n                if (fLikelyPattern && TokIsForInOrForOf())\n                {\n                    m_pscan->SeekTo(exprStart);\n                    ParseDestructuredLiteralWithScopeSave(tkNone, false/*isDecl*/, false /*topLevel*/, DIC_None, false /*allowIn*/);\n\n                    if (buildAST)\n                    {\n                        pnodeT = ConvertToPattern(pnodeT);\n                    }\n                }\n                if (buildAST)\n                {\n                    Assert(pnodeT);\n                    pnodeT->isUsed = false;\n                }\n            }\n            break;\n        }\n\n        if (TokIsForInOrForOf())\n        {\n            bool isForOf = (m_token.tk != tkIN);\n            Assert(!isForOf || (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.of));\n\n            if ((buildAST && nullptr == pnodeT) || !fForInOrOfOkay)\n            {\n                if (isForOf)\n                {\n                    Error(ERRForOfNoInitAllowed);\n                }\n                else\n                {\n                    Error(ERRForInNoInitAllowed);\n                }\n            }\n            if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n            }\n\n            m_pscan->Scan();\n            ParseNodePtr pnodeObj = ParseExpr<buildAST>(isForOf ? koplCma : koplNo);\n            charcount_t ichLim = m_pscan->IchLimTok();\n            ChkCurTok(tkRParen, ERRnoRparen);\n\n            if (buildAST)\n            {\n                if (isForOf)\n                {\n                    pnode = CreateNodeWithScanner<knopForOf>(ichMin);\n                }\n                else\n                {\n                    pnode = CreateNodeWithScanner<knopForIn>(ichMin);\n                }\n                pnode->sxForInOrForOf.pnodeBlock = pnodeBlock;\n                pnode->sxForInOrForOf.pnodeLval = pnodeT;\n                pnode->sxForInOrForOf.pnodeObj = pnodeObj;\n                pnode->ichLim = ichLim;\n                \n                TrackAssignment<true>(pnodeT, nullptr);\n            }\n            PushStmt<buildAST>(&stmt, pnode, isForOf ? knopForOf : knopForIn, pnodeLabel, pLabelIdList);\n            ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n\n            if (buildAST)\n            {\n                pnode->sxForInOrForOf.pnodeBody = pnodeBody;\n            }\n            PopStmt(&stmt);\n        }\n        else\n        {\n            if (!nativeForOkay)\n            {\n                Error(ERRDestructInit);\n            }\n\n            ChkCurTok(tkSColon, ERRnoSemic);\n            ParseNodePtr pnodeCond = nullptr;\n            if (m_token.tk != tkSColon)\n            {\n                pnodeCond = ParseExpr<buildAST>();\n                if (m_token.tk != tkSColon)\n                {\n                    Error(ERRnoSemic);\n                }\n            }\n\n            tokens tk;\n            tk = m_pscan->Scan();\n\n            ParseNodePtr pnodeIncr = nullptr;\n            if (tk != tkRParen)\n            {\n                pnodeIncr = ParseExpr<buildAST>();\n                if(pnodeIncr)\n                {\n                    pnodeIncr->isUsed = false;\n                }\n            }\n\n            charcount_t ichLim = m_pscan->IchLimTok();\n\n            ChkCurTok(tkRParen, ERRnoRparen);\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopFor>(ichMin);\n                pnode->sxFor.pnodeBlock = pnodeBlock;\n                pnode->sxFor.pnodeInverted= nullptr;\n                pnode->sxFor.pnodeInit = pnodeT;\n                pnode->sxFor.pnodeCond = pnodeCond;\n                pnode->sxFor.pnodeIncr = pnodeIncr;\n                pnode->ichLim = ichLim;\n            }\n            PushStmt<buildAST>(&stmt, pnode, knopFor, pnodeLabel, pLabelIdList);\n            ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n            if (buildAST)\n            {\n                pnode->sxFor.pnodeBody = pnodeBody;\n            }\n            PopStmt(&stmt);\n        }\n\n        if (buildAST)\n        {\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n        }\n\n        FinishParseBlock(pnodeBlock);\n\n        break;\n    }\n\n    case tkSWITCH:\n    {\n        BOOL fSeenDefault = FALSE;\n        ParseNodePtr pnodeBlock = nullptr;\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeVal = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopSwitch>(ichMin);\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopSwitch, pnodeLabel, pLabelIdList);\n        pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block, nullptr, pLabelIdList);\n\n        if (buildAST)\n        {\n            pnode->sxSwitch.pnodeVal = pnodeVal;\n            pnode->sxSwitch.pnodeBlock = pnodeBlock;\n            pnode->ichLim = ichLim;\n            PushFuncBlockScope(pnode->sxSwitch.pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n\n            pnode->sxSwitch.pnodeDefault = nullptr;\n            ppnodeT = &pnode->sxSwitch.pnodeCases;\n        }\n\n        for (;;)\n        {\n            ParseNodePtr pnodeBody = nullptr;\n            switch (m_token.tk)\n            {\n            default:\n                goto LEndSwitch;\n            case tkCASE:\n            {\n                pnodeT = this->ParseCase<buildAST>(&pnodeBody);\n                break;\n            }\n            case tkDEFAULT:\n                if (fSeenDefault)\n                {\n                    Error(ERRdupDefault);\n                    // No recovery necessary since this is a semantic, not structural, error\n                }\n                fSeenDefault = TRUE;\n                charcount_t ichMinT = m_pscan->IchMinTok();\n                m_pscan->Scan();\n                charcount_t ichMinInner = m_pscan->IchLimTok();\n                ChkCurTok(tkColon, ERRnoColon);\n                if (buildAST)\n                {\n                    pnodeT = CreateNodeWithScanner<knopCase>(ichMinT);\n                    pnode->sxSwitch.pnodeDefault = pnodeT;\n                    pnodeT->ichLim = ichMinInner;\n                    pnodeT->sxCase.pnodeExpr = nullptr;\n                }\n                ParseStmtList<buildAST>(&pnodeBody);\n                break;\n            }\n            if (buildAST)\n            {\n                if (pnodeBody)\n                {\n                    // Create a block node to contain the statement list for this case.\n                    // This helps us insert byte code to return the right value from\n                    // global/eval code.\n                    pnodeT->sxCase.pnodeBody = CreateBlockNode(pnodeT->ichMin, pnodeT->ichLim);\n                    pnodeT->sxCase.pnodeBody->grfpn |= PNodeFlags::fpnSyntheticNode; // block is not a user specifier block\n                    pnodeT->sxCase.pnodeBody->sxBlock.pnodeStmt = pnodeBody;\n                }\n                else\n                {\n                    pnodeT->sxCase.pnodeBody = nullptr;\n                }\n                *ppnodeT = pnodeT;\n                ppnodeT = &pnodeT->sxCase.pnodeNext;\n            }\n        }\nLEndSwitch:\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (buildAST)\n        {\n            *ppnodeT = nullptr;\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n            FinishParseBlock(pnode->sxSwitch.pnodeBlock);\n        }\n        else\n        {\n            FinishParseBlock(pnodeBlock);\n        }\n        PopStmt(&stmt);\n\n        break;\n    }\n\n    case tkWHILE:\n    {\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopWhile>(ichMin);\n            pnode->sxWhile.pnodeCond = pnodeCond;\n            pnode->ichLim = ichLim;\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopWhile, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        PopStmt(&stmt);\n\n        if (buildAST)\n        {\n            pnode->sxWhile.pnodeBody = pnodeBody;\n        }\n        break;\n    }\n\n    case tkDO:\n    {\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopDoWhile>();\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopDoWhile, pnodeLabel, pLabelIdList);\n        m_pscan->Scan();\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        PopStmt(&stmt);\n        charcount_t ichMinT = m_pscan->IchMinTok();\n\n        ChkCurTok(tkWHILE, ERRnoWhile);\n        ChkCurTok(tkLParen, ERRnoLparen);\n\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode->sxWhile.pnodeBody = pnodeBody;\n            pnode->sxWhile.pnodeCond = pnodeCond;\n            pnode->ichLim = ichLim;\n            pnode->ichMin = ichMinT;\n        }\n\n        // REVIEW: Allow do...while statements to be embedded in other compound statements like if..else, or do..while?\n        //      goto LNeedTerminator;\n\n        // For now just eat the trailing semicolon if present.\n        if (m_token.tk == tkSColon)\n        {\n            if (pnode)\n            {\n                pnode->grfpn |= PNodeFlags::fpnExplicitSemicolon;\n            }\n            m_pscan->Scan();\n        }\n        else if (pnode)\n        {\n            pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n        }\n\n        break;\n    }\n\n    case tkIF:\n    {\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopIf>(ichMin);\n            pnode->ichLim = m_pscan->IchLimTok();\n            pnode->sxIf.pnodeCond = pnodeCond;\n        }\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        PushStmt<buildAST>(&stmt, pnode, knopIf, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeTrue = ParseStatement<buildAST>();\n        ParseNodePtr pnodeFalse = nullptr;\n        if (m_token.tk == tkELSE)\n        {\n            m_pscan->Scan();\n            pnodeFalse = ParseStatement<buildAST>();\n        }\n        if (buildAST)\n        {\n            pnode->sxIf.pnodeTrue = pnodeTrue;\n            pnode->sxIf.pnodeFalse = pnodeFalse;\n        }\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkTRY:\n    {\n        if (buildAST)\n        {\n            pnode = CreateBlockNode();\n            pnode->grfpn |= PNodeFlags::fpnSyntheticNode; // block is not a user specifier block\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopBlock, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeStmt = ParseTryCatchFinally<buildAST>();\n        if (buildAST)\n        {\n            pnode->sxBlock.pnodeStmt = pnodeStmt;\n        }\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkWITH:\n    {\n        if ( IsStrictMode() )\n        {\n            Error(ERRES5NoWith);\n        }\n        if (m_currentNodeFunc)\n        {\n            GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(); // Used by DeferNested\n        }\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeObj = ParseExpr<buildAST>();\n        if (!buildAST)\n        {\n            m_scopeCountNoAst++;\n        }\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopWith>(ichMin);\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopWith, pnodeLabel, pLabelIdList);\n\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n        if (buildAST)\n        {\n            pnode->sxWith.pnodeObj = pnodeObj;\n            this->CheckArguments(pnode->sxWith.pnodeObj);\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pnode;\n                m_ppnodeExprScope = &pnode->sxWith.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pnode;\n                m_ppnodeScope = &pnode->sxWith.pnodeNext;\n            }\n            pnode->sxWith.pnodeNext = nullptr;\n            pnode->sxWith.scope = nullptr;\n\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = &pnode->sxWith.pnodeScopes;\n            pnode->sxWith.pnodeScopes = nullptr;\n\n            pnode->ichLim = ichLim;\n        }\n\n        PushBlockInfo(CreateBlockNode());\n        PushDynamicBlock();\n\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        if (buildAST)\n        {\n            pnode->sxWith.pnodeBody = pnodeBody;\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n        }\n        else\n        {\n            m_scopeCountNoAst--;\n        }\n\n        // The dynamic block is not stored in the actual parse tree and so will not\n        // be visited by the byte code generator.  Grab the callsEval flag off it and\n        // pass on to outer block in case of:\n        // with (...) eval(...); // i.e. blockless form of with\n        bool callsEval = GetCurrentBlock()->sxBlock.GetCallsEval();\n        PopBlockInfo();\n        if (callsEval)\n        {\n            // be careful not to overwrite an existing true with false\n            GetCurrentBlock()->sxBlock.SetCallsEval(true);\n        }\n\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkLCurly:\n        pnode = ParseBlock<buildAST>(pnodeLabel, pLabelIdList);\n        break;\n\n    case tkSColon:\n        pnode = nullptr;\n        m_pscan->Scan();\n        break;\n\n    case tkBREAK:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopBreak>();\n        }\n        fnop = fnopBreak;\n        goto LGetJumpStatement;\n\n    case tkCONTINUE:\n        if (buildAST)\n        {\n            pnode = CreateNode(knopContinue);\n        }\n        fnop = fnopContinue;\n\nLGetJumpStatement:\n        m_pscan->ScanForcingPid();\n        if (tkID == m_token.tk && !m_pscan->FHadNewLine())\n        {\n            // Labeled break or continue.\n            pid = m_token.GetIdentifier(m_phtbl);\n            AssertMem(pid);\n            if (buildAST)\n            {\n                pnode->sxJump.hasExplicitTarget=true;\n                pnode->ichLim = m_pscan->IchLimTok();\n\n                m_pscan->Scan();\n                PushStmt<buildAST>(&stmt, pnode, pnode->nop, pnodeLabel, nullptr);\n                Assert(pnode->sxStmt.grfnop == 0);\n                for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    AssertNodeMem(pstmt->pnodeStmt);\n                    AssertNodeMemN(pstmt->pnodeLab);\n                    for (pnodeT = pstmt->pnodeLab; nullptr != pnodeT;\n                         pnodeT = pnodeT->sxLabel.pnodeNext)\n                    {\n                        Assert(knopLabel == pnodeT->nop);\n                        if (pid == pnodeT->sxLabel.pid)\n                        {\n                            // Found the label. Make sure we can use it. We can\n                            // break out of any statement, but we can only\n                            // continue loops.\n                            if (fnop == fnopContinue &&\n                                !(pstmt->pnodeStmt->Grfnop() & fnop))\n                            {\n                                Error(ERRbadContinue);\n                            }\n                            else\n                            {\n                                pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                                pnode->sxJump.pnodeTarget = pstmt->pnodeStmt;\n                            }\n                            PopStmt(&stmt);\n                            goto LNeedTerminator;\n                        }\n                    }\n                    pnode->sxStmt.grfnop |=\n                        (pstmt->pnodeStmt->Grfnop() & fnopCleanup);\n                }\n            }\n            else\n            {\n                m_pscan->Scan();\n                for (pstmt = m_pstmtCur; pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    LabelId* pLabelId;\n                    for (pLabelId = pstmt->pLabelId; pLabelId; pLabelId = pLabelId->next)\n                    {\n\n                        if (pid == pLabelId->pid)\n                        {\n                            // Found the label. Make sure we can use it. We can\n                            // break out of any statement, but we can only\n                            // continue loops.\n                            if (fnop == fnopContinue &&\n                                !(ParseNode::Grfnop(pstmt->op) & fnop))\n                            {\n                                Error(ERRbadContinue);\n                            }\n                            goto LNeedTerminator;\n                        }\n                    }\n                }\n            }\n            Error(ERRnoLabel);\n        }\n        else\n        {\n            // If we're doing a fast scan, we're not tracking labels, so we can't accurately do this analysis.\n            // Let the thread that's doing the full parse detect the error, if there is one.\n            if (!this->m_doingFastScan)\n            {\n                // Unlabeled break or continue.\n                if (buildAST)\n                {\n                    pnode->sxJump.hasExplicitTarget=false;\n                    PushStmt<buildAST>(&stmt, pnode, pnode->nop, pnodeLabel, nullptr);\n                    Assert(pnode->sxStmt.grfnop == 0);\n                }\n\n                for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    if (buildAST)\n                    {\n                        AnalysisAssert(pstmt->pnodeStmt);\n                        if (pstmt->pnodeStmt->Grfnop() & fnop)\n                        {\n                            pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                            pnode->sxJump.pnodeTarget = pstmt->pnodeStmt;\n                            PopStmt(&stmt);\n                            goto LNeedTerminator;\n                        }\n                        pnode->sxStmt.grfnop |=\n                            (pstmt->pnodeStmt->Grfnop() & fnopCleanup);\n                    }\n                    else\n                    {\n                        if (ParseNode::Grfnop(pstmt->GetNop()) & fnop)\n                        {\n                            if (!pstmt->isDeferred)\n                            {\n                                AnalysisAssert(pstmt->pnodeStmt);\n                                pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                            }\n                            goto LNeedTerminator;\n                        }\n                    }\n                }\n                Error(fnop == fnopBreak ? ERRbadBreak : ERRbadContinue);\n            }\n            goto LNeedTerminator;\n        }\n\n    case tkRETURN:\n    {\n        if (buildAST)\n        {\n            if (nullptr == m_currentNodeFunc)\n            {\n                Error(ERRbadReturn);\n            }\n            pnode = CreateNodeWithScanner<knopReturn>();\n        }\n        m_pscan->Scan();\n        ParseNodePtr pnodeExpr = nullptr;\n        ParseOptionalExpr<buildAST>(&pnodeExpr, true);\n        if (buildAST)\n        {\n            pnode->sxReturn.pnodeExpr = pnodeExpr;\n            if (pnodeExpr)\n            {\n                this->CheckArguments(pnode->sxReturn.pnodeExpr);\n                pnode->ichLim = pnode->sxReturn.pnodeExpr->ichLim;\n            }\n            // See if return should call finally\n            PushStmt<buildAST>(&stmt, pnode, knopReturn, pnodeLabel, nullptr);\n            Assert(pnode->sxStmt.grfnop == 0);\n            for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n            {\n                AssertNodeMem(pstmt->pnodeStmt);\n                AssertNodeMemN(pstmt->pnodeLab);\n                if (pstmt->pnodeStmt->Grfnop() & fnopCleanup)\n                {\n                    pnode->sxStmt.grfnop |= fnopCleanup;\n                    break;\n                }\n            }\n            PopStmt(&stmt);\n        }\n        goto LNeedTerminator;\n    }\n\n    case tkTHROW:\n    {\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopThrow, nullptr);\n        }\n        m_pscan->Scan();\n        ParseNodePtr pnode1 = nullptr;\n        if (m_token.tk != tkSColon &&\n            m_token.tk != tkRCurly &&\n            !m_pscan->FHadNewLine())\n        {\n            pnode1 = ParseExpr<buildAST>();\n        }\n        else\n        {\n            Error(ERRdanglingThrow);\n        }\n\n        if (buildAST)\n        {\n            pnode->sxUni.pnode1 = pnode1;\n            if (pnode1)\n            {\n                this->CheckArguments(pnode->sxUni.pnode1);\n                pnode->ichLim = pnode->sxUni.pnode1->ichLim;\n            }\n        }\n        goto LNeedTerminator;\n    }\n\n    case tkDEBUGGER:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopDebugger>();\n        }\n        m_pscan->Scan();\n        goto LNeedTerminator;\n\n    case tkIMPORT:\n        if (!(m_grfscr & fscrIsModuleCode))\n        {\n            goto LDefaultToken;\n        }\n\n        pnode = ParseImportDeclaration<buildAST>();\n\n        goto LNeedTerminator;\n\n    case tkEXPORT:\n        if (!(m_grfscr & fscrIsModuleCode))\n        {\n            goto LDefaultToken;\n        }\n\n        pnode = ParseExportDeclaration<buildAST>();\n\n        goto LNeedTerminator;\n\nLDefaultToken:\n    default:\n    {\n        // First check for a label via lookahead. If not found,\n        // rewind and reparse as expression statement.\n        if (m_token.tk == tkLParen || m_token.tk == tkID)\n        {\n            RestorePoint idStart;\n            m_pscan->Capture(&idStart);\n\n            // Support legacy behavior of allowing parentheses around label identifiers.\n            // Require balanced parentheses for correcting parsing.  Note unbalanced cases\n            // take care of themselves correctly by resulting in rewind and parsing as\n            // an expression statement.\n            // REVIEW[ianhall]: Can this legacy functionality be removed? Chrome does not support this parsing behavior.\n            uint parenCount = 0;\n            while (m_token.tk == tkLParen)\n            {\n                parenCount += 1;\n                m_pscan->Scan();\n            }\n\n            if (m_token.tk == tkID)\n            {\n                IdentToken tokInner;\n                tokInner.tk = tkID;\n                tokInner.ichMin = m_pscan->IchMinTok();\n                tokInner.ichLim = m_pscan->IchLimTok();\n                tokInner.pid = m_token.GetIdentifier(m_phtbl);\n\n                m_pscan->Scan();\n\n                while (parenCount > 0 && m_token.tk == tkRParen)\n                {\n                    parenCount -= 1;\n                    m_pscan->Scan();\n                }\n\n                if (parenCount == 0 && m_token.tk == tkColon)\n                {\n                    // We have a label.\n                    // TODO[ianhall]: Refactor to eliminate separate code paths for buildAST and !buildAST\n                    if (buildAST)\n                    {\n                        // See if the label is already defined.\n                        if (nullptr != PnodeLabel(tokInner.pid, pnodeLabel))\n                        {\n                            Error(ERRbadLabel);\n                        }\n                        pnodeT = CreateNodeWithScanner<knopLabel>();\n                        pnodeT->sxLabel.pid = tokInner.pid;\n                        pnodeT->sxLabel.pnodeNext = pnodeLabel;\n                        pnodeLabel = pnodeT;\n                    }\n                    else\n                    {\n                        // See if the label is already defined.\n                        if (PnodeLabelNoAST(&tokInner, pLabelIdList))\n                        {\n                            Error(ERRbadLabel);\n                        }\n                        LabelId* pLabelId = CreateLabelId(&tokInner);\n                        pLabelId->next = pLabelIdList;\n                        pLabelIdList = pLabelId;\n                    }\n                    m_pscan->Scan();\n                    goto LRestart;\n                }\n            }\n\n            // No label, rewind back to the tkID and parse an expression\n            m_pscan->SeekTo(idStart);\n        }\n\n        // Must be an expression statement.\n        pnode = ParseExpr<buildAST>();\n\n        if (m_hasDeferredShorthandInitError)\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            expressionStmt = true;\n\n            AnalysisAssert(pnode);\n            pnode->isUsed = false;\n        }\n    }\n\nLNeedTerminator:\n        // Need a semicolon, new-line, } or end-of-file.\n        // We digest a semicolon if it's there.\n        switch (m_token.tk)\n        {\n        case tkSColon:\n            m_pscan->Scan();\n            if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnExplicitSemicolon;\n            break;\n        case tkEOF:\n        case tkRCurly:\n            if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n            break;\n        default:\n            if (!m_pscan->FHadNewLine())\n            {\n                Error(ERRnoSemic);\n            }\n            else\n            {\n                if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n            }\n            break;\n        }\n        break;\n    }\n\n    if (m_hasDeferredShorthandInitError)\n    {\n        Error(ERRnoColon);\n    }\n\n    if (buildAST)\n    {\n        // All non expression statements excluded from the \"this.x\" optimization\n        // Another check while parsing expressions\n        if (!expressionStmt)\n        {\n            if (m_currentNodeFunc)\n            {\n                m_currentNodeFunc->sxFnc.SetHasNonThisStmt();\n            }\n            else if (m_currentNodeProg)\n            {\n                m_currentNodeProg->sxFnc.SetHasNonThisStmt();\n            }\n        }\n\n#if EXCEPTION_RECOVERY\n        // close the try/catch block\n        if(Js::Configuration::Global.flags.SwallowExceptions)\n        {\n            // pop the try block and fill in the body\n            PopStmt(&stmtTryBlock);\n            pTryBlock->sxBlock.pnodeStmt = pnode;\n            PopStmt(&stmtTry);\n            if(pnode != nullptr)\n            {\n                pTry->ichLim = pnode->ichLim;\n            }\n            pTry->sxTry.pnodeBody = pTryBlock;\n\n\n            // create a catch block with an empty body\n            StmtNest stmtCatch;\n            ParseNodePtr pCatch;\n            pCatch = CreateNodeWithScanner<knopCatch>();\n            PushStmt<buildAST>(&stmtCatch, pCatch, knopCatch, nullptr, nullptr);\n            pCatch->sxCatch.pnodeBody = nullptr;\n            if(pnode != nullptr)\n            {\n                pCatch->ichLim = pnode->ichLim;\n            }\n            pCatch->sxCatch.grfnop = 0;\n            pCatch->sxCatch.pnodeNext = nullptr;\n\n            // create a fake name for the catch var.\n            const WCHAR *uniqueNameStr = _u(\"__ehobj\");\n            IdentPtr uniqueName = m_phtbl->PidHashNameLen(uniqueNameStr, static_cast<int32>(wcslen(uniqueNameStr)));\n\n            pCatch->sxCatch.pnodeParam = CreateNameNode(uniqueName);\n\n            // Add this catch to the current list. We don't bother adjusting the catch and function expression\n            // lists here because the catch is just an empty statement.\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pCatch;\n                m_ppnodeExprScope = &pCatch->sxCatch.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pCatch;\n                m_ppnodeScope = &pCatch->sxCatch.pnodeNext;\n            }\n\n            pCatch->sxCatch.pnodeScopes = nullptr;\n\n            PopStmt(&stmtCatch);\n\n            // fill in and pop the try-catch\n            pParentTryCatch->sxTryCatch.pnodeTry = pTry;\n            pParentTryCatch->sxTryCatch.pnodeCatch = pCatch;\n            PopStmt(&stmtTryCatch);\n            PopStmt(&stmtTryCatchBlock);\n\n            // replace the node that's being returned\n            pParentTryCatchBlock->sxBlock.pnodeStmt = pParentTryCatch;\n            pnode = pParentTryCatchBlock;\n        }\n#endif // EXCEPTION_RECOVERY\n\n    }\n\n    return pnode;\n}\n\nBOOL\nParser::TokIsForInOrForOf()\n{\n    return m_token.tk == tkIN ||\n        (m_token.tk == tkID &&\n         m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.of);\n}\n\n/***************************************************************************\nParse a sequence of statements.\n***************************************************************************/\ntemplate<bool buildAST>\nvoid Parser::ParseStmtList(ParseNodePtr *ppnodeList, ParseNodePtr **pppnodeLast, StrictModeEnvironment smEnvironment, const bool isSourceElementList, bool* strictModeOn)\n{\n    BOOL doneDirectives = !isSourceElementList; // directives may only exist in a SourceElementList, not a StatementList\n    BOOL seenDirectiveContainingOctal = false; // Have we seen an octal directive before a use strict directive?\n\n    BOOL old_UseStrictMode = m_fUseStrictMode;\n\n    ParseNodePtr pnodeStmt;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    if (buildAST)\n    {\n        AssertMem(ppnodeList);\n        AssertMemN(pppnodeLast);\n        *ppnodeList = nullptr;\n    }\n\n    if(CONFIG_FLAG(ForceStrictMode))\n    {\n        m_fUseStrictMode = TRUE;\n    }\n\n    for (;;)\n    {\n        switch (m_token.tk)\n        {\n        case tkCASE:\n        case tkDEFAULT:\n        case tkRCurly:\n        case tkEOF:\n            if (buildAST && nullptr != pppnodeLast)\n            {\n                *pppnodeLast = lastNodeRef;\n            }\n            if (!buildAST)\n            {\n                m_fUseStrictMode = old_UseStrictMode;\n            }\n            return;\n        }\n\n        if (doneDirectives == FALSE)\n        {\n            bool isOctalInString = false;\n            bool isUseStrictDirective = false;\n            bool isUseAsmDirective = false;\n            if (smEnvironment != SM_NotUsed && CheckForDirective(&isUseStrictDirective, &isUseAsmDirective, &isOctalInString))\n            {\n                // Ignore \"use asm\" statement when not building the AST\n                isUseAsmDirective &= buildAST;\n\n                if (isUseStrictDirective)\n                {\n                    // Functions with non-simple parameter list cannot be made strict mode\n                    if (GetCurrentFunctionNode()->sxFnc.HasNonSimpleParameterList())\n                    {\n                        Error(ERRNonSimpleParamListInStrictMode);\n                    }\n\n                    if (seenDirectiveContainingOctal)\n                    {\n                        // Directives seen before a \"use strict\" cannot contain an octal.\n                        Error(ERRES5NoOctal);\n                    }\n                    if (!buildAST)\n                    {\n                        // Turning on strict mode in deferred code.\n                        m_fUseStrictMode = TRUE;\n                        if (!m_inDeferredNestedFunc)\n                        {\n                            // Top-level deferred function, so there's a parse node\n                            Assert(m_currentNodeFunc != nullptr);\n                            m_currentNodeFunc->sxFnc.SetStrictMode();\n                        }\n                        else if (strictModeOn)\n                        {\n                            // This turns on strict mode in a deferred function, we need to go back\n                            // and re-check duplicated formals.\n                            *strictModeOn = true;\n                        }\n                    }\n                    else\n                    {\n                        if (smEnvironment == SM_OnGlobalCode)\n                        {\n                            // Turning on strict mode at the top level\n                            m_fUseStrictMode = TRUE;\n                        }\n                        else\n                        {\n                            // i.e. smEnvironment == SM_OnFunctionCode\n                            Assert(m_currentNodeFunc != nullptr);\n                            m_currentNodeFunc->sxFnc.SetStrictMode();\n                        }\n                    }\n                }\n                else if (isUseAsmDirective)\n                {\n                    if (smEnvironment != SM_OnGlobalCode) //Top level use asm doesn't mean anything.\n                    {\n                        // i.e. smEnvironment == SM_OnFunctionCode\n                        Assert(m_currentNodeFunc != nullptr);\n                        m_currentNodeFunc->sxFnc.SetAsmjsMode();\n                        m_currentNodeFunc->sxFnc.SetCanBeDeferred(false);\n                        m_InAsmMode = true;\n\n                        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(AsmJSFunction, m_scriptContext);\n                    }\n                }\n                else if (isOctalInString)\n                {\n                    seenDirectiveContainingOctal = TRUE;\n                }\n            }\n            else\n            {\n                // The first time we see anything other than a directive we can have no more directives.\n                doneDirectives = TRUE;\n            }\n        }\n\n        if (nullptr != (pnodeStmt = ParseStatement<buildAST>()))\n        {\n            if (buildAST)\n            {\n                AddToNodeList(ppnodeList, &lastNodeRef, pnodeStmt);\n            }\n        }\n    }\n}\n\ntemplate <class Fn>\nvoid Parser::VisitFunctionsInScope(ParseNodePtr pnodeScopeList, Fn fn)\n{\n    ParseNodePtr pnodeScope;\n    for (pnodeScope = pnodeScopeList; pnodeScope;)\n    {\n        switch (pnodeScope->nop)\n        {\n        case knopBlock:\n            VisitFunctionsInScope(pnodeScope->sxBlock.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxBlock.pnodeNext;\n            break;\n\n        case knopFncDecl:\n            fn(pnodeScope);\n            pnodeScope = pnodeScope->sxFnc.pnodeNext;\n            break;\n\n        case knopCatch:\n            VisitFunctionsInScope(pnodeScope->sxCatch.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            VisitFunctionsInScope(pnodeScope->sxWith.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxWith.pnodeNext;\n            break;\n\n        default:\n            AssertMsg(false, \"Unexpected node with scope list\");\n            return;\n        }\n    }\n}\n\n// Scripts above this size (minus string literals and comments) will have parsing of\n// function bodies deferred.\nULONG Parser::GetDeferralThreshold(bool isProfileLoaded)\n{\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (CONFIG_FLAG(ForceDeferParse) ||\n        PHASE_FORCE1(Js::DeferParsePhase) ||\n        Js::Configuration::Global.flags.IsEnabled(Js::ForceUndoDeferFlag))\n    {\n        return 0;\n    }\n    else if (Js::Configuration::Global.flags.IsEnabled(Js::DeferParseFlag))\n    {\n        return Js::Configuration::Global.flags.DeferParse;\n    }\n    else\n#endif\n    {\n        if (isProfileLoaded)\n        {\n            return DEFAULT_CONFIG_ProfileBasedDeferParseThreshold;\n        }\n        return DEFAULT_CONFIG_DeferParseThreshold;\n    }\n}\n\nvoid Parser::FinishDeferredFunction(ParseNodePtr pnodeScopeList)\n{\n    VisitFunctionsInScope(pnodeScopeList,\n        [this](ParseNodePtr pnodeFnc)\n    {\n        Assert(pnodeFnc->nop == knopFncDecl);\n\n        // Non-simple params (such as default) require a good amount of logic to put vars on appriopriate scopes. ParseFncDecl handles it\n        // properly (both on defer and non-defer case). This is to avoid write duplicated logic here as well. Function with non-simple-param\n        // will remain deferred untill they are called.\n        if (pnodeFnc->sxFnc.pnodeBody == nullptr && !pnodeFnc->sxFnc.HasNonSimpleParameterList())\n        {\n            // Go back and generate an AST for this function.\n            JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_FUNC(this->GetScriptContext(), pnodeFnc->sxFnc.functionId, /*Undefer*/TRUE));\n\n            ParseNodePtr pnodeFncSave = this->m_currentNodeFunc;\n            this->m_currentNodeFunc = pnodeFnc;\n\n            ParseNodePtr pnodeFncExprBlock = nullptr;\n            if (pnodeFnc->sxFnc.pnodeName &&\n                !pnodeFnc->sxFnc.IsDeclaration())\n            {\n                // Set up the named function expression symbol so references inside the function can be bound.\n                ParseNodePtr pnodeName = pnodeFnc->sxFnc.pnodeName;\n                Assert(pnodeName->nop == knopVarDecl);\n                Assert(pnodeName->sxVar.pnodeNext == nullptr);\n\n                pnodeFncExprBlock = this->StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FuncExpr);\n                PidRefStack *ref = this->PushPidRef(pnodeName->sxVar.pid);\n                pnodeName->sxVar.symRef = ref->GetSymRef();\n                ref->SetSym(pnodeName->sxVar.sym);\n\n                Scope *fncExprScope = pnodeFncExprBlock->sxBlock.scope;\n                fncExprScope->AddNewSymbol(pnodeName->sxVar.sym);\n                pnodeFnc->sxFnc.scope = fncExprScope;\n            }\n\n            ParseNodePtr pnodeBlock = this->StartParseBlock<true>(PnodeBlockType::Parameter, ScopeType_Parameter);\n            pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n            // Add the args to the scope, since we won't re-parse those.\n            Scope *scope = pnodeBlock->sxBlock.scope;\n            auto addArgsToScope = [&](ParseNodePtr pnodeArg) {\n                if (pnodeArg->IsVarLetOrConst())\n                {\n                    PidRefStack *ref = this->PushPidRef(pnodeArg->sxVar.pid);\n                    pnodeArg->sxVar.symRef = ref->GetSymRef();\n                    if (ref->GetSym() != nullptr)\n                    {\n                        // Duplicate parameter in a configuration that allows them.\n                        // The symbol is already in the scope, just point it to the right declaration.\n                        Assert(ref->GetSym() == pnodeArg->sxVar.sym);\n                        ref->GetSym()->SetDecl(pnodeArg);\n                    }\n                    else\n                    {\n                        ref->SetSym(pnodeArg->sxVar.sym);\n                        scope->AddNewSymbol(pnodeArg->sxVar.sym);\n                    }\n                }\n            };\n            MapFormals(pnodeFnc, addArgsToScope);\n            MapFormalsFromPattern(pnodeFnc, addArgsToScope);\n\n            ParseNodePtr pnodeInnerBlock = this->StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n            pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n            // Set the parameter block's child to the function body block.\n            *m_ppnodeScope = pnodeInnerBlock;\n\n            ParseNodePtr *ppnodeScopeSave = nullptr;\n            ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n            ppnodeScopeSave = m_ppnodeScope;\n\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n            pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = nullptr;\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (scope != nullptr && !pnodeFnc->sxFnc.IsAsync())\n            {\n                if (scope->GetCanMergeWithBodyScope())\n                {\n                    scope->ForEachSymbol([this](Symbol* paramSym)\n                    {\n                        PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                        ref->SetSym(paramSym);\n                    });\n                }\n                else\n                {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                    // Add a new symbol reference for each formal in the param scope to the body scope.\n                    scope->ForEachSymbol([this](Symbol* param) {\n                        OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n                        ParseNodePtr paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                        paramNode->sxVar.sym->SetHasInit(true);\n                    });\n                }\n            }\n\n            Assert(m_currentNodeNonLambdaFunc == nullptr);\n            m_currentNodeNonLambdaFunc = pnodeFnc;\n\n            this->FinishFncNode(pnodeFnc);\n\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = nullptr;\n\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n\n            AssertMem(m_ppnodeScope);\n            Assert(nullptr == *m_ppnodeScope);\n            m_ppnodeScope = ppnodeScopeSave;\n\n            this->FinishParseBlock(pnodeInnerBlock);\n\n            this->AddArgumentsNodeToVars(pnodeFnc);\n\n            this->FinishParseBlock(pnodeBlock);\n            if (pnodeFncExprBlock)\n            {\n                this->FinishParseBlock(pnodeFncExprBlock);\n            }\n\n            this->m_currentNodeFunc = pnodeFncSave;\n        }\n    });\n}\n\nvoid Parser::InitPids()\n{\n    AssertMemN(m_phtbl);\n    wellKnownPropertyPids.arguments = m_phtbl->PidHashNameLen(g_ssym_arguments.sz, g_ssym_arguments.cch);\n    wellKnownPropertyPids.async = m_phtbl->PidHashNameLen(g_ssym_async.sz, g_ssym_async.cch);\n    wellKnownPropertyPids.eval = m_phtbl->PidHashNameLen(g_ssym_eval.sz, g_ssym_eval.cch);\n    wellKnownPropertyPids.get = m_phtbl->PidHashNameLen(g_ssym_get.sz, g_ssym_get.cch);\n    wellKnownPropertyPids.set = m_phtbl->PidHashNameLen(g_ssym_set.sz, g_ssym_set.cch);\n    wellKnownPropertyPids.let = m_phtbl->PidHashNameLen(g_ssym_let.sz, g_ssym_let.cch);\n    wellKnownPropertyPids.constructor = m_phtbl->PidHashNameLen(g_ssym_constructor.sz, g_ssym_constructor.cch);\n    wellKnownPropertyPids.prototype = m_phtbl->PidHashNameLen(g_ssym_prototype.sz, g_ssym_prototype.cch);\n    wellKnownPropertyPids.__proto__ = m_phtbl->PidHashNameLen(_u(\"__proto__\"), sizeof(\"__proto__\") - 1);\n    wellKnownPropertyPids.of = m_phtbl->PidHashNameLen(_u(\"of\"), sizeof(\"of\") - 1);\n    wellKnownPropertyPids.target = m_phtbl->PidHashNameLen(_u(\"target\"), sizeof(\"target\") - 1);\n    wellKnownPropertyPids.as = m_phtbl->PidHashNameLen(_u(\"as\"), sizeof(\"as\") - 1);\n    wellKnownPropertyPids.from = m_phtbl->PidHashNameLen(_u(\"from\"), sizeof(\"from\") - 1);\n    wellKnownPropertyPids._default = m_phtbl->PidHashNameLen(_u(\"default\"), sizeof(\"default\") - 1);\n    wellKnownPropertyPids._starDefaultStar = m_phtbl->PidHashNameLen(_u(\"*default*\"), sizeof(\"*default*\") - 1);\n    wellKnownPropertyPids._star = m_phtbl->PidHashNameLen(_u(\"*\"), sizeof(\"*\") - 1);\n}\n\nvoid Parser::RestoreScopeInfo(Js::ParseableFunctionInfo* functionBody)\n{\n    if (!functionBody)\n    {\n        return;\n    }\n\n    Js::ScopeInfo* scopeInfo = functionBody->GetScopeInfo();\n    if (!scopeInfo)\n    {\n        return;\n    }\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n\n    RestoreScopeInfo(scopeInfo->GetParent()); // Recursively restore outer func scope info\n\n    Js::ScopeInfo* funcExprScopeInfo = scopeInfo->GetFuncExprScopeInfo();\n    if (funcExprScopeInfo)\n    {\n        funcExprScopeInfo->SetScopeId(m_nextBlockId);\n        ParseNodePtr pnodeFncExprScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Function, ScopeType_FuncExpr, funcExprScopeInfo->GetSymbolCount());\n        Scope *scope = pnodeFncExprScope->sxBlock.scope;\n        funcExprScopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n    }\n\n    Js::ScopeInfo* paramScopeInfo = scopeInfo->GetParamScopeInfo();\n    if (paramScopeInfo)\n    {\n        paramScopeInfo->SetScopeId(m_nextBlockId);\n        ParseNodePtr pnodeFncExprScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Parameter, ScopeType_Parameter, paramScopeInfo->GetSymbolCount());\n        Scope *scope = pnodeFncExprScope->sxBlock.scope;\n        paramScopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n    }\n\n    scopeInfo->SetScopeId(m_nextBlockId);\n    ParseNodePtr pnodeFncScope = nullptr;\n    if (scopeInfo->IsGlobalEval())\n    {\n        pnodeFncScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Regular, ScopeType_GlobalEvalBlock, scopeInfo->GetSymbolCount());\n    }\n    else\n    {\n        pnodeFncScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Function, ScopeType_FunctionBody, scopeInfo->GetSymbolCount());\n    }\n    Scope *scope = pnodeFncScope->sxBlock.scope;\n    scopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n}\n\nvoid Parser::FinishScopeInfo(Js::ParseableFunctionInfo *functionBody)\n{\n    if (!functionBody)\n    {\n        return;\n    }\n\n    Js::ScopeInfo* scopeInfo = functionBody->GetScopeInfo();\n    if (!scopeInfo)\n    {\n        return;\n    }\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n\n    int scopeId = scopeInfo->GetScopeId();\n\n    scopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n    {\n        this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n    });\n    PopScope(scopeInfo->GetScope());\n    PopStmt(&m_currentBlockInfo->pstmt);\n    PopBlockInfo();\n\n    Js::ScopeInfo *paramScopeInfo = scopeInfo->GetParamScopeInfo();\n    if (paramScopeInfo)\n    {\n        scopeId = paramScopeInfo->GetScopeId();\n        paramScopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n        {\n            this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n        });\n        PopScope(paramScopeInfo->GetScope());\n        PopStmt(&m_currentBlockInfo->pstmt);\n        PopBlockInfo();\n    }\n\n    Js::ScopeInfo *funcExprScopeInfo = scopeInfo->GetFuncExprScopeInfo();\n    if (funcExprScopeInfo)\n    {\n        scopeId = funcExprScopeInfo->GetScopeId();\n        funcExprScopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n        {\n            this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n        });\n        PopScope(funcExprScopeInfo->GetScope());\n        PopStmt(&m_currentBlockInfo->pstmt);\n        PopBlockInfo();\n    }\n\n    FinishScopeInfo(scopeInfo->GetParent());\n}\n\n/***************************************************************************\nParse the code.\n***************************************************************************/\nParseNodePtr Parser::Parse(LPCUTF8 pszSrc, size_t offset, size_t length, charcount_t charOffset, ULONG grfscr, ULONG lineNumber, Js::LocalFunctionId * nextFunctionId, CompileScriptException *pse)\n{\n    ParseNodePtr pnodeProg;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    m_nextBlockId = 0;\n\n    // Scanner should run in Running mode and not syntax coloring mode\n    grfscr &= ~fscrSyntaxColor;\n\n    if (this->m_scriptContext->IsScriptContextInDebugMode()\n#ifdef ENABLE_PREJIT\n         || Js::Configuration::Global.flags.Prejit\n#endif\n         || ((grfscr & fscrNoDeferParse) != 0)\n        )\n    {\n        // Don't do deferred parsing if debugger is attached or feature is disabled\n        // by command-line switch.\n        grfscr &= ~fscrDeferFncParse;\n    }\n    else if (!(grfscr & fscrGlobalCode) &&\n             (\n                 PHASE_OFF1(Js::Phase::DeferEventHandlersPhase) ||\n                 this->m_scriptContext->IsScriptContextInSourceRundownOrDebugMode()\n             )\n        )\n    {\n        // Don't defer event handlers in debug/rundown mode, because we need to register the document,\n        // so we need to create a full FunctionBody for the script body.\n        grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool isDeferred = (grfscr & fscrDeferredFnc) != 0;\n    bool isModuleSource = (grfscr & fscrIsModuleCode) != 0;\n\n    m_grfscr = grfscr;\n    m_length = length;\n    m_originalLength = length;\n    m_nextFunctionId = nextFunctionId;\n\n    if(m_parseType != ParseType_Deferred)\n    {\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_START(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), *m_nextFunctionId, 0, m_parseType, Js::Constants::GlobalFunction));\n        OUTPUT_TRACE(Js::DeferParsePhase, _u(\"Parsing function (%s) : %s (%d)\\n\"), GetParseType(), Js::Constants::GlobalFunction, *m_nextFunctionId);\n    }\n\n    // Give the scanner the source and get the first token\n    m_pscan->SetText(pszSrc, offset, length, charOffset, grfscr, lineNumber);\n    m_pscan->Scan();\n\n    // Make the main 'knopProg' node\n    int32 initSize = 0;\n    m_pCurrentAstSize = &initSize;\n    pnodeProg = CreateProgNodeWithScanner(isModuleSource);\n    pnodeProg->grfpn = PNodeFlags::fpnNone;\n    pnodeProg->sxFnc.pid = nullptr;\n    pnodeProg->sxFnc.pnodeName = nullptr;\n    pnodeProg->sxFnc.pnodeRest = nullptr;\n    pnodeProg->sxFnc.ClearFlags();\n    pnodeProg->sxFnc.SetNested(FALSE);\n    pnodeProg->sxFnc.astSize = 0;\n    pnodeProg->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeProg->sxFnc.lineNumber = lineNumber;\n    pnodeProg->sxFnc.columnNumber = 0;\n\n    if (!isDeferred || (isDeferred && grfscr & fscrGlobalCode))\n    {\n        // In the deferred case, if the global function is deferred parse (which is in no-refresh case),\n        // we will re-use the same function body, so start with the correct functionId.\n        pnodeProg->sxFnc.functionId = (*m_nextFunctionId)++;\n    }\n    else\n    {\n        pnodeProg->sxFnc.functionId = Js::Constants::NoFunctionId;\n    }\n\n    if (isModuleSource)\n    {\n        Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n\n        pnodeProg->sxModule.localExportEntries = nullptr;\n        pnodeProg->sxModule.indirectExportEntries = nullptr;\n        pnodeProg->sxModule.starExportEntries = nullptr;\n        pnodeProg->sxModule.importEntries = nullptr;\n        pnodeProg->sxModule.requestedModules = nullptr;\n    }\n\n    m_pCurrentAstSize = & (pnodeProg->sxFnc.astSize);\n\n    pnodeProg->sxFnc.hint = nullptr;\n    pnodeProg->sxFnc.hintLength = 0;\n    pnodeProg->sxFnc.hintOffset = 0;\n    pnodeProg->sxFnc.isNameIdentifierRef = true;\n    pnodeProg->sxFnc.nestedFuncEscapes = false;\n\n    // initialize parsing variables\n    pnodeProg->sxFnc.pnodeNext = nullptr;\n\n    m_currentNodeFunc = nullptr;\n    m_currentNodeDeferredFunc = nullptr;\n    m_currentNodeProg = pnodeProg;\n    m_cactIdentToNodeLookup = 1;\n\n    pnodeProg->sxFnc.nestedCount = 0;\n    m_pnestedCount = &pnodeProg->sxFnc.nestedCount;\n    m_inDeferredNestedFunc = false;\n\n    pnodeProg->sxFnc.pnodeParams = nullptr;\n    pnodeProg->sxFnc.pnodeVars = nullptr;\n    pnodeProg->sxFnc.pnodeRest = nullptr;\n    m_ppnodeVar = &pnodeProg->sxFnc.pnodeVars;\n    SetCurrentStatement(nullptr);\n    AssertMsg(m_pstmtCur == nullptr, \"Statement stack should be empty when we start parse global code\");\n\n    // Create block for const's and let's\n    ParseNodePtr pnodeGlobalBlock = StartParseBlock<true>(PnodeBlockType::Global, ScopeType_Global);\n    pnodeProg->sxProg.scope = pnodeGlobalBlock->sxBlock.scope;\n    ParseNodePtr pnodeGlobalEvalBlock = nullptr;\n\n    // Don't track function expressions separately from declarations at global scope.\n    m_ppnodeExprScope = nullptr;\n\n    // This synthetic block scope will contain all the nested scopes.\n    pnodeProg->sxFnc.pnodeBodyScope = nullptr;\n    pnodeProg->sxFnc.pnodeScopes = pnodeGlobalBlock;\n    m_ppnodeScope = &pnodeGlobalBlock->sxBlock.pnodeScopes;\n\n    if ((this->m_grfscr & fscrEvalCode) &&\n        !(this->m_functionBody && this->m_functionBody->GetScopeInfo()))\n    {\n        pnodeGlobalEvalBlock = StartParseBlock<true>(PnodeBlockType::Regular, ScopeType_GlobalEvalBlock);\n        pnodeProg->sxFnc.pnodeScopes = pnodeGlobalEvalBlock;\n        m_ppnodeScope = &pnodeGlobalEvalBlock->sxBlock.pnodeScopes;\n    }\n\n    Js::ScopeInfo *scopeInfo = nullptr;\n    if (m_parseType == ParseType_Deferred && m_functionBody)\n    {\n        // this->m_functionBody can be cleared during parsing, but we need access to the scope info later.\n        scopeInfo = m_functionBody->GetScopeInfo();\n        if (scopeInfo)\n        {\n            // Create an enclosing function context.\n            m_currentNodeFunc = CreateNode(knopFncDecl);\n            m_currentNodeFunc->sxFnc.pnodeName = nullptr;\n            m_currentNodeFunc->sxFnc.functionId = m_functionBody->GetLocalFunctionId();\n            m_currentNodeFunc->sxFnc.nestedCount = m_functionBody->GetNestedCount();\n            m_currentNodeFunc->sxFnc.SetStrictMode(!!this->m_fUseStrictMode);\n\n            this->RestoreScopeInfo(scopeInfo->GetParent());\n        }\n    }\n\n    // It's possible for the module global to be defer-parsed in debug scenarios.\n    if (isModuleSource && (!isDeferred || (isDeferred && grfscr & fscrGlobalCode)))\n    {\n        ParseNodePtr moduleFunction = GenerateModuleFunctionWrapper<true>();\n        pnodeProg->sxFnc.pnodeBody = nullptr;\n        AddToNodeList(&pnodeProg->sxFnc.pnodeBody, &lastNodeRef, moduleFunction);\n    }\n    else\n    {\n        // Process a sequence of statements/declarations\n        ParseStmtList<true>(\n            &pnodeProg->sxFnc.pnodeBody,\n            &lastNodeRef,\n            SM_OnGlobalCode,\n            !(m_grfscr & fscrDeferredFncExpression) /* isSourceElementList */);\n    }\n\n    if (m_parseType == ParseType_Deferred)\n    {\n        if (scopeInfo)\n        {\n            this->FinishScopeInfo(scopeInfo->GetParent());\n        }\n    }\n\n    pnodeProg->sxProg.m_UsesArgumentsAtGlobal = m_UsesArgumentsAtGlobal;\n\n    if (IsStrictMode())\n    {\n        pnodeProg->sxFnc.SetStrictMode();\n    }\n\n#if DEBUG\n    if(m_grfscr & fscrEnforceJSON && !IsJSONValid(pnodeProg->sxFnc.pnodeBody))\n    {\n        Error(ERRsyntax);\n    }\n#endif\n\n    if (tkEOF != m_token.tk)\n        Error(ERRsyntax);\n\n    // Append an EndCode node.\n    AddToNodeList(&pnodeProg->sxFnc.pnodeBody, &lastNodeRef,\n        CreateNodeWithScanner<knopEndCode>());\n    AssertMem(lastNodeRef);\n    AssertNodeMem(*lastNodeRef);\n    Assert((*lastNodeRef)->nop == knopEndCode);\n    (*lastNodeRef)->ichMin = 0;\n    (*lastNodeRef)->ichLim = 0;\n\n    // Get the extent of the code.\n    pnodeProg->ichLim = m_pscan->IchLimTok();\n    pnodeProg->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n    // Terminate the local list\n    *m_ppnodeVar = nullptr;\n\n    Assert(nullptr == *m_ppnodeScope);\n    Assert(nullptr == pnodeProg->sxFnc.pnodeNext);\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (Js::Configuration::Global.flags.IsEnabled(Js::ForceUndoDeferFlag))\n    {\n        m_stoppedDeferredParse = true;\n    }\n#endif\n\n    if (m_stoppedDeferredParse)\n    {\n        if (this->m_hasParallelJob)\n        {\n#if ENABLE_BACKGROUND_PARSING\n            BackgroundParser *bgp = static_cast<BackgroundParser*>(m_scriptContext->GetBackgroundParser());\n            Assert(bgp);\n            this->WaitForBackgroundJobs(bgp, pse);\n#endif\n        }\n\n        // Finally, see if there are any function bodies we now want to generate because we\n        // decided to stop deferring.\n        FinishDeferredFunction(pnodeProg->sxFnc.pnodeScopes);\n    }\n\n    if (pnodeGlobalEvalBlock)\n    {\n        FinishParseBlock(pnodeGlobalEvalBlock);\n    }\n    // Append block as body of pnodeProg\n    FinishParseBlock(pnodeGlobalBlock);\n\n    m_scriptContext->AddSourceSize(m_length);\n\n    if (m_parseType != ParseType_Deferred)\n    {\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_STOP(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeProg->sxFnc.functionId, *m_pCurrentAstSize, false, Js::Constants::GlobalFunction));\n    }\n    return pnodeProg;\n}\n\n\nbool Parser::CheckForDirective(bool* pIsUseStrict, bool *pIsUseAsm, bool* pIsOctalInString)\n{\n    // A directive is a string constant followed by a statement terminating token\n    if (m_token.tk != tkStrCon)\n        return false;\n\n    // Careful, need to check for octal before calling m_pscan->Scan()\n    // because Scan() clears the \"had octal\" flag on the scanner and\n    // m_pscan->Restore() does not restore this flag.\n    if (pIsOctalInString != nullptr)\n    {\n        *pIsOctalInString = m_pscan->IsOctOrLeadingZeroOnLastTKNumber();\n    }\n\n    Ident* pidDirective = m_token.GetStr();\n    RestorePoint start;\n    m_pscan->Capture(&start);\n    m_pscan->Scan();\n\n    bool isDirective = true;\n\n    switch (m_token.tk)\n    {\n    case tkSColon:\n    case tkEOF:\n    case tkLCurly:\n    case tkRCurly:\n        break;\n    default:\n        if (!m_pscan->FHadNewLine())\n        {\n            isDirective = false;\n        }\n        break;\n    }\n\n    if (isDirective)\n    {\n        if (pIsUseStrict != nullptr)\n        {\n            *pIsUseStrict = CheckStrictModeStrPid(pidDirective);\n        }\n        if (pIsUseAsm != nullptr)\n        {\n            *pIsUseAsm = CheckAsmjsModeStrPid(pidDirective);\n        }\n    }\n\n    m_pscan->SeekTo(start);\n    return isDirective;\n}\n\nbool Parser::CheckStrictModeStrPid(IdentPtr pid)\n{\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (Js::Configuration::Global.flags.NoStrictMode)\n        return false;\n#endif\n\n    return pid != nullptr &&\n        pid->Cch() == 10 &&\n        !m_pscan->IsEscapeOnLastTkStrCon() &&\n        wcsncmp(pid->Psz(), _u(\"use strict\"), 10) == 0;\n}\n\nbool Parser::CheckAsmjsModeStrPid(IdentPtr pid)\n{\n#ifdef ASMJS_PLAT\n    if (!CONFIG_FLAG_RELEASE(Asmjs))\n    {\n        return false;\n    }\n\n    bool isAsmCandidate = (pid != nullptr &&\n        AutoSystemInfo::Data.SSE2Available() &&\n        pid->Cch() == 7 &&\n        !m_pscan->IsEscapeOnLastTkStrCon() &&\n        wcsncmp(pid->Psz(), _u(\"use asm\"), 10) == 0);\n\n    if (isAsmCandidate && m_scriptContext->IsScriptContextInDebugMode())\n    {\n        // We would like to report this to debugger - they may choose to disable debugging.\n        // TODO : localization of the string?\n        m_scriptContext->RaiseMessageToDebugger(DEIT_ASMJS_IN_DEBUGGING, _u(\"AsmJs initialization error - AsmJs disabled due to script debugger\"), !m_sourceContextInfo->IsDynamic() ? m_sourceContextInfo->url : nullptr);\n        return false;\n    }\n\n    return isAsmCandidate && !(m_grfscr & fscrNoAsmJs);\n#else\n    return false;\n#endif\n}\n\nHRESULT Parser::ParseUtf8Source(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t length, ULONG grfsrc, CompileScriptException *pse,\n    Js::LocalFunctionId * nextFunctionId, SourceContextInfo * sourceContextInfo)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    return ParseSourceInternal( parseTree, pSrc, 0, length, 0, true, grfsrc, pse, nextFunctionId, 0, sourceContextInfo);\n}\n\nHRESULT Parser::ParseCesu8Source(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t length, ULONG grfsrc, CompileScriptException *pse,\n    Js::LocalFunctionId * nextFunctionId, SourceContextInfo * sourceContextInfo)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    return ParseSourceInternal( parseTree, pSrc, 0, length, 0, false, grfsrc, pse, nextFunctionId, 0, sourceContextInfo);\n}\n\nvoid Parser::PrepareScanner(bool fromExternal)\n{\n    // NOTE: HashTbl and Scanner are currently allocated from the CRT heap. If we want to allocate them from the\n    // parser arena, then we also need to change the way the HashTbl allocates PID's from its underlying\n    // allocator (which also currently uses the CRT heap). This is not trivial, because we still need to support\n    // heap allocation for the colorizer interface.\n\n    // create the hash table and init PID members\n    if (nullptr == (m_phtbl = HashTbl::Create(HASH_TABLE_SIZE, &m_err)))\n        Error(ERRnoMemory);\n    InitPids();\n\n    // create the scanner\n    if (nullptr == (m_pscan = Scanner_t::Create(this, m_phtbl, &m_token, &m_err, m_scriptContext)))\n        Error(ERRnoMemory);\n\n    if (fromExternal)\n        m_pscan->FromExternalSource();\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::PrepareForBackgroundParse()\n{\n    m_pscan->PrepareForBackgroundParse(m_scriptContext);\n}\n\nvoid Parser::AddBackgroundParseItem(BackgroundParseItem *const item)\n{\n    if (currBackgroundParseItem == nullptr)\n    {\n        backgroundParseItems = item;\n    }\n    else\n    {\n        currBackgroundParseItem->SetNext(item);\n    }\n    currBackgroundParseItem = item;\n}\n#endif\n\nvoid Parser::AddFastScannedRegExpNode(ParseNodePtr const pnode)\n{\n    Assert(!IsBackgroundParser());\n    Assert(m_doingFastScan);\n\n    if (fastScannedRegExpNodes == nullptr)\n    {\n        fastScannedRegExpNodes = Anew(&m_nodeAllocator, NodeDList, &m_nodeAllocator);\n    }\n    fastScannedRegExpNodes->Append(pnode);\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::AddBackgroundRegExpNode(ParseNodePtr const pnode)\n{\n    Assert(IsBackgroundParser());\n    Assert(currBackgroundParseItem != nullptr);\n\n    currBackgroundParseItem->AddRegExpNode(pnode, &m_nodeAllocator);\n}\n#endif\n\nHRESULT Parser::ParseFunctionInBackground(ParseNodePtr pnodeFnc, ParseContext *parseContext, bool topLevelDeferred, CompileScriptException *pse)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    HRESULT hr = S_OK;\n    SmartFPUControl smartFpuControl;\n    uint nextFunctionId = pnodeFnc->sxFnc.functionId + 1;\n\n    this->RestoreContext(parseContext);\n    DebugOnly( m_err.fInited = TRUE; )\n    m_nextFunctionId = &nextFunctionId;\n    m_deferringAST = topLevelDeferred;\n    m_inDeferredNestedFunc = false;\n    m_scopeCountNoAst = 0;\n\n    SetCurrentStatement(nullptr);\n\n    pnodeFnc->sxFnc.pnodeVars = nullptr;\n    pnodeFnc->sxFnc.pnodeParams = nullptr;\n    pnodeFnc->sxFnc.pnodeBody = nullptr;\n    pnodeFnc->sxFnc.nestedCount = 0;\n\n    ParseNodePtr pnodeParentFnc = GetCurrentFunctionNode();\n    m_currentNodeFunc = pnodeFnc;\n    m_currentNodeDeferredFunc = nullptr;\n    m_ppnodeScope = nullptr;\n    m_ppnodeExprScope = nullptr;\n\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n    m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n\n    ParseNodePtr pnodeBlock = StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n    pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n    m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n\n    try\n    {\n        m_pscan->Scan();\n\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n        this->ParseFncFormals<true>(pnodeFnc, pnodeParentFnc, fFncNoFlgs);\n\n        if (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n        }\n\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n        // Put the scanner into \"no hashing\" mode.\n        BYTE deferFlags = m_pscan->SetDeferredParse(topLevelDeferred);\n\n        // Process a sequence of statements/declarations\n        if (topLevelDeferred)\n        {\n            ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true);\n        }\n        else\n        {\n            ParseNodePtr *lastNodeRef = nullptr;\n            ParseStmtList<true>(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, SM_OnFunctionCode, true);\n            AddArgumentsNodeToVars(pnodeFnc);\n            // Append an EndCode node.\n            AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n        }\n\n        // Restore the scanner's default hashing mode.\n        m_pscan->SetDeferredParseFlags(deferFlags);\n\n#if DBG\n        pnodeFnc->sxFnc.deferredParseNextFunctionId = *this->m_nextFunctionId;\n#endif\n        this->m_deferringAST = FALSE;\n\n        // Append block as body of pnodeProg\n        FinishParseBlock(pnodeBlock);\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan, m_err.m_hr, nullptr);\n    }\n\n    if (IsStrictMode())\n    {\n        pnodeFnc->sxFnc.SetStrictMode();\n    }\n\n    if (topLevelDeferred)\n    {\n        pnodeFnc->sxFnc.pnodeVars = nullptr;\n    }\n\n    m_grfscr |= uDeferSave;\n\n    Assert(nullptr == *m_ppnodeScope);\n\n    return hr;\n}\n\nHRESULT Parser::ParseSourceWithOffset(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t offset, size_t cbLength, charcount_t cchOffset,\n        bool isCesu8, ULONG grfscr, CompileScriptException *pse, Js::LocalFunctionId * nextFunctionId, ULONG lineNumber, SourceContextInfo * sourceContextInfo,\n        Js::ParseableFunctionInfo* functionInfo)\n{\n    m_functionBody = functionInfo;\n    if (m_functionBody)\n    {\n        m_currDeferredStub = m_functionBody->GetDeferredStubs();\n        m_InAsmMode = grfscr & fscrNoAsmJs ? false : m_functionBody->GetIsAsmjsMode();\n    }\n    m_deferAsmJs = !m_InAsmMode;\n    m_parseType = ParseType_Deferred;\n    return ParseSourceInternal( parseTree, pSrc, offset, cbLength, cchOffset, !isCesu8, grfscr, pse, nextFunctionId, lineNumber, sourceContextInfo);\n}\n\nbool Parser::IsStrictMode() const\n{\n    return (m_fUseStrictMode ||\n           (m_currentNodeFunc != nullptr && m_currentNodeFunc->sxFnc.GetStrictMode()));\n}\n\nBOOL Parser::ExpectingExternalSource()\n{\n    return m_fExpectExternalSource;\n}\n\nSymbol *PnFnc::GetFuncSymbol()\n{\n    if (pnodeName &&\n        pnodeName->nop == knopVarDecl)\n    {\n        return pnodeName->sxVar.sym;\n    }\n    return nullptr;\n}\n\nvoid PnFnc::SetFuncSymbol(Symbol *sym)\n{\n    Assert(pnodeName &&\n           pnodeName->nop == knopVarDecl);\n    pnodeName->sxVar.sym = sym;\n}\n\nParseNodePtr PnFnc::GetParamScope() const\n{\n    if (this->pnodeScopes == nullptr)\n    {\n        return nullptr;\n    }\n    Assert(this->pnodeScopes->nop == knopBlock &&\n           this->pnodeScopes->sxBlock.pnodeNext == nullptr);\n    return this->pnodeScopes->sxBlock.pnodeScopes;\n}\n\nParseNodePtr PnFnc::GetBodyScope() const\n{\n    if (this->pnodeBodyScope == nullptr)\n    {\n        return nullptr;\n    }\n    Assert(this->pnodeBodyScope->nop == knopBlock &&\n           this->pnodeBodyScope->sxBlock.pnodeNext == nullptr);\n    return this->pnodeBodyScope->sxBlock.pnodeScopes;\n}\n\n// Create node versions with explicit token limits\nParseNodePtr Parser::CreateNode(OpCode nop, charcount_t ichMin, charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    Assert(nop >= 0 && nop < knopLim);\n    ParseNodePtr pnode;\n    __analysis_assume(nop < knopLim);\n    int cb = nop >= 0 && nop < knopLim ? g_mpnopcbNode[nop] : kcbPnNone;\n\n    pnode = (ParseNodePtr)m_nodeAllocator.Alloc(cb);\n    Assert(pnode);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += cb;\n\n    InitNode(nop,pnode);\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateNameNode(IdentPtr pid,charcount_t ichMin,charcount_t ichLim) {\n  ParseNodePtr pnode = CreateNodeT<knopName>(ichMin,ichLim);\n  pnode->sxPid.pid = pid;\n  pnode->sxPid.sym=NULL;\n  pnode->sxPid.symRef=NULL;\n  return pnode;\n}\n\nParseNodePtr Parser::CreateUniNode(OpCode nop, ParseNodePtr pnode1, charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnUni));\n\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnUni);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnUni;\n\n    InitNode(nop, pnode);\n\n    pnode->sxUni.pnode1 = pnode1;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBinNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2,charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = StaticCreateBinNode(nop, pnode1, pnode2, &m_nodeAllocator);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnBin;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTriNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2, ParseNodePtr pnode3,\n                                   charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnTri));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnTri);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnTri;\n\n    InitNode(nop, pnode);\n\n    pnode->sxTri.pnodeNext = NULL;\n    pnode->sxTri.pnode1 = pnode1;\n    pnode->sxTri.pnode2 = pnode2;\n    pnode->sxTri.pnode3 = pnode3;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nbool PnBlock::HasBlockScopedContent() const\n{\n    // A block has its own content if a let, const, or function is declared there.\n\n    if (this->pnodeLexVars != nullptr || this->blockType == Parameter)\n    {\n        return true;\n    }\n\n    // The enclosing scopes can contain functions and other things, so walk the list\n    // looking specifically for functions.\n\n    for (ParseNodePtr pnode = this->pnodeScopes; pnode;)\n    {\n        switch (pnode->nop) {\n\n        case knopFncDecl:\n            return true;\n\n        case knopBlock:\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n\n        case knopCatch:\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n\n        default:\n            Assert(UNREACHED);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nclass ByteCodeGenerator;\n\n// Copy AST; this works mostly on expressions for now\nParseNode* Parser::CopyPnode(ParseNode *pnode) {\n    if (pnode==NULL)\n        return NULL;\n    switch (pnode->nop) {\n        //PTNODE(knopName       , \"name\"        ,None    ,Pid  ,fnopLeaf)\n    case knopName: {\n      ParseNode* nameNode=CreateNameNode(pnode->sxPid.pid,pnode->ichMin,pnode->ichLim);\n      nameNode->sxPid.sym=pnode->sxPid.sym;\n      return nameNode;\n    }\n      //PTNODE(knopInt        , \"int const\"    ,None    ,Int  ,fnopLeaf|fnopConst)\n  case knopInt:\n    return pnode;\n      //PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n  case knopFlt:\n    return pnode;\n      //PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopStr:\n    return pnode;\n      //PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopRegExp:\n    return pnode;\n    break;\n      //PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n  case knopThis:\n    return CreateNodeT<knopThis>(pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n  case knopNull:\n    return pnode;\n      //PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n  case knopFalse:\n    {\n      ParseNode* ret = CreateNodeT<knopFalse>(pnode->ichMin, pnode->ichLim);\n      ret->location = pnode->location;\n      return ret;\n    }\n      //PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n  case knopTrue:\n    {\n        ParseNode* ret = CreateNodeT<knopTrue>(pnode->ichMin, pnode->ichLim);\n        ret->location = pnode->location;\n        return ret;\n    }\n      //PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n  case knopEmpty:\n    return CreateNodeT<knopEmpty>(pnode->ichMin,pnode->ichLim);\n      // Unary operators.\n      //PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n      //PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n      //PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n      //PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n      //PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni    , fnopUni)\n      //PTNODE(knopDecPost    , \"-- post\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopDecPre     , \"-- pre\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n      //PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n      //PTNODE(knopDelete     , \"delete\"    ,None    ,Uni  ,fnopUni)\n  case knopNot:\n  case knopNeg:\n  case knopPos:\n  case knopLogNot:\n  case knopEllipsis:\n  case knopIncPost:\n  case knopDecPost:\n  case knopIncPre:\n  case knopDecPre:\n  case knopTypeof:\n  case knopVoid:\n  case knopDelete:\n    return CreateUniNode(pnode->nop,CopyPnode(pnode->sxUni.pnode1),pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n      //PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n  case knopArray:\n  case knopObject:\n    // TODO: need to copy arr\n    Assert(false);\n    break;\n      // Binary operators\n      //PTNODE(knopAdd        , \"+\"            ,Add     ,Bin  ,fnopBin)\n      //PTNODE(knopSub        , \"-\"            ,Sub     ,Bin  ,fnopBin)\n      //PTNODE(knopMul        , \"*\"            ,Mul     ,Bin  ,fnopBin)\n      //PTNODE(knopExpo       , \"**\"           ,Expo     ,Bin  ,fnopBin)\n      //PTNODE(knopDiv        , \"/\"            ,Div     ,Bin  ,fnopBin)\n      //PTNODE(knopMod        , \"%\"            ,Mod     ,Bin  ,fnopBin)\n      //PTNODE(knopOr         , \"|\"            ,BitOr   ,Bin  ,fnopBin)\n      //PTNODE(knopXor        , \"^\"            ,BitXor  ,Bin  ,fnopBin)\n      //PTNODE(knopAnd        , \"&\"            ,BitAnd  ,Bin  ,fnopBin)\n      //PTNODE(knopEq         , \"==\"        ,EQ      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopNe         , \"!=\"        ,NE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopLt         , \"<\"            ,LT      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopLe         , \"<=\"        ,LE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopGe         , \">=\"        ,GE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopGt         , \">\"            ,GT      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopEqv        , \"===\"        ,Eqv     ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopIn         , \"in\"        ,In      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopInstOf     , \"instanceof\",InstOf  ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopNEqv       , \"!==\"        ,NEqv    ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopComma      , \",\"            ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLsh        , \"<<\"        ,Lsh     ,Bin  ,fnopBin)\n      //PTNODE(knopRsh        , \">>\"        ,Rsh     ,Bin  ,fnopBin)\n      //PTNODE(knopRs2        , \">>>\"        ,Rs2     ,Bin  ,fnopBin)\n  case knopAdd:\n  case knopSub:\n  case knopMul:\n  case knopExpo:\n  case knopDiv:\n  case knopMod:\n  case knopOr:\n  case knopXor:\n  case knopAnd:\n  case knopEq:\n  case knopNe:\n  case knopLt:\n  case knopLe:\n  case knopGe:\n  case knopGt:\n  case knopEqv:\n  case knopIn:\n  case knopInstOf:\n  case knopNEqv:\n  case knopComma:\n  case knopLogOr:\n  case knopLogAnd:\n  case knopLsh:\n  case knopRsh:\n  case knopRs2:\n      //PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsg:\n      //PTNODE(knopDot        , \".\"            ,None    ,Bin  ,fnopBin)\n  case knopDot:\n      //PTNODE(knopAsgAdd     , \"+=\"        ,Add     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAdd:\n      //PTNODE(knopAsgSub     , \"-=\"        ,Sub     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgSub:\n      //PTNODE(knopAsgMul     , \"*=\"        ,Mul     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMul:\n      //PTNODE(knopAsgDiv     , \"/=\"        ,Div     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgExpo:\n      //PTNODE(knopAsgExpo    , \"**=\"       ,Expo    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgDiv:\n      //PTNODE(knopAsgMod     , \"%=\"        ,Mod     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMod:\n      //PTNODE(knopAsgAnd     , \"&=\"        ,BitAnd  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAnd:\n      //PTNODE(knopAsgXor     , \"^=\"        ,BitXor  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgXor:\n      //PTNODE(knopAsgOr      , \"|=\"        ,BitOr   ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgOr:\n      //PTNODE(knopAsgLsh     , \"<<=\"        ,Lsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgLsh:\n      //PTNODE(knopAsgRsh     , \">>=\"        ,Rsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRsh:\n      //PTNODE(knopAsgRs2     , \">>>=\"        ,Rs2     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRs2:\n      //PTNODE(knopMember     , \":\"            ,None    ,Bin  ,fnopBin)\n  case knopMember:\n  case knopMemberShort:\n      //PTNODE(knopIndex      , \"[]\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopList       , \"<list>\"    ,None    ,Bin  ,fnopNone)\n\n  case knopIndex:\n  case knopList:\n    return CreateBinNode(pnode->nop,CopyPnode(pnode->sxBin.pnode1),\n                         CopyPnode(pnode->sxBin.pnode2),pnode->ichMin,pnode->ichLim);\n\n      //PTNODE(knopCall       , \"()\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopNew        , \"new\"        ,None    ,Bin  ,fnopBin)\n  case knopNew:\n  case knopCall:\n    return CreateCallNode(pnode->nop,CopyPnode(pnode->sxCall.pnodeTarget),\n                         CopyPnode(pnode->sxCall.pnodeArgs),pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n  case knopQmark:\n    return CreateTriNode(pnode->nop,CopyPnode(pnode->sxTri.pnode1),\n                         CopyPnode(pnode->sxTri.pnode2),CopyPnode(pnode->sxTri.pnode3),\n                         pnode->ichMin,pnode->ichLim);\n      // General nodes.\n      //PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n    case knopVarDecl: {\n      ParseNode* copyNode=CreateNodeT<knopVarDecl>(pnode->ichMin,pnode->ichLim);\n      copyNode->sxVar.pnodeInit=CopyPnode(pnode->sxVar.pnodeInit);\n      copyNode->sxVar.sym=pnode->sxVar.sym;\n      // TODO: mult-decl\n      Assert(pnode->sxVar.pnodeNext==NULL);\n      copyNode->sxVar.pnodeNext=NULL;\n      return copyNode;\n    }\n      //PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n      //PTNODE(knopProg       , \"program\"    ,None    ,Fnc  ,fnopNone)\n  case knopFncDecl:\n  case knopProg:\n    Assert(false);\n    break;\n      //PTNODE(knopEndCode    , \"<endcode>\"    ,None    ,None ,fnopNone)\n  case knopEndCode:\n    break;\n      //PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n  case knopDebugger:\n    break;\n      //PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n    case knopFor: {\n      ParseNode* copyNode=CreateNodeT<knopFor>(pnode->ichMin,pnode->ichLim);\n      copyNode->sxFor.pnodeInverted=NULL;\n      copyNode->sxFor.pnodeInit=CopyPnode(pnode->sxFor.pnodeInit);\n      copyNode->sxFor.pnodeCond=CopyPnode(pnode->sxFor.pnodeCond);\n      copyNode->sxFor.pnodeIncr=CopyPnode(pnode->sxFor.pnodeIncr);\n      copyNode->sxFor.pnodeBody=CopyPnode(pnode->sxFor.pnodeBody);\n      return copyNode;\n    }\n      //PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n  case knopIf:\n    Assert(false);\n    break;\n      //PTNODE(knopWhile      , \"while\"        ,None    ,While,fnopBreak|fnopContinue)\n  case knopWhile:\n    Assert(false);\n    break;\n      //PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n  case knopDoWhile:\n    Assert(false);\n    break;\n      //PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n  case knopForIn:\n    Assert(false);\n    break;\n  case knopForOf:\n    Assert(false);\n    break;\n      //PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n  case knopReturn: {\n    ParseNode* copyNode=CreateNodeT<knopReturn>(pnode->ichMin,pnode->ichLim);\n    copyNode->sxReturn.pnodeExpr=CopyPnode(pnode->sxReturn.pnodeExpr);\n    return copyNode;\n  }\n      //PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n  case knopBlock: {\n    ParseNode* copyNode=CreateBlockNode(pnode->ichMin,pnode->ichLim,pnode->sxBlock.blockType);\n    if (pnode->grfpn & PNodeFlags::fpnSyntheticNode) {\n        // fpnSyntheticNode is sometimes set on PnodeBlockType::Regular blocks which\n        // CreateBlockNode() will not automatically set for us, so set it here if it's\n        // specified on the source node.\n        copyNode->grfpn |= PNodeFlags::fpnSyntheticNode;\n    }\n    copyNode->sxBlock.pnodeStmt=CopyPnode(pnode->sxBlock.pnodeStmt);\n    return copyNode;\n  }\n      //PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n  case knopWith:\n    Assert(false);\n    break;\n      //PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n  case knopBreak:\n    Assert(false);\n    break;\n      //PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n  case knopContinue:\n    Assert(false);\n    break;\n      //PTNODE(knopLabel      , \"label\"        ,None    ,Label,fnopNone)\n  case knopLabel:\n    Assert(false);\n    break;\n      //PTNODE(knopSwitch     , \"switch\"    ,None    ,Switch,fnopBreak)\n  case knopSwitch:\n    Assert(false);\n    break;\n      //PTNODE(knopCase       , \"case\"        ,None    ,Case ,fnopNone)\n  case knopCase:\n    Assert(false);\n    break;\n      //PTNODE(knopTryFinally,\"try-finally\",None,TryFinally,fnopCleanup)\n  case knopTryFinally:\n    Assert(false);\n    break;\n  case knopFinally:\n    Assert(false);\n    break;\n      //PTNODE(knopCatch      , \"catch\"     ,None    ,Catch,fnopNone)\n  case knopCatch:\n    Assert(false);\n    break;\n      //PTNODE(knopTryCatch      , \"try-catch\" ,None    ,TryCatch  ,fnopCleanup)\n  case knopTryCatch:\n    Assert(false);\n    break;\n      //PTNODE(knopTry        , \"try\"       ,None    ,Try  ,fnopCleanup)\n  case knopTry:\n    Assert(false);\n    break;\n      //PTNODE(knopThrow      , \"throw\"     ,None    ,Uni  ,fnopNone)\n  case knopThrow:\n    Assert(false);\n    break;\n  default:\n    Assert(false);\n    break;\n    }\n    return NULL;\n}\n\n// Returns true when str is string for Nan, Infinity or -Infinity.\n// Does not check for double number value being in NaN/Infinity range.\n// static\ntemplate<bool CheckForNegativeInfinity>\ninline bool Parser::IsNaNOrInfinityLiteral(LPCOLESTR str)\n{\n    // Note: wcscmp crashes when one of the parameters is NULL.\n    return str &&\n           (wcscmp(_u(\"NaN\"), str) == 0 ||\n           wcscmp(_u(\"Infinity\"), str) == 0 ||\n               (CheckForNegativeInfinity && wcscmp(_u(\"-Infinity\"), str) == 0));\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseSuper(ParseNodePtr pnode, bool fAllowCall)\n{\n    ParseNodePtr currentNodeFunc = GetCurrentFunctionNode();\n\n    if (buildAST) {\n        pnode = CreateNodeWithScanner<knopSuper>();\n    }\n\n    m_pscan->ScanForcingPid();\n\n    switch (m_token.tk)\n    {\n    case tkDot:     // super.prop\n    case tkLBrack:  // super[foo]\n    case tkLParen:  // super(args)\n        break;\n\n    default:\n        Error(ERRInvalidSuper);\n        break;\n    }\n\n    if (!fAllowCall && (m_token.tk == tkLParen))\n    {\n        Error(ERRInvalidSuper); // new super() is not allowed\n    }\n    else if (this->m_parsingSuperRestrictionState == ParsingSuperRestrictionState_SuperCallAndPropertyAllowed)\n    {\n        // Any super access is good within a class constructor\n    }\n    else if (this->m_parsingSuperRestrictionState == ParsingSuperRestrictionState_SuperPropertyAllowed)\n    {\n        if (m_token.tk == tkLParen)\n        {\n            if ((this->m_grfscr & fscrEval) == fscrNil)\n            {\n                // Cannot call super within a class member\n                Error(ERRInvalidSuper);\n            }\n            else\n            {\n                Js::JavascriptFunction * caller = nullptr;\n                if (Js::JavascriptStackWalker::GetCaller(&caller, m_scriptContext))\n                {\n                    Js::FunctionBody * callerBody = caller->GetFunctionBody();\n                    Assert(callerBody);\n                    if (!callerBody->GetFunctionInfo()->GetAllowDirectSuper())\n                    {\n                        Error(ERRInvalidSuper);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        // Anything else is an error\n        Error(ERRInvalidSuper);\n    }\n\n    currentNodeFunc->sxFnc.SetHasSuperReference(TRUE);\n    CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Super, m_scriptContext);\n    return pnode;\n}\n\nvoid Parser::AppendToList(ParseNodePtr *node, ParseNodePtr nodeToAppend)\n{\n    Assert(nodeToAppend);\n    ParseNodePtr* lastPtr = node;\n    while ((*lastPtr) && (*lastPtr)->nop == knopList)\n    {\n        lastPtr = &(*lastPtr)->sxBin.pnode2;\n    }\n    auto last = (*lastPtr);\n    if (last)\n    {\n        *lastPtr = CreateBinNode(knopList, last, nodeToAppend, last->ichMin, nodeToAppend->ichLim);\n    }\n    else\n    {\n        *lastPtr = nodeToAppend;\n    }\n}\n\nParseNodePtr Parser::ConvertArrayToArrayPattern(ParseNodePtr pnode)\n{\n    Assert(pnode->nop == knopArray);\n    pnode->nop = knopArrayPattern;\n\n    ForEachItemRefInList(&pnode->sxArrLit.pnode1, [&](ParseNodePtr *itemRef) {\n        ParseNodePtr item = *itemRef;\n        if (item->nop == knopEllipsis)\n        {\n            itemRef = &item->sxUni.pnode1;\n            item = *itemRef;\n            if (!(item->nop == knopName\n                  || item->nop == knopDot\n                  || item->nop == knopIndex\n                  || item->nop == knopArray\n                  || item->nop == knopObject))\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n        }\n        else if (item->nop == knopAsg)\n        {\n            itemRef = &item->sxBin.pnode1;\n            item = *itemRef;\n        }\n\n        if (item->nop == knopArray)\n        {\n            ConvertArrayToArrayPattern(item);\n        }\n        else if (item->nop == knopObject)\n        {\n            *itemRef = ConvertObjectToObjectPattern(item);\n        }\n        else if (item->nop == knopName)\n        {\n            TrackAssignment<true>(item, nullptr);\n        }\n    });\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateParamPatternNode(ParseNodePtr pnode1)\n{\n    ParseNodePtr paramPatternNode = CreateNode(knopParamPattern, pnode1->ichMin, pnode1->ichLim);\n    paramPatternNode->sxParamPattern.pnode1 = pnode1;\n    paramPatternNode->sxParamPattern.pnodeNext = nullptr;\n    paramPatternNode->sxParamPattern.location = Js::Constants::NoRegister;\n    return paramPatternNode;\n}\n\nParseNodePtr Parser::ConvertObjectToObjectPattern(ParseNodePtr pnodeMemberList)\n{\n    charcount_t ichMin = m_pscan->IchMinTok();\n    charcount_t ichLim = m_pscan->IchLimTok();\n    ParseNodePtr pnodeMemberNodeList = nullptr;\n    if (pnodeMemberList != nullptr && pnodeMemberList->nop == knopObject)\n    {\n        ichMin = pnodeMemberList->ichMin;\n        ichLim = pnodeMemberList->ichLim;\n        pnodeMemberList = pnodeMemberList->sxUni.pnode1;\n    }\n\n    ForEachItemInList(pnodeMemberList, [&](ParseNodePtr item) {\n        ParseNodePtr memberNode = ConvertMemberToMemberPattern(item);\n        AppendToList(&pnodeMemberNodeList, memberNode);\n    });\n\n    return CreateUniNode(knopObjectPattern, pnodeMemberNodeList, ichMin, ichLim);\n}\n\nParseNodePtr Parser::GetRightSideNodeFromPattern(ParseNodePtr pnode)\n{\n    Assert(pnode != nullptr);\n    ParseNodePtr rightNode = nullptr;\n    OpCode op = pnode->nop;\n    if (op == knopObject)\n    {\n        rightNode = ConvertObjectToObjectPattern(pnode);\n    }\n    else if (op == knopArray)\n    {\n        rightNode = ConvertArrayToArrayPattern(pnode);\n    }\n    else\n    {\n        rightNode = pnode;\n        if (op == knopName)\n        {\n            TrackAssignment<true>(pnode, nullptr);\n        }\n    }\n\n    return rightNode;\n}\n\nParseNodePtr Parser::ConvertMemberToMemberPattern(ParseNodePtr pnodeMember)\n{\n    if (pnodeMember->nop == knopObjectPatternMember)\n    {\n        return pnodeMember;\n    }\n\n    Assert(pnodeMember->nop == knopMember || pnodeMember->nop == knopMemberShort);\n\n    ParseNodePtr rightNode = GetRightSideNodeFromPattern(pnodeMember->sxBin.pnode2);\n    ParseNodePtr resultNode = CreateBinNode(knopObjectPatternMember, pnodeMember->sxBin.pnode1, rightNode);\n    resultNode->ichMin = pnodeMember->ichMin;\n    resultNode->ichLim = pnodeMember->ichLim;\n    return resultNode;\n}\n\nParseNodePtr Parser::ConvertToPattern(ParseNodePtr pnode)\n{\n    if (pnode != nullptr)\n    {\n        if (pnode->nop == knopArray)\n        {\n            ConvertArrayToArrayPattern(pnode);\n        }\n        else if (pnode->nop == knopObject)\n        {\n            pnode = ConvertObjectToObjectPattern(pnode);\n        }\n    }\n    return pnode;\n}\n\n// This essentially be called for verifying the structure of the current tree with satisfying the destructuring grammar.\nvoid Parser::ParseDestructuredLiteralWithScopeSave(tokens declarationType,\n    bool isDecl,\n    bool topLevel,\n    DestructuringInitializerContext initializerContext/* = DIC_None*/,\n    bool allowIn /*= true*/)\n{\n    // We are going to parse the text again to validate the current grammar as Destructuring. Saving some scopes and\n    // AST related information before the validation parsing and later they will be restored.\n\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    ParseNodePtr pnodeDeferredFncSave = m_currentNodeDeferredFunc;\n    if (m_currentNodeDeferredFunc == nullptr)\n    {\n        m_currentNodeDeferredFunc = m_currentNodeFunc;\n    }\n    int32 *pAstSizeSave = m_pCurrentAstSize;\n    uint *pNestedCountSave = m_pnestedCount;\n    ParseNodePtr *ppnodeScopeSave = m_ppnodeScope;\n    ParseNodePtr *ppnodeExprScopeSave = m_ppnodeExprScope;\n\n    ParseNodePtr newTempScope = nullptr;\n    m_ppnodeScope = &newTempScope;\n\n    int32 newTempAstSize = 0;\n    m_pCurrentAstSize = &newTempAstSize;\n\n    uint newTempNestedCount = 0;\n    m_pnestedCount = &newTempNestedCount;\n\n    m_ppnodeExprScope = nullptr;\n\n    charcount_t funcInArraySave = m_funcInArray;\n    uint funcInArrayDepthSave = m_funcInArrayDepth;\n\n    // we need to reset this as we are going to parse the grammar again.\n    m_hasDeferredShorthandInitError = false;\n\n    ParseDestructuredLiteral<false>(declarationType, isDecl, topLevel, initializerContext, allowIn);\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_currentNodeDeferredFunc = pnodeDeferredFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n    m_pnestedCount = pNestedCountSave;\n    m_ppnodeScope = ppnodeScopeSave;\n    m_ppnodeExprScope = ppnodeExprScopeSave;\n    m_funcInArray = funcInArraySave;\n    m_funcInArrayDepth = funcInArrayDepthSave;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredLiteral(tokens declarationType,\n    bool isDecl,\n    bool topLevel/* = true*/,\n    DestructuringInitializerContext initializerContext/* = DIC_None*/,\n    bool allowIn/* = true*/,\n    BOOL *forInOfOkay/* = nullptr*/,\n    BOOL *nativeForOkay/* = nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    Assert(IsPossiblePatternStart());\n    if (m_token.tk == tkLCurly)\n    {\n        pnode = ParseDestructuredObjectLiteral<buildAST>(declarationType, isDecl, topLevel);\n    }\n    else\n    {\n        pnode = ParseDestructuredArrayLiteral<buildAST>(declarationType, isDecl, topLevel);\n    }\n\n    return ParseDestructuredInitializer<buildAST>(pnode, isDecl, topLevel, initializerContext, allowIn, forInOfOkay, nativeForOkay);\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredInitializer(ParseNodePtr lhsNode,\n    bool isDecl,\n    bool topLevel,\n    DestructuringInitializerContext initializerContext,\n    bool allowIn,\n    BOOL *forInOfOkay,\n    BOOL *nativeForOkay)\n{\n    m_pscan->Scan();\n    if (topLevel && nativeForOkay == nullptr)\n    {\n        if (initializerContext != DIC_ForceErrorOnInitializer && m_token.tk != tkAsg)\n        {\n            // e.g. var {x};\n            Error(ERRDestructInit);\n        }\n        else if (initializerContext == DIC_ForceErrorOnInitializer && m_token.tk == tkAsg)\n        {\n            // e.g. catch([x] = [0])\n            Error(ERRDestructNotInit);\n        }\n    }\n\n    if (m_token.tk != tkAsg || initializerContext == DIC_ShouldNotParseInitializer)\n    {\n        if (topLevel && nativeForOkay != nullptr)\n        {\n            // Native loop should have destructuring initializer\n            *nativeForOkay = FALSE;\n        }\n\n        return lhsNode;\n    }\n\n    if (forInOfOkay)\n    {\n        *forInOfOkay = FALSE;\n    }\n\n    m_pscan->Scan();\n\n\n    bool alreadyHasInitError = m_hasDeferredShorthandInitError;\n\n    ParseNodePtr pnodeDefault = ParseExpr<buildAST>(koplCma, nullptr, allowIn);\n\n    if (m_hasDeferredShorthandInitError && !alreadyHasInitError)\n    {\n        Error(ERRnoColon);\n    }\n\n    ParseNodePtr pnodeDestructAsg = nullptr;\n    if (buildAST)\n    {\n        Assert(lhsNode != nullptr);\n\n        pnodeDestructAsg = CreateNodeWithScanner<knopAsg>();\n        pnodeDestructAsg->sxBin.pnode1 = lhsNode;\n        pnodeDestructAsg->sxBin.pnode2 = pnodeDefault;\n        pnodeDestructAsg->ichMin = lhsNode->ichMin;\n        pnodeDestructAsg->ichLim = pnodeDefault->ichLim;\n    }\n    return pnodeDestructAsg;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredObjectLiteral(tokens declarationType, bool isDecl, bool topLevel/* = true*/)\n{\n    Assert(m_token.tk == tkLCurly);\n    charcount_t ichMin = m_pscan->IchMinTok();\n    m_pscan->Scan();\n\n    if (!isDecl)\n    {\n        declarationType = tkLCurly;\n    }\n    ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(nullptr/*pNameHint*/, nullptr/*pHintLength*/, declarationType);\n    Assert(m_token.tk == tkRCurly);\n\n    ParseNodePtr objectPatternNode = nullptr;\n    if (buildAST)\n    {\n        charcount_t ichLim = m_pscan->IchLimTok();\n        objectPatternNode = CreateUniNode(knopObjectPattern, pnodeMemberList, ichMin, ichLim);\n    }\n    return objectPatternNode;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredVarDecl(tokens declarationType, bool isDecl, bool *hasSeenRest, bool topLevel/* = true*/, bool allowEmptyExpression/* = true*/)\n{\n    ParseNodePtr pnodeElem = nullptr;\n    int parenCount = 0;\n    bool seenRest = false;\n\n    // Save the Block ID prior to the increments, so we can restore it back.\n    int originalCurrentBlockId = GetCurrentBlock()->sxBlock.blockId;\n\n    // Eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkLParen)\n        {\n            m_pscan->Scan();\n            ++parenCount;\n\n            // Match the block increment we do upon entering parenthetical expressions\n            // so that the block ID's will match on reparsing of parameters.\n            GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n        }\n    }\n\n    if (m_token.tk == tkEllipsis)\n    {\n        // As per ES 2015 : Rest can have left-hand-side-expression when on assignment expression, but under declaration only binding identifier is allowed\n        // But spec is going to change for this one to allow LHS-expression both on expression and declaration - so making that happen early.\n\n        seenRest = true;\n        m_pscan->Scan();\n\n        // Eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early.\n        if (!isDecl)\n        {\n            while (m_token.tk == tkLParen)\n            {\n                m_pscan->Scan();\n                ++parenCount;\n\n                // Match the block increment we do upon entering parenthetical expressions\n                // so that the block ID's will match on reparsing of parameters.\n                GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n            }\n        }\n\n        if (m_token.tk != tkID && m_token.tk != tkSUPER && m_token.tk != tkLCurly && m_token.tk != tkLBrack)\n        {\n            if (isDecl)\n            {\n                Error(ERRnoIdent);\n            }\n            else\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n        }\n    }\n\n    if (IsPossiblePatternStart())\n    {\n        // Go recursively\n        pnodeElem = ParseDestructuredLiteral<buildAST>(declarationType, isDecl, false /*topLevel*/, seenRest ? DIC_ShouldNotParseInitializer : DIC_None);\n        if (!isDecl)\n        {\n            BOOL fCanAssign;\n            IdentToken token;\n            // Look for postfix operator\n            pnodeElem = ParsePostfixOperators<buildAST>(pnodeElem, TRUE, FALSE, FALSE, &fCanAssign, &token);\n        }\n    }\n    else if (m_token.tk == tkSUPER || m_token.tk == tkID)\n    {\n        if (isDecl)\n        {\n            charcount_t ichMin = m_pscan->IchMinTok();\n            pnodeElem = ParseVariableDeclaration<buildAST>(declarationType, ichMin\n                ,/* fAllowIn */false, /* pfForInOk */nullptr, /* singleDefOnly */true, /* allowInit */!seenRest, false /*topLevelParse*/);\n\n        }\n        else\n        {\n            BOOL fCanAssign;\n            IdentToken token;\n            // We aren't declaring anything, so scan the ID reference manually.\n            pnodeElem = ParseTerm<buildAST>(/* fAllowCall */ m_token.tk != tkSUPER, nullptr /*pNameHint*/, nullptr /*pHintLength*/, nullptr /*pShortNameOffset*/, &token, false,\n                                                             &fCanAssign);\n\n            // In this destructuring case we can force error here as we cannot assign.\n\n            if (!fCanAssign)\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n\n            if (buildAST)\n            {\n                if (IsStrictMode() && pnodeElem != nullptr && pnodeElem->nop == knopName)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeElem->sxPid.pid);\n                }\n            }\n            else\n            {\n                if (IsStrictMode() && token.tk == tkID)\n                {\n                    CheckStrictModeEvalArgumentsUsage(token.pid);\n                }\n                token.tk = tkNone;\n            }\n        }\n    }\n    else if (!((m_token.tk == tkComma || m_token.tk == tkRBrack || m_token.tk == tkRCurly) && allowEmptyExpression))\n    {\n        if (m_token.IsOperator())\n        {\n            Error(ERRDestructNoOper);\n        }\n        Error(ERRDestructIDRef);\n    }\n\n    // Swallow RParens before a default expression, if any.\n    // We eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early. We need to do the same for right parentheses.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n            --parenCount;\n        }\n    }\n\n    if (hasSeenRest != nullptr)\n    {\n        *hasSeenRest = seenRest;\n    }\n\n    if (m_token.tk == tkAsg)\n    {\n        // Parse the initializer.\n        if (seenRest)\n        {\n            Error(ERRRestWithDefault);\n        }\n        m_pscan->Scan();\n\n        bool alreadyHasInitError = m_hasDeferredShorthandInitError;\n        ParseNodePtr pnodeInit = ParseExpr<buildAST>(koplCma);\n\n        if (m_hasDeferredShorthandInitError && !alreadyHasInitError)\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            pnodeElem = CreateBinNode(knopAsg, pnodeElem, pnodeInit);\n        }\n    }\n\n    if (buildAST && seenRest)\n    {\n        ParseNodePtr pnodeRest = CreateNodeWithScanner<knopEllipsis>();\n        pnodeRest->sxUni.pnode1 = pnodeElem;\n        pnodeElem = pnodeRest;\n    }\n\n    // We eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early. We need to do the same for right parentheses.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n            --parenCount;\n        }\n\n        // Restore the Block ID of the current block after the parsing of destructured variable declarations and initializers.\n        GetCurrentBlock()->sxBlock.blockId = originalCurrentBlockId;\n    }\n\n    if (!(m_token.tk == tkComma || m_token.tk == tkRBrack || m_token.tk == tkRCurly))\n    {\n        if (m_token.IsOperator())\n        {\n            Error(ERRDestructNoOper);\n        }\n        Error(ERRsyntax);\n    }\n\n    if (parenCount != 0)\n    {\n        Error(ERRnoRparen);\n    }\n    return pnodeElem;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredArrayLiteral(tokens declarationType, bool isDecl, bool topLevel)\n{\n    Assert(m_token.tk == tkLBrack);\n    charcount_t ichMin = m_pscan->IchMinTok();\n\n    m_pscan->Scan();\n\n    ParseNodePtr pnodeDestructArr = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    uint count = 0;\n    bool hasMissingValues = false;\n    bool seenRest = false;\n\n    if (m_token.tk != tkRBrack)\n    {\n        while (true)\n        {\n            ParseNodePtr pnodeElem = ParseDestructuredVarDecl<buildAST>(declarationType, isDecl, &seenRest, topLevel);\n            if (buildAST)\n            {\n                if (pnodeElem == nullptr && buildAST)\n                {\n                    pnodeElem = CreateNodeWithScanner<knopEmpty>();\n                    hasMissingValues = true;\n                }\n                AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeElem);\n            }\n            count++;\n\n            if (m_token.tk == tkRBrack)\n            {\n                break;\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                Error(ERRDestructNoOper);\n            }\n\n            if (seenRest) // Rest must be in the last position.\n            {\n                Error(ERRDestructRestLast);\n            }\n\n            m_pscan->Scan();\n\n            // break if we have the trailing comma as well, eg. [a,]\n            if (m_token.tk == tkRBrack)\n            {\n                break;\n            }\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeDestructArr = CreateNodeWithScanner<knopArrayPattern>();\n        pnodeDestructArr->sxArrLit.pnode1 = pnodeList;\n        pnodeDestructArr->sxArrLit.arrayOfTaggedInts = false;\n        pnodeDestructArr->sxArrLit.arrayOfInts = false;\n        pnodeDestructArr->sxArrLit.arrayOfNumbers = false;\n        pnodeDestructArr->sxArrLit.hasMissingValues = hasMissingValues;\n        pnodeDestructArr->sxArrLit.count = count;\n        pnodeDestructArr->sxArrLit.spreadCount = seenRest ? 1 : 0;\n        pnodeDestructArr->ichMin = ichMin;\n        pnodeDestructArr->ichLim = m_pscan->IchLimTok();\n\n        if (pnodeDestructArr->sxArrLit.pnode1)\n        {\n            this->CheckArguments(pnodeDestructArr->sxArrLit.pnode1);\n        }\n    }\n\n    return pnodeDestructArr;\n}\n\nvoid Parser::CaptureContext(ParseContext *parseContext) const\n{\n    parseContext->pszSrc = m_pscan->PchBase();\n    parseContext->length = this->m_originalLength;\n    parseContext->characterOffset = m_pscan->IchMinTok();\n    parseContext->offset = parseContext->characterOffset + m_pscan->m_cMultiUnits;\n    parseContext->grfscr = this->m_grfscr;\n    parseContext->lineNumber = m_pscan->LineCur();\n\n    parseContext->pnodeProg = this->m_currentNodeProg;\n    parseContext->fromExternal = m_pscan->IsFromExternalSource();\n    parseContext->strictMode = this->IsStrictMode();\n    parseContext->sourceContextInfo = this->m_sourceContextInfo;\n    parseContext->currentBlockInfo = this->m_currentBlockInfo;\n    parseContext->nextBlockId = this->m_nextBlockId;\n}\n\nvoid Parser::RestoreContext(ParseContext *const parseContext)\n{\n    m_sourceContextInfo = parseContext->sourceContextInfo;\n    m_currentBlockInfo = parseContext->currentBlockInfo;\n    m_nextBlockId = parseContext->nextBlockId;\n    m_grfscr = parseContext->grfscr;\n    m_length = parseContext->length;\n    m_pscan->SetText(parseContext->pszSrc, parseContext->offset, parseContext->length, parseContext->characterOffset, parseContext->grfscr, parseContext->lineNumber);\n    m_currentNodeProg = parseContext->pnodeProg;\n    m_fUseStrictMode = parseContext->strictMode;\n}\n\nclass ByteCodeGenerator;\n#if DBG_DUMP\n\n#define INDENT_SIZE 2\n\nvoid PrintPnodeListWIndent(ParseNode *pnode,int indentAmt);\nvoid PrintFormalsWIndent(ParseNode *pnode, int indentAmt);\n\n\nvoid Indent(int indentAmt) {\n    for (int i=0;i<indentAmt;i++) {\n        Output::Print(_u(\" \"));\n    }\n}\n\nvoid PrintBlockType(PnodeBlockType type)\n{\n    switch (type)\n    {\n    case Global:\n        Output::Print(_u(\"(Global)\"));\n        break;\n    case Function:\n        Output::Print(_u(\"(Function)\"));\n        break;\n    case Regular:\n        Output::Print(_u(\"(Regular)\"));\n        break;\n    case Parameter:\n        Output::Print(_u(\"(Parameter)\"));\n        break;\n    default:\n        Output::Print(_u(\"(unknown blocktype)\"));\n        break;\n    }\n}\n\nvoid PrintScopesWIndent(ParseNode *pnode,int indentAmt) {\n    ParseNode *scope = nullptr;\n    bool firstOnly = false;\n    switch(pnode->nop)\n    {\n    case knopProg:\n    case knopFncDecl: scope = pnode->sxFnc.pnodeScopes; break;\n    case knopBlock: scope = pnode->sxBlock.pnodeScopes; break;\n    case knopCatch: scope = pnode->sxCatch.pnodeScopes; break;\n    case knopWith: scope = pnode->sxWith.pnodeScopes; break;\n    case knopSwitch: scope = pnode->sxSwitch.pnodeBlock; firstOnly = true; break;\n    case knopFor: scope = pnode->sxFor.pnodeBlock; firstOnly = true; break;\n    case knopForIn: scope = pnode->sxForInOrForOf.pnodeBlock; firstOnly = true; break;\n    case knopForOf: scope = pnode->sxForInOrForOf.pnodeBlock; firstOnly = true; break;\n    }\n    if (scope) {\n        Output::Print(_u(\"[%4d, %4d): \"), scope->ichMin, scope->ichLim);\n        Indent(indentAmt);\n        Output::Print(_u(\"Scopes: \"));\n        ParseNode *next = nullptr;\n        ParseNode *syntheticBlock = nullptr;\n        while (scope) {\n            switch (scope->nop) {\n            case knopFncDecl: Output::Print(_u(\"knopFncDecl\")); next = scope->sxFnc.pnodeNext; break;\n            case knopBlock: Output::Print(_u(\"knopBlock\")); PrintBlockType(scope->sxBlock.blockType); next = scope->sxBlock.pnodeNext; break;\n            case knopCatch: Output::Print(_u(\"knopCatch\")); next = scope->sxCatch.pnodeNext; break;\n            case knopWith: Output::Print(_u(\"knopWith\")); next = scope->sxWith.pnodeNext; break;\n            default: Output::Print(_u(\"unknown\")); break;\n            }\n            if (firstOnly) {\n                next = nullptr;\n                syntheticBlock = scope;\n            }\n            if (scope->grfpn & fpnSyntheticNode) {\n                Output::Print(_u(\" synthetic\"));\n                if (scope->nop == knopBlock)\n                    syntheticBlock = scope;\n            }\n            Output::Print(_u(\" (%d-%d)\"), scope->ichMin, scope->ichLim);\n            if (next) Output::Print(_u(\", \"));\n            scope = next;\n        }\n        Output::Print(_u(\"\\n\"));\n        if (syntheticBlock || firstOnly) {\n            PrintScopesWIndent(syntheticBlock, indentAmt + INDENT_SIZE);\n        }\n    }\n}\n\nvoid PrintPnodeWIndent(ParseNode *pnode,int indentAmt) {\n    if (pnode==NULL)\n        return;\n\n    Output::Print(_u(\"[%4d, %4d): \"), pnode->ichMin, pnode->ichLim);\n    switch (pnode->nop) {\n        //PTNODE(knopName       , \"name\"        ,None    ,Pid  ,fnopLeaf)\n  case knopName:\n      Indent(indentAmt);\n      if (pnode->sxPid.pid!=NULL) {\n        Output::Print(_u(\"id: %s\\n\"),pnode->sxPid.pid->Psz());\n      }\n      else {\n        Output::Print(_u(\"name node\\n\"));\n      }\n      break;\n      //PTNODE(knopInt        , \"int const\"    ,None    ,Int  ,fnopLeaf|fnopConst)\n  case knopInt:\n      Indent(indentAmt);\n      Output::Print(_u(\"%d\\n\"),pnode->sxInt.lw);\n      break;\n      //PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n  case knopFlt:\n      Indent(indentAmt);\n      Output::Print(_u(\"%lf\\n\"),pnode->sxFlt.dbl);\n      break;\n      //PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopStr:\n      Indent(indentAmt);\n      Output::Print(_u(\"\\\"%s\\\"\\n\"),pnode->sxPid.pid->Psz());\n      break;\n      //PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopRegExp:\n      Indent(indentAmt);\n      Output::Print(_u(\"/%x/\\n\"),pnode->sxPid.regexPattern);\n      break;\n      //PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n  case knopThis:\n      Indent(indentAmt);\n      Output::Print(_u(\"this\\n\"));\n      break;\n      //PTNODE(knopSuper      , \"super\"       ,None    ,None ,fnopLeaf)\n  case knopSuper:\n      Indent(indentAmt);\n      Output::Print(_u(\"super\\n\"));\n      break;\n      //PTNODE(knopNewTarget  , \"new.target\"  ,None    ,None ,fnopLeaf)\n  case knopNewTarget:\n      Indent(indentAmt);\n      Output::Print(_u(\"new.target\\n\"));\n      break;\n      //PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n  case knopNull:\n      Indent(indentAmt);\n      Output::Print(_u(\"null\\n\"));\n      break;\n      //PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n  case knopFalse:\n      Indent(indentAmt);\n      Output::Print(_u(\"false\\n\"));\n      break;\n      //PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n  case knopTrue:\n      Indent(indentAmt);\n      Output::Print(_u(\"true\\n\"));\n      break;\n      //PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n  case knopEmpty:\n      Indent(indentAmt);\n      Output::Print(_u(\"empty\\n\"));\n      break;\n      // Unary operators.\n      //PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n  case knopNot:\n      Indent(indentAmt);\n      Output::Print(_u(\"~\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n  case knopNeg:\n      Indent(indentAmt);\n      Output::Print(_u(\"U-\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n  case knopPos:\n      Indent(indentAmt);\n      Output::Print(_u(\"U+\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n  case knopLogNot:\n      Indent(indentAmt);\n      Output::Print(_u(\"!\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni    , fnopUni)\n  case knopEllipsis:\n      Indent(indentAmt);\n      Output::Print(_u(\"...<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIncPost    , \"++ post\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n  case knopIncPost:\n      Indent(indentAmt);\n      Output::Print(_u(\"<expr>++\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDecPost    , \"-- post\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n  case knopDecPost:\n      Indent(indentAmt);\n      Output::Print(_u(\"<expr>--\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n  case knopIncPre:\n      Indent(indentAmt);\n      Output::Print(_u(\"++<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDecPre     , \"-- pre\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n  case knopDecPre:\n      Indent(indentAmt);\n      Output::Print(_u(\"--<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n  case knopTypeof:\n      Indent(indentAmt);\n      Output::Print(_u(\"typeof\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n  case knopVoid:\n      Indent(indentAmt);\n      Output::Print(_u(\"void\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDelete     , \"delete\"    ,None    ,Uni  ,fnopUni)\n  case knopDelete:\n      Indent(indentAmt);\n      Output::Print(_u(\"delete\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n\n  case knopArrayPattern:\n      Indent(indentAmt);\n      Output::Print(_u(\"Array Pattern\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n  case knopObjectPattern:\n      Indent(indentAmt);\n      Output::Print(_u(\"Object Pattern\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n  case knopArray:\n      Indent(indentAmt);\n      Output::Print(_u(\"Array Literal\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n  case knopObject:\n      Indent(indentAmt);\n      Output::Print(_u(\"Object Literal\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      // Binary and Ternary Operators\n      //PTNODE(knopAdd        , \"+\"            ,Add     ,Bin  ,fnopBin)\n  case knopAdd:\n      Indent(indentAmt);\n      Output::Print(_u(\"+\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopSub        , \"-\"            ,Sub     ,Bin  ,fnopBin)\n  case knopSub:\n      Indent(indentAmt);\n      Output::Print(_u(\"-\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopMul        , \"*\"            ,Mul     ,Bin  ,fnopBin)\n  case knopMul:\n      Indent(indentAmt);\n      Output::Print(_u(\"*\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDiv        , \"/\"            ,Div     ,Bin  ,fnopBin)\n  case knopExpo:\n      Indent(indentAmt);\n      Output::Print(_u(\"**\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2, indentAmt + INDENT_SIZE);\n      break;\n      //PTNODE(knopExpo        , \"**\"            ,Expo     ,Bin  ,fnopBin)\n\n  case knopDiv:\n      Indent(indentAmt);\n      Output::Print(_u(\"/\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopMod        , \"%\"            ,Mod     ,Bin  ,fnopBin)\n  case knopMod:\n      Indent(indentAmt);\n      Output::Print(_u(\"%\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopOr         , \"|\"            ,BitOr   ,Bin  ,fnopBin)\n  case knopOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"|\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopXor        , \"^\"            ,BitXor  ,Bin  ,fnopBin)\n  case knopXor:\n      Indent(indentAmt);\n      Output::Print(_u(\"^\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAnd        , \"&\"            ,BitAnd  ,Bin  ,fnopBin)\n  case knopAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEq         , \"==\"        ,EQ      ,Bin  ,fnopBin|fnopRel)\n  case knopEq:\n      Indent(indentAmt);\n      Output::Print(_u(\"==\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNe         , \"!=\"        ,NE      ,Bin  ,fnopBin|fnopRel)\n  case knopNe:\n      Indent(indentAmt);\n      Output::Print(_u(\"!=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLt         , \"<\"            ,LT      ,Bin  ,fnopBin|fnopRel)\n  case knopLt:\n      Indent(indentAmt);\n      Output::Print(_u(\"<\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLe         , \"<=\"        ,LE      ,Bin  ,fnopBin|fnopRel)\n  case knopLe:\n      Indent(indentAmt);\n      Output::Print(_u(\"<=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopGe         , \">=\"        ,GE      ,Bin  ,fnopBin|fnopRel)\n  case knopGe:\n      Indent(indentAmt);\n      Output::Print(_u(\">=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopGt         , \">\"            ,GT      ,Bin  ,fnopBin|fnopRel)\n  case knopGt:\n      Indent(indentAmt);\n      Output::Print(_u(\">\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopCall       , \"()\"        ,None    ,Bin  ,fnopBin)\n  case knopCall:\n      Indent(indentAmt);\n      Output::Print(_u(\"Call\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDot        , \".\"            ,None    ,Bin  ,fnopBin)\n  case knopDot:\n      Indent(indentAmt);\n      Output::Print(_u(\".\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsg:\n      Indent(indentAmt);\n      Output::Print(_u(\"=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopInstOf     , \"instanceof\",InstOf  ,Bin  ,fnopBin|fnopRel)\n  case knopInstOf:\n      Indent(indentAmt);\n      Output::Print(_u(\"instanceof\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIn         , \"in\"        ,In      ,Bin  ,fnopBin|fnopRel)\n  case knopIn:\n      Indent(indentAmt);\n      Output::Print(_u(\"in\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEqv        , \"===\"        ,Eqv     ,Bin  ,fnopBin|fnopRel)\n  case knopEqv:\n      Indent(indentAmt);\n      Output::Print(_u(\"===\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNEqv       , \"!==\"        ,NEqv    ,Bin  ,fnopBin|fnopRel)\n  case knopNEqv:\n      Indent(indentAmt);\n      Output::Print(_u(\"!==\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopComma      , \",\"            ,None    ,Bin  ,fnopBin)\n  case knopComma:\n      Indent(indentAmt);\n      Output::Print(_u(\",\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n  case knopLogOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"||\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n  case knopLogAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&&\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLsh        , \"<<\"        ,Lsh     ,Bin  ,fnopBin)\n  case knopLsh:\n      Indent(indentAmt);\n      Output::Print(_u(\"<<\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopRsh        , \">>\"        ,Rsh     ,Bin  ,fnopBin)\n  case knopRsh:\n      Indent(indentAmt);\n      Output::Print(_u(\">>\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopRs2        , \">>>\"        ,Rs2     ,Bin  ,fnopBin)\n  case knopRs2:\n      Indent(indentAmt);\n      Output::Print(_u(\">>>\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNew        , \"new\"        ,None    ,Bin  ,fnopBin)\n  case knopNew:\n      Indent(indentAmt);\n      Output::Print(_u(\"new\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIndex      , \"[]\"        ,None    ,Bin  ,fnopBin)\n  case knopIndex:\n      Indent(indentAmt);\n      Output::Print(_u(\"[]\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n  case knopQmark:\n      Indent(indentAmt);\n      Output::Print(_u(\"?:\\n\"));\n      PrintPnodeWIndent(pnode->sxTri.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxTri.pnode2,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxTri.pnode3,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgAdd     , \"+=\"        ,Add     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAdd:\n      Indent(indentAmt);\n      Output::Print(_u(\"+=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgSub     , \"-=\"        ,Sub     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgSub:\n      Indent(indentAmt);\n      Output::Print(_u(\"-=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgMul     , \"*=\"        ,Mul     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMul:\n      Indent(indentAmt);\n      Output::Print(_u(\"*=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgDiv     , \"/=\"        ,Div     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgExpo:\n      Indent(indentAmt);\n      Output::Print(_u(\"**=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2, indentAmt + INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgExpo     , \"**=\"       ,Expo     ,Bin  ,fnopBin|fnopAsg)\n\n  case knopAsgDiv:\n      Indent(indentAmt);\n      Output::Print(_u(\"/=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgMod     , \"%=\"        ,Mod     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMod:\n      Indent(indentAmt);\n      Output::Print(_u(\"%=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgAnd     , \"&=\"        ,BitAnd  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgXor     , \"^=\"        ,BitXor  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgXor:\n      Indent(indentAmt);\n      Output::Print(_u(\"^=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgOr      , \"|=\"        ,BitOr   ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"|=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgLsh     , \"<<=\"        ,Lsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgLsh:\n      Indent(indentAmt);\n      Output::Print(_u(\"<<=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgRsh     , \">>=\"        ,Rsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRsh:\n      Indent(indentAmt);\n      Output::Print(_u(\">>=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgRs2     , \">>>=\"        ,Rs2     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRs2:\n      Indent(indentAmt);\n      Output::Print(_u(\">>>=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n\n  case knopComputedName:\n      Indent(indentAmt);\n      Output::Print(_u(\"ComputedProperty\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n      //PTNODE(knopMember     , \":\"            ,None    ,Bin  ,fnopBin)\n  case knopMember:\n  case knopMemberShort:\n  case knopObjectPatternMember:\n      Indent(indentAmt);\n      Output::Print(_u(\":\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      // General nodes.\n      //PTNODE(knopList       , \"<list>\"    ,None    ,Bin  ,fnopNone)\n  case knopList:\n      Indent(indentAmt);\n      Output::Print(_u(\"List\\n\"));\n      PrintPnodeListWIndent(pnode,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n  case knopVarDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"var %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n  case knopConstDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"const %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n  case knopLetDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"let %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n  case knopFncDecl:\n      Indent(indentAmt);\n      if (pnode->sxFnc.pid!=NULL)\n      {\n          Output::Print(_u(\"fn decl %d nested %d name %s (%d-%d)\\n\"),pnode->sxFnc.IsDeclaration(),pnode->sxFnc.IsNested(),\n              pnode->sxFnc.pid->Psz(), pnode->ichMin, pnode->ichLim);\n      }\n      else\n      {\n          Output::Print(_u(\"fn decl %d nested %d anonymous (%d-%d)\\n\"),pnode->sxFnc.IsDeclaration(),pnode->sxFnc.IsNested(),pnode->ichMin,pnode->ichLim);\n      }\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintFormalsWIndent(pnode->sxFnc.pnodeParams, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFnc.pnodeRest, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFnc.pnodeBody, indentAmt + INDENT_SIZE);\n      if (pnode->sxFnc.pnodeBody == nullptr)\n      {\n          Output::Print(_u(\"[%4d, %4d): \"), pnode->ichMin, pnode->ichLim);\n          Indent(indentAmt + INDENT_SIZE);\n          Output::Print(_u(\"<parse deferred body>\\n\"));\n      }\n      break;\n      //PTNODE(knopProg       , \"program\"    ,None    ,Fnc  ,fnopNone)\n  case knopProg:\n      Indent(indentAmt);\n      Output::Print(_u(\"program\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxFnc.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEndCode    , \"<endcode>\"    ,None    ,None ,fnopNone)\n  case knopEndCode:\n      Indent(indentAmt);\n      Output::Print(_u(\"<endcode>\\n\"));\n      break;\n      //PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n  case knopDebugger:\n      Indent(indentAmt);\n      Output::Print(_u(\"<debugger>\\n\"));\n      break;\n      //PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n  case knopFor:\n      Indent(indentAmt);\n      Output::Print(_u(\"for\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeInit,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeIncr,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n  case knopIf:\n      Indent(indentAmt);\n      Output::Print(_u(\"if\\n\"));\n      PrintPnodeWIndent(pnode->sxIf.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxIf.pnodeTrue,indentAmt+INDENT_SIZE);\n      if (pnode->sxIf.pnodeFalse!=NULL)\n          PrintPnodeWIndent(pnode->sxIf.pnodeFalse,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopWhile      , \"while\"        ,None    ,While,fnopBreak|fnopContinue)\n  case knopWhile:\n      Indent(indentAmt);\n      Output::Print(_u(\"while\\n\"));\n      PrintPnodeWIndent(pnode->sxWhile.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWhile.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n  case knopDoWhile:\n      Indent(indentAmt);\n      Output::Print(_u(\"do\\n\"));\n      PrintPnodeWIndent(pnode->sxWhile.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWhile.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n  case knopForIn:\n      Indent(indentAmt);\n      Output::Print(_u(\"forIn\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeLval,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n  case knopForOf:\n      Indent(indentAmt);\n      Output::Print(_u(\"forOf\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeLval,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n  case knopReturn:\n      Indent(indentAmt);\n      Output::Print(_u(\"return\\n\"));\n      if (pnode->sxReturn.pnodeExpr!=NULL)\n          PrintPnodeWIndent(pnode->sxReturn.pnodeExpr,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n  case knopBlock:\n      Indent(indentAmt);\n      Output::Print(_u(\"block \"));\n      if (pnode->grfpn & fpnSyntheticNode)\n          Output::Print(_u(\"synthetic \"));\n      PrintBlockType(pnode->sxBlock.blockType);\n      Output::Print(_u(\"(%d-%d)\\n\"),pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      if (pnode->sxBlock.pnodeStmt!=NULL)\n          PrintPnodeWIndent(pnode->sxBlock.pnodeStmt,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n  case knopWith:\n      Indent(indentAmt);\n      Output::Print(_u(\"with (%d-%d)\\n\"), pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWith.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWith.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n  case knopBreak:\n      Indent(indentAmt);\n      Output::Print(_u(\"break\\n\"));\n      // TODO: some representation of target\n      break;\n      //PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n  case knopContinue:\n      Indent(indentAmt);\n      Output::Print(_u(\"continue\\n\"));\n      // TODO: some representation of target\n      break;\n      //PTNODE(knopLabel      , \"label\"        ,None    ,Label,fnopNone)\n  case knopLabel:\n      Indent(indentAmt);\n      Output::Print(_u(\"label %s\"),pnode->sxLabel.pid->Psz());\n      // TODO: print labeled statement\n      break;\n      //PTNODE(knopSwitch     , \"switch\"    ,None    ,Switch,fnopBreak)\n  case knopSwitch:\n      Indent(indentAmt);\n      Output::Print(_u(\"switch\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      for (ParseNode *pnodeT = pnode->sxSwitch.pnodeCases; NULL != pnodeT;pnodeT = pnodeT->sxCase.pnodeNext) {\n          PrintPnodeWIndent(pnodeT,indentAmt+2);\n      }\n      break;\n      //PTNODE(knopCase       , \"case\"        ,None    ,Case ,fnopNone)\n  case knopCase:\n      Indent(indentAmt);\n      Output::Print(_u(\"case\\n\"));\n      PrintPnodeWIndent(pnode->sxCase.pnodeExpr,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCase.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTryFinally,\"try-finally\",None,TryFinally,fnopCleanup)\n  case knopTryFinally:\n      PrintPnodeWIndent(pnode->sxTryFinally.pnodeTry,indentAmt);\n      PrintPnodeWIndent(pnode->sxTryFinally.pnodeFinally,indentAmt);\n      break;\n  case knopFinally:\n      Indent(indentAmt);\n      Output::Print(_u(\"finally\\n\"));\n      PrintPnodeWIndent(pnode->sxFinally.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopCatch      , \"catch\"     ,None    ,Catch,fnopNone)\n  case knopCatch:\n      Indent(indentAmt);\n      Output::Print(_u(\"catch (%d-%d)\\n\"), pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCatch.pnodeParam,indentAmt+INDENT_SIZE);\n//      if (pnode->sxCatch.pnodeGuard!=NULL)\n//          PrintPnodeWIndent(pnode->sxCatch.pnodeGuard,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCatch.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTryCatch      , \"try-catch\" ,None    ,TryCatch  ,fnopCleanup)\n  case knopTryCatch:\n      PrintPnodeWIndent(pnode->sxTryCatch.pnodeTry,indentAmt);\n      PrintPnodeWIndent(pnode->sxTryCatch.pnodeCatch,indentAmt);\n      break;\n      //PTNODE(knopTry        , \"try\"       ,None    ,Try  ,fnopCleanup)\n  case knopTry:\n      Indent(indentAmt);\n      Output::Print(_u(\"try\\n\"));\n      PrintPnodeWIndent(pnode->sxTry.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopThrow      , \"throw\"     ,None    ,Uni  ,fnopNone)\n  case knopThrow:\n      Indent(indentAmt);\n      Output::Print(_u(\"throw\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopClassDecl, \"classDecl\", None , Class, fnopLeaf)\n  case knopClassDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"class %s\"), pnode->sxClass.pnodeName->sxVar.pid->Psz());\n      if (pnode->sxClass.pnodeExtends != nullptr)\n      {\n          Output::Print(_u(\" extends \"));\n          PrintPnodeWIndent(pnode->sxClass.pnodeExtends, 0);\n      }\n      else {\n          Output::Print(_u(\"\\n\"));\n      }\n\n      PrintPnodeWIndent(pnode->sxClass.pnodeConstructor,   indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxClass.pnodeMembers,       indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxClass.pnodeStaticMembers, indentAmt + INDENT_SIZE);\n      break;\n  case knopStrTemplate:\n      Indent(indentAmt);\n      Output::Print(_u(\"string template\\n\"));\n      PrintPnodeListWIndent(pnode->sxStrTemplate.pnodeSubstitutionExpressions, indentAmt + INDENT_SIZE);\n      break;\n  case knopYieldStar:\n      Indent(indentAmt);\n      Output::Print(_u(\"yield*\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopYield:\n  case knopYieldLeaf:\n      Indent(indentAmt);\n      Output::Print(_u(\"yield\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopAwait:\n      Indent(indentAmt);\n      Output::Print(_u(\"await\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopExportDefault:\n      Indent(indentAmt);\n      Output::Print(_u(\"export default\\n\"));\n      PrintPnodeListWIndent(pnode->sxExportDefault.pnodeExpr, indentAmt + INDENT_SIZE);\n      break;\n  default:\n      Output::Print(_u(\"unhandled pnode op %d\\n\"),pnode->nop);\n      break;\n    }\n}\n\nvoid PrintPnodeListWIndent(ParseNode *pnode,int indentAmt) {\n    if (pnode!=NULL) {\n        while(pnode->nop==knopList) {\n            PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt);\n            pnode = pnode->sxBin.pnode2;\n        }\n        PrintPnodeWIndent(pnode,indentAmt);\n    }\n}\n\nvoid PrintFormalsWIndent(ParseNode *pnodeArgs, int indentAmt)\n{\n    for (ParseNode *pnode = pnodeArgs; pnode != nullptr; pnode = pnode->GetFormalNext())\n    {\n        PrintPnodeWIndent(pnode->nop == knopParamPattern ? pnode->sxParamPattern.pnode1 : pnode, indentAmt);\n    }\n}\n\nvoid PrintPnode(ParseNode *pnode) {\n    PrintPnodeWIndent(pnode,0);\n}\n\nvoid ParseNode::Dump()\n{\n    switch(nop)\n    {\n    case knopFncDecl:\n    case knopProg:\n        LPCOLESTR name = Js::Constants::AnonymousFunction;\n        if(this->sxFnc.pnodeName)\n        {\n            name = this->sxFnc.pnodeName->sxVar.pid->Psz();\n        }\n\n        Output::Print(_u(\"%s (%d) [%d, %d]:\\n\"), name, this->sxFnc.functionId, this->sxFnc.lineNumber, this->sxFnc.columnNumber);\n        Output::Print(_u(\"hasArguments: %s callsEval:%s childCallsEval:%s HasReferenceableBuiltInArguments:%s ArgumentsObjectEscapes:%s HasWith:%s HasThis:%s HasOnlyThis:%s \\n\"),\n            IsTrueOrFalse(this->sxFnc.HasHeapArguments()),\n            IsTrueOrFalse(this->sxFnc.CallsEval()),\n            IsTrueOrFalse(this->sxFnc.ChildCallsEval()),\n            IsTrueOrFalse(this->sxFnc.HasReferenceableBuiltInArguments()),\n            IsTrueOrFalse(this->sxFnc.GetArgumentsObjectEscapes()),\n            IsTrueOrFalse(this->sxFnc.HasWithStmt()),\n            IsTrueOrFalse(this->sxFnc.HasThisStmt()),\n            IsTrueOrFalse(this->sxFnc.HasOnlyThisStmts()));\n        if(this->sxFnc.funcInfo)\n        {\n            this->sxFnc.funcInfo->Dump();\n        }\n        break;\n    }\n}\n#endif\n\nDeferredFunctionStub * BuildDeferredStubTree(ParseNode *pnodeFnc, Recycler *recycler)\n{\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    uint nestedCount = pnodeFnc->sxFnc.nestedCount;\n    if (nestedCount == 0)\n    {\n        return nullptr;\n    }\n\n    if (pnodeFnc->sxFnc.deferredStub)\n    {\n        return pnodeFnc->sxFnc.deferredStub;\n    }\n\n    DeferredFunctionStub *deferredStubs = RecyclerNewArray(recycler, DeferredFunctionStub, nestedCount);\n    uint i = 0;\n\n    ParseNode *pnodeBlock = pnodeFnc->sxFnc.pnodeBodyScope;\n    Assert(pnodeBlock != nullptr\n        && pnodeBlock->nop == knopBlock\n        && (pnodeBlock->sxBlock.blockType == PnodeBlockType::Function\n            || pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter));\n\n    for (ParseNode *pnodeChild = pnodeBlock->sxBlock.pnodeScopes; pnodeChild != nullptr;)\n    {\n\n        if (pnodeChild->nop != knopFncDecl)\n        {\n            // We only expect to find a function body block in a parameter scope block.\n            Assert(pnodeChild->nop == knopBlock\n                && (pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter\n                    || pnodeChild->sxBlock.blockType == PnodeBlockType::Function));\n            pnodeChild = pnodeChild->sxBlock.pnodeNext;\n            continue;\n        }\n        AssertOrFailFast(i < nestedCount);\n\n        if (pnodeChild->sxFnc.pnodeBody != nullptr)\n        {\n            // Anomalous case of a non-deferred function nested within a deferred one.\n            // Work around by discarding the stub tree.\n            return nullptr;\n        }\n\n        if (pnodeChild->sxFnc.IsGeneratedDefault())\n        {\n            ++i;\n            pnodeChild = pnodeChild->sxFnc.pnodeNext;\n            continue;\n        }\n\n        AnalysisAssertOrFailFast(i < nestedCount);\n\n        deferredStubs[i].fncFlags = pnodeChild->sxFnc.fncFlags;\n        deferredStubs[i].nestedCount = pnodeChild->sxFnc.nestedCount;\n        deferredStubs[i].restorePoint = *pnodeChild->sxFnc.pRestorePoint;\n        deferredStubs[i].deferredStubs = BuildDeferredStubTree(pnodeChild, recycler);\n        deferredStubs[i].ichMin = pnodeChild->ichMin;\n        ++i;\n        pnodeChild = pnodeChild->sxFnc.pnodeNext;\n    }\n\n    return deferredStubs;\n}\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n#include \"RuntimeByteCodePch.h\"\n#include \"FormalsUtil.h\"\n#include \"Language/AsmJs.h\"\n\nvoid EmitReference(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitAssignment(ParseNode *asgnNode, ParseNode *lhs, Js::RegSlot rhsLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitLoad(ParseNode *rhs, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitCall(ParseNode* pnode, Js::RegSlot rhsLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, BOOL fReturnValue, BOOL fEvaluateComponents, BOOL fHasNewTarget, Js::RegSlot overrideThisLocation = Js::Constants::NoRegister);\nvoid EmitSuperFieldPatch(FuncInfo* funcInfo, ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator);\n\nvoid EmitUseBeforeDeclaration(Symbol *sym, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitUseBeforeDeclarationRuntimeError(ByteCodeGenerator *byteCodeGenerator, Js::RegSlot location);\nvoid VisitClearTmpRegs(ParseNode * pnode, ByteCodeGenerator * byteCodeGenerator, FuncInfo * funcInfo);\n\nbool CallTargetIsArray(ParseNode *pnode)\n{\n    return pnode->nop == knopName && pnode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::Array;\n}\n\n#define STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \\\nif ((isTopLevel)) \\\n{ \\\n    byteCodeGenerator->StartStatement(pnode); \\\n}\n\n#define ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \\\nif ((isTopLevel)) \\\n{ \\\n    byteCodeGenerator->EndStatement(pnode); \\\n}\n\nBOOL MayHaveSideEffectOnNode(ParseNode *pnode, ParseNode *pnodeSE)\n{\n    // Try to determine whether pnodeSE may kill the named var represented by pnode.\n\n    if (pnode->nop == knopComputedName)\n    {\n        pnode = pnode->sxUni.pnode1;\n    }\n\n    if (pnode->nop != knopName)\n    {\n        // Only investigating named vars here.\n        return false;\n    }\n\n    uint fnop = ParseNode::Grfnop(pnodeSE->nop);\n    if (fnop & fnopLeaf)\n    {\n        // pnodeSE is a leaf and can't kill anything.\n        return false;\n    }\n\n    if (fnop & fnopAsg)\n    {\n        // pnodeSE is an assignment (=, ++, +=, etc.)\n        // Trying to examine the LHS of pnodeSE caused small perf regressions,\n        // maybe because of code layout or some other subtle effect.\n        return true;\n    }\n\n    if (fnop & fnopUni)\n    {\n        // pnodeSE is a unary op, so recurse to the source (if present - e.g., [] may have no opnd).\n        if (pnodeSE->nop == knopTempRef)\n        {\n            return false;\n        }\n        else\n        {\n            return pnodeSE->sxUni.pnode1 && MayHaveSideEffectOnNode(pnode, pnodeSE->sxUni.pnode1);\n        }\n    }\n    else if (fnop & fnopBin)\n    {\n        // pnodeSE is a binary (or ternary) op, so recurse to the sources (if present).\n        if (pnodeSE->nop == knopQmark)\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode1) ||\n                MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode2) ||\n                MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode3);\n        }\n        else if (pnodeSE->nop == knopCall || pnodeSE->nop == knopNew)\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxCall.pnodeTarget) ||\n                (pnodeSE->sxCall.pnodeArgs && MayHaveSideEffectOnNode(pnode, pnodeSE->sxCall.pnodeArgs));\n        }\n        else\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxBin.pnode1) ||\n                (pnodeSE->sxBin.pnode2 && MayHaveSideEffectOnNode(pnode, pnodeSE->sxBin.pnode2));\n        }\n    }\n    else if (pnodeSE->nop == knopList)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nbool IsCallOfConstants(ParseNode *pnode);\nbool BlockHasOwnScope(ParseNode* pnodeBlock, ByteCodeGenerator *byteCodeGenerator);\nbool CreateNativeArrays(ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\n\nbool IsArguments(ParseNode *pnode)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return pnode->sxPid.sym && pnode->sxPid.sym->GetIsArguments();\n\n        case knopCall:\n        case knopNew:\n            if (IsArguments(pnode->sxCall.pnodeTarget))\n            {\n                return true;\n            }\n\n            if (pnode->sxCall.pnodeArgs)\n            {\n                ParseNode *pnodeArg = pnode->sxCall.pnodeArgs;\n                while (pnodeArg->nop == knopList)\n                {\n                    if (IsArguments(pnodeArg->sxBin.pnode1))\n                        return true;\n\n                    pnodeArg = pnodeArg->sxBin.pnode2;\n                }\n\n                pnode = pnodeArg;\n                break;\n            }\n\n            return false;\n\n        case knopArray:\n            if (pnode->sxArrLit.arrayOfNumbers || pnode->sxArrLit.count == 0)\n            {\n                return false;\n            }\n\n            pnode = pnode->sxUni.pnode1;\n            break;\n\n        case knopQmark:\n            if (IsArguments(pnode->sxTri.pnode1) || IsArguments(pnode->sxTri.pnode2))\n            {\n                return true;\n            }\n\n            pnode = pnode->sxTri.pnode3;\n            break;\n\n            //\n            // Cases where we don't check for \"arguments\" yet.\n            // Assume that they might have it. Disable the optimization is such scenarios\n            //\n        case knopList:\n        case knopObject:\n        case knopVarDecl:\n        case knopConstDecl:\n        case knopLetDecl:\n        case knopFncDecl:\n        case knopClassDecl:\n        case knopFor:\n        case knopIf:\n        case knopDoWhile:\n        case knopWhile:\n        case knopForIn:\n        case knopForOf:\n        case knopReturn:\n        case knopBlock:\n        case knopBreak:\n        case knopContinue:\n        case knopLabel:\n        case knopTypeof:\n        case knopThrow:\n        case knopWith:\n        case knopFinally:\n        case knopTry:\n        case knopTryCatch:\n        case knopTryFinally:\n        case knopArrayPattern:\n        case knopObjectPattern:\n        case knopParamPattern:\n            return true;\n\n        default:\n        {\n            uint flags = ParseNode::Grfnop(pnode->nop);\n            if (flags&fnopUni)\n            {\n                Assert(pnode->sxUni.pnode1);\n\n                pnode = pnode->sxUni.pnode1;\n                break;\n            }\n            else if (flags&fnopBin)\n            {\n                Assert(pnode->sxBin.pnode1 && pnode->sxBin.pnode2);\n\n                if (IsArguments(pnode->sxBin.pnode1))\n                {\n                    return true;\n                }\n\n                pnode = pnode->sxBin.pnode2;\n                break;\n            }\n\n            return false;\n        }\n\n        }\n    }\n}\n\nbool ApplyEnclosesArgs(ParseNode* fncDecl, ByteCodeGenerator* byteCodeGenerator);\nvoid Emit(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue, bool isConstructorCall = false, ParseNode *bindPnode = nullptr, bool isTopLevel = false);\nvoid EmitComputedFunctionNameVar(ParseNode *nameNode, ParseNode *exprNode, ByteCodeGenerator *byteCodeGenerator);\nvoid EmitBinaryOpnds(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nbool IsExpressionStatement(ParseNode* stmt, const Js::ScriptContext *const scriptContext);\nvoid EmitInvoke(Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitInvoke(Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, Js::RegSlot arg1Location);\n\nstatic const Js::OpCode nopToOp[knopLim] =\n{\n#define OP(x) Br##x##_A\n#define PTNODE(nop,sn,pc,nk,grfnop,json) Js::OpCode::pc,\n#include \"ptlist.h\"\n};\nstatic const Js::OpCode nopToCMOp[knopLim] =\n{\n#define OP(x) Cm##x##_A\n#define PTNODE(nop,sn,pc,nk,grfnop,json) Js::OpCode::pc,\n#include \"ptlist.h\"\n};\n\nJs::OpCode ByteCodeGenerator::ToChkUndeclOp(Js::OpCode op) const\n{\n    switch (op)\n    {\n    case Js::OpCode::StLocalSlot:\n        return Js::OpCode::StLocalSlotChkUndecl;\n\n    case Js::OpCode::StInnerSlot:\n        return Js::OpCode::StInnerSlotChkUndecl;\n\n    case Js::OpCode::StEnvSlot:\n        return Js::OpCode::StEnvSlotChkUndecl;\n\n    case Js::OpCode::StObjSlot:\n        return Js::OpCode::StObjSlotChkUndecl;\n\n    case Js::OpCode::StLocalObjSlot:\n        return Js::OpCode::StLocalObjSlotChkUndecl;\n\n    case Js::OpCode::StInnerObjSlot:\n        return Js::OpCode::StInnerObjSlotChkUndecl;\n\n    case Js::OpCode::StEnvObjSlot:\n        return Js::OpCode::StEnvObjSlotChkUndecl;\n\n    default:\n        AssertMsg(false, \"Unknown opcode for chk undecl mapping\");\n        return Js::OpCode::InvalidOpCode;\n    }\n}\n\n// Tracks a register slot let/const property for the passed in debugger block/catch scope.\n// debuggerScope         - The scope to add the variable to.\n// symbol                - The symbol that represents the register property.\n// funcInfo              - The function info used to store the property into the tracked debugger register slot list.\n// flags                 - The flags to assign to the property.\n// isFunctionDeclaration - Whether or not the register is a function declaration, which requires that its byte code offset be updated immediately.\nvoid ByteCodeGenerator::TrackRegisterPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol *symbol,\n    FuncInfo *funcInfo,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    Assert(debuggerScope);\n    Assert(symbol);\n    Assert(funcInfo);\n\n    Js::RegSlot location = symbol->GetLocation();\n\n    Js::DebuggerScope *correctDebuggerScope = debuggerScope;\n    if (debuggerScope->scopeType != Js::DiagExtraScopesType::DiagBlockScopeDirect && debuggerScope->scopeType != Js::DiagExtraScopesType::DiagCatchScopeDirect)\n    {\n        // We have to get the appropriate scope and add property over there.\n        // Make sure the scope is created whether we're in debug mode or not, because we\n        // need the empty scopes present during reparsing for debug mode.\n        correctDebuggerScope = debuggerScope->GetSiblingScope(location, Writer()->GetFunctionWrite());\n    }\n\n    if (this->ShouldTrackDebuggerMetadata() && !symbol->GetIsTrackedForDebugger())\n    {\n        // Only track the property if we're in debug mode since it's only needed by the debugger.\n        Js::PropertyId propertyId = symbol->EnsurePosition(this);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            correctDebuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ true,\n            flags,\n            isFunctionDeclaration);\n\n        Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n        byteCodeFunction->InsertSymbolToRegSlotList(location, propertyId, funcInfo->varRegsCount);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\nvoid ByteCodeGenerator::TrackActivationObjectPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol *symbol,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    Assert(debuggerScope);\n    Assert(symbol);\n\n    // Only need to track activation object properties in debug mode.\n    if (ShouldTrackDebuggerMetadata() && !symbol->GetIsTrackedForDebugger())\n    {\n        Js::RegSlot location = symbol->GetLocation();\n        Js::PropertyId propertyId = symbol->EnsurePosition(this);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            debuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ false,\n            flags,\n            isFunctionDeclaration);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\nvoid ByteCodeGenerator::TrackSlotArrayPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol* symbol,\n    Js::PropertyId propertyId,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    // Note: Slot array properties are tracked even in non-debug mode in order to support slot array serialization\n    // of let/const variables between non-debug and debug mode (for example, when a slot array var escapes and is retrieved\n    // after a debugger attach or for WWA apps).  They are also needed for heap enumeration.\n    Assert(debuggerScope);\n    Assert(symbol);\n\n    if (!symbol->GetIsTrackedForDebugger())\n    {\n        Js::RegSlot location = symbol->GetScopeSlot();\n        Assert(location != Js::Constants::NoRegister);\n        Assert(propertyId != Js::Constants::NoProperty);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            debuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ false,\n            flags,\n            isFunctionDeclaration);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\n// Tracks a function declaration inside a block scope for the debugger metadata's current scope (let binding).\nvoid ByteCodeGenerator::TrackFunctionDeclarationPropertyForDebugger(Symbol *functionDeclarationSymbol, FuncInfo *funcInfoParent)\n{\n    Assert(functionDeclarationSymbol);\n    Assert(funcInfoParent);\n    AssertMsg(functionDeclarationSymbol->GetIsBlockVar(), \"We should only track inner function let bindings for the debugger.\");\n\n    // Note: we don't have to check symbol->GetIsTrackedForDebugger, as we are not doing actual work here,\n    //       which is done in other Track* functions that we call.\n\n    if (functionDeclarationSymbol->IsInSlot(funcInfoParent))\n    {\n        if (functionDeclarationSymbol->GetScope()->GetIsObject())\n        {\n            this->TrackActivationObjectPropertyForDebugger(\n                this->Writer()->GetCurrentDebuggerScope(),\n                functionDeclarationSymbol,\n                Js::DebuggerScopePropertyFlags_None,\n                true /*isFunctionDeclaration*/);\n        }\n        else\n        {\n            // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n            // Note that slot array inner function bindings are tracked even in non-debug mode in order\n            // to keep the lifetime of the closure binding that could escape around for heap enumeration.\n            functionDeclarationSymbol->EnsureScopeSlot(funcInfoParent);\n            functionDeclarationSymbol->EnsurePosition(this);\n            this->TrackSlotArrayPropertyForDebugger(\n                this->Writer()->GetCurrentDebuggerScope(),\n                functionDeclarationSymbol,\n                functionDeclarationSymbol->GetPosition(),\n                Js::DebuggerScopePropertyFlags_None,\n                true /*isFunctionDeclaration*/);\n        }\n    }\n    else\n    {\n        this->TrackRegisterPropertyForDebugger(\n            this->Writer()->GetCurrentDebuggerScope(),\n            functionDeclarationSymbol,\n            funcInfoParent,\n            Js::DebuggerScopePropertyFlags_None,\n            true /*isFunctionDeclaration*/);\n    }\n}\n\n// Updates the byte code offset of the property with the passed in location and ID.\n// Used to track let/const variables that are in the dead zone debugger side.\n// location                 - The activation object, scope slot index, or register location for the property.\n// propertyId               - The ID of the property to update.\n// shouldConsumeRegister    - Whether or not the a register should be consumed (used for reg slot locations).\nvoid ByteCodeGenerator::UpdateDebuggerPropertyInitializationOffset(Js::RegSlot location, Js::PropertyId propertyId, bool shouldConsumeRegister)\n{\n    Assert(this->Writer());\n    Js::DebuggerScope* currentDebuggerScope = this->Writer()->GetCurrentDebuggerScope();\n    Assert(currentDebuggerScope);\n    if (currentDebuggerScope != nullptr)\n    {\n        this->Writer()->UpdateDebuggerPropertyInitializationOffset(\n            currentDebuggerScope,\n            location,\n            propertyId,\n            shouldConsumeRegister);\n    }\n}\n\nvoid ByteCodeGenerator::LoadHeapArguments(FuncInfo *funcInfo)\n{\n    if (funcInfo->GetHasCachedScope())\n    {\n        this->LoadCachedHeapArguments(funcInfo);\n    }\n    else\n    {\n        this->LoadUncachedHeapArguments(funcInfo);\n    }\n}\n\nvoid GetFormalArgsArray(ByteCodeGenerator *byteCodeGenerator, FuncInfo * funcInfo, Js::PropertyIdArray *propIds)\n{\n    Assert(funcInfo);\n    Assert(propIds);\n    Assert(byteCodeGenerator);\n\n    bool hadDuplicates = false;\n    Js::ArgSlot i = 0;\n\n    auto processArg = [&](ParseNode *pnode)\n    {\n        if (pnode->IsVarLetOrConst())\n        {\n            Assert(i < propIds->count);\n            Symbol *sym = pnode->sxVar.sym;\n            Assert(sym);\n            Js::PropertyId symPos = sym->EnsurePosition(byteCodeGenerator);\n\n            //\n            // Check if the function has any same name parameters\n            // For the same name param, only the last one will be passed the correct propertyid\n            // For remaining dup param names, pass Constants::NoProperty\n            //\n            for (Js::ArgSlot j = 0; j < i; j++)\n            {\n                if (propIds->elements[j] == symPos)\n                {\n                    // Found a dup parameter name\n                    propIds->elements[j] = Js::Constants::NoProperty;\n                    hadDuplicates = true;\n                    break;\n                }\n            }\n            propIds->elements[i] = symPos;\n        }\n        else\n        {\n            propIds->elements[i] = Js::Constants::NoProperty;\n        }\n        ++i;\n    };\n    MapFormals(funcInfo->root, processArg);\n\n    propIds->hadDuplicates = hadDuplicates;\n}\n\nvoid ByteCodeGenerator::LoadUncachedHeapArguments(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetHasHeapArguments());\n\n    Scope *scope = funcInfo->GetBodyScope();\n    Assert(scope);\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n    \n\n    Js::OpCode opcode = !funcInfo->root->sxFnc.HasNonSimpleParameterList() ? Js::OpCode::LdHeapArguments : Js::OpCode::LdLetHeapArguments;\n    bool hasRest = funcInfo->root->sxFnc.pnodeRest != nullptr;\n    uint count = funcInfo->inArgsCount + (hasRest ? 1 : 0) - 1;\n    if (count == 0)\n    {\n        // If no formals to function (only \"this\"), then no need to create the scope object.\n        // Leave both the arguments location and the propertyIds location as null.\n        Assert(funcInfo->root->sxFnc.pnodeParams == nullptr && !hasRest);\n    }\n    else if (!NeedScopeObjectForArguments(funcInfo, funcInfo->root))\n    {\n        // We may not need a scope object for arguments, e.g. strict mode with no eval.\n    }\n    else if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        // Pass the frame object and ID array to the runtime, and put the resulting Arguments object\n        // at the expected location.\n\n        Js::PropertyIdArray *propIds = funcInfo->GetParsedFunctionBody()->AllocatePropertyIdArrayForFormals(count * sizeof(Js::PropertyId), count, 0);\n        GetFormalArgsArray(this, funcInfo, propIds);\n    }\n\n    this->m_writer.Reg1(opcode, argumentsLoc);\n    EmitLocalPropInit(argSym->GetLocation(), argSym, funcInfo);\n}\n\nvoid ByteCodeGenerator::LoadCachedHeapArguments(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetHasHeapArguments());\n\n    Scope *scope = funcInfo->GetBodyScope();\n    Assert(scope);\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n\n    Js::OpCode op = !funcInfo->root->sxFnc.HasNonSimpleParameterList() ? Js::OpCode::LdHeapArgsCached : Js::OpCode::LdLetHeapArgsCached;\n\n    this->m_writer.Reg1(op, argumentsLoc);\n    EmitLocalPropInit(argumentsLoc, argSym, funcInfo);\n}\n\nJs::JavascriptArray* ByteCodeGenerator::BuildArrayFromStringList(ParseNode* stringNodeList, uint arrayLength, Js::ScriptContext* scriptContext)\n{\n    Assert(stringNodeList);\n\n    uint index = 0;\n    Js::Var str;\n    IdentPtr pid;\n    Js::JavascriptArray* pArr = scriptContext->GetLibrary()->CreateArray(arrayLength);\n\n    while (stringNodeList->nop == knopList)\n    {\n        Assert(stringNodeList->sxBin.pnode1->nop == knopStr);\n\n        pid = stringNodeList->sxBin.pnode1->sxPid.pid;\n        str = Js::JavascriptString::NewCopyBuffer(pid->Psz(), pid->Cch(), scriptContext);\n        pArr->SetItemWithAttributes(index, str, PropertyEnumerable);\n\n        stringNodeList = stringNodeList->sxBin.pnode2;\n        index++;\n    }\n\n    Assert(stringNodeList->nop == knopStr);\n\n    pid = stringNodeList->sxPid.pid;\n    str = Js::JavascriptString::NewCopyBuffer(pid->Psz(), pid->Cch(), scriptContext);\n    pArr->SetItemWithAttributes(index, str, PropertyEnumerable);\n\n    return pArr;\n}\n\n// For now, this just assigns field ids for the current script.\n// Later, we will combine this information with the global field id map.\n// This temporary code will not work if a global member is accessed both with and without a LHS.\nvoid ByteCodeGenerator::AssignPropertyIds(Js::ParseableFunctionInfo* functionInfo)\n{\n    globalScope->ForEachSymbol([this, functionInfo](Symbol * sym)\n    {\n        this->AssignPropertyId(sym, functionInfo);\n    });\n}\n\nvoid ByteCodeGenerator::InitBlockScopedContent(ParseNode *pnodeBlock, Js::DebuggerScope* debuggerScope, FuncInfo *funcInfo)\n{\n    Assert(pnodeBlock->nop == knopBlock);\n\n    auto genBlockInit = [this, debuggerScope, funcInfo](ParseNode *pnode)\n    {\n        // Only check if the scope is valid when let/const vars are in the scope.  If there are no let/const vars,\n        // the debugger scope will not be created.\n        AssertMsg(debuggerScope, \"Missing a case of scope tracking in BeginEmitBlock.\");\n\n        FuncInfo *funcInfo = this->TopFuncInfo();\n        Symbol *sym = pnode->sxVar.sym;\n        Scope *scope = sym->GetScope();\n\n        if (sym->GetIsGlobal())\n        {\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n            if (this->flags & fscrEval)\n            {\n                AssertMsg(this->IsConsoleScopeEval(), \"Let/Consts cannot be in global scope outside of console eval\");\n                Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ? Js::OpCode::InitUndeclConsoleConstFld : Js::OpCode::InitUndeclConsoleLetFld;\n                this->m_writer.ElementScopedU(op, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n            else\n            {\n                Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                    Js::OpCode::InitUndeclRootConstFld : Js::OpCode::InitUndeclRootLetFld;\n                this->m_writer.ElementRootU(op, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n        }\n        else if (sym->IsInSlot(funcInfo) || (scope->GetIsObject() && sym->NeedsSlotAlloc(funcInfo)))\n        {\n            if (scope->GetIsObject())\n            {\n                Js::RegSlot scopeLocation = scope->GetLocation();\n                Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n                if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n                {\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n\n                    Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                        Js::OpCode::InitUndeclLocalConstFld : Js::OpCode::InitUndeclLocalLetFld;\n\n                    this->m_writer.ElementP(op, ByteCodeGenerator::ReturnRegister, cacheId);\n                }\n                else\n                {\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n\n                    Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                        Js::OpCode::InitUndeclConstFld : Js::OpCode::InitUndeclLetFld;\n\n                    this->m_writer.ElementPIndexed(op, ByteCodeGenerator::ReturnRegister, scope->GetInnerScopeIndex(), cacheId);\n                }\n\n                TrackActivationObjectPropertyForDebugger(debuggerScope, sym, pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n            else\n            {\n                Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg1(Js::OpCode::InitUndecl, tmpReg);\n                this->EmitLocalPropInit(tmpReg, sym, funcInfo);\n                funcInfo->ReleaseTmpRegister(tmpReg);\n\n                // Slot array properties are tracked in non-debug mode as well because they need to stay\n                // around for heap enumeration and escaping during attach/detach.\n                TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(this), pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n        }\n        else if (!sym->GetIsModuleExportStorage())\n        {\n            if (sym->GetDecl()->sxVar.isSwitchStmtDecl)\n            {\n                // let/const declared in a switch is the only case of a variable that must be checked for\n                // use-before-declaration dynamically within its own function.\n                this->m_writer.Reg1(Js::OpCode::InitUndecl, sym->GetLocation());\n            }\n            // Syms that begin in register may be delay-captured. In debugger mode, such syms\n            // will live only in slots, so tell the debugger to find them there.\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(this), pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n            else \n            {\n                TrackRegisterPropertyForDebugger(debuggerScope, sym, funcInfo, pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n        }\n    };\n\n    IterateBlockScopedVariables(pnodeBlock, genBlockInit);\n}\n\n// Records the start of a debugger scope if the passed in node has any let/const variables (or is not a block node).\n// If it has no let/const variables, nullptr will be returned as no scope will be created.\nJs::DebuggerScope* ByteCodeGenerator::RecordStartScopeObject(ParseNode *pnodeBlock, Js::DiagExtraScopesType scopeType, Js::RegSlot scopeLocation /*= Js::Constants::NoRegister*/, int* index /*= nullptr*/)\n{\n    Assert(pnodeBlock);\n    if (pnodeBlock->nop == knopBlock && !pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        // In order to reduce allocations now that we track debugger scopes in non-debug mode,\n        // don't add a block to the chain if it has no let/const variables at all.\n        return nullptr;\n    }\n\n    return this->Writer()->RecordStartScopeObject(scopeType, scopeLocation, index);\n}\n\n// Records the end of the current scope, but only if the current block has block scoped content.\n// Otherwise, a scope would not have been added (see ByteCodeGenerator::RecordStartScopeObject()).\nvoid ByteCodeGenerator::RecordEndScopeObject(ParseNode *pnodeBlock)\n{\n    Assert(pnodeBlock);\n    if (pnodeBlock->nop == knopBlock && !pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        return;\n    }\n\n    this->Writer()->RecordEndScopeObject();\n}\n\nvoid BeginEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Js::DebuggerScope* debuggerScope = nullptr;\n\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        byteCodeGenerator->PushScope(scope);\n\n        Js::RegSlot scopeLocation = scope->GetLocation();\n        if (scope->GetMustInstantiate())\n        {\n            Assert(scopeLocation == Js::Constants::NoRegister);\n            scopeLocation = funcInfo->FirstInnerScopeReg() + scope->GetInnerScopeIndex();\n\n            if (scope->GetIsObject())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInObject, scopeLocation);\n\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::NewBlockScope, scope->GetInnerScopeIndex());\n            }\n            else\n            {\n                int scopeIndex = Js::DebuggerScope::InvalidScopeIndex;\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInSlot, scopeLocation, &scopeIndex);\n\n                // TODO: Handle heap enumeration\n                int scopeSlotCount = scope->GetScopeSlotCount();\n                byteCodeGenerator->Writer()->Num3(Js::OpCode::NewInnerScopeSlots, scope->GetInnerScopeIndex(), scopeSlotCount + Js::ScopeSlots::FirstSlotIndex, scopeIndex);\n            }\n        }\n        else\n        {\n            // In the direct register access case, there is no block scope emitted but we can still track\n            // the start and end offset of the block.  The location registers for let/const variables will still be\n            // captured along with this range in InitBlockScopedContent().\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeDirect);\n        }\n\n        bool const isGlobalEvalBlockScope = scope->IsGlobalEvalBlockScope();\n        Js::RegSlot frameDisplayLoc = Js::Constants::NoRegister;\n        Js::RegSlot tmpInnerEnvReg = Js::Constants::NoRegister;\n        ParseNodePtr pnodeScope;\n        for (pnodeScope = pnodeBlock->sxBlock.pnodeScopes; pnodeScope;)\n        {\n            switch (pnodeScope->nop)\n            {\n            case knopFncDecl:\n                if (pnodeScope->sxFnc.IsDeclaration())\n                {\n                    // The frameDisplayLoc register's lifetime has to be controlled by this function. We can't let\n                    // it be released by DefineOneFunction, because further iterations of this loop can allocate\n                    // temps, and we can't let frameDisplayLoc be re-purposed until this loop completes.\n                    // So we'll supply a temp that we allocate and release here.\n                    if (frameDisplayLoc == Js::Constants::NoRegister)\n                    {\n                        if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n                        {\n                            frameDisplayLoc = funcInfo->frameDisplayRegister;\n                        }\n                        else\n                        {\n                            frameDisplayLoc = funcInfo->GetEnvRegister();\n                        }\n                        tmpInnerEnvReg = funcInfo->AcquireTmpRegister();\n                        frameDisplayLoc = byteCodeGenerator->PrependLocalScopes(frameDisplayLoc, tmpInnerEnvReg, funcInfo);\n                    }\n                    byteCodeGenerator->DefineOneFunction(pnodeScope, funcInfo, true, frameDisplayLoc);\n                }\n\n                // If this is the global eval block scope, the function is actually assigned to the global\n                // so we don't need to keep the registers.\n                if (isGlobalEvalBlockScope)\n                {\n                    funcInfo->ReleaseLoc(pnodeScope);\n                    pnodeScope->location = Js::Constants::NoRegister;\n                }\n                pnodeScope = pnodeScope->sxFnc.pnodeNext;\n                break;\n\n            case knopBlock:\n                pnodeScope = pnodeScope->sxBlock.pnodeNext;\n                break;\n\n            case knopCatch:\n                pnodeScope = pnodeScope->sxCatch.pnodeNext;\n                break;\n\n            case knopWith:\n                pnodeScope = pnodeScope->sxWith.pnodeNext;\n                break;\n            }\n        }\n\n        if (tmpInnerEnvReg != Js::Constants::NoRegister)\n        {\n            funcInfo->ReleaseTmpRegister(tmpInnerEnvReg);\n        }\n\n        if (pnodeBlock->sxBlock.scope->IsGlobalEvalBlockScope() && funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            Scope* globalEvalBlockScope = funcInfo->GetGlobalEvalBlockScope();\n            byteCodeGenerator->EmitInitCapturedThis(funcInfo, globalEvalBlockScope);\n        }\n    }\n    else\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        if (scope)\n        {\n            if (scope->GetMustInstantiate())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInObject);\n            }\n            else\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeDirect);\n            }\n        }\n        else\n        {\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInSlot);\n        }\n    }\n\n    byteCodeGenerator->InitBlockScopedContent(pnodeBlock, debuggerScope, funcInfo);\n}\n\nvoid EndEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        Assert(scope);\n        Assert(scope == byteCodeGenerator->GetCurrentScope());\n        byteCodeGenerator->PopScope();\n    }\n\n    byteCodeGenerator->RecordEndScopeObject(pnodeBlock);\n}\n\nvoid CloneEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        // Only let variables have observable behavior when there are per iteration\n        // bindings.  const variables do not since they are immutable.  Therefore,\n        // (and the spec agrees), only create new scope clones if the loop variable\n        // is a let declaration.\n        bool isConst = false;\n        pnodeBlock->sxBlock.scope->ForEachSymbolUntil([&isConst](Symbol * const sym) {\n            // Exploit the fact that a for loop sxBlock can only have let and const\n            // declarations, and can only have one or the other, regardless of how\n            // many syms there might be.  Thus only check the first sym.\n            isConst = sym->GetDecl()->nop == knopConstDecl;\n            return true;\n        });\n\n        if (!isConst)\n        {\n            Scope *scope = pnodeBlock->sxBlock.scope;\n            Assert(scope == byteCodeGenerator->GetCurrentScope());\n\n            if (scope->GetMustInstantiate())\n            {\n                Js::OpCode op = scope->GetIsObject() ? Js::OpCode::CloneBlockScope : Js::OpCode::CloneInnerScopeSlots;\n\n                byteCodeGenerator->Writer()->Unsigned1(op, scope->GetInnerScopeIndex());\n            }\n        }\n    }\n}\n\nvoid EmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    Assert(pnodeBlock->nop == knopBlock);\n    ParseNode *pnode = pnodeBlock->sxBlock.pnodeStmt;\n    if (pnode == nullptr)\n    {\n        return;\n    }\n\n    BeginEmitBlock(pnodeBlock, byteCodeGenerator, funcInfo);\n\n    ParseNode *pnodeLastValStmt = pnodeBlock->sxBlock.pnodeLastValStmt;\n\n    while (pnode->nop == knopList)\n    {\n        ParseNode* stmt = pnode->sxBin.pnode1;\n        if (stmt == pnodeLastValStmt)\n        {\n            // This is the last guaranteed return value, so any potential return values have to be\n            // copied to the return register from this point forward.\n            pnodeLastValStmt = nullptr;\n        }\n        byteCodeGenerator->EmitTopLevelStatement(stmt, funcInfo, fReturnValue && (pnodeLastValStmt == nullptr));\n        pnode = pnode->sxBin.pnode2;\n    }\n\n    if (pnode == pnodeLastValStmt)\n    {\n        pnodeLastValStmt = nullptr;\n    }\n    byteCodeGenerator->EmitTopLevelStatement(pnode, funcInfo, fReturnValue && (pnodeLastValStmt == nullptr));\n\n    EndEmitBlock(pnodeBlock, byteCodeGenerator, funcInfo);\n}\n\nvoid ClearTmpRegs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* emitFunc)\n{\n    if (emitFunc->IsTmpReg(pnode->location))\n    {\n        pnode->location = Js::Constants::NoRegister;\n    }\n}\n\nvoid ByteCodeGenerator::EmitTopLevelStatement(ParseNode *stmt, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    if (stmt->nop == knopFncDecl && stmt->sxFnc.IsDeclaration())\n    {\n        // Function declarations (not function-declaration RHS's) are already fully processed.\n        // Skip them here so the temp registers don't get messed up.\n        return;\n    }\n\n    if (stmt->nop == knopName || stmt->nop == knopDot)\n    {\n        // Generating span for top level names are mostly useful in debugging mode, because user can debug it even though no side-effect expected.\n        // But the name can have runtime error, e.g., foo.bar; // where foo is not defined.\n        // At this time we need to throw proper line number and offset. so recording on all modes will be useful.\n        StartStatement(stmt);\n        Writer()->Empty(Js::OpCode::Nop);\n        EndStatement(stmt);\n    }\n\n    Emit(stmt, this, funcInfo, fReturnValue, false/*isConstructorCall*/, nullptr/*bindPnode*/, true/*isTopLevel*/);\n    if (funcInfo->IsTmpReg(stmt->location))\n    {\n        if (!stmt->isUsed && !fReturnValue)\n        {\n            m_writer.Reg1(Js::OpCode::Unused, stmt->location);\n        }\n        funcInfo->ReleaseLoc(stmt);\n    }\n}\n\n// ByteCodeGenerator::DefineFunctions\n//\n// Emit byte code for scope-wide function definitions before any calls in the scope, regardless of lexical\n// order. Note that stores to the closure array are not emitted until we see the knopFncDecl in the tree\n// to make sure that sources of the stores have been defined.\nvoid ByteCodeGenerator::DefineFunctions(FuncInfo *funcInfoParent)\n{\n    // DefineCachedFunctions doesn't depend on whether the user vars are declared or not, so\n    // we'll just overload this variable to mean that the functions getting called again and we don't need to do anything\n    if (funcInfoParent->GetHasCachedScope())\n    {\n        this->DefineCachedFunctions(funcInfoParent);\n    }\n    else\n    {\n        this->DefineUncachedFunctions(funcInfoParent);\n    }\n}\n\n// Iterate over all child functions in a function's parameter and body scopes.\ntemplate<typename Fn>\nvoid MapContainerScopeFunctions(ParseNode* pnodeScope, Fn fn)\n{\n    auto mapFncDeclsInScopeList = [&](ParseNode *pnodeHead)\n    {\n        for (ParseNode *pnode = pnodeHead; pnode != nullptr;)\n        {\n            switch (pnode->nop)\n            {\n            case knopFncDecl:\n                fn(pnode);\n                pnode = pnode->sxFnc.pnodeNext;\n                break;\n\n            case knopBlock:\n                pnode = pnode->sxBlock.pnodeNext;\n                break;\n\n            case knopCatch:\n                pnode = pnode->sxCatch.pnodeNext;\n                break;\n\n            case knopWith:\n                pnode = pnode->sxWith.pnodeNext;\n                break;\n\n            default:\n                AssertMsg(false, \"Unexpected opcode in tree of scopes\");\n                return;\n            }\n        }\n    };\n    pnodeScope->sxFnc.MapContainerScopes(mapFncDeclsInScopeList);\n}\n\nvoid ByteCodeGenerator::DefineCachedFunctions(FuncInfo *funcInfoParent)\n{\n    ParseNode *pnodeParent = funcInfoParent->root;\n    uint slotCount = 0;\n\n    auto countFncSlots = [&](ParseNode *pnodeFnc)\n    {\n        if (pnodeFnc->sxFnc.GetFuncSymbol() != nullptr && pnodeFnc->sxFnc.IsDeclaration())\n        {\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, countFncSlots);\n\n    if (slotCount == 0)\n    {\n        return;\n    }\n\n    size_t extraBytesActual = AllocSizeMath::Mul(slotCount, sizeof(Js::FuncInfoEntry));\n    // Reg2Aux takes int for byteCount so we need to convert to int. OOM if we can't because it would truncate data.\n    if (extraBytesActual > INT_MAX)\n    {\n        Js::Throw::OutOfMemory();\n    }\n    int extraBytes = (int)extraBytesActual;\n\n    Js::FuncInfoArray *info = AnewPlus(alloc, extraBytes, Js::FuncInfoArray, slotCount);\n\n    slotCount = 0;\n\n    auto fillEntries = [&](ParseNode *pnodeFnc)\n    {\n        Symbol *sym = pnodeFnc->sxFnc.GetFuncSymbol();\n        if (sym != nullptr && (pnodeFnc->sxFnc.IsDeclaration()))\n        {\n            AssertMsg(!pnodeFnc->sxFnc.IsGenerator(), \"Generator functions are not supported by InitCachedFuncs but since they always escape they should disable function caching\");\n            Js::FuncInfoEntry *entry = &info->elements[slotCount];\n            entry->nestedIndex = pnodeFnc->sxFnc.nestedIndex;\n            entry->scopeSlot = sym->GetScopeSlot();\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, fillEntries);\n\n    m_writer.AuxNoReg(Js::OpCode::InitCachedFuncs,\n        info,\n        sizeof(Js::FuncInfoArray) + extraBytes,\n        sizeof(Js::FuncInfoArray) + extraBytes);\n\n    slotCount = 0;\n    auto defineOrGetCachedFunc = [&](ParseNode *pnodeFnc)\n    {\n        Symbol *sym = pnodeFnc->sxFnc.GetFuncSymbol();\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            // Do we need to define the function here (i.e., is it not one of our cached locals)?\n            // Only happens if the sym is null (e.g., function x.y(){}).\n            if (sym == nullptr)\n            {\n                this->DefineOneFunction(pnodeFnc, funcInfoParent);\n            }\n            else if (!sym->IsInSlot(funcInfoParent) && sym->GetLocation() != Js::Constants::NoRegister)\n            {\n                // If it was defined by InitCachedFuncs, do we need to put it in a register rather than a slot?\n                m_writer.Reg1Unsigned1(Js::OpCode::GetCachedFunc, sym->GetLocation(), slotCount);\n            }\n            // The \"x = function() {...}\" case is being generated on the fly, during emission,\n            // so the caller expects to be able to release this register.\n            funcInfoParent->ReleaseLoc(pnodeFnc);\n            pnodeFnc->location = Js::Constants::NoRegister;\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, defineOrGetCachedFunc);\n\n    AdeletePlus(alloc, extraBytes, info);\n}\n\nvoid ByteCodeGenerator::DefineUncachedFunctions(FuncInfo *funcInfoParent)\n{\n    ParseNode *pnodeParent = funcInfoParent->root;\n    auto defineCheck = [&](ParseNode *pnodeFnc)\n    {\n        Assert(pnodeFnc->nop == knopFncDecl);\n\n        //\n        // Don't define the function upfront in following cases\n        // 1. x = function() {...};\n        //    Don't define the function for all modes.\n        //    Such a function can only be accessed via the LHS, so we define it at the assignment point\n        //    rather than the scope entry to save a register (and possibly save the whole definition).\n        //\n        // 2. x = function f() {...};\n        //    f is not visible in the enclosing scope.\n        //    Such function expressions should be emitted only at the assignment point, as can be used only\n        //    after the assignment. Might save register.\n        //\n\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            this->DefineOneFunction(pnodeFnc, funcInfoParent);\n            // The \"x = function() {...}\" case is being generated on the fly, during emission,\n            // so the caller expects to be able to release this register.\n            funcInfoParent->ReleaseLoc(pnodeFnc);\n            pnodeFnc->location = Js::Constants::NoRegister;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, defineCheck);\n}\n\nvoid EmitAssignmentToFuncName(ParseNode *pnodeFnc, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfoParent)\n{\n    // Assign the location holding the func object reference to the given name.\n    Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n\n    if (sym != nullptr && !sym->GetIsFuncExpr())\n    {\n        if (sym->GetIsModuleExportStorage())\n        {\n            byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n        }\n        else if (sym->GetIsGlobal())\n        {\n            Js::PropertyId propertyId = sym->GetPosition();\n            byteCodeGenerator->EmitGlobalFncDeclInit(pnodeFnc->location, propertyId, funcInfoParent);\n            if (byteCodeGenerator->GetFlags() & fscrEval && !funcInfoParent->GetIsStrictMode())\n            {\n                byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n            }\n        }\n        else\n        {\n            if (sym->NeedsSlotAlloc(funcInfoParent))\n            {\n                if (!sym->GetHasNonCommittedReference() ||\n                    (funcInfoParent->GetParsedFunctionBody()->DoStackNestedFunc()))\n                {\n                    // No point in trying to optimize if there are no references before we have to commit to slot.\n                    // And not safe to delay putting a stack function in the slot, since we may miss boxing.\n                    sym->SetIsCommittedToSlot();\n                }\n            }\n\n            if (sym->GetScope()->GetFunc() != byteCodeGenerator->TopFuncInfo())\n            {\n                byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n            }\n            else if (!sym->GetIsBlockVar() || sym->HasRealBlockVarRef() || sym->GetScope()->GetIsObject())\n            {\n                byteCodeGenerator->EmitLocalPropInit(pnodeFnc->location, sym, funcInfoParent);\n            }\n\n            Symbol * fncScopeSym = sym->GetFuncScopeVarSym();\n\n            if (fncScopeSym)\n            {\n                if (fncScopeSym->GetIsGlobal() && byteCodeGenerator->GetFlags() & fscrEval)\n                {\n                    Js::PropertyId propertyId = fncScopeSym->GetPosition();\n                    byteCodeGenerator->EmitGlobalFncDeclInit(pnodeFnc->location, propertyId, funcInfoParent);\n                }\n                else\n                {\n                    byteCodeGenerator->EmitPropStore(pnodeFnc->location, fncScopeSym, nullptr, funcInfoParent, false, false, /* isFncDeclVar */true);\n                }\n            }\n        }\n    }\n}\n\nJs::RegSlot ByteCodeGenerator::DefineOneFunction(ParseNode *pnodeFnc, FuncInfo *funcInfoParent, bool generateAssignment, Js::RegSlot regEnv, Js::RegSlot frameDisplayTemp)\n{\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    funcInfoParent->AcquireLoc(pnodeFnc);\n\n    if (regEnv == Js::Constants::NoRegister)\n    {\n        // If the child needs a closure, find a heap-allocated frame to pass to it.\n        if (frameDisplayTemp != Js::Constants::NoRegister)\n        {\n            // We allocated a temp to hold a local frame display value. Use that.\n            // It's likely that the FD is on the stack, and we used the temp to load it back.\n            regEnv = frameDisplayTemp;\n        }\n        else if (funcInfoParent->frameDisplayRegister != Js::Constants::NoRegister)\n        {\n            // This function has built a frame display, so pass it down.\n            regEnv = funcInfoParent->frameDisplayRegister;\n        }\n        else\n        {\n            // This function has no captured locals but inherits a closure environment, so pass it down.\n            regEnv = funcInfoParent->GetEnvRegister();\n        }\n\n        regEnv = this->PrependLocalScopes(regEnv, Js::Constants::NoRegister, funcInfoParent);\n    }\n\n    // AssertMsg(funcInfo->nonLocalSymbols == 0 || regEnv != funcInfoParent->nullConstantRegister,\n    // \"We need a closure for the nested function\");\n\n    // If we are in a parameter scope and it is not merged with body scope then we have to create the child function as an inner function\n    if (regEnv == funcInfoParent->frameDisplayRegister || regEnv == funcInfoParent->GetEnvRegister())\n    {\n        m_writer.NewFunction(pnodeFnc->location, pnodeFnc->sxFnc.nestedIndex, pnodeFnc->sxFnc.IsCoroutine());\n    }\n    else\n    {\n        m_writer.NewInnerFunction(pnodeFnc->location, pnodeFnc->sxFnc.nestedIndex, regEnv, pnodeFnc->sxFnc.IsCoroutine());\n    }\n\n    if (funcInfoParent->IsGlobalFunction() && (this->flags & fscrEval))\n    {\n        // A function declared at global scope in eval is untrackable,\n        // so make sure the caller's cached scope is invalidated.\n        this->funcEscapes = true;\n    }\n    else\n    {\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            Symbol * funcSymbol = pnodeFnc->sxFnc.GetFuncSymbol();\n            if (funcSymbol)\n            {\n                // In the case where a let/const declaration is the same symbol name\n                // as the function declaration (shadowing case), the let/const var and\n                // the function declaration symbol are the same and share the same flags\n                // (particularly, sym->GetIsBlockVar() for this code path).\n                //\n                // For example:\n                // let a = 0;       // <-- sym->GetIsBlockVar() = true\n                // function b(){}   // <-- sym2->GetIsBlockVar() = false\n                //\n                // let x = 0;       // <-- sym3->GetIsBlockVar() = true\n                // function x(){}   // <-- sym3->GetIsBlockVar() = true\n                //\n                // In order to tell if the function is actually part\n                // of a block scope, we compare against the function scope here.\n                // Note that having a function with the same name as a let/const declaration\n                // is a redeclaration error, but we're pushing the fix for this out since it's\n                // a bit involved.\n                Assert(funcInfoParent->GetBodyScope() != nullptr && funcSymbol->GetScope() != nullptr);\n                bool isFunctionDeclarationInBlock = funcSymbol->GetIsBlockVar();\n\n                // Track all vars/lets/consts register slot function declarations.\n                if (ShouldTrackDebuggerMetadata()\n                    // If this is a let binding function declaration at global level, we want to\n                    // be sure to track the register location as well.\n                    && !(funcInfoParent->IsGlobalFunction() && !isFunctionDeclarationInBlock))\n                {\n                    if (!funcSymbol->IsInSlot(funcInfoParent))\n                    {\n                        funcInfoParent->byteCodeFunction->GetFunctionBody()->InsertSymbolToRegSlotList(funcSymbol->GetName(), pnodeFnc->location, funcInfoParent->varRegsCount);\n                    }\n                }\n\n                if (isFunctionDeclarationInBlock)\n                {\n                    // We only track inner let bindings for the debugger side.\n                    this->TrackFunctionDeclarationPropertyForDebugger(funcSymbol, funcInfoParent);\n                }\n            }\n        }\n    }\n\n    if (pnodeFnc->sxFnc.IsDefaultModuleExport())\n    {\n        this->EmitAssignmentToDefaultModuleExport(pnodeFnc, funcInfoParent);\n    }\n\n    if (pnodeFnc->sxFnc.pnodeName == nullptr || !generateAssignment)\n    {\n        return regEnv;\n    }\n\n    EmitAssignmentToFuncName(pnodeFnc, this, funcInfoParent);\n\n    return regEnv;\n}\n\nvoid ByteCodeGenerator::DefineUserVars(FuncInfo *funcInfo)\n{\n    // Initialize scope-wide variables on entry to the scope. TODO: optimize by detecting uses that are always reached\n    // by an existing initialization.\n\n    BOOL fGlobal = funcInfo->IsGlobalFunction();\n    ParseNode *pnode;\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // Global declarations need a temp register to hold the init value, but the node shouldn't get a register.\n    // Just assign one on the fly and re-use it for all initializations.\n    Js::RegSlot tmpReg = fGlobal ? funcInfo->AcquireTmpRegister() : Js::Constants::NoRegister;\n\n    for (pnode = funcInfo->root->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n    {\n        Symbol* sym = pnode->sxVar.sym;\n\n        if (sym != nullptr && !(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n        {\n            if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n            {\n                // The init node was bound to the catch object, because it's inside a catch and has the\n                // same name as the catch object. But we want to define a user var at function scope,\n                // so find the right symbol. (We'll still assign the RHS value to the catch object symbol.)\n                // This also applies to a var declaration in the same scope as a let declaration.\n#if DBG\n                if (!sym->GetIsCatch())\n                {\n                    // Assert that catch cannot be at function scope and let and var at function scope is redeclaration error.\n                    Assert(funcInfo->bodyScope != sym->GetScope());\n                }\n#endif\n                sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                Assert(sym && !sym->GetIsCatch() && !sym->GetIsBlockVar());\n            }\n\n            if (sym->GetSymbolType() == STVariable && !sym->GetIsModuleExportStorage())\n            {\n                if (fGlobal)\n                {\n                    Js::PropertyId propertyId = sym->EnsurePosition(this);\n                    // We do need to initialize some globals to avoid JS errors on loading undefined variables.\n                    // But we first need to make sure we're not trashing built-ins.\n\n                    if (this->flags & fscrEval)\n                    {\n                        if (funcInfo->byteCodeFunction->GetIsStrictMode())\n                        {\n                            // Check/Init the property of the frame object\n                            this->m_writer.ElementRootU(Js::OpCode::LdLocalElemUndef,\n                                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                        }\n                        else\n                        {\n                            // The check and the init involve the first element in the scope chain.\n                            this->m_writer.ElementScopedU(\n                                Js::OpCode::LdElemUndefScoped, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                        }\n                    }\n                    else\n                    {\n                        this->m_writer.ElementU(Js::OpCode::LdElemUndef, ByteCodeGenerator::RootObjectRegister,\n                            funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                    }\n                }\n                else if (!sym->GetIsArguments())\n                {\n                    if (sym->NeedsSlotAlloc(funcInfo))\n                    {\n                        if (!sym->GetHasNonCommittedReference() ||\n                            (sym->GetHasFuncAssignment() && funcInfo->GetParsedFunctionBody()->DoStackNestedFunc()))\n                        {\n                            // No point in trying to optimize if there are no references before we have to commit to slot.\n                            // And not safe to delay putting a stack function in the slot, since we may miss boxing.\n                            sym->SetIsCommittedToSlot();\n                        }\n                    }\n\n                    // Undef-initialize the home location if it is a register (not closure-captured, or else capture\n                    // is delayed) or a property of an object.\n                    if ((!sym->GetHasInit() && !sym->IsInSlot(funcInfo)) ||\n                        (funcInfo->bodyScope->GetIsObject() && !funcInfo->GetHasCachedScope()))\n                    {\n                        // If the  current symbol is the duplicate arguments symbol created in the body for split\n                        // scope then load undef only if the arguments symbol is used in the body.\n                        if (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments())\n                        {\n                            Js::RegSlot reg = sym->GetLocation();\n                            if (reg == Js::Constants::NoRegister)\n                            {\n                                Assert(sym->IsInSlot(funcInfo));\n                                reg = funcInfo->AcquireTmpRegister();\n                            }\n                            this->m_writer.Reg1(Js::OpCode::LdUndef, reg);\n                            this->EmitLocalPropInit(reg, sym, funcInfo);\n\n                            if (ShouldTrackDebuggerMetadata() && !sym->GetHasInit() && !sym->IsInSlot(funcInfo))\n                            {\n                                byteCodeFunction->InsertSymbolToRegSlotList(sym->GetName(), reg, funcInfo->varRegsCount);\n                            }\n\n                            funcInfo->ReleaseTmpRegister(reg);\n                        }\n                    }\n                }\n                else if (ShouldTrackDebuggerMetadata())\n                {\n                    if (!sym->GetHasInit() && !sym->IsInSlot(funcInfo))\n                    {\n                        Js::RegSlot reg = sym->GetLocation();\n                        if (reg != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(sym->GetName(), reg, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n                sym->SetHasInit(TRUE);\n            }\n        }\n\n    }\n    if (tmpReg != Js::Constants::NoRegister)\n    {\n        funcInfo->ReleaseTmpRegister(tmpReg);\n    }\n\n    for (int i = 0; i < funcInfo->nonUserNonTempRegistersToInitialize.Count(); ++i)\n    {\n        m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->nonUserNonTempRegistersToInitialize.Item(i));\n    }\n}\n\nvoid ByteCodeGenerator::InitBlockScopedNonTemps(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    // Initialize all non-temp register variables on entry to the enclosing func - in particular,\n    // those with lifetimes that begin after the start of user code and may not be initialized normally.\n    // This protects us from, for instance, trying to restore garbage on bailout.\n    // It was originally done in debugger mode only, but we do it always to avoid issues with boxing\n    // garbage on exit from jitted loop bodies.\n    while (pnode)\n    {\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n        {\n            // If this is a block-scoped function, initialize it.\n            ParseNode *pnodeName = pnode->sxFnc.pnodeName;\n            if (!pnode->sxFnc.IsMethod() && pnodeName && pnodeName->nop == knopVarDecl)\n            {\n                Symbol *sym = pnodeName->sxVar.sym;\n                Assert(sym);\n                if (sym->GetLocation() != Js::Constants::NoRegister &&\n                    sym->GetScope()->IsBlockScope(funcInfo) &&\n                    sym->GetScope()->GetFunc() == funcInfo)\n                {\n                    this->m_writer.Reg1(Js::OpCode::LdUndef, sym->GetLocation());\n                }\n            }\n\n            // No need to recurse to the nested scopes, as they belong to a nested function.\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n        }\n\n        case knopBlock:\n        {\n            Scope *scope = pnode->sxBlock.scope;\n            if (scope)\n            {\n                if (scope->IsBlockScope(funcInfo))\n                {\n                    Js::RegSlot scopeLoc = scope->GetLocation();\n                    if (scopeLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(scopeLoc))\n                    {\n                        this->m_writer.Reg1(Js::OpCode::LdUndef, scopeLoc);\n                    }\n                }\n                auto fnInit = [this, funcInfo](ParseNode *pnode)\n                {\n                    Symbol *sym = pnode->sxVar.sym;\n                    if (!sym->IsInSlot(funcInfo) && !sym->GetIsGlobal() && !sym->GetIsModuleImport())\n                    {\n                        this->m_writer.Reg1(Js::OpCode::InitUndecl, pnode->sxVar.sym->GetLocation());\n                    }\n                };\n                IterateBlockScopedVariables(pnode, fnInit);\n            }\n            InitBlockScopedNonTemps(pnode->sxBlock.pnodeScopes, funcInfo);\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n        }\n        case knopCatch:\n            InitBlockScopedNonTemps(pnode->sxCatch.pnodeScopes, funcInfo);\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n        {\n            Js::RegSlot withLoc = pnode->location;\n            AssertMsg(withLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(withLoc),\n                \"We should put with objects at known stack locations in debug mode\");\n            this->m_writer.Reg1(Js::OpCode::LdUndef, withLoc);\n            InitBlockScopedNonTemps(pnode->sxWith.pnodeScopes, funcInfo);\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n        }\n\n        default:\n            Assert(false);\n            return;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeObjectInit(FuncInfo *funcInfo)\n{\n    Assert(!funcInfo->byteCodeFunction->GetFunctionBody()->DoStackNestedFunc());\n\n    if (!funcInfo->GetHasCachedScope() /* || forcing scope/inner func caching */)\n    {\n        return;\n    }\n\n    Scope* currentScope = funcInfo->GetCurrentChildScope();\n    uint slotCount = currentScope->GetScopeSlotCount();\n    uint cachedFuncCount = 0;\n    Js::PropertyId firstFuncSlot = Js::Constants::NoProperty;\n    Js::PropertyId firstVarSlot = Js::Constants::NoProperty;\n    uint extraAlloc = (slotCount + Js::ActivationObjectEx::ExtraSlotCount()) * sizeof(Js::PropertyId);\n\n    // Create and fill the array of local property ID's.\n    // They all have slots assigned to them already (if they need them): see StartEmitFunction.\n    \n    Js::PropertyIdArray *propIds = funcInfo->GetParsedFunctionBody()->AllocatePropertyIdArrayForFormals(extraAlloc, slotCount, Js::ActivationObjectEx::ExtraSlotCount());\n    \n    ParseNode *pnodeFnc = funcInfo->root;\n    ParseNode *pnode;\n    Symbol *sym;\n\n    if (funcInfo->GetFuncExprNameReference() && pnodeFnc->sxFnc.GetFuncSymbol()->GetScope() == funcInfo->GetBodyScope())\n    {\n        Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.GetFuncSymbol(), propIds, this);\n    }\n\n    if (funcInfo->GetHasArguments())\n    {\n        // Because the arguments object can access all instances of same-named formals (\"function(x,x){...}\"),\n        // be sure we initialize any duplicate appearances of a formal parameter to \"NoProperty\".\n        Js::PropertyId slot = 0;\n        auto initArg = [&](ParseNode *pnode)\n        {\n            if (pnode->IsVarLetOrConst())\n            {\n                Symbol *sym = pnode->sxVar.sym;\n                Assert(sym);\n                if (sym->GetScopeSlot() == slot)\n                {\n                    // This is the last appearance of the formal, so record the ID.\n                    Symbol::SaveToPropIdArray(sym, propIds, this);\n                }\n                else\n                {\n                    // This is an earlier duplicate appearance of the formal, so use NoProperty as a placeholder\n                    // since this slot can't be accessed by name.\n                    Assert(sym->GetScopeSlot() != Js::Constants::NoProperty && sym->GetScopeSlot() > slot);\n                    propIds->elements[slot] = Js::Constants::NoProperty;\n                }\n            }\n            else\n            {\n                // This is for patterns\n                propIds->elements[slot] = Js::Constants::NoProperty;\n            }\n            slot++;\n        };\n        MapFormalsWithoutRest(pnodeFnc, initArg);\n\n        // If the rest is in the slot - we need to keep that slot.\n        if (pnodeFnc->sxFnc.pnodeRest != nullptr && pnodeFnc->sxFnc.pnodeRest->sxVar.sym->IsInSlot(funcInfo))\n        {\n            Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.pnodeRest->sxVar.sym, propIds, this);\n        }\n    }\n    else\n    {\n        MapFormals(pnodeFnc, [&](ParseNode *pnode)\n        {\n            if (pnode->IsVarLetOrConst())\n            {\n                Symbol::SaveToPropIdArray(pnode->sxVar.sym, propIds, this);\n            }\n        });\n    }\n\n    auto saveFunctionVarsToPropIdArray = [&](ParseNode *pnodeFunction)\n    {\n        if (pnodeFunction->sxFnc.IsDeclaration())\n        {\n            ParseNode *pnodeName = pnodeFunction->sxFnc.pnodeName;\n            if (pnodeName != nullptr)\n            {\n                while (pnodeName->nop == knopList)\n                {\n                    if (pnodeName->sxBin.pnode1->nop == knopVarDecl)\n                    {\n                        sym = pnodeName->sxBin.pnode1->sxVar.sym;\n                        if (sym)\n                        {\n                            Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);\n                        }\n                    }\n                    pnodeName = pnodeName->sxBin.pnode2;\n                }\n                if (pnodeName->nop == knopVarDecl)\n                {\n                    sym = pnodeName->sxVar.sym;\n                    if (sym)\n                    {\n                        Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);\n                        cachedFuncCount++;\n                    }\n                }\n            }\n        }\n    };\n    MapContainerScopeFunctions(pnodeFnc, saveFunctionVarsToPropIdArray);\n\n    if (currentScope->GetScopeType() != ScopeType_Parameter)\n    {\n        for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n            {\n                if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                {\n                    sym = currentScope->FindLocalSymbol(sym->GetName());\n                }\n                Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n            }\n        }\n\n        ParseNode *pnodeBlock = pnodeFnc->sxFnc.pnodeScopes;\n        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n        }\n\n        pnodeBlock = pnodeFnc->sxFnc.pnodeBodyScope;\n        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n        }\n    }\n    else\n    {\n        Assert(!currentScope->GetCanMergeWithBodyScope());\n    }\n\n    if (funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->thisScopeSlot] = Js::PropertyIds::_lexicalThisSlotSymbol;\n    }\n    if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->newTargetScopeSlot] = Js::PropertyIds::_lexicalNewTargetSymbol;\n    }\n    if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->superScopeSlot] = Js::PropertyIds::_superReferenceSymbol;\n    }\n    if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->superCtorScopeSlot] = Js::PropertyIds::_superCtorReferenceSymbol;\n    }\n\n    // Write the first func slot and first var slot into the auxiliary data\n    Js::PropertyId *slots = propIds->elements + slotCount;\n    slots[0] = cachedFuncCount;\n    slots[1] = firstFuncSlot;\n    slots[2] = firstVarSlot;\n    slots[3] = funcInfo->GetParsedFunctionBody()->NewObjectLiteral();\n\n    propIds->hasNonSimpleParams = funcInfo->root->sxFnc.HasNonSimpleParameterList();\n    \n    funcInfo->GetParsedFunctionBody()->SetHasCachedScopePropIds(true);\n}\n\nvoid ByteCodeGenerator::SetClosureRegisters(FuncInfo* funcInfo, Js::FunctionBody* byteCodeFunction)\n{\n    if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalFrameDisplayRegister(funcInfo->frameDisplayRegister);\n    }\n\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalClosureRegister(funcInfo->frameObjRegister);\n        byteCodeFunction->SetHasScopeObject(true);\n    }\n    else if (funcInfo->frameSlotsRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalClosureRegister(funcInfo->frameSlotsRegister);\n    }\n\n    if (funcInfo->paramSlotsRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetParamClosureRegister(funcInfo->paramSlotsRegister);\n    }\n}\n\nvoid ByteCodeGenerator::FinalizeRegisters(FuncInfo * funcInfo, Js::FunctionBody * byteCodeFunction)\n{\n    if (byteCodeFunction->IsCoroutine())\n    {\n        // EmitYield uses 'false' to create the IteratorResult object\n        funcInfo->AssignFalseConstRegister();\n    }\n\n    if (funcInfo->NeedEnvRegister())\n    {\n        bool constReg = !funcInfo->GetIsTopLevelEventHandler() && funcInfo->IsGlobalFunction() && !(this->flags & fscrEval);\n        funcInfo->AssignEnvRegister(constReg);\n    }\n\n    // Set the function body's constant count before emitting anything so that the byte code writer\n    // can distinguish constants from variables.\n    byteCodeFunction->CheckAndSetConstantCount(funcInfo->constRegsCount);\n\n    this->SetClosureRegisters(funcInfo, byteCodeFunction);\n\n    if (this->IsInDebugMode())\n    {\n        // Give permanent registers to the inner scopes in debug mode.\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n        if (innerScopeCount)\n        {\n            funcInfo->SetFirstInnerScopeReg(funcInfo->NextVarRegister());\n            for (uint i = 1; i < innerScopeCount; i++)\n            {\n                funcInfo->NextVarRegister();\n            }\n        }\n    }\n\n    // NOTE: The FB expects the yield reg to be the final non-temp.\n    if (byteCodeFunction->IsCoroutine())\n    {\n        funcInfo->AssignYieldRegister();\n    }\n\n    Js::RegSlot firstTmpReg = funcInfo->varRegsCount;\n    funcInfo->SetFirstTmpReg(firstTmpReg);\n    byteCodeFunction->SetFirstTmpReg(funcInfo->RegCount());\n}\n\nvoid ByteCodeGenerator::InitScopeSlotArray(FuncInfo * funcInfo)\n{\n    // Record slots info for ScopeSlots/ScopeObject.\n    uint scopeSlotCount = funcInfo->bodyScope->GetScopeSlotCount();\n    Assert(funcInfo->paramScope == nullptr || funcInfo->paramScope->GetScopeSlotCount() == 0 || !funcInfo->paramScope->GetCanMergeWithBodyScope());\n    uint scopeSlotCountForParamScope = funcInfo->paramScope != nullptr ? funcInfo->paramScope->GetScopeSlotCount() : 0;\n\n    if (scopeSlotCount == 0 && scopeSlotCountForParamScope == 0)\n    {\n        return;\n    }\n\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    if (scopeSlotCount > 0 || scopeSlotCountForParamScope > 0)\n    {\n        byteCodeFunction->SetScopeSlotArraySizes(scopeSlotCount, scopeSlotCountForParamScope);\n    }\n\n    // TODO: Need to add property ids for the case when scopeSlotCountForParamSCope is non-zero\n    if (scopeSlotCount)\n    {\n        Js::PropertyId *propertyIdsForScopeSlotArray = RecyclerNewArrayLeafZ(scriptContext->GetRecycler(), Js::PropertyId, scopeSlotCount);\n        byteCodeFunction->SetPropertyIdsForScopeSlotArray(propertyIdsForScopeSlotArray, scopeSlotCount, scopeSlotCountForParamScope);\n        AssertMsg(!byteCodeFunction->IsReparsed() || byteCodeFunction->m_wasEverAsmjsMode || byteCodeFunction->scopeSlotArraySize == scopeSlotCount,\n            \"The slot array size is different between debug and non-debug mode\");\n#if DEBUG\n        for (UINT i = 0; i < scopeSlotCount; i++)\n        {\n            propertyIdsForScopeSlotArray[i] = Js::Constants::NoProperty;\n        }\n#endif\n        auto setPropertyIdForScopeSlotArray =\n            [scopeSlotCount, propertyIdsForScopeSlotArray]\n            (Js::PropertyId slot, Js::PropertyId propId)\n        {\n            if (slot < 0 || (uint)slot >= scopeSlotCount)\n            {\n                Js::Throw::FatalInternalError();\n            }\n            propertyIdsForScopeSlotArray[slot] = propId;\n        };\n\n        auto setPropIdsForScopeSlotArray = [funcInfo, setPropertyIdForScopeSlotArray](Symbol *const sym)\n        {\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                if (funcInfo->IsInnerArgumentsSymbol(sym) && !funcInfo->GetHasArguments())\n                {\n                    // In split scope case we have a duplicate symbol for arguments in the body (innerArgumentsSymbol).\n                    // But if arguments is not referenced in the body we don't have to allocate scope slot for it.\n                    // If we allocate one, then the debugger will assume that the arguments symbol is there and skip creating the fake one.\n                }\n                else\n                {\n                    // All properties should get correct propertyId here.\n                    Assert(sym->HasScopeSlot()); // We can't allocate scope slot now. Any symbol needing scope slot must have allocated it before this point.\n                    setPropertyIdForScopeSlotArray(sym->GetScopeSlot(), sym->EnsurePosition(funcInfo));\n                }\n            }\n        };\n\n        funcInfo->GetBodyScope()->ForEachSymbol(setPropIdsForScopeSlotArray);\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->thisScopeSlot, Js::PropertyIds::_lexicalThisSlotSymbol);\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->newTargetScopeSlot, Js::PropertyIds::_lexicalNewTargetSymbol);\n        }\n\n        if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->superScopeSlot, Js::PropertyIds::_superReferenceSymbol);\n        }\n\n        if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->superCtorScopeSlot, Js::PropertyIds::_superCtorReferenceSymbol);\n        }\n\n#if DEBUG\n        for (UINT i = 0; i < scopeSlotCount; i++)\n        {\n            Assert(propertyIdsForScopeSlotArray[i] != Js::Constants::NoProperty\n                || funcInfo->frameObjRegister != Js::Constants::NoRegister); // ScopeObject may have unassigned entries, e.g. for same-named parameters\n        }\n#endif\n    }\n}\n\n// temporarily load all constants and special registers in a single block\nvoid ByteCodeGenerator::LoadAllConstants(FuncInfo *funcInfo)\n{\n    Symbol *sym;\n\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    byteCodeFunction->CreateConstantTable();\n\n    if (funcInfo->nullConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordNullObject(byteCodeFunction->MapRegSlot(funcInfo->nullConstantRegister));\n    }\n\n    if (funcInfo->undefinedConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordUndefinedObject(byteCodeFunction->MapRegSlot(funcInfo->undefinedConstantRegister));\n    }\n\n    if (funcInfo->trueConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordTrueObject(byteCodeFunction->MapRegSlot(funcInfo->trueConstantRegister));\n    }\n\n    if (funcInfo->falseConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordFalseObject(byteCodeFunction->MapRegSlot(funcInfo->falseConstantRegister));\n    }\n\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        m_writer.RecordObjectRegister(funcInfo->frameObjRegister);\n        if (!funcInfo->GetApplyEnclosesArgs())\n        {\n            this->EmitScopeObjectInit(funcInfo);\n        }\n\n#if DBG\n        uint count = 0;\n        funcInfo->GetBodyScope()->ForEachSymbol([&](Symbol *const sym)\n        {\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                // All properties should get correct propertyId here.\n                count++;\n            }\n        });\n\n        if (funcInfo->GetParamScope() != nullptr)\n        {\n            funcInfo->GetParamScope()->ForEachSymbol([&](Symbol *const sym)\n            {\n                if (sym->NeedsSlotAlloc(funcInfo))\n                {\n                    // All properties should get correct propertyId here.\n                    count++;\n                }\n            });\n        }\n\n        // A reparse should result in the same size of the activation object.\n        // Exclude functions which were created from the ByteCodeCache.\n        AssertMsg(!byteCodeFunction->IsReparsed() || byteCodeFunction->HasGeneratedFromByteCodeCache() ||\n            byteCodeFunction->scopeObjectSize == count || byteCodeFunction->m_wasEverAsmjsMode,\n            \"The activation object size is different between debug and non-debug mode\");\n        byteCodeFunction->scopeObjectSize = count;\n#endif\n    }\n    else if (funcInfo->frameSlotsRegister != Js::Constants::NoRegister)\n    {\n        int scopeSlotCount = funcInfo->bodyScope->GetScopeSlotCount();\n        int paramSlotCount = funcInfo->paramScope->GetScopeSlotCount();\n        if (scopeSlotCount == 0 && paramSlotCount == 0)\n        {\n            AssertMsg(funcInfo->frameDisplayRegister != Js::Constants::NoRegister, \"Why do we need scope slots?\");\n            m_writer.Reg1(Js::OpCode::LdC_A_Null, funcInfo->frameSlotsRegister);\n        }\n    }\n\n    if (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject())\n    {\n        byteCodeFunction->MapAndSetFuncExprScopeRegister(funcInfo->funcExprScope->GetLocation());\n        byteCodeFunction->SetEnvDepth((uint16)-1);\n    }\n\n    bool thisLoadedFromParams = false;\n\n    if (funcInfo->NeedEnvRegister())\n    {\n        byteCodeFunction->MapAndSetEnvRegister(funcInfo->GetEnvRegister());\n        if (funcInfo->GetIsTopLevelEventHandler())\n        {\n            byteCodeFunction->MapAndSetThisRegisterForEventHandler(funcInfo->thisPointerRegister);\n            // The environment is the namespace hierarchy starting with \"this\".\n            Assert(!funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n            thisLoadedFromParams = true;\n            this->InvalidateCachedOuterScopes(funcInfo);\n        }\n        else if (funcInfo->IsGlobalFunction() && !(this->flags & fscrEval))\n        {\n            Assert(funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n\n            if (funcInfo->GetIsStrictMode())\n            {\n                byteCodeFunction->RecordStrictNullDisplayConstant(byteCodeFunction->MapRegSlot(funcInfo->GetEnvRegister()));\n            }\n            else\n            {\n                byteCodeFunction->RecordNullDisplayConstant(byteCodeFunction->MapRegSlot(funcInfo->GetEnvRegister()));\n            }\n        }\n        else\n        {\n            // environment may be required to load \"this\"\n            Assert(!funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n            this->InvalidateCachedOuterScopes(funcInfo);\n        }\n    }\n\n    if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n    {\n        m_writer.RecordFrameDisplayRegister(funcInfo->frameDisplayRegister);\n    }\n\n    // new.target may be used to construct the 'this' register so make sure to load it first\n    if (funcInfo->newTargetRegister != Js::Constants::NoRegister)\n    {\n        this->LoadNewTargetObject(funcInfo);\n    }\n\n    if (funcInfo->thisPointerRegister != Js::Constants::NoRegister)\n    {\n        this->LoadThisObject(funcInfo, thisLoadedFromParams);\n    }\n\n    this->RecordAllIntConstants(funcInfo);\n    this->RecordAllStrConstants(funcInfo);\n    this->RecordAllStringTemplateCallsiteConstants(funcInfo);\n\n    funcInfo->doubleConstantToRegister.Map([byteCodeFunction](double d, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordFloatConstant(byteCodeFunction->MapRegSlot(location), d);\n    });\n\n    if (funcInfo->GetHasArguments())\n    {\n        sym = funcInfo->GetArgumentsSymbol();\n        Assert(sym);\n        Assert(funcInfo->GetHasHeapArguments());\n\n        if (funcInfo->GetCallsEval() || (!funcInfo->GetApplyEnclosesArgs()))\n        {\n            this->LoadHeapArguments(funcInfo);\n        }\n\n    }\n    else if (!funcInfo->IsGlobalFunction() && !IsInNonDebugMode())\n    {\n        uint count = funcInfo->inArgsCount + (funcInfo->root->sxFnc.pnodeRest != nullptr ? 1 : 0) - 1;\n        if (count != 0)\n        {\n            Js::PropertyIdArray *propIds = RecyclerNewPlus(scriptContext->GetRecycler(), count * sizeof(Js::PropertyId), Js::PropertyIdArray, count, 0);\n\n            GetFormalArgsArray(this, funcInfo, propIds);\n            byteCodeFunction->SetPropertyIdsOfFormals(propIds);\n        }\n    }\n\n    //\n    // If the function is a function expression with a name,\n    // load the function object at runtime to its activation object.\n    //\n    sym = funcInfo->root->sxFnc.GetFuncSymbol();\n    bool funcExprWithName = !funcInfo->IsGlobalFunction() && sym && sym->GetIsFuncExpr();\n\n    if (funcExprWithName)\n    {\n        if (funcInfo->GetFuncExprNameReference() ||\n            (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject()))\n        {\n            //\n            // x = function f(...) { ... }\n            // A named function expression's name (Symbol:f) belongs to the enclosing scope.\n            // Thus there are no uses of 'f' within the scope of the function (as references to 'f'\n            // are looked up in the closure). So, we can't use f's register as it is from the enclosing\n            // scope's register namespace. So use a tmp register.\n            // In ES5 mode though 'f' is *not* a part of the enclosing scope. So we always assign 'f' a register\n            // from it's register namespace, which LdFuncExpr can use.\n            //\n            Js::RegSlot ldFuncExprDst = sym->GetLocation();\n            this->m_writer.Reg1(Js::OpCode::LdFuncExpr, ldFuncExprDst);\n\n            if (sym->IsInSlot(funcInfo))\n            {\n                Js::RegSlot scopeLocation;\n                AnalysisAssert(funcInfo->funcExprScope);\n\n                if (funcInfo->funcExprScope->GetIsObject())\n                {\n                    scopeLocation = funcInfo->funcExprScope->GetLocation();\n                    this->m_writer.Property(Js::OpCode::StFuncExpr, sym->GetLocation(), scopeLocation,\n                        funcInfo->FindOrAddReferencedPropertyId(sym->GetPosition()));\n                }\n                else if (funcInfo->bodyScope->GetIsObject())\n                {\n                    this->m_writer.ElementU(Js::OpCode::StLocalFuncExpr, sym->GetLocation(),\n                        funcInfo->FindOrAddReferencedPropertyId(sym->GetPosition()));\n                }\n                else\n                {\n                    Assert(sym->HasScopeSlot());\n                    this->m_writer.SlotI1(Js::OpCode::StLocalSlot, sym->GetLocation(),\n                                          sym->GetScopeSlot() + Js::ScopeSlots::FirstSlotIndex);\n                }\n            }\n            else if (ShouldTrackDebuggerMetadata())\n            {\n                funcInfo->byteCodeFunction->GetFunctionBody()->InsertSymbolToRegSlotList(sym->GetName(), sym->GetLocation(), funcInfo->varRegsCount);\n            }\n        }\n    }\n}\n\nvoid ByteCodeGenerator::InvalidateCachedOuterScopes(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetEnvRegister() != Js::Constants::NoRegister);\n\n    // Walk the scope stack, from funcInfo outward, looking for scopes that have been cached.\n\n    Scope *scope = funcInfo->GetBodyScope()->GetEnclosingScope();\n    uint32 envIndex = 0;\n\n    while (scope && scope->GetFunc() == funcInfo)\n    {\n        // Skip over FuncExpr Scope and parameter scope for current funcInfo to get to the first enclosing scope of the outer function.\n        scope = scope->GetEnclosingScope();\n    }\n\n    for (; scope; scope = scope->GetEnclosingScope())\n    {\n        FuncInfo *func = scope->GetFunc();\n        if (scope == func->GetBodyScope())\n        {\n            if (func->Escapes() && func->GetHasCachedScope())\n            {\n                Assert(scope->GetIsObject());\n                this->m_writer.Unsigned1(Js::OpCode::InvalCachedScope, envIndex);\n            }\n        }\n        if (scope->GetMustInstantiate())\n        {\n            envIndex++;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::LoadThisObject(FuncInfo *funcInfo, bool thisLoadedFromParams)\n{\n    if (this->scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled() && funcInfo->IsClassConstructor())\n    {\n        // Derived class constructors initialize 'this' to be Undecl except \"extends null\" cases\n        //   - we'll check this value during a super call and during 'this' access\n        //\n        // Base class constructors or \"extends null\" cases initialize 'this' to a new object using new.target\n        if (funcInfo->IsBaseClassConstructor())\n        {\n            EmitBaseClassConstructorThisObject(funcInfo);\n        }\n        else\n        {\n            Js::ByteCodeLabel thisLabel = this->Writer()->DefineLabel();\n            Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n\n            Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n            this->Writer()->Reg1(Js::OpCode::LdFuncObj, tmpReg);\n            this->Writer()->BrReg1(Js::OpCode::BrOnBaseConstructorKind, thisLabel, tmpReg);  // branch when [[ConstructorKind]]==\"base\"\n            funcInfo->ReleaseTmpRegister(tmpReg);\n\n            this->m_writer.Reg1(Js::OpCode::InitUndecl, funcInfo->thisPointerRegister);  // not \"extends null\" case\n            this->Writer()->Br(Js::OpCode::Br, skipLabel);\n\n            this->Writer()->MarkLabel(thisLabel);\n            EmitBaseClassConstructorThisObject(funcInfo);  // \"extends null\" case\n\n            this->Writer()->MarkLabel(skipLabel);\n        }\n    }\n    else if (!funcInfo->IsGlobalFunction() || (this->flags & fscrEval))\n    {\n        //\n        // thisLoadedFromParams would be true for the event Handler case,\n        // \"this\" would have been loaded from parameters to put in the environment\n        //\n        if (!thisLoadedFromParams && !funcInfo->IsLambda())\n        {\n            m_writer.ArgIn0(funcInfo->thisPointerRegister);\n        }\n        if (!(this->flags & fscrEval) || !funcInfo->IsGlobalFunction())\n        {\n            // we don't want to emit 'this' for eval, because 'this' value in eval is equal to 'this' value of caller\n            // and does not depend on \"use strict\" inside of eval.\n            // so we pass 'this' directly in GlobalObject::EntryEval()\n            EmitThis(funcInfo, funcInfo->thisPointerRegister);\n        }\n    }\n    else\n    {\n        Assert(funcInfo->IsGlobalFunction());\n        Js::RegSlot root = funcInfo->nullConstantRegister;\n        EmitThis(funcInfo, root);\n    }\n}\n\nvoid ByteCodeGenerator::LoadNewTargetObject(FuncInfo *funcInfo)\n{\n    if (funcInfo->IsClassConstructor())\n    {\n        Assert(!funcInfo->IsLambda());\n\n        m_writer.ArgIn0(funcInfo->newTargetRegister);\n    }\n    else if (funcInfo->IsLambda() && !(this->flags & fscrEval))\n    {\n        Scope *scope;\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n        if (scope->GetFunc()->IsGlobalFunction())\n        {\n            m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);\n        }\n        else\n        {\n            Js::PropertyId slot = scope->GetFunc()->newTargetScopeSlot;\n            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->newTargetRegister);\n        }\n    }\n    else if ((funcInfo->IsGlobalFunction() || funcInfo->IsLambda()) && (this->flags & fscrEval))\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else if (funcInfo->NeedEnvRegister())\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor.\n            m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);\n            return;\n        }\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalNewTargetSymbol, false, false);\n        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->newTargetRegister, cacheId);\n    }\n    else if (funcInfo->IsGlobalFunction())\n    {\n        m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);\n    }\n    else\n    {\n        m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeSlotLoadThis(FuncInfo *funcInfo, Js::RegSlot regLoc, bool chkUndecl)\n{\n    FuncInfo* nonLambdaFunc = funcInfo;\n    if (funcInfo->IsLambda())\n    {\n        nonLambdaFunc = FindEnclosingNonLambda();\n    }\n\n    if (nonLambdaFunc->IsClassConstructor() && !nonLambdaFunc->IsBaseClassConstructor())\n    {\n        // If we are in a derived class constructor and we have a scope slot for 'this',\n        // we need to load 'this' from the scope slot. This is to support the case where\n        // the call to initialize 'this' via super() is inside a lambda since the lambda\n        // can't assign to the 'this' register of the parent constructor.\n        if (nonLambdaFunc->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            Js::PropertyId slot = nonLambdaFunc->thisScopeSlot;\n\n            EmitInternalScopedSlotLoad(funcInfo, slot, regLoc, chkUndecl);\n        }\n        else if (funcInfo->thisPointerRegister != Js::Constants::NoRegister && chkUndecl)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);\n        }\n        else if (chkUndecl)\n        {\n            // If we don't have a scope slot for 'this' we know that super could not have\n            // been called inside a lambda so we can check to see if we called\n            // super and assigned to the this register already. If not, this should trigger\n            // a ReferenceError.\n            EmitUseBeforeDeclarationRuntimeError(this, Js::Constants::NoRegister);\n        }\n    }\n    else if (this->flags & fscrEval && (funcInfo->IsGlobalFunction() || (funcInfo->IsLambda() && nonLambdaFunc->IsGlobalFunction()))\n        && funcInfo->GetBodyScope()->GetIsObject())\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else if (funcInfo->NeedEnvRegister())\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor\n            return;\n        }\n\n        // CONSIDER [tawoll] - Should we add a ByteCodeGenerator flag (fscrEvalWithClassConstructorParent) and avoid doing this runtime check?\n        Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n        this->Writer()->BrReg1(Js::OpCode::BrNotUndecl_A, skipLabel, funcInfo->thisPointerRegister);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalThisSlotSymbol, false, false);\n        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->thisPointerRegister, cacheId);\n        if (chkUndecl)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);\n        }\n\n        this->Writer()->MarkLabel(skipLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeSlotStoreThis(FuncInfo *funcInfo, Js::RegSlot regLoc, bool chkUndecl)\n{\n    if (this->flags & fscrEval && (funcInfo->IsGlobalFunction() || (funcInfo->IsLambda() && FindEnclosingNonLambda()->IsGlobalFunction())))\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalThisSlotSymbol, false, true);\n        this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo->byteCodeFunction->GetIsStrictMode()), funcInfo->thisPointerRegister, cacheId);\n    }\n    else if (regLoc != Js::Constants::NoRegister)\n    {\n        EmitInternalScopedSlotStore(funcInfo, regLoc, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitSuperCall(FuncInfo* funcInfo, ParseNode* pnode, BOOL fReturnValue)\n{\n    Assert(pnode->sxCall.pnodeTarget->nop == knopSuper);\n\n    FuncInfo* nonLambdaFunc = funcInfo;\n\n    if (funcInfo->IsLambda())\n    {\n        nonLambdaFunc = this->FindEnclosingNonLambda();\n    }\n\n    if (nonLambdaFunc->IsBaseClassConstructor())\n    {\n        // super() is not allowed in base class constructors. If we detect this, emit a ReferenceError and skip making the call.\n        this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_ClassSuperInBaseClass));\n        return;\n    }\n    else\n    {\n        EmitSuperFieldPatch(funcInfo, pnode, this);\n        pnode->isUsed = true;\n    }\n\n    // We already know pnode->sxCall.pnodeTarget->nop is super but we can't use the super register in case\n    // this is an eval and we will load super dynamically from the scope using ScopedLdHomeObj.\n    // That means we'll have to rely on the location of the call target to be sure.\n    // We have to make sure to allocate the location for the node now, before we try to branch on it.\n    Emit(pnode->sxCall.pnodeTarget, this, funcInfo, false, /*isConstructorCall*/ true); // reuse isConstructorCall (\"new super()\" is illegal)\n\n    //\n    // if (super is class constructor) {\n    //   _this = new.target;\n    // } else {\n    //   _this = NewScObjFull(new.target);\n    // }\n    //\n    // temp = super.call(_this, new.target); // CallFlag_New | CallFlag_NewTarget | CallFlag_ExtraArg\n    // if (temp is object) {\n    //   _this = temp;\n    // }\n    //\n    // if (UndeclBlockVar === this) {\n    //   this = _this;\n    // } else {\n    //   throw ReferenceError;\n    // }\n    //\n    funcInfo->AcquireLoc(pnode);\n    Js::RegSlot thisForSuperCall = funcInfo->AcquireTmpRegister();\n    Js::ByteCodeLabel useNewTargetForThisLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel makeCallLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel useSuperCallResultLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel doneLabel = this->Writer()->DefineLabel();\n\n    Js::RegSlot tmpReg = this->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnode->sxCall.pnodeTarget->location, funcInfo);\n    this->Writer()->BrReg1(Js::OpCode::BrOnClassConstructor, useNewTargetForThisLabel, tmpReg);\n\n    this->Writer()->Reg2(Js::OpCode::NewScObjectNoCtorFull, thisForSuperCall, funcInfo->newTargetRegister);\n    this->Writer()->Br(Js::OpCode::Br, makeCallLabel);\n\n    this->Writer()->MarkLabel(useNewTargetForThisLabel);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, thisForSuperCall, funcInfo->newTargetRegister);\n\n    this->Writer()->MarkLabel(makeCallLabel);\n    EmitCall(pnode, Js::Constants::NoRegister, this, funcInfo, fReturnValue, /*fEvaluateComponents*/ true, /*fHasNewTarget*/ true, thisForSuperCall);\n\n    // We have to use another temp for the this value before assigning to this register.\n    // This is because IRBuilder does not expect us to use the value of a temp after potentially assigning to that same temp.\n    // Ex:\n    // _this = new.target;\n    // temp = super.call(_this);\n    // if (temp is object) {\n    //   _this = temp; // creates a new sym for _this as it was previously used\n    // }\n    // this = _this; // tries to loads a value from the old sym (which is dead)\n    Js::RegSlot valueForThis = funcInfo->AcquireTmpRegister();\n\n    this->Writer()->BrReg1(Js::OpCode::BrOnObject_A, useSuperCallResultLabel, pnode->location);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, valueForThis, thisForSuperCall);\n    this->Writer()->Br(Js::OpCode::Br, doneLabel);\n    this->Writer()->MarkLabel(useSuperCallResultLabel);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, valueForThis, pnode->location);\n    this->Writer()->MarkLabel(doneLabel);\n\n    // The call is done and we know what we will bind to 'this' so let's check to see if 'this' is already decl.\n    // We may need to load 'this' from the scope slot.\n    EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister, false);\n\n    Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n    Js::RegSlot tmpUndeclReg = funcInfo->AcquireTmpRegister();\n    this->Writer()->Reg1(Js::OpCode::InitUndecl, tmpUndeclReg);\n    this->Writer()->BrReg2(Js::OpCode::BrSrEq_A, skipLabel, funcInfo->thisPointerRegister, tmpUndeclReg);\n    funcInfo->ReleaseTmpRegister(tmpUndeclReg);\n\n    this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_ClassThisAlreadyAssigned));\n    this->Writer()->MarkLabel(skipLabel);\n\n    this->Writer()->Reg2(Js::OpCode::StrictLdThis, funcInfo->thisPointerRegister, valueForThis);\n    funcInfo->ReleaseTmpRegister(valueForThis);\n    funcInfo->ReleaseTmpRegister(thisForSuperCall);\n\n    // We already assigned the result of super() to the 'this' register but we need to store it in the scope slot, too. If there is one.\n    this->EmitScopeSlotStoreThis(funcInfo, nonLambdaFunc->thisScopeSlot);\n}\n\nvoid ByteCodeGenerator::EmitClassConstructorEndCode(FuncInfo *funcInfo)\n{\n    if (funcInfo->thisPointerRegister != Js::Constants::NoRegister)\n    {\n        // We need to try and load 'this' from the scope slot, if there is one.\n        EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister);\n        this->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitBaseClassConstructorThisObject(FuncInfo *funcInfo)\n{\n    this->Writer()->Reg2(Js::OpCode::NewScObjectNoCtorFull, funcInfo->thisPointerRegister, funcInfo->newTargetRegister);\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotLoad(FuncInfo *funcInfo, Js::RegSlot slot, Js::RegSlot symbolRegister, bool chkUndecl)\n{\n    Scope* scope = nullptr;\n\n    if (funcInfo->IsLambda())\n    {\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, symbolRegister, chkUndecl);\n    }\n    else\n    {\n        scope = funcInfo->GetBodyScope();\n\n        EmitInternalScopedSlotLoad(funcInfo, scope, -1, slot, symbolRegister, chkUndecl);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotLoad(FuncInfo *funcInfo, Scope *scope, Js::PropertyId envIndex, Js::RegSlot slot, Js::RegSlot symbolRegister, bool chkUndecl)\n{\n    Assert(slot != Js::Constants::NoProperty);\n    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, symbolRegister);\n    Js::OpCode opcode;\n\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    opcode = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n    slot += (scope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n    if (envIndex != -1)\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n    {\n        this->m_writer.SlotI1(opcode, symbolRegister, slot, profileId);\n    }\n    else\n    {\n        this->m_writer.Slot(opcode, symbolRegister, scopeLocation, slot, profileId);\n    }\n\n    if (chkUndecl)\n    {\n        this->m_writer.Reg1(Js::OpCode::ChkUndecl, symbolRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotStore(FuncInfo *funcInfo, Js::RegSlot slot, Js::RegSlot symbolRegister)\n{\n    Assert(slot != Js::Constants::NoProperty);\n\n    Scope* scope = nullptr;\n    Js::OpCode opcode;\n\n    Js::PropertyId envIndex = -1;\n    if (funcInfo->IsLambda())\n    {\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n    }\n    else\n    {\n        scope = funcInfo->GetBodyScope();\n    }\n\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    opcode = this->GetStSlotOp(scope, envIndex, scopeLocation, false, funcInfo);\n    slot += (scope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n    if (envIndex != -1)\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot);\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n    {\n        this->m_writer.SlotI1(opcode, symbolRegister, slot);\n    }\n    else if (scope->GetIsObject())\n    {\n        this->m_writer.Slot(opcode, symbolRegister, scopeLocation, slot);\n    }\n    else\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, scope->GetInnerScopeIndex(), slot);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopeObjInit(FuncInfo *funcInfo, Scope *scope, Js::RegSlot valueLocation, Js::PropertyId propertyId)\n{\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    Js::OpCode opcode = this->GetInitFldOp(scope, scopeLocation, funcInfo);\n    if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n        this->m_writer.ElementP(opcode, valueLocation, cacheId);\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n        this->m_writer.ElementPIndexed(opcode, valueLocation, scope->GetInnerScopeIndex(), cacheId);\n    }\n    else\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n        this->m_writer.PatchableProperty(opcode, valueLocation, scopeLocation, cacheId);\n    }\n}\n\nvoid ByteCodeGenerator::GetEnclosingNonLambdaScope(FuncInfo *funcInfo, Scope * &scope, Js::PropertyId &envIndex)\n{\n    Assert(funcInfo->IsLambda());\n    envIndex = -1;\n    for (scope = GetCurrentScope(); scope; scope = scope->GetEnclosingScope())\n    {\n        if (scope->GetMustInstantiate() && scope->GetFunc() != funcInfo)\n        {\n            envIndex++;\n        }\n        if (((scope == scope->GetFunc()->GetBodyScope() || scope == scope->GetFunc()->GetParamScope()) && !scope->GetFunc()->IsLambda()) || scope->IsGlobalEvalBlockScope())\n        {\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitThis(FuncInfo *funcInfo, Js::RegSlot fromRegister)\n{\n    if (funcInfo->IsLambda())\n    {\n        Scope *scope;\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n        FuncInfo* parent = scope->GetFunc();\n\n        if (parent->IsGlobalFunction())\n        {\n            if (this->flags & fscrEval)\n            {\n                scope = parent->GetGlobalEvalBlockScope();\n                Js::PropertyId slot = parent->thisScopeSlot;\n                EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);\n            }\n            else\n            {\n                // Always load global object via LdThis of null to get the possibly protected via secureHostObject global object.\n                this->m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, funcInfo->nullConstantRegister, this->GetModuleID());\n            }\n        }\n        else if (!parent->IsClassConstructor() || parent->IsBaseClassConstructor())\n        {\n            // In a lambda inside a derived class constructor, 'this' should be loaded from the scope slot whenever 'this' is accessed.\n            // It's safe to load 'this' into the register for base class constructors because there is no complex assignment to 'this'\n            // via super call chain.\n            Js::PropertyId slot = parent->thisScopeSlot;\n            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);\n        }\n    }\n    else if (funcInfo->byteCodeFunction->GetIsStrictMode() && (!funcInfo->IsGlobalFunction() || this->flags & fscrEval))\n    {\n        m_writer.Reg2(Js::OpCode::StrictLdThis, funcInfo->thisPointerRegister, fromRegister);\n    }\n    else\n    {\n        m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, fromRegister, this->GetModuleID());\n    }\n}\n\nvoid ByteCodeGenerator::EmitLoadFormalIntoRegister(ParseNode *pnodeFormal, Js::RegSlot pos, FuncInfo *funcInfo)\n{\n    if (pnodeFormal->IsVarLetOrConst())\n    {\n        // Get the param from its argument position into its assigned register.\n        // The position should match the location, otherwise, it has been shadowed by parameter with the same name\n        Symbol *formal = pnodeFormal->sxVar.sym;\n        if (formal->GetLocation() + 1 == pos)\n        {\n            // Transfer to the frame object, etc., if necessary.\n            this->EmitLocalPropInit(formal->GetLocation(), formal, funcInfo);\n        }\n\n        if (ShouldTrackDebuggerMetadata() && !formal->IsInSlot(funcInfo))\n        {\n            Assert(!formal->GetHasInit());\n            funcInfo->GetParsedFunctionBody()->InsertSymbolToRegSlotList(formal->GetName(), formal->GetLocation(), funcInfo->varRegsCount);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::HomeArguments(FuncInfo *funcInfo)\n{\n    // Transfer formal parameters to their home locations on the local frame.\n    if (funcInfo->GetHasArguments())\n    {\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            // Since we don't have to iterate over arguments here, we'll trust the location to be correct.\n            EmitLoadFormalIntoRegister(funcInfo->root->sxFnc.pnodeRest, funcInfo->root->sxFnc.pnodeRest->sxVar.sym->GetLocation() + 1, funcInfo);\n        }\n\n        // The arguments object creation helper does this work for us.\n        return;\n    }\n\n    Js::ArgSlot pos = 1;\n    auto loadFormal = [&](ParseNode *pnodeFormal)\n    {\n        EmitLoadFormalIntoRegister(pnodeFormal, pos, funcInfo);\n        pos++;\n    };\n    MapFormals(funcInfo->root, loadFormal);\n}\n\nvoid ByteCodeGenerator::DefineLabels(FuncInfo *funcInfo)\n{\n    funcInfo->singleExit = m_writer.DefineLabel();\n    SList<ParseNode *>::Iterator iter(&funcInfo->targetStatements);\n    while (iter.Next())\n    {\n        ParseNode * node = iter.Data();\n        node->sxStmt.breakLabel = m_writer.DefineLabel();\n        node->sxStmt.continueLabel = m_writer.DefineLabel();\n        node->emitLabels = true;\n    }\n}\n\nvoid ByteCodeGenerator::EmitGlobalBody(FuncInfo *funcInfo)\n{\n    // Emit global code (global scope or eval), fixing up the return register with the implicit\n    // return value.\n    ParseNode *pnode = funcInfo->root->sxFnc.pnodeBody;\n    ParseNode *pnodeLastVal = funcInfo->root->sxProg.pnodeLastValStmt;\n    if (pnodeLastVal == nullptr)\n    {\n        // We're not guaranteed to compute any values, so fix up the return register at the top\n        // in case.\n        this->m_writer.Reg1(Js::OpCode::LdUndef, ReturnRegister);\n    }\n\n    while (pnode->nop == knopList)\n    {\n        ParseNode *stmt = pnode->sxBin.pnode1;\n        if (stmt == pnodeLastVal)\n        {\n            pnodeLastVal = nullptr;\n        }\n        if (pnodeLastVal == nullptr && (this->flags & fscrReturnExpression))\n        {\n            EmitTopLevelStatement(stmt, funcInfo, true);\n        }\n        else\n        {\n            // Haven't hit the post-dominating return value yet,\n            // so don't bother with the return register.\n            EmitTopLevelStatement(stmt, funcInfo, false);\n        }\n        pnode = pnode->sxBin.pnode2;\n    }\n    EmitTopLevelStatement(pnode, funcInfo, false);\n}\n\nvoid ByteCodeGenerator::EmitFunctionBody(FuncInfo *funcInfo)\n{\n    // Emit a function body. Only explicit returns and the implicit \"undef\" at the bottom\n    // get copied to the return register.\n    ParseNode *pnodeBody = funcInfo->root->sxFnc.pnodeBody;\n    ParseNode *pnode = pnodeBody;\n    while (pnode->nop == knopList)\n    {\n        ParseNode *stmt = pnode->sxBin.pnode1;\n        if (stmt->CapturesSyms())\n        {\n            CapturedSymMap *map = funcInfo->EnsureCapturedSymMap();\n            SList<Symbol*> *list = map->Item(stmt);\n            FOREACH_SLIST_ENTRY(Symbol*, sym, list)\n            {\n                if (!sym->GetIsCommittedToSlot())\n                {\n                    Assert(sym->GetLocation() != Js::Constants::NoProperty);\n                    sym->SetIsCommittedToSlot();\n                    ParseNode *decl = sym->GetDecl();\n                    Assert(decl);\n                    if (PHASE_TRACE(Js::DelayCapturePhase, funcInfo->byteCodeFunction))\n                    {\n                        Output::Print(_u(\"--- DelayCapture: Committed symbol '%s' to slot.\\n\"), sym->GetName());\n                        Output::Flush();\n                    }\n                    // REVIEW[ianhall]: HACK to work around this causing an error due to sym not yet being initialized\n                    // what is this doing? Why are we assigning sym to itself?\n                    bool old = sym->GetNeedDeclaration();\n                    sym->SetNeedDeclaration(false);\n                    this->EmitPropStore(sym->GetLocation(), sym, sym->GetPid(), funcInfo, decl->nop == knopLetDecl, decl->nop == knopConstDecl);\n                    sym->SetNeedDeclaration(old);\n                }\n            }\n            NEXT_SLIST_ENTRY;\n        }\n        EmitTopLevelStatement(stmt, funcInfo, false);\n        pnode = pnode->sxBin.pnode2;\n    }\n    Assert(!pnode->CapturesSyms());\n    EmitTopLevelStatement(pnode, funcInfo, false);\n}\n\nvoid ByteCodeGenerator::EmitProgram(ParseNode *pnodeProg)\n{\n    // Indicate that the binding phase is over.\n    this->isBinding = false;\n    this->trackEnvDepth = true;\n    AssignPropertyIds(pnodeProg->sxFnc.funcInfo->byteCodeFunction);\n\n    int32 initSize = this->maxAstSize / AstBytecodeRatioEstimate;\n\n    // Use the temp allocator in bytecode write temp buffer.\n    m_writer.InitData(this->alloc, initSize);\n\n#ifdef LOG_BYTECODE_AST_RATIO\n    // log the max Ast size\n    Output::Print(_u(\"Max Ast size: %d\"), initSize);\n#endif\n\n    Assert(pnodeProg && pnodeProg->nop == knopProg);\n\n    if (this->parentScopeInfo)\n    {\n        // Scope stack is already set up the way we want it, so don't visit the global scope.\n        // Start emitting with the nested scope (i.e., the deferred function).\n        this->EmitScopeList(pnodeProg->sxProg.pnodeScopes);\n    }\n    else\n    {\n        this->EmitScopeList(pnodeProg);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInitCapturedThis(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        // Ensure space for the this slot\n        this->EmitInternalScopeObjInit(funcInfo, scope, funcInfo->thisPointerRegister, Js::PropertyIds::_lexicalThisSlotSymbol);\n    }\n    else\n    {\n        this->EmitInternalScopedSlotStore(funcInfo, funcInfo->thisScopeSlot, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInitCapturedNewTarget(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        // Ensure space for the new.target slot\n        this->EmitInternalScopeObjInit(funcInfo, scope, funcInfo->newTargetRegister, Js::PropertyIds::_lexicalNewTargetSymbol);\n    }\n    else\n    {\n        this->EmitInternalScopedSlotStore(funcInfo, funcInfo->newTargetScopeSlot, funcInfo->newTargetRegister);\n    }\n}\n\nvoid EmitDestructuredObject(ParseNode *lhs, Js::RegSlot rhsLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitDestructuredValueOrInitializer(ParseNodePtr lhsElementNode, Js::RegSlot rhsLocation, ParseNodePtr initializer, bool isNonPatternAssignmentTarget, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\n\nvoid ByteCodeGenerator::PopulateFormalsScope(uint beginOffset, FuncInfo *funcInfo, ParseNode *pnode)\n{\n    Js::DebuggerScope *debuggerScope = nullptr;\n    auto processArg = [&](ParseNode *pnodeArg) {\n        if (pnodeArg->IsVarLetOrConst())\n        {\n            if (debuggerScope == nullptr)\n            {\n                debuggerScope = RecordStartScopeObject(pnode, funcInfo->paramScope && funcInfo->paramScope->GetIsObject() ? Js::DiagParamScopeInObject : Js::DiagParamScope);\n                debuggerScope->SetBegin(beginOffset);\n            }\n\n            debuggerScope->AddProperty(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym->EnsurePosition(funcInfo), Js::DebuggerScopePropertyFlags_None);\n        }\n    };\n\n    MapFormals(pnode, processArg);\n    MapFormalsFromPattern(pnode, processArg);\n\n    if (debuggerScope != nullptr)\n    {\n        RecordEndScopeObject(pnode);\n    }\n}\n\nvoid ByteCodeGenerator::EmitDefaultArgs(FuncInfo *funcInfo, ParseNode *pnode)\n{\n    uint beginOffset = m_writer.GetCurrentOffset();\n\n    auto emitDefaultArg = [&](ParseNode *pnodeArg)\n    {\n        if (pnodeArg->nop == knopParamPattern)\n        {\n            this->StartStatement(pnodeArg);\n\n            Assert(pnodeArg->sxParamPattern.location != Js::Constants::NoRegister);\n            ParseNodePtr pnode1 = pnodeArg->sxParamPattern.pnode1;\n\n            if (pnode1->IsPattern())\n            {\n                EmitAssignment(nullptr, pnode1, pnodeArg->sxParamPattern.location, this, funcInfo);\n            }\n            else\n            {\n                Assert(pnode1->nop == knopAsg);\n                Assert(pnode1->sxBin.pnode1->IsPattern());\n                EmitDestructuredValueOrInitializer(pnode1->sxBin.pnode1,\n                    pnodeArg->sxParamPattern.location,\n                    pnode1->sxBin.pnode2,\n                    false /*isNonPatternAssignmentTarget*/,\n                    this,\n                    funcInfo);\n            }\n            this->EndStatement(pnodeArg);\n            return;\n        }\n        else if (pnodeArg->IsVarLetOrConst())\n        {\n            Js::RegSlot location = pnodeArg->sxVar.sym->GetLocation();\n\n            if (pnodeArg->sxVar.pnodeInit == nullptr)\n            {\n                // Since the formal hasn't been initialized in LdLetHeapArguments, we'll initialize it here.\n                pnodeArg->sxVar.sym->SetNeedDeclaration(false);\n                EmitPropStore(location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                return;\n            }\n\n            // Load the default argument if we got undefined, skip RHS evaluation otherwise.\n            Js::ByteCodeLabel noDefaultLabel = this->m_writer.DefineLabel();\n            Js::ByteCodeLabel endLabel = this->m_writer.DefineLabel();\n            this->StartStatement(pnodeArg);\n            // Let us use strict not equal to differentiate between null and undefined\n            m_writer.BrReg2(Js::OpCode::BrSrNeq_A, noDefaultLabel, location, funcInfo->undefinedConstantRegister);\n\n            Emit(pnodeArg->sxVar.pnodeInit, this, funcInfo, false);\n            pnodeArg->sxVar.sym->SetNeedDeclaration(false); // After emit to prevent foo(a = a)\n\n            if (funcInfo->GetHasArguments() && pnodeArg->sxVar.sym->IsInSlot(funcInfo))\n            {\n                EmitPropStore(pnodeArg->sxVar.pnodeInit->location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                m_writer.Br(endLabel);\n            }\n            else\n            {\n                EmitAssignment(nullptr, pnodeArg, pnodeArg->sxVar.pnodeInit->location, this, funcInfo);\n            }\n\n            funcInfo->ReleaseLoc(pnodeArg->sxVar.pnodeInit);\n\n            m_writer.MarkLabel(noDefaultLabel);\n\n            if (funcInfo->GetHasArguments() && pnodeArg->sxVar.sym->IsInSlot(funcInfo))\n            {\n                EmitPropStore(location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                m_writer.MarkLabel(endLabel);\n            }\n\n            this->EndStatement(pnodeArg);\n        }\n    };\n\n    // If the function is async, we wrap the default arguments in a try catch and reject a Promise in case of error.\n    if (pnode->sxFnc.IsAsync())\n    {\n        uint cacheId;\n        Js::ByteCodeLabel catchLabel = m_writer.DefineLabel();\n        Js::ByteCodeLabel doneLabel = m_writer.DefineLabel();\n        Js::RegSlot catchArgLocation = funcInfo->AcquireTmpRegister();\n        Js::RegSlot promiseLocation = funcInfo->AcquireTmpRegister();\n        Js::RegSlot rejectLocation = funcInfo->AcquireTmpRegister();\n\n        // try\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n        m_writer.Br(Js::OpCode::TryCatch, catchLabel);\n\n        // Rest cannot have a default argument, so we ignore it.\n        MapFormalsWithoutRest(pnode, emitDefaultArg);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n        m_writer.Empty(Js::OpCode::Leave);\n        m_writer.Br(doneLabel);\n\n        // catch\n        m_writer.MarkLabel(catchLabel);\n        m_writer.Reg1(Js::OpCode::Catch, catchArgLocation);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n        m_writer.Empty(Js::OpCode::Nop);\n\n        // return Promise.reject(error);\n        cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(Js::PropertyIds::Promise, false, false);\n        m_writer.PatchableRootProperty(Js::OpCode::LdRootFld, promiseLocation, cacheId, false, false);\n\n        EmitInvoke(rejectLocation, promiseLocation, Js::PropertyIds::reject, this, funcInfo, catchArgLocation);\n\n        m_writer.Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, rejectLocation);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n        m_writer.Empty(Js::OpCode::Leave);\n        m_writer.Br(funcInfo->singleExit);\n        m_writer.Empty(Js::OpCode::Leave);\n\n        m_writer.MarkLabel(doneLabel);\n\n        this->SetHasTry(true);\n\n        funcInfo->ReleaseTmpRegister(rejectLocation);\n        funcInfo->ReleaseTmpRegister(promiseLocation);\n        funcInfo->ReleaseTmpRegister(catchArgLocation);\n    }\n    else\n    {\n        // Rest cannot have a default argument, so we ignore it.\n        MapFormalsWithoutRest(pnode, emitDefaultArg);\n    }\n\n    if (m_writer.GetCurrentOffset() > beginOffset)\n    {\n        PopulateFormalsScope(beginOffset, funcInfo, pnode);\n    }\n}\n\nvoid ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n{\n    Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));\n    FuncInfo *funcInfo = pnode->sxFnc.funcInfo;\n    Assert(funcInfo != nullptr);\n\n    if (funcInfo->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;\n    deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));\n    deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),\n        funcInfo->root,\n        !!(this->flags & fscrEvalCode),\n        ((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));\n\n    deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);\n    if (pnode->sxFnc.HasDefaultArguments())\n    {\n        deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);\n    }\n\n    if (funcInfo->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            deferParseFunction->BuildDeferredStubs(funcInfo->root);\n        }\n        Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // We've now done a full parse of this function, so we no longer need to remember the extents\n    // and attributes of the top-level nested functions. (The above code has run for all of those,\n    // so they have pointers to the stub sub-trees they need.)\n    byteCodeFunction->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!funcInfo->IsGlobalFunction())\n        {\n            // Note: Do not set the stack nested func flag if the function has been redeferred and recompiled.\n            // In that case the flag already has the value we want.\n            if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)\n            {\n#if DBG\n                byteCodeFunction->SetCanDoStackNestedFunc();\n#endif\n                if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    byteCodeFunction->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (byteCodeFunction->DoStackNestedFunc())\n        {\n            uint nestedCount = byteCodeFunction->GetNestedCount();\n            for (uint i = 0; i < nestedCount; i++)\n            {\n                Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);\n                if (nested->IsFunctionBody())\n                {\n                    nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (byteCodeFunction->GetByteCode() != nullptr)\n        {\n            // Previously compiled function nested within a re-deferred and re-compiled function.\n            return;\n        }\n\n        // Bug : 301517\n        // In the debug mode the hasOnlyThis optimization needs to be disabled, since user can break in this function\n        // and do operation on 'this' and its property, which may not be defined yet.\n        if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            byteCodeFunction->SetHasOnlyThisStmts(true);\n        }\n\n        if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))\n            {\n                bool applyEnclosesArgs = true;\n                for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)\n                {\n                    Symbol* sym = pnodeVar->sxVar.sym;\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                    {\n                        applyEnclosesArgs = false;\n                        break;\n                    }\n                }\n                auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)\n                {\n                    if (*applyEnclosesArgs)\n                    {\n                        for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)\n                        {\n                            Symbol* sym = lexvar->sxVar.sym;\n                            if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                            {\n                                *applyEnclosesArgs = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);\n                funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);\n            }\n        }\n\n        InitScopeSlotArray(funcInfo);\n        FinalizeRegisters(funcInfo, byteCodeFunction);\n        DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);\n\n        // Reserve temp registers for the inner scopes. We prefer temps because the JIT will then renumber them\n        // and see different lifetimes. (Note that debug mode requires permanent registers. See FinalizeRegisters.)\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n            if (innerScopeCount)\n            {\n                funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());\n                for (uint i = 1; i < innerScopeCount; i++)\n                {\n                    funcInfo->AcquireTmpRegister();\n                }\n            }\n        }\n\n        funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,\n            alloc,\n            funcInfo->RegCount() // Pass the actual register count. // TODO: Check if we can reduce this count\n            );\n        funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n\n        byteCodeFunction->AllocateLiteralRegexArray();\n        m_callSiteId = 0;\n        m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), funcInfo);\n\n        this->inPrologue = true;\n\n        // Class constructors do not have a [[call]] slot but we don't implement a generic way to express this.\n        // What we do is emit a check for the new flag here. If we don't have CallFlags_New set, the opcode will throw.\n        // We need to do this before emitting 'this' since the base class constructor will try to construct a new object.\n        if (funcInfo->IsClassConstructor())\n        {\n            m_writer.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* currentScope = funcInfo->GetCurrentChildScope();\n        Scope* paramScope = funcInfo->GetParamScope();\n        Scope* bodyScope = funcInfo->GetBodyScope();\n\n        // For now, emit all constant loads at top of function (should instead put in closest dominator of uses).\n        LoadAllConstants(funcInfo);\n        HomeArguments(funcInfo);\n\n        if (!currentScope->GetCanMergeWithBodyScope())\n        {\n            byteCodeFunction->SetParamAndBodyScopeNotMerged();\n\n            // Pop the body scope before emitting the default args\n            PopScope();\n            Assert(this->GetCurrentScope() == paramScope);\n        }\n\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            byteCodeFunction->SetHasRestParameter();\n        }\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))\n        {\n            EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);\n        }\n\n        // Any function with a super reference or an eval call inside a method or a constructor needs to load super,\n        if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))\n            // unless we are already inside the 'global' scope inside an eval (in which case 'ScopedLdHomeObj' is emitted at every 'super' reference).\n            && !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))\n        {\n            if (funcInfo->IsLambda())\n            {\n                Scope *scope;\n                Js::PropertyId envIndex = -1;\n                GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n                FuncInfo* parent = scope->GetFunc();\n\n                if (!parent->IsGlobalFunction())\n                {\n                    // lambda in non-global scope (eval and non-eval)\n                    EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);\n                    if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & fscrEval))\n                {\n                    // lambda in non-eval global scope\n                    m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);\n                }\n                // lambda in eval global scope: ScopedLdHomeObj will handle error throwing\n            }\n            else\n            {\n                m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);\n\n                if (funcInfo->superCtorRegister != Js::Constants::NoRegister) // super() is allowed only in derived class constructors\n                {\n                    m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);\n                }\n\n                if (!funcInfo->IsGlobalFunction())\n                {\n                    if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        // Stash the super reference in case something inside the eval or lambda references it.\n                        uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n                        }\n                    }\n                    else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        // While the diag locals walker will pick up super from scoped slots or an activation object,\n                        // it will not pick it up when it is only in a register.\n                        byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(funcInfo, bodyScope);\n        }\n\n        // We don't want to load super if we are already in an eval. ScopedLdHomeObj will take care of loading super in that case.\n        if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())\n        {\n            if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);\n            }\n\n            if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);\n            }\n        }\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        ::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        DefineLabels(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n\n            EmitDefaultArgs(funcInfo, pnode);\n\n            if (!currentScope->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == paramScope);\n                // Push the body scope\n                PushScope(bodyScope);\n\n                funcInfo->SetCurrentChildScope(bodyScope);\n\n                // Mark the beginning of the body scope so that new scope slots can be created.\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(funcInfo);\n\n        // Emit all scope-wide function definitions before emitting function bodies\n        // so that calls may reference functions they precede lexically.\n        // Note, global eval scope is a fake local scope and is handled as if it were\n        // a lexical block instead of a true global scope, so do not define the functions\n        // here. They will be defined during BeginEmitBlock.\n        if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            // This only handles function declarations, which param scope cannot have any.\n            DefineFunctions(funcInfo);\n        }\n\n        DefineUserVars(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))\n        {\n            // If we didn't create a scope object and didn't have default args, we still need to transfer the formals to their slots.\n            MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });\n        }\n\n        // Rest needs to trigger use before declaration until all default args have been processed.\n        if (pnode->sxFnc.pnodeRest != nullptr)\n        {\n            pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n        {\n            // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n            // We have to do this after the rest param is marked as false for need declaration.\n            paramScope->ForEachSymbol([&](Symbol* param) {\n                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));\n                if (param->GetIsArguments() && !funcInfo->GetHasArguments())\n                {\n                    // Do not copy the arguments to the body if it is not used\n                }\n                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))\n                {\n                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                    // Walking the scope chain is not possible at this time.\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))\n                    {\n                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);\n                    }\n\n                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            });\n\n            // In split scope as the body has a separate closure we have to copy the value of this and other special slots\n            // from param scope to the body scope\n            auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)\n            {\n                if (dest != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = src;\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(op, tempReg, slot);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            };\n            copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n\n        this->inPrologue = false;\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EmitGlobalBody(funcInfo);\n        }\n        else\n        {\n            EmitFunctionBody(funcInfo);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n        ::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        if (!this->IsInDebugMode())\n        {\n            // Release the temp registers that we reserved for inner scopes above.\n            if (innerScopeCount)\n            {\n                Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;\n                for (uint i = 0; i < innerScopeCount; i++)\n                {\n                    funcInfo->ReleaseTmpRegister(tmpReg);\n                    tmpReg--;\n                }\n            }\n        }\n\n        Assert(funcInfo->firstTmpReg == firstTmpReg);\n        Assert(funcInfo->curTmpReg == firstTmpReg);\n        Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());\n\n        byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);\n        byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);\n        byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());\n\n        // Do a uint32 add just to verify that we haven't overflowed the reg slot type.\n        UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);\n\n#if DBG_DUMP\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                m_writer.ByteCodeDataSize(),\n                m_writer.AuxiliaryDataSize(),\n                m_writer.AuxiliaryContextDataSize(),\n                m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),\n                funcInfo->name);\n\n            this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(funcInfo);\n        this->MapReferencedPropertyIds(funcInfo);\n\n        Assert(this->TopFuncInfo() == funcInfo);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        m_writer.SetCallSiteCount(m_callSiteId);\n#ifdef LOG_BYTECODE_AST_RATIO\n        m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);\n#else\n        m_writer.End();\n#endif\n    }\n    catch (...)\n    {\n        // Failed to generate byte-code for this function body (likely OOM or stack overflow). Notify the function body so that\n        // it can revert intermediate state changes that may have taken place during byte code generation before the failure.\n        byteCodeFunction->ResetByteCodeGenState();\n        m_writer.Reset();\n        throw;\n    }\n\n#ifdef PERF_HINT\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())\n    {\n        if (byteCodeFunction->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);\n        }\n\n        if (funcInfo->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);\n        }\n        else if (funcInfo->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);\n        }\n    }\n#endif\n\n\n    byteCodeFunction->SetInitialDefaultEntryPoint();\n    byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode()) // debug mode mismatch\n    {\n        if (m_utf8SourceInfo->GetIsLibraryCode())\n        {\n            Assert(!byteCodeFunction->IsInDebugMode()); // Library script byteCode is never in debug mode\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if DBG_DUMP\n    if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        pnode->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(byteCodeFunction);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))\n    {\n        byteCodeFunction->DumpScopes();\n    }\n#endif\n#if ENABLE_NATIVE_CODEGEN\n    if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);\n    }\n#endif\n}\n\nvoid ByteCodeGenerator::MapCacheIdsToPropertyIds(FuncInfo *funcInfo)\n{\n    Js::FunctionBody *functionBody = funcInfo->GetParsedFunctionBody();\n    uint rootObjectLoadInlineCacheStart = funcInfo->GetInlineCacheCount();\n    uint rootObjectLoadMethodInlineCacheStart = rootObjectLoadInlineCacheStart + funcInfo->GetRootObjectLoadInlineCacheCount();\n    uint rootObjectStoreInlineCacheStart = rootObjectLoadMethodInlineCacheStart + funcInfo->GetRootObjectLoadMethodInlineCacheCount();\n    uint totalFieldAccessInlineCacheCount = rootObjectStoreInlineCacheStart + funcInfo->GetRootObjectStoreInlineCacheCount();\n\n    functionBody->CreateCacheIdToPropertyIdMap(rootObjectLoadInlineCacheStart, rootObjectLoadMethodInlineCacheStart,\n        rootObjectStoreInlineCacheStart, totalFieldAccessInlineCacheCount, funcInfo->GetIsInstInlineCacheCount());\n\n    if (totalFieldAccessInlineCacheCount == 0)\n    {\n        return;\n    }\n\n    funcInfo->inlineCacheMap->Map([functionBody](Js::RegSlot regSlot, FuncInfo::InlineCacheIdMap *inlineCacheIdMap)\n    {\n        inlineCacheIdMap->Map([functionBody](Js::PropertyId propertyId, FuncInfo::InlineCacheList* inlineCacheList)\n        {\n            if (inlineCacheList)\n            {\n                inlineCacheList->Iterate([functionBody, propertyId](InlineCacheUnit cacheUnit)\n                {\n                    CompileAssert(offsetof(InlineCacheUnit, cacheId) == offsetof(InlineCacheUnit, loadCacheId));\n                    if (cacheUnit.loadCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.loadCacheId, propertyId);\n                    }\n                    if (cacheUnit.loadMethodCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.loadMethodCacheId, propertyId);\n                    }\n                    if (cacheUnit.storeCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.storeCacheId, propertyId);\n                    }\n                });\n            }\n        });\n    });\n\n    funcInfo->rootObjectLoadInlineCacheMap->Map([functionBody, rootObjectLoadInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectLoadInlineCacheStart, propertyId);\n    });\n    funcInfo->rootObjectLoadMethodInlineCacheMap->Map([functionBody, rootObjectLoadMethodInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectLoadMethodInlineCacheStart, propertyId);\n    });\n    funcInfo->rootObjectStoreInlineCacheMap->Map([functionBody, rootObjectStoreInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectStoreInlineCacheStart, propertyId);\n    });\n\n    SListBase<uint>::Iterator valueOfIter(&funcInfo->valueOfStoreCacheIds);\n    while (valueOfIter.Next())\n    {\n        functionBody->SetPropertyIdForCacheId(valueOfIter.Data(), Js::PropertyIds::valueOf);\n    }\n\n    SListBase<uint>::Iterator toStringIter(&funcInfo->toStringStoreCacheIds);\n    while (toStringIter.Next())\n    {\n        functionBody->SetPropertyIdForCacheId(toStringIter.Data(), Js::PropertyIds::toString);\n    }\n\n#if DBG\n    functionBody->VerifyCacheIdToPropertyIdMap();\n#endif\n}\n\nvoid ByteCodeGenerator::MapReferencedPropertyIds(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *functionBody = funcInfo->GetParsedFunctionBody();\n    uint referencedPropertyIdCount = funcInfo->GetReferencedPropertyIdCount();\n    functionBody->CreateReferencedPropertyIdMap(referencedPropertyIdCount);\n\n    funcInfo->referencedPropertyIdToMapIndex->Map([functionBody](Js::PropertyId propertyId, uint mapIndex)\n    {\n        functionBody->SetReferencedPropertyIdWithMapIndex(mapIndex, propertyId);\n    });\n\n#if DBG\n    functionBody->VerifyReferencedPropertyIdMap();\n#endif\n}\n\nvoid ByteCodeGenerator::EmitScopeList(ParseNode *pnode, ParseNode *breakOnBodyScopeNode)\n{\n    while (pnode)\n    {\n        if (breakOnBodyScopeNode != nullptr && breakOnBodyScopeNode == pnode)\n        {\n            break;\n        }\n\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n#ifdef ASMJS_PLAT\n            if (pnode->sxFnc.GetAsmjsMode())\n            {\n                Js::ExclusiveContext context(this, GetScriptContext());\n                if (Js::AsmJSCompiler::Compile(&context, pnode, pnode->sxFnc.pnodeParams))\n                {\n                    pnode = pnode->sxFnc.pnodeNext;\n                    break;\n                }\n                else if (CONFIG_FLAG(AsmJsStopOnError))\n                {\n                    exit(JSERR_AsmJsCompileError);\n                }\n                else\n                {\n                    // if asm.js parse error happened, reparse with asm.js disabled.\n                    throw Js::AsmJsParseException();\n                }\n            }\n#endif\n            // FALLTHROUGH\n        case knopProg:\n            if (pnode->sxFnc.funcInfo)\n            {\n                FuncInfo* funcInfo = pnode->sxFnc.funcInfo;\n                Scope* paramScope = funcInfo->GetParamScope();\n\n                if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n                {\n                    funcInfo->SetCurrentChildScope(paramScope);\n                }\n                else\n                {\n                    funcInfo->SetCurrentChildScope(funcInfo->GetBodyScope());\n                }\n                this->StartEmitFunction(pnode);\n\n                // Persist outer func scope info if nested func is deferred\n                if (CONFIG_FLAG(DeferNested))\n                {\n                    FuncInfo* parentFunc = TopFuncInfo();\n                    Js::ScopeInfo::SaveScopeInfoForDeferParse(this, parentFunc, funcInfo);\n                    PushFuncInfo(_u(\"StartEmitFunction\"), funcInfo);\n                }\n\n                if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n                {\n                    // Before emitting the body scoped functions let us switch the special scope slot to use the body ones\n                    pnode->sxFnc.funcInfo->UseInnerSpecialScopeSlots();\n                    this->EmitScopeList(pnode->sxFnc.pnodeBodyScope->sxBlock.pnodeScopes);\n                }\n                else\n                {\n                    this->EmitScopeList(pnode->sxFnc.pnodeScopes);\n                }\n\n                this->EmitOneFunction(pnode);\n                this->EndEmitFunction(pnode);\n\n                Assert(pnode->sxFnc.pnodeBody == nullptr || funcInfo->isReused || funcInfo->GetCurrentChildScope() == funcInfo->GetBodyScope());\n                funcInfo->SetCurrentChildScope(nullptr);\n            }\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n\n        case knopBlock:\n            this->StartEmitBlock(pnode);\n            this->EmitScopeList(pnode->sxBlock.pnodeScopes);\n            this->EndEmitBlock(pnode);\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n\n        case knopCatch:\n            this->StartEmitCatch(pnode);\n            this->EmitScopeList(pnode->sxCatch.pnodeScopes);\n            this->EndEmitCatch(pnode);\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            this->StartEmitWith(pnode);\n            this->EmitScopeList(pnode->sxWith.pnodeScopes);\n            this->EndEmitWith(pnode);\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n\n        default:\n            AssertMsg(false, \"Unexpected opcode in tree of scopes\");\n            break;\n        }\n    }\n}\n\nvoid EnsureFncDeclScopeSlot(ParseNode *pnodeFnc, FuncInfo *funcInfo)\n{\n    if (pnodeFnc->sxFnc.pnodeName)\n    {\n        Assert(pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl);\n        Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n        // If this function is shadowing the arguments symbol in body then skip it.\n        // We will allocate scope slot for the arguments symbol during EmitLocalPropInit.\n        if (sym && !sym->GetIsArguments())\n        {\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n}\n\n// Similar to EnsureFncScopeSlot visitor function, but verifies that a slot is needed before assigning it.\nvoid CheckFncDeclScopeSlot(ParseNode *pnodeFnc, FuncInfo *funcInfo)\n{\n    if (pnodeFnc->sxFnc.pnodeName && pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl)\n    {\n        Assert(pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl);\n        Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n        if (sym && sym->NeedsSlotAlloc(funcInfo))\n        {\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EnsureSpecialScopeSlots(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        if (funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n\n        if (((!funcInfo->IsLambda() && funcInfo->GetCallsEval())\n            || funcInfo->isSuperLexicallyCaptured))\n        {\n            if (funcInfo->superRegister != Js::Constants::NoRegister)\n            {\n                funcInfo->EnsureSuperScopeSlot();\n            }\n\n            if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n            {\n                funcInfo->EnsureSuperCtorScopeSlot();\n            }\n        }\n\n        if (funcInfo->isNewTargetLexicallyCaptured)\n        {\n            funcInfo->EnsureNewTargetScopeSlot();\n        }\n    }\n    else\n    {\n        // Don't rely on the Emit() pass to assign scope slots where needed, because peeps/shortcuts\n        // may cause some expressions not to be emitted. Assign the slots we need before we start\n        // emitting the prolog.\n        // TODO: Investigate moving detection of non-local references to Emit() so we don't assign\n        // slots to symbols that are never referenced in emitted code.\n\n        if (funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n\n        if (funcInfo->isSuperLexicallyCaptured)\n        {\n            funcInfo->EnsureSuperScopeSlot();\n        }\n\n        if (funcInfo->isSuperCtorLexicallyCaptured)\n        {\n            funcInfo->EnsureSuperCtorScopeSlot();\n        }\n\n        if (funcInfo->isNewTargetLexicallyCaptured)\n        {\n            funcInfo->EnsureNewTargetScopeSlot();\n        }\n    }\n}\n\nvoid ByteCodeGenerator::InitSpecialScopeSlots(FuncInfo* funcInfo)\n{\n    if (funcInfo->bodyScope->GetIsObject())\n    {\n        // In split scope make sure to do init fld for the duplicate special scope slots\n        if (funcInfo->innerThisScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_lexicalThisSlotSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->thisPointerRegister, cacheId);\n        }\n        if (funcInfo->innerSuperScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n        }\n        if (funcInfo->innerSuperCtorScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n        }\n        if (funcInfo->innerNewTargetScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_lexicalNewTargetSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->newTargetRegister, cacheId);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::StartEmitFunction(ParseNode *pnodeFnc)\n{\n    Assert(pnodeFnc->nop == knopFncDecl || pnodeFnc->nop == knopProg);\n\n    FuncInfo *funcInfo = pnodeFnc->sxFnc.funcInfo;\n\n    if (funcInfo->byteCodeFunction->IsFunctionParsed())\n    {\n        if (!(flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n        {\n            // Only set the environment depth if it's truly known (i.e., not in eval or event handler).\n            funcInfo->GetParsedFunctionBody()->SetEnvDepth(this->envDepth);\n        }\n\n        if (pnodeFnc->sxFnc.FIBPreventsDeferral())\n        {\n            for (Scope *scope = this->currentScope; scope; scope = scope->GetEnclosingScope())\n            {\n                if (scope->GetScopeType() != ScopeType_FunctionBody && \n                    scope->GetScopeType() != ScopeType_Global &&\n                    scope->GetScopeType() != ScopeType_GlobalEvalBlock &&\n                    scope->GetMustInstantiate())\n                {\n                    funcInfo->byteCodeFunction->SetAttributes((Js::FunctionInfo::Attributes)(funcInfo->byteCodeFunction->GetAttributes() & ~Js::FunctionInfo::Attributes::CanDefer));\n                    break;\n                }\n            }\n        }\n    }\n\n    if (funcInfo->GetCallsEval())\n    {\n        funcInfo->byteCodeFunction->SetDontInline(true);\n    }\n\n    Scope * const funcExprScope = funcInfo->funcExprScope;\n    if (funcExprScope)\n    {\n        if (funcInfo->GetCallsEval())\n        {\n            Assert(funcExprScope->GetIsObject());\n        }\n\n        if (funcExprScope->GetIsObject())\n        {\n            funcExprScope->SetCapturesAll(true);\n            funcExprScope->SetMustInstantiate(true);\n            PushScope(funcExprScope);\n        }\n        else\n        {\n            Symbol *sym = funcInfo->root->sxFnc.GetFuncSymbol();\n            if (funcInfo->paramScope->GetCanMergeWithBodyScope())\n            {\n                funcInfo->bodyScope->AddSymbol(sym);\n            }\n            else\n            {\n                funcInfo->paramScope->AddSymbol(sym);\n            }\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n\n    Scope * const bodyScope = funcInfo->GetBodyScope();\n    Scope * const paramScope = funcInfo->GetParamScope();\n\n    if (pnodeFnc->nop != knopProg)\n    {\n        if (!bodyScope->GetIsObject() && NeedObjectAsFunctionScope(funcInfo, pnodeFnc))\n        {\n            Assert(bodyScope->GetIsObject());\n        }\n\n        if (bodyScope->GetIsObject())\n        {\n            bodyScope->SetLocation(funcInfo->frameObjRegister);\n        }\n        else\n        {\n            bodyScope->SetLocation(funcInfo->frameSlotsRegister);\n        }\n\n        if (!paramScope->GetCanMergeWithBodyScope())\n        {\n            if (paramScope->GetIsObject())\n            {\n                paramScope->SetLocation(funcInfo->frameObjRegister);\n            }\n            else\n            {\n                paramScope->SetLocation(funcInfo->frameSlotsRegister);\n            }\n        }\n\n        if (bodyScope->GetIsObject())\n        {\n            // Win8 908700: Disable under F12 debugger because there are too many cached scopes holding onto locals.\n            funcInfo->SetHasCachedScope(\n                !PHASE_OFF(Js::CachedScopePhase, funcInfo->byteCodeFunction) &&\n                !funcInfo->Escapes() &&\n                funcInfo->frameObjRegister != Js::Constants::NoRegister &&\n                !ApplyEnclosesArgs(pnodeFnc, this) &&\n                funcInfo->paramScope->GetCanMergeWithBodyScope() && // There is eval in the param scope\n                (PHASE_FORCE(Js::CachedScopePhase, funcInfo->byteCodeFunction) || !IsInDebugMode())\n#if ENABLE_TTD\n                && !funcInfo->GetParsedFunctionBody()->GetScriptContext()->GetThreadContext()->IsRuntimeInTTDMode()\n#endif\n            );\n\n            if (funcInfo->GetHasCachedScope())\n            {\n                Assert(funcInfo->funcObjRegister == Js::Constants::NoRegister);\n                Symbol *funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n                if (funcSym && funcSym->GetIsFuncExpr())\n                {\n                    if (funcSym->GetLocation() == Js::Constants::NoRegister)\n                    {\n                        funcInfo->funcObjRegister = funcInfo->NextVarRegister();\n                    }\n                    else\n                    {\n                        funcInfo->funcObjRegister = funcSym->GetLocation();\n                    }\n                }\n                else\n                {\n                    funcInfo->funcObjRegister = funcInfo->NextVarRegister();\n                }\n                Assert(funcInfo->funcObjRegister != Js::Constants::NoRegister);\n            }\n\n            ParseNode *pnode;\n            Symbol *sym;\n\n            if (funcInfo->GetHasArguments())\n            {\n                // Process function's formal parameters\n                MapFormals(pnodeFnc, [&](ParseNode *pnode)\n                {\n                    if (pnode->IsVarLetOrConst())\n                    {\n                        pnode->sxVar.sym->EnsureScopeSlot(funcInfo);\n                    }\n                });\n\n                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });\n\n                // Only allocate scope slot for \"arguments\" when really necessary. \"hasDeferredChild\"\n                // doesn't require scope slot for \"arguments\" because inner functions can't access\n                // outer function's arguments directly.\n                sym = funcInfo->GetArgumentsSymbol();\n                Assert(sym);\n                if (sym->NeedsSlotAlloc(funcInfo))\n                {\n                    sym->EnsureScopeSlot(funcInfo);\n                }\n            }\n\n            sym = funcInfo->root->sxFnc.GetFuncSymbol();\n\n            if (sym && sym->NeedsSlotAlloc(funcInfo))\n            {\n                if (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject())\n                {\n                    sym->SetScopeSlot(0);\n                }\n                else if (funcInfo->GetFuncExprNameReference())\n                {\n                    sym->EnsureScopeSlot(funcInfo);\n                }\n            }\n\n            if (!funcInfo->GetHasArguments())\n            {\n                Symbol *formal;\n                Js::ArgSlot pos = 1;\n                auto moveArgToReg = [&](ParseNode *pnode)\n                {\n                    if (pnode->IsVarLetOrConst())\n                    {\n                        formal = pnode->sxVar.sym;\n                        // Get the param from its argument position into its assigned register.\n                        // The position should match the location; otherwise, it has been shadowed by parameter with the same name.\n                        if (formal->GetLocation() + 1 == pos)\n                        {\n                            pnode->sxVar.sym->EnsureScopeSlot(funcInfo);\n                        }\n                    }\n                    pos++;\n                };\n                MapFormals(pnodeFnc, moveArgToReg);\n                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });\n            }\n\n            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);\n\n            auto ensureFncDeclScopeSlots = [&](ParseNode *pnodeScope)\n            {\n                for (pnode = pnodeScope; pnode;)\n                {\n                    switch (pnode->nop)\n                    {\n                    case knopFncDecl:\n                        if (pnode->sxFnc.IsDeclaration())\n                        {\n                            EnsureFncDeclScopeSlot(pnode, funcInfo);\n                        }\n                        pnode = pnode->sxFnc.pnodeNext;\n                        break;\n                    case knopBlock:\n                        pnode = pnode->sxBlock.pnodeNext;\n                        break;\n                    case knopCatch:\n                        pnode = pnode->sxCatch.pnodeNext;\n                        break;\n                    case knopWith:\n                        pnode = pnode->sxWith.pnodeNext;\n                        break;\n                    }\n                }\n            };\n            pnodeFnc->sxFnc.MapContainerScopes(ensureFncDeclScopeSlots);\n\n            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n            {\n                sym = pnode->sxVar.sym;\n                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n                {\n                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                    {\n                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                    }\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments()\n                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            }\n\n            if (pnodeFnc->sxFnc.pnodeBody)\n            {\n                Assert(pnodeFnc->sxFnc.pnodeScopes->nop == knopBlock);\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);\n            }\n        }\n        else\n        {\n            ParseNode *pnode;\n            Symbol *sym;\n\n            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);\n\n            pnodeFnc->sxFnc.MapContainerScopes([&](ParseNode *pnodeScope) { this->EnsureFncScopeSlots(pnodeScope, funcInfo); });\n\n            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n            {\n                sym = pnode->sxVar.sym;\n                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n                {\n                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                    {\n                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                    }\n                    if (sym->GetSymbolType() == STVariable && sym->NeedsSlotAlloc(funcInfo) && !sym->GetIsArguments()\n                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            }\n\n            auto ensureScopeSlot = [&](ParseNode *pnode)\n            {\n                if (pnode->IsVarLetOrConst())\n                {\n                    sym = pnode->sxVar.sym;\n                    if (sym->GetSymbolType() == STFormal && sym->NeedsSlotAlloc(funcInfo))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            };\n            // Process function's formal parameters\n            MapFormals(pnodeFnc, ensureScopeSlot);\n            MapFormalsFromPattern(pnodeFnc, ensureScopeSlot);\n\n            if (funcInfo->GetHasArguments())\n            {\n                sym = funcInfo->GetArgumentsSymbol();\n                Assert(sym);\n\n                // There is no eval so the arguments may be captured in a lambda.\n                // But we cannot relay on slots getting allocated while the lambda is emitted as the function body may be reparsed.\n                sym->EnsureScopeSlot(funcInfo);\n            }\n\n            if (pnodeFnc->sxFnc.pnodeBody)\n            {\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeScopes, funcInfo);\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);\n            }\n        }\n\n        if (!paramScope->GetCanMergeWithBodyScope() && bodyScope->GetScopeSlotCount() == 0 && !bodyScope->GetHasOwnLocalInClosure())\n        {\n            // When we have split scope the body scope may be wrongly marked as must instantiate even though the capture occurred\n            // in param scope. This check is to make sure if no capture occurs in body scope make in not must instantiate.\n            bodyScope->SetMustInstantiate(false);\n        }\n        else\n        {\n            bodyScope->SetMustInstantiate(funcInfo->frameObjRegister != Js::Constants::NoRegister || funcInfo->frameSlotsRegister != Js::Constants::NoRegister);\n        }\n        paramScope->SetMustInstantiate(!paramScope->GetCanMergeWithBodyScope());\n    }\n    else\n    {\n        bool newScopeForEval = (funcInfo->byteCodeFunction->GetIsStrictMode() && (this->GetFlags() & fscrEval));\n\n        if (newScopeForEval)\n        {\n            Assert(bodyScope->GetIsObject());\n        }\n    }\n\n    if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n    {\n        ParseNodePtr paramBlock = pnodeFnc->sxFnc.pnodeScopes;\n        Assert(paramBlock->nop == knopBlock && paramBlock->sxBlock.blockType == Parameter);\n\n        PushScope(paramScope);\n\n        // While emitting the functions we have to stop when we see the body scope block.\n        // Otherwise functions defined in the body scope will not be able to get the right references.\n        this->EmitScopeList(paramBlock->sxBlock.pnodeScopes, pnodeFnc->sxFnc.pnodeBodyScope);\n        Assert(this->GetCurrentScope() == paramScope);\n    }\n\n    PushScope(bodyScope);\n}\n\nvoid ByteCodeGenerator::EmitModuleExportAccess(Symbol* sym, Js::OpCode opcode, Js::RegSlot location, FuncInfo* funcInfo)\n{\n    if (EnsureSymbolModuleSlots(sym, funcInfo))\n    {\n        this->Writer()->SlotI2(opcode, location, sym->GetModuleIndex(), sym->GetScopeSlot());\n    }\n    else\n    {\n        this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(ERRInvalidExportName));\n\n        if (opcode == Js::OpCode::LdModuleSlot)\n        {\n            this->Writer()->Reg1(Js::OpCode::LdUndef, location);\n        }\n    }\n}\n\nbool ByteCodeGenerator::EnsureSymbolModuleSlots(Symbol* sym, FuncInfo* funcInfo)\n{\n    Assert(sym->GetIsModuleExportStorage());\n\n    if (sym->GetModuleIndex() != Js::Constants::NoProperty && sym->GetScopeSlot() != Js::Constants::NoProperty)\n    {\n        return true;\n    }\n\n    Js::JavascriptLibrary* library = this->GetScriptContext()->GetLibrary();\n    library->EnsureModuleRecordList();\n    uint moduleIndex = this->GetModuleID();\n    uint moduleSlotIndex;\n    Js::SourceTextModuleRecord* moduleRecord = library->GetModuleRecord(moduleIndex);\n\n    if (sym->GetIsModuleImport())\n    {\n        Js::PropertyId localImportNameId = sym->EnsurePosition(funcInfo);\n        Js::ModuleNameRecord* moduleNameRecord = nullptr;\n        if (!moduleRecord->ResolveImport(localImportNameId, &moduleNameRecord))\n        {\n            return false;\n        }\n\n        AnalysisAssert(moduleNameRecord != nullptr);\n        Assert(moduleNameRecord->module->IsSourceTextModuleRecord());\n        Js::SourceTextModuleRecord* resolvedModuleRecord = (Js::SourceTextModuleRecord*)moduleNameRecord->module;\n\n        moduleIndex = resolvedModuleRecord->GetModuleId();\n        moduleSlotIndex = resolvedModuleRecord->GetLocalExportSlotIndexByLocalName(moduleNameRecord->bindingName);\n    }\n    else\n    {\n        Js::PropertyId exportNameId = sym->EnsurePosition(funcInfo);\n        moduleSlotIndex = moduleRecord->GetLocalExportSlotIndexByLocalName(exportNameId);\n    }\n\n    sym->SetModuleIndex(moduleIndex);\n    sym->SetScopeSlot(moduleSlotIndex);\n\n    return true;\n}\n\nvoid ByteCodeGenerator::EmitAssignmentToDefaultModuleExport(ParseNode* pnode, FuncInfo* funcInfo)\n{\n    // We are assigning pnode to the default export of the current module.\n    uint moduleIndex = this->GetModuleID();\n\n    Js::JavascriptLibrary* library = this->GetScriptContext()->GetLibrary();\n    library->EnsureModuleRecordList();\n    Js::SourceTextModuleRecord* moduleRecord = library->GetModuleRecord(moduleIndex);\n    uint moduleSlotIndex = moduleRecord->GetLocalExportSlotIndexByExportName(Js::PropertyIds::default_);\n\n    this->Writer()->SlotI2(Js::OpCode::StModuleSlot, pnode->location, moduleIndex, moduleSlotIndex);\n}\n\nvoid ByteCodeGenerator::EnsureLetConstScopeSlots(ParseNode *pnodeBlock, FuncInfo *funcInfo)\n{\n    bool callsEval = pnodeBlock->sxBlock.GetCallsEval() || pnodeBlock->sxBlock.GetChildCallsEval();\n    auto ensureLetConstSlots = ([this, funcInfo, callsEval](ParseNode *pnode)\n    {\n        Symbol *sym = pnode->sxVar.sym;\n        if (callsEval || sym->NeedsSlotAlloc(funcInfo))\n        {\n            sym->EnsureScopeSlot(funcInfo);\n            this->ProcessCapturedSym(sym);\n        }\n    });\n    IterateBlockScopedVariables(pnodeBlock, ensureLetConstSlots);\n}\n\nvoid ByteCodeGenerator::EnsureFncScopeSlots(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    while (pnode)\n    {\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n            if (pnode->sxFnc.IsDeclaration())\n            {\n                CheckFncDeclScopeSlot(pnode, funcInfo);\n            }\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n        case knopBlock:\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n        case knopCatch:\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n        case knopWith:\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitFunction(ParseNode *pnodeFnc)\n{\n    Assert(pnodeFnc->nop == knopFncDecl || pnodeFnc->nop == knopProg);\n    Assert(pnodeFnc->nop == knopFncDecl && currentScope->GetEnclosingScope() != nullptr || pnodeFnc->nop == knopProg);\n\n    PopScope(); // function body\n\n    FuncInfo *funcInfo = pnodeFnc->sxFnc.funcInfo;\n\n    Scope* paramScope = funcInfo->paramScope;\n    if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n    {\n        Assert(this->GetCurrentScope() == paramScope);\n        PopScope(); // Pop the param scope\n    }\n\n    Scope *scope = funcInfo->funcExprScope;\n    if (scope && scope->GetMustInstantiate())\n    {\n        Assert(currentScope == scope);\n        PopScope();\n    }\n\n    if (CONFIG_FLAG(DeferNested))\n    {\n        Assert(funcInfo == this->TopFuncInfo());\n        PopFuncInfo(_u(\"EndEmitFunction\"));\n    }\n}\n\nvoid ByteCodeGenerator::StartEmitCatch(ParseNode *pnodeCatch)\n{\n    Assert(pnodeCatch->nop == knopCatch);\n\n    Scope *scope = pnodeCatch->sxCatch.scope;\n    FuncInfo *funcInfo = scope->GetFunc();\n\n    // Catch scope is a dynamic object if it can be passed to a scoped lookup helper (i.e., eval is present or we're in an event handler).\n    if (funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n    {\n        scope->SetIsObject();\n    }\n\n    if (pnodeCatch->sxCatch.pnodeParam->nop == knopParamPattern)\n    {\n        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval());\n        scope->SetMustInstantiate(scope->Count() > 0 && (scope->GetMustInstantiate() || scope->GetCapturesAll() || funcInfo->IsGlobalFunction()));\n\n        Parser::MapBindIdentifier(pnodeCatch->sxCatch.pnodeParam->sxParamPattern.pnode1, [&](ParseNodePtr item)\n        {\n            Symbol *sym = item->sxVar.sym;\n            if (funcInfo->IsGlobalFunction())\n            {\n                sym->SetIsGlobalCatch(true);\n            }\n\n            Assert(sym->GetScopeSlot() == Js::Constants::NoProperty);\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                sym->EnsureScopeSlot(funcInfo);\n            }\n        });\n\n        // In the case of pattern we will always going to push the scope.\n        PushScope(scope);\n    }\n    else\n    {\n        Symbol *sym = pnodeCatch->sxCatch.pnodeParam->sxPid.sym;\n\n        // Catch object is stored in the catch scope if there may be an ambiguous lookup or a var declaration that hides it.\n        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || sym->GetHasNonLocalReference());\n        scope->SetMustInstantiate(scope->GetCapturesAll() || funcInfo->IsGlobalFunction());\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            sym->SetIsGlobalCatch(true);\n        }\n\n        if (scope->GetMustInstantiate())\n        {\n            if (sym->IsInSlot(funcInfo))\n            {\n                // Since there is only one symbol we are pushing to slot.\n                // Also in order to make IsInSlot to return true - forcing the sym-has-non-local-reference.\n                this->ProcessCapturedSym(sym);\n                sym->EnsureScopeSlot(funcInfo);\n            }\n        }\n\n        PushScope(scope);\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitCatch(ParseNode *pnodeCatch)\n{\n    Assert(pnodeCatch->nop == knopCatch);\n    Assert(currentScope == pnodeCatch->sxCatch.scope);\n    PopScope();\n}\n\nvoid ByteCodeGenerator::StartEmitBlock(ParseNode *pnodeBlock)\n{\n    if (!BlockHasOwnScope(pnodeBlock, this))\n    {\n        return;\n    }\n\n    Assert(pnodeBlock->nop == knopBlock);\n\n    PushBlock(pnodeBlock);\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (pnodeBlock->sxBlock.GetCallsEval() || pnodeBlock->sxBlock.GetChildCallsEval() || (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n    {\n        Assert(scope->GetIsObject());\n    }\n\n    // TODO: Consider nested deferred parsing.\n    if (scope->GetMustInstantiate())\n    {\n        FuncInfo *funcInfo = scope->GetFunc();\n        if (scope->IsGlobalEvalBlockScope() && funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n        this->EnsureFncScopeSlots(pnodeBlock->sxBlock.pnodeScopes, funcInfo);\n        this->EnsureLetConstScopeSlots(pnodeBlock, funcInfo);\n        PushScope(scope);\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitBlock(ParseNode *pnodeBlock)\n{\n    if (!BlockHasOwnScope(pnodeBlock, this))\n    {\n        return;\n    }\n\n    Assert(pnodeBlock->nop == knopBlock);\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (scope && scope->GetMustInstantiate())\n    {\n        Assert(currentScope == pnodeBlock->sxBlock.scope);\n        PopScope();\n    }\n\n    PopBlock();\n}\n\nvoid ByteCodeGenerator::StartEmitWith(ParseNode *pnodeWith)\n{\n    Assert(pnodeWith->nop == knopWith);\n\n    Scope *scope = pnodeWith->sxWith.scope;\n\n    Assert(scope->GetIsObject());\n\n    PushScope(scope);\n}\n\nvoid ByteCodeGenerator::EndEmitWith(ParseNode *pnodeWith)\n{\n    Assert(pnodeWith->nop == knopWith);\n    Assert(currentScope == pnodeWith->sxWith.scope);\n\n    PopScope();\n}\n\nJs::RegSlot ByteCodeGenerator::PrependLocalScopes(Js::RegSlot evalEnv, Js::RegSlot tempLoc, FuncInfo *funcInfo)\n{\n    Scope *currScope = this->currentScope;\n    Scope *funcScope = funcInfo->GetCurrentChildScope() ? funcInfo->GetCurrentChildScope() : funcInfo->GetBodyScope();\n\n    if (currScope == funcScope)\n    {\n        return evalEnv;\n    }\n\n    bool acquireTempLoc = tempLoc == Js::Constants::NoRegister;\n    if (acquireTempLoc)\n    {\n        tempLoc = funcInfo->AcquireTmpRegister();\n    }\n\n    // The with/catch objects must be prepended to the environment we pass to eval() or to a func declared inside with,\n    // but the list must first be reversed so that innermost scopes appear first in the list.\n    while (currScope != funcScope)\n    {\n        Scope *innerScope;\n        for (innerScope = currScope; innerScope->GetEnclosingScope() != funcScope; innerScope = innerScope->GetEnclosingScope())\n            ;\n        if (innerScope->GetMustInstantiate())\n        {\n            if (!innerScope->HasInnerScopeIndex())\n            {\n                if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n                {\n                    this->m_writer.Reg2(Js::OpCode::LdInnerFrameDisplayNoParent, tempLoc, innerScope->GetLocation());\n                }\n                else\n                {\n                    this->m_writer.Reg3(Js::OpCode::LdInnerFrameDisplay, tempLoc, innerScope->GetLocation(), evalEnv);\n                }\n            }\n            else\n            {\n                if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n                {\n                    this->m_writer.Reg1Unsigned1(Js::OpCode::LdIndexedFrameDisplayNoParent, tempLoc, innerScope->GetInnerScopeIndex());\n                }\n                else\n                {\n                    this->m_writer.Reg2Int1(Js::OpCode::LdIndexedFrameDisplay, tempLoc, evalEnv, innerScope->GetInnerScopeIndex());\n                }\n            }\n            evalEnv = tempLoc;\n        }\n        funcScope = innerScope;\n    }\n\n    if (acquireTempLoc)\n    {\n        funcInfo->ReleaseTmpRegister(tempLoc);\n    }\n    return evalEnv;\n}\n\nvoid ByteCodeGenerator::EmitLoadInstance(Symbol *sym, IdentPtr pid, Js::RegSlot *pThisLocation, Js::RegSlot *pInstLocation, FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::RegSlot thisLocation = *pThisLocation;\n    Js::RegSlot instLocation = *pInstLocation;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym != nullptr && sym->GetIsModuleExportStorage())\n    {\n        *pInstLocation = Js::Constants::NoRegister;\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n\n        if (scope != symScope)\n        {\n            // We're not sure where the function is (eval/with/etc).\n            // So we're going to need registers to hold the instance where we (dynamically) find\n            // the function, and possibly to hold the \"this\" pointer we will pass to it.\n            // Assign them here so that they can't overlap with the scopeLocation assigned below.\n            // Otherwise we wind up with temp lifetime confusion in the IRBuilder. (Win8 281689)\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = funcInfo->AcquireTmpRegister();\n                // The \"this\" pointer will not be the same as the instance, so give it its own register.\n                thisLocation = funcInfo->AcquireTmpRegister();\n            }\n        }\n\n        if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj, tmpReg,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::OpCode op = unwrapWithObj ? Js::OpCode::UnwrapWithObj : Js::OpCode::Ld_A;\n\n            this->m_writer.Reg2(op, instLocation, tmpReg);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg2(op, thisLocation, tmpReg);\n            }\n\n            funcInfo->ReleaseTmpRegister(tmpReg);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            Assert(scope->GetIsObject());\n            this->m_writer.Reg1(Js::OpCode::LdLocalObj, instLocation);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg1(Js::OpCode::LdLocalObj, thisLocation);\n            }\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::OpCode op = unwrapWithObj ? Js::OpCode::UnwrapWithObj : Js::OpCode::Ld_A;\n            this->m_writer.Reg2(op, instLocation, scopeLocation);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg2(op, thisLocation, scopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        if (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents))\n        {\n            // Load of a symbol with unknown scope from within eval.\n            // Get it from the closure environment.\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = funcInfo->AcquireTmpRegister();\n            }\n\n            // TODO: It should be possible to avoid this double call to ScopedLdInst by having it return both\n            // results at once. The reason for the uncertainty here is that we don't know whether the callee\n            // belongs to a \"with\" object. If it does, we have to pass the \"with\" object as \"this\"; in all other\n            // cases, we pass \"undefined\". For now, there are apparently no significant performance issues.\n            Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n            if (thisLocation == Js::Constants::NoRegister)\n            {\n                thisLocation = funcInfo->AcquireTmpRegister();\n            }\n            this->m_writer.ScopedProperty2(Js::OpCode::ScopedLdInst, instLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId), thisLocation);\n        }\n        else\n        {\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = ByteCodeGenerator::RootObjectRegister;\n            }\n            else\n            {\n                this->m_writer.Reg2(Js::OpCode::Ld_A, instLocation, ByteCodeGenerator::RootObjectRegister);\n            }\n\n            if (thisLocation == Js::Constants::NoRegister)\n            {\n                thisLocation = funcInfo->undefinedConstantRegister;\n            }\n            else\n            {\n                this->m_writer.Reg2(Js::OpCode::Ld_A, thisLocation, funcInfo->undefinedConstantRegister);\n            }\n        }\n    }\n    else if (instLocation != Js::Constants::NoRegister)\n    {\n        if (envIndex != -1)\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj, instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.Reg1Unsigned1(Js::OpCode::LdInnerScope, instLocation, scope->GetInnerScopeIndex());\n        }\n        else if (symScope != funcInfo->GetBodyScope())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, instLocation, scopeLocation);\n        }\n        else\n        {\n            Assert(funcInfo->frameObjRegister != Js::Constants::NoRegister);\n            this->m_writer.Reg1(Js::OpCode::LdLocalObj, instLocation);\n        }\n\n        if (thisLocation != Js::Constants::NoRegister)\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, thisLocation, funcInfo->undefinedConstantRegister);\n        }\n        else\n        {\n            thisLocation = funcInfo->undefinedConstantRegister;\n        }\n    }\n\n    *pThisLocation = thisLocation;\n    *pInstLocation = instLocation;\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitGlobalFncDeclInit(Js::RegSlot rhsLocation, Js::PropertyId propertyId, FuncInfo * funcInfo)\n{\n    // Note: declared variables and assignments in the global function go to the root object directly.\n    if (this->flags & fscrEval)\n    {\n        // Func decl's always get their init values before any use, so we don't pre-initialize the property to undef.\n        // That means that we have to use ScopedInitFld so that we initialize the property on the right instance\n        // even if the instance doesn't have the property yet (i.e., collapse the init-to-undef and the store\n        // into one operation). See WOOB 1121763 and 1120973.\n        this->m_writer.ScopedProperty(Js::OpCode::ScopedInitFunc, rhsLocation,\n            funcInfo->FindOrAddReferencedPropertyId(propertyId));\n    }\n    else\n    {\n        this->EmitPatchableRootProperty(Js::OpCode::InitRootFld, rhsLocation, propertyId, false, true, funcInfo);\n    }\n}\n\nvoid\nByteCodeGenerator::EmitPatchableRootProperty(Js::OpCode opcode,\n    Js::RegSlot regSlot, Js::PropertyId propertyId, bool isLoadMethod, bool isStore, FuncInfo * funcInfo)\n{\n    uint cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, isLoadMethod, isStore);\n    this->m_writer.PatchableRootProperty(opcode, regSlot, cacheId, isLoadMethod, isStore);\n}\n\nvoid ByteCodeGenerator::EmitLocalPropInit(Js::RegSlot rhsLocation, Symbol *sym, FuncInfo *funcInfo)\n{\n    Scope *scope = sym->GetScope();\n\n    // Check consistency of sym->IsInSlot.\n    Assert(sym->NeedsSlotAlloc(funcInfo) || sym->GetScopeSlot() == Js::Constants::NoProperty);\n\n    // Arrived at the scope in which the property was defined.\n    if (sym->NeedsSlotAlloc(funcInfo))\n    {\n        // The property is in memory rather than register. We'll have to load it from the slots.\n        if (scope->GetIsObject())\n        {\n            Assert(!this->TopFuncInfo()->GetParsedFunctionBody()->DoStackNestedFunc());\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n            Js::RegSlot objReg;\n            if (scope->HasInnerScopeIndex())\n            {\n                objReg = funcInfo->InnerScopeToRegSlot(scope);\n            }\n            else\n            {\n                objReg = scope->GetLocation();\n            }\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(objReg, propertyId, false, true);\n            Js::OpCode op = this->GetInitFldOp(scope, objReg, funcInfo, sym->GetIsNonSimpleParameter());\n            if (objReg != Js::Constants::NoRegister && objReg == funcInfo->frameObjRegister)\n            {\n                this->m_writer.ElementP(op, rhsLocation, cacheId);\n            }\n            else if (scope->HasInnerScopeIndex())\n            {\n                this->m_writer.ElementPIndexed(op, rhsLocation, scope->GetInnerScopeIndex(), cacheId);\n            }\n            else\n            {\n                this->m_writer.PatchableProperty(op, rhsLocation, scope->GetLocation(), cacheId);\n            }\n        }\n        else\n        {\n            // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            Js::RegSlot slotReg = scope->GetCanMerge() ? funcInfo->frameSlotsRegister : scope->GetLocation();\n            // Now store the property to its slot.\n            Js::OpCode op = this->GetStSlotOp(scope, -1, slotReg, false, funcInfo);\n\n            if (slotReg != Js::Constants::NoRegister && slotReg == funcInfo->frameSlotsRegister)\n            {\n                this->m_writer.SlotI1(op, rhsLocation, slot + Js::ScopeSlots::FirstSlotIndex);\n            }\n            else\n            {\n                this->m_writer.SlotI2(op, rhsLocation, scope->GetInnerScopeIndex(), slot + Js::ScopeSlots::FirstSlotIndex);\n            }\n        }\n    }\n    if (sym->GetLocation() != Js::Constants::NoRegister && rhsLocation != sym->GetLocation())\n    {\n        this->m_writer.Reg2(Js::OpCode::Ld_A, sym->GetLocation(), rhsLocation);\n    }\n}\n\nJs::OpCode\nByteCodeGenerator::GetStSlotOp(Scope *scope, int envIndex, Js::RegSlot scopeLocation, bool chkBlockVar, FuncInfo *funcInfo)\n{\n    Js::OpCode op;\n\n    if (envIndex != -1)\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::StEnvObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::StEnvSlot;\n        }\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameSlotsRegister)\n    {\n        op = Js::OpCode::StLocalSlot;\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = Js::OpCode::StLocalObjSlot;\n    }\n    else\n    {\n        Assert(scope->HasInnerScopeIndex());\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::StInnerObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::StInnerSlot;\n        }\n    }\n\n    if (chkBlockVar)\n    {\n        op = this->ToChkUndeclOp(op);\n    }\n\n    return op;\n}\n\nJs::OpCode\nByteCodeGenerator::GetInitFldOp(Scope *scope, Js::RegSlot scopeLocation, FuncInfo *funcInfo, bool letDecl)\n{\n    Js::OpCode op;\n\n    if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = letDecl ? Js::OpCode::InitLocalLetFld : Js::OpCode::InitLocalFld;\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        op = letDecl ? Js::OpCode::InitInnerLetFld : Js::OpCode::InitInnerFld;\n    }\n    else\n    {\n        op = letDecl ? Js::OpCode::InitLetFld : Js::OpCode::InitFld;\n    }\n\n    return op;\n}\n\nvoid ByteCodeGenerator::EmitPropStore(Js::RegSlot rhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo, bool isLetDecl, bool isConstDecl, bool isFncDeclVar)\n{\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::PropertyId envIndex = -1;\n    Scope *symScope = sym == nullptr || sym->GetIsGlobal() ? this->globalScope : sym->GetScope();\n    Assert(symScope);\n    // isFncDeclVar denotes that the symbol being stored to here is the var\n    // binding of a function declaration and we know we want to store directly\n    // to it, skipping over any dynamic scopes that may lie in between.\n    Scope *scope = nullptr;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    bool scopeAcquired = false;\n    Js::OpCode op;\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n\n        EmitModuleExportAccess(sym, Js::OpCode::StModuleSlot, rhsLocation, funcInfo);\n        return;\n    }\n\n    if (isFncDeclVar)\n    {\n        // async functions allow for the fncDeclVar to be in the body or parameter scope\n        // of the parent function, so we need to calculate envIndex in lieu of the while\n        // loop below.\n        do\n        {\n            scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        } while (scope != symScope);\n        Assert(scope == symScope);\n        scopeLocation = scope->GetLocation();\n    }\n\n    while (!isFncDeclVar)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n        if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        Js::RegSlot unwrappedScopeLocation = scopeLocation;\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.PatchableProperty(\n                Js::OpCode::StFld,\n                rhsLocation,\n                instLocation,\n                funcInfo->FindOrAddInlineCacheId(instLocation, propertyId, false, true));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementP(Js::OpCode::StLocalFld, rhsLocation,\n                funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n            this->m_writer.PatchableProperty(Js::OpCode::StFld, rhsLocation, scopeLocation, cacheId);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        EmitUseBeforeDeclarationRuntimeError(this, Js::Constants::NoRegister);\n        // Intentionally continue on to do normal EmitPropStore behavior so\n        // that the bytecode ends up well-formed for the backend.  This is\n        // in contrast to EmitPropLoad and EmitPropTypeof where they both\n        // tell EmitUseBeforeDeclarationRuntimeError to emit a LdUndef in place\n        // of their load and then they skip emitting their own bytecode.\n        // Potayto potahto.\n    }\n\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->frameDisplayRegister, propertyId, false, true);\n                this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo), rhsLocation, cacheId);\n            }\n            else\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, true);\n                bool isConsoleScopeLetConst = this->IsConsoleScopeEval() && (isLetDecl || isConstDecl);\n                // In \"eval\", store to a symbol with unknown scope goes through the closure environment.\n                this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo, isConsoleScopeLetConst), rhsLocation, cacheId);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, true);\n\n            // In \"eval\", store to a symbol with unknown scope goes through the closure environment.\n            this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo), rhsLocation, cacheId);\n        }\n        else\n        {\n            this->EmitPatchableRootProperty(GetStFldOpCode(funcInfo, true, isLetDecl, isConstDecl, false), rhsLocation, propertyId, false, true, funcInfo);\n        }\n    }\n    else if (sym->GetIsFuncExpr())\n    {\n        // Store to function expr variable.\n\n        // strict mode: we need to throw type error\n        if (funcInfo->byteCodeFunction->GetIsStrictMode())\n        {\n            // Note that in this case the sym's location belongs to the parent function, so we can't use it.\n            // It doesn't matter which register we use, as long as it's valid for this function.\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_CantAssignToReadOnly));\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            // This is a case where const reassignment can't be proven statically (e.g., eval, with) so\n            // we have to catch it at runtime.\n            this->m_writer.W1(\n                Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        bool chkBlockVar = !isLetDecl && !isConstDecl && NeedCheckBlockVar(sym, scope, funcInfo);\n\n        // The property is in memory rather than register. We'll have to load it from the slots.\n        op = this->GetStSlotOp(scope, envIndex, scopeLocation, chkBlockVar, funcInfo);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, rhsLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var),\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, rhsLocation,\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n        else\n        {\n            Assert(scope->HasInnerScopeIndex());\n            this->m_writer.SlotI2(op, rhsLocation, scope->GetInnerScopeIndex(),\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n\n        if (this->ShouldTrackDebuggerMetadata() && (isLetDecl || isConstDecl))\n        {\n            Js::PropertyId location = scope->GetIsObject() ? sym->GetLocation() : slot;\n            this->UpdateDebuggerPropertyInitializationOffset(location, sym->GetPosition(), false);\n        }\n    }\n    else if (isConstDecl)\n    {\n        this->m_writer.Reg2(Js::OpCode::InitConst, sym->GetLocation(), rhsLocation);\n\n        if (this->ShouldTrackDebuggerMetadata())\n        {\n            this->UpdateDebuggerPropertyInitializationOffset(sym->GetLocation(), sym->GetPosition());\n        }\n    }\n    else\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            // This is a case where const reassignment can't be proven statically (e.g., eval, with) so\n            // we have to catch it at runtime.\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n        if (rhsLocation != sym->GetLocation())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, sym->GetLocation(), rhsLocation);\n\n            if (this->ShouldTrackDebuggerMetadata() && isLetDecl)\n            {\n                this->UpdateDebuggerPropertyInitializationOffset(sym->GetLocation(), sym->GetPosition());\n            }\n        }\n    }\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n\n    if (scopeAcquired)\n    {\n        funcInfo->ReleaseTmpRegister(scopeLocation);\n    }\n}\n\nJs::OpCode\nByteCodeGenerator::GetLdSlotOp(Scope *scope, int envIndex, Js::RegSlot scopeLocation, FuncInfo *funcInfo)\n{\n    Js::OpCode op;\n\n    if (envIndex != -1)\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::LdEnvObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::LdEnvSlot;\n        }\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameSlotsRegister)\n    {\n        op = Js::OpCode::LdLocalSlot;\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = Js::OpCode::LdLocalObjSlot;\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::LdInnerObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::LdInnerSlot;\n        }\n    }\n    else\n    {\n        Assert(scope->GetIsObject());\n        op = Js::OpCode::LdObjSlot;\n    }\n\n    return op;\n}\n\nvoid ByteCodeGenerator::EmitPropLoad(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, get it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just copy the value to the lhsLocation.\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        EmitModuleExportAccess(sym, Js::OpCode::LdModuleSlot, lhsLocation, funcInfo);\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n\n        scopeLocation = scope->GetLocation();\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.PatchableProperty(\n                Js::OpCode::LdFld,\n                lhsLocation,\n                instLocation,\n                funcInfo->FindOrAddInlineCacheId(instLocation, propertyId, false, false));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementP(Js::OpCode::LdLocalFld, lhsLocation,\n                funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, false));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, false);\n            this->m_writer.PatchableProperty(Js::OpCode::LdFld, lhsLocation, scopeLocation, cacheId);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        // Ensure this symbol has a slot if it needs one.\n        if (sym->IsInSlot(funcInfo))\n        {\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            funcInfo->FindOrAddSlotProfileId(scope, slot);\n        }\n\n        EmitUseBeforeDeclarationRuntimeError(this, lhsLocation);\n    }\n    else if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->frameDisplayRegister, propertyId, false, false);\n                this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n            }\n            else\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, false);\n\n                // Load of a symbol with unknown scope from within eval\n                // Get it from the closure environment.\n                this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, false);\n\n            // Load of a symbol with unknown scope from within eval or event handler.\n            // Get it from the closure environment.\n            this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n        }\n        else\n        {\n            // Special case non-writable built-ins\n            // TODO: support non-writable global property in general by detecting what attribute the property have current?\n            // But can't be done if we are byte code serialized, because the attribute might be different for use fields\n            // next time we run. May want to catch that in the JIT.\n            Js::OpCode opcode = Js::OpCode::LdRootFld;\n\n            // These properties are non-writable\n            switch (propertyId)\n            {\n            case Js::PropertyIds::NaN:\n                opcode = Js::OpCode::LdNaN;\n                break;\n            case Js::PropertyIds::Infinity:\n                opcode = Js::OpCode::LdInfinity;\n                break;\n            case Js::PropertyIds::undefined:\n                opcode = Js::OpCode::LdUndef;\n                break;\n            }\n\n            if (opcode == Js::OpCode::LdRootFld)\n            {\n                this->EmitPatchableRootProperty(Js::OpCode::LdRootFld, lhsLocation, propertyId, false, false, funcInfo);\n            }\n            else\n            {\n                this->Writer()->Reg1(opcode, lhsLocation);\n            }\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, slot);\n        bool chkBlockVar = NeedCheckBlockVar(sym, scope, funcInfo);\n        Js::OpCode op;\n\n        // Now get the property from its slot.\n        op = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n        slot = slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, lhsLocation, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, lhsLocation, slot, profileId);\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.SlotI2(op, lhsLocation, scope->GetInnerScopeIndex(), slot, profileId);\n        }\n        else\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.Slot(op, lhsLocation, scopeLocation, slot, profileId);\n        }\n\n        if (chkBlockVar)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, lhsLocation);\n        }\n    }\n    else\n    {\n        if (lhsLocation != sym->GetLocation())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, lhsLocation, sym->GetLocation());\n        }\n        if (sym->GetIsBlockVar() && ((sym->GetDecl()->nop == knopLetDecl || sym->GetDecl()->nop == knopConstDecl) && sym->GetDecl()->sxVar.isSwitchStmtDecl))\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, lhsLocation);\n        }\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nbool ByteCodeGenerator::NeedCheckBlockVar(Symbol* sym, Scope* scope, FuncInfo* funcInfo) const\n{\n    bool tdz = sym->GetIsBlockVar()\n        && (scope->GetFunc() != funcInfo || ((sym->GetDecl()->nop == knopLetDecl || sym->GetDecl()->nop == knopConstDecl) && sym->GetDecl()->sxVar.isSwitchStmtDecl));\n\n    return tdz || sym->GetIsNonSimpleParameter();\n}\n\nvoid ByteCodeGenerator::EmitPropDelete(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, delete it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just return false.\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            scopeLocation = ByteCodeGenerator::RootObjectRegister;\n        }\n        else if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.Property(Js::OpCode::DeleteFld, lhsLocation, instLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementU(Js::OpCode::DeleteLocalFld, lhsLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            this->m_writer.Property(Js::OpCode::DeleteFld, lhsLocation, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents))\n        {\n            this->m_writer.ScopedProperty(Js::OpCode::ScopedDeleteFld, lhsLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            this->m_writer.Property(Js::OpCode::DeleteRootFld, lhsLocation, ByteCodeGenerator::RootObjectRegister,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n    }\n    else\n    {\n        // The delete will look like a non-local reference, so make sure a slot is reserved.\n        sym->EnsureScopeSlot(funcInfo);\n        this->m_writer.Reg1(Js::OpCode::LdFalse, lhsLocation);\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitTypeOfFld(FuncInfo * funcInfo, Js::PropertyId propertyId, Js::RegSlot value, Js::RegSlot instance, Js::OpCode ldFldOp)\n{\n\n    uint cacheId;\n    Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n    switch (ldFldOp)\n    {\n    case Js::OpCode::LdRootFldForTypeOf:\n        cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, false, false);\n        this->Writer()->PatchableRootProperty(ldFldOp, tmpReg, cacheId, false, false);\n        break;\n\n    case Js::OpCode::LdLocalFld:\n    case Js::OpCode::ScopedLdFldForTypeOf:\n        cacheId = funcInfo->FindOrAddInlineCacheId(instance, propertyId, false, false);\n        this->Writer()->ElementP(ldFldOp, tmpReg, cacheId);\n        break;\n\n    default:\n        cacheId = funcInfo->FindOrAddInlineCacheId(instance, propertyId, false, false);\n        this->Writer()->PatchableProperty(ldFldOp, tmpReg, instance, cacheId);\n        break;\n    }\n\n    this->Writer()->Reg2(Js::OpCode::Typeof, value, tmpReg);\n    funcInfo->ReleaseTmpRegister(tmpReg);\n}\n\nvoid ByteCodeGenerator::EmitPropTypeof(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, delete it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just return false\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        Js::RegSlot tmpLocation = funcInfo->AcquireTmpRegister();\n        EmitModuleExportAccess(sym, Js::OpCode::LdModuleSlot, tmpLocation, funcInfo);\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, tmpLocation);\n        funcInfo->ReleaseTmpRegister(tmpLocation);\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            scopeLocation = ByteCodeGenerator::RootObjectRegister;\n        }\n        else if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(Js::OpCode::BrOnNoEnvProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, instLocation, Js::OpCode::LdFldForTypeOf);\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, scopeLocation, Js::OpCode::LdLocalFld);\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, scopeLocation, Js::OpCode::LdFldForTypeOf);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        // Ensure this symbol has a slot if it needs one.\n        if (sym->IsInSlot(funcInfo))\n        {\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            funcInfo->FindOrAddSlotProfileId(scope, slot);\n        }\n\n        EmitUseBeforeDeclarationRuntimeError(this, lhsLocation);\n    }\n    else if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->frameDisplayRegister, Js::OpCode::ScopedLdFldForTypeOf);\n            }\n            else\n            {\n                this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->GetEnvRegister(), Js::OpCode::ScopedLdFldForTypeOf);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->GetEnvRegister(), Js::OpCode::ScopedLdFldForTypeOf);\n        }\n        else\n        {\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, ByteCodeGenerator::RootObjectRegister, Js::OpCode::LdRootFldForTypeOf);\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, slot);\n        Js::RegSlot tmpLocation = funcInfo->AcquireTmpRegister();\n        bool chkBlockVar = NeedCheckBlockVar(sym, scope, funcInfo);\n        Js::OpCode op;\n\n        op = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n        slot = slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, tmpLocation, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, tmpLocation, slot, profileId);\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.SlotI2(op, tmpLocation, scope->GetInnerScopeIndex(), slot, profileId);\n        }\n        else\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.Slot(op, tmpLocation, scopeLocation, slot, profileId);\n        }\n\n        if (chkBlockVar)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, tmpLocation);\n        }\n\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, tmpLocation);\n        funcInfo->ReleaseTmpRegister(tmpLocation);\n    }\n    else\n    {\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, sym->GetLocation());\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EnsureNoRedeclarations(ParseNode *pnodeBlock, FuncInfo *funcInfo)\n{\n    // Emit dynamic runtime checks for variable re-declarations. Only necessary for global functions (script or eval).\n    // In eval only var declarations can cause redeclaration, and only in non-strict mode, because let/const variables\n    // remain local to the eval code.\n\n    Assert(pnodeBlock->nop == knopBlock);\n    Assert(pnodeBlock->sxBlock.blockType == PnodeBlockType::Global || pnodeBlock->sxBlock.scope->GetScopeType() == ScopeType_GlobalEvalBlock);\n\n    if (!(this->flags & fscrEvalCode))\n    {\n        IterateBlockScopedVariables(pnodeBlock, [this](ParseNode *pnode)\n        {\n            FuncInfo *funcInfo = this->TopFuncInfo();\n            Symbol *sym = pnode->sxVar.sym;\n\n            Assert(sym->GetIsGlobal());\n\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n            this->m_writer.ElementRootU(Js::OpCode::EnsureNoRootFld, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        });\n    }\n\n    for (ParseNode *pnode = funcInfo->root->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n    {\n        Symbol* sym = pnode->sxVar.sym;\n\n        if (sym == nullptr || pnode->sxVar.isBlockScopeFncDeclVar)\n            continue;\n\n        if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n        {\n            // The init node was bound to the catch object, because it's inside a catch and has the\n            // same name as the catch object. But we want to define a user var at function scope,\n            // so find the right symbol. (We'll still assign the RHS value to the catch object symbol.)\n            // This also applies to a var declaration in the same scope as a let declaration.\n\n            // Assert that catch cannot be at function scope and let and var at function scope is redeclaration error.\n            Assert(sym->GetIsCatch() || funcInfo->bodyScope != sym->GetScope());\n            sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n            Assert(sym && !sym->GetIsCatch() && !sym->GetIsBlockVar());\n        }\n\n        Assert(sym->GetIsGlobal());\n\n        if (sym->GetSymbolType() == STVariable)\n        {\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n            if (this->flags & fscrEval)\n            {\n                if (!funcInfo->byteCodeFunction->GetIsStrictMode())\n                {\n                    this->m_writer.ScopedProperty(Js::OpCode::ScopedEnsureNoRedeclFld, ByteCodeGenerator::RootObjectRegister,\n                        funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                }\n            }\n            else\n            {\n                this->m_writer.ElementRootU(Js::OpCode::EnsureNoRootRedeclFld, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n        }\n    }\n}\n\nvoid ByteCodeGenerator::RecordAllIntConstants(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->constantToRegister.Map([byteCodeFunction](unsigned int val, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordIntConstant(byteCodeFunction->MapRegSlot(location), val);\n    });\n}\n\nvoid ByteCodeGenerator::RecordAllStrConstants(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->stringToRegister.Map([byteCodeFunction](IdentPtr pid, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordStrConstant(byteCodeFunction->MapRegSlot(location), pid->Psz(), pid->Cch());\n    });\n}\n\nvoid ByteCodeGenerator::RecordAllStringTemplateCallsiteConstants(FuncInfo* funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->stringTemplateCallsiteRegisterMap.Map([byteCodeFunction](ParseNodePtr pnode, Js::RegSlot location)\n    {\n        Js::ScriptContext* scriptContext = byteCodeFunction->GetScriptContext();\n        Js::JavascriptLibrary* library = scriptContext->GetLibrary();\n        Js::RecyclableObject* callsiteObject = library->TryGetStringTemplateCallsiteObject(pnode);\n\n        if (callsiteObject == nullptr)\n        {\n            Js::RecyclableObject* rawArray = ByteCodeGenerator::BuildArrayFromStringList(pnode->sxStrTemplate.pnodeStringRawLiterals, pnode->sxStrTemplate.countStringLiterals, scriptContext);\n            rawArray->Freeze();\n\n            callsiteObject = ByteCodeGenerator::BuildArrayFromStringList(pnode->sxStrTemplate.pnodeStringLiterals, pnode->sxStrTemplate.countStringLiterals, scriptContext);\n            callsiteObject->SetPropertyWithAttributes(Js::PropertyIds::raw, rawArray, PropertyNone, nullptr);\n            callsiteObject->Freeze();\n\n            library->AddStringTemplateCallsiteObject(callsiteObject);\n        }\n\n        byteCodeFunction->RecordConstant(byteCodeFunction->MapRegSlot(location), callsiteObject);\n    });\n}\n\nbool IsApplyArgs(ParseNode* callNode)\n{\n    ParseNode* target = callNode->sxCall.pnodeTarget;\n    ParseNode* args = callNode->sxCall.pnodeArgs;\n    if ((target != nullptr) && (target->nop == knopDot))\n    {\n        ParseNode* lhsNode = target->sxBin.pnode1;\n        if ((lhsNode != nullptr) && ((lhsNode->nop == knopDot) || (lhsNode->nop == knopName)) && !IsArguments(lhsNode))\n        {\n            ParseNode* nameNode = target->sxBin.pnode2;\n            if (nameNode != nullptr)\n            {\n                bool nameIsApply = nameNode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::apply;\n                if (nameIsApply && args != nullptr && args->nop == knopList)\n                {\n                    ParseNode* arg1 = args->sxBin.pnode1;\n                    ParseNode* arg2 = args->sxBin.pnode2;\n                    if ((arg1 != nullptr) && (arg1->nop == knopThis) && (arg2 != nullptr) && (arg2->nop == knopName) && (arg2->sxPid.sym != nullptr))\n                    {\n                        return arg2->sxPid.sym->GetIsArguments();\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvoid PostCheckApplyEnclosesArgs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, ApplyCheck* applyCheck)\n{\n    if ((pnode == nullptr) || (!applyCheck->matches))\n    {\n        return;\n    }\n\n    if (pnode->nop == knopCall)\n    {\n        if ((!pnode->isUsed) && IsApplyArgs(pnode))\n        {\n            if (!applyCheck->insideApplyCall)\n            {\n                applyCheck->matches = false;\n            }\n            applyCheck->insideApplyCall = false;\n        }\n    }\n}\n\nvoid CheckApplyEnclosesArgs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, ApplyCheck* applyCheck)\n{\n    if ((pnode == nullptr) || (!applyCheck->matches))\n    {\n        return;\n    }\n\n    switch (pnode->nop)\n    {\n    case knopName:\n    {\n        Symbol* sym = pnode->sxPid.sym;\n        if (sym != nullptr)\n        {\n            if (sym->GetIsArguments())\n            {\n                if (!applyCheck->insideApplyCall)\n                {\n                    applyCheck->matches = false;\n                }\n            }\n        }\n        break;\n    }\n\n    case knopCall:\n        if ((!pnode->isUsed) && IsApplyArgs(pnode))\n        {\n            // no nested apply calls\n            if (applyCheck->insideApplyCall)\n            {\n                applyCheck->matches = false;\n            }\n            else\n            {\n                applyCheck->insideApplyCall = true;\n                applyCheck->sawApply = true;\n                pnode->sxCall.isApplyCall = true;\n            }\n        }\n        break;\n    }\n}\n\nunsigned int CountArguments(ParseNode *pnode, BOOL *pSideEffect = nullptr)\n{\n    // If the caller passed us a pSideEffect, it wants to know whether there are potential\n    // side-effects in the argument list. We need to know this so that the call target\n    // operands can be preserved if necessary.\n    // For now, treat any non-leaf op as a potential side-effect. This causes no detectable slowdowns,\n    // but we can be more precise if we need to be.\n    if (pSideEffect)\n    {\n        *pSideEffect = FALSE;\n    }\n\n    unsigned int argCount = 1;\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            argCount++;\n            if (pSideEffect && !(ParseNode::Grfnop(pnode->sxBin.pnode1->nop) & fnopLeaf))\n            {\n                *pSideEffect = TRUE;\n            }\n            pnode = pnode->sxBin.pnode2;\n        }\n        argCount++;\n        if (pSideEffect && !(ParseNode::Grfnop(pnode->nop) & fnopLeaf))\n        {\n            *pSideEffect = TRUE;\n        }\n    }\n\n    return argCount;\n}\n\nvoid SaveOpndValue(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    // Save a local name to a register other than its home location.\n    // This guards against side-effects in cases like x.foo(x = bar()).\n    Symbol *sym = nullptr;\n    if (pnode->nop == knopName)\n    {\n        sym = pnode->sxPid.sym;\n    }\n    else if (pnode->nop == knopComputedName)\n    {\n        ParseNode *pnode1 = pnode->sxUni.pnode1;\n        if (pnode1->nop == knopName)\n        {\n            sym = pnode1->sxPid.sym;\n        }\n    }\n\n    if (sym == nullptr)\n    {\n        return;\n    }\n\n    // If the target is a local being kept in its home location,\n    // protect the target's value in the event the home location is overwritten.\n    if (pnode->location != Js::Constants::NoRegister &&\n        sym->GetScope()->GetFunc() == funcInfo &&\n        pnode->location == sym->GetLocation())\n    {\n        pnode->location = funcInfo->AcquireTmpRegister();\n    }\n}\n\nvoid ByteCodeGenerator::StartStatement(ParseNode* node)\n{\n    Assert(TopFuncInfo() != nullptr);\n    m_writer.StartStatement(node, TopFuncInfo()->curTmpReg - TopFuncInfo()->firstTmpReg);\n}\n\nvoid ByteCodeGenerator::EndStatement(ParseNode* node)\n{\n    m_writer.EndStatement(node);\n}\n\nvoid ByteCodeGenerator::StartSubexpression(ParseNode* node)\n{\n    Assert(TopFuncInfo() != nullptr);\n    m_writer.StartSubexpression(node);\n}\n\nvoid ByteCodeGenerator::EndSubexpression(ParseNode* node)\n{\n    m_writer.EndSubexpression(node);\n}\n\nvoid EmitReference(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // Generate code for the LHS of an assignment.\n    switch (pnode->nop)\n    {\n    case knopDot:\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        break;\n\n    case knopIndex:\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Emit(pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n        break;\n\n    case knopName:\n        break;\n\n    case knopArrayPattern:\n    case knopObjectPattern:\n        break;\n\n    case knopCall:\n    case knopNew:\n        // Emit the operands of a call that will be used as a LHS.\n        // These have to be emitted before the RHS, but they have to persist until\n        // the end of the expression.\n        // Emit the call target operands first.\n        switch (pnode->sxCall.pnodeTarget->nop)\n        {\n        case knopDot:\n        case knopIndex:\n            funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n            EmitReference(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            break;\n\n        case knopName:\n        {\n            Symbol *sym = pnode->sxCall.pnodeTarget->sxPid.sym;\n            if (!sym || sym->GetLocation() == Js::Constants::NoRegister)\n            {\n                funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n            }\n            if (sym && (sym->IsInSlot(funcInfo) || sym->GetScope()->GetFunc() != funcInfo))\n            {\n                // Can't get the value from the assigned register, so load it here.\n                EmitLoad(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            }\n            else\n            {\n                // EmitLoad will check for needsDeclaration and emit the Use Before Declaration error\n                // bytecode op as necessary, but EmitReference does not check this (by design). So we\n                // must manually check here.\n                EmitUseBeforeDeclaration(pnode->sxCall.pnodeTarget->sxPid.sym, byteCodeGenerator, funcInfo);\n                EmitReference(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            }\n            break;\n        }\n        default:\n            EmitLoad(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            break;\n        }\n\n        // Now the arg list. We evaluate everything now and emit the ArgOut's later.\n        if (pnode->sxCall.pnodeArgs)\n        {\n            ParseNode *pnodeArg = pnode->sxCall.pnodeArgs;\n            while (pnodeArg->nop == knopList)\n            {\n                Emit(pnodeArg->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n                pnodeArg = pnodeArg->sxBin.pnode2;\n            }\n            Emit(pnodeArg, byteCodeGenerator, funcInfo, false);\n        }\n        break;\n\n    default:\n        Emit(pnode, byteCodeGenerator, funcInfo, false);\n        break;\n    }\n}\n\nvoid EmitGetIterator(Js::RegSlot iteratorLocation, Js::RegSlot iterableLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorNext(Js::RegSlot itemLocation, Js::RegSlot iteratorLocation, Js::RegSlot nextInputLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorClose(Js::RegSlot iteratorLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorComplete(Js::RegSlot doneLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorValue(Js::RegSlot valueLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\n\nvoid EmitDestructuredElement(ParseNode *elem, Js::RegSlot sourceLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo *funcInfo)\n{\n    switch (elem->nop)\n    {\n    case knopVarDecl:\n    case knopLetDecl:\n    case knopConstDecl:\n        // We manually need to set NeedDeclaration since the node won't be visited.\n        elem->sxVar.sym->SetNeedDeclaration(false);\n        break;\n\n    default:\n        EmitReference(elem, byteCodeGenerator, funcInfo);\n    }\n\n    EmitAssignment(nullptr, elem, sourceLocation, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseReference(elem);\n}\n\nvoid EmitDestructuredRestArray(ParseNode *elem,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::RegSlot restArrayLocation = funcInfo->AcquireTmpRegister();\n    bool isAssignmentTarget = !(elem->sxUni.pnode1->IsPattern() || elem->sxUni.pnode1->IsVarLetOrConst());\n\n    if (isAssignmentTarget)\n    {\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n        EmitReference(elem->sxUni.pnode1, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n    }\n\n    byteCodeGenerator->Writer()->Reg1Unsigned1(\n        Js::OpCode::NewScArray,\n        restArrayLocation,\n        ByteCodeGenerator::DefaultArraySize);\n\n    // BytecodeGen can't convey to IRBuilder that some of the temporaries used here are live. When we\n    // have a rest parameter, a counter is used in a loop for the array index, but there is no way to\n    // convey this is live on the back edge.\n    // As a workaround, we have a persistent var reg that is used for the loop counter\n    Js::RegSlot counterLocation = elem->location;\n    // TODO[ianhall]: Is calling EnregisterConstant() during Emit phase allowed?\n    Js::RegSlot zeroConstantReg = byteCodeGenerator->EnregisterConstant(0);\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, counterLocation, zeroConstantReg);\n\n    // loopTop:\n    Js::ByteCodeLabel loopTop = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->MarkLabel(loopTop);\n\n    Js::RegSlot itemLocation = funcInfo->AcquireTmpRegister();\n\n    EmitIteratorNext(itemLocation, iteratorLocation, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n    Js::ByteCodeLabel iteratorDone = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, iteratorDone, doneLocation);\n\n    Js::RegSlot valueLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorValue(valueLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->Writer()->Element(\n        ByteCodeGenerator::GetStElemIOpCode(funcInfo),\n        valueLocation, restArrayLocation, counterLocation);\n    funcInfo->ReleaseTmpRegister(valueLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n    funcInfo->ReleaseTmpRegister(itemLocation);\n\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Incr_A, counterLocation, counterLocation);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->Writer()->Br(loopTop);\n\n    // iteratorDone:\n    byteCodeGenerator->Writer()->MarkLabel(iteratorDone);\n\n    ParseNode *restElem = elem->sxUni.pnode1;\n    if (isAssignmentTarget)\n    {\n        EmitAssignment(nullptr, restElem, restArrayLocation, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseReference(restElem);\n    }\n    else\n    {\n        EmitDestructuredElement(restElem, restArrayLocation, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(restArrayLocation);\n}\n\nvoid EmitDestructuredArray(\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo);\n\nvoid EmitIteratorCloseIfNotDone(Js::RegSlot iteratorLocation, Js::RegSlot doneLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::ByteCodeLabel skipCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, skipCloseLabel, doneLocation);\n\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCloseLabel);\n}\n\n/*\n  EmitDestructuredArray(lhsArray, rhs):\n    iterator = rhs[@@iterator]\n\n    if lhsArray empty\n      return\n\n    for each element in lhsArray except rest\n      value = iterator.next()\n      if element is a nested destructured array\n        EmitDestructuredArray(element, value)\n      else\n        if value is undefined and there is an initializer\n          evaluate initializer\n          evaluate element reference\n          element = initializer\n        else\n          element = value\n\n    if lhsArray has a rest element\n      rest = []\n      while iterator is not done\n        value = iterator.next()\n        rest.append(value)\n*/\nvoid EmitDestructuredArrayCore(\n    ParseNode *list,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo\n    )\n{\n    Assert(list != nullptr);\n\n    ParseNode *elem = nullptr;\n    while (list != nullptr)\n    {\n        ParseNode *init = nullptr;\n\n        if (list->nop == knopList)\n        {\n            elem = list->sxBin.pnode1;\n        }\n        else\n        {\n            elem = list;\n        }\n\n        if (elem->nop == knopEllipsis)\n        {\n            break;\n        }\n\n        switch (elem->nop)\n        {\n        case knopAsg:\n            // An assignment node will always have an initializer\n            init = elem->sxBin.pnode2;\n            elem = elem->sxBin.pnode1;\n            break;\n\n        case knopVarDecl:\n        case knopLetDecl:\n        case knopConstDecl:\n            init = elem->sxVar.pnodeInit;\n            break;\n\n        default:\n            break;\n        }\n\n        byteCodeGenerator->StartStatement(elem);\n\n        bool isAssignmentTarget = !(elem->IsPattern() || elem->IsVarLetOrConst());\n\n        if (isAssignmentTarget)\n        {\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n            EmitReference(elem, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n        Js::RegSlot itemLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorNext(itemLocation, iteratorLocation, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n        Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorComplete(doneLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n        if (elem->nop == knopEmpty)\n        {\n            if (list->nop == knopList)\n            {\n                list = list->sxBin.pnode2;\n                funcInfo->ReleaseTmpRegister(doneLocation);\n                funcInfo->ReleaseTmpRegister(itemLocation);\n                continue;\n            }\n            else\n            {\n                Assert(list->nop == knopEmpty);\n                EmitIteratorCloseIfNotDone(iteratorLocation, doneLocation, byteCodeGenerator, funcInfo);\n                funcInfo->ReleaseTmpRegister(doneLocation);\n                funcInfo->ReleaseTmpRegister(itemLocation);\n                break;\n            }\n        }\n\n        // If the iterator hasn't completed, skip assigning undefined.\n        Js::ByteCodeLabel iteratorAlreadyDone = byteCodeGenerator->Writer()->DefineLabel();\n        byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, iteratorAlreadyDone, doneLocation);\n\n        // We're not done with the iterator, so assign the .next() value.\n        Js::RegSlot valueLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorValue(valueLocation, itemLocation, byteCodeGenerator, funcInfo);\n        Js::ByteCodeLabel beforeDefaultAssign = byteCodeGenerator->Writer()->DefineLabel();\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n        byteCodeGenerator->Writer()->Br(beforeDefaultAssign);\n\n        // iteratorAlreadyDone:\n        byteCodeGenerator->Writer()->MarkLabel(iteratorAlreadyDone);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocation, funcInfo->undefinedConstantRegister);\n\n        // beforeDefaultAssign:\n        byteCodeGenerator->Writer()->MarkLabel(beforeDefaultAssign);\n\n        if (elem->IsPattern())\n        {\n            // If we get an undefined value and have an initializer, use it in place of undefined.\n            if (init != nullptr)\n            {\n                /*\n                the IR builder uses two symbols for a temp register in the if else path\n                R9 <- R3\n                if (...)\n                R9 <- R2\n                R10 = R9.<property>  // error -> IR creates a new lifetime for the if path, and the direct path dest is not referenced\n                hence we have to create a new temp\n\n                TEMP REG USED TO FIX THIS PRODUCES THIS\n                R9 <- R3\n                if (BrEq_A R9, R3)\n                R10 <- R2               :\n                else\n                R10 <- R9               : skipdefault\n                ...  = R10[@@iterator]  : loadIter\n                */\n\n                // Temp Register\n                Js::RegSlot valueLocationTmp = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->StartStatement(init);\n\n                Js::ByteCodeLabel skipDefault = byteCodeGenerator->Writer()->DefineLabel();\n                Js::ByteCodeLabel loadIter = byteCodeGenerator->Writer()->DefineLabel();\n\n                // check value is undefined\n                byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrNeq_A, skipDefault, valueLocation, funcInfo->undefinedConstantRegister);\n\n                // Evaluate the default expression and assign it.\n                Emit(init, byteCodeGenerator, funcInfo, false);\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocationTmp, init->location);\n                funcInfo->ReleaseLoc(init);\n\n                // jmp to loadIter\n                byteCodeGenerator->Writer()->Br(loadIter);\n\n                // skipDefault:\n                byteCodeGenerator->Writer()->MarkLabel(skipDefault);\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocationTmp, valueLocation);\n\n                // loadIter:\n                // @@iterator\n                byteCodeGenerator->Writer()->MarkLabel(loadIter);\n                byteCodeGenerator->EndStatement(init);\n\n                if (elem->nop == knopObjectPattern)\n                {\n                    EmitDestructuredObject(elem, valueLocationTmp, byteCodeGenerator, funcInfo);\n                }\n                else\n                {\n                    // Recursively emit a destructured array using the current .next() as the RHS.\n                    EmitDestructuredArray(elem, valueLocationTmp, byteCodeGenerator, funcInfo);\n                }\n\n                funcInfo->ReleaseTmpRegister(valueLocationTmp);\n            }\n            else\n            {\n                if (elem->nop == knopObjectPattern)\n                {\n                    EmitDestructuredObject(elem, valueLocation, byteCodeGenerator, funcInfo);\n                }\n                else\n                {\n                    // Recursively emit a destructured array using the current .next() as the RHS.\n                    EmitDestructuredArray(elem, valueLocation, byteCodeGenerator, funcInfo);\n                }\n            }\n        }\n        else\n        {\n            EmitDestructuredValueOrInitializer(elem, valueLocation, init, isAssignmentTarget, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n        if (list->nop != knopList)\n        {\n            EmitIteratorCloseIfNotDone(iteratorLocation, doneLocation, byteCodeGenerator, funcInfo);\n        }\n\n        funcInfo->ReleaseTmpRegister(valueLocation);\n        funcInfo->ReleaseTmpRegister(doneLocation);\n        funcInfo->ReleaseTmpRegister(itemLocation);\n\n        if (isAssignmentTarget)\n        {\n            funcInfo->ReleaseReference(elem);\n        }\n\n        byteCodeGenerator->EndStatement(elem);\n\n        if (list->nop == knopList)\n        {\n            list = list->sxBin.pnode2;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    // If we saw a rest element, emit the rest array.\n    if (elem != nullptr && elem->nop == knopEllipsis)\n    {\n        EmitDestructuredRestArray(elem,\n            iteratorLocation,\n            shouldCallReturnFunctionLocation,\n            shouldCallReturnFunctionLocationFinally,\n            byteCodeGenerator,\n            funcInfo);\n    }\n}\n\n// Generating\n// try {\n//    CallIteratorClose\n// } catch (e) {\n//    do nothing \n// }\n\nvoid EmitTryCatchAroundClose(\n    Js::RegSlot iteratorLocation,\n    Js::ByteCodeLabel endLabel,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    //\n    // There is no need to add TryScopeRecord here as we are going to call 'return' function and there is not yield expression here.\n\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->Br(endLabel);\n\n    byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n    Js::RegSlot catchParamLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, catchParamLocation);\n    funcInfo->ReleaseTmpRegister(catchParamLocation);\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n}\n\nstruct ByteCodeGenerator::TryScopeRecord : public JsUtil::DoublyLinkedListElement<TryScopeRecord>\n{\n    Js::OpCode op;\n    Js::ByteCodeLabel label;\n    Js::RegSlot reg1;\n    Js::RegSlot reg2;\n\n    TryScopeRecord(Js::OpCode op, Js::ByteCodeLabel label) : op(op), label(label), reg1(Js::Constants::NoRegister), reg2(Js::Constants::NoRegister) { }\n    TryScopeRecord(Js::OpCode op, Js::ByteCodeLabel label, Js::RegSlot r1, Js::RegSlot r2) : op(op), label(label), reg1(r1), reg2(r2) { }\n};\n\n// Generating\n// catch(e) {\n//      if (shouldCallReturn)\n//          CallReturnWhichWrappedByTryCatch\n//      throw e;\n// }\nvoid EmitTopLevelCatch(Js::ByteCodeLabel catchLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnLocation,\n    Js::RegSlot shouldCallReturnLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel afterCatchBlockLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->Br(afterCatchBlockLabel);\n    byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n\n    Js::RegSlot catchParamLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, catchParamLocation);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForCatch(Js::OpCode::ResumeCatch, catchLabel);\n    if (funcInfo->byteCodeFunction->IsCoroutine())\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForCatch);\n    }\n\n    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnLocationFinally);\n    EmitTryCatchAroundClose(iteratorLocation, skipCallCloseLabel, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);\n\n    // Rethrow the exception.\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Throw, catchParamLocation);\n\n    funcInfo->ReleaseTmpRegister(catchParamLocation);\n\n    if (funcInfo->byteCodeFunction->IsCoroutine())\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->MarkLabel(afterCatchBlockLabel);\n}\n\n// Generating\n// finally {\n//      if (shouldCallReturn)\n//          CallReturn\n// }\n\nvoid EmitTopLevelFinally(Js::ByteCodeLabel finallyLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnLocation,\n    Js::RegSlot yieldExceptionLocation,\n    Js::RegSlot yieldOffsetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    Js::ByteCodeLabel afterFinallyBlockLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    byteCodeGenerator->Writer()->Br(afterFinallyBlockLabel);\n    byteCodeGenerator->Writer()->MarkLabel(finallyLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForFinally(Js::OpCode::ResumeFinally, finallyLabel, yieldExceptionLocation, yieldOffsetLocation);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForFinally);\n    }\n\n    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        funcInfo->ReleaseTmpRegister(yieldOffsetLocation);\n        funcInfo->ReleaseTmpRegister(yieldExceptionLocation);\n    }\n\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::LeaveNull);\n    byteCodeGenerator->Writer()->MarkLabel(afterFinallyBlockLabel);\n}\n\nvoid EmitCatchAndFinallyBlocks(Js::ByteCodeLabel catchLabel,\n    Js::ByteCodeLabel finallyLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    Js::RegSlot yieldExceptionLocation,\n    Js::RegSlot yieldOffsetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo\n    )\n{\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    EmitTopLevelCatch(catchLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        byteCodeGenerator,\n        funcInfo);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    EmitTopLevelFinally(finallyLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocationFinally,\n        yieldExceptionLocation,\n        yieldOffsetLocation,\n        byteCodeGenerator,\n        funcInfo);\n\n    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocationFinally);\n    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocation);\n}\n\n// Emit a wrapper try..finaly block around the destructuring elements\nvoid EmitDestructuredArray(\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(lhs);\n    Js::RegSlot iteratorLocation = funcInfo->AcquireTmpRegister();\n\n    EmitGetIterator(iteratorLocation, rhsLocation, byteCodeGenerator, funcInfo);\n\n    Assert(lhs->nop == knopArrayPattern);\n    ParseNode *list = lhs->sxArrLit.pnode1;\n\n    if (list == nullptr)\n    { // Handline this case ([] = obj);\n        EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n        // No elements to bind or assign.\n        funcInfo->ReleaseTmpRegister(iteratorLocation);\n        byteCodeGenerator->EndStatement(lhs);\n        return;\n    }\n\n    // This variable facilitates on when to call the return function (which is Iterator close). When we are emitting bytecode for destructuring element\n    // this variable will be set to true.\n    Js::RegSlot shouldCallReturnFunctionLocation = funcInfo->AcquireTmpRegister();\n    Js::RegSlot shouldCallReturnFunctionLocationFinally = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->SetHasFinally(true);\n    byteCodeGenerator->SetHasTry(true);\n    byteCodeGenerator->TopFuncInfo()->byteCodeFunction->SetDontInline(true);\n\n    Js::RegSlot regException = Js::Constants::NoRegister;\n    Js::RegSlot regOffset = Js::Constants::NoRegister;\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    if (isCoroutine)\n    {\n        regException = funcInfo->AcquireTmpRegister();\n        regOffset = funcInfo->AcquireTmpRegister();\n    }\n\n    // Insert try node here \n    Js::ByteCodeLabel finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTryFinally(Js::OpCode::TryFinallyWithYield, finallyLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n        tryRecForTryFinally.reg1 = regException;\n        tryRecForTryFinally.reg2 = regOffset;\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTryFinally);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n    }\n\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n    }\n\n    EmitDestructuredArrayCore(list,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        byteCodeGenerator,\n        funcInfo);\n\n    EmitCatchAndFinallyBlocks(catchLabel,\n        finallyLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        regException,\n        regOffset,\n        byteCodeGenerator,\n        funcInfo);\n\n    funcInfo->ReleaseTmpRegister(iteratorLocation);\n\n    byteCodeGenerator->EndStatement(lhs);\n}\n\nvoid EmitNameInvoke(Js::RegSlot lhsLocation,\n    Js::RegSlot objectLocation,\n    ParseNodePtr nameNode,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo)\n{\n    Assert(nameNode != nullptr);\n    if (nameNode->nop == knopComputedName)\n    {\n        ParseNodePtr pnode1 = nameNode->sxUni.pnode1;\n        Emit(pnode1, byteCodeGenerator, funcInfo, false/*isConstructorCall*/);\n\n        byteCodeGenerator->Writer()->Element(Js::OpCode::LdElemI_A, lhsLocation, objectLocation, pnode1->location);\n        funcInfo->ReleaseLoc(pnode1);\n    }\n    else\n    {\n        Assert(nameNode->nop == knopName || nameNode->nop == knopStr);\n        Symbol *sym = nameNode->sxPid.sym;\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(byteCodeGenerator) : nameNode->sxPid.pid->GetPropertyId();\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(objectLocation, propertyId, false/*isLoadMethod*/, false/*isStore*/);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, lhsLocation, objectLocation, cacheId);\n    }\n}\n\nvoid EmitDestructuredValueOrInitializer(ParseNodePtr lhsElementNode,\n    Js::RegSlot rhsLocation,\n    ParseNodePtr initializer,\n    bool isNonPatternAssignmentTarget,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // If we have initializer we need to see if the destructured value is undefined or not - if it is undefined we need to assign initializer\n\n    Js::ByteCodeLabel useDefault = -1;\n    Js::ByteCodeLabel end = -1;\n    Js::RegSlot rhsLocationTmp = rhsLocation;\n\n    if (initializer != nullptr)\n    {\n        rhsLocationTmp = funcInfo->AcquireTmpRegister();\n\n        useDefault = byteCodeGenerator->Writer()->DefineLabel();\n        end = byteCodeGenerator->Writer()->DefineLabel();\n\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrEq_A, useDefault, rhsLocation, funcInfo->undefinedConstantRegister);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocationTmp, rhsLocation);\n\n        byteCodeGenerator->Writer()->Br(end);\n        byteCodeGenerator->Writer()->MarkLabel(useDefault);\n\n        Emit(initializer, byteCodeGenerator, funcInfo, false/*isConstructorCall*/);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocationTmp, initializer->location);\n        funcInfo->ReleaseLoc(initializer);\n\n        byteCodeGenerator->Writer()->MarkLabel(end);\n    }\n\n    if (lhsElementNode->nop == knopArrayPattern)\n    {\n        EmitDestructuredArray(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else if (lhsElementNode->nop == knopObjectPattern)\n    {\n        EmitDestructuredObject(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else if (isNonPatternAssignmentTarget)\n    {\n        EmitAssignment(nullptr, lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitDestructuredElement(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n\n    if (initializer != nullptr)\n    {\n        funcInfo->ReleaseTmpRegister(rhsLocationTmp);\n    }\n}\n\nvoid EmitDestructuredObjectMember(ParseNodePtr memberNode,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Assert(memberNode->nop == knopObjectPatternMember);\n\n    Js::RegSlot nameLocation = funcInfo->AcquireTmpRegister();\n    EmitNameInvoke(nameLocation, rhsLocation, memberNode->sxBin.pnode1, byteCodeGenerator, funcInfo);\n\n    // Imagine we are transforming\n    // {x:x1} = {} to x1 = {}.x  (here x1 is the second node of the member but that is our lhsnode)\n\n    ParseNodePtr lhsElementNode = memberNode->sxBin.pnode2;\n    ParseNodePtr init = nullptr;\n    if (lhsElementNode->IsVarLetOrConst())\n    {\n        init = lhsElementNode->sxVar.pnodeInit;\n    }\n    else if (lhsElementNode->nop == knopAsg)\n    {\n        init = lhsElementNode->sxBin.pnode2;\n        lhsElementNode = lhsElementNode->sxBin.pnode1;\n    }\n\n    EmitDestructuredValueOrInitializer(lhsElementNode, nameLocation, init, false /*isNonPatternAssignmentTarget*/, byteCodeGenerator, funcInfo);\n\n    funcInfo->ReleaseTmpRegister(nameLocation);\n}\n\nvoid EmitDestructuredObject(ParseNode *lhs,\n    Js::RegSlot rhsLocationOrig,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Assert(lhs->nop == knopObjectPattern);\n    ParseNodePtr pnode1 = lhs->sxUni.pnode1;\n\n    byteCodeGenerator->StartStatement(lhs);\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    Js::RegSlot rhsLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocation, rhsLocationOrig);\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrNeq_A, skipThrow, rhsLocation, funcInfo->undefinedConstantRegister);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ObjectCoercible));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n\n    if (pnode1 != nullptr)\n    {\n        Assert(pnode1->nop == knopList || pnode1->nop == knopObjectPatternMember);\n\n        ParseNodePtr current = pnode1;\n        while (current->nop == knopList)\n        {\n            ParseNodePtr memberNode = current->sxBin.pnode1;\n            EmitDestructuredObjectMember(memberNode, rhsLocation, byteCodeGenerator, funcInfo);\n            current = current->sxBin.pnode2;\n        }\n        EmitDestructuredObjectMember(current, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(rhsLocation);\n    byteCodeGenerator->EndStatement(lhs);\n}\n\nvoid EmitAssignment(\n    ParseNode *asgnNode,\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    switch (lhs->nop)\n    {\n        // assignment to a local or global variable\n    case knopVarDecl:\n    case knopLetDecl:\n    case knopConstDecl:\n    {\n        Symbol *sym = lhs->sxVar.sym;\n        Assert(sym != nullptr);\n        byteCodeGenerator->EmitPropStore(rhsLocation, sym, nullptr, funcInfo, lhs->nop == knopLetDecl, lhs->nop == knopConstDecl);\n        break;\n    }\n\n    case knopName:\n    {\n        byteCodeGenerator->EmitPropStore(rhsLocation, lhs->sxPid.sym, lhs->sxPid.pid, funcInfo);\n        break;\n    }\n\n    // x.y =\n    case knopDot:\n    {\n        // PutValue(x, \"y\", rhs)\n        Js::PropertyId propertyId = lhs->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(lhs->sxBin.pnode1->location, propertyId, false, true);\n        if (lhs->sxBin.pnode1->nop == knopSuper)\n        {\n            Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n            byteCodeGenerator->Writer()->PatchablePropertyWithThisPtr(Js::OpCode::StSuperFld, rhsLocation, tmpReg, funcInfo->thisPointerRegister, cacheId);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->PatchableProperty(\n                ByteCodeGenerator::GetStFldOpCode(funcInfo, false, false, false, false), rhsLocation, lhs->sxBin.pnode1->location, cacheId);\n        }\n\n        break;\n    }\n\n    case knopIndex:\n    {\n        byteCodeGenerator->Writer()->Element(\n            ByteCodeGenerator::GetStElemIOpCode(funcInfo),\n            rhsLocation, lhs->sxBin.pnode1->location, lhs->sxBin.pnode2->location);\n        break;\n    }\n\n    case knopObjectPattern:\n    {\n        Assert(byteCodeGenerator->IsES6DestructuringEnabled());\n        // Copy the rhs value to be the result of the assignment if needed.\n        if (asgnNode != nullptr)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n        return EmitDestructuredObject(lhs, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    case knopArrayPattern:\n    {\n        Assert(byteCodeGenerator->IsES6DestructuringEnabled());\n        // Copy the rhs value to be the result of the assignment if needed.\n        if (asgnNode != nullptr)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n        return EmitDestructuredArray(lhs, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    case knopArray:\n    case knopObject:\n        // Assignment to array/object can get through to byte code gen when the parser fails to convert destructuring\n        // assignment to pattern (because of structural mismatch between LHS & RHS?). Revisit when we nail\n        // down early vs. runtime errors for destructuring.\n        byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAssignTo));\n        break;\n\n    default:\n        Assert(!PHASE_ON1(Js::EarlyReferenceErrorsPhase));\n        byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAssignTo));\n        break;\n    }\n\n    if (asgnNode != nullptr)\n    {\n        // We leave it up to the caller to pass this node only if the assignment expression is used.\n        if (asgnNode->location != rhsLocation)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n    }\n}\n\nvoid EmitLoad(\n    ParseNode *lhs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // Emit the instructions to load the value into the LHS location. Do not assign/free any temps\n    // in the process.\n    // We usually get here as part of an op-equiv expression: x.y += z;\n    // In such a case, x has to be emitted first, then the value of x.y loaded (by this function), then z emitted.\n    switch (lhs->nop)\n    {\n\n        // load of a local or global variable\n    case knopName:\n    {\n        funcInfo->AcquireLoc(lhs);\n        byteCodeGenerator->EmitPropLoad(lhs->location, lhs->sxPid.sym, lhs->sxPid.pid, funcInfo);\n        break;\n    }\n\n    // = x.y\n    case knopDot:\n    {\n        // get field id for \"y\"\n        Js::PropertyId propertyId = lhs->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(lhs->sxBin.pnode1->location, propertyId, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, lhs->location, lhs->sxBin.pnode1->location, cacheId);\n        break;\n    }\n\n    case knopIndex:\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Element(\n            Js::OpCode::LdElemI_A, lhs->location, lhs->sxBin.pnode1->location, lhs->sxBin.pnode2->location);\n        break;\n\n        // f(x) +=\n    case knopCall:\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        EmitCall(lhs, /*rhs=*/ Js::Constants::NoRegister, byteCodeGenerator, funcInfo, /*fReturnValue=*/ false, /*fEvaluateComponents=*/ false, /*fHasNewTarget=*/ false);\n        break;\n\n    default:\n        funcInfo->AcquireLoc(lhs);\n        Emit(lhs, byteCodeGenerator, funcInfo, false);\n        break;\n    }\n}\n\nvoid EmitList(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            byteCodeGenerator->EmitTopLevelStatement(pnode->sxBin.pnode1, funcInfo, false);\n            pnode = pnode->sxBin.pnode2;\n        }\n        byteCodeGenerator->EmitTopLevelStatement(pnode, funcInfo, false);\n    }\n}\n\nvoid EmitSpreadArgToListBytecodeInstr(ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, Js::RegSlot argLoc, Js::ProfileId callSiteId, Js::ArgSlot &argIndex)\n{\n    Js::RegSlot regVal = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, argLoc);\n    byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, regVal, callSiteId);\n    funcInfo->ReleaseTmpRegister(regVal);\n}\n\nsize_t EmitArgs(\n    ParseNode *pnode,\n    BOOL fAssignRegs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr\n    )\n{\n    Js::ArgSlot argIndex = 0;\n    Js::ArgSlot spreadIndex = 0;\n\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            // If this is a put, the arguments have already been evaluated (see EmitReference).\n            // We just need to emit the ArgOut instructions.\n            if (fAssignRegs)\n            {\n                Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            }\n\n            if (pnode->sxBin.pnode1->nop == knopEllipsis)\n            {\n                Assert(spreadIndices != nullptr);\n                spreadIndices->elements[spreadIndex++] = argIndex + 1; // account for 'this'\n                EmitSpreadArgToListBytecodeInstr(byteCodeGenerator, funcInfo, pnode->sxBin.pnode1->location, callSiteId, argIndex);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, pnode->sxBin.pnode1->location, callSiteId);\n            }\n            if (fAssignRegs)\n            {\n                funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n            }\n\n            pnode = pnode->sxBin.pnode2;\n        }\n\n        // If this is a put, the call target has already been evaluated (see EmitReference).\n        if (fAssignRegs)\n        {\n            Emit(pnode, byteCodeGenerator, funcInfo, false);\n        }\n\n        if (pnode->nop == knopEllipsis)\n        {\n            Assert(spreadIndices != nullptr);\n            spreadIndices->elements[spreadIndex++] = argIndex + 1; // account for 'this'\n            EmitSpreadArgToListBytecodeInstr(byteCodeGenerator, funcInfo, pnode->location, callSiteId, argIndex);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, pnode->location, callSiteId);\n        }\n\n        if (fAssignRegs)\n        {\n            funcInfo->ReleaseLoc(pnode);\n        }\n    }\n\n    return argIndex;\n}\n\nvoid EmitArgListStart(\n    Js::RegSlot thisLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId)\n{\n    if (thisLocation != Js::Constants::NoRegister)\n    {\n        // Emit the \"this\" object.\n        byteCodeGenerator->Writer()->ArgOut<true>(0, thisLocation, callSiteId);\n    }\n}\n\nJs::ArgSlot EmitArgListEnd(\n    ParseNode *pnode,\n    Js::RegSlot rhsLocation,\n    Js::RegSlot thisLocation,\n    Js::RegSlot evalLocation,\n    Js::RegSlot newTargetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    size_t argIndex,\n    Js::ProfileId callSiteId)\n{\n    BOOL fEvalInModule = false;\n    BOOL fIsPut = (rhsLocation != Js::Constants::NoRegister);\n    BOOL fIsEval = (evalLocation != Js::Constants::NoRegister);\n    BOOL fHasNewTarget = (newTargetLocation != Js::Constants::NoRegister);\n\n    Js::ArgSlot argSlotIndex = (Js::ArgSlot) argIndex;\n    static const Js::ArgSlot maxExtraArgSlot = 4;  // max(extraEvalArg, extraArg), where extraEvalArg==2 (moduleRoot,env), extraArg==4 (this, eval, evalInModule, newTarget)\n\n    // check for integer overflow with margin for increments below to calculate argument count\n    if ((size_t)argSlotIndex != argIndex || argSlotIndex + maxExtraArgSlot < argSlotIndex)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    Js::ArgSlot evalIndex;\n\n    if (fIsPut)\n    {\n        // Emit the assigned value as an additional operand. Note that the value has already been evaluated.\n        // We just need to emit the ArgOut instruction.\n        argSlotIndex++;\n        byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex, rhsLocation, callSiteId);\n    }\n\n    if (fIsEval && argSlotIndex > 0)\n    {\n        Assert(!fHasNewTarget);\n\n        // Pass the frame display as an extra argument to \"eval\".\n        // Do this only if eval is called with some args\n        Js::RegSlot evalEnv;\n        if (funcInfo->IsGlobalFunction() && !(funcInfo->GetIsStrictMode() && byteCodeGenerator->GetFlags() & fscrEval))\n        {\n            // Use current environment as the environment for the function being called when:\n            // - this is the root global function (not an eval's global function)\n            // - this is an eval's global function that is not in strict mode (see else block)\n            evalEnv = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // Use the frame display as the environment for the function being called when:\n            // - this is not a global function and thus it will have its own scope\n            // - this is an eval's global function that is in strict mode, since in strict mode the eval's global function\n            //   has its own scope\n            evalEnv = funcInfo->frameDisplayRegister;\n        }\n\n        evalEnv = byteCodeGenerator->PrependLocalScopes(evalEnv, evalLocation, funcInfo);\n\n        Js::ModuleID moduleID = byteCodeGenerator->GetModuleID();\n        if (moduleID != kmodGlobal)\n        {\n            // Pass both the module root and the environment.\n            fEvalInModule = true;\n            byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex + 1, ByteCodeGenerator::RootObjectRegister, callSiteId);\n            evalIndex = argSlotIndex + 2;\n        }\n        else\n        {\n            // Just pass the environment.\n            evalIndex = argSlotIndex + 1;\n        }\n\n        if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n        {\n            byteCodeGenerator->Writer()->ArgOutEnv(evalIndex);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->ArgOut<false>(evalIndex, evalEnv, callSiteId);\n        }\n    }\n\n    if (fHasNewTarget)\n    {\n        Assert(!fIsEval);\n\n        byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex + 1, newTargetLocation, callSiteId);\n    }\n\n    Js::ArgSlot argIntCount = argSlotIndex + 1 + (Js::ArgSlot)fIsEval + (Js::ArgSlot)fEvalInModule + (Js::ArgSlot)fHasNewTarget;\n\n    // eval and no args passed, return 1 as argument count\n    if (fIsEval && pnode == nullptr)\n    {\n        return 1;\n    }\n\n    return argIntCount;\n}\n\nJs::ArgSlot EmitArgList(\n    ParseNode *pnode,\n    Js::RegSlot rhsLocation,\n    Js::RegSlot thisLocation,\n    Js::RegSlot newTargetLocation,\n    BOOL fIsEval,\n    BOOL fAssignRegs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    uint16 spreadArgCount = 0,\n    Js::AuxArray<uint32> **spreadIndices = nullptr)\n{\n    // This function emits the arguments for a call.\n    // ArgOut's with uses immediately following defs.\n\n    EmitArgListStart(thisLocation, byteCodeGenerator, funcInfo, callSiteId);\n\n    Js::RegSlot evalLocation = Js::Constants::NoRegister;\n\n    //\n    // If Emitting arguments for eval and assigning registers, get a tmpLocation for eval.\n    // This would be used while generating frameDisplay in EmitArgListEnd.\n    //\n    if (fIsEval)\n    {\n        evalLocation = funcInfo->AcquireTmpRegister();\n    }\n\n    if (spreadArgCount > 0)\n    {\n        const size_t extraAlloc = spreadArgCount * sizeof(uint32);\n        Assert(spreadIndices != nullptr);\n        *spreadIndices = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<uint32>, spreadArgCount);\n    }\n\n    size_t argIndex = EmitArgs(pnode, fAssignRegs, byteCodeGenerator, funcInfo, callSiteId, spreadIndices == nullptr ? nullptr : *spreadIndices);\n\n    Js::ArgSlot argumentsCount = EmitArgListEnd(pnode, rhsLocation, thisLocation, evalLocation, newTargetLocation, byteCodeGenerator, funcInfo, argIndex, callSiteId);\n\n    if (fIsEval)\n    {\n        funcInfo->ReleaseTmpRegister(evalLocation);\n    }\n\n    return argumentsCount;\n}\n\nvoid EmitConstantArgsToVarArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) Js::Var *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        if (args->sxBin.pnode1->nop == knopInt)\n        {\n            int value = args->sxBin.pnode1->sxInt.lw;\n            vars[index++] = Js::TaggedInt::ToVarUnchecked(value);\n        }\n        else if (args->sxBin.pnode1->nop == knopFlt)\n        {\n            Js::Var number = Js::JavascriptNumber::New(args->sxBin.pnode1->sxFlt.dbl, byteCodeGenerator->GetScriptContext());\n#if ! FLOATVAR\n            byteCodeGenerator->GetScriptContext()->BindReference(number);\n#endif\n            vars[index++] = number;\n        }\n        else\n        {\n            AnalysisAssert(false);\n        }\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    if (args->nop == knopInt)\n    {\n        int value = args->sxInt.lw;\n        vars[index++] = Js::TaggedInt::ToVarUnchecked(value);\n    }\n    else if (args->nop == knopFlt)\n    {\n        Js::Var number = Js::JavascriptNumber::New(args->sxFlt.dbl, byteCodeGenerator->GetScriptContext());\n#if ! FLOATVAR\n        byteCodeGenerator->GetScriptContext()->BindReference(number);\n#endif\n        vars[index++] = number;\n    }\n    else\n    {\n        AnalysisAssert(false);\n    }\n}\n\nvoid EmitConstantArgsToIntArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) int32 *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        Assert(args->sxBin.pnode1->nop == knopInt);\n        vars[index++] = args->sxBin.pnode1->sxInt.lw;\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    Assert(args->nop == knopInt);\n    vars[index++] = args->sxInt.lw;\n\n    Assert(index == argCount);\n}\n\nvoid EmitConstantArgsToFltArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) double *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        OpCode nop = args->sxBin.pnode1->nop;\n        if (nop == knopInt)\n        {\n            vars[index++] = (double)args->sxBin.pnode1->sxInt.lw;\n        }\n        else\n        {\n            Assert(nop == knopFlt);\n            vars[index++] = args->sxBin.pnode1->sxFlt.dbl;\n        }\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    if (args->nop == knopInt)\n    {\n        vars[index++] = (double)args->sxInt.lw;\n    }\n    else\n    {\n        Assert(args->nop == knopFlt);\n        vars[index++] = args->sxFlt.dbl;\n    }\n\n    Assert(index == argCount);\n}\n\n//\n// Called when we have new Ctr(constant, constant...)\n//\nJs::ArgSlot EmitNewObjectOfConstants(\n    ParseNode *pnode,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    unsigned int argCount)\n{\n    EmitArgListStart(Js::Constants::NoRegister, byteCodeGenerator, funcInfo, Js::Constants::NoProfileId);\n\n    // Create the vars array\n    Js::VarArrayVarCount *vars = AnewPlus(byteCodeGenerator->GetAllocator(), (argCount - 1) * sizeof(Js::Var), Js::VarArrayVarCount, Js::TaggedInt::ToVarUnchecked(argCount - 1));\n\n    // Emit all constants to the vars array\n    EmitConstantArgsToVarArray(byteCodeGenerator, vars->elements, pnode->sxCall.pnodeArgs, argCount - 1);\n\n    // Finish the arg list\n    Js::ArgSlot actualArgCount = EmitArgListEnd(\n        pnode->sxCall.pnodeArgs,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        byteCodeGenerator,\n        funcInfo,\n        argCount - 1,\n        Js::Constants::NoProfileId);\n\n    // Make sure the cacheId to regSlot map in the ByteCodeWriter is left in a consistent state after writing NewScObject_A\n    byteCodeGenerator->Writer()->RemoveEntryForRegSlotFromCacheIdMap(pnode->sxCall.pnodeTarget->location);\n\n    // Generate the opcode with vars\n    byteCodeGenerator->Writer()->AuxiliaryContext(\n        Js::OpCode::NewScObject_A,\n        funcInfo->AcquireLoc(pnode),\n        vars,\n        sizeof(Js::VarArray) + (argCount - 1) * sizeof(Js::Var),\n        pnode->sxCall.pnodeTarget->location);\n\n    AdeletePlus(byteCodeGenerator->GetAllocator(), (argCount - 1) * sizeof(Js::VarArrayVarCount), vars);\n\n    return actualArgCount;\n}\n\nvoid EmitMethodFld(bool isRoot, bool isScoped, Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, bool registerCacheIdForCall = true)\n{\n    Js::OpCode opcode;\n    if (!isRoot)\n    {\n        if (callObjLocation == funcInfo->frameObjRegister)\n        {\n            opcode = Js::OpCode::LdLocalMethodFld;\n        }\n        else\n        {\n            opcode = Js::OpCode::LdMethodFld;\n        }\n    }\n    else if (isScoped)\n    {\n        opcode = Js::OpCode::ScopedLdMethodFld;\n    }\n    else\n    {\n        opcode = Js::OpCode::LdRootMethodFld;\n    }\n\n    if (isScoped || !isRoot)\n    {\n        Assert(isScoped || !isRoot || callObjLocation == ByteCodeGenerator::RootObjectRegister);\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(callObjLocation, propertyId, true, false);\n        if (callObjLocation == funcInfo->frameObjRegister)\n        {\n            byteCodeGenerator->Writer()->ElementP(opcode, location, cacheId, false /*isCtor*/, registerCacheIdForCall);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->PatchableProperty(opcode, location, callObjLocation, cacheId, false /*isCtor*/, registerCacheIdForCall);\n        }\n    }\n    else\n    {\n        uint cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, true, false);\n        byteCodeGenerator->Writer()->PatchableRootProperty(opcode, location, cacheId, true, false, registerCacheIdForCall);\n    }\n}\n\nvoid EmitMethodFld(ParseNode *pnode, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, bool registerCacheIdForCall = true)\n{\n    // Load a call target of the form x.y(). (Call target may be a plain knopName if we're getting it from\n    // the global object, etc.)\n    bool isRoot = pnode->nop == knopName && (pnode->sxPid.sym == nullptr || pnode->sxPid.sym->GetIsGlobal());\n    bool isScoped = (byteCodeGenerator->GetFlags() & fscrEval) != 0 ||\n        (isRoot && callObjLocation != ByteCodeGenerator::RootObjectRegister);\n\n    EmitMethodFld(isRoot, isScoped, pnode->location, callObjLocation, propertyId, byteCodeGenerator, funcInfo, registerCacheIdForCall);\n}\n\n// lhs.apply(this, arguments);\nvoid EmitApplyCall(ParseNode* pnode, Js::RegSlot rhsLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, BOOL fReturnValue)\n{\n    ParseNode* applyNode = pnode->sxCall.pnodeTarget;\n    ParseNode* thisNode = pnode->sxCall.pnodeArgs->sxBin.pnode1;\n    Assert(applyNode->nop == knopDot);\n\n    ParseNode* funcNode = applyNode->sxBin.pnode1;\n    Js::ByteCodeLabel slowPath = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel afterSlowPath = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel argsAlreadyCreated = byteCodeGenerator->Writer()->DefineLabel();\n\n    Assert(applyNode->nop == knopDot);\n\n    Emit(funcNode, byteCodeGenerator, funcInfo, false);\n\n    funcInfo->AcquireLoc(applyNode);\n    Js::PropertyId propertyId = applyNode->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n    // As we won't be emitting a call instruction for apply, no need to register the cacheId for apply\n    // load to be associated with the call. This is also required, as in the absence of a corresponding\n    // call for apply, we won't remove the entry for \"apply\" cacheId from\n    // ByteCodeWriter::callRegToLdFldCacheIndexMap, which is contrary to our assumption that we would\n    // have removed an entry from a map upon seeing its corresponding call.\n    EmitMethodFld(applyNode, funcNode->location, propertyId, byteCodeGenerator, funcInfo, false /*registerCacheIdForCall*/);\n\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdArgumentsFromFrame, argumentsLoc);\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrNotNull_A, argsAlreadyCreated, argumentsLoc);\n\n    // If apply is overridden, bail to slow path.\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFncNeqApply, slowPath, applyNode->location);\n\n    // Note: acquire and release a temp register for this stack arg pointer instead of trying to stash it\n    // in funcInfo->stackArgReg. Otherwise, we'll needlessly load and store it in jitted loop bodies and\n    // may crash if we try to unbox it on the store.\n    Js::RegSlot stackArgReg = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdStackArgPtr, stackArgReg);\n\n    Js::RegSlot argCountLocation = funcInfo->AcquireTmpRegister();\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdArgCnt, argCountLocation);\n    byteCodeGenerator->Writer()->Reg5(Js::OpCode::ApplyArgs, funcNode->location, funcNode->location, thisNode->location, stackArgReg, argCountLocation);\n\n    funcInfo->ReleaseTmpRegister(argCountLocation);\n    funcInfo->ReleaseTmpRegister(stackArgReg);\n    funcInfo->ReleaseLoc(applyNode);\n    funcInfo->ReleaseLoc(funcNode);\n\n    // Clear these nodes as they are going to be used to re-generate the slow path.\n    VisitClearTmpRegs(applyNode, byteCodeGenerator, funcInfo);\n    VisitClearTmpRegs(funcNode, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Br(afterSlowPath);\n\n    // slow path\n    byteCodeGenerator->Writer()->MarkLabel(slowPath);\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->EmitScopeObjectInit(funcInfo);\n    }\n    byteCodeGenerator->LoadHeapArguments(funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(argsAlreadyCreated);\n    EmitCall(pnode, rhsLocation, byteCodeGenerator, funcInfo, fReturnValue, /*fEvaluateComponents*/true, /*fHasNewTarget*/false);\n    byteCodeGenerator->Writer()->MarkLabel(afterSlowPath);\n}\n\nvoid EmitMethodElem(ParseNode *pnode, Js::RegSlot callObjLocation, Js::RegSlot indexLocation, ByteCodeGenerator *byteCodeGenerator)\n{\n    // Load a call target of the form x[y]().\n    byteCodeGenerator->Writer()->Element(Js::OpCode::LdMethodElem, pnode->location, callObjLocation, indexLocation);\n}\n\nvoid EmitCallTargetNoEvalComponents(\n    ParseNode *pnodeTarget,\n    BOOL fSideEffectArgs,\n    Js::RegSlot *thisLocation,\n    Js::RegSlot *callObjLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // We first get a reference to the call target, then evaluate the arguments, then\n    // evaluate the call target.\n\n    // - emit reference to target\n    //    - copy instance to scratch reg if necessary.\n    //    - assign this\n    //    - assign instance for dynamic/global name\n    // - emit args\n    // - do call (CallFld/Elem/I)\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n        *thisLocation = pnodeTarget->sxBin.pnode1->location;\n        *callObjLocation = pnodeTarget->sxBin.pnode1->location;\n        break;\n\n    case knopIndex:\n        *thisLocation = pnodeTarget->sxBin.pnode1->location;\n        *callObjLocation = pnodeTarget->sxBin.pnode1->location;\n        break;\n\n    case knopName:\n        // If the call target is a name, do some extra work to get its instance and the \"this\" pointer.\n        byteCodeGenerator->EmitLoadInstance(pnodeTarget->sxPid.sym, pnodeTarget->sxPid.pid, thisLocation, callObjLocation, funcInfo);\n        if (*thisLocation == Js::Constants::NoRegister)\n        {\n            *thisLocation = funcInfo->undefinedConstantRegister;\n        }\n\n        break;\n\n    default:\n        *thisLocation = funcInfo->undefinedConstantRegister;\n        break;\n    }\n}\n\nvoid EmitSuperMethodBegin(\n    ParseNode *pnodeTarget,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    FuncInfo *parentFuncInfo = funcInfo;\n    if (parentFuncInfo->IsLambda())\n    {\n        parentFuncInfo = byteCodeGenerator->FindEnclosingNonLambda();\n    }\n\n    if (pnodeTarget->sxBin.pnode1->nop == knopSuper && parentFuncInfo->IsClassConstructor() && !parentFuncInfo->IsBaseClassConstructor())\n    {\n        byteCodeGenerator->EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister, /*chkUndecl*/ true);\n    }\n}\n\nvoid EmitCallTarget(\n    ParseNode *pnodeTarget,\n    BOOL fSideEffectArgs,\n    Js::RegSlot *thisLocation,\n    Js::RegSlot *callObjLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // - emit target\n    //    - assign this\n    // - emit args\n    // - do call\n\n    // The call target is fully evaluated before the argument list. Note that we're not handling\n    // put-call cases here currently, as such cases only apply to host objects\n    // and are very unlikely to behave differently depending on the order of evaluation.\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs)\n        {\n            // Though we're done with target evaluation after this point, still protect opnd1 from\n            // arg side-effects as it's the \"this\" pointer.\n            SaveOpndValue(pnodeTarget->sxBin.pnode1, funcInfo);\n        }\n\n        if ((pnodeTarget->sxBin.pnode2->nop == knopName) && ((pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::apply) || (pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::call)))\n        {\n            pnodeTarget->sxBin.pnode1->SetIsCallApplyTargetLoad();\n        }\n\n        Emit(pnodeTarget->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Js::PropertyId propertyId = pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n        \n        Js::RegSlot protoLocation =\n            (pnodeTarget->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            pnodeTarget->sxBin.pnode1->location;\n\n        EmitSuperMethodBegin(pnodeTarget, byteCodeGenerator, funcInfo);\n        EmitMethodFld(pnodeTarget, protoLocation, propertyId, byteCodeGenerator, funcInfo);\n\n        // Function calls on the 'super' object should maintain current 'this' pointer\n        *thisLocation = (pnodeTarget->sxBin.pnode1->nop == knopSuper) ? funcInfo->thisPointerRegister : pnodeTarget->sxBin.pnode1->location;\n        break;\n    }\n\n    case knopIndex:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs || !(ParseNode::Grfnop(pnodeTarget->sxBin.pnode2->nop) & fnopLeaf))\n        {\n            // Though we're done with target evaluation after this point, still protect opnd1 from\n            // arg or opnd2 side-effects as it's the \"this\" pointer.\n            SaveOpndValue(pnodeTarget->sxBin.pnode1, funcInfo);\n        }\n        Emit(pnodeTarget->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Emit(pnodeTarget->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot indexLocation = pnodeTarget->sxBin.pnode2->location;\n\n        Js::RegSlot protoLocation =\n            (pnodeTarget->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            pnodeTarget->sxBin.pnode1->location;\n\n        EmitSuperMethodBegin(pnodeTarget, byteCodeGenerator, funcInfo);\n        EmitMethodElem(pnodeTarget, protoLocation, indexLocation, byteCodeGenerator);\n\n        funcInfo->ReleaseLoc(pnodeTarget->sxBin.pnode2); // don't release indexLocation until after we use it.\n\n        // Function calls on the 'super' object should maintain current 'this' pointer\n        *thisLocation = (pnodeTarget->sxBin.pnode1->nop == knopSuper) ? funcInfo->thisPointerRegister : pnodeTarget->sxBin.pnode1->location;\n        break;\n    }\n\n    case knopClassDecl:\n    {\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false);\n        // We won't always have an assigned this register (e.g. class expression calls.) We need undefined in this case.\n        *thisLocation = funcInfo->thisPointerRegister == Js::Constants::NoRegister ? funcInfo->undefinedConstantRegister : funcInfo->thisPointerRegister;\n        break;\n    }\n\n    case knopSuper:\n    {\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false, /*isConstructorCall*/ true);  // reuse isConstructorCall (\"new super()\" is illegal)\n\n        // Super calls should always use the new.target register unless we don't have one.\n        // That could happen if we have an eval('super()') outside of a class constructor.\n        if (funcInfo->newTargetRegister != Js::Constants::NoRegister)\n        {\n            *thisLocation = funcInfo->newTargetRegister;\n        }\n        else\n        {\n            *thisLocation = funcInfo->thisPointerRegister;\n        }\n        break;\n    }\n\n    case knopName:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs)\n        {\n            SaveOpndValue(pnodeTarget, funcInfo);\n        }\n        byteCodeGenerator->EmitLoadInstance(pnodeTarget->sxPid.sym, pnodeTarget->sxPid.pid, thisLocation, callObjLocation, funcInfo);\n        if (*callObjLocation != Js::Constants::NoRegister)\n        {\n            // Load the call target as a property of the instance.\n            Js::PropertyId propertyId = pnodeTarget->sxPid.PropertyIdFromNameNode();\n            EmitMethodFld(pnodeTarget, *callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n            break;\n        }\n\n        // FALL THROUGH to evaluate call target.\n    }\n\n    default:\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false);\n        *thisLocation = funcInfo->undefinedConstantRegister;\n        break;\n    }\n\n    // \"This\" pointer should have been assigned by the above.\n    Assert(*thisLocation != Js::Constants::NoRegister);\n}\n\nvoid EmitCallI(\n    ParseNode *pnode,\n    BOOL fEvaluateComponents,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    BOOL fHasNewTarget,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit a call where the target is in a register, because it's either a local name or an expression we've\n    // already evaluated.\n\n    ParseNode *pnodeTarget = pnode->sxBin.pnode1;\n    Js::OpCode op;\n    Js::CallFlags callFlags = Js::CallFlags::CallFlags_None;\n    uint spreadExtraAlloc = 0;\n\n    Js::ArgSlot actualArgSlotCount = (Js::ArgSlot) actualArgCount;\n\n    // check for integer overflow\n    if ((size_t)actualArgSlotCount != actualArgCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    if (fIsPut)\n    {\n        if (pnode->sxCall.spreadArgCount > 0)\n        {\n            // TODO(tcare): We are disallowing spread with CallIPut for the moment. See DEVDIV2: 876387\n            //              When CallIPut is migrated to the CallIExtended layout, this can be removed.\n            byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAsgCall));\n        }\n        // Grab a tmp register for the call result.\n        Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n        byteCodeGenerator->Writer()->CallI(Js::OpCode::CallIFlags, tmpReg, pnodeTarget->location, actualArgSlotCount, callSiteId, Js::CallFlags::CallFlags_NewTarget);\n        funcInfo->ReleaseTmpRegister(tmpReg);\n    }\n    else\n    {\n        if (fEvaluateComponents)\n        {\n            // Release the call target operands we assigned above. If we didn't assign them here,\n            // we'll need them later, so we can't re-use them for the result of the call.\n            funcInfo->ReleaseLoc(pnodeTarget);\n        }\n        // Grab a register for the call result.\n        if (pnode->isUsed)\n        {\n            funcInfo->AcquireLoc(pnode);\n        }\n\n        if (fIsEval)\n        {\n            op = Js::OpCode::CallIExtendedFlags;\n            callFlags = Js::CallFlags::CallFlags_ExtraArg;\n        }\n        else\n        {\n            bool isSuperCall = pnodeTarget->nop == knopSuper;\n\n            if (isSuperCall)\n            {\n                callFlags = Js::CallFlags_New;\n            }\n            if (fHasNewTarget)\n            {\n                callFlags = (Js::CallFlags) (callFlags | Js::CallFlags::CallFlags_ExtraArg | Js::CallFlags::CallFlags_NewTarget);\n            }\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                op = (isSuperCall || fHasNewTarget) ? Js::OpCode::CallIExtendedFlags : Js::OpCode::CallIExtended;\n            }\n            else\n            {\n                op = (isSuperCall || fHasNewTarget) ? Js::OpCode::CallIFlags : Js::OpCode::CallI;\n            }\n        }\n\n        if (op == Js::OpCode::CallI || op == Js::OpCode::CallIFlags)\n        {\n            if (pnodeTarget->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnodeTarget->location, funcInfo);\n                byteCodeGenerator->Writer()->CallI(op, pnode->location, tmpReg, actualArgSlotCount, callSiteId, callFlags);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallI(op, pnode->location, pnodeTarget->location, actualArgSlotCount, callSiteId, callFlags);\n            }\n        }\n        else\n        {\n            uint spreadIndicesSize = 0;\n            Js::CallIExtendedOptions options = Js::CallIExtended_None;\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                Assert(spreadIndices != nullptr);\n                spreadExtraAlloc = spreadIndices->count * sizeof(uint32);\n                spreadIndicesSize = sizeof(*spreadIndices) + spreadExtraAlloc;\n                options = Js::CallIExtended_SpreadArgs;\n            }\n\n            if (pnodeTarget->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnodeTarget->location, funcInfo);\n                byteCodeGenerator->Writer()->CallIExtended(op, pnode->location, tmpReg, actualArgSlotCount, options, spreadIndices, spreadIndicesSize, callSiteId, callFlags);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallIExtended(op, pnode->location, pnodeTarget->location, actualArgSlotCount, options, spreadIndices, spreadIndicesSize, callSiteId, callFlags);\n            }\n        }\n\n        if (pnode->sxCall.spreadArgCount > 0)\n        {\n            Assert(spreadExtraAlloc != 0);\n            AdeletePlus(byteCodeGenerator->GetAllocator(), spreadExtraAlloc, spreadIndices);\n        }\n    }\n}\n\nvoid EmitCallInstrNoEvalComponents(\n    ParseNode *pnode,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    Js::RegSlot thisLocation,\n    Js::RegSlot callObjLocation,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit the call instruction. The call target is a reference at this point, and we evaluate\n    // it as part of doing the actual call.\n    // Note that we don't handle the (fEvaluateComponents == TRUE) case in this function.\n    // (This function is only called on the !fEvaluateComponents branch in EmitCall.)\n\n    ParseNode *pnodeTarget = pnode->sxBin.pnode1;\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n    {\n        Assert(pnodeTarget->sxBin.pnode2->nop == knopName);\n        Js::PropertyId propertyId = pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        EmitMethodFld(pnodeTarget, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    break;\n\n    case knopIndex:\n    {\n        EmitMethodElem(pnodeTarget, pnodeTarget->sxBin.pnode1->location, pnodeTarget->sxBin.pnode2->location, byteCodeGenerator);\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    break;\n\n    case knopName:\n    {\n        if (callObjLocation != Js::Constants::NoRegister)\n        {\n            // We still have to get the property from its instance, so emit CallFld.\n            if (thisLocation != callObjLocation)\n            {\n                funcInfo->ReleaseTmpRegister(thisLocation);\n            }\n            funcInfo->ReleaseTmpRegister(callObjLocation);\n\n            Js::PropertyId propertyId = pnodeTarget->sxPid.PropertyIdFromNameNode();\n            EmitMethodFld(pnodeTarget, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n            EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n            break;\n        }\n    }\n    // FALL THROUGH\n\n    default:\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n        break;\n    }\n}\n\nvoid EmitCallInstr(\n    ParseNode *pnode,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    BOOL fHasNewTarget,\n    Js::RegSlot thisLocation,\n    Js::RegSlot callObjLocation,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit a call instruction. The call target has been fully evaluated already, so we always\n    // emit a CallI through the register that holds the target value.\n    // Note that we don't handle !fEvaluateComponents cases at this point.\n    // (This function is only called on the fEvaluateComponents branch in EmitCall.)\n\n    if (thisLocation != Js::Constants::NoRegister)\n    {\n        funcInfo->ReleaseTmpRegister(thisLocation);\n    }\n\n    if (callObjLocation != Js::Constants::NoRegister &&\n        callObjLocation != thisLocation)\n    {\n        funcInfo->ReleaseTmpRegister(callObjLocation);\n    }\n\n    EmitCallI(pnode, /*fEvaluateComponents*/ TRUE, fIsPut, fIsEval, fHasNewTarget, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n}\n\nvoid EmitNew(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::ArgSlot argCount = pnode->sxCall.argCount;\n    argCount++; // include \"this\"\n\n    BOOL fSideEffectArgs = FALSE;\n    unsigned int tmpCount = CountArguments(pnode->sxCall.pnodeArgs, &fSideEffectArgs);\n    Assert(argCount == tmpCount);\n\n    if (argCount != (Js::ArgSlot)argCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    byteCodeGenerator->StartStatement(pnode);\n\n    // Start call, allocate out param space\n    funcInfo->StartRecordingOutArgs(argCount);\n\n    // Assign the call target operand(s), putting them into expression temps if necessary to protect\n    // them from side-effects.\n    if (fSideEffectArgs)\n    {\n        SaveOpndValue(pnode->sxCall.pnodeTarget, funcInfo);\n    }\n\n    if (pnode->sxCall.pnodeTarget->nop == knopSuper)\n    {\n        EmitSuperFieldPatch(funcInfo, pnode, byteCodeGenerator);\n    }\n\n    Emit(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo, false, true);\n\n    if (pnode->sxCall.pnodeArgs == nullptr)\n    {\n        funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n        Js::OpCode op = (CreateNativeArrays(byteCodeGenerator, funcInfo)\n            && CallTargetIsArray(pnode->sxCall.pnodeTarget))\n            ? Js::OpCode::NewScObjArray : Js::OpCode::NewScObject;\n        Assert(argCount == 1);\n\n        Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(op);\n        byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argCount);\n        byteCodeGenerator->Writer()->CallI(op, funcInfo->AcquireLoc(pnode),\n            pnode->sxCall.pnodeTarget->location, argCount, callSiteId);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argCount);\n        uint32 actualArgCount = 0;\n\n        if (IsCallOfConstants(pnode))\n        {\n            funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n            actualArgCount = EmitNewObjectOfConstants(pnode, byteCodeGenerator, funcInfo, argCount);\n        }\n        else\n        {\n            Js::OpCode op;\n            if ((CreateNativeArrays(byteCodeGenerator, funcInfo) && CallTargetIsArray(pnode->sxCall.pnodeTarget)))\n            {\n                op = pnode->sxCall.spreadArgCount > 0 ? Js::OpCode::NewScObjArraySpread : Js::OpCode::NewScObjArray;\n            }\n            else\n            {\n                op = pnode->sxCall.spreadArgCount > 0 ? Js::OpCode::NewScObjectSpread : Js::OpCode::NewScObject;\n            }\n\n            Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(op);\n\n\n            Js::AuxArray<uint32> *spreadIndices = nullptr;\n            actualArgCount = EmitArgList(pnode->sxCall.pnodeArgs, Js::Constants::NoRegister, Js::Constants::NoRegister, Js::Constants::NoRegister,\n                false, true, byteCodeGenerator, funcInfo, callSiteId, pnode->sxCall.spreadArgCount, &spreadIndices);\n            funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                Assert(spreadIndices != nullptr);\n                uint spreadExtraAlloc = spreadIndices->count * sizeof(uint32);\n                uint spreadIndicesSize = sizeof(*spreadIndices) + spreadExtraAlloc;\n                byteCodeGenerator->Writer()->CallIExtended(op, funcInfo->AcquireLoc(pnode), pnode->sxCall.pnodeTarget->location,\n                    (uint16)actualArgCount, Js::CallIExtended_SpreadArgs,\n                    spreadIndices, spreadIndicesSize, callSiteId);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallI(op, funcInfo->AcquireLoc(pnode), pnode->sxCall.pnodeTarget->location,\n                    (uint16)actualArgCount, callSiteId);\n            }\n        }\n\n        Assert(argCount == actualArgCount);\n    }\n\n    // End call, pop param space\n    funcInfo->EndRecordingOutArgs(argCount);\n    return;\n}\n\nvoid EmitCall(\n    ParseNode* pnode,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo,\n    BOOL fReturnValue,\n    BOOL fEvaluateComponents,\n    BOOL fHasNewTarget,\n    Js::RegSlot overrideThisLocation)\n{\n    BOOL fIsPut = (rhsLocation != Js::Constants::NoRegister);\n    // If the call returns a float, we'll note this in the byte code.\n    Js::RegSlot thisLocation = Js::Constants::NoRegister;\n    Js::RegSlot callObjLocation = Js::Constants::NoRegister;\n    Js::RegSlot newTargetLocation = Js::Constants::NoRegister;\n    BOOL fSideEffectArgs = FALSE;\n    ParseNode *pnodeTarget = pnode->sxCall.pnodeTarget;\n    ParseNode *pnodeArgs = pnode->sxCall.pnodeArgs;\n    uint16 spreadArgCount = pnode->sxCall.spreadArgCount;\n\n    if (CreateNativeArrays(byteCodeGenerator, funcInfo) && CallTargetIsArray(pnode->sxCall.pnodeTarget)) {\n        // some minifiers (potentially incorrectly) assume that \"v = new Array()\" and \"v = Array()\" are equivalent,\n        // and replace the former with the latter to save 4 characters. What that means for us is that it, at least\n        // initially, uses the \"Call\" path. We want to guess that it _is_ just \"new Array()\" and change over to the\n        // \"new\" path, since then our native array handling can kick in.\n        /*EmitNew(pnode, byteCodeGenerator, funcInfo);\n        return;*/\n    }\n\n    unsigned int argCount = CountArguments(pnode->sxCall.pnodeArgs, &fSideEffectArgs) + (unsigned int)fIsPut;\n\n    BOOL fIsEval = !fIsPut && pnode->sxCall.isEvalCall;\n\n    if (fIsEval)\n    {\n        Assert(!fHasNewTarget);\n\n        //\n        // \"eval\" takes the closure environment as an extra argument\n        // Pass the closure env only if some argument is passed\n        // For just eval(), don't pass the closure environment\n        //\n        if (argCount > 1)\n        {\n            // Check the module ID as well. If it's not the global (default) module,\n            // we need to pass the root to eval so it can do the right global lookups.\n            // (Passing the module root is the least disruptive way to get the module ID\n            // to the helper, given the current set of byte codes. Once we have a full set\n            // of byte code ops taking immediate opnds, passing the ID is more intuitive.)\n            Js::ModuleID moduleID = byteCodeGenerator->GetModuleID();\n            if (moduleID == kmodGlobal)\n            {\n                argCount++;\n            }\n            else\n            {\n                // Module ID must be passed\n                argCount += 2;\n            }\n        }\n    }\n\n    if (fHasNewTarget)\n    {\n        Assert(!fIsEval);\n\n        // When we need to pass new.target explicitly, it is passed as an extra argument.\n        // This is similar to how eval passes an extra argument for the frame display and is\n        // used to support cases where we need to pass both 'this' and new.target as part of\n        // a function call.\n        // OpCode::LdNewTarget knows how to look at the call flags and fetch this argument.\n        argCount++;\n        newTargetLocation = funcInfo->newTargetRegister;\n\n        Assert(newTargetLocation != Js::Constants::NoRegister);\n    }\n\n    Js::ArgSlot argSlotCount = (Js::ArgSlot)argCount;\n\n    if (argCount != (unsigned int)argSlotCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    if (fReturnValue)\n    {\n        pnode->isUsed = true;\n    }\n\n    //\n    // Set up the call.\n    //\n\n    if (!fEvaluateComponents)\n    {\n        EmitCallTargetNoEvalComponents(pnodeTarget, fSideEffectArgs, &thisLocation, &callObjLocation, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitCallTarget(pnodeTarget, fSideEffectArgs, &thisLocation, &callObjLocation, byteCodeGenerator, funcInfo);\n    }\n\n    bool releaseThisLocation = true;\n    // If we are strictly overriding the this location, ignore what the call target set this location to.\n    if (overrideThisLocation != Js::Constants::NoRegister)\n    {\n        thisLocation = overrideThisLocation;\n        releaseThisLocation = false;\n    }\n\n    // Evaluate the arguments (nothing mode-specific here).\n    // Start call, allocate out param space\n    funcInfo->StartRecordingOutArgs(argSlotCount);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argSlotCount);\n    Js::AuxArray<uint32> *spreadIndices;\n    Js::ArgSlot actualArgCount = EmitArgList(pnodeArgs, rhsLocation, thisLocation, newTargetLocation, fIsEval, fEvaluateComponents, byteCodeGenerator, funcInfo, callSiteId, spreadArgCount, &spreadIndices);\n    Assert(argSlotCount == actualArgCount);\n\n    if (!fEvaluateComponents)\n    {\n        EmitCallInstrNoEvalComponents(pnode, fIsPut, fIsEval, thisLocation, callObjLocation, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    else\n    {\n        EmitCallInstr(pnode, fIsPut, fIsEval, fHasNewTarget, releaseThisLocation ? thisLocation : Js::Constants::NoRegister, callObjLocation, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n\n    // End call, pop param space\n    funcInfo->EndRecordingOutArgs(argSlotCount);\n}\n\nvoid EmitInvoke(\n    Js::RegSlot location,\n    Js::RegSlot callObjLocation,\n    Js::PropertyId propertyId,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo)\n{\n    EmitMethodFld(false, false, location, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n\n    funcInfo->StartRecordingOutArgs(1);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, 1);\n    EmitArgListStart(callObjLocation, byteCodeGenerator, funcInfo, callSiteId);\n\n    byteCodeGenerator->Writer()->CallI(Js::OpCode::CallI, location, location, 1, callSiteId);\n}\n\nvoid EmitInvoke(\n    Js::RegSlot location,\n    Js::RegSlot callObjLocation,\n    Js::PropertyId propertyId,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo,\n    Js::RegSlot arg1Location)\n{\n    EmitMethodFld(false, false, location, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n\n    funcInfo->StartRecordingOutArgs(2);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, 2);\n    EmitArgListStart(callObjLocation, byteCodeGenerator, funcInfo, callSiteId);\n    byteCodeGenerator->Writer()->ArgOut<true>(1, arg1Location, callSiteId);\n\n    byteCodeGenerator->Writer()->CallI(Js::OpCode::CallI, location, location, 2, callSiteId);\n}\n\nvoid EmitComputedFunctionNameVar(ParseNode *nameNode, ParseNode *exprNode, ByteCodeGenerator *byteCodeGenerator)\n{\n    AssertMsg(exprNode != nullptr, \"callers of this function should pass in a valid expression Node\");\n\n    if (nameNode == nullptr)\n    {\n        return;\n    }\n\n    if ((exprNode->nop == knopFncDecl && (exprNode->sxFnc.pnodeName == nullptr || exprNode->sxFnc.pnodeName->nop != knopVarDecl)))\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetComputedNameVar, exprNode->location, nameNode->location);\n    }\n}\n\nvoid EmitMemberNode(ParseNode *memberNode, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, ParseNode* parentNode, bool useStore, bool* isObjectEmpty = nullptr)\n{\n    ParseNode *nameNode = memberNode->sxBin.pnode1;\n    ParseNode *exprNode = memberNode->sxBin.pnode2;\n\n    bool isFncDecl = exprNode->nop == knopFncDecl;\n    bool isClassMember = isFncDecl && exprNode->sxFnc.IsClassMember();\n\n    // Moved SetComputedNameVar before LdFld of prototype because loading the prototype undefers the function TypeHandler\n    // which makes this bytecode too late to influence the function.name.\n    if (nameNode->nop == knopComputedName)\n    {\n        // Computed property name\n        // Transparently pass the name expr\n        // The Emit will replace this with a temp register if necessary to preserve the value.\n        nameNode->location = nameNode->sxUni.pnode1->location;\n        EmitBinaryOpnds(nameNode, exprNode, byteCodeGenerator, funcInfo);\n        if (isFncDecl && !exprNode->sxFnc.IsClassConstructor())\n        {\n            EmitComputedFunctionNameVar(nameNode, exprNode, byteCodeGenerator);\n        }\n    }\n\n    // Classes allocates a RegSlot as part of Instance Methods EmitClassInitializers,\n    // but if we don't have any members then we don't need to load the prototype.\n    Assert(isClassMember == (isObjectEmpty != nullptr));\n    if (isClassMember && *isObjectEmpty)\n    {\n        *isObjectEmpty = false;\n        int cacheId = funcInfo->FindOrAddInlineCacheId(parentNode->location, Js::PropertyIds::prototype, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, objectLocation, parentNode->location, cacheId);\n    }\n\n    if (nameNode->nop == knopComputedName)\n    {\n        Assert(memberNode->nop == knopGetMember || memberNode->nop == knopSetMember || memberNode->nop == knopMember);\n\n        Js::OpCode setOp = memberNode->nop == knopGetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberGetComputedName : Js::OpCode::InitGetElemI) :\n            memberNode->nop == knopSetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberSetComputedName : Js::OpCode::InitSetElemI) :\n            (isClassMember ? Js::OpCode::InitClassMemberComputedName : Js::OpCode::InitComputedProperty);\n\n        byteCodeGenerator->Writer()->Element(setOp, exprNode->location, objectLocation, nameNode->location, true);\n\n        // Class and object members need a reference back to the class.\n        if (isFncDecl)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, exprNode->location, objectLocation);\n        }\n\n        funcInfo->ReleaseLoc(exprNode);\n        funcInfo->ReleaseLoc(nameNode);\n\n        return;\n    }\n\n    Js::OpCode stFldOpCode = (Js::OpCode)0;\n    if (useStore)\n    {\n        stFldOpCode = ByteCodeGenerator::GetStFldOpCode(funcInfo, false, false, false, isClassMember);\n    }\n\n    Emit(exprNode, byteCodeGenerator, funcInfo, false);\n    Js::PropertyId propertyId = nameNode->sxPid.PropertyIdFromNameNode();\n\n    if (Js::PropertyIds::name == propertyId\n        && exprNode->nop == knopFncDecl\n        && exprNode->sxFnc.IsStaticMember()\n        && parentNode != nullptr && parentNode->nop == knopClassDecl\n        && parentNode->sxClass.pnodeConstructor != nullptr)\n    {\n        Js::ParseableFunctionInfo* nameFunc = parentNode->sxClass.pnodeConstructor->sxFnc.funcInfo->byteCodeFunction->GetParseableFunctionInfo();\n        nameFunc->SetIsStaticNameFunction(true);\n    }\n\n    if (memberNode->nop == knopMember || memberNode->nop == knopMemberShort)\n    {\n        // The internal prototype should be set only if the production is of the form PropertyDefinition : PropertyName : AssignmentExpression\n        if (propertyId == Js::PropertyIds::__proto__ && memberNode->nop != knopMemberShort && (exprNode->nop != knopFncDecl || !exprNode->sxFnc.IsMethod()))\n        {\n            byteCodeGenerator->Writer()->Property(Js::OpCode::InitProto, exprNode->location, objectLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(objectLocation, propertyId, false, true);\n            Js::OpCode patchablePropertyOpCode;\n\n            if (useStore)\n            {\n                patchablePropertyOpCode = stFldOpCode;\n            }\n            else if (isClassMember)\n            {\n                patchablePropertyOpCode = Js::OpCode::InitClassMember;\n            }\n            else\n            {\n                patchablePropertyOpCode = Js::OpCode::InitFld;\n            }\n\n            byteCodeGenerator->Writer()->PatchableProperty(patchablePropertyOpCode, exprNode->location, objectLocation, cacheId);\n        }\n    }\n    else\n    {\n        Assert(memberNode->nop == knopGetMember || memberNode->nop == knopSetMember);\n\n        Js::OpCode setOp = memberNode->nop == knopGetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberGet : Js::OpCode::InitGetFld) :\n            (isClassMember ? Js::OpCode::InitClassMemberSet : Js::OpCode::InitSetFld);\n\n        byteCodeGenerator->Writer()->Property(setOp, exprNode->location, objectLocation, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n    }\n\n    // Class and object members need a reference back to the class.\n    if (isFncDecl)\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, exprNode->location, objectLocation);\n    }\n\n    funcInfo->ReleaseLoc(exprNode);\n\n    if (propertyId == Js::PropertyIds::valueOf)\n    {\n        byteCodeGenerator->GetScriptContext()->optimizationOverrides.SetSideEffects(Js::SideEffects_ValueOf);\n    }\n    else if (propertyId == Js::PropertyIds::toString)\n    {\n        byteCodeGenerator->GetScriptContext()->optimizationOverrides.SetSideEffects(Js::SideEffects_ToString);\n    }\n}\n\nvoid EmitClassInitializers(ParseNode *memberList, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, ParseNode* parentNode, bool isObjectEmpty)\n{\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            ParseNode *memberNode = memberList->sxBin.pnode1;\n            EmitMemberNode(memberNode, objectLocation, byteCodeGenerator, funcInfo, parentNode, /*useStore*/ false, &isObjectEmpty);\n            memberList = memberList->sxBin.pnode2;\n        }\n        EmitMemberNode(memberList, objectLocation, byteCodeGenerator, funcInfo, parentNode, /*useStore*/ false, &isObjectEmpty);\n    }\n}\n\nvoid EmitObjectInitializers(ParseNode *memberList, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    ParseNode *pmemberList = memberList;\n    unsigned int argCount = 0;\n    uint32  value;\n    Js::PropertyId propertyId;\n\n    //\n    // 1. Add all non-int property ids to a dictionary propertyIds with value true\n    // 2. Get the count of propertyIds\n    // 3. Create a propertyId array of size count\n    // 4. Put the propIds in the auxiliary area\n    // 5. Get the objectLiteralCacheId\n    // 6. Generate propId inits with values\n    //\n\n    // Handle propertyId collision\n    typedef JsUtil::BaseHashSet<Js::PropertyId, ArenaAllocator, PowerOf2SizePolicy> PropertyIdSet;\n    PropertyIdSet* propertyIds = Anew(byteCodeGenerator->GetAllocator(), PropertyIdSet, byteCodeGenerator->GetAllocator(), 17);\n\n    bool hasComputedName = false;\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            if (memberList->sxBin.pnode1->sxBin.pnode1->nop == knopComputedName)\n            {\n                hasComputedName = true;\n                break;\n            }\n\n            propertyId = memberList->sxBin.pnode1->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value))\n            {\n                propertyIds->Item(propertyId);\n            }\n\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        if (memberList->sxBin.pnode1->nop != knopComputedName && !hasComputedName)\n        {\n            propertyId = memberList->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value))\n            {\n                propertyIds->Item(propertyId);\n            }\n        }\n    }\n\n    argCount = propertyIds->Count();\n\n    memberList = pmemberList;\n    if ((memberList == nullptr) || (argCount == 0))\n    {\n        // Empty literal or numeric property only object literal\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::NewScObjectSimple, objectLocation);\n    }\n    else\n    {\n        Js::PropertyIdArray *propIds = AnewPlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::PropertyId), Js::PropertyIdArray, argCount, 0);\n\n        if (propertyIds->ContainsKey(Js::PropertyIds::__proto__))\n        {\n            // Always record whether the initializer contains __proto__ no matter if current environment has it enabled\n            // or not, in case the bytecode is later run with __proto__ enabled.\n            propIds->has__proto__ = true;\n        }\n\n        unsigned int argIndex = 0;\n        while (memberList->nop == knopList)\n        {\n            if (memberList->sxBin.pnode1->sxBin.pnode1->nop == knopComputedName)\n            {\n                break;\n            }\n            propertyId = memberList->sxBin.pnode1->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value) && propertyIds->Remove(propertyId))\n            {\n                propIds->elements[argIndex] = propertyId;\n                argIndex++;\n            }\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        if (memberList->sxBin.pnode1->nop != knopComputedName && !hasComputedName)\n        {\n            propertyId = memberList->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value) && propertyIds->Remove(propertyId))\n            {\n                propIds->elements[argIndex] = propertyId;\n                argIndex++;\n            }\n        }\n\n        uint32 literalObjectId = funcInfo->GetParsedFunctionBody()->NewObjectLiteral();\n\n        // Generate the opcode with propIds and cacheId\n        byteCodeGenerator->Writer()->Auxiliary(Js::OpCode::NewScObjectLiteral, objectLocation, propIds, sizeof(Js::PropertyIdArray) + argCount * sizeof(Js::PropertyId), literalObjectId);\n\n        Adelete(byteCodeGenerator->GetAllocator(), propertyIds);\n\n        AdeletePlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::PropertyId), propIds);\n    }\n\n    memberList = pmemberList;\n\n    bool useStore = false;\n    // Generate the actual assignment to those properties\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            ParseNode *memberNode = memberList->sxBin.pnode1;\n\n            if (memberNode->sxBin.pnode1->nop == knopComputedName)\n            {\n                useStore = true;\n            }\n\n            byteCodeGenerator->StartSubexpression(memberNode);\n            EmitMemberNode(memberNode, objectLocation, byteCodeGenerator, funcInfo, nullptr, useStore);\n            byteCodeGenerator->EndSubexpression(memberNode);\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        byteCodeGenerator->StartSubexpression(memberList);\n        EmitMemberNode(memberList, objectLocation, byteCodeGenerator, funcInfo, nullptr, useStore);\n        byteCodeGenerator->EndSubexpression(memberList);\n    }\n}\n\nvoid EmitStringTemplate(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Assert(pnode->sxStrTemplate.pnodeStringLiterals);\n\n    // For a tagged string template, we will create the callsite constant object as part of the FunctionBody constants table.\n    // We only need to emit code for non-tagged string templates here.\n    if (!pnode->sxStrTemplate.isTaggedTemplate)\n    {\n        // If we have no substitutions and this is not a tagged template, we can emit just the single cooked string.\n        if (pnode->sxStrTemplate.pnodeSubstitutionExpressions == nullptr)\n        {\n            Assert(pnode->sxStrTemplate.pnodeStringLiterals->nop != knopList);\n\n            funcInfo->AcquireLoc(pnode);\n            Emit(pnode->sxStrTemplate.pnodeStringLiterals, byteCodeGenerator, funcInfo, false);\n\n            Assert(pnode->location != pnode->sxStrTemplate.pnodeStringLiterals->location);\n\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxStrTemplate.pnodeStringLiterals->location);\n            funcInfo->ReleaseLoc(pnode->sxStrTemplate.pnodeStringLiterals);\n        }\n        else\n        {\n            // If we have substitutions but no tag function, we can skip the callSite object construction (and also ignore raw strings).\n            funcInfo->AcquireLoc(pnode);\n\n            // First string must be a list node since we have substitutions.\n            AssertMsg(pnode->sxStrTemplate.pnodeStringLiterals->nop == knopList, \"First string in the list must be a knopList node.\");\n\n            ParseNode* stringNodeList = pnode->sxStrTemplate.pnodeStringLiterals;\n\n            // Emit the first string and load that into the pnode location.\n            Emit(stringNodeList->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n\n            Assert(pnode->location != stringNodeList->sxBin.pnode1->location);\n\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, stringNodeList->sxBin.pnode1->location);\n            funcInfo->ReleaseLoc(stringNodeList->sxBin.pnode1);\n\n            ParseNode* expressionNodeList = pnode->sxStrTemplate.pnodeSubstitutionExpressions;\n            ParseNode* stringNode;\n            ParseNode* expressionNode;\n\n            // Now append the substitution expressions and remaining string constants via normal add operator\n            // We will always have one more string constant than substitution expression\n            // `strcon1 ${expr1} strcon2 ${expr2} strcon3` = strcon1 + expr1 + strcon2 + expr2 + strcon3\n            //\n            // strcon1 --- step 1 (above)\n            // expr1   \\__ step 2\n            // strcon2 /\n            // expr2   \\__ step 3\n            // strcon3 /\n            while (stringNodeList->nop == knopList)\n            {\n                // If the current head of the expression list is a list, fetch the node and walk the list.\n                if (expressionNodeList->nop == knopList)\n                {\n                    expressionNode = expressionNodeList->sxBin.pnode1;\n                    expressionNodeList = expressionNodeList->sxBin.pnode2;\n                }\n                else\n                {\n                    // This is the last element of the expression list.\n                    expressionNode = expressionNodeList;\n                }\n\n                // Emit the expression and append it to the string we're building.\n                Emit(expressionNode, byteCodeGenerator, funcInfo, false);\n\n                Js::RegSlot toStringLocation = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Str, toStringLocation, expressionNode->location);\n                byteCodeGenerator->Writer()->Reg3(Js::OpCode::Add_A, pnode->location, pnode->location, toStringLocation);\n                funcInfo->ReleaseTmpRegister(toStringLocation);\n                funcInfo->ReleaseLoc(expressionNode);\n\n                // Move to the next string in the list - we already got ahead of the expressions in the first string literal above.\n                stringNodeList = stringNodeList->sxBin.pnode2;\n\n                // If the current head of the string literal list is also a list node, need to fetch the actual string literal node.\n                if (stringNodeList->nop == knopList)\n                {\n                    stringNode = stringNodeList->sxBin.pnode1;\n                }\n                else\n                {\n                    // This is the last element of the string literal list.\n                    stringNode = stringNodeList;\n                }\n\n                // Emit the string node following the previous expression and append it to the string.\n                // This is either just some string in the list or it is the last string.\n                Emit(stringNode, byteCodeGenerator, funcInfo, false);\n                byteCodeGenerator->Writer()->Reg3(Js::OpCode::Add_A, pnode->location, pnode->location, stringNode->location);\n                funcInfo->ReleaseLoc(stringNode);\n            }\n        }\n    }\n}\n\nvoid SetNewArrayElements(ParseNode *pnode, Js::RegSlot arrayLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    ParseNode *args = pnode->sxUni.pnode1;\n    uint argCount = pnode->sxArrLit.count;\n    uint spreadCount = pnode->sxArrLit.spreadCount;\n    bool nativeArrays = CreateNativeArrays(byteCodeGenerator, funcInfo);\n\n    bool arrayIntOpt = nativeArrays && pnode->sxArrLit.arrayOfInts;\n    if (arrayIntOpt)\n    {\n        int extraAlloc = argCount * sizeof(int32);\n        Js::AuxArray<int> *ints = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<int32>, argCount);\n        EmitConstantArgsToIntArray(byteCodeGenerator, ints->elements, args, argCount);\n        Assert(!pnode->sxArrLit.hasMissingValues);\n        byteCodeGenerator->Writer()->Auxiliary(\n            Js::OpCode::NewScIntArray,\n            pnode->location,\n            ints,\n            sizeof(Js::AuxArray<int>) + extraAlloc,\n            argCount);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, ints);\n        return;\n    }\n\n    bool arrayNumOpt = nativeArrays && pnode->sxArrLit.arrayOfNumbers;\n    if (arrayNumOpt)\n    {\n        int extraAlloc = argCount * sizeof(double);\n        Js::AuxArray<double> *doubles = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<double>, argCount);\n        EmitConstantArgsToFltArray(byteCodeGenerator, doubles->elements, args, argCount);\n        Assert(!pnode->sxArrLit.hasMissingValues);\n        byteCodeGenerator->Writer()->Auxiliary(\n            Js::OpCode::NewScFltArray,\n            pnode->location,\n            doubles,\n            sizeof(Js::AuxArray<double>) + extraAlloc,\n            argCount);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, doubles);\n        return;\n    }\n\n    bool arrayLitOpt = pnode->sxArrLit.arrayOfTaggedInts && pnode->sxArrLit.count > 1;\n    Assert(!arrayLitOpt || !nativeArrays);\n\n    Js::RegSlot spreadArrLoc = arrayLocation;\n    Js::AuxArray<uint32> *spreadIndices = nullptr;\n    const uint extraAlloc = spreadCount * sizeof(uint32);\n    if (pnode->sxArrLit.spreadCount > 0)\n    {\n        arrayLocation = funcInfo->AcquireTmpRegister();\n        spreadIndices = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<uint32>, spreadCount);\n    }\n\n    byteCodeGenerator->Writer()->Reg1Unsigned1(\n        pnode->sxArrLit.hasMissingValues ? Js::OpCode::NewScArrayWithMissingValues : Js::OpCode::NewScArray,\n        arrayLocation,\n        argCount);\n\n    if (args != nullptr)\n    {\n        Js::OpCode opcode;\n        Js::RegSlot arrLoc;\n        if (argCount == 1 && !byteCodeGenerator->Writer()->DoProfileNewScArrayOp(Js::OpCode::NewScArray))\n        {\n            opcode = Js::OpCode::StArrItemC_CI4;\n            arrLoc = arrayLocation;\n        }\n        else if (arrayLitOpt)\n        {\n            opcode = Js::OpCode::StArrSegItem_A;\n            arrLoc = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdArrHead, arrLoc, arrayLocation);\n        }\n        else if (Js::JavascriptArray::HasInlineHeadSegment(argCount))\n        {\n            // The head segment will be allocated inline as an interior pointer. To keep the array alive, the set operation\n            // should be done relative to the array header to keep it alive (instead of the array segment).\n            opcode = Js::OpCode::StArrInlineItem_CI4;\n            arrLoc = arrayLocation;\n        }\n        else if (argCount <= Js::JavascriptArray::MaxInitialDenseLength)\n        {\n            opcode = Js::OpCode::StArrSegItem_CI4;\n            arrLoc = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdArrHead, arrLoc, arrayLocation);\n        }\n        else\n        {\n            opcode = Js::OpCode::StArrItemI_CI4;\n            arrLoc = arrayLocation;\n        }\n\n        if (arrayLitOpt)\n        {\n            Js::VarArray *vars = AnewPlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::Var), Js::VarArray, argCount);\n\n            EmitConstantArgsToVarArray(byteCodeGenerator, vars->elements, args, argCount);\n\n            // Generate the opcode with vars\n            byteCodeGenerator->Writer()->Auxiliary(Js::OpCode::StArrSegItem_A, arrLoc, vars, sizeof(Js::VarArray) + argCount * sizeof(Js::Var), argCount);\n\n            AdeletePlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::Var), vars);\n        }\n        else\n        {\n            uint i = 0;\n            unsigned spreadIndex = 0;\n            Js::RegSlot rhsLocation;\n            while (args->nop == knopList)\n            {\n                if (args->sxBin.pnode1->nop != knopEmpty)\n                {\n                    Emit(args->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n                    rhsLocation = args->sxBin.pnode1->location;\n                    Js::RegSlot regVal = rhsLocation;\n                    if (args->sxBin.pnode1->nop == knopEllipsis)\n                    {\n                        AnalysisAssert(spreadIndices);\n                        regVal = funcInfo->AcquireTmpRegister();\n                        byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, rhsLocation);\n                        spreadIndices->elements[spreadIndex++] = i;\n                    }\n\n                    byteCodeGenerator->Writer()->ElementUnsigned1(opcode, regVal, arrLoc, i);\n\n                    if (args->sxBin.pnode1->nop == knopEllipsis)\n                    {\n                        funcInfo->ReleaseTmpRegister(regVal);\n                    }\n\n                    funcInfo->ReleaseLoc(args->sxBin.pnode1);\n                }\n\n                args = args->sxBin.pnode2;\n                i++;\n            }\n\n            if (args->nop != knopEmpty)\n            {\n                Emit(args, byteCodeGenerator, funcInfo, false);\n                rhsLocation = args->location;\n                Js::RegSlot regVal = rhsLocation;\n                if (args->nop == knopEllipsis)\n                {\n                    regVal = funcInfo->AcquireTmpRegister();\n                    byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, rhsLocation);\n                    AnalysisAssert(spreadIndices);\n                    spreadIndices->elements[spreadIndex] = i;\n                }\n\n                byteCodeGenerator->Writer()->ElementUnsigned1(opcode, regVal, arrLoc, i);\n\n                if (args->nop == knopEllipsis)\n                {\n                    funcInfo->ReleaseTmpRegister(regVal);\n                }\n\n                funcInfo->ReleaseLoc(args);\n                i++;\n            }\n            Assert(i <= argCount);\n        }\n\n        if (arrLoc != arrayLocation)\n        {\n            funcInfo->ReleaseTmpRegister(arrLoc);\n        }\n    }\n\n    if (pnode->sxArrLit.spreadCount > 0)\n    {\n        byteCodeGenerator->Writer()->Reg2Aux(Js::OpCode::SpreadArrayLiteral, spreadArrLoc, arrayLocation, spreadIndices, sizeof(Js::AuxArray<uint32>) + extraAlloc, extraAlloc);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, spreadIndices);\n        funcInfo->ReleaseTmpRegister(arrayLocation);\n    }\n}\n\n// FIX: TODO: mixed-mode expressions (arithmetic expressions mixed with boolean expressions); current solution\n// will not short-circuit in some cases and is not complete (for example: var i=(x==y))\n// This uses Aho and Ullman style double-branch generation (p. 494 ASU); we will need to peephole optimize or replace\n// with special case for single-branch style.\nvoid EmitBooleanExpression(ParseNode *expr, Js::ByteCodeLabel trueLabel, Js::ByteCodeLabel falseLabel, ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(expr);\n    switch (expr->nop)\n    {\n\n    case knopLogOr:\n    {\n        Js::ByteCodeLabel leftFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxBin.pnode1, trueLabel, leftFalse, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftFalse);\n        EmitBooleanExpression(expr->sxBin.pnode2, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        break;\n    }\n\n    case knopLogAnd:\n    {\n        Js::ByteCodeLabel leftTrue = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxBin.pnode1, leftTrue, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftTrue);\n        EmitBooleanExpression(expr->sxBin.pnode2, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        break;\n    }\n\n    case knopLogNot:\n        EmitBooleanExpression(expr->sxUni.pnode1, falseLabel, trueLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxUni.pnode1);\n        break;\n\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        EmitBinaryOpnds(expr->sxBin.pnode1, expr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->BrReg2(nopToOp[expr->nop], trueLabel, expr->sxBin.pnode1->location,\n            expr->sxBin.pnode2->location);\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    case knopTrue:\n        byteCodeGenerator->Writer()->Br(trueLabel);\n        break;\n    case knopFalse:\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    default:\n        // Note: we usually release the temp assigned to a node after we Emit it.\n        // But in this case, EmitBooleanExpression is just a wrapper around a normal Emit call,\n        // and the caller of EmitBooleanExpression expects to be able to release this register.\n\n        Emit(expr, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    }\n\n    byteCodeGenerator->EndStatement(expr);\n}\n\nvoid EmitGeneratingBooleanExpression(ParseNode *expr, Js::ByteCodeLabel trueLabel, bool truefallthrough, Js::ByteCodeLabel falseLabel, bool falsefallthrough, Js::RegSlot writeto,\n    ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    switch (expr->nop)\n    {\n\n    case knopLogOr:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        Js::ByteCodeLabel leftFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode1, trueLabel, false, leftFalse, true, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftFalse);\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode2, trueLabel, truefallthrough, falseLabel, falsefallthrough, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n\n    case knopLogAnd:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        Js::ByteCodeLabel leftTrue = byteCodeGenerator->Writer()->DefineLabel();\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode1, leftTrue, true, falseLabel, false, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftTrue);\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode2, trueLabel, truefallthrough, falseLabel, falsefallthrough, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n\n    case knopLogNot:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        // this time we want a boolean expression, since Logical Not is nice and only returns true or false\n        Js::ByteCodeLabel emitTrue = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel emitFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxUni.pnode1, emitFalse, emitTrue, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(emitTrue);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, writeto);\n        byteCodeGenerator->Writer()->Br(trueLabel);\n        byteCodeGenerator->Writer()->MarkLabel(emitFalse);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, writeto);\n        if (!falsefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        funcInfo->ReleaseLoc(expr->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        byteCodeGenerator->StartStatement(expr);\n        EmitBinaryOpnds(expr->sxBin.pnode1, expr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        funcInfo->AcquireLoc(expr);\n        byteCodeGenerator->Writer()->Reg3(nopToCMOp[expr->nop], expr->location, expr->sxBin.pnode1->location,\n            expr->sxBin.pnode2->location);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n        // The inliner likes small bytecode\n        if (!(truefallthrough || falsefallthrough))\n        {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        else if (truefallthrough && !falsefallthrough) {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n        }\n        else if (falsefallthrough && !truefallthrough) {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    case knopTrue:\n        byteCodeGenerator->StartStatement(expr);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, writeto);\n        if (!truefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(trueLabel);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    case knopFalse:\n        byteCodeGenerator->StartStatement(expr);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, writeto);\n        if (!falsefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    default:\n        // Note: we usually release the temp assigned to a node after we Emit it.\n        // But in this case, EmitBooleanExpression is just a wrapper around a normal Emit call,\n        // and the caller of EmitBooleanExpression expects to be able to release this register.\n\n        // For diagnostics purposes, register the name and dot to the statement list.\n        if (expr->nop == knopName || expr->nop == knopDot)\n        {\n            byteCodeGenerator->StartStatement(expr);\n            Emit(expr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n            // The inliner likes small bytecode\n            if (!(truefallthrough || falsefallthrough))\n            {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n                byteCodeGenerator->Writer()->Br(falseLabel);\n            }\n            else if (truefallthrough && !falsefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n            }\n            else if (falsefallthrough && !truefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            }\n            byteCodeGenerator->EndStatement(expr);\n        }\n        else\n        {\n            Emit(expr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n            // The inliner likes small bytecode\n            if (!(truefallthrough || falsefallthrough))\n            {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n                byteCodeGenerator->Writer()->Br(falseLabel);\n            }\n            else if (truefallthrough && !falsefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n            }\n            else if (falsefallthrough && !truefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            }\n        }\n        break;\n    }\n}\n\n// used by while and for loops\nvoid EmitLoop(\n    ParseNode *loopNode,\n    ParseNode *cond,\n    ParseNode *body,\n    ParseNode *incr,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue,\n    BOOL doWhile = FALSE,\n    ParseNode *forLoopBlock = nullptr)\n{\n    // Need to increment loop count whether we are going to profile or not for HasLoop()\n\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxLoop.loopId = loopId;\n\n    if (doWhile)\n    {\n        Emit(body, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(body);\n        if (loopNode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.continueLabel);\n        }\n        if (!ByteCodeGenerator::IsFalse(cond) ||\n            byteCodeGenerator->IsInDebugMode())\n        {\n            EmitBooleanExpression(cond, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoc(cond);\n    }\n    else\n    {\n        if (cond)\n        {\n            if (!(cond->nop == knopInt &&\n                cond->sxInt.lw != 0))\n            {\n                Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n                EmitBooleanExpression(cond, trueLabel, continuePastLoop, byteCodeGenerator, funcInfo);\n                byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n            }\n            funcInfo->ReleaseLoc(cond);\n        }\n        Emit(body, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(body);\n\n        if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled() &&\n            forLoopBlock != nullptr)\n        {\n            CloneEmitBlock(forLoopBlock, byteCodeGenerator, funcInfo);\n        }\n\n        if (loopNode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.continueLabel);\n        }\n\n        if (incr != nullptr)\n        {\n            Emit(incr, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(incr);\n        }\n\n        byteCodeGenerator->Writer()->Br(loopEntrance);\n    }\n\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.breakLabel);\n    }\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n}\n\nvoid ByteCodeGenerator::EmitInvertedLoop(ParseNode* outerLoop, ParseNode* invertedLoop, FuncInfo* funcInfo)\n{\n    Js::ByteCodeLabel invertedLoopLabel = this->m_writer.DefineLabel();\n    Js::ByteCodeLabel afterInvertedLoop = this->m_writer.DefineLabel();\n\n    // emit branch around original\n    Emit(outerLoop->sxFor.pnodeInit, this, funcInfo, false);\n    funcInfo->ReleaseLoc(outerLoop->sxFor.pnodeInit);\n    this->m_writer.BrS(Js::OpCode::BrNotHasSideEffects, invertedLoopLabel, Js::SideEffects_Any);\n\n    // emit original\n    EmitLoop(outerLoop, outerLoop->sxFor.pnodeCond, outerLoop->sxFor.pnodeBody,\n        outerLoop->sxFor.pnodeIncr, this, funcInfo, false);\n\n    // clear temporary registers since inverted loop may share nodes with\n    // emitted original loop\n    VisitClearTmpRegs(outerLoop, this, funcInfo);\n\n    // emit branch around inverted\n    this->m_writer.Br(afterInvertedLoop);\n    this->m_writer.MarkLabel(invertedLoopLabel);\n\n    // Emit a zero trip test for the original outer-loop\n    Js::ByteCodeLabel zeroTrip = this->m_writer.DefineLabel();\n    ParseNode* testNode = this->GetParser()->CopyPnode(outerLoop->sxFor.pnodeCond);\n    EmitBooleanExpression(testNode, zeroTrip, afterInvertedLoop, this, funcInfo);\n    this->m_writer.MarkLabel(zeroTrip);\n    funcInfo->ReleaseLoc(testNode);\n\n    // emit inverted\n    Emit(invertedLoop->sxFor.pnodeInit, this, funcInfo, false);\n    funcInfo->ReleaseLoc(invertedLoop->sxFor.pnodeInit);\n    EmitLoop(invertedLoop, invertedLoop->sxFor.pnodeCond, invertedLoop->sxFor.pnodeBody,\n        invertedLoop->sxFor.pnodeIncr, this, funcInfo, false);\n    this->m_writer.MarkLabel(afterInvertedLoop);\n}\n\nvoid EmitGetIterator(Js::RegSlot iteratorLocation, Js::RegSlot iterableLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get iterator object from the iterable\n    EmitInvoke(iteratorLocation, iterableLocation, Js::PropertyIds::_symbolIterator, byteCodeGenerator, funcInfo);\n\n    // throw TypeError if the result is not an object\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, iteratorLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n}\n\nvoid EmitIteratorNext(Js::RegSlot itemLocation, Js::RegSlot iteratorLocation, Js::RegSlot nextInputLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // invoke next() on the iterator\n    if (nextInputLocation == Js::Constants::NoRegister)\n    {\n        EmitInvoke(itemLocation, iteratorLocation, Js::PropertyIds::next, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitInvoke(itemLocation, iteratorLocation, Js::PropertyIds::next, byteCodeGenerator, funcInfo, nextInputLocation);\n    }\n\n    // throw TypeError if the result is not an object\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, itemLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n}\n\n// Generating\n// if (hasReturnFunction) {\n//     value = Call Retrun;\n//     if (value != Object) \n//        throw TypeError;\n// }\n\nvoid EmitIteratorClose(Js::RegSlot iteratorLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::RegSlot returnLocation = funcInfo->AcquireTmpRegister();\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel noReturn = byteCodeGenerator->Writer()->DefineLabel();\n\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorLocation, Js::PropertyIds::return_, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, returnLocation, iteratorLocation, cacheId);\n\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrEq_A, noReturn, returnLocation, funcInfo->undefinedConstantRegister);\n\n    EmitInvoke(returnLocation, iteratorLocation, Js::PropertyIds::return_, byteCodeGenerator, funcInfo);\n\n    // throw TypeError if the result is not an Object\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, returnLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n    byteCodeGenerator->Writer()->MarkLabel(noReturn);\n\n    funcInfo->ReleaseTmpRegister(returnLocation);\n}\n\nvoid EmitIteratorComplete(Js::RegSlot doneLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get the iterator result's \"done\" property\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorResultLocation, Js::PropertyIds::done, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, doneLocation, iteratorResultLocation, cacheId);\n\n    // Do not need to do ToBoolean explicitly with current uses of EmitIteratorComplete since BrTrue_A does this.\n    // Add a ToBoolean controlled by template flag if needed for new uses later on.\n}\n\nvoid EmitIteratorValue(Js::RegSlot valueLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get the iterator result's \"value\" property\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorResultLocation, Js::PropertyIds::value, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, valueLocation, iteratorResultLocation, cacheId);\n}\n\nvoid EmitForInOfLoopBody(ParseNode *loopNode,\n    Js::ByteCodeLabel loopEntrance,\n    Js::ByteCodeLabel continuePastLoop,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue)\n{\n    if (loopNode->sxForInOrForOf.pnodeLval->nop != knopVarDecl &&\n        loopNode->sxForInOrForOf.pnodeLval->nop != knopLetDecl &&\n        loopNode->sxForInOrForOf.pnodeLval->nop != knopConstDecl)\n    {\n        EmitReference(loopNode->sxForInOrForOf.pnodeLval, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        Symbol * sym = loopNode->sxForInOrForOf.pnodeLval->sxVar.sym;\n        sym->SetNeedDeclaration(false);\n    }\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        BeginEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n\n    EmitAssignment(nullptr, loopNode->sxForInOrForOf.pnodeLval, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    // The StartStatement is already done in the caller of this function.\n    byteCodeGenerator->EndStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    funcInfo->ReleaseReference(loopNode->sxForInOrForOf.pnodeLval);\n\n    Emit(loopNode->sxForInOrForOf.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n    funcInfo->ReleaseLoc(loopNode->sxForInOrForOf.pnodeBody);\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(loopNode->sxForInOrForOf.itemLocation);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxForInOrForOf.continueLabel);\n    }\n    byteCodeGenerator->Writer()->Br(loopEntrance);\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxForInOrForOf.breakLabel);\n    }\n}\n\nvoid EmitForIn(ParseNode *loopNode,\n    Js::ByteCodeLabel loopEntrance,\n    Js::ByteCodeLabel continuePastLoop,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue)\n{\n    Assert(loopNode->nop == knopForIn);\n    Assert(loopNode->location == Js::Constants::NoRegister);\n\n    // Grab registers for the enumerator and for the current enumerated item.\n    // The enumerator register will be released after this call returns.\n    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();\n\n    uint forInLoopLevel = funcInfo->AcquireForInLoopLevel();\n\n    // get enumerator from the collection\n    byteCodeGenerator->Writer()->Reg1Unsigned1(Js::OpCode::InitForInEnumerator, loopNode->sxForInOrForOf.pnodeObj->location, forInLoopLevel);\n\n    // The StartStatement is already done in the caller of the current function, which is EmitForInOrForOf\n    byteCodeGenerator->EndStatement(loopNode);\n\n    // Need to increment loop count whether we are going into profile or not for HasLoop()\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxForInOrForOf.loopId = loopId;\n\n    // The EndStatement will happen in the EmitForInOfLoopBody function\n    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    // branch past loop when MoveAndGetNext returns nullptr\n    byteCodeGenerator->Writer()->BrReg1Unsigned1(Js::OpCode::BrOnEmpty, continuePastLoop, loopNode->sxForInOrForOf.itemLocation, forInLoopLevel);\n    \n    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    funcInfo->ReleaseForInLoopLevel(forInLoopLevel);\n\n    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitForInOrForOf(ParseNode *loopNode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    bool isForIn = (loopNode->nop == knopForIn);\n    Assert(isForIn || loopNode->nop == knopForOf);\n\n    BeginEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->StartStatement(loopNode);\n    if (!isForIn)\n    {\n        funcInfo->AcquireLoc(loopNode);\n    }\n\n    // Record the branch bytecode offset.\n    // This is used for \"ignore exception\" and \"set next stmt\" scenarios. See ProbeContainer::GetNextUserStatementOffsetForAdvance:\n    // If there is a branch recorded between current offset and next stmt offset, we'll use offset of the branch recorded,\n    // otherwise use offset of next stmt.\n    // The idea here is that when we bail out after ignore exception, we need to bail out to the beginning of the ForIn,\n    // but currently ForIn stmt starts at the condition part, which is needed for correct handling of break point on ForIn\n    // (break every time on the loop back edge) and correct display of current statement under debugger.\n    // See WinBlue 231880 for details.\n    byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_All);\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled() &&\n        loopNode->sxForInOrForOf.pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        byteCodeGenerator->Writer()->RecordForInOrOfCollectionScope();\n    }\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    if (loopNode->sxForInOrForOf.pnodeLval->nop == knopVarDecl)\n    {\n        EmitReference(loopNode->sxForInOrForOf.pnodeLval, byteCodeGenerator, funcInfo);\n    }\n\n    Emit(loopNode->sxForInOrForOf.pnodeObj, byteCodeGenerator, funcInfo, false); // evaluate collection expression\n    funcInfo->ReleaseLoc(loopNode->sxForInOrForOf.pnodeObj);\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n        if (loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope != nullptr)\n        {\n            loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope->ForEachSymbol([](Symbol *sym) {\n                sym->SetIsTrackedForDebugger(false);\n            });\n        }\n    }\n\n    if (isForIn)\n    {\n        EmitForIn(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n        if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n        {\n            EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n        }\n\n        return;\n    }\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrNeq_A, skipThrow, loopNode->sxForInOrForOf.pnodeObj->location, funcInfo->undefinedConstantRegister);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ObjectCoercible));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n\n    Js::RegSlot regException = Js::Constants::NoRegister;\n    Js::RegSlot regOffset = Js::Constants::NoRegister;\n\n    // These two temp variables store the information of return function to be called or not.\n    // one variable is used for catch block and one is used for finally block. These variable will be set to true when we think that return function\n    // to be called on abrupt loop break. \n    // Why two variables? since these are temps and JIT does like not flow if single variable is used in multiple blocks.\n    Js::RegSlot shouldCallReturnFunctionLocation = funcInfo->AcquireTmpRegister();\n    Js::RegSlot shouldCallReturnFunctionLocationFinally = funcInfo->AcquireTmpRegister();\n\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    if (isCoroutine)\n    {\n        regException = funcInfo->AcquireTmpRegister();\n        regOffset = funcInfo->AcquireTmpRegister();\n    }\n\n    // Grab registers for the enumerator and for the current enumerated item.\n    // The enumerator register will be released after this call returns.\n    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();\n\n    // We want call profile information on the @@iterator call, so instead of adding a GetForOfIterator bytecode op\n    // to do all the following work in a helper do it explicitly in bytecode so that the @@iterator call is exposed\n    // to the profiler and JIT.\n\n    byteCodeGenerator->SetHasFinally(true);\n    byteCodeGenerator->SetHasTry(true);\n    byteCodeGenerator->TopFuncInfo()->byteCodeFunction->SetDontInline(true);\n\n    // do a ToObject on the collection\n    Js::RegSlot tmpObj = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Obj, tmpObj, loopNode->sxForInOrForOf.pnodeObj->location);\n\n    EmitGetIterator(loopNode->location, tmpObj, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseTmpRegister(tmpObj);\n\n    // The whole loop is surrounded with try..catch..finally - in order to capture the abrupt completion.\n    Js::ByteCodeLabel finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTryFinally(Js::OpCode::TryFinallyWithYield, finallyLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n        tryRecForTryFinally.reg1 = regException;\n        tryRecForTryFinally.reg2 = regOffset;\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTryFinally);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n    }\n\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n    }\n\n    byteCodeGenerator->EndStatement(loopNode);\n\n    // Need to increment loop count whether we are going into profile or not for HasLoop()\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxForInOrForOf.loopId = loopId;\n\n    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    EmitIteratorNext(loopNode->sxForInOrForOf.itemLocation, loopNode->location, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    // branch past loop if the result's done property is truthy\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, continuePastLoop, doneLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n\n    // otherwise put result's value property in itemLocation\n    EmitIteratorValue(loopNode->sxForInOrForOf.itemLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n\n    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    EmitCatchAndFinallyBlocks(catchLabel,\n        finallyLabel,\n        loopNode->location,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        regException,\n        regOffset,\n        byteCodeGenerator,\n        funcInfo);\n\n    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitArrayLiteral(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    funcInfo->AcquireLoc(pnode);\n    ParseNode *args = pnode->sxUni.pnode1;\n    if (args == nullptr)\n    {\n        byteCodeGenerator->Writer()->Reg1Unsigned1(\n            pnode->sxArrLit.hasMissingValues ? Js::OpCode::NewScArrayWithMissingValues : Js::OpCode::NewScArray,\n            pnode->location,\n            ByteCodeGenerator::DefaultArraySize);\n    }\n    else\n    {\n        SetNewArrayElements(pnode, pnode->location, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitJumpCleanup(ParseNode *pnode, ParseNode *pnodeTarget, ByteCodeGenerator *byteCodeGenerator, FuncInfo * funcInfo)\n{\n    for (; pnode != pnodeTarget; pnode = pnode->sxStmt.pnodeOuter)\n    {\n        switch (pnode->nop)\n        {\n        case knopTry:\n        case knopCatch:\n        case knopFinally:\n            // We insert OpCode::Leave when there is a 'return' inside try/catch/finally.\n            // This is for flow control and does not participate in identifying boundaries of try/catch blocks,\n            // thus we shouldn't call RecordCrossFrameEntryExitRecord() here.\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            break;\n\n        case knopForOf:\n#if ENABLE_PROFILE_INFO\n            if (Js::DynamicProfileInfo::EnableImplicitCallFlags(funcInfo->GetParsedFunctionBody()))\n            {\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::ProfiledLoopEnd, pnode->sxLoop.loopId);\n            }\n#endif\n            // The ForOf loop code is wrapped around try..catch..finally - Forcing couple Leave bytecode over here\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            break;\n\n#if ENABLE_PROFILE_INFO\n        case knopWhile:\n        case knopDoWhile:\n        case knopFor:\n        case knopForIn:\n            if (Js::DynamicProfileInfo::EnableImplicitCallFlags(funcInfo->GetParsedFunctionBody()))\n            {\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::ProfiledLoopEnd, pnode->sxLoop.loopId);\n            }\n            break;\n#endif\n\n        }\n    }\n}\n\nvoid EmitBinaryOpnds(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // If opnd2 can overwrite opnd1, make sure the value of opnd1 is stashed away.\n    if (MayHaveSideEffectOnNode(pnode1, pnode2))\n    {\n        SaveOpndValue(pnode1, funcInfo);\n    }\n\n    Emit(pnode1, byteCodeGenerator, funcInfo, false);\n\n    if (pnode1->nop == knopComputedName && pnode2->nop == knopClassDecl &&\n        (pnode2->sxClass.pnodeConstructor == nullptr || pnode2->sxClass.pnodeConstructor->nop != knopVarDecl))\n    {\n        Emit(pnode2, byteCodeGenerator, funcInfo, false, false, pnode1);\n    }\n    else\n    {\n        Emit(pnode2, byteCodeGenerator, funcInfo, false);\n    }\n}\n\nvoid EmitBinaryReference(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fLoadLhs)\n{\n    // Make sure that the RHS of an assignment doesn't kill the opnd's of the expression on the LHS.\n    switch (pnode1->nop)\n    {\n    case knopName:\n        if (fLoadLhs && MayHaveSideEffectOnNode(pnode1, pnode2))\n        {\n            // Given x op y, y may kill x, so stash x.\n            // Note that this only matters if we're loading x prior to the op.\n            SaveOpndValue(pnode1, funcInfo);\n        }\n        break;\n    case knopDot:\n        if (fLoadLhs)\n        {\n            // We're loading the value of the LHS before the RHS, so make sure the LHS gets a register first.\n            funcInfo->AcquireLoc(pnode1);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode2))\n        {\n            // Given x.y op z, z may kill x, so stash x away.\n            SaveOpndValue(pnode1->sxBin.pnode1, funcInfo);\n        }\n        break;\n    case knopIndex:\n        if (fLoadLhs)\n        {\n            // We're loading the value of the LHS before the RHS, so make sure the LHS gets a register first.\n            funcInfo->AcquireLoc(pnode1);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode2) ||\n            MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode1->sxBin.pnode2))\n        {\n            // Given x[y] op z, y or z may kill x, so stash x away.\n            SaveOpndValue(pnode1->sxBin.pnode1, funcInfo);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode2, pnode2))\n        {\n            // Given x[y] op z, z may kill y, so stash y away.\n            // But make sure that x gets a register before y.\n            funcInfo->AcquireLoc(pnode1->sxBin.pnode1);\n            SaveOpndValue(pnode1->sxBin.pnode2, funcInfo);\n        }\n        break;\n    }\n\n    if (fLoadLhs)\n    {\n        // Emit code to load the value of the LHS.\n        EmitLoad(pnode1, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        // Emit code to evaluate the LHS opnds, but don't load the LHS's value.\n        EmitReference(pnode1, byteCodeGenerator, funcInfo);\n    }\n\n    // Evaluate the RHS.\n    Emit(pnode2, byteCodeGenerator, funcInfo, false);\n}\n\nvoid EmitUseBeforeDeclarationRuntimeError(ByteCodeGenerator * byteCodeGenerator, Js::RegSlot location)\n{\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_UseBeforeDeclaration));\n\n    if (location != Js::Constants::NoRegister)\n    {\n        // Optionally load something into register in order to do not confuse IRBuilder. This value will never be used.\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, location);\n    }\n}\n\nvoid EmitUseBeforeDeclaration(Symbol *sym, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // Don't emit static use-before-declaration error in a closure or dynamic scope case. We detect such cases with dynamic checks,\n    // if necessary.\n    if (sym != nullptr &&\n        !sym->GetIsModuleExportStorage() &&\n        sym->GetNeedDeclaration() &&\n        byteCodeGenerator->GetCurrentScope()->HasStaticPathToAncestor(sym->GetScope()) &&\n        sym->GetScope()->GetFunc() == funcInfo)\n    {\n        EmitUseBeforeDeclarationRuntimeError(byteCodeGenerator, Js::Constants::NoRegister);\n    }\n}\n\nvoid EmitBinary(Js::OpCode opcode, ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(pnode);\n    EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n    funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg3(opcode,\n        pnode->location,\n        pnode->sxBin.pnode1->location,\n        pnode->sxBin.pnode2->location);\n    byteCodeGenerator->EndStatement(pnode);\n}\n\nbool CollectConcat(ParseNode *pnodeAdd, DListCounted<ParseNode *, ArenaAllocator>& concatOpnds, ArenaAllocator *arenaAllocator)\n{\n    Assert(pnodeAdd->nop == knopAdd);\n    Assert(pnodeAdd->CanFlattenConcatExpr());\n\n    bool doConcatString = false;\n    DList<ParseNode*, ArenaAllocator> pnodeStack(arenaAllocator);\n    pnodeStack.Prepend(pnodeAdd->sxBin.pnode2);\n    ParseNode * pnode = pnodeAdd->sxBin.pnode1;\n    while (true)\n    {\n        if (!pnode->CanFlattenConcatExpr())\n        {\n            concatOpnds.Append(pnode);\n        }\n        else if (pnode->nop == knopStr)\n        {\n            concatOpnds.Append(pnode);\n\n            // Detect if there are any string larger then the append size limit.\n            // If there are, we can do concat; otherwise, still use add so we will not lose the AddLeftDead opportunities.\n            doConcatString = doConcatString || !Js::CompoundString::ShouldAppendChars(pnode->sxPid.pid->Cch());\n        }\n        else\n        {\n            Assert(pnode->nop == knopAdd);\n            pnodeStack.Prepend(pnode->sxBin.pnode2);\n            pnode = pnode->sxBin.pnode1;\n            continue;\n        }\n\n        if (pnodeStack.Empty())\n        {\n            break;\n        }\n\n        pnode = pnodeStack.Head();\n        pnodeStack.RemoveHead();\n    }\n\n    return doConcatString;\n}\n\nvoid EmitConcat3(ParseNode *pnode, ParseNode *pnode1, ParseNode *pnode2, ParseNode *pnode3, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(pnode);\n    if (MayHaveSideEffectOnNode(pnode1, pnode2) || MayHaveSideEffectOnNode(pnode1, pnode3))\n    {\n        SaveOpndValue(pnode1, funcInfo);\n    }\n\n    if (MayHaveSideEffectOnNode(pnode2, pnode3))\n    {\n        SaveOpndValue(pnode2, funcInfo);\n    }\n\n    Emit(pnode1, byteCodeGenerator, funcInfo, false);\n    Emit(pnode2, byteCodeGenerator, funcInfo, false);\n    Emit(pnode3, byteCodeGenerator, funcInfo, false);\n    funcInfo->ReleaseLoc(pnode3);\n    funcInfo->ReleaseLoc(pnode2);\n    funcInfo->ReleaseLoc(pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg4(Js::OpCode::Concat3,\n        pnode->location,\n        pnode1->location,\n        pnode2->location,\n        pnode3->location);\n    byteCodeGenerator->EndStatement(pnode);\n}\n\nvoid EmitNewConcatStrMulti(ParseNode *pnode, uint8 count, ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    EmitBinaryOpnds(pnode1, pnode2, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseLoc(pnode2);\n    funcInfo->ReleaseLoc(pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg3B1(Js::OpCode::NewConcatStrMulti,\n        pnode->location,\n        pnode1->location,\n        pnode2->location,\n        count);\n}\n\nvoid EmitAdd(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Assert(pnode->nop == knopAdd);\n\n    if (pnode->CanFlattenConcatExpr())\n    {\n        // We should only have a string concat if the feature is on.\n        Assert(!PHASE_OFF1(Js::ByteCodeConcatExprOptPhase));\n        DListCounted<ParseNode*, ArenaAllocator> concatOpnds(byteCodeGenerator->GetAllocator());\n        bool doConcatString = CollectConcat(pnode, concatOpnds, byteCodeGenerator->GetAllocator());\n        if (doConcatString)\n        {\n            uint concatCount = concatOpnds.Count();\n            Assert(concatCount >= 2);\n\n            // Don't do concatN if the number is too high\n            // CONSIDER: although we could have done multiple ConcatNs\n            if (concatCount > 2 && concatCount <= UINT8_MAX)\n            {\n#if DBG\n                char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];\n#endif\n                ParseNode * pnode1 = concatOpnds.Head();\n                concatOpnds.RemoveHead();\n                ParseNode * pnode2 = concatOpnds.Head();\n                concatOpnds.RemoveHead();\n                if (concatCount == 3)\n                {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ByteCodeConcatExprOptPhase, _u(\"%s(%s) offset:#%d : Concat3\\n\"),\n                        funcInfo->GetParsedFunctionBody()->GetDisplayName(),\n                        funcInfo->GetParsedFunctionBody()->GetDebugNumberSet(debugStringBuffer),\n                        byteCodeGenerator->Writer()->ByteCodeDataSize());\n                    EmitConcat3(pnode, pnode1, pnode2, concatOpnds.Head(), byteCodeGenerator, funcInfo);\n                    return;\n                }\n\n                OUTPUT_TRACE_DEBUGONLY(Js::ByteCodeConcatExprOptPhase, _u(\"%s(%s) offset:#%d: ConcatMulti %d\\n\"),\n                    funcInfo->GetParsedFunctionBody()->GetDisplayName(),\n                    funcInfo->GetParsedFunctionBody()->GetDebugNumberSet(debugStringBuffer),\n                    byteCodeGenerator->Writer()->ByteCodeDataSize(), concatCount);\n                byteCodeGenerator->StartStatement(pnode);\n                funcInfo->AcquireLoc(pnode);\n\n                // CONSIDER: this may cause the backend not able CSE repeating pattern within the concat.\n                EmitNewConcatStrMulti(pnode, (uint8)concatCount, pnode1, pnode2, byteCodeGenerator, funcInfo);\n\n                uint i = 2;\n                do\n                {\n                    ParseNode * currNode = concatOpnds.Head();\n                    concatOpnds.RemoveHead();\n                    ParseNode * currNode2 = concatOpnds.Head();\n                    concatOpnds.RemoveHead();\n\n                    EmitBinaryOpnds(currNode, currNode2, byteCodeGenerator, funcInfo);\n                    funcInfo->ReleaseLoc(currNode2);\n                    funcInfo->ReleaseLoc(currNode);\n                    byteCodeGenerator->Writer()->Reg3B1(\n                        Js::OpCode::SetConcatStrMultiItem2, pnode->location, currNode->location, currNode2->location, (uint8)i);\n                    i += 2;\n                } while (concatOpnds.Count() > 1);\n\n                if (!concatOpnds.Empty())\n                {\n                    ParseNode * currNode = concatOpnds.Head();\n                    Emit(currNode, byteCodeGenerator, funcInfo, false);\n                    funcInfo->ReleaseLoc(currNode);\n                    byteCodeGenerator->Writer()->Reg2B1(\n                        Js::OpCode::SetConcatStrMultiItem, pnode->location, currNode->location, (uint8)i);\n                    i++;\n                }\n\n                Assert(concatCount == i);\n                byteCodeGenerator->EndStatement(pnode);\n                return;\n            }\n        }\n\n        // Since we collected all the node already, let's just emit them instead of doing it recursively.\n        byteCodeGenerator->StartStatement(pnode);\n        ParseNode * currNode = concatOpnds.Head();\n        concatOpnds.RemoveHead();\n        ParseNode * currNode2 = concatOpnds.Head();\n        concatOpnds.RemoveHead();\n\n        EmitBinaryOpnds(currNode, currNode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(currNode2);\n        funcInfo->ReleaseLoc(currNode);\n        Js::RegSlot dstReg = funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg3(\n            Js::OpCode::Add_A, dstReg, currNode->location, currNode2->location);\n        while (!concatOpnds.Empty())\n        {\n            currNode = concatOpnds.Head();\n            concatOpnds.RemoveHead();\n            Emit(currNode, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(currNode);\n            byteCodeGenerator->Writer()->Reg3(\n                Js::OpCode::Add_A, dstReg, dstReg, currNode->location);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n    }\n    else\n    {\n        EmitBinary(Js::OpCode::Add_A, pnode, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitSuperFieldPatch(FuncInfo* funcInfo, ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator)\n{\n    ParseNodePtr propFuncNode = funcInfo->root;\n\n    if (byteCodeGenerator->GetFlags() & fscrEval)\n    {\n        // If we are inside an eval, ScopedLdHomeObj will take care of the patch.\n        return;\n    }\n\n    if (funcInfo->IsLambda())\n    {\n        FuncInfo *parent = byteCodeGenerator->FindEnclosingNonLambda();\n        propFuncNode = parent->root;\n    }\n\n    // No need to emit a LdFld for the constructor.\n    if (propFuncNode->sxFnc.IsClassConstructor())\n    {\n        return;\n    }\n\n    if (!propFuncNode->sxFnc.IsClassMember() || propFuncNode->sxFnc.pid == nullptr)\n    {\n        // Non-methods will fail lookup.\n        return;\n    }\n    if (propFuncNode->sxFnc.pid->GetPropertyId() == Js::Constants::NoProperty)\n    {\n        byteCodeGenerator->AssignPropertyId(propFuncNode->sxFnc.pid);\n    }\n\n    // Load the current method's property ID from super instead of using super directly.\n    Js::RegSlot superLoc = funcInfo->superRegister;\n    pnode->sxCall.pnodeTarget->location = Js::Constants::NoRegister;\n    Js::RegSlot superPropLoc = funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n    Js::PropertyId propertyId = propFuncNode->sxFnc.pid->GetPropertyId();\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(superLoc, propertyId, true, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdMethodFld, superPropLoc, superLoc, cacheId);\n\n    propFuncNode->sxFnc.pnodeName = nullptr;\n}\n\n\n\nvoid ByteCodeGenerator::EmitLeaveOpCodesBeforeYield()\n{\n    for (TryScopeRecord* node = this->tryScopeRecordsList.Tail(); node != nullptr; node = node->Previous())\n    {\n        switch (node->op)\n        {\n        case Js::OpCode::TryFinallyWithYield:\n            this->Writer()->Empty(Js::OpCode::LeaveNull);\n            break;\n        case Js::OpCode::TryCatch:\n        case Js::OpCode::ResumeFinally:\n        case Js::OpCode::ResumeCatch:\n            this->Writer()->Empty(Js::OpCode::Leave);\n            break;\n        default:\n            AssertMsg(false, \"Unexpected OpCode before Yield in the Try-Catch-Finally cache for generator!\");\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitTryBlockHeadersAfterYield()\n{\n    for (TryScopeRecord* node = this->tryScopeRecordsList.Head(); node != nullptr; node = node->Next())\n    {\n        switch (node->op)\n        {\n        case Js::OpCode::TryCatch:\n            this->Writer()->Br(node->op, node->label);\n            break;\n        case Js::OpCode::TryFinallyWithYield:\n        case Js::OpCode::ResumeFinally:\n            this->Writer()->BrReg2(node->op, node->label, node->reg1, node->reg2);\n            break;\n        case Js::OpCode::ResumeCatch:\n            this->Writer()->Empty(node->op);\n            break;\n        default:\n            AssertMsg(false, \"Unexpected OpCode after yield in the Try-Catch-Finally cache for generator!\");\n            break;\n        }\n    }\n}\n\nvoid EmitYield(Js::RegSlot inputLocation, Js::RegSlot resultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo,\n    Js::RegSlot yieldStarIterator = Js::Constants::NoRegister)\n{\n    // If the bytecode emitted by this function is part of 'yield*', inputLocation is the object\n    // returned by the iterable's next/return/throw method. Otherwise, it is the yielded value.\n    if (yieldStarIterator == Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::NewScObjectSimple, funcInfo->yieldRegister);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->yieldRegister, Js::PropertyIds::value, false, true);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::StFld, inputLocation, funcInfo->yieldRegister, cacheId);\n\n        cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->yieldRegister, Js::PropertyIds::done, false, true);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::StFld, funcInfo->falseConstantRegister, funcInfo->yieldRegister, cacheId);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, funcInfo->yieldRegister, inputLocation);\n    }\n\n    byteCodeGenerator->EmitLeaveOpCodesBeforeYield();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Yield, funcInfo->yieldRegister, funcInfo->yieldRegister);\n    byteCodeGenerator->EmitTryBlockHeadersAfterYield();\n\n    if (yieldStarIterator == Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::ResumeYield, resultLocation, funcInfo->yieldRegister);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Reg3(Js::OpCode::ResumeYieldStar, resultLocation, funcInfo->yieldRegister, yieldStarIterator);\n    }\n}\n\nvoid EmitYieldStar(ParseNode* yieldStarNode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    funcInfo->AcquireLoc(yieldStarNode);\n\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    Js::RegSlot iteratorLocation = funcInfo->AcquireTmpRegister();\n\n    // Evaluate operand\n    Emit(yieldStarNode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n    funcInfo->ReleaseLoc(yieldStarNode->sxUni.pnode1);\n\n    EmitGetIterator(iteratorLocation, yieldStarNode->sxUni.pnode1->location, byteCodeGenerator, funcInfo);\n\n    // Call the iterator's next()\n    EmitIteratorNext(yieldStarNode->location, iteratorLocation, funcInfo->undefinedConstantRegister, byteCodeGenerator, funcInfo);\n\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    // since a yield* doesn't have a user defined body, we cannot return from this loop\n    // which means we don't need to support EmitJumpCleanup() and there do not need to\n    // remember the loopId like the loop statements do.\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, yieldStarNode->location, byteCodeGenerator, funcInfo);\n\n    // branch past the loop if the done property is truthy\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, continuePastLoop, doneLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n\n    EmitYield(yieldStarNode->location, yieldStarNode->location, byteCodeGenerator, funcInfo, iteratorLocation);\n\n    funcInfo->ReleaseTmpRegister(iteratorLocation);\n\n    byteCodeGenerator->Writer()->Br(loopEntrance);\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    // Put the iterator result's value in yieldStarNode->location.\n    // It will be used as the result value of the yield* operator expression.\n    EmitIteratorValue(yieldStarNode->location, yieldStarNode->location, byteCodeGenerator, funcInfo);\n}\n\nvoid TrackIntConstantsOnGlobalUserObject(ByteCodeGenerator *byteCodeGenerator, bool isSymGlobalAndSingleAssignment, Js::PropertyId propertyId)\n{\n    if (isSymGlobalAndSingleAssignment)\n    {\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalUserObject(propertyId);\n    }\n}\n\nvoid TrackIntConstantsOnGlobalObject(ByteCodeGenerator *byteCodeGenerator, bool isSymGlobalAndSingleAssignment, Js::PropertyId propertyId)\n{\n    if (isSymGlobalAndSingleAssignment)\n    {\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalObject(propertyId);\n    }\n}\n\nvoid TrackIntConstantsOnGlobalObject(ByteCodeGenerator *byteCodeGenerator, Symbol *sym)\n{\n    if (sym && sym->GetIsGlobal() && sym->IsAssignedOnce())\n    {\n        Js::PropertyId propertyId = sym->EnsurePosition(byteCodeGenerator);\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalObject(propertyId);\n    }\n}\n\nvoid TrackMemberNodesInObjectForIntConstants(ByteCodeGenerator *byteCodeGenerator, ParseNodePtr objNode)\n{\n    Assert(objNode->nop == knopObject);\n    Assert(ParseNode::Grfnop(objNode->nop) & fnopUni);\n\n    ParseNodePtr memberList = objNode->sxUni.pnode1;\n\n    while (memberList != nullptr)\n    {\n        ParseNodePtr memberNode = memberList->nop == knopList ? memberList->sxBin.pnode1 : memberList;\n        ParseNodePtr memberNameNode = memberNode->sxBin.pnode1;\n        ParseNodePtr memberValNode = memberNode->sxBin.pnode2;\n\n        if (memberNameNode->nop != knopComputedName && memberValNode->nop == knopInt)\n        {\n            Js::PropertyId propertyId = memberNameNode->sxPid.PropertyIdFromNameNode();\n            TrackIntConstantsOnGlobalUserObject(byteCodeGenerator, true, propertyId);\n        }\n\n        memberList = memberList->nop == knopList ? memberList->sxBin.pnode2 : nullptr;\n    }\n}\n\nvoid TrackGlobalIntAssignmentsForknopDotProps(ParseNodePtr knopDotNode, ByteCodeGenerator * byteCodeGenerator)\n{\n    Assert(knopDotNode->nop == knopDot);\n\n    ParseNodePtr objectNode = knopDotNode->sxBin.pnode1;\n    ParseNodePtr propertyNode = knopDotNode->sxBin.pnode2;\n    bool isSymGlobalAndSingleAssignment = false;\n\n    if (objectNode->nop == knopName)\n    {\n        Symbol * sym = objectNode->sxVar.sym;\n        isSymGlobalAndSingleAssignment = sym && sym->GetIsGlobal() && sym->IsAssignedOnce() && propertyNode->sxPid.pid->IsSingleAssignment();\n        Js::PropertyId propertyId = propertyNode->sxPid.PropertyIdFromNameNode();\n        TrackIntConstantsOnGlobalUserObject(byteCodeGenerator, isSymGlobalAndSingleAssignment, propertyId);\n    }\n    else if (objectNode->nop == knopThis)\n    {\n        // Assume knopThis always refer to GlobalObject\n        // Cases like \"this.a = \"\n        isSymGlobalAndSingleAssignment = propertyNode->sxPid.pid->IsSingleAssignment();\n        Js::PropertyId propertyId = propertyNode->sxPid.PropertyIdFromNameNode();\n        TrackIntConstantsOnGlobalObject(byteCodeGenerator, isSymGlobalAndSingleAssignment, propertyId);\n    }\n}\n\nvoid TrackGlobalIntAssignments(ParseNodePtr pnode, ByteCodeGenerator * byteCodeGenerator)\n{\n    // Track the Global Int Constant properties' assignments here.\n    uint nodeType = ParseNode::Grfnop(pnode->nop);\n    if (nodeType & fnopAsg)\n    {\n        if (nodeType & fnopBin)\n        {\n            ParseNodePtr lhs = pnode->sxBin.pnode1;\n            ParseNodePtr rhs = pnode->sxBin.pnode2;\n\n            Assert(lhs && rhs);\n\n            // Don't track other than integers and objects with member nodes.\n            if (rhs->nop == knopObject && (ParseNode::Grfnop(rhs->nop) & fnopUni))\n            {\n                TrackMemberNodesInObjectForIntConstants(byteCodeGenerator, rhs);\n            }\n            else if (rhs->nop != knopInt &&\n                ((rhs->nop != knopLsh && rhs->nop != knopRsh) || (rhs->sxBin.pnode1->nop != knopInt || rhs->sxBin.pnode2->nop != knopInt)))\n            {\n                return;\n            }\n\n            if (lhs->nop == knopName)\n            {\n                // Handle \"a = <Integer>\" cases here\n                Symbol * sym = lhs->sxVar.sym;\n                TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n            }\n            else if (lhs->nop == knopDot && lhs->sxBin.pnode2->nop == knopName)\n            {\n                // Cases like \"obj.a = <Integer>\"\n                TrackGlobalIntAssignmentsForknopDotProps(lhs, byteCodeGenerator);\n            }\n        }\n        else if (nodeType & fnopUni)\n        {\n            ParseNodePtr lhs = pnode->sxUni.pnode1;\n\n            if (lhs->nop == knopName)\n            {\n                // Cases like \"a++\"\n                Symbol * sym = lhs->sxVar.sym;\n                TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n            }\n            else if (lhs->nop == knopDot && lhs->sxBin.pnode2->nop == knopName)\n            {\n                // Cases like \"obj.a++\"\n                TrackGlobalIntAssignmentsForknopDotProps(lhs, byteCodeGenerator);\n            }\n        }\n    }\n}\n\nvoid Emit(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue, bool isConstructorCall, ParseNode * bindPnode, bool isTopLevel)\n{\n    if (pnode == nullptr)\n    {\n        return;\n    }\n\n    ThreadContext::ProbeCurrentStackNoDispose(Js::Constants::MinStackByteCodeVisitor, byteCodeGenerator->GetScriptContext());\n\n    TrackGlobalIntAssignments(pnode, byteCodeGenerator);\n\n    // printNop(pnode->nop);\n    switch (pnode->nop)\n    {\n    case knopList:\n        EmitList(pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopInt:\n        // currently, these are loaded at the top\n        break;\n        // PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n    case knopFlt:\n        // currently, these are loaded at the top\n        break;\n        // PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n    case knopStr:\n        // TODO: protocol for combining string constants\n        break;\n        // PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n    case knopRegExp:\n        funcInfo->GetParsedFunctionBody()->SetLiteralRegex(pnode->sxPid.regexPatternIndex, pnode->sxPid.regexPattern);\n        byteCodeGenerator->Writer()->Reg1Unsigned1(Js::OpCode::NewRegEx, funcInfo->AcquireLoc(pnode), pnode->sxPid.regexPatternIndex);\n        break;          // PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n    case knopThis:\n        // enregistered\n        // Try to load 'this' from a scope slot if we are in a derived class constructor with scope slots. Otherwise, this is a nop.\n        byteCodeGenerator->EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister);\n        break;\n        // PTNODE(knopNewTarget      , \"new.target\"       ,None    , None        , fnopLeaf)\n    case knopNewTarget:\n        break;\n        // PTNODE(knopSuper      , \"super\"       ,None    , None        , fnopLeaf)\n    case knopSuper:\n        if (!funcInfo->IsClassMember())\n        {\n            FuncInfo* nonLambdaFunc = funcInfo;\n            if (funcInfo->IsLambda())\n            {\n                nonLambdaFunc = byteCodeGenerator->FindEnclosingNonLambda();\n            }\n\n            if (nonLambdaFunc->IsGlobalFunction())\n            {\n                if ((byteCodeGenerator->GetFlags() & fscrEval))\n                {\n                    byteCodeGenerator->Writer()->Reg1(isConstructorCall ? Js::OpCode::ScopedLdFuncObj : Js::OpCode::ScopedLdHomeObj, funcInfo->AcquireLoc(pnode));\n                }\n                else\n                {\n                    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_BadSuperReference));\n                }\n            }\n        }\n        break;\n        // PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n    case knopNull:\n        // enregistered\n        break;\n        // PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n    case knopFalse:\n        // enregistered\n        break;\n        // PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n    case knopTrue:\n        // enregistered\n        break;\n        // PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n    case knopEmpty:\n        break;\n        // Unary operators.\n    // PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n    case knopNot:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Not_A, funcInfo->AcquireLoc(pnode), pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n    case knopNeg:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Neg_A, pnode->location, pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n    case knopPos:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Conv_Num, funcInfo->AcquireLoc(pnode), pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n    case knopLogNot:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // For boolean expressions that compute a result, we have to burn a register for the result\n        // so that the back end can identify it cheaply as a single temp lifetime. Revisit this if we do\n        // full-on renaming in the back end.\n        funcInfo->AcquireLoc(pnode);\n        if (pnode->sxUni.pnode1->nop == knopInt)\n        {\n            int32 value = pnode->sxUni.pnode1->sxInt.lw;\n            Js::OpCode op = value ? Js::OpCode::LdFalse : Js::OpCode::LdTrue;\n            byteCodeGenerator->Writer()->Reg1(op, pnode->location);\n        }\n        else\n        {\n            Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, pnode->location);\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, doneLabel, pnode->sxUni.pnode1->location);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, pnode->location);\n            byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        }\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni         , fnopUni)\n    case knopEllipsis:\n    {\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        // Transparently pass the location of the array.\n        pnode->location = pnode->sxUni.pnode1->location;\n        break;\n    }\n    // PTNODE(knopIncPost    , \"post++\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n    case knopIncPost:\n    case knopDecPost:\n        // FALL THROUGH to the faster pre-inc/dec case if the result of the expression is not needed.\n        if (pnode->isUsed || fReturnValue)\n        {\n            byteCodeGenerator->StartStatement(pnode);\n            Js::OpCode op = Js::OpCode::Add_A;\n            if (pnode->nop == knopDecPost)\n            {\n                op = Js::OpCode::Sub_A;\n            }\n            // Grab a register for the expression result.\n            funcInfo->AcquireLoc(pnode);\n\n            // Load the initial value, convert it (this is the expression result), and increment it.\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Num, pnode->location, pnode->sxUni.pnode1->location);\n\n            Js::RegSlot incDecResult = pnode->sxUni.pnode1->location;\n            if (funcInfo->RegIsConst(incDecResult))\n            {\n                // Avoid letting the add/sub overwrite a constant reg, as this may actually change the\n                // contents of the constant table.\n                incDecResult = funcInfo->AcquireTmpRegister();\n            }\n\n            Js::RegSlot oneReg = funcInfo->constantToRegister.LookupWithKey(1, Js::Constants::NoRegister);\n            Assert(oneReg != Js::Constants::NoRegister);\n            byteCodeGenerator->Writer()->Reg3(op, incDecResult, pnode->location, oneReg);\n\n            // Store the incremented value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, incDecResult, byteCodeGenerator, funcInfo);\n\n            // Release the incremented value and the l-value.\n            if (incDecResult != pnode->sxUni.pnode1->location)\n            {\n                funcInfo->ReleaseTmpRegister(incDecResult);\n            }\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n            byteCodeGenerator->EndStatement(pnode);\n\n            break;\n        }\n        else\n        {\n            pnode->nop = (pnode->nop == knopIncPost) ? knopIncPre : knopDecPre;\n        }\n        // FALL THROUGH to the fast pre-inc/dec case if the result of the expression is not needed.\n\n    // PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n    case knopIncPre:\n    case knopDecPre:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n        Js::OpCode op = Js::OpCode::Incr_A;\n        if (pnode->nop == knopDecPre)\n        {\n            op = Js::OpCode::Decr_A;\n        }\n\n        // Assign a register for the result only if the result is used or the operand can't be assigned to\n        // (i.e., is a constant).\n        if (pnode->isUsed || fReturnValue)\n        {\n            funcInfo->AcquireLoc(pnode);\n\n            // Load the initial value and increment it (this is the expression result).\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->Writer()->Reg2(op, pnode->location, pnode->sxUni.pnode1->location);\n\n            // Store the incremented value and release the l-value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n        }\n        else\n        {\n            // Load the initial value and increment it (this is the expression result).\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n\n            Js::RegSlot incDecResult = pnode->sxUni.pnode1->location;\n            if (funcInfo->RegIsConst(incDecResult))\n            {\n                // Avoid letting the add/sub overwrite a constant reg, as this may actually change the\n                // contents of the constant table.\n                incDecResult = funcInfo->AcquireTmpRegister();\n            }\n\n            byteCodeGenerator->Writer()->Reg2(op, incDecResult, pnode->sxUni.pnode1->location);\n\n            // Store the incremented value and release the l-value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, incDecResult, byteCodeGenerator, funcInfo);\n            if (incDecResult != pnode->sxUni.pnode1->location)\n            {\n                funcInfo->ReleaseTmpRegister(incDecResult);\n            }\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n        }\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    // PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n    case knopTypeof:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        ParseNode* pnodeOpnd = pnode->sxUni.pnode1;\n        switch (pnodeOpnd->nop)\n        {\n        case knopDot:\n        {\n            Emit(pnodeOpnd->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            Js::PropertyId propertyId = pnodeOpnd->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n            Assert(pnodeOpnd->sxBin.pnode2->nop == knopName);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n\n            byteCodeGenerator->EmitTypeOfFld(funcInfo, propertyId, pnode->location, pnodeOpnd->sxBin.pnode1->location, Js::OpCode::LdFldForTypeOf);\n            break;\n        }\n\n        case knopIndex:\n        {\n            EmitBinaryOpnds(pnodeOpnd->sxBin.pnode1, pnodeOpnd->sxBin.pnode2, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode2);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Element(Js::OpCode::TypeofElem, pnode->location, pnodeOpnd->sxBin.pnode1->location, pnodeOpnd->sxBin.pnode2->location);\n            break;\n        }\n        case knopName:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->EmitPropTypeof(pnode->location, pnodeOpnd->sxPid.sym, pnodeOpnd->sxPid.pid, funcInfo);\n            break;\n        }\n\n        default:\n            Emit(pnodeOpnd, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pnodeOpnd);\n            byteCodeGenerator->Writer()->Reg2(\n                Js::OpCode::Typeof, funcInfo->AcquireLoc(pnode), pnodeOpnd->location);\n            break;\n        }\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n    case knopVoid:\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, funcInfo->AcquireLoc(pnode));\n        break;\n        // PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n    case knopArray:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitArrayLiteral(pnode, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n    case knopObject:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        funcInfo->AcquireLoc(pnode);\n        EmitObjectInitializers(pnode->sxUni.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopComputedName, \"[name]\"      ,None    ,Uni  ,fnopUni)\n    case knopComputedName:\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        if (pnode->location == Js::Constants::NoRegister)\n        {\n            // The name is some expression with no home location. We can just re-use the register.\n            pnode->location = pnode->sxUni.pnode1->location;\n        }\n        else if (pnode->location != pnode->sxUni.pnode1->location)\n        {\n            // The name had to be protected from side-effects of the RHS.\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxUni.pnode1->location);\n        }\n        break;\n        // Binary and Ternary Operators\n    case knopAdd:\n        EmitAdd(pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopSub:\n    case knopMul:\n    case knopExpo:\n    case knopDiv:\n    case knopMod:\n    case knopOr:\n    case knopXor:\n    case knopAnd:\n    case knopLsh:\n    case knopRsh:\n    case knopRs2:\n    case knopIn:\n        EmitBinary(nopToOp[pnode->nop], pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopInstOf:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        uint cacheId = funcInfo->NewIsInstInlineCache();\n        byteCodeGenerator->Writer()->Reg3C(nopToOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n            pnode->sxBin.pnode2->location, cacheId);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n    }\n    break;\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg3(nopToCMOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n            pnode->sxBin.pnode2->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    case knopNew:\n    {\n        EmitNew(pnode, byteCodeGenerator, funcInfo);\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopDelete:\n    {\n        ParseNode *pexpr = pnode->sxUni.pnode1;\n        byteCodeGenerator->StartStatement(pnode);\n        switch (pexpr->nop)\n        {\n        case knopName:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->EmitPropDelete(pnode->location, pexpr->sxPid.sym, pexpr->sxPid.pid, funcInfo);\n            break;\n        }\n        case knopDot:\n        {\n            Emit(pexpr->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            Js::PropertyId propertyId = pexpr->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            \n            if (pexpr->sxBin.pnode1->nop == knopSuper)\n            {\n                byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_DeletePropertyWithSuper));\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->Property(Js::OpCode::DeleteFld, pnode->location, pexpr->sxBin.pnode1->location,\n                    funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n\n            break;\n        }\n        case knopIndex:\n        {\n            EmitBinaryOpnds(pexpr->sxBin.pnode1, pexpr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode2);\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Element(Js::OpCode::DeleteElemI_A, pnode->location, pexpr->sxBin.pnode1->location, pexpr->sxBin.pnode2->location);\n            break;\n        }\n        case knopThis:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, pnode->location);\n            break;\n        }\n        default:\n        {\n            Emit(pexpr, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pexpr);\n            byteCodeGenerator->Writer()->Reg2(\n                Js::OpCode::Delete_A, funcInfo->AcquireLoc(pnode), pexpr->location);\n            break;\n        }\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopCall:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n\n        if (pnode->sxCall.pnodeTarget->nop == knopSuper)\n        {\n            byteCodeGenerator->EmitSuperCall(funcInfo, pnode, fReturnValue);\n        }\n        else\n        {\n            if (pnode->sxCall.isApplyCall && funcInfo->GetApplyEnclosesArgs())\n            {\n                // TODO[ianhall]: Can we remove the ApplyCall bytecode gen time optimization?\n                EmitApplyCall(pnode, Js::Constants::NoRegister, byteCodeGenerator, funcInfo, fReturnValue);\n            }\n            else\n            {\n                EmitCall(pnode, Js::Constants::NoRegister, byteCodeGenerator, funcInfo, fReturnValue, /*fEvaluateComponents*/ true, /*fHasNewTarget*/ false);\n            }\n        }\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopIndex:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n\n        Js::RegSlot callObjLocation = pnode->sxBin.pnode1->location;\n\n        Js::RegSlot protoLocation =\n            (pnode->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            callObjLocation;\n\n        EmitSuperMethodBegin(pnode, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Element(\n            Js::OpCode::LdElemI_A, pnode->location, protoLocation, pnode->sxBin.pnode2->location);\n\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // this is MemberExpression as rvalue\n    case knopDot:\n    {\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        Js::PropertyId propertyId = pnode->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        Js::RegSlot callObjLocation = pnode->sxBin.pnode1->location;\n        Js::RegSlot protoLocation = callObjLocation;\n        EmitSuperMethodBegin(pnode, byteCodeGenerator, funcInfo);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(callObjLocation, propertyId, false, false);\n        if (pnode->IsCallApplyTargetLoad())\n        {\n            if (pnode->sxBin.pnode1->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFldForCallApplyTarget, pnode->location, tmpReg, cacheId);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFldForCallApplyTarget, pnode->location, protoLocation, cacheId);\n            }\n        }\n        else\n        {\n            if (pnode->sxBin.pnode1->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n                byteCodeGenerator->Writer()->PatchablePropertyWithThisPtr(Js::OpCode::LdSuperFld, pnode->location, tmpReg, funcInfo->thisPointerRegister, cacheId, isConstructorCall);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, pnode->location, callObjLocation, cacheId, isConstructorCall);\n            }\n        }\n\n        break;\n    }\n\n    // PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n    case knopAsg:\n    {\n        ParseNode *lhs = pnode->sxBin.pnode1;\n        ParseNode *rhs = pnode->sxBin.pnode2;\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->isUsed || fReturnValue)\n        {\n            // If the assignment result is used, grab a register to hold it and pass it to EmitAssignment,\n            // which will copy the assigned value there.\n            funcInfo->AcquireLoc(pnode);\n            EmitBinaryReference(lhs, rhs, byteCodeGenerator, funcInfo, false);\n            EmitAssignment(pnode, lhs, rhs->location, byteCodeGenerator, funcInfo);\n        }\n        else\n        {\n            EmitBinaryReference(lhs, rhs, byteCodeGenerator, funcInfo, false);\n            EmitAssignment(nullptr, lhs, rhs->location, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoc(rhs);\n        if (!(byteCodeGenerator->IsES6DestructuringEnabled() && (lhs->IsPattern())))\n        {\n            funcInfo->ReleaseReference(lhs);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n\n    case knopName:\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->EmitPropLoad(pnode->location, pnode->sxPid.sym, pnode->sxPid.pid, funcInfo);\n        break;\n\n    case knopComma:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        // The parser marks binary opnd pnodes as used, but value of the first opnd of a comma is not used.\n        // Easier to correct this here than to check every binary op in the parser.\n        ParseNode *pnode1 = pnode->sxBin.pnode1;\n        pnode1->isUsed = false;\n        if (pnode1->nop == knopComma)\n        {\n            // Spot fix for giant comma expressions that send us into OOS if we use a simple recursive\n            // algorithm. Instead of recursing on comma LHS's, iterate over them, pushing the RHS's onto\n            // a stack. (This suggests a model for removing recursion from Emit altogether...)\n            ArenaAllocator *alloc = byteCodeGenerator->GetAllocator();\n            SList<ParseNode *> rhsStack(alloc);\n            do\n            {\n                rhsStack.Push(pnode1->sxBin.pnode2);\n                pnode1 = pnode1->sxBin.pnode1;\n                pnode1->isUsed = false;\n            } while (pnode1->nop == knopComma);\n\n            Emit(pnode1, byteCodeGenerator, funcInfo, false);\n            if (funcInfo->IsTmpReg(pnode1->location))\n            {\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnode1->location);\n            }\n\n            while (!rhsStack.Empty())\n            {\n                ParseNode *pnodeRhs = rhsStack.Pop();\n                pnodeRhs->isUsed = false;\n                Emit(pnodeRhs, byteCodeGenerator, funcInfo, false);\n                if (funcInfo->IsTmpReg(pnodeRhs->location))\n                {\n                    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnodeRhs->location);\n                }\n                funcInfo->ReleaseLoc(pnodeRhs);\n            }\n        }\n        else\n        {\n            Emit(pnode1, byteCodeGenerator, funcInfo, false);\n            if (funcInfo->IsTmpReg(pnode1->location))\n            {\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnode1->location);\n            }\n        }\n        funcInfo->ReleaseLoc(pnode1);\n\n        pnode->sxBin.pnode2->isUsed = pnode->isUsed || fReturnValue;\n        Emit(pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->AcquireLoc(pnode);\n        if (pnode->sxBin.pnode2->isUsed && pnode->location != pnode->sxBin.pnode2->location)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxBin.pnode2->location);\n        }\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n    }\n    break;\n\n    // The binary logical ops && and || resolve to the value of the left-hand expression if its\n    // boolean value short-circuits the operation, and to the value of the right-hand expression\n    // otherwise. (In other words, the \"truth\" of the right-hand expression is never tested.)\n    // PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n    case knopLogOr:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // We use a single dest here for the whole generating boolean expr, because we were poorly\n        // optimizing the previous version where we had a dest for each level\n        funcInfo->AcquireLoc(pnode);\n        EmitGeneratingBooleanExpression(pnode, doneLabel, true, doneLabel, true, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n    case knopLogAnd:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // We use a single dest here for the whole generating boolean expr, because we were poorly\n        // optimizing the previous version where we had a dest for each level\n        funcInfo->AcquireLoc(pnode);\n        EmitGeneratingBooleanExpression(pnode, doneLabel, true, doneLabel, true, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n    case knopQmark:\n    {\n        Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel falseLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel skipLabel = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(pnode->sxTri.pnode1, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode1);\n\n        // For boolean expressions that compute a result, we have to burn a register for the result\n        // so that the back end can identify it cheaply as a single temp lifetime. Revisit this if we do\n        // full-on renaming in the back end.\n        funcInfo->AcquireLoc(pnode);\n\n        Emit(pnode->sxTri.pnode2, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxTri.pnode2->location);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode2);\n\n        // Record the branch bytecode offset\n        byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_FromCurrentToNext);\n\n        byteCodeGenerator->Writer()->Br(skipLabel);\n\n        byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n        Emit(pnode->sxTri.pnode3, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxTri.pnode3->location);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode3);\n\n        byteCodeGenerator->Writer()->MarkLabel(skipLabel);\n\n        break;\n    }\n\n    case knopAsgAdd:\n    case knopAsgSub:\n    case knopAsgMul:\n    case knopAsgDiv:\n    case knopAsgExpo:\n    case knopAsgMod:\n    case knopAsgAnd:\n    case knopAsgXor:\n    case knopAsgOr:\n    case knopAsgLsh:\n    case knopAsgRsh:\n    case knopAsgRs2:\n        byteCodeGenerator->StartStatement(pnode);\n        // Assign a register for the result only if the result is used or the LHS can't be assigned to\n        // (i.e., is a constant).\n        if (pnode->isUsed || fReturnValue || funcInfo->RegIsConst(pnode->sxBin.pnode1->location))\n        {\n            // If the assign-op result is used, grab a register to hold it.\n            funcInfo->AcquireLoc(pnode);\n\n            // Grab a register for the initial value and load it.\n            EmitBinaryReference(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, true);\n            funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n            // Do the arithmetic, store the result, and release the l-value.\n            byteCodeGenerator->Writer()->Reg3(nopToOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n                pnode->sxBin.pnode2->location);\n\n            EmitAssignment(pnode, pnode->sxBin.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n        }\n        else\n        {\n            // Grab a register for the initial value and load it.\n            EmitBinaryReference(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, true);\n            funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n            // Do the arithmetic, store the result, and release the l-value.\n            byteCodeGenerator->Writer()->Reg3(nopToOp[pnode->nop], pnode->sxBin.pnode1->location, pnode->sxBin.pnode1->location,\n                pnode->sxBin.pnode2->location);\n            EmitAssignment(nullptr, pnode->sxBin.pnode1, pnode->sxBin.pnode1->location, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoad(pnode->sxBin.pnode1);\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n\n        // General nodes.\n        // PTNODE(knopTempRef      , \"temp ref\"  ,None   ,Uni ,fnopUni)\n    case knopTempRef:\n        // TODO: check whether mov is necessary\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxUni.pnode1->location);\n        break;\n        // PTNODE(knopTemp      , \"temp\"        ,None   ,None ,fnopLeaf)\n    case knopTemp:\n        // Emit initialization code\n        if (pnode->sxVar.pnodeInit != nullptr)\n        {\n            byteCodeGenerator->StartStatement(pnode);\n            Emit(pnode->sxVar.pnodeInit, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxVar.pnodeInit->location);\n            funcInfo->ReleaseLoc(pnode->sxVar.pnodeInit);\n            byteCodeGenerator->EndStatement(pnode);\n        }\n        break;\n        // PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n    case knopVarDecl:\n    case knopConstDecl:\n    case knopLetDecl:\n    {\n        // Emit initialization code\n        ParseNodePtr initNode = pnode->sxVar.pnodeInit;\n        AssertMsg(pnode->nop != knopConstDecl || initNode != nullptr, \"knopConstDecl expected to have an initializer\");\n\n        if (initNode != nullptr || pnode->nop == knopLetDecl)\n        {\n            Symbol *sym = pnode->sxVar.sym;\n            Js::RegSlot rhsLocation;\n\n            byteCodeGenerator->StartStatement(pnode);\n\n            if (initNode != nullptr)\n            {\n                Emit(initNode, byteCodeGenerator, funcInfo, false);\n                rhsLocation = initNode->location;\n\n                if (initNode->nop == knopObject)\n                {\n                    TrackMemberNodesInObjectForIntConstants(byteCodeGenerator, initNode);\n                }\n                else if (initNode->nop == knopInt)\n                {\n                    TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n                }\n            }\n            else\n            {\n                Assert(pnode->nop == knopLetDecl);\n                rhsLocation = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, rhsLocation);\n            }\n\n            if (pnode->nop != knopVarDecl)\n            {\n                Assert(sym->GetDecl() == pnode);\n                sym->SetNeedDeclaration(false);\n            }\n\n            EmitAssignment(nullptr, pnode, rhsLocation, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseTmpRegister(rhsLocation);\n\n            byteCodeGenerator->EndStatement(pnode);\n        }\n        break;\n    }\n    // PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n    case knopFncDecl:\n        // The \"function declarations\" were emitted in DefineFunctions()\n        if (!pnode->sxFnc.IsDeclaration())\n        {\n            byteCodeGenerator->DefineOneFunction(pnode, funcInfo, false);\n        }\n        break;\n        // PTNODE(knopClassDecl, \"class\"    ,None    ,None ,fnopLeaf)\n    case knopClassDecl:\n    {\n        funcInfo->AcquireLoc(pnode);\n\n        Assert(pnode->sxClass.pnodeConstructor);\n        pnode->sxClass.pnodeConstructor->location = pnode->location;\n\n        BeginEmitBlock(pnode->sxClass.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        // Extends\n        if (pnode->sxClass.pnodeExtends)\n        {\n            // We can't do StartStatement/EndStatement for pnodeExtends here because the load locations may differ between\n            // defer and nondefer parse modes.\n            Emit(pnode->sxClass.pnodeExtends, byteCodeGenerator, funcInfo, false);\n        }\n\n        // Constructor\n        Emit(pnode->sxClass.pnodeConstructor, byteCodeGenerator, funcInfo, false);\n        EmitComputedFunctionNameVar(bindPnode, pnode->sxClass.pnodeConstructor, byteCodeGenerator);\n        if (pnode->sxClass.pnodeExtends)\n        {\n            byteCodeGenerator->StartStatement(pnode->sxClass.pnodeExtends);\n            byteCodeGenerator->Writer()->InitClass(pnode->location, pnode->sxClass.pnodeExtends->location);\n            byteCodeGenerator->EndStatement(pnode->sxClass.pnodeExtends);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->InitClass(pnode->location);\n        }\n\n        Js::RegSlot protoLoc = funcInfo->AcquireTmpRegister(); //register set if we have Instance Methods\n        int cacheId = funcInfo->FindOrAddInlineCacheId(pnode->location, Js::PropertyIds::prototype, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, protoLoc, pnode->location, cacheId);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, pnode->location, protoLoc);\n\n        // Static Methods\n        EmitClassInitializers(pnode->sxClass.pnodeStaticMembers, pnode->location, byteCodeGenerator, funcInfo, pnode, /*isObjectEmpty*/ false);\n\n        // Instance Methods\n        EmitClassInitializers(pnode->sxClass.pnodeMembers, protoLoc, byteCodeGenerator, funcInfo, pnode, /*isObjectEmpty*/ true);\n        funcInfo->ReleaseTmpRegister(protoLoc);\n\n        // Emit name binding.\n        if (pnode->sxClass.pnodeName)\n        {\n            Symbol * sym = pnode->sxClass.pnodeName->sxVar.sym;\n            sym->SetNeedDeclaration(false);\n            byteCodeGenerator->EmitPropStore(pnode->location, sym, nullptr, funcInfo, false, true);\n        }\n\n        EndEmitBlock(pnode->sxClass.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        if (pnode->sxClass.pnodeExtends)\n        {\n            funcInfo->ReleaseLoc(pnode->sxClass.pnodeExtends);\n        }\n\n        if (pnode->sxClass.pnodeDeclName)\n        {\n            Symbol * sym = pnode->sxClass.pnodeDeclName->sxVar.sym;\n            sym->SetNeedDeclaration(false);\n            byteCodeGenerator->EmitPropStore(pnode->location, sym, nullptr, funcInfo, true, false);\n        }\n\n        if (pnode->sxClass.IsDefaultModuleExport())\n        {\n            byteCodeGenerator->EmitAssignmentToDefaultModuleExport(pnode, funcInfo);\n        }\n\n        break;\n    }\n    case knopStrTemplate:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitStringTemplate(pnode, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    case knopEndCode:\n        byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_All);\n\n        // load undefined for the fallthrough case:\n        if (!funcInfo->IsGlobalFunction())\n        {\n            if (funcInfo->IsClassConstructor())\n            {\n                // For class constructors, we need to explicitly load 'this' into the return register.\n                byteCodeGenerator->EmitClassConstructorEndCode(funcInfo);\n            }\n            else\n            {\n                // In the global function, implicit return values are copied to the return register, and if\n                // necessary the return register is initialized at the top. Don't clobber the value here.\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, ByteCodeGenerator::ReturnRegister);\n            }\n        }\n\n        // Label for non-fall-through return\n        byteCodeGenerator->Writer()->MarkLabel(funcInfo->singleExit);\n\n        if (funcInfo->GetHasCachedScope())\n        {\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::CommitScope);\n        }\n        byteCodeGenerator->StartStatement(pnode);\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Ret);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n    case knopDebugger:\n        byteCodeGenerator->StartStatement(pnode);\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Break);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n    case knopFor:\n        if (pnode->sxFor.pnodeInverted != nullptr)\n        {\n            byteCodeGenerator->EmitInvertedLoop(pnode, pnode->sxFor.pnodeInverted, funcInfo);\n        }\n        else\n        {\n            BeginEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n            Emit(pnode->sxFor.pnodeInit, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pnode->sxFor.pnodeInit);\n            if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n            {\n                CloneEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n            }\n            EmitLoop(pnode,\n                pnode->sxFor.pnodeCond,\n                pnode->sxFor.pnodeBody,\n                pnode->sxFor.pnodeIncr,\n                byteCodeGenerator,\n                funcInfo,\n                fReturnValue,\n                FALSE,\n                pnode->sxFor.pnodeBlock);\n            EndEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n        }\n        break;\n        // PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n    case knopIf:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n\n        Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel falseLabel = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(pnode->sxIf.pnodeCond, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxIf.pnodeCond);\n\n        byteCodeGenerator->EndStatement(pnode);\n\n        byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n        Emit(pnode->sxIf.pnodeTrue, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnode->sxIf.pnodeTrue);\n        if (pnode->sxIf.pnodeFalse != nullptr)\n        {\n            // has else clause\n            Js::ByteCodeLabel skipLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n            // Record the branch bytecode offset\n            byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_FromCurrentToNext);\n\n            // then clause skips else clause\n            byteCodeGenerator->Writer()->Br(skipLabel);\n            // generate code for else clause\n            byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n            Emit(pnode->sxIf.pnodeFalse, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnode->sxIf.pnodeFalse);\n            byteCodeGenerator->Writer()->MarkLabel(skipLabel);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n        }\n\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        break;\n    }\n    case knopWhile:\n        EmitLoop(pnode,\n            pnode->sxWhile.pnodeCond,\n            pnode->sxWhile.pnodeBody,\n            nullptr,\n            byteCodeGenerator,\n            funcInfo,\n            fReturnValue);\n        break;\n        // PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n    case knopDoWhile:\n        EmitLoop(pnode,\n            pnode->sxWhile.pnodeCond,\n            pnode->sxWhile.pnodeBody,\n            nullptr,\n            byteCodeGenerator,\n            funcInfo,\n            fReturnValue,\n            true);\n        break;\n        // PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n    case knopForIn:\n        EmitForInOrForOf(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n        break;\n    case knopForOf:\n        EmitForInOrForOf(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n        break;\n        // PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n    case knopReturn:\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxReturn.pnodeExpr != nullptr)\n        {\n            if (pnode->sxReturn.pnodeExpr->location == Js::Constants::NoRegister)\n            {\n                // No need to burn a register for the return value. If we need a temp, use R0 directly.\n                pnode->sxReturn.pnodeExpr->location = ByteCodeGenerator::ReturnRegister;\n            }\n            Emit(pnode->sxReturn.pnodeExpr, byteCodeGenerator, funcInfo, fReturnValue);\n            if (pnode->sxReturn.pnodeExpr->location != ByteCodeGenerator::ReturnRegister)\n            {\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, pnode->sxReturn.pnodeExpr->location);\n            }\n            funcInfo->GetParsedFunctionBody()->SetHasNoExplicitReturnValue(false);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, ByteCodeGenerator::ReturnRegister);\n        }\n        if (funcInfo->IsClassConstructor())\n        {\n            // return expr; // becomes like below:\n            //\n            // if (IsObject(expr)) {\n            //   return expr;\n            // } else if (IsBaseClassConstructor) {\n            //   return this;\n            // } else if (!IsUndefined(expr)) {\n            //   throw TypeError;\n            // }\n\n            Js::ByteCodeLabel returnExprLabel = byteCodeGenerator->Writer()->DefineLabel();\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, returnExprLabel, ByteCodeGenerator::ReturnRegister);\n\n            if (funcInfo->IsBaseClassConstructor())\n            {\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, funcInfo->thisPointerRegister);\n            }\n            else\n            {\n                Js::ByteCodeLabel returnThisLabel = byteCodeGenerator->Writer()->DefineLabel();\n                byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrEq_A, returnThisLabel, ByteCodeGenerator::ReturnRegister, funcInfo->undefinedConstantRegister);\n                byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ClassDerivedConstructorInvalidReturnType));\n                byteCodeGenerator->Writer()->MarkLabel(returnThisLabel);\n                byteCodeGenerator->EmitClassConstructorEndCode(funcInfo);\n            }\n\n            byteCodeGenerator->Writer()->MarkLabel(returnExprLabel);\n        }\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, nullptr, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Br(funcInfo->singleExit);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopLabel:\n        break;\n        // PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n    case knopBlock:\n        if (pnode->sxBlock.pnodeStmt != nullptr)\n        {\n            EmitBlock(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n            if (pnode->emitLabels)\n            {\n                byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n            }\n        }\n        break;\n        // PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n    case knopWith:\n    {\n        Assert(pnode->sxWith.pnodeObj != nullptr);\n        byteCodeGenerator->StartStatement(pnode);\n        // Copy the with object to a temp register (the location assigned to pnode) so that if the with object\n        // is overwritten in the body, the lookups are not affected.\n        funcInfo->AcquireLoc(pnode);\n        Emit(pnode->sxWith.pnodeObj, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot regVal = (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled()) ? funcInfo->AcquireTmpRegister() : pnode->location;\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Obj, regVal, pnode->sxWith.pnodeObj->location);\n        if (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled())\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::NewWithObject, pnode->location, regVal);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n\n#ifdef PERF_HINT\n        if (PHASE_TRACE1(Js::PerfHintPhase))\n        {\n            WritePerfHint(PerfHints::HasWithBlock, funcInfo->byteCodeFunction->GetFunctionBody(), byteCodeGenerator->Writer()->GetCurrentOffset() - 1);\n        }\n#endif\n        if (pnode->sxWith.pnodeBody != nullptr)\n        {\n            Scope *scope = pnode->sxWith.scope;\n            scope->SetLocation(pnode->location);\n            byteCodeGenerator->PushScope(scope);\n\n            Js::DebuggerScope *debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagExtraScopesType::DiagWithScope, regVal);\n\n            if (byteCodeGenerator->ShouldTrackDebuggerMetadata())\n            {\n                byteCodeGenerator->Writer()->AddPropertyToDebuggerScope(debuggerScope, regVal, Js::Constants::NoProperty, /*shouldConsumeRegister*/ true, Js::DebuggerScopePropertyFlags_WithObject);\n            }\n\n            Emit(pnode->sxWith.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnode->sxWith.pnodeBody);\n            byteCodeGenerator->PopScope();\n\n            byteCodeGenerator->RecordEndScopeObject(pnode);\n        }\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        if (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled())\n        {\n            funcInfo->ReleaseTmpRegister(regVal);\n        }\n        funcInfo->ReleaseLoc(pnode->sxWith.pnodeObj);\n        break;\n    }\n    // PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n    case knopBreak:\n        Assert(pnode->sxJump.pnodeTarget->emitLabels);\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, pnode->sxJump.pnodeTarget, byteCodeGenerator, funcInfo);\n        }\n        byteCodeGenerator->Writer()->Br(pnode->sxJump.pnodeTarget->sxStmt.breakLabel);\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopContinue:\n        Assert(pnode->sxJump.pnodeTarget->emitLabels);\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, pnode->sxJump.pnodeTarget, byteCodeGenerator, funcInfo);\n        }\n        byteCodeGenerator->Writer()->Br(pnode->sxJump.pnodeTarget->sxStmt.continueLabel);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n    case knopSwitch:\n    {\n        BOOL fHasDefault = false;\n        Assert(pnode->sxSwitch.pnodeVal != nullptr);\n        byteCodeGenerator->StartStatement(pnode);\n        Emit(pnode->sxSwitch.pnodeVal, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot regVal = funcInfo->AcquireTmpRegister();\n\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::BeginSwitch, regVal, pnode->sxSwitch.pnodeVal->location);\n\n        BeginEmitBlock(pnode->sxSwitch.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        byteCodeGenerator->EndStatement(pnode);\n\n        // TODO: if all cases are compile-time constants, emit a switch statement in the byte\n        // code so the BE can optimize it.\n\n        ParseNode *pnodeCase;\n        for (pnodeCase = pnode->sxSwitch.pnodeCases; pnodeCase; pnodeCase = pnodeCase->sxCase.pnodeNext)\n        {\n            // Jump to the first case body if this one doesn't match. Make sure any side-effects of the case\n            // expression take place regardless.\n            pnodeCase->sxCase.labelCase = byteCodeGenerator->Writer()->DefineLabel();\n            if (pnodeCase == pnode->sxSwitch.pnodeDefault)\n            {\n                fHasDefault = true;\n                continue;\n            }\n            Emit(pnodeCase->sxCase.pnodeExpr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->BrReg2(\n                Js::OpCode::Case, pnodeCase->sxCase.labelCase, regVal, pnodeCase->sxCase.pnodeExpr->location);\n            funcInfo->ReleaseLoc(pnodeCase->sxCase.pnodeExpr);\n        }\n\n        // No explicit case value matches. Jump to the default arm (if any) or break out altogether.\n        if (fHasDefault)\n        {\n            byteCodeGenerator->Writer()->Br(Js::OpCode::EndSwitch, pnode->sxSwitch.pnodeDefault->sxCase.labelCase);\n        }\n        else\n        {\n            if (!pnode->emitLabels)\n            {\n                pnode->sxStmt.breakLabel = byteCodeGenerator->Writer()->DefineLabel();\n            }\n            byteCodeGenerator->Writer()->Br(Js::OpCode::EndSwitch, pnode->sxStmt.breakLabel);\n        }\n        // Now emit the case arms to which we jump on matching a case value.\n        for (pnodeCase = pnode->sxSwitch.pnodeCases; pnodeCase; pnodeCase = pnodeCase->sxCase.pnodeNext)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnodeCase->sxCase.labelCase);\n            Emit(pnodeCase->sxCase.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnodeCase->sxCase.pnodeBody);\n        }\n\n        EndEmitBlock(pnode->sxSwitch.pnodeBlock, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseTmpRegister(regVal);\n        funcInfo->ReleaseLoc(pnode->sxSwitch.pnodeVal);\n\n        if (!fHasDefault || pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        break;\n    }\n\n    case knopTryCatch:\n    {\n        Js::ByteCodeLabel catchLabel = (Js::ByteCodeLabel) - 1;\n\n        ParseNode *pnodeTry = pnode->sxTryCatch.pnodeTry;\n        Assert(pnodeTry);\n        ParseNode *pnodeCatch = pnode->sxTryCatch.pnodeCatch;\n        Assert(pnodeCatch);\n\n        catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n        // Note: try uses OpCode::Leave which causes a return to parent interpreter thunk,\n        // same for catch block. Thus record cross interpreter frame entry/exit records for them.\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n        ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n        }\n\n        Emit(pnodeTry->sxTry.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeTry->sxTry.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->Br(pnode->sxStmt.breakLabel);\n        byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n        Assert(pnodeCatch->sxCatch.pnodeParam);\n        ParseNode *pnodeObj = pnodeCatch->sxCatch.pnodeParam;\n        Js::RegSlot location;\n\n        bool acquiredTempLocation = false;\n\n        Js::DebuggerScope *debuggerScope = nullptr;\n        Js::DebuggerScopePropertyFlags debuggerPropertyFlags = Js::DebuggerScopePropertyFlags_CatchObject;\n\n        bool isPattern = pnodeObj->nop == knopParamPattern;\n\n        if (isPattern)\n        {\n            location = pnodeObj->sxParamPattern.location;\n        }\n        else\n        {\n            location = pnodeObj->sxPid.sym->GetLocation();\n        }\n\n        if (location == Js::Constants::NoRegister)\n        {\n            location = funcInfo->AcquireLoc(pnodeObj);\n            acquiredTempLocation = true;\n        }\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, location);\n\n        Scope *scope = pnodeCatch->sxCatch.scope;\n        byteCodeGenerator->PushScope(scope);\n\n        if (scope->GetMustInstantiate())\n        {\n            Assert(scope->GetLocation() == Js::Constants::NoRegister);\n            if (scope->GetIsObject())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeInObject, funcInfo->InnerScopeToRegSlot(scope));\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::NewPseudoScope, scope->GetInnerScopeIndex());\n            }\n            else\n            {\n\n                int index = Js::DebuggerScope::InvalidScopeIndex;\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeInSlot, funcInfo->InnerScopeToRegSlot(scope), &index);\n                byteCodeGenerator->Writer()->Num3(Js::OpCode::NewInnerScopeSlots, scope->GetInnerScopeIndex(), scope->GetScopeSlotCount() + Js::ScopeSlots::FirstSlotIndex, index);\n            }\n        }\n        else\n        {\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeDirect, location);\n        }\n\n        auto ParamTrackAndInitialization = [&](Symbol *sym, bool initializeParam, Js::RegSlot location)\n        {\n            if (sym->IsInSlot(funcInfo))\n            {\n                Assert(scope->GetMustInstantiate());\n                if (scope->GetIsObject())\n                {\n                    Js::OpCode op = (sym->GetDecl()->nop == knopLetDecl) ? Js::OpCode::InitUndeclLetFld :\n                        byteCodeGenerator->GetInitFldOp(scope, scope->GetLocation(), funcInfo, false);\n\n                    Js::PropertyId propertyId = sym->EnsurePosition(byteCodeGenerator);\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n                    byteCodeGenerator->Writer()->ElementPIndexed(op, location, scope->GetInnerScopeIndex(), cacheId);\n\n                    byteCodeGenerator->TrackActivationObjectPropertyForDebugger(debuggerScope, sym, debuggerPropertyFlags);\n                }\n                else\n                {\n                    byteCodeGenerator->TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(byteCodeGenerator), debuggerPropertyFlags);\n                    if (initializeParam)\n                    {\n                        byteCodeGenerator->EmitLocalPropInit(location, sym, funcInfo);\n                    }\n                    else\n                    {\n                        Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n                        byteCodeGenerator->Writer()->Reg1(Js::OpCode::InitUndecl, tmpReg);\n                        byteCodeGenerator->EmitLocalPropInit(tmpReg, sym, funcInfo);\n                        funcInfo->ReleaseTmpRegister(tmpReg);\n                    }\n                }\n            }\n            else\n            {\n                byteCodeGenerator->TrackRegisterPropertyForDebugger(debuggerScope, sym, funcInfo, debuggerPropertyFlags);\n                if (initializeParam)\n                {\n                    byteCodeGenerator->EmitLocalPropInit(location, sym, funcInfo);\n                }\n                else\n                {\n                    byteCodeGenerator->Writer()->Reg1(Js::OpCode::InitUndecl, location);\n                }\n            }\n        };\n\n        if (isPattern)\n        {\n            Parser::MapBindIdentifier(pnodeObj->sxParamPattern.pnode1, [&](ParseNodePtr item)\n            {\n                Js::RegSlot itemLocation = item->sxVar.sym->GetLocation();\n                if (itemLocation == Js::Constants::NoRegister)\n                {\n                    // The var has no assigned register, meaning it's captured, so we have no reg to write to.\n                    // Emit the designated return reg in the byte code to avoid asserting on bad register.\n                    itemLocation = ByteCodeGenerator::ReturnRegister;\n                }\n                ParamTrackAndInitialization(item->sxVar.sym, false /*initializeParam*/, itemLocation);\n            });\n            byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n            // Now emitting bytecode for destructuring pattern\n            byteCodeGenerator->StartStatement(pnodeCatch);\n            ParseNodePtr pnode1 = pnodeObj->sxParamPattern.pnode1;\n            Assert(pnode1->IsPattern());\n            EmitAssignment(nullptr, pnode1, location, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->EndStatement(pnodeCatch);\n        }\n        else\n        {\n            ParamTrackAndInitialization(pnodeObj->sxPid.sym, true /*initializeParam*/, location);\n            if (scope->GetMustInstantiate())\n            {\n                pnodeObj->sxPid.sym->SetIsGlobalCatch(true);\n            }\n            byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n            // Allow a debugger to stop on the 'catch (e)'\n            byteCodeGenerator->StartStatement(pnodeCatch);\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Nop);\n            byteCodeGenerator->EndStatement(pnodeCatch);\n        }\n\n        ByteCodeGenerator::TryScopeRecord tryRecForCatch(Js::OpCode::ResumeCatch, catchLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForCatch);\n        }\n\n        Emit(pnodeCatch->sxCatch.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->PopScope();\n\n        byteCodeGenerator->RecordEndScopeObject(pnode);\n\n        funcInfo->ReleaseLoc(pnodeCatch->sxCatch.pnodeBody);\n\n        if (acquiredTempLocation)\n        {\n            funcInfo->ReleaseLoc(pnodeObj);\n        }\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        break;\n    }\n\n    case knopTryFinally:\n    {\n        Js::ByteCodeLabel finallyLabel = (Js::ByteCodeLabel) - 1;\n\n        ParseNode *pnodeTry = pnode->sxTryFinally.pnodeTry;\n        Assert(pnodeTry);\n        ParseNode *pnodeFinally = pnode->sxTryFinally.pnodeFinally;\n        Assert(pnodeFinally);\n\n        // If we yield from the finally block after an exception, we have to store the exception object for the future next call.\n        // When we yield from the Try-Finally the offset to the end of the Try block is needed for the branch instruction.\n        Js::RegSlot regException = Js::Constants::NoRegister;\n        Js::RegSlot regOffset = Js::Constants::NoRegister;\n\n        finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n        // [CONSIDER][aneeshd] Ideally the TryFinallyWithYield opcode needs to be used only if there is a yield expression.\n        // For now, if the function is generator we are using the TryFinallyWithYield.\n        ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryFinallyWithYield, finallyLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            regException = funcInfo->AcquireTmpRegister();\n            regOffset = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n            tryRecForTry.reg1 = regException;\n            tryRecForTry.reg2 = regOffset;\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n        }\n\n        // Increasing the stack as we will be storing the additional values when we enter try..finally.\n        funcInfo->StartRecordingOutArgs(1);\n\n        Emit(pnodeTry->sxTry.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeTry->sxTry.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        // Note: although we don't use OpCode::Leave for finally block,\n        // OpCode::LeaveNull causes a return to parent interpreter thunk.\n        // This has to be on offset prior to offset of 1st statement of finally.\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n        byteCodeGenerator->Writer()->Br(pnode->sxStmt.breakLabel);\n        byteCodeGenerator->Writer()->MarkLabel(finallyLabel);\n\n        ByteCodeGenerator::TryScopeRecord tryRecForFinally(Js::OpCode::ResumeFinally, finallyLabel, regException, regOffset);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForFinally);\n        }\n\n        Emit(pnodeFinally->sxFinally.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeFinally->sxFinally.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n            funcInfo->ReleaseTmpRegister(regOffset);\n            funcInfo->ReleaseTmpRegister(regException);\n        }\n\n        funcInfo->EndRecordingOutArgs(1);\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::LeaveNull);\n\n        byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        break;\n    }\n    case knopThrow:\n        byteCodeGenerator->StartStatement(pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::Throw, pnode->sxUni.pnode1->location);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopYieldLeaf:\n        byteCodeGenerator->StartStatement(pnode);\n        funcInfo->AcquireLoc(pnode);\n        EmitYield(funcInfo->undefinedConstantRegister, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopAwait:\n    case knopYield:\n        byteCodeGenerator->StartStatement(pnode);\n        funcInfo->AcquireLoc(pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        EmitYield(pnode->sxUni.pnode1->location, pnode->location, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopYieldStar:\n        byteCodeGenerator->StartStatement(pnode);\n        EmitYieldStar(pnode, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopExportDefault:\n        Emit(pnode->sxExportDefault.pnodeExpr, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->EmitAssignmentToDefaultModuleExport(pnode->sxExportDefault.pnodeExpr, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxExportDefault.pnodeExpr);\n        pnode = pnode->sxExportDefault.pnodeExpr;\n        break;\n    default:\n        AssertMsg(0, \"emit unhandled pnode op\");\n        break;\n    }\n\n    if (fReturnValue && IsExpressionStatement(pnode, byteCodeGenerator->GetScriptContext()))\n    {\n        // If this statement may produce the global function's return value, copy its result to the return register.\n        // fReturnValue implies global function, which implies that \"return\" is a parse error.\n        Assert(funcInfo->IsGlobalFunction());\n        Assert(pnode->nop != knopReturn);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, pnode->location);\n    }\n}\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\nWScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");\n\nvar tests = [\n  { \n    name: \"Split parameter scope in function definition\", \n    body: function () { \n        function f1(a = 10, b = function () { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Function defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f2(a = 10, b = function () { return a; }, c = b() + a) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            assert.areEqual(20, c, \"Initial value of the third parameter in the body scope should be twice the value of the first parameter\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f2()(), \"Function defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f3(a = 10, b = function () { return a; }) { \n            assert.areEqual(1, a, \"Initial value of parameter in the body scope should be the same as the one passed in\"); \n            var a = 20; \n            assert.areEqual(20, a, \"Assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(f3(1)(), 1, \"Function defined in the param scope captures the formals from the param scope even when the default expression is not applied for that param\"); \n\n        (function (a = 10, b = a += 10, c = function () { return a + b; }) { \n            assert.areEqual(20, a, \"Initial value of parameter in the body scope should be same as the corresponding symbol's final value in the param scope\"); \n            var a2 = 40; \n            (function () { assert.areEqual(40, a2, \"Symbols defined in the body scope should be unaffected by the duplicate formal symbols\"); })(); \n            assert.areEqual(40, c(), \"Function defined in param scope uses the formals from param scope even when executed inside the body\"); \n        })(); \n\n        (function (a = 10, b = function () { assert.areEqual(10, a, \"Function defined in the param scope captures the formals from the param scope when executed from the param scope\"); }, c = b()) { \n        })(); \n\n        function f4(a = 10, b = function () { return a; }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f4()(), \"Even if the formals are not redeclared in the function body the symbol in the param scope and body scope are different\"); \n\n        function f5(a = 10, b = function () { return function () { return a; }; }) { \n            var a = 20; \n            return b; \n        } \n        assert.areEqual(10, f5()()(), \"Parameter scope works fine with nested functions\"); \n\n        var a1 = 10; \n        function f6(a, b = function () { a; return a1; }) { \n            assert.areEqual(undefined, a1, \"Inside the function body the assignment hasn't happened yet\"); \n            var a1 = 20; \n            assert.areEqual(20, a1, \"Assignment to the symbol inside the function changes the value\"); \n            return b; \n        } \n        assert.areEqual(10, f6()(), \"Function in the param scope correctly binds to the outer variable\"); \n         \n        function f7(a = 10, b = { iFnc () { return a; } }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f7().iFnc(), \"Function definition inside the object literal should capture the formal from the param scope\");\n        \n        var f8 = function (a, b = ((function() { assert.areEqual('string1', a, \"First arguemnt receives the right value\"); })(), 1), c) {\n            var d = 'string3';\n            (function () { assert.areEqual('string3', d, \"Var declaration in the body is initialized properly\"); })();\n            return c;\n        };\n\n        assert.areEqual('string2', f8('string1', undefined, 'string2'), \"Function returns the third argument properly\");\n        \n        function f9() {\n            var f10 = function (a = function () { c; }, b, c) {\n                assert.areEqual(1, c, \"Third argument is properly populated\");\n                arguments;\n                function f11() {};\n            };\n            f10(undefined, undefined, 1);\n        }\n        f9();\n        f9();\n        \n        function f12() {\n            var result = ((a = (w = a => a * a) => w) => a)()()(10); \n            \n            assert.areEqual(100, result, \"The inner lambda function properly maps to the right symbol for a\");\n        };\n        f12();\n    } \n }, \n { \n    name: \"Split parameter scope and function expressions with name\", \n    body: function () { \n        function f1(a = 10, b = function c() { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope of the method should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope of the method updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Function expression defined in the param scope captures the formals from the param scope not body scope\"); \n         \n        function f2(a = 10, b = function c(recurse = true) { return recurse ? c(false) : a; }) { \n            return b; \n        } \n        assert.areEqual(10, f2()(), \"Recursive function expression defined in the param scope captures the formals from the param scope not body scope\");\n        \n        assert.areEqual(10, f2()(), \"Recursive function expression defined in the param scope captures the formals from the param scope not body scope\");\n\n        var f3 = function f4 (a = function ( ) { b; return f4(20); }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f3()(), \"Recursive call to the function from the param scope returns the right value\");\n\n        var f5 = function f6 (a = function ( ) { b; return f6; }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f5()()(20), \"Recursive call to the function from the param scope returns the right value\");\n        \n        var f7 = function f8 (a = function ( ) { b; }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            var a = function () { return f8(20); };\n            return a;\n        }\n        assert.areEqual(10, f7()(), \"Recursive call to the function from the body scope returns the right value\");\n        \n        var f9 = function f10 (a = function ( ) { b; return f10(20); }, b) {\n            eval(\"\");\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f9()(), \"Recursive call to the function from the param scope returns the right value when eval is there in the body\");\n        \n        var f11 = function f12 (a = function ( ) { b; }, b) {\n            eval(\"\");\n            if (a == 20) {\n                return 10;\n            }\n            var a = function () { return f12(20); };\n            return a;\n        }\n        assert.areEqual(10, f11()(), \"Recursive call to the function from the body scope returns the right value when eval is there in the body\");\n    } \n }, \n { \n    name: \"Split parameter scope in member functions\", \n    body: function () { \n       var o1 = { \n           f(a = 10, b = function () { return a; }) { \n               assert.areEqual(10, a, \"Initial value of parameter in the body scope of the method should be the same as the one in param scope\"); \n               var a = 20; \n               assert.areEqual(20, a, \"New assignment in the body scope of the method updates the variable's value in body scope\"); \n                return b; \n            } \n        } \n        assert.areEqual(o1.f()(), 10, \"Function defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n         \n        var o2 = { \n            f1(a = 10, b = function () { return { f2 () { return a; } } }) { \n                var a = 20; \n                c = function () { return { f2 () { return a; } } }; \n                return [b, c]; \n            } \n        } \n        var result = o2.f1(); \n        assert.areEqual(10, result[0]().f2(), \"Short hand method defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n        assert.areEqual(20, result[1]().f2(), \"Short hand method defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n    } \n  },\n  { \n    name: \"Arrow functions in split param scope\", \n    body: function () { \n        function f1(a = 10, b = () => { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f2(a = 10, b = () => { return a; }) { \n            assert.areEqual(1, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(1, f2(1)(), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope even when value is passed\"); \n\n        function f3(a = 10, b = () => a) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f3()(), \"Arrow functions with concise body defined in the param scope captures the formals from the param scope not body scope\"); \n\n        ((a = 10, b = a += 10, c = () => { assert.areEqual(20, a, \"Value of the first formal inside the lambda should be same as the default value\"); return a + b; }, d = c() * 10) => { \n            assert.areEqual(d, 400, \"Initial value of the formal parameter inside the body should be the same as final value from the param scope\"); \n        })(); \n\n        function f4(a = 10, b = () => { return () => a; }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f4()()(), \"Nested lambda should capture the formal param value from the param scope\"); \n\n        assert.throws(function f4(a = () => x) { var x = 1; a(); }, ReferenceError, \"Lambdas in param scope shouldn't be able to access the variables from body\", \"'x' is undefined\"); \n        assert.throws(function f5() { (function (a = () => x) { var x = 1; return a; })()(); }, ReferenceError, \"Lambdas in param scope shouldn't be able to access the variables from body\", \"'x' is undefined\"); \n        assert.throws((a = () => 10, b = a() + c, c = 10) => {}, ReferenceError, \"Formals defined to the right shouldn't be usable in lambdas\", \"Use before declaration\"); \n    } \n  },\n  { \n    name: \"Split parameter scope with Rest\", \n    body: function () { \n        var arr = [2, 3, 4]; \n        function f1(a = 10, b = function () { return a; }, ...c) { \n            assert.areEqual(arr.length, c.length, \"Rest parameter should contain the same number of elements as the spread arg\"); \n            for (i = 0; i < arr.length; i++) { \n                assert.areEqual(arr[i], c[i], \"Elements in the rest and the spread should be in the same order\"); \n            } \n            return b; \n        } \n        assert.areEqual(f1(undefined, undefined, ...arr)(), 10, \"Presence of rest parameter shouldn't affect the binding\"); \n\n        ((a = 10, b = () => a, ...c) => { \n            assert.areEqual(arr.length, c.length, \"Rest parameter should contain the same number of elements as the spread arg\"); \n            for (i = 0; i < arr.length; i++) { \n                assert.areEqual(arr[i], c[i], \"Elements in the rest and the spread should be in the same order\"); \n            } \n            return b; \n        })(undefined, undefined, ...arr); \n    } \n  },\n  { \n    name: \"Split parameter scope with this\", \n    body: function () { \n        function f1(a = this.x, b = function() { assert.areEqual(100, this.x, \"this object for the function in param scope is passed from the final call site\"); return a; }) { \n            assert.areEqual(10, this.x, \"this objects property retains the value from param scope\"); \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f1.call({x : 10}).call({x : 100}), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope\"); \n         \n        (function (a = this.x, b = function() {this.x = 20; return a;}) { \n            assert.areEqual(10, this.x, \"this objects property retains the value in param scope before the inner function call\"); \n            b.call(this); \n            assert.areEqual(20, this.x, \"Update to a this's property from the param scope is reflected in the body scope\"); \n        }).call({x : 10}); \n         \n        this.x = 10; \n        ((a = this.x, b = function() { a; this.x = 20; }) => { \n            assert.areEqual(10, this.x, \"this objects property retains the value in param scope before the inner function call in lambda\"); \n            b.call(this); \n            assert.areEqual(20, this.x, \"Update to a this's property from the param scope of lambda function is reflected in the body scope\"); \n        })(); \n         \n        function f2(a = function() { return this.x; }, b = this.y, c = a.call({x : 20}) + b) { \n            assert.areEqual(undefined, this.x, \"this object remains unaffected\"); \n            return c; \n        } \n        assert.areEqual(30, f2.call({y : 10}), \"Properties are accessed from the right this object\"); \n\n        var thisObj = {x : 1, y : 20 };\n        function f3(a, b = () => { a; this.x = 10; return this.y; }) {\n            assert.areEqual(1, this.x, \"Assignment from the param scope has not happened yet\");\n            assert.areEqual(20, this.y, \"y property of the this object is not affected\");\n            return b; \n        } \n        assert.areEqual(20, f3.call(thisObj)(), \"Lambda defined in the param scope returns the right property value from thisObj\"); \n        assert.areEqual(10, thisObj.x, \"Assignment from the param scope method updates thisObj's property\"); \n\n        function f4(a, b = () => { a; return this; }) {\n            return b;\n        }\n        assert.areEqual(thisObj, f4.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\"); \n        \n        var thisObj = { x : 1 };\n        function f5() {\n            return (a = this, b = function() { return a; }) => b;\n        }\n        assert.areEqual(thisObj, f5.call(thisObj)()(), \"This object is returned properly from the inner lambda method's child function\");\n\n        function f6(a, b = function () { return a; }) {\n            return (a = this, b = function() { return a; }) => b;\n        }\n        assert.areEqual(thisObj, f6.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a split scoped function\");\n\n        function f7(a, b = function () { return a; }) {\n            function f8() {\n                return (a = this, b = function() { return a; }) => b;\n            }\n            return f8.call(this);\n        }\n        assert.areEqual(thisObj, f7.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a nested split scoped function\");\n\n        function f9(a, b = function () { return a; }) {\n            function f10(c, d = function () { c; }) {\n                return (a = this, b = function() { return a; }) => b;\n            }\n            return f10.call(this);\n        }\n        assert.areEqual(thisObj, f9.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a double nested split scoped function\");\n        \n        function f11(a = this.x * 10, b = () => { a; return this; }) {\n            assert.areEqual(10, a, \"this should be accessible in the parameter scope\");\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            assert.isTrue(eval(\"thisObj == this\"), \"Eval should be able to access the this object properly\");\n            return b;\n        }\n        assert.areEqual(thisObj, f11.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\"); \n\n        function f12(a = this.x * 10, b = () => { a; return this; }) {\n            var c = 100;\n            assert.areEqual(10, a, \"this should be accessible in the parameter scope\");\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            assert.isTrue(eval(\"thisObj == this\"), \"Eval should be able to access the this object properly\");\n            assert.areEqual(thisObj, (() => this)(), \"Lambda should capture the this object from body properly\");\n            assert.areEqual(100, c, \"Body variable should be unaffected by the slot allocation of this object\");\n            return b;\n        }\n        assert.areEqual(thisObj, f12.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\");\n\n        function f13(a = 10, b = () => { a; return this; }) {\n            var c = 100;\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            var d = () => this;\n            this.x = 5;\n            assert.isTrue(eval(\"this.x == 5\"), \"Eval should be able to access the this object properly after the field is updated\");\n            assert.isTrue(eval(\"d().x == 5\"), \"Lambda should capture the this symbol from the body properly\");\n            assert.isTrue(eval(\"a == 10\"), \"Eval should be able to access the first parameter properly\");\n            assert.isTrue(eval(\"b().x == 5\"), \"Lambda from the param scope should capture the this symbol properly\");\n            assert.isTrue(eval(\"d().x == 5\"), \"Lambda should capture the this symbol from the body properly\");\n            return b;\n        }\n        assert.areEqual(5, f13.call(thisObj)().x, \"Lambda defined in the param scope returns the same this object as the one in body\"); \n    } \n  },\n  { \n    name: \"Split parameter scope and class\", \n    body: function () { \n        class c { \n            f(a = 10, d, b = function () { return a; }, c) { \n                assert.areEqual(10, a, \"Initial value of parameter in the body scope in class method should be the same as the one in param scope\"); \n                var a = 20; \n                assert.areEqual(20, a, \"Assignment in the class method body updates the value of the variable\"); \n                return b; \n            } \n        } \n        assert.areEqual(10, (new c()).f()(), \"Method defined in the param scope of the class should capture the formal from the param scope itself\"); \n\n        function f1(a = 10, d, b = class { method1() { return a; } }, c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        var result = f1(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined in param scope should capture the formals form that param scope itself\"); \n\n        class c2 { \n            f1(a = 10, d, b = function () { a = this.f2(); return a; }, c) { \n                assert.areEqual(30, this.f2(), \"this object in the body points to the right this object\"); \n                return b; \n            }; \n            f2() { \n                return 30; \n            } \n        } \n        var f2Obj = new c2(); \n        assert.areEqual(100, f2Obj.f1().call({f2() { return 100; }}), \"Method defined in the param uses its own this object while updating the formal\"); \n\n        function f2(a = 10, d, b = class { method1() { return class { method2() { return a; }} } }, c) { \n            a = 20; \n            return b; \n        } \n        var obj1 = f2(); \n        var obj2 = (new obj1()).method1(); \n        assert.areEqual(10, (new obj2()).method2(), \"Nested class definition in the param scope should capture the formals from the param scope\"); \n\n        var actualArray = [2, 3, 4]; \n        class c3 { \n            f(a = 10, b = () => { return c; }, ...c) { \n                assert.areEqual(actualArray.length, c.length, \"Rest param and the actual array should have the same length\"); \n                for (var i = 0; i < c.length; i++) { \n                    assert.areEqual(actualArray[i], c[i], \"Rest parameter should have the same value as the actual array\"); \n                } \n                c = []; \n                return b; \n            } \n        } \n        result = (new c3()).f(undefined, undefined, ...[2, 3, 4])(); \n        assert.areEqual(actualArray.length, result.length, \"The result and the actual array should have the same length\"); \n        for (var i = 0; i < result.length; i++) { \n            assert.areEqual(actualArray[i], result[i], \"The result array should have the same value as the actual array\"); \n        } \n\n        class c4 { \n            f({x:x = 10, y:y = () => { return x; }}) { \n                assert.areEqual(10, x, \"Initial value of destructure parameter in the body scope in class method should be the same as the one in param scope\"); \n                x = 20; \n                assert.areEqual(20, x, \"Assignment in the class method body updates the value of the variable\"); \n                return y; \n            } \n        } \n        assert.areEqual(10, (new c4()).f({})(), \"The method defined as the default destructured value of the parameter should capture the formal from the param scope\");\n        \n        function f3(a = 10, d, b = (function () { return a; }, class { method1() { return a; } }), c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        result = f3(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after another function definition, in the param scope should capture the formals form that param scope itself\"); \n        \n        function f4(a = 10, d, b = (function () { return a; }, class {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f4(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after another class definition, in the param scope should capture the formals form that param scope itself\");\n         \n        function f5(a = 10, d, b = (function () { return a; }, class {}, function () {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f5(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after a function and class, in the param scope should capture the formals form that param scope itself\");\n        \n        function f6(a = 10, d, b = (function () { return a; }, class {}, function (a, b = () => a) {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f6(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after a split scope function, in the param scope should capture the formals form that param scope itself\");\n        \n        function f7(a = 10, d, b = (function () { return a; }, class c1 { method1() { return a; } }), c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        result = f7(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class with name defined, after another function definition, in the param scope should capture the formals form that param scope itself\");\n        \n        function f8(a = 10, d, b = class c1 { method1() { return a; } }, c = (function () { return a; }, class c2 extends b { method2() { return a * a; } })) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return c; \n        } \n        result = f8(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class extending another class defined, after another function definition, in the param scope should capture the formals form that param scope itself\");\n        assert.areEqual(100, (new result()).method2(), \"Method in the derived class returns the right value\");\n    } \n  },\n  { \n    name: \"Split parameter scope in generator methods\", \n    body: function () { \n        function *f1(a = 10, d, b = function () { return a; }, c) { \n            yield a; \n            var a = 20; \n            yield a; \n            yield b; \n        } \n        var f1Obj = f1(); \n        assert.areEqual(10, f1Obj.next().value, \"Initial value of the parameter in the body scope should be the same as the final value of the parameter in param scope\"); \n        assert.areEqual(20, f1Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(10, f1Obj.next().value(), \"Function defined in the param scope captures the formal from the param scope itself\"); \n\n        function *f2(a = 10, d, b = function () { return a; }, c) { \n            yield a; \n            a = 20; \n            yield a; \n            yield b; \n        } \n        var f2Obj = f2(); \n        assert.areEqual(10, f2Obj.next().value, \"Initial value of the parameter in the body scope should be the same as the final value of the parameter in param scope\"); \n        assert.areEqual(20, f2Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(10, f2Obj.next().value(), \"Function defined in the param scope captures the formal from the param scope itself even if it is not redeclared in the body\"); \n\n        function *f3(a = 10, d, b = function *() { yield a + c; }, c = 100) { \n            a = 20; \n            yield a; \n            yield b; \n        } \n        var f3Obj = f3(); \n        assert.areEqual(20, f3Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(110, f3Obj.next().value().next().value, \"Function defined in the param scope captures the formals from the param scope\"); \n\n        function *f4(a = 10, d, b = function *() { yield a; }, c) { \n            var a = 20; \n            yield function *() { yield a; }; \n            yield b; \n        } \n        var f4Obj = f4(); \n        assert.areEqual(20, f4Obj.next().value().next().value, \"Generator defined inside the body captures the symbol from the body scope\"); \n        assert.areEqual(10, f4Obj.next().value().next().value, \"Function defined in the param scope captures the formal from param scope even if it is captured in the body scope\"); \n    } \n  },\n  { \n    name: \"Split parameter scope with destructuring\", \n    body: function () { \n        function f1( {a:a1, b:b1}, c = function() { return a1 + b1; } ) { \n            assert.areEqual(10, a1, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            assert.areEqual(20, b1, \"Initial value of the second destructuring parameter in the body scope should be the same as the one in param scope\"); \n            a1 = 1; \n            b1 = 2; \n            assert.areEqual(1, a1, \"New assignment in the body scope updates the first formal's value in body scope\"); \n            assert.areEqual(2, b1, \"New assignment in the body scope updates the second formal's value in body scope\"); \n            assert.areEqual(30, c(), \"The param scope method should return the sum of the destructured formals from the param scope\"); \n            return c; \n        } \n        assert.areEqual(30, f1({ a : 10, b : 20 })(), \"Returned method should return the sum of the destructured formals from the param scope\"); \n\n        function f2({x:x = 10, y:y = function () { return x; }}) { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(20, x, \"Assignment in the body updates the formal's value\"); \n            return y; \n        } \n        assert.areEqual(10, f2({ })(), \"Returned method should return the value of the destructured formal from the param scope\"); \n         \n        function f3({y:y = function () { return x; }, x:x = 10}) { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(20, x, \"Assignment in the body updates the formal's value\"); \n            return y; \n        } \n        assert.areEqual(10, f3({ })(), \"Returned method should return the value of the destructured formal from the param scope even if declared after\"); \n         \n        (({x:x = 10, y:y = function () { return x; }}) => { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(10, y(), \"Assignment in the body does not affect the formal captured from the param scope\"); \n        })({}); \n    } \n  },\n  { \n    name: \"Nested split scopes\", \n    body: function () { \n          function f1(a = 10, b = function () { return a; }, c) { \n              function iFnc(d = 100, e = 200, pf1 = function () { return d + e; }) { \n                  d = 1000; \n                  e = 2000; \n                  pf2 = function () { return d + e; }; \n                  return [pf1, pf2]; \n              } \n              return [b].concat(iFnc()); \n          } \n          var result = f1(); \n          assert.areEqual(10, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope\"); \n          assert.areEqual(300, result[1](), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope\"); \n          assert.areEqual(3000, result[2](), \"Function defined in the body scope of the inner function should capture the symbols from its body scope\"); \n\n          function f2(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              c = 2000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc()]; \n          } \n          result = f2(); \n          assert.areEqual(10, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope even if formals are with the same name in inner function\"); \n          assert.areEqual(300, result[1](), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope  if formals are with the same name in the outer function\"); \n\n          function f3(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              c = 2000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc]; \n          } \n          assert.areEqual(300, f3()[1]()(), \"Function defined in the param scope of the inner function should capture the right formals even if the inner function is executed outside\"); \n\n          function f4(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc(undefined, b, c)]; \n          } \n          result = f4(1, undefined, 3); \n          assert.areEqual(1, result[0](), \"Function defined in the param scope of the outer function correctly captures the passed in value for the formal\"); \n          assert.areEqual(1, result[1](), \"Function defined in the param scope of the inner function is replaced by the function definition from the param scope of the outer function\"); \n\n          function f5(a = 10, b = function () { return a; }, c) { \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc(a, undefined, c)]; \n          } \n          result = f5(1, undefined, 3); \n          assert.areEqual(1, result[0](), \"Function defined in the param scope of the outer function correctly captures the passed in value for the formal\"); \n          assert.areEqual(4, result[1](), \"Function defined in the param scope of the inner function captures the passed values for the formals\"); \n\n          function f6(a , b, c) { \n              function iFnc(a = 1, b = function () { return a + c; }, c = 2) { \n                  a = 10; \n                  c = 20; \n                  return b; \n              } \n              return iFnc; \n          } \n          assert.areEqual(3, f6()()(), \"Function defined in the param scope captures the formals when defined inside another method without split scope\"); \n\n          function f7(a = 10 , b = 20, c = function () { return a + b; }) { \n              return (function () { \n                  function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                      a = 1000; \n                      c = 2000; \n                      return b; \n                  } \n                  return [c, iFnc]; \n              })(); \n          } \n          result = f7(); \n          assert.areEqual(30, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope even in nested case\"); \n          assert.areEqual(300, result[1]()(), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope even when nested inside a normal method and a split scope\"); \n\n          function f8(a = 1, b = function (d = 10, e = function () { return a + d; }) { assert.areEqual(d, 10, \"Split scope function defined in param scope should capture the right formal value\"); d = 20; return e; }, c) { \n              a = 2; \n              return b; \n          } \n          assert.areEqual(11, f8()()(), \"Split scope function defined within the param scope should capture the formals from the corresponding param scopes\"); \n\n          function f9(a = 1, b = function () { return function (d = 10, e = function () { return a + d; }) { d = 20; return e; } }, c) { \n              a = 2; \n              return b; \n          } \n          assert.areEqual(11, f9()()()(), \"Split scope function defined within the param scope should capture the formals from the corresponding param scope in nested scope\"); \n    }   \n  }, \n  {\n    name: \"Split scope with symbol shadowing\",\n    body: function () {\n          function f1(a = 10, b = function () { return a; }) {\n              assert.areEqual(100, a(), \"Function definition inside the body is hoisted\");\n              function a () {\n                  return 100;\n              }\n              return b;\n        }\n        assert.areEqual(10, f1()(), \"Function definition in the param scope captures the symbol from the param scope\");\n\n        function f2(a = 10, b = function () { return a; }, c = b) {\n            a = 20;\n            assert.areEqual(20, b(), \"Function definition in the body scope captures the body symbol\");\n            function b() {\n                return a;\n            }\n            return [c, b];\n        }\n        var result = f2();\n        assert.areEqual(10, result[0](), \"Function definition in the param scope captures the param scope symbol\");\n        assert.areEqual(20, result[1](), \"Function definition in the body captures the body symbol\");\n        \n        var g = 1;\n        function f3(a = 10, b = function () { a; return g;}) {\n            assert.areEqual(10, g(), \"Function definition inside the body is unaffected by the outer variable\");\n            function g() {\n                return 10;\n            }\n            return b;\n        }\n        assert.areEqual(1, f3()(), \"Function definition in the param scope captures the outer scoped var\");\n        \n        function f4(a = x1, b = function g() {\n            a;\n            return function h() {\n                assert.areEqual(10, x1, \"x1 is captured from the outer scope\");\n            };\n        }) {\n            var x1 = 100;\n            b()();\n        };\n        var x1 = 10;\n        f4();\n        \n        var x2 = 1;\n        function f5(a = x2, b = function() { a; return x2; }) {\n            {\n                function x2() {\n                }\n            }\n            var x2 = 2;\n            return b;\n        }\n        assert.areEqual(1, f5()(), \"Symbol capture at the param scope is unaffected by the inner definitions\");\n        \n        var x3 = 1;\n        function f6(a = x3, b = function(_x) { a; return x3; }) {\n            var x3 = 2;\n            return b;\n        }\n        assert.areEqual(1, f6()(), \"Symbol capture at the param scope is unaffected by other references in the body and param\");\n    }\n  },\n  {\n    name : \"Split scope and arguments symbol\",\n    body : function () {\n        assert.throws(function () { eval(\"function f(a = arguments, b = () => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f1() { function f2(a = arguments, b = () => a) { } }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope inside another function\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = arguments, b = () => a, c = eval('')) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with eval\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = arguments = [1, 2], b = () => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = a = arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, b = () => { a; arguments}) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list when captured in lambda method\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = (c = arguments) => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list when captured in a lambda in split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, b = () => a, c = () => { return arguments; }) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list in split scope when captured by a lambda method\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = () => () => arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, arguments = function () { return a; } ) { }\"); }, SyntaxError, \"Use of arguments as a parameter name is not allowed in non-simple parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a, arguments = function () { return a; }}) { }\"); }, SyntaxError, \"Use of arguments as a parameter name is not allowed in destructuring parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a = arguments}, b = function () { return a; } ) { }\"); }, SyntaxError, \"Use of arguments is not allowed in destructuring parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments[0]) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 1, b = () => arguments[0]) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope at any position\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments[0] + b, b = 10) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope at any position\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { var arguments }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even when duplicate definition occurs in the body\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { function arguments() { } }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even when duplicate definition occurs in the body\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(arguments, b = () => arguments) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even if it is a formal shadowing the actual arguments\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a, arguments}, b = () => a) { }\"); }, SyntaxError, \"Arguments cannot be used as a formal name when one of the formal is captured\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, {arguments, b = () => arguments}) { }\"); }, SyntaxError, \"Arguments cannot be used as a formal name when one of the formal is captured\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        \n        function f1(a, b = () => a) {\n            eval(\"\");\n            b = () => { return arguments; };\n            assert.areEqual(1, arguments[0], \"Arguments object receives the first parameter properly\");\n            assert.areEqual(1, b()[0], \"First argument receives the right value passed in\");\n            assert.areEqual(undefined, b()[1], \"Second argument receives the right value passed in\");\n            assert.areEqual(2, arguments.length, \"Arguments should have only two elements in it\");\n        }\n        f1(1, undefined);\n        \n        function f2(a, b = () => { return a; }) {\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            (() => { arguments = [3, 4]; a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f2(1, undefined, 2)(), \"Param scope method properly captures the first parameter\");\n        \n        function f3(a, b = () => { return a; }) {\n            eval(\"\");\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            (() => { arguments = [3, 4]; a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f3(1, undefined, 2)(), \"Param scope method properly captures the first parameter, with eval in the body\");\n        \n        function f4(a, b = function () { a; } ) {\n            var c = 10;\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            eval(\"\");\n        }\n        f4(1);\n        \n        function f5(a, b = function () { a; } ) {\n            var c = 10;\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            eval(\"\");\n        }\n        f5(1);\n        \n        function f6(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n        }\n        f6(1);\n        \n        function f7(a, b = function () { a; } ) {\n            assert.areEqual(5, arguments(), \"Function definition is hoisted\");\n            function arguments() { return 5; }\n        }\n        f7(1);\n        \n        function f8(a, b = function () { a; } ) {\n            assert.areEqual(5, arguments(), \"Function definition is hoisted\");\n            function arguments() { return 5; }\n            eval(\"\");\n        }\n        f8(1);\n        \n        function f9(a, b = function () { a; } ) {\n            assert.areEqual(1, eval(\"a\"), \"Eval should be able to access the first argument properly\");\n            assert.areEqual(1, eval(\"arguments[0]\"), \"Eval should be able to access the first argument properly from arguments object\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual(100, eval(\"arguments\"), \"Updated value of arguments is visible in eval\");\n            assert.areEqual(1, eval(\"a\"), \"First argument remains unchanged after the arguments are updated\");\n        }\n        f9(1);\n        \n        function f10(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n        }\n        f10(1);\n        \n        function f11(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            eval(\"\");\n        }\n        f11(1);\n        \n        function f12(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            b = () => arguments;\n            assert.areEqual(1, b()[0], \"Lambda captures the right arguments symbol\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual(100, b(), \"Lambda now gives the updated value\");\n            eval(\"\");\n        }\n        f12(1);\n        \n        function f13(a, b = () => { return a; }) {\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            ((c = arguments = [3, 4]) => { a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f13(1, undefined, 2)(), \"Param scope method properly captures the first parameter\");\n        \n        function f14(a, b = () => { return a; }) {\n            eval(\"\");\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            ((c = arguments = [3, 4]) => { a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f14(1, undefined, 2)(), \"Param scope method properly captures the first parameter, with eval in the body\");\n        \n        function f15(a, b = function () { a; }, ...c) {\n            assert.areEqual(1, arguments[0], \"Checking first argument\");\n            assert.areEqual(undefined, arguments[1], \"Checking second argument\");\n            assert.areEqual(2, arguments[2], \"Checking third argument\");\n            assert.areEqual(3, arguments[3], \"Checking fourth argument\");\n            assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual([2, 3], c, \"Rest should remain unaffected when arguments is updated\");\n            eval(\"\");\n        }\n        f15(1, undefined, 2, 3);\n        \n        var f16 = function f17(a, b = function () { a; }, ...c) {\n            if (a === 1) {\n                assert.areEqual(1, arguments[0], \"Checking first argument\");\n                assert.areEqual(undefined, arguments[1], \"Checking second argument\");\n                assert.areEqual(2, arguments[2], \"Checking third argument\");\n                assert.areEqual(3, arguments[3], \"Checking fourth argument\");\n                assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n                return f17(undefined, undefined, ...c);\n            } else {\n                assert.areEqual(undefined, arguments[0], \"Checking first argument on the recursive call\");\n                assert.areEqual(undefined, arguments[1], \"Checking second argument on the recursive call\");\n                assert.areEqual(2, arguments[2], \"Checking third argument on the recursive call\");\n                assert.areEqual(3, arguments[3], \"Checking fourth argument on the recursive call\");\n                assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n                var arguments = 100;\n                assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n                assert.areEqual([2, 3], c, \"Rest should remain unaffected when arguments is updated\");\n                return eval(\"c\");\n            }\n        }\n        assert.areEqual([2, 3], f16(1, undefined, 2, 3), \"Rest should remain unaffected when arguments is updated\");\n\n        function f18(a, b = function arguments(c) {\n            if (!c) {\n                return arguments.callee(a, 10, 20);\n            }\n            return arguments;\n        }) {\n            assert.areEqual(10, b()[1], \"Function defined in the param scope can be called recursively\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol is unaffected by the function expression\");\n        }\n        f18(1);\n\n        function f19(a, b = arguments) {\n            var c = function arguments(c) {\n                if (!arguments.length) {\n                    return arguments.callee(a, 10, 20, 30);\n                }\n                return arguments;\n            }\n            assert.areEqual(30, c()[3], \"In the function body the arguments function expression with name is not visible\");\n            assert.areEqual(1, b[0], \"In the param scope arguments symbol referes to the passed in values\");\n        }\n        f19(1, undefined, 2, 3, 4);\n\n        function f20(a, b = function arguments(c) {\n            if (!c) {\n                return arguments.callee(a, 10, 20);\n            }\n            return eval(\"arguments\");\n        }) {\n            assert.areEqual(1, b()[0], \"Function defined in the param scope can be called recursively when eval occurs in its body\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol is unaffected by the function expression\");\n        }\n        f20(1);\n\n        function f21(a, b = arguments) {\n            var c = function arguments(c) {\n                if (!arguments.length) {\n                    return arguments.callee(a, 10, 20, 30);\n                }\n                return arguments;\n            }\n            assert.areEqual(30, c()[3], \"In the function body the arguments function expression with name is not visible when eval is there in the body\");\n            assert.areEqual(3, eval(\"b[3]\"), \"In the param scope arguments symbol referes to the passed in values\");\n        }\n        f21(1, undefined, 2, 3, 4);\n\n        function f22(a, b = () => a) {\n            assert.areEqual(1, arguments[0], \"Function in block causes a var declaration to be hoisted and the initial value should be same as the arguments symbol\");\n            {\n                {\n                    function arguments() {\n                        return 10;\n                    }\n                }\n            }\n            assert.areEqual(1, b(), \"Function defined in the param scope should be able to capture the formal even when arguments in overwritten the body\");\n            assert.areEqual(10, arguments(), \"Hoisted var binding is updated after the block is exected\");\n        }\n        f22(1);\n\n        function f23(a, b = () => a) {\n            function f16() {\n                eval(\"\");\n                this.arguments = 1;\n            }\n\n            a = 10;\n            var obj = new f16();\n            \n            function arguments() {\n                return 10;\n            }\n            assert.areEqual(1, obj.arguments, \"Inner function with eval should add the property named arguments when duplicate arguments definition occurs in the parent body\");\n            assert.areEqual(1, b(), \"Formal captured from the param scope should be constrained to the param scope\");\n        };\n        f23(1);\n    }  \n  },\n  {\n    name: \"Split scope and super call\",\n    body: function () {\n        class c1 {\n            constructor() {\n                return { x : 1 };\n            }\n        };\n\n        class c2 extends c1 {\n            constructor(a = 1, b = () => { assert.areEqual(1, super().x, \"Super is accessible in the param scope\"); return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                return {};\n            }\n        }\n        new c2();\n\n        class c3 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                (() => assert.areEqual(1, super().x, \"Lambda should be able to access the super method properly in the body\"))();\n                a = 10;\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c3();\n\n        class c4 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                assert.areEqual(1, eval(\"super().x\"), \"Eval should be able to access the super property properly\");\n            }\n        }\n        new c4();\n\n        class c5 extends c1 {\n            constructor(a = super().x, b = () => { return a; }) {\n                assert.areEqual(1, a, \"First formal calls the super from the param scope\");\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c5();\n    }\n  },\n  {\n    name: \"Split scope and super property\",\n    body: function () {\n        class c1 {\n            foo () {\n                return 1;\n            }\n        };\n\n        class c2 extends c1 {\n            foo(a = 1, b = () => { assert.areEqual(1, super.foo(), \"Super property access works fine from a lambda defined in the param scope\"); return a; }) {\n                a = 20;\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c2()).foo();\n\n        class c3 extends c1 {\n            foo(a = 1, b = () => { return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(1, super.foo(), \"Super property access works fine from a lambda defined in the body scope\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c3()).foo();\n\n        class c4 extends c1 {\n            foo(a = 1, b = () => { return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                assert.areEqual(1, eval(\"super.foo()\"), \"Eval should be able to access the super property properly from the body scope\");\n            }\n        }\n        (new c4()).foo();\n\n        class c5 extends c1 {\n            foo(a = super.foo(), b = () => { return a; }) {\n                assert.areEqual(1, a, \"First formal uses the super property from the param scope\");\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                a = 20;\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c5()).foo();\n    }\n  },\n  {\n    name: \"Split scope and new.target\",\n    body: function () {\n        class c1 {\n            constructor(newTarget) {\n                assert.isTrue(newTarget == new.target, \"Base class should receive the right value for new.target\"); \n            }\n        };\n\n        class c2 extends c1 {\n            constructor(a = 1, b = () => { assert.isTrue(new.target == c2, \"new.target should have the derived class value in the param scope\"); return a; }) {\n                super(c2);\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c2();\n\n        class c3 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                super(c3);\n                var c = 10;\n                (() => assert.isTrue(new.target == c3, \"new.target should be the derived class in the body scope when captured by lambda\"))();\n                assert.isTrue(new.target == c3, \"new.target should be the derived class in the body scope\");\n            }\n        }\n        new c3();\n\n        class c4 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                super(c4);\n                assert.isTrue(eval(\"new.target == c4\"), \"new.target should be the derived class inside eval\");\n                assert.isTrue(new.target == c4, \"new.target should be the derived class in the body scope\");\n            }\n        }\n        new c4();\n\n        class c5 extends c1 {\n            constructor(a = new.target, b = () => { return a; }) {\n                super(c5);\n                assert.isTrue(a == c5, \"new.target accessed from the param scope should work fine\");\n            }\n        }\n        new c5();\n    }\n  },\n  { \n    name: \"Split parameter scope and eval\", \n    body: function () { \n        function g() { \n            return 3 * 3; \n        } \n\n        function f1(h = () => eval(\"g()\")) {\n            assert.areEqual(6, g(), \"Right method is called in the body scope\");\n            function g() { \n                return 2 * 3; \n            }\n            return h();\n        }\n        assert.areEqual(9, f1(), \"Paramater scope remains split\");\n\n        function f2(h = () => eval(\"g()\")) {\n            assert.areEqual(6, eval(\"g()\"), \"Right method is called in the body scope\");\n            function g() { \n                return 2 * 3; \n            }\n            return h();\n        }\n        assert.areEqual(9, f2(), \"Paramater scope remains split\");\n    }\n  },\n  {  \n    name: \"Split parameter scope with eval in body\",  \n    body: function () {  \n        function f1(a = 10, b = function () { return a; }) {   \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\");  \n            assert.areEqual(10, eval('a'), \"Initial value of parameter in the body scope in eval should be the same as the one in param scope\");  \n            var a = 20;   \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\");  \n            assert.areEqual(20, eval('a'), \"New assignment in the body scope updates the variable's value when evaluated through eval in body scope\");  \n            return b;   \n        }   \n        assert.areEqual(10, f1()(), \"Function defined in the param scope captures the formals from the param scope not body scope with eval\");  \n          \n        function f2(a = 10, b = function () { return a; }) {   \n            assert.areEqual(10, eval('b()'), \"Eval of the function from param scope should return the right value for the formal\");  \n            var a = 20;   \n            assert.areEqual(10, eval('b()'), \"Eval of the function from param scope should return the right value for the formal even after assignment to the corresponding body symbol\");  \n            return b;   \n        }   \n        assert.areEqual(10, f2()(), \"Function defined in the param scope captures the formals from the param scope not body scope with eval\");  \n          \n        function f3(a = 10, b = function () { return a; }) {   \n            assert.areEqual(100, eval('b()'), \"Eval of the function from body scope should return the right value for the formal\");  \n            var a = 20;   \n            function b () { return a * a; }  \n            assert.areEqual(400, eval('b()'), \"Eval of the function from body scope should return the right value after assignment to the corresponding body symbol\");  \n            return b;   \n        }   \n        assert.areEqual(400, f3()(), \"Function defined in the body scope captures the symbol from the body scope with eval\");\n        \n        function f4 (a, b, c = function () { b; }, d = 1) {\n            var e = 10;\n            assert.areEqual(2, arguments[0], \"Unmapped arguments value has the expected value in the body\");\n            (function () {\n                eval('');\n            }());\n        };\n        f4.call(1, 2);\n    }  \n  },\n  {\n    name: \"Split scope and with\",\n    body: function () {\n          function f1(a, b, c = function () { a; }) {\n            with ({}) {\n                var d = function () {\n                    return 10;\n                };\n                assert.areEqual(10, d(), \"With inside a split scope function should work fine\");\n            }\n          }\n          f1();\n          \n          function f2(a, b, c = function () { a; }) {\n            var d = function () {\n                return 10;\n            };\n            with ({}) {\n                assert.areEqual(10, d(), \"With inside a split scope function should be able to access the function definition from the body\");\n            }\n          }\n          f2();\n          \n          function f3(a, b = function () { return 10; }, c = function () { a; }) {\n            with ({}) {\n                assert.areEqual(10, b(), \"With inside a split scope function should be able to access the function definition from the param scope\");\n            }\n          }\n          f3();\n\n          function f4(a, b = function () { return 10; }, c = function () { a; }) {\n            var d = {\n                e : function () { return 10; }\n            };\n            e = function () { return 100; };\n            with (d) {\n                assert.areEqual(10, e(), \"With should use the function definition inside the object not the one from body\");\n            }\n          }\n          f4();\n\n          function f5(a, b = { d : function () { return 10; } }, c = function () { a; }) {\n            var d = { };\n            with (b) {\n                assert.areEqual(10, d(), \"With should use the function definition inside the object from the param scope not the one from body\");\n            }\n          }\n          f5();\n          \n          var v6 = 100\n          function f6(a, b, c = function () { a; }, e = function () { with({}) { assert.areEqual(100, v6, \"With inside param scope should be able to access var from outside\"); } }, f = e()) {\n            var v6 = { };\n          }\n          f6();\n\n          function f7(a, b, c = function () { a; }) {\n            with ({}) {\n                assert.areEqual(100, v6, \"With inside body scope should be able to access var from outside\");\n            }\n          }\n          f7();\n          \n          function f8() {\n            function f9() {\n                return 1;\n            }\n            var v1 = 10;\n            function f10(a = 10, b = function f11() {\n                a;\n                assert.areEqual(10, v1, \"Function in the param scope should be able to access the outside variable\");\n                with ({}) {\n                    assert.areEqual(1, f9(), \"With construct inside a param scoped function should be able to execute functions from outside\");\n                }\n            }) {\n                b();\n            };\n            f10();\n          }\n          f8();\n          f8();\n          \n          function f12() {\n            function f13() {\n                return 1;\n            }\n            var v2 = 100;\n            function f14(a = 10, b = function () {\n                assert.areEqual(10, a, \"Function in the param scope should be able to access the formal from parent\");\n                return function () {\n                    assert.areEqual(10, a, \"Function nested in the param scope should be able to access the formal from the split scoped function\");\n                    assert.areEqual(100, v2, \"Function in the param scope should be able to access the outside variable\");\n                    with ({}) {\n                        assert.areEqual(1, f13(), \"With construct inside a param scoped function should be able to execute functions from outside\");\n                    }\n                };\n            }) {\n                b()();\n            };\n            f14();\n          }\n          f12();\n          f12();\n    }  \n  },\n  { \n    name: \"Basic eval in parameter scope\", \n    body: function () { \n        assert.areEqual(1, \n                        function (a = eval(\"1\")) { return a; }(), \n                        \"Eval with static constant works in parameter scope\"); \n\n        { \n            let b = 2; \n            assert.areEqual(2, \n                            function (a = eval(\"b\")) { return a; }(), \n                            \"Eval with parent var reference works in parameter scope\"); \n        } \n\n        assert.areEqual(1, \n                        function (a, b = eval(\"arguments[0]\")) { return b; }(1), \n                        \"Eval with arguments reference works in parameter scope\"); \n\n        function testSelf(a = eval(\"testSelf(1)\")) { \n            return a; \n        } \n        assert.areEqual(1, testSelf(1), \"Eval with reference to the current function works in parameter scope\"); \n\n        var testSelfExpr = function (a = eval(\"testSelfExpr(1)\")) { \n            return a; \n        } \n        assert.areEqual(1, testSelfExpr(), \"Eval with reference to the current function expression works in parameter scope\"); \n\n        { \n            let a = 1, b = 2, c = 3; \n            function testEvalRef(a = eval(\"a\"), b = eval(\"b\"), c = eval(\"c\")) { \n                return [a, b, c]; \n            } \n            assert.throws(function () { testEvalRef(); }, \n                        ReferenceError, \n                        \"Eval with reference to the current formal throws\", \n                        \"Use before declaration\"); \n\n            function testEvalRef2(x = eval(\"a\"), y = eval(\"b\"), z = eval(\"c\")) { \n                return [x, y, z]; \n            } \n            assert.areEqual([1, 2, 3], testEvalRef2(), \"Eval with references works in parameter scope\"); \n        }\n\n        function f1(a = 10, b = () => eval(\"a\")) {\n            assert.areEqual(10, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f1();\n\n        function f2(a = 10, b = () => eval(\"a\")) {\n            a = 20;\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope even when there is no eval in the body\");\n        }\n        f2();\n\n        function f3(a = 10, b = function () { return eval(\"a\"); }) {\n            a = 20;\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope even when there is no eval in the body\");\n        }\n        f3();\n\n        function f4(a = 10, b = () => eval(\"a\"), c = a = 30) {\n            assert.areEqual(30, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(30, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f4();\n\n        function f5(a = 10, b = () => eval(\"a\")) {\n            assert.areEqual(30, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            var a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(30, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f5(30);\n    } \n  }, \n  { \n    name: \"Eval declarations in parameter scope\", \n    body: function() { \n        // Redeclarations of formals - var \n        assert.throws(function () { return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                        ReferenceError, \n                        \"Redeclaring the current formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n        assert.doesNotThrow(function () { \"use strict\"; return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                            \"Redeclaring the current formal using var inside a strict mode eval does not throw\"); \n        assert.doesNotThrow(function () { \"use strict\"; return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                            \"Redeclaring the current formal using var inside a strict mode function eval does not throw\"); \n\n        assert.throws(function () { function foo(a = eval(\"var b\"), b, c = b) { return [a, b, c]; } foo(); }, \n                        ReferenceError, \n                        \"Redeclaring a future formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n\n        assert.throws(function () { function foo(a, b = eval(\"var a\"), c = a) { return [a, b, c]; } foo(); }, \n                        ReferenceError, \n                        \"Redeclaring a previous formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n\n        // Let and const do not leak outside of an eval, so the test cases below should never throw. \n        // Redeclarations of formals - let \n        assert.doesNotThrow(function (a = eval(\"let a\")) { return a; }, \n                            \"Attempting to redeclare the current formal using let inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a = eval(\"let b\"), b) { return [a, b]; }, \n                            \"Attempting to redeclare a future formal using let inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a, b = eval(\"let a\")) { return [a, b]; }, \n                            \"Attempting to redeclare a previous formal using let inside an eval does not leak\"); \n\n        // Redeclarations of formals - const \n        assert.doesNotThrow(function (a = eval(\"const a = 1\")) { return a; }, \n                            \"Attempting to redeclare the current formal using const inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a = eval(\"const b = 1\"), b) { return [a, b]; }, \n                            \"Attempting to redeclare a future formal using const inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a, b = eval(\"const a = 1\")) { return [a, b]; }, \n                            \"Attempting to redeclare a previous formal using const inside an eval does not leak\"); \n\n        // Conditional declarations \n        function test(x = eval(\"var a1 = 1; let b1 = 2; const c1 = 3;\")) { \n            // none should be visible \n            assert.throws(function () { a1 }, ReferenceError, \"Ignoring the default value does not result in an eval declaration leaking\", \"'a1' is undefined\"); \n            assert.throws(function () { b1 }, ReferenceError, \"Let declarations do not leak out of eval to parameter scope\",   \"'b1' is undefined\"); \n            assert.throws(function () { c1 }, ReferenceError, \"Const declarations do not leak out of eval to parameter scope when x is \", \"'c1' is undefined\"); \n        } \n        test(); \n\n        // Redefining locals \n        function foo(a = eval(\"var x = 1; assert.areEqual(1, x, 'Variable declared inside eval is accessible within eval');\")) { \n            assert.areEqual(undefined, x, \"Var declaration from eval is not visible in the body\"); \n            var x = 10; \n            assert.areEqual(10, x, \"Var declaration from eval uses its new value in the body declaration\"); \n        } \n        assert.doesNotThrow(function() { foo(); }, \"Redefining a local var with an eval var does not throw\"); \n\n        // Function bodies defined in eval\n        function funcArrow(a = eval(\"() => 1\"), b = a) { function a() { return 10; }; return [a(), b()]; }\n        assert.areEqual([10,1], funcArrow(), \"Defining an arrow function body inside an eval works at default parameter scope\");\n\n        function funcDecl(a = eval(\"(function foo() { return 1; })\"), b = a()) { return [a(), b]; }\n        assert.areEqual([1, 1], funcDecl(), \"Defining a function inside an eval works at default parameter scope\");\n\n        function funcDecl(a = eval(\"function foo() { return 1; }; foo\"), b = a()) { return [a(), b]; }\n        assert.areEqual([1, 1], funcDecl(), \"Defining a function inside an eval works at default parameter scope\");\n\n        function genFuncDecl(a = eval(\"(function *foo() { yield 1; return 2; })\"), b = a(), c = b.next()) { return [c, b.next()]; }\n        assert.areEqual([{value : 1, done : false}, {value : 2, done : true}], genFuncDecl(), \"Declaring a generator function inside an eval works at default parameter scope\");\n\n        function funcExpr(a = eval(\"f = function foo() { return 1; }\"), b = f()) { return [a(), b, f()]; }\n        assert.areEqual([1, 1, 1], funcExpr(), \"Declaring a function inside an eval works at default parameter scope\");\n\n        assert.throws(function () { eval(\"function foo(a = eval('b'), b) {}; foo();\"); }, ReferenceError, \"Future default references using eval are not allowed\", \"Use before declaration\");\n    } \n  }, \n]; \n\n\ntestRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" }); \n"], "fixing_code": ["//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n#include \"ParserPch.h\"\n#include \"FormalsUtil.h\"\n#include \"../Runtime/Language/SourceDynamicProfileManager.h\"\n\n#if DBG_DUMP\nvoid PrintPnodeWIndent(ParseNode *pnode,int indentAmt);\n#endif\n\nconst char* const nopNames[knopLim]= {\n#define PTNODE(nop,sn,pc,nk,grfnop,json) sn,\n#include \"ptlist.h\"\n};\nvoid printNop(int nop) {\n  printf(\"%s\\n\",nopNames[nop]);\n}\n\nconst uint ParseNode::mpnopgrfnop[knopLim] =\n{\n#define PTNODE(nop,sn,pc,nk,grfnop,json) grfnop,\n#include \"ptlist.h\"\n};\n\nbool Parser::IsES6DestructuringEnabled() const\n{\n    return m_scriptContext->GetConfig()->IsES6DestructuringEnabled();\n}\n\nstruct DeferredFunctionStub\n{\n    RestorePoint restorePoint;\n    uint fncFlags;\n    uint nestedCount;\n    DeferredFunctionStub *deferredStubs;\n    charcount_t ichMin;\n};\n\nstruct StmtNest\n{\n    union\n    {\n        struct\n        {\n            ParseNodePtr pnodeStmt; // This statement node.\n            ParseNodePtr pnodeLab;  // Labels for this statement.\n        };\n        struct\n        {\n            bool isDeferred : 1;\n            OpCode op;              // This statement operation.\n            LabelId* pLabelId;      // Labels for this statement.\n        };\n    };\n    StmtNest *pstmtOuter;           // Enclosing statement.\n\n    OpCode GetNop() const \n    { \n        AnalysisAssert(isDeferred || pnodeStmt != nullptr);\n        return isDeferred ? op : pnodeStmt->nop; \n    }\n};\n\nstruct BlockInfoStack\n{\n    StmtNest pstmt;\n    ParseNode *pnodeBlock;\n    ParseNodePtr *m_ppnodeLex;              // lexical variable list tail\n    BlockInfoStack *pBlockInfoOuter;        // containing block's BlockInfoStack\n    BlockInfoStack *pBlockInfoFunction;     // nearest function's BlockInfoStack (if pnodeBlock is a function, this points to itself)\n};\n\n#if DEBUG\nParser::Parser(Js::ScriptContext* scriptContext, BOOL strictMode, PageAllocator *alloc, bool isBackground, size_t size)\n#else\nParser::Parser(Js::ScriptContext* scriptContext, BOOL strictMode, PageAllocator *alloc, bool isBackground)\n#endif\n    : m_nodeAllocator(_u(\"Parser\"), alloc ? alloc : scriptContext->GetThreadContext()->GetPageAllocator(), Parser::OutOfMemory),\n    // use the GuestArena directly for keeping the RegexPattern* alive during byte code generation\n    m_registeredRegexPatterns(scriptContext->GetGuestArena())\n{\n    AssertMsg(size == sizeof(Parser), \"verify conditionals affecting the size of Parser agree\");\n    Assert(scriptContext != nullptr);\n    m_isInBackground = isBackground;\n    m_phtbl = nullptr;\n    m_pscan = nullptr;\n    m_deferringAST = FALSE;\n    m_stoppedDeferredParse = FALSE;\n    m_hasParallelJob = false;\n    m_doingFastScan = false;\n    m_scriptContext = scriptContext;\n    m_pCurrentAstSize = nullptr;\n    m_arrayDepth = 0;\n    m_funcInArrayDepth = 0;\n    m_parenDepth = 0;\n    m_funcInArray = 0;\n    m_tryCatchOrFinallyDepth = 0;\n    m_UsesArgumentsAtGlobal = false;\n    m_currentNodeFunc = nullptr;\n    m_currentNodeDeferredFunc = nullptr;\n    m_currentNodeNonLambdaFunc = nullptr;\n    m_currentNodeNonLambdaDeferredFunc = nullptr;\n    m_currentNodeProg = nullptr;\n    m_currDeferredStub = nullptr;\n    m_prevSiblingDeferredStub = nullptr;\n    m_pstmtCur = nullptr;\n    m_currentBlockInfo = nullptr;\n    m_currentScope = nullptr;\n    m_currentDynamicBlock = nullptr;\n    m_grfscr = fscrNil;\n    m_length = 0;\n    m_originalLength = 0;\n    m_nextFunctionId = nullptr;\n    m_errorCallback = nullptr;\n    m_uncertainStructure = FALSE;\n    m_reparsingLambdaParams = false;\n    m_inFIB = false;\n    currBackgroundParseItem = nullptr;\n    backgroundParseItems = nullptr;\n    fastScannedRegExpNodes = nullptr;\n\n    m_fUseStrictMode = strictMode;\n    m_InAsmMode = false;\n    m_deferAsmJs = true;\n    m_scopeCountNoAst = 0;\n    m_fExpectExternalSource = 0;\n\n    m_parseType = ParseType_Upfront;\n\n    m_deferEllipsisError = false;\n    m_hasDeferredShorthandInitError = false;\n    m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperDisallowed;\n}\n\nParser::~Parser(void)\n{\n    if (m_scriptContext == nullptr || m_scriptContext->GetGuestArena() == nullptr)\n    {\n        // If the scriptContext or guestArena have gone away, there is no point clearing each item of this list.\n        // Just reset it so that destructor of the SList will be no-op\n        m_registeredRegexPatterns.Reset();\n    }\n\n    if (this->m_hasParallelJob)\n    {\n#if ENABLE_BACKGROUND_PARSING\n        // Let the background threads know that they can decommit their arena pages.\n        BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n        Assert(bgp);\n        if (bgp->Processor()->ProcessesInBackground())\n        {\n            JsUtil::BackgroundJobProcessor *processor = static_cast<JsUtil::BackgroundJobProcessor*>(bgp->Processor());\n\n            bool result = processor->IterateBackgroundThreads([&](JsUtil::ParallelThreadData *threadData)->bool {\n                threadData->canDecommit = true;\n                return false;\n            });\n            Assert(result);\n        }\n#endif\n    }\n\n    Release();\n\n}\n\nvoid Parser::OutOfMemory()\n{\n    throw ParseExceptionObject(ERRnoMemory);\n}\n\nvoid Parser::Error(HRESULT hr)\n{\n    Assert(FAILED(hr));\n    m_err.Throw(hr);\n}\n\nvoid Parser::Error(HRESULT hr, ParseNodePtr pnode)\n{\n    if (pnode && pnode->ichLim)\n    {\n        Error(hr, pnode->ichMin, pnode->ichLim);\n    }\n    else\n    {\n        Error(hr);\n    }\n}\n\nvoid Parser::Error(HRESULT hr, charcount_t ichMin, charcount_t ichLim)\n{\n    m_pscan->SetErrorPosition(ichMin, ichLim);\n    Error(hr);\n}\n\nvoid Parser::IdentifierExpectedError(const Token& token)\n{\n    Assert(token.tk != tkID);\n\n    HRESULT hr;\n    if (token.IsReservedWord())\n    {\n        if (token.IsKeyword())\n        {\n            hr = ERRKeywordNotId;\n        }\n        else\n        {\n            Assert(token.IsFutureReservedWord(true));\n            if (token.IsFutureReservedWord(false))\n            {\n                // Future reserved word in strict and non-strict modes\n                hr = ERRFutureReservedWordNotId;\n            }\n            else\n            {\n                // Future reserved word only in strict mode. The token would have been converted to tkID by the scanner if not\n                // in strict mode.\n                Assert(IsStrictMode());\n                hr = ERRFutureReservedWordInStrictModeNotId;\n            }\n        }\n    }\n    else\n    {\n        hr = ERRnoIdent;\n    }\n\n    Error(hr);\n}\n\nHRESULT Parser::ValidateSyntax(LPCUTF8 pszSrc, size_t encodedCharCount, bool isGenerator, bool isAsync, CompileScriptException *pse, void (Parser::*validateFunction)())\n{\n    AssertPsz(pszSrc);\n    AssertMemN(pse);\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n\n    HRESULT hr;\n    SmartFPUControl smartFpuControl;\n\n    DebugOnly( m_err.fInited = TRUE; )\n    BOOL fDeferSave = m_deferringAST;\n    try\n    {\n        hr = NOERROR;\n\n        this->PrepareScanner(false);\n\n        m_length = encodedCharCount;\n        m_originalLength = encodedCharCount;\n\n        // make sure deferred parsing is turned off\n        ULONG grfscr = fscrNil;\n\n        // Give the scanner the source and get the first token\n        m_pscan->SetText(pszSrc, 0, encodedCharCount, 0, grfscr);\n        m_pscan->SetYieldIsKeyword(isGenerator);\n        m_pscan->SetAwaitIsKeyword(isAsync);\n        m_pscan->Scan();\n\n        uint nestedCount = 0;\n        m_pnestedCount = &nestedCount;\n\n        ParseNodePtr pnodeScope = nullptr;\n        m_ppnodeScope = &pnodeScope;\n        m_ppnodeExprScope = nullptr;\n\n        uint nextFunctionId = 0;\n        m_nextFunctionId = &nextFunctionId;\n\n        m_inDeferredNestedFunc = false;\n        m_deferringAST = true;\n\n\n\n        m_nextBlockId = 0;\n\n        ParseNode *pnodeFnc = CreateNode(knopFncDecl);\n        pnodeFnc->sxFnc.ClearFlags();\n        pnodeFnc->sxFnc.SetDeclaration(false);\n        pnodeFnc->sxFnc.functionId   = 0;\n        pnodeFnc->sxFnc.astSize      = 0;\n        pnodeFnc->sxFnc.pnodeVars    = nullptr;\n        pnodeFnc->sxFnc.pnodeParams  = nullptr;\n        pnodeFnc->sxFnc.pnodeBody    = nullptr;\n        pnodeFnc->sxFnc.pnodeName    = nullptr;\n        pnodeFnc->sxFnc.pnodeRest    = nullptr;\n        pnodeFnc->sxFnc.deferredStub = nullptr;\n        pnodeFnc->sxFnc.SetIsGenerator(isGenerator);\n        pnodeFnc->sxFnc.SetIsAsync(isAsync);\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n        m_currentNodeFunc = pnodeFnc;\n        m_currentNodeDeferredFunc = NULL;\n        m_sourceContextInfo = nullptr;\n        AssertMsg(m_pstmtCur == NULL, \"Statement stack should be empty when we start parse function body\");\n\n        ParseNodePtr block = StartParseBlock<false>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        (this->*validateFunction)();\n        FinishParseBlock(block);\n\n        pnodeFnc->ichLim = m_pscan->IchLimTok();\n        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        pnodeFnc->sxFnc.pnodeVars = nullptr;\n\n        // there should be nothing after successful parsing for a given construct\n        if (m_token.tk != tkEOF)\n            Error(ERRsyntax);\n\n        RELEASEPTR(m_pscan);\n        m_deferringAST = fDeferSave;\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_deferringAST = fDeferSave;\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan,  m_err.m_hr, /* pnodeBase */ NULL);\n    }\n\n    return hr;\n}\n\nHRESULT Parser::ParseSourceInternal(\n    __out ParseNodePtr* parseTree, LPCUTF8 pszSrc, size_t offsetInBytes, size_t encodedCharCount, charcount_t offsetInChars,\n    bool fromExternal, ULONG grfscr, CompileScriptException *pse, Js::LocalFunctionId * nextFunctionId, ULONG lineNumber, SourceContextInfo * sourceContextInfo)\n{\n    AssertMem(parseTree);\n    AssertPsz(pszSrc);\n    AssertMemN(pse);\n   \n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackDefault);\n    }\n\n#ifdef PROFILE_EXEC\n    m_scriptContext->ProfileBegin(Js::ParsePhase);\n#endif\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_START(m_scriptContext,0));\n\n    *parseTree = NULL;\n    m_sourceLim = 0;\n\n    m_grfscr = grfscr;\n    m_sourceContextInfo = sourceContextInfo;\n\n    ParseNodePtr pnodeBase = NULL;\n    HRESULT hr;\n    SmartFPUControl smartFpuControl;\n\n    DebugOnly( m_err.fInited = TRUE; )\n\n    try\n    {\n        this->PrepareScanner(fromExternal);\n\n        if ((grfscr & fscrEvalCode) != 0)\n        {\n            this->m_parsingSuperRestrictionState = Parser::ParsingSuperRestrictionState_SuperPropertyAllowed;\n        }\n\n        if ((grfscr & fscrIsModuleCode) != 0)\n        {\n            // Module source flag should not be enabled unless module is enabled\n            Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n\n            // Module code is always strict mode code.\n            this->m_fUseStrictMode = TRUE;\n        }\n\n        // parse the source\n        pnodeBase = Parse(pszSrc, offsetInBytes, encodedCharCount, offsetInChars, grfscr, lineNumber, nextFunctionId, pse);\n\n        AssertNodeMem(pnodeBase);\n\n        // Record the actual number of words parsed.\n        m_sourceLim = pnodeBase->ichLim - offsetInChars;\n\n        // TODO: The assert can be false positive in some scenarios and chuckj to fix it later\n        // Assert(utf8::ByteIndexIntoCharacterIndex(pszSrc + offsetInBytes, encodedCharCount, fromExternal ? utf8::doDefault : utf8::doAllowThreeByteSurrogates) == m_sourceLim);\n\n#if DBG_DUMP\n        if (Js::Configuration::Global.flags.Trace.IsEnabled(Js::ParsePhase))\n        {\n            PrintPnodeWIndent(pnodeBase,4);\n            fflush(stdout);\n        }\n#endif\n\n        *parseTree = pnodeBase;\n\n        hr = NOERROR;\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan, m_err.m_hr, pnodeBase);\n    }\n\n    if (this->m_hasParallelJob)\n    {\n#if ENABLE_BACKGROUND_PARSING\n        ///// Wait here for remaining jobs to finish. Then look for errors, do final const bindings.\n        // pleath TODO: If there are remaining jobs, let the main thread help finish them.\n        BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n        Assert(bgp);\n\n        CompileScriptException se;\n        this->WaitForBackgroundJobs(bgp, &se);\n\n        BackgroundParseItem *failedItem = bgp->GetFailedBackgroundParseItem();\n        if (failedItem)\n        {\n            CompileScriptException *bgPse = failedItem->GetPSE();\n            Assert(bgPse);\n            *pse = *bgPse;\n            hr = failedItem->GetHR();\n            bgp->SetFailedBackgroundParseItem(nullptr);\n        }\n\n        if (this->fastScannedRegExpNodes != nullptr)\n        {\n            this->FinishBackgroundRegExpNodes();\n        }\n\n        for (BackgroundParseItem *item = this->backgroundParseItems; item; item = item->GetNext())\n        {\n            Parser *parser = item->GetParser();\n            parser->FinishBackgroundPidRefs(item, this != parser);\n        }\n#endif\n    }\n\n    // done with the scanner\n    RELEASEPTR(m_pscan);\n\n#ifdef PROFILE_EXEC\n    m_scriptContext->ProfileEnd(Js::ParsePhase);\n#endif\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_STOP(m_scriptContext, 0));\n    \n    return hr;\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::WaitForBackgroundJobs(BackgroundParser *bgp, CompileScriptException *pse)\n{\n    // The scan of the script is done, but there may be unfinished background jobs in the queue.\n    // Enlist the main thread to help with those.\n    BackgroundParseItem *item;\n    if (!*bgp->GetPendingBackgroundItemsPtr())\n    {\n        // We're done.\n        return;\n    }\n\n    // Save parser state, since we'll need to restore it in order to bind references correctly later.\n    this->m_isInBackground = true;\n    this->SetCurrBackgroundParseItem(nullptr);\n    uint blockIdSave = this->m_nextBlockId;\n    uint functionIdSave = *this->m_nextFunctionId;\n    StmtNest *pstmtSave = this->m_pstmtCur;\n\n    if (!bgp->Processor()->ProcessesInBackground())\n    {\n        // No background thread. Just walk the jobs with no locking and process them.\n        for (item = bgp->GetNextUnprocessedItem(); item; item = bgp->GetNextUnprocessedItem())\n        {\n            bgp->Processor()->RemoveJob(item);\n            bool succeeded = bgp->Process(item, this, pse);\n            bgp->JobProcessed(item, succeeded);\n        }\n        Assert(!*bgp->GetPendingBackgroundItemsPtr());\n    }\n    else\n    {\n        // Background threads. We need to have the critical section in order to:\n        // - Check for unprocessed jobs;\n        // - Remove jobs from the processor queue;\n        // - Do JobsProcessed work (such as removing jobs from the BackgroundParser's unprocessed list).\n        CriticalSection *pcs = static_cast<JsUtil::BackgroundJobProcessor*>(bgp->Processor())->GetCriticalSection();\n        pcs->Enter();\n        for (;;)\n        {\n            // Grab a job (in lock)\n            item = bgp->GetNextUnprocessedItem();\n            if (item == nullptr)\n            {\n                break;\n            }\n            bgp->Processor()->RemoveJob(item);\n            pcs->Leave();\n\n            // Process job (if there is one) (outside lock)\n            bool succeeded = bgp->Process(item, this, pse);\n\n            pcs->Enter();\n            bgp->JobProcessed(item, succeeded);\n        }\n        pcs->Leave();\n\n        // Wait for the background threads to finish jobs they're already processing (if any).\n        // TODO: Replace with a proper semaphore.\n        while(*bgp->GetPendingBackgroundItemsPtr());\n    }\n\n    Assert(!*bgp->GetPendingBackgroundItemsPtr());\n\n    // Restore parser state.\n    this->m_pstmtCur = pstmtSave;\n    this->m_isInBackground = false;\n    this->m_nextBlockId = blockIdSave;\n    *this->m_nextFunctionId = functionIdSave;\n}\n\nvoid Parser::FinishBackgroundPidRefs(BackgroundParseItem *item, bool isOtherParser)\n{\n    for (BlockInfoStack *blockInfo = item->GetParseContext()->currentBlockInfo; blockInfo; blockInfo = blockInfo->pBlockInfoOuter)\n    {\n        if (isOtherParser)\n        {\n            this->BindPidRefs<true>(blockInfo, item->GetMaxBlockId());\n        }\n        else\n        {\n            this->BindPidRefs<false>(blockInfo, item->GetMaxBlockId());\n        }\n    }\n}\n\nvoid Parser::FinishBackgroundRegExpNodes()\n{\n    // We have a list of RegExp nodes that we saw on the UI thread in functions we're parallel parsing,\n    // and for each background job we have a list of RegExp nodes for which we couldn't allocate patterns.\n    // We need to copy the pattern pointers from the UI thread nodes to the corresponding nodes on the\n    // background nodes.\n    // There may be UI thread nodes for which there are no background thread equivalents, because the UI thread\n    // has to assume that the background thread won't defer anything.\n\n    // Note that because these lists (and the list of background jobs) are SList's built by prepending, they are\n    // all in reverse lexical order.\n\n    Assert(!this->IsBackgroundParser());\n    Assert(this->fastScannedRegExpNodes);\n    Assert(this->backgroundParseItems != nullptr);\n\n    BackgroundParseItem *currBackgroundItem;\n\n#if DBG\n    for (currBackgroundItem = this->backgroundParseItems;\n         currBackgroundItem;\n         currBackgroundItem = currBackgroundItem->GetNext())\n    {\n        if (currBackgroundItem->RegExpNodeList())\n        {\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnode, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnode->sxPid.regexPattern == nullptr);\n            }\n            NEXT_DLIST_ENTRY;\n        }\n    }\n#endif\n\n    // Hook up the patterns allocated on the main thread to the nodes created on the background thread.\n    // Walk the list of foreground nodes, advancing through the work items and looking up each item.\n    // Note that the background thread may have chosen to defer a given RegEx literal, so not every foreground\n    // node will have a matching background node. Doesn't matter for correctness.\n    // (It's inefficient, of course, to have to restart the inner loop from the beginning of the work item's\n    // list, but it should be unusual to have many RegExes in a single work item's chunk of code. Figure out how\n    // to start the inner loop from a known internal node within the list if that turns out to be important.)\n    currBackgroundItem = this->backgroundParseItems;\n    FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnodeFgnd, this->fastScannedRegExpNodes)\n    {\n        Assert(pnodeFgnd->nop == knopRegExp);\n        Assert(pnodeFgnd->sxPid.regexPattern != nullptr);\n        bool quit = false;\n\n        while (!quit)\n        {\n            // Find the next work item with a RegEx in it.\n            while (currBackgroundItem && currBackgroundItem->RegExpNodeList() == nullptr)\n            {\n                currBackgroundItem = currBackgroundItem->GetNext();\n            }\n            if (!currBackgroundItem)\n            {\n                break;\n            }\n\n            // Walk the RegExps in the work item.\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnodeBgnd, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnodeBgnd->nop == knopRegExp);\n\n                if (pnodeFgnd->ichMin <= pnodeBgnd->ichMin)\n                {\n                    // Either we found a match, or the next background node is past the foreground node.\n                    // In any case, we can stop searching.\n                    if (pnodeFgnd->ichMin == pnodeBgnd->ichMin)\n                    {\n                        Assert(pnodeFgnd->ichLim == pnodeBgnd->ichLim);\n                        pnodeBgnd->sxPid.regexPattern = pnodeFgnd->sxPid.regexPattern;\n                    }\n                    quit = true;\n                    break;\n                }\n            }\n            NEXT_DLIST_ENTRY;\n\n            if (!quit)\n            {\n                // Need to advance to the next work item.\n                currBackgroundItem = currBackgroundItem->GetNext();\n            }\n        }\n    }\n    NEXT_DLIST_ENTRY;\n\n#if DBG\n    for (currBackgroundItem = this->backgroundParseItems;\n         currBackgroundItem;\n         currBackgroundItem = currBackgroundItem->GetNext())\n    {\n        if (currBackgroundItem->RegExpNodeList())\n        {\n            FOREACH_DLIST_ENTRY(ParseNodePtr, ArenaAllocator, pnode, currBackgroundItem->RegExpNodeList())\n            {\n                Assert(pnode->sxPid.regexPattern != nullptr);\n            }\n            NEXT_DLIST_ENTRY;\n        }\n    }\n#endif\n}\n#endif\n\nLabelId* Parser::CreateLabelId(IdentToken* pToken)\n{\n    LabelId* pLabelId;\n\n    pLabelId = (LabelId*)m_nodeAllocator.Alloc(sizeof(LabelId));\n    if (NULL == pLabelId)\n        Error(ERRnoMemory);\n    pLabelId->pid = pToken->pid;\n    pLabelId->next = NULL;\n\n    return pLabelId;\n}\n\n/*****************************************************************************\nThe following set of routines allocate parse tree nodes of various kinds.\nThey catch an exception on out of memory.\n*****************************************************************************/\nstatic const int g_mpnopcbNode[] =\n{\n#define PTNODE(nop,sn,pc,nk,ok,json) kcbPn##nk,\n#include \"ptlist.h\"\n};\n\nconst Js::RegSlot NoRegister = (Js::RegSlot)-1;\nconst Js::RegSlot OneByteRegister = (Js::RegSlot_OneByte)-1;\n\nvoid Parser::InitNode(OpCode nop,ParseNodePtr pnode) {\n    pnode->nop = nop;\n    pnode->grfpn = PNodeFlags::fpnNone;\n    pnode->location = NoRegister;\n    pnode->emitLabels = false;\n    pnode->isUsed = true;\n    pnode->notEscapedUse = false;\n    pnode->isInList = false;\n    pnode->isCallApplyTargetLoad = false;\n}\n\n// Create nodes using Arena\nParseNodePtr\nParser::StaticCreateBlockNode(ArenaAllocator* alloc, charcount_t ichMin , charcount_t ichLim, int blockId, PnodeBlockType blockType)\n{\n    ParseNodePtr pnode = StaticCreateNodeT<knopBlock>(alloc, ichMin, ichLim);\n    InitBlockNode(pnode, blockId, blockType);\n    return pnode;\n}\n\nvoid Parser::InitBlockNode(ParseNodePtr pnode, int blockId, PnodeBlockType blockType)\n{\n    Assert(pnode->nop == knopBlock);\n    pnode->sxBlock.pnodeScopes = nullptr;\n    pnode->sxBlock.pnodeNext = nullptr;\n    pnode->sxBlock.scope = nullptr;\n    pnode->sxBlock.enclosingBlock = nullptr;\n    pnode->sxBlock.pnodeLexVars = nullptr;\n    pnode->sxBlock.pnodeStmt = nullptr;\n    pnode->sxBlock.pnodeLastValStmt = nullptr;\n\n    pnode->sxBlock.callsEval = false;\n    pnode->sxBlock.childCallsEval = false;\n    pnode->sxBlock.blockType = blockType;\n    pnode->sxBlock.blockId = blockId;\n\n    if (blockType != PnodeBlockType::Regular)\n    {\n        pnode->grfpn |= PNodeFlags::fpnSyntheticNode;\n    }\n}\n\n// Create Node with limit\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeT(charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = StaticCreateNodeT<nop>(&m_nodeAllocator, ichMin, ichLim);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += GetNodeSize<nop>();\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateDeclNode(OpCode nop, IdentPtr pid, SymbolType symbolType, bool errorOnRedecl, bool *isRedecl)\n{\n    ParseNodePtr pnode = CreateNode(nop);\n\n    pnode->sxVar.InitDeclNode(pid, NULL);\n\n    if (symbolType != STUnknown)\n    {\n        pnode->sxVar.sym = AddDeclForPid(pnode, pid, symbolType, errorOnRedecl, isRedecl);\n    }\n\n    return pnode;\n}\n\nSymbol* Parser::AddDeclForPid(ParseNodePtr pnode, IdentPtr pid, SymbolType symbolType, bool errorOnRedecl, bool *isRedecl)\n{\n    Assert(pnode->IsVarLetOrConst());\n\n    PidRefStack *refForUse = nullptr, *refForDecl = nullptr;\n\n    if (isRedecl)\n    {\n        *isRedecl = false;\n    }\n\n    BlockInfoStack *blockInfo;\n    bool fBlockScope = false;\n    if (pnode->nop != knopVarDecl || symbolType == STFunction)\n    {\n        Assert(m_pstmtCur);\n        if (m_pstmtCur->GetNop() != knopBlock)\n        {\n            // Let/const declared in a bare statement context.\n            Error(ERRDeclOutOfStmt);\n        }\n\n        if (m_pstmtCur->pstmtOuter && m_pstmtCur->pstmtOuter->GetNop() == knopSwitch)\n        {\n            // Let/const declared inside a switch block (requiring conservative use-before-decl check).\n            pnode->sxVar.isSwitchStmtDecl = true;\n        }\n\n        fBlockScope = pnode->nop != knopVarDecl ||\n            (\n                !GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope ||\n                GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock\n                );\n    }\n    if (fBlockScope)\n    {\n        blockInfo = GetCurrentBlockInfo();\n    }\n    else\n    {\n        blockInfo = GetCurrentFunctionBlockInfo();\n    }\n\n    // If we are creating an 'arguments' Sym at function block scope, create it in\n    // the parameter scope instead. That way, if we need to reuse the Sym for the\n    // actual arguments object at the end of the function, we don't need to move it\n    // into the parameter scope.\n    if (pid == wellKnownPropertyPids.arguments\n        && pnode->nop == knopVarDecl\n        && blockInfo->pnodeBlock->sxBlock.blockType == PnodeBlockType::Function\n        && blockInfo->pBlockInfoOuter != nullptr\n        && blockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter\n        && blockInfo->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_FuncExpr\n        && blockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.scope->GetCanMergeWithBodyScope())\n    {\n        blockInfo = blockInfo->pBlockInfoOuter;\n    }\n\n    refForDecl = this->FindOrAddPidRef(pid, blockInfo->pnodeBlock->sxBlock.blockId, GetCurrentFunctionNode()->sxFnc.functionId);\n\n    if (refForDecl == nullptr)\n    {\n        Error(ERRnoMemory);\n    }\n\n    if (refForDecl->funcId != GetCurrentFunctionNode()->sxFnc.functionId)\n    {\n        // Fix up the function id, which is incorrect if we're reparsing lambda parameters\n        Assert(this->m_reparsingLambdaParams);\n        refForDecl->funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    }\n    \n    if (blockInfo == GetCurrentBlockInfo())\n    {\n        refForUse = refForDecl;\n    }\n    else\n    {\n        refForUse = this->PushPidRef(pid);\n    }\n    pnode->sxVar.symRef = refForUse->GetSymRef();\n    Symbol *sym = refForDecl->GetSym();\n    if (sym != nullptr)\n    {\n        if (isRedecl)\n        {\n            *isRedecl = true;\n        }\n        // Multiple declarations in the same scope. 3 possibilities: error, existing one wins, new one wins.\n        switch (pnode->nop)\n        {\n        case knopLetDecl:\n        case knopConstDecl:\n            if (!sym->GetDecl()->sxVar.isBlockScopeFncDeclVar)\n            {\n                Assert(errorOnRedecl);\n                // Redeclaration error.\n                Error(ERRRedeclaration);\n            }\n            else\n            {\n                // (New) let/const hides the (old) var\n                sym->SetSymbolType(symbolType);\n                sym->SetDecl(pnode);\n            }\n            break;\n        case knopVarDecl:\n            if (m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                // If this is a parameter list, mark the scope to indicate that it has duplicate definition.\n                // If later this turns out to be a non-simple param list (like function f(a, a, c = 1) {}) then it is a SyntaxError to have duplicate formals.\n                m_currentScope->SetHasDuplicateFormals();\n            }\n\n            if (sym->GetDecl() == nullptr)\n            {\n                Assert(symbolType == STFunction);\n                sym->SetDecl(pnode);\n                break;\n            }\n            switch (sym->GetDecl()->nop)\n            {\n            case knopLetDecl:\n            case knopConstDecl:\n                // Destructuring made possible to have the formals to be the let bind. But that shouldn't throw the error.\n                if (errorOnRedecl && (!IsES6DestructuringEnabled() || sym->GetSymbolType() != STFormal))\n                {\n                    Error(ERRRedeclaration);\n                }\n                // If !errorOnRedecl, (old) let/const hides the (new) var, so do nothing.\n                break;\n            case knopVarDecl:\n                // Legal redeclaration. Who wins?\n                if (errorOnRedecl || sym->GetDecl()->sxVar.isBlockScopeFncDeclVar)\n                {\n                    if (symbolType == STFormal ||\n                        (symbolType == STFunction && sym->GetSymbolType() != STFormal) ||\n                        sym->GetSymbolType() == STVariable)\n                    {\n                        // New decl wins.\n                        sym->SetSymbolType(symbolType);\n                        sym->SetDecl(pnode);\n                    }\n                }\n                break;\n            }\n            break;\n        }\n    }\n    else\n    {\n        Scope *scope = blockInfo->pnodeBlock->sxBlock.scope;\n        if (scope == nullptr)\n        {\n            Assert(blockInfo->pnodeBlock->sxBlock.blockType == PnodeBlockType::Regular);\n            scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, ScopeType_Block);\n            if (this->IsCurBlockInLoop())\n            {\n                scope->SetIsBlockInLoop();\n            }\n            blockInfo->pnodeBlock->sxBlock.scope = scope;\n            PushScope(scope);\n        }\n\n        if (scope->GetScopeType() == ScopeType_GlobalEvalBlock)\n        {\n            Assert(fBlockScope);\n            Assert(scope->GetEnclosingScope() == m_currentNodeProg->sxProg.scope);\n            // Check for same-named decl in Global scope.\n            PidRefStack *pidRefOld = pid->GetPidRefForScopeId(0);\n            if (pidRefOld && pidRefOld->GetSym())\n            {\n                Error(ERRRedeclaration);\n            }\n        }\n        else if (scope->GetScopeType() == ScopeType_Global && (this->m_grfscr & fscrEvalCode) &&\n                 !(m_functionBody && m_functionBody->GetScopeInfo()))\n        {\n            // Check for same-named decl in GlobalEvalBlock scope. Note that this is not necessary\n            // if we're compiling a deferred nested function and the global scope was restored from cached info,\n            // because in that case we don't need a GlobalEvalScope.\n            Assert(!fBlockScope || (this->m_grfscr & fscrConsoleScopeEval) == fscrConsoleScopeEval);\n            PidRefStack *pidRefOld = pid->GetPidRefForScopeId(1);\n            if (pidRefOld && pidRefOld->GetSym())\n            {\n                Error(ERRRedeclaration);\n            }\n        }\n\n        if ((scope->GetScopeType() == ScopeType_FunctionBody || scope->GetScopeType() == ScopeType_Parameter) && symbolType != STFunction)\n        {\n            ParseNodePtr pnodeFnc = GetCurrentFunctionNode();\n            AnalysisAssert(pnodeFnc);\n            if (pnodeFnc->sxFnc.pnodeName &&\n                pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl &&\n                pnodeFnc->sxFnc.pnodeName->sxVar.pid == pid)\n            {\n                // Named function expression has its name hidden by a local declaration.\n                // This is important to know if we don't know whether nested deferred functions refer to it,\n                // because if the name has a non-local reference then we have to create a scope object.\n                m_currentNodeFunc->sxFnc.SetNameIsHidden();\n            }\n        }\n\n        if (!sym)\n        {\n            const char16 *name = reinterpret_cast<const char16*>(pid->Psz());\n            int nameLength = pid->Cch();\n            SymbolName const symName(name, nameLength);\n\n            Assert(!scope->FindLocalSymbol(symName));\n            sym = Anew(&m_nodeAllocator, Symbol, symName, pnode, symbolType);\n            scope->AddNewSymbol(sym);\n            sym->SetPid(pid);\n        }\n        refForDecl->SetSym(sym);\n    }\n    return sym;\n}\n\nbool Parser::IsCurBlockInLoop() const\n{\n    for (StmtNest *stmt = this->m_pstmtCur; stmt != nullptr; stmt = stmt->pstmtOuter)\n    {\n        OpCode nop = stmt->GetNop();\n        if (ParseNode::Grfnop(nop) & fnopContinue)\n        {\n            return true;\n        }\n        if (nop == knopFncDecl)\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nvoid Parser::RestorePidRefForSym(Symbol *sym)\n{\n    IdentPtr pid = m_pscan->m_phtbl->PidHashNameLen(sym->GetName().GetBuffer(), sym->GetName().GetLength());\n    Assert(pid);\n    sym->SetPid(pid);\n    PidRefStack *ref = this->PushPidRef(pid);\n    ref->SetSym(sym);\n}\n\nIdentPtr Parser::PidFromNode(ParseNodePtr pnode)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return pnode->sxPid.pid;\n\n        case knopVarDecl:\n            return pnode->sxVar.pid;\n\n        case knopDot:\n            Assert(pnode->sxBin.pnode2->nop == knopName);\n            return pnode->sxBin.pnode2->sxPid.pid;\n\n        case knopComma:\n            // Advance to the RHS and iterate.\n            pnode = pnode->sxBin.pnode2;\n            break;\n\n        default:\n            return nullptr;\n        }\n    }\n}\n\n#if DBG\nvoid VerifyNodeSize(OpCode nop, int size)\n{\n    Assert(nop >= 0 && nop < knopLim);\n    __analysis_assume(nop < knopLim);\n    Assert(g_mpnopcbNode[nop] == size);\n}\n#endif\n\nParseNodePtr Parser::StaticCreateBinNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2,ArenaAllocator* alloc)\n{\n    DebugOnly(VerifyNodeSize(nop, kcbPnBin));\n    ParseNodePtr pnode = (ParseNodePtr)alloc->Alloc(kcbPnBin);\n    InitNode(nop, pnode);\n\n    pnode->sxBin.pnodeNext = nullptr;\n    pnode->sxBin.pnode1 = pnode1;\n    pnode->sxBin.pnode2 = pnode2;\n\n    // Statically detect if the add is a concat\n    if (!PHASE_OFF1(Js::ByteCodeConcatExprOptPhase))\n    {\n        // We can't flatten the concat expression if the LHS is not a flatten concat already\n        // e.g.  a + (<str> + b)\n        //      Side effect of ToStr(b) need to happen first before ToStr(a)\n        //      If we flatten the concat expression, we will do ToStr(a) before ToStr(b)\n        if ((nop == knopAdd) && (pnode1->CanFlattenConcatExpr() || pnode2->nop == knopStr))\n        {\n            pnode->grfpn |= fpnCanFlattenConcatExpr;\n        }\n    }\n\n    return pnode;\n}\n\n// Create nodes using parser allocator\n\nParseNodePtr Parser::CreateNode(OpCode nop, charcount_t ichMin)\n{\n    bool nodeAllowed = IsNodeAllowedInCurrentDeferralState(nop);\n    Assert(nodeAllowed);\n\n    Assert(nop >= 0 && nop < knopLim);\n    ParseNodePtr pnode;\n    int cb = (nop >= knopNone && nop < knopLim) ? g_mpnopcbNode[nop] : g_mpnopcbNode[knopEmpty];\n\n    pnode = (ParseNodePtr)m_nodeAllocator.Alloc(cb);\n    Assert(pnode != nullptr);\n\n    if (!m_deferringAST)\n    {\n        Assert(m_pCurrentAstSize != nullptr);\n        *m_pCurrentAstSize += cb;\n    }\n\n    InitNode(nop,pnode);\n\n    // default - may be changed\n    pnode->ichMin = ichMin;\n    if (m_pscan!= nullptr) {\n      pnode->ichLim = m_pscan->IchLimTok();\n    }\n    else pnode->ichLim=0;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateUniNode(OpCode nop, ParseNodePtr pnode1)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnUni));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnUni);\n\n    Assert(m_pCurrentAstSize != nullptr);\n    *m_pCurrentAstSize += kcbPnUni;\n\n    InitNode(nop, pnode);\n\n    pnode->sxUni.pnode1 = pnode1;\n    if (nullptr == pnode1)\n    {\n        // no ops\n        pnode->ichMin = m_pscan->IchMinTok();\n        pnode->ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        // 1 op\n        pnode->ichMin = pnode1->ichMin;\n        pnode->ichLim = pnode1->ichLim;\n        this->CheckArguments(pnode);\n    }\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBinNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2)\n{\n    Assert(!this->m_deferringAST);\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        // no ops\n        Assert(nullptr == pnode2);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        if (nullptr == pnode2)\n        {\n            // 1 op\n            ichMin = pnode1->ichMin;\n            ichLim = pnode1->ichLim;\n        }\n        else\n        {\n            // 2 ops\n            ichMin = pnode1->ichMin;\n            ichLim = pnode2->ichLim;\n            if (nop != knopDot && nop != knopIndex)\n            {\n                this->CheckArguments(pnode2);\n            }\n        }\n        if (nop != knopDot && nop != knopIndex)\n        {\n            this->CheckArguments(pnode1);\n        }\n    }\n\n    return CreateBinNode(nop, pnode1, pnode2, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateTriNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2, ParseNodePtr pnode3)\n{\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        // no ops\n        Assert(nullptr == pnode2);\n        Assert(nullptr == pnode3);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else if (nullptr == pnode2)\n    {\n        // 1 op\n        Assert(nullptr == pnode3);\n        ichMin = pnode1->ichMin;\n        ichLim = pnode1->ichLim;\n    }\n    else if (nullptr == pnode3)\n    {\n        // 2 op\n        ichMin = pnode1->ichMin;\n        ichLim = pnode2->ichLim;\n    }\n    else\n    {\n        // 3 ops\n        ichMin = pnode1->ichMin;\n        ichLim = pnode3->ichLim;\n    }\n\n    return CreateTriNode(nop, pnode1, pnode2, pnode3, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateBlockNode(charcount_t ichMin,charcount_t ichLim, PnodeBlockType blockType)\n{\n    return StaticCreateBlockNode(&m_nodeAllocator, ichMin, ichLim, this->m_nextBlockId++, blockType);\n}\n\nParseNodePtr\nParser::CreateCallNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2,charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnCall));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnCall);\n\n    Assert(m_pCurrentAstSize != nullptr);\n    *m_pCurrentAstSize += kcbPnCall;\n\n    InitNode(nop, pnode);\n\n    pnode->sxCall.pnodeTarget = pnode1;\n    pnode->sxCall.pnodeArgs = pnode2;\n    pnode->sxCall.argCount = 0;\n    pnode->sxCall.spreadArgCount = 0;\n    pnode->sxCall.callOfConstants = false;\n    pnode->sxCall.isApplyCall = false;\n    pnode->sxCall.isEvalCall = false;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateStrNode(IdentPtr pid)\n{\n    Assert(!this->m_deferringAST);\n\n    ParseNodePtr pnode = CreateNode(knopStr);\n    pnode->sxPid.pid=pid;\n    pnode->grfpn |= PNodeFlags::fpnCanFlattenConcatExpr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateIntNode(int32 lw)\n{\n    ParseNodePtr pnode = CreateNode(knopInt);\n    pnode->sxInt.lw = lw;\n    return pnode;\n}\n\n// Create Node with scanner limit\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeWithScanner()\n{\n    Assert(m_pscan != nullptr);\n    return CreateNodeWithScanner<nop>(m_pscan->IchMinTok());\n}\n\ntemplate <OpCode nop>\nParseNodePtr Parser::CreateNodeWithScanner(charcount_t ichMin)\n{\n    Assert(m_pscan != nullptr);\n    return CreateNodeT<nop>(ichMin, m_pscan->IchLimTok());\n}\n\nParseNodePtr Parser::CreateProgNodeWithScanner(bool isModuleSource)\n{\n    ParseNodePtr pnodeProg;\n\n    if (isModuleSource)\n    {\n        pnodeProg = CreateNodeWithScanner<knopModule>();\n\n        // knopModule is not actually handled anywhere since we would need to handle it everywhere we could\n        // have knopProg and it would be treated exactly the same except for import/export statements.\n        // We are only using it as a way to get the correct size for PnModule.\n        // Consider: Should we add a flag to PnProg which is false but set to true in PnModule?\n        //           If we do, it can't be a virtual method since the parse nodes are all in a union.\n        pnodeProg->nop = knopProg;\n    }\n    else\n    {\n        pnodeProg = CreateNodeWithScanner<knopProg>();\n    }\n\n    return pnodeProg;\n}\n\nParseNodePtr Parser::CreateCallNode(OpCode nop, ParseNodePtr pnode1, ParseNodePtr pnode2)\n{\n    charcount_t ichMin;\n    charcount_t ichLim;\n\n    if (nullptr == pnode1)\n    {\n        Assert(nullptr == pnode2);\n        ichMin = m_pscan->IchMinTok();\n        ichLim = m_pscan->IchLimTok();\n    }\n    else\n    {\n        if (nullptr == pnode2)\n        {\n            ichMin = pnode1->ichMin;\n            ichLim = pnode1->ichLim;\n        }\n        else\n        {\n            ichMin = pnode1->ichMin;\n            ichLim = pnode2->ichLim;\n        }\n        if (pnode1->nop == knopDot || pnode1->nop == knopIndex)\n        {\n            this->CheckArguments(pnode1->sxBin.pnode1);\n        }\n    }\n    return CreateCallNode(nop, pnode1, pnode2, ichMin, ichLim);\n}\n\nParseNodePtr Parser::CreateStrNodeWithScanner(IdentPtr pid)\n{\n    Assert(!this->m_deferringAST);\n\n    ParseNodePtr pnode = CreateNodeWithScanner<knopStr>();\n    pnode->sxPid.pid=pid;\n    pnode->grfpn |= PNodeFlags::fpnCanFlattenConcatExpr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateIntNodeWithScanner(int32 lw)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = CreateNodeWithScanner<knopInt>();\n    pnode->sxInt.lw = lw;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTempNode(ParseNode* initExpr)\n{\n    ParseNodePtr pnode = CreateNode(knopTemp, (charcount_t)0);\n    pnode->sxVar.pnodeInit =initExpr;\n    pnode->sxVar.pnodeNext = nullptr;\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTempRef(ParseNode* tempNode)\n{\n    ParseNodePtr pnode = CreateUniNode(knopTempRef, tempNode);\n    return pnode;\n}\n\nvoid Parser::CheckPidIsValid(IdentPtr pid, bool autoArgumentsObject)\n{\n    if (IsStrictMode())\n    {\n        // in strict mode, variable named 'eval' cannot be created\n        if (pid == wellKnownPropertyPids.eval)\n        {\n            Error(ERREvalUsage);\n        }\n        else if (pid == wellKnownPropertyPids.arguments && !autoArgumentsObject)\n        {\n            Error(ERRArgsUsage);\n        }\n    }\n}\n\n// CreateVarDecl needs m_ppnodeVar to be pointing to the right function.\n// Post-parsing rewriting during bytecode gen may have m_ppnodeVar pointing to the last parsed function.\n// This function sets up m_ppnodeVar to point to the given pnodeFnc and creates the new var declaration.\n// This prevents accidentally adding var declarations to the last parsed function.\nParseNodePtr Parser::AddVarDeclNode(IdentPtr pid, ParseNodePtr pnodeFnc)\n{\n    AnalysisAssert(pnodeFnc);\n\n    ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n\n    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n    while (*m_ppnodeVar != nullptr)\n    {\n        m_ppnodeVar = &(*m_ppnodeVar)->sxVar.pnodeNext;\n    }\n\n    ParseNodePtr pnode = CreateVarDeclNode(pid, STUnknown, false, 0, /* checkReDecl = */ false);\n\n    m_ppnodeVar = ppnodeVarSave;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateModuleImportDeclNode(IdentPtr localName)\n{\n    ParseNodePtr declNode = CreateBlockScopedDeclNode(localName, knopConstDecl);\n    Symbol* sym = declNode->sxVar.sym;\n\n    sym->SetIsModuleExportStorage(true);\n    sym->SetIsModuleImport(true);\n\n    return declNode;\n}\n\nParseNodePtr Parser::CreateVarDeclNode(IdentPtr pid, SymbolType symbolType, bool autoArgumentsObject, ParseNodePtr pnodeFnc, bool errorOnRedecl, bool *isRedecl)\n{\n    ParseNodePtr pnode = CreateDeclNode(knopVarDecl, pid, symbolType, errorOnRedecl, isRedecl);\n\n    // Append the variable to the end of the current variable list.\n    AssertMem(m_ppnodeVar);\n    pnode->sxVar.pnodeNext = *m_ppnodeVar;\n    *m_ppnodeVar = pnode;\n    if (nullptr != pid)\n    {\n        // this is not a temp - make sure temps go after this node\n        AssertMem(pid);\n        m_ppnodeVar = &pnode->sxVar.pnodeNext;\n        CheckPidIsValid(pid, autoArgumentsObject);\n    }\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBlockScopedDeclNode(IdentPtr pid, OpCode nodeType)\n{\n    Assert(nodeType == knopConstDecl || nodeType == knopLetDecl);\n\n    ParseNodePtr pnode = CreateDeclNode(nodeType, pid, STVariable, true);\n\n    if (nullptr != pid)\n    {\n        AssertMem(pid);\n        pid->SetIsLetOrConst();\n        AddVarDeclToBlock(pnode);\n        CheckPidIsValid(pid);\n    }\n\n    return pnode;\n}\n\nvoid Parser::AddVarDeclToBlock(ParseNode *pnode)\n{\n    Assert(pnode->nop == knopConstDecl || pnode->nop == knopLetDecl);\n\n    // Maintain a combined list of let and const declarations to keep\n    // track of declaration order.\n\n    AssertMem(m_currentBlockInfo->m_ppnodeLex);\n    *m_currentBlockInfo->m_ppnodeLex = pnode;\n    m_currentBlockInfo->m_ppnodeLex = &pnode->sxVar.pnodeNext;\n    pnode->sxVar.pnodeNext = nullptr;\n}\n\nvoid Parser::SetCurrentStatement(StmtNest *stmt)\n{\n    m_pstmtCur = stmt;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlockWithCapacity(PnodeBlockType blockType, ScopeType scopeType, int capacity)\n{\n    Scope *scope = nullptr;\n    // Block scopes are created lazily when we discover block-scoped content.\n    if (scopeType != ScopeType_Unknown && scopeType != ScopeType_Block)\n    {\n        scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, scopeType, capacity);\n        PushScope(scope);\n    }\n\n    return StartParseBlockHelper<buildAST>(blockType, scope, nullptr, nullptr);\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlock(PnodeBlockType blockType, ScopeType scopeType, ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    Scope *scope = nullptr;\n    // Block scopes are created lazily when we discover block-scoped content.\n    if (scopeType != ScopeType_Unknown && scopeType != ScopeType_Block)\n    {\n        scope = Anew(&m_nodeAllocator, Scope, &m_nodeAllocator, scopeType);\n        PushScope(scope);\n    }\n\n    return StartParseBlockHelper<buildAST>(blockType, scope, pnodeLabel, pLabelId);\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::StartParseBlockHelper(PnodeBlockType blockType, Scope *scope, ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    ParseNodePtr pnodeBlock = CreateBlockNode(blockType);\n    pnodeBlock->sxBlock.scope = scope;\n    BlockInfoStack *newBlockInfo = PushBlockInfo(pnodeBlock);\n\n    PushStmt<buildAST>(&newBlockInfo->pstmt, pnodeBlock, knopBlock, pnodeLabel, pLabelId);\n\n    return pnodeBlock;\n}\n\nvoid Parser::PushScope(Scope *scope)\n{\n    Assert(scope);\n    scope->SetEnclosingScope(m_currentScope);\n    m_currentScope = scope;\n}\n\nvoid Parser::PopScope(Scope *scope)\n{\n    Assert(scope == m_currentScope);\n    m_currentScope = scope->GetEnclosingScope();\n    scope->SetEnclosingScope(nullptr);\n}\n\nvoid Parser::PushFuncBlockScope(ParseNodePtr pnodeBlock, ParseNodePtr **ppnodeScopeSave, ParseNodePtr **ppnodeExprScopeSave)\n{\n    // Maintain the scope tree.\n\n    pnodeBlock->sxBlock.pnodeScopes = nullptr;\n    pnodeBlock->sxBlock.pnodeNext = nullptr;\n\n    // Insert this block into the active list of scopes (m_ppnodeExprScope or m_ppnodeScope).\n    // Save the current block's \"next\" pointer as the new endpoint of that list.\n    if (m_ppnodeExprScope)\n    {\n        *ppnodeScopeSave = m_ppnodeScope;\n\n        Assert(*m_ppnodeExprScope == nullptr);\n        *m_ppnodeExprScope = pnodeBlock;\n        *ppnodeExprScopeSave = &pnodeBlock->sxBlock.pnodeNext;\n    }\n    else\n    {\n        Assert(m_ppnodeScope);\n        Assert(*m_ppnodeScope == nullptr);\n        *m_ppnodeScope = pnodeBlock;\n        *ppnodeScopeSave = &pnodeBlock->sxBlock.pnodeNext;\n\n        *ppnodeExprScopeSave = m_ppnodeExprScope;\n    }\n\n    // Advance the global scope list pointer to the new block's child list.\n    m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n    // Set m_ppnodeExprScope to NULL to make that list inactive.\n    m_ppnodeExprScope = nullptr;\n}\n\nvoid Parser::PopFuncBlockScope(ParseNodePtr *ppnodeScopeSave, ParseNodePtr *ppnodeExprScopeSave)\n{\n    Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n    m_ppnodeExprScope = ppnodeExprScopeSave;\n\n    AssertMem(m_ppnodeScope);\n    Assert(nullptr == *m_ppnodeScope);\n    m_ppnodeScope = ppnodeScopeSave;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseBlock(ParseNodePtr pnodeLabel, LabelId* pLabelId)\n{\n    ParseNodePtr pnodeBlock = nullptr;\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n    pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block, pnodeLabel, pLabelId);\n\n    BlockInfoStack* outerBlockInfo = m_currentBlockInfo->pBlockInfoOuter;\n    if (outerBlockInfo != nullptr && outerBlockInfo->pnodeBlock != nullptr\n        && outerBlockInfo->pnodeBlock->sxBlock.scope != nullptr\n        && outerBlockInfo->pnodeBlock->sxBlock.scope->GetScopeType() == ScopeType_CatchParamPattern)\n    {\n        // If we are parsing the catch block then destructured params can have let declrations. Let's add them to the new block.\n        for (ParseNodePtr pnode = m_currentBlockInfo->pBlockInfoOuter->pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            PidRefStack* ref = PushPidRef(pnode->sxVar.sym->GetPid());\n            ref->SetSym(pnode->sxVar.sym);\n        }\n    }\n\n    ChkCurTok(tkLCurly, ERRnoLcurly);\n    ParseNodePtr * ppnodeList = nullptr;\n    if (buildAST)\n    {\n        PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        ppnodeList = &pnodeBlock->sxBlock.pnodeStmt;\n    }\n\n    ParseStmtList<buildAST>(ppnodeList);\n\n    if (buildAST)\n    {\n        PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n    }\n\n    FinishParseBlock(pnodeBlock);\n\n    ChkCurTok(tkRCurly, ERRnoRcurly);\n\n\n    return pnodeBlock;\n}\n\nvoid Parser::FinishParseBlock(ParseNode *pnodeBlock, bool needScanRCurly)\n{\n    Assert(m_currentBlockInfo != nullptr && pnodeBlock == m_currentBlockInfo->pnodeBlock);\n\n    if (needScanRCurly)\n    {\n        // Only update the ichLim if we were expecting an RCurly. If there is an\n        // expression body without a necessary RCurly, the correct ichLim will\n        // have been set already.\n        pnodeBlock->ichLim = m_pscan->IchLimTok();\n    }\n\n    BindPidRefs<false>(GetCurrentBlockInfo(), m_nextBlockId - 1);\n\n    PopStmt(&m_currentBlockInfo->pstmt);\n\n    PopBlockInfo();\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (scope)\n    {\n        PopScope(scope);\n    }\n}\n\nvoid Parser::FinishParseFncExprScope(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncExprScope)\n{\n    int fncExprScopeId = pnodeFncExprScope->sxBlock.blockId;\n    ParseNodePtr pnodeName = pnodeFnc->sxFnc.pnodeName;\n    if (pnodeName)\n    {\n        Assert(pnodeName->nop == knopVarDecl);\n        BindPidRefsInScope(pnodeName->sxVar.pid, pnodeName->sxVar.sym, fncExprScopeId);\n    }\n    FinishParseBlock(pnodeFncExprScope);\n}\n\ntemplate <const bool backgroundPidRef>\nvoid Parser::BindPidRefs(BlockInfoStack *blockInfo, uint maxBlockId)\n{\n    // We need to bind all assignments in order to emit assignment to 'const' error\n    int blockId = blockInfo->pnodeBlock->sxBlock.blockId;\n\n    Scope *scope = blockInfo->pnodeBlock->sxBlock.scope;\n    if (scope)\n    {\n        auto bindPidRefs = [blockId, maxBlockId, this](Symbol *sym)\n        {\n            ParseNodePtr pnode = sym->GetDecl();\n            IdentPtr pid;\n#if PROFILE_DICTIONARY\n            int depth = 0;\n#endif\n            Assert(pnode);\n            switch (pnode->nop)\n            {\n            case knopVarDecl:\n            case knopLetDecl:\n            case knopConstDecl:\n                pid = pnode->sxVar.pid;\n                if (backgroundPidRef)\n                {\n                    pid = this->m_pscan->m_phtbl->FindExistingPid(pid->Psz(), pid->Psz() + pid->Cch(), pid->Cch(), pid->Hash(), nullptr, nullptr\n#if PROFILE_DICTIONARY\n                                                                  , depth\n#endif\n                        );\n                    if (pid == nullptr)\n                    {\n                        break;\n                    }\n                }\n                this->BindPidRefsInScope(pid, sym, blockId, maxBlockId);\n                break;\n            case knopName:\n                pid = pnode->sxPid.pid;\n                if (backgroundPidRef)\n                {\n                    pid = this->m_pscan->m_phtbl->FindExistingPid(pid->Psz(), pid->Psz() + pid->Cch(), pid->Cch(), pid->Hash(), nullptr, nullptr\n#if PROFILE_DICTIONARY\n                                                                  , depth\n#endif\n                        );\n                    if (pid == nullptr)\n                    {\n                        break;\n                    }\n                }\n                this->BindPidRefsInScope(pid, sym, blockId, maxBlockId);\n                break;\n            default:\n                Assert(0);\n                break;\n            }\n        };\n\n        scope->ForEachSymbol(bindPidRefs);\n    }\n}\n\nvoid Parser::BindPidRefsInScope(IdentPtr pid, Symbol *sym, int blockId, uint maxBlockId)\n{\n    PidRefStack *ref, *nextRef, *lastRef = nullptr;\n    Js::LocalFunctionId funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    Assert(sym);\n\n    if (pid->GetIsModuleExport())\n    {\n        sym->SetIsModuleExportStorage(true);\n    }\n\n    bool hasFuncAssignment = sym->GetHasFuncAssignment();\n    bool doesEscape = false;\n\n    for (ref = pid->GetTopRef(); ref && ref->GetScopeId() >= blockId; ref = nextRef)\n    {\n        // Fix up sym* on PID ref.\n        Assert(!ref->GetSym() || ref->GetSym() == sym);\n        nextRef = ref->prev;\n        Assert(ref->GetScopeId() >= 0);\n        if ((uint)ref->GetScopeId() > maxBlockId)\n        {\n            lastRef = ref;\n            continue;\n        }\n        ref->SetSym(sym);\n        this->RemovePrevPidRef(pid, lastRef);\n\n        if (ref->IsAssignment())\n        {\n            sym->PromoteAssignmentState();\n            if (m_currentNodeFunc && sym->GetIsFormal())\n            {\n                m_currentNodeFunc->sxFnc.SetHasAnyWriteToFormals(true);                \n            }\n        }\n\n        if (ref->GetFuncScopeId() != funcId && !sym->GetIsGlobal() && !sym->GetIsModuleExportStorage())\n        {\n            Assert(ref->GetFuncScopeId() > funcId);\n            sym->SetHasNonLocalReference();\n        }\n\n        if (ref->IsFuncAssignment())\n        {\n            hasFuncAssignment = true;\n        }\n\n        if (ref->IsEscape())\n        {\n            doesEscape = true;\n        }\n\n        if (m_currentNodeFunc && doesEscape && hasFuncAssignment)\n        {\n            if (m_sourceContextInfo ? \n                    !PHASE_OFF_RAW(Js::DisableStackFuncOnDeferredEscapePhase, m_sourceContextInfo->sourceContextId, m_currentNodeFunc->sxFnc.functionId) :\n                    !PHASE_OFF1(Js::DisableStackFuncOnDeferredEscapePhase))\n            {\n                m_currentNodeFunc->sxFnc.SetNestedFuncEscapes();\n            }\n        }\n\n        if (ref->GetScopeId() == blockId)\n        {\n            break;\n        }\n    }\n}\n\nvoid Parser::MarkEscapingRef(ParseNodePtr pnode, IdentToken *pToken)\n{\n    if (m_currentNodeFunc == nullptr)\n    {\n        return;\n    }\n    if (pnode && pnode->nop == knopFncDecl)\n    {\n        this->SetNestedFuncEscapes();\n    }\n    else if (pToken->pid)\n    {\n        PidRefStack *pidRef = pToken->pid->GetTopRef();\n        if (pidRef->sym)\n        {\n            if (pidRef->sym->GetSymbolType() == STFunction)\n            {\n                this->SetNestedFuncEscapes();\n            }\n        }\n        else\n        {\n            pidRef->isEscape = true;\n        }\n    }\n}\n\nvoid Parser::SetNestedFuncEscapes() const\n{\n    if (m_sourceContextInfo ? \n            !PHASE_OFF_RAW(Js::DisableStackFuncOnDeferredEscapePhase, m_sourceContextInfo->sourceContextId, m_currentNodeFunc->sxFnc.functionId) :\n            !PHASE_OFF1(Js::DisableStackFuncOnDeferredEscapePhase))\n    {\n        m_currentNodeFunc->sxFnc.SetNestedFuncEscapes();\n    }\n}\n\nvoid Parser::PopStmt(StmtNest *pStmt)\n{\n    Assert(pStmt == m_pstmtCur);\n    SetCurrentStatement(m_pstmtCur->pstmtOuter);\n}\n\nBlockInfoStack *Parser::PushBlockInfo(ParseNodePtr pnodeBlock)\n{\n    BlockInfoStack *newBlockInfo = (BlockInfoStack *)m_nodeAllocator.Alloc(sizeof(BlockInfoStack));\n    Assert(nullptr != newBlockInfo);\n\n    newBlockInfo->pnodeBlock = pnodeBlock;\n    newBlockInfo->pBlockInfoOuter = m_currentBlockInfo;\n    newBlockInfo->m_ppnodeLex = &pnodeBlock->sxBlock.pnodeLexVars;\n\n    if (pnodeBlock->sxBlock.blockType != PnodeBlockType::Regular)\n    {\n        newBlockInfo->pBlockInfoFunction = newBlockInfo;\n    }\n    else\n    {\n        Assert(m_currentBlockInfo);\n        newBlockInfo->pBlockInfoFunction = m_currentBlockInfo->pBlockInfoFunction;\n    }\n\n    m_currentBlockInfo = newBlockInfo;\n    return newBlockInfo;\n}\n\nvoid Parser::PopBlockInfo()\n{\n    Assert(m_currentBlockInfo);\n    PopDynamicBlock();\n    m_currentBlockInfo = m_currentBlockInfo->pBlockInfoOuter;\n}\n\nvoid Parser::PushDynamicBlock()\n{\n    Assert(GetCurrentBlock());\n    int blockId = GetCurrentBlock()->sxBlock.blockId;\n    if (m_currentDynamicBlock && m_currentDynamicBlock->id == blockId)\n    {\n        return;\n    }\n    BlockIdsStack *info = (BlockIdsStack *)m_nodeAllocator.Alloc(sizeof(BlockIdsStack));\n    if (nullptr == info)\n    {\n        Error(ERRnoMemory);\n    }\n\n    info->id = blockId;\n    info->prev = m_currentDynamicBlock;\n    m_currentDynamicBlock = info;\n}\n\nvoid Parser::PopDynamicBlock()\n{\n    int blockId = GetCurrentDynamicBlockId();\n    if (GetCurrentBlock()->sxBlock.blockId != blockId || blockId == -1)\n    {\n        return;\n    }\n    Assert(m_currentDynamicBlock);\n    for (BlockInfoStack *blockInfo = m_currentBlockInfo; blockInfo; blockInfo = blockInfo->pBlockInfoOuter)\n    {\n        for (ParseNodePtr pnodeDecl = blockInfo->pnodeBlock->sxBlock.pnodeLexVars;\n             pnodeDecl;\n             pnodeDecl = pnodeDecl->sxVar.pnodeNext)\n        {\n            this->SetPidRefsInScopeDynamic(pnodeDecl->sxVar.pid, blockId);\n        }\n    }\n\n    m_currentDynamicBlock = m_currentDynamicBlock->prev;\n}\n\nint Parser::GetCurrentDynamicBlockId() const\n{\n    return m_currentDynamicBlock ? m_currentDynamicBlock->id : -1;\n}\n\nParseNode *Parser::GetCurrentFunctionNode()\n{\n    if (m_currentNodeDeferredFunc != nullptr)\n    {\n        return m_currentNodeDeferredFunc;\n    }\n    else if (m_currentNodeFunc != nullptr)\n    {\n        return m_currentNodeFunc;\n    }\n    else\n    {\n        AssertMsg(GetFunctionBlock()->sxBlock.blockType == PnodeBlockType::Global,\n            \"Most likely we are trying to find a syntax error, related to 'let' or 'const' in deferred parsing mode with disabled support of 'let' and 'const'\");\n        return m_currentNodeProg;\n    }\n}\n\nParseNode *Parser::GetCurrentNonLambdaFunctionNode()\n{\n    if (m_currentNodeNonLambdaDeferredFunc != nullptr)\n    {\n        return m_currentNodeNonLambdaDeferredFunc;\n    }\n    return m_currentNodeNonLambdaFunc;\n\n}\nvoid Parser::RegisterRegexPattern(UnifiedRegex::RegexPattern *const regexPattern)\n{\n    Assert(regexPattern);\n\n    // ensure a no-throw add behavior here, to catch out of memory exceptions, using the guest arena allocator\n    if (!m_registeredRegexPatterns.PrependNoThrow(m_scriptContext->GetGuestArena(), regexPattern))\n    {\n        Parser::Error(ERRnoMemory);\n    }\n}\n\nvoid Parser::CaptureState(ParserState *state)\n{\n    Assert(state != nullptr);\n\n    state->m_funcInArraySave = m_funcInArray;\n    state->m_funcInArrayDepthSave = m_funcInArrayDepth;\n    state->m_nestedCountSave = *m_pnestedCount;\n    state->m_ppnodeScopeSave = m_ppnodeScope;\n    state->m_ppnodeExprScopeSave = m_ppnodeExprScope;\n    state->m_pCurrentAstSizeSave = m_pCurrentAstSize;\n    state->m_nextBlockId = m_nextBlockId;\n\n    Assert(state->m_ppnodeScopeSave == nullptr || *state->m_ppnodeScopeSave == nullptr);\n    Assert(state->m_ppnodeExprScopeSave == nullptr || *state->m_ppnodeExprScopeSave == nullptr);\n\n#if DEBUG\n    state->m_currentBlockInfo = m_currentBlockInfo;\n#endif\n}\n\nvoid Parser::RestoreStateFrom(ParserState *state)\n{\n    Assert(state != nullptr);\n    Assert(state->m_currentBlockInfo == m_currentBlockInfo);\n\n    m_funcInArray = state->m_funcInArraySave;\n    m_funcInArrayDepth = state->m_funcInArrayDepthSave;\n    *m_pnestedCount = state->m_nestedCountSave;\n    m_pCurrentAstSize = state->m_pCurrentAstSizeSave;\n    m_nextBlockId = state->m_nextBlockId;\n\n    if (state->m_ppnodeScopeSave != nullptr)\n    {\n        *state->m_ppnodeScopeSave = nullptr;\n    }\n\n    if (state->m_ppnodeExprScopeSave != nullptr)\n    {\n        *state->m_ppnodeExprScopeSave = nullptr;\n    }\n\n    m_ppnodeScope = state->m_ppnodeScopeSave;\n    m_ppnodeExprScope = state->m_ppnodeExprScopeSave;\n}\n\nvoid Parser::AddToNodeListEscapedUse(ParseNode ** ppnodeList, ParseNode *** pppnodeLast,\n                           ParseNode * pnodeAdd)\n{\n    AddToNodeList(ppnodeList, pppnodeLast, pnodeAdd);\n    pnodeAdd->SetIsInList();\n}\n\nvoid Parser::AddToNodeList(ParseNode ** ppnodeList, ParseNode *** pppnodeLast,\n                           ParseNode * pnodeAdd)\n{\n    Assert(!this->m_deferringAST);\n    if (nullptr == *pppnodeLast)\n    {\n        // should be an empty list\n        Assert(nullptr == *ppnodeList);\n\n        *ppnodeList = pnodeAdd;\n        *pppnodeLast = ppnodeList;\n    }\n    else\n    {\n        //\n        AssertNodeMem(*ppnodeList);\n        AssertNodeMem(**pppnodeLast);\n\n        ParseNode *pnodeT = CreateBinNode(knopList, **pppnodeLast, pnodeAdd);\n        **pppnodeLast = pnodeT;\n        *pppnodeLast = &pnodeT->sxBin.pnode2;\n    }\n}\n\n// Check reference to \"arguments\" that indicates the object may escape.\nvoid Parser::CheckArguments(ParseNodePtr pnode)\n{\n    if (m_currentNodeFunc && this->NodeIsIdent(pnode, wellKnownPropertyPids.arguments))\n    {\n        m_currentNodeFunc->sxFnc.SetHasHeapArguments();\n    }\n}\n\n// Check use of \"arguments\" that requires instantiation of the object.\nvoid Parser::CheckArgumentsUse(IdentPtr pid, ParseNodePtr pnodeFnc)\n{\n    if (pid == wellKnownPropertyPids.arguments)\n    {\n        if (pnodeFnc != nullptr && pnodeFnc != m_currentNodeProg)\n        {\n            pnodeFnc->sxFnc.SetUsesArguments(TRUE);\n        }\n        else\n        {\n            m_UsesArgumentsAtGlobal = true;\n        }\n    }\n}\n\nvoid Parser::CheckStrictModeEvalArgumentsUsage(IdentPtr pid, ParseNodePtr pnode)\n{\n    if (pid != nullptr)\n    {\n        // In strict mode, 'eval' / 'arguments' cannot be assigned to.\n        if ( pid == wellKnownPropertyPids.eval)\n        {\n            Error(ERREvalUsage, pnode);\n        }\n\n        if (pid == wellKnownPropertyPids.arguments)\n        {\n            Error(ERRArgsUsage, pnode);\n        }\n    }\n}\n\nvoid Parser::ReduceDeferredScriptLength(size_t chars)\n{\n    // If we're in deferred mode, subtract the given char count from the total length,\n    // and see if this puts us under the deferral threshold.\n    if ((m_grfscr & fscrDeferFncParse) &&\n        (\n            PHASE_OFF1(Js::DeferEventHandlersPhase) ||\n            (m_grfscr & fscrGlobalCode)\n        )\n    )\n    {\n        if (m_length > chars)\n        {\n            m_length -= chars;\n        }\n        else\n        {\n            m_length = 0;\n        }\n        if (m_length < Parser::GetDeferralThreshold(this->m_sourceContextInfo->IsSourceProfileLoaded()))\n        {\n            // Stop deferring.\n            m_grfscr &= ~fscrDeferFncParse;\n            m_stoppedDeferredParse = TRUE;\n        }\n    }\n}\n\n/***************************************************************************\nLook for an existing label with the given name.\n***************************************************************************/\nBOOL Parser::PnodeLabelNoAST(IdentToken* pToken, LabelId* pLabelIdList)\n{\n    StmtNest* pStmt;\n    LabelId* pLabelId;\n\n    // Look in the label stack.\n    for (pStmt = m_pstmtCur; pStmt != nullptr; pStmt = pStmt->pstmtOuter)\n    {\n        for (pLabelId = pStmt->pLabelId; pLabelId != nullptr; pLabelId = pLabelId->next)\n        {\n            if (pLabelId->pid == pToken->pid)\n                return TRUE;\n        }\n    }\n\n    // Also look in the pnodeLabels list.\n    for (pLabelId = pLabelIdList; pLabelId != nullptr; pLabelId = pLabelId->next)\n    {\n        if (pLabelId->pid == pToken->pid)\n            return TRUE;\n    }\n\n    return FALSE;\n}\n\nvoid Parser::EnsureStackAvailable()\n{\n    if (!m_scriptContext->GetThreadContext()->IsStackAvailable(Js::Constants::MinStackCompile))\n    {\n        Error(ERRnoMemory);\n    }\n}\n\nvoid Parser::ThrowNewTargetSyntaxErrForGlobalScope()\n{\n    if (GetCurrentNonLambdaFunctionNode() != nullptr)\n    {\n        return;\n    }\n\n    if ((this->m_grfscr & fscrEval) != 0)\n    {\n        Js::JavascriptFunction * caller = nullptr;\n        if (Js::JavascriptStackWalker::GetCaller(&caller, m_scriptContext))\n        {\n            Js::FunctionBody * callerBody = caller->GetFunctionBody();\n            Assert(callerBody);\n            if (!callerBody->GetIsGlobalFunc() && !(callerBody->IsLambda() && callerBody->GetEnclosedByGlobalFunc()))\n            {\n                return;\n            }\n        }\n    }\n\n    Error(ERRInvalidNewTarget);\n }\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMetaProperty(tokens metaParentKeyword, charcount_t ichMin, _Out_opt_ BOOL* pfCanAssign)\n{\n    AssertMsg(metaParentKeyword == tkNEW, \"Only supported for tkNEW parent keywords\");\n    AssertMsg(this->m_token.tk == tkDot, \"We must be currently sitting on the dot after the parent keyword\");\n\n    m_pscan->Scan();\n\n    if (this->m_token.tk == tkID && this->m_token.GetIdentifier(m_phtbl) == this->GetTargetPid())\n    {\n        ThrowNewTargetSyntaxErrForGlobalScope();\n        if (pfCanAssign)\n        {\n            *pfCanAssign = FALSE;\n        }\n        if (buildAST)\n        {\n            return CreateNodeWithScanner<knopNewTarget>(ichMin);\n        }\n    }\n    else\n    {\n        Error(ERRsyntax);\n    }\n\n    return nullptr;\n}\n\ntemplate<bool buildAST> \nvoid Parser::ParseNamedImportOrExportClause(ModuleImportOrExportEntryList* importOrExportEntryList, bool isExportClause)\n{\n    Assert(m_token.tk == tkLCurly);\n    Assert(importOrExportEntryList != nullptr);\n\n    m_pscan->Scan();\n\n    while (m_token.tk != tkRCurly && m_token.tk != tkEOF)\n    {\n        tokens firstToken = m_token.tk;\n\n        if (!(m_token.IsIdentifier() || m_token.IsReservedWord()))\n        {\n            Error(ERRsyntax);\n        }\n\n        IdentPtr identifierName = m_token.GetIdentifier(m_phtbl);\n        IdentPtr identifierAs = identifierName;\n\n        m_pscan->Scan();\n\n        if (m_token.tk == tkID)\n        {\n            // We have the pattern \"IdentifierName as\"\n            if (wellKnownPropertyPids.as != m_token.GetIdentifier(m_phtbl))\n            {\n                Error(ERRsyntax);\n            }\n\n            m_pscan->Scan();\n\n            // If we are parsing an import statement, the token after 'as' must be a BindingIdentifier.\n            if (!isExportClause)\n            {\n                ChkCurTokNoScan(tkID, ERRsyntax);\n            }\n\n            if (!(m_token.IsIdentifier() || m_token.IsReservedWord()))\n            {\n                Error(ERRsyntax);\n            }\n\n            identifierAs = m_token.GetIdentifier(m_phtbl);\n\n            // Scan to the next token.\n            m_pscan->Scan();\n        }\n        else if (!isExportClause && firstToken != tkID)\n        {\n            // If we are parsing an import statement and this ImportSpecifier clause did not have\n            // 'as ImportedBinding' at the end of it, identifierName must be a BindingIdentifier.\n            Error(ERRsyntax);\n        }\n\n        if (m_token.tk == tkComma)\n        {\n            // Consume a trailing comma\n            m_pscan->Scan();\n        }\n\n        if (buildAST)\n        {\n            // The name we will use 'as' this import/export is a binding identifier in import statements.\n            if (!isExportClause)\n            {\n                CreateModuleImportDeclNode(identifierAs);\n                AddModuleImportOrExportEntry(importOrExportEntryList, identifierName, identifierAs, nullptr, nullptr);\n            }\n            else\n            {\n                identifierName->SetIsModuleExport();\n                AddModuleImportOrExportEntry(importOrExportEntryList, nullptr, identifierName, identifierAs, nullptr);\n            }\n        }\n    }\n\n    // Final token in a named import or export clause must be a '}'\n    ChkCurTokNoScan(tkRCurly, ERRsyntax);\n}\n\nIdentPtrList* Parser::GetRequestedModulesList()\n{\n    return m_currentNodeProg->sxModule.requestedModules;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleImportEntryList()\n{\n    return m_currentNodeProg->sxModule.importEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleLocalExportEntryList()\n{\n    return m_currentNodeProg->sxModule.localExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleIndirectExportEntryList()\n{\n    return m_currentNodeProg->sxModule.indirectExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::GetModuleStarExportEntryList()\n{\n    return m_currentNodeProg->sxModule.starExportEntries;\n}\n\nIdentPtrList* Parser::EnsureRequestedModulesList()\n{\n    if (m_currentNodeProg->sxModule.requestedModules == nullptr)\n    {\n        m_currentNodeProg->sxModule.requestedModules = Anew(&m_nodeAllocator, IdentPtrList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.requestedModules;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleImportEntryList()\n{\n    if (m_currentNodeProg->sxModule.importEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.importEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.importEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleLocalExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.localExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.localExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.localExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleIndirectExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.indirectExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.indirectExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.indirectExportEntries;\n}\n\nModuleImportOrExportEntryList* Parser::EnsureModuleStarExportEntryList()\n{\n    if (m_currentNodeProg->sxModule.starExportEntries == nullptr)\n    {\n        m_currentNodeProg->sxModule.starExportEntries = Anew(&m_nodeAllocator, ModuleImportOrExportEntryList, &m_nodeAllocator);\n    }\n    return m_currentNodeProg->sxModule.starExportEntries;\n}\n\nvoid Parser::AddModuleSpecifier(IdentPtr moduleRequest)\n{\n    IdentPtrList* requestedModulesList = EnsureRequestedModulesList();\n\n    if (!requestedModulesList->Has(moduleRequest))\n    {\n        requestedModulesList->Prepend(moduleRequest);\n    }\n}\n\nModuleImportOrExportEntry* Parser::AddModuleImportOrExportEntry(ModuleImportOrExportEntryList* importOrExportEntryList, ModuleImportOrExportEntry* importOrExportEntry)\n{\n    if (importOrExportEntry->exportName != nullptr)\n    {\n        CheckForDuplicateExportEntry(importOrExportEntryList, importOrExportEntry->exportName);\n    }\n\n    importOrExportEntryList->Prepend(*importOrExportEntry);\n\n    return importOrExportEntry;\n}\n\nModuleImportOrExportEntry* Parser::AddModuleImportOrExportEntry(ModuleImportOrExportEntryList* importOrExportEntryList, IdentPtr importName, IdentPtr localName, IdentPtr exportName, IdentPtr moduleRequest)\n{\n    ModuleImportOrExportEntry* importOrExportEntry = Anew(&m_nodeAllocator, ModuleImportOrExportEntry);\n\n    importOrExportEntry->importName = importName;\n    importOrExportEntry->localName = localName;\n    importOrExportEntry->exportName = exportName;\n    importOrExportEntry->moduleRequest = moduleRequest;\n\n    return AddModuleImportOrExportEntry(importOrExportEntryList, importOrExportEntry);\n}\n\nvoid Parser::AddModuleLocalExportEntry(ParseNodePtr varDeclNode)\n{\n    Assert(varDeclNode->nop == knopVarDecl || varDeclNode->nop == knopLetDecl || varDeclNode->nop == knopConstDecl);\n\n    IdentPtr localName = varDeclNode->sxVar.pid;\n    varDeclNode->sxVar.sym->SetIsModuleExportStorage(true);\n\n    AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, localName, nullptr);\n}\n\nvoid Parser::CheckForDuplicateExportEntry(ModuleImportOrExportEntryList* exportEntryList, IdentPtr exportName)\n{\n    ModuleImportOrExportEntry* findResult = exportEntryList->Find([&](ModuleImportOrExportEntry exportEntry)\n    {\n        if (exportName == exportEntry.exportName)\n        {\n            return true;\n        }\n        return false;\n    });\n\n    if (findResult != nullptr)\n    {\n        Error(ERRsyntax);\n    }\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseImportClause(ModuleImportOrExportEntryList* importEntryList, bool parsingAfterComma)\n{\n    bool parsedNamespaceOrNamedImport = false;\n\n    switch (m_token.tk)\n    {\n    case tkID:\n        // This is the default binding identifier.\n\n        // If we already saw a comma in the import clause, this is a syntax error.\n        if (parsingAfterComma)\n        {\n            Error(ERRsyntax);\n        }\n\n        if (buildAST)\n        {\n            IdentPtr localName = m_token.GetIdentifier(m_phtbl);\n            IdentPtr importName = wellKnownPropertyPids._default;\n\n            CreateModuleImportDeclNode(localName);\n            AddModuleImportOrExportEntry(importEntryList, importName, localName, nullptr, nullptr);\n        }\n\n        break;\n\n    case tkLCurly:\n        // This begins a list of named imports.\n        ParseNamedImportOrExportClause<buildAST>(importEntryList, false);\n\n        parsedNamespaceOrNamedImport = true;\n        break;\n\n    case tkStar:\n        // This begins a namespace import clause.\n        // \"* as ImportedBinding\"\n\n        // Token following * must be the identifier 'as'\n        m_pscan->Scan();\n        if (m_token.tk != tkID || wellKnownPropertyPids.as != m_token.GetIdentifier(m_phtbl))\n        {\n            Error(ERRsyntax);\n        }\n\n        // Token following 'as' must be a binding identifier.\n        m_pscan->Scan();\n        ChkCurTokNoScan(tkID, ERRsyntax);\n\n        if (buildAST)\n        {\n            IdentPtr localName = m_token.GetIdentifier(m_phtbl);\n            IdentPtr importName = wellKnownPropertyPids._star;\n\n            CreateModuleImportDeclNode(localName);\n            AddModuleImportOrExportEntry(importEntryList, importName, localName, nullptr, nullptr);\n        }\n\n        parsedNamespaceOrNamedImport = true;\n        break;\n\n    default:\n        Error(ERRsyntax);\n    }\n\n    m_pscan->Scan();\n\n    if (m_token.tk == tkComma)\n    {\n        // There cannot be more than one comma in a module import clause.\n        // There cannot be a namespace import or named imports list on the left of the comma in a module import clause.\n        if (parsingAfterComma || parsedNamespaceOrNamedImport)\n        {\n            Error(ERRsyntax);\n        }\n\n        m_pscan->Scan();\n\n        ParseImportClause<buildAST>(importEntryList, true);\n    }\n}\n\nbool Parser::IsImportOrExportStatementValidHere()\n{\n    ParseNodePtr curFunc = GetCurrentFunctionNode();\n\n    // Import must be located in the top scope of the module body.\n    return curFunc->nop == knopFncDecl\n        && curFunc->sxFnc.IsModule()\n        && this->m_currentBlockInfo->pnodeBlock == curFunc->sxFnc.pnodeBodyScope\n        && (this->m_grfscr & fscrEvalCode) != fscrEvalCode\n        && this->m_tryCatchOrFinallyDepth == 0;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseImportDeclaration()\n{\n    Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n    Assert(m_token.tk == tkIMPORT);\n\n    if (!IsImportOrExportStatementValidHere())\n    {\n        Error(ERRInvalidModuleImportOrExport);\n    }\n\n    // We just parsed an import token. Next valid token is *, {, string constant, or binding identifier.\n    m_pscan->Scan();\n\n    if (m_token.tk == tkStrCon)\n    {\n        // This import declaration has no import clause.\n        // \"import ModuleSpecifier;\"\n        if (buildAST)\n        {\n            AddModuleSpecifier(m_token.GetStr());\n        }\n\n        // Scan past the module identifier.\n        m_pscan->Scan();\n    }\n    else\n    {\n        ModuleImportOrExportEntryList importEntryList(&m_nodeAllocator);\n\n        // Parse the import clause (default binding can only exist before the comma).\n        ParseImportClause<buildAST>(&importEntryList);\n\n        // Token following import clause must be the identifier 'from'\n        IdentPtr moduleSpecifier = ParseImportOrExportFromClause<buildAST>(true);\n\n        if (buildAST)\n        {\n            Assert(moduleSpecifier != nullptr);\n\n            AddModuleSpecifier(moduleSpecifier);\n\n            importEntryList.Map([this, moduleSpecifier](ModuleImportOrExportEntry& importEntry) {\n                importEntry.moduleRequest = moduleSpecifier;\n                AddModuleImportOrExportEntry(EnsureModuleImportEntryList(), &importEntry);\n            });\n        }\n\n        importEntryList.Clear();\n    }\n\n    // Import statement is actually a nop, we hoist all the imported bindings to the top of the module.\n    return nullptr;\n}\n\ntemplate<bool buildAST>\nIdentPtr Parser::ParseImportOrExportFromClause(bool throwIfNotFound)\n{\n    IdentPtr moduleSpecifier = nullptr;\n\n    if (m_token.tk == tkID && wellKnownPropertyPids.from == m_token.GetIdentifier(m_phtbl))\n    {\n        m_pscan->Scan();\n\n        // Token following the 'from' token must be a string constant - the module specifier.\n        ChkCurTokNoScan(tkStrCon, ERRsyntax);\n\n        if (buildAST)\n        {\n            moduleSpecifier = m_token.GetStr();\n        }\n\n        m_pscan->Scan();\n    }\n    else if (throwIfNotFound)\n    {\n        Error(ERRsyntax);\n    }\n\n    return moduleSpecifier;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseDefaultExportClause()\n{\n    Assert(m_token.tk == tkDEFAULT);\n\n    m_pscan->Scan();\n    ParseNodePtr pnode = nullptr;\n    ushort flags = fFncNoFlgs;\n\n    switch (m_token.tk)\n    {\n    case tkCLASS:\n        {\n            if (!m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n            {\n                goto LDefault;\n            }\n\n            // Before we parse the class itself we need to know if the class has an identifier name.\n            // If it does, we'll treat this class as an ordinary class declaration which will bind\n            // it to that name. Otherwise the class should parse as a nameless class expression and\n            // bind only to the export binding.\n            BOOL classHasName = false;\n            RestorePoint parsedClass;\n            m_pscan->Capture(&parsedClass);\n            m_pscan->Scan();\n\n            if (m_token.tk == tkID)\n            {\n                classHasName = true;\n            }\n\n            m_pscan->SeekTo(parsedClass);\n            pnode = ParseClassDecl<buildAST>(classHasName, nullptr, nullptr, nullptr);\n\n            if (buildAST)\n            {\n                AnalysisAssert(pnode != nullptr);\n                Assert(pnode->nop == knopClassDecl);\n\n                pnode->sxClass.SetIsDefaultModuleExport(true);\n            }\n\n            break;\n        }\n    case tkID:\n        // If we parsed an async token, it could either modify the next token (if it is a\n        // function token) or it could be an identifier (let async = 0; export default async;).\n        // To handle both cases, when we parse an async token we need to keep the parser state\n        // and rewind if the next token is not function.\n        if (wellKnownPropertyPids.async == m_token.GetIdentifier(m_phtbl))\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            m_pscan->Scan();\n            if (m_token.tk == tkFUNCTION)\n            {\n                // Token after async is function, consume the async token and continue to parse the\n                // function as an async function.\n                flags |= fFncAsync;\n                goto LFunction;\n            }\n            // Token after async is not function, no idea what the async token is supposed to mean\n            // so rewind and let the default case handle it.\n            m_pscan->SeekTo(parsedAsync);\n        }\n        goto LDefault;\n        break;\n    case tkFUNCTION:\n        {\nLFunction:\n            // We just parsed a function token but we need to figure out if the function\n            // has an identifier name or not before we call the helper.\n            RestorePoint parsedFunction;\n            m_pscan->Capture(&parsedFunction);\n            m_pscan->Scan();\n\n            if (m_token.tk == tkStar)\n            {\n                // If we saw 'function*' that indicates we are going to parse a generator,\n                // but doesn't tell us if the generator has an identifier or not.\n                // Skip the '*' token for now as it doesn't matter yet.\n                m_pscan->Scan();\n            }\n\n            // We say that if the function has an identifier name, it is a 'normal' declaration\n            // and should create a binding to that identifier as well as one for our default export.\n            if (m_token.tk == tkID)\n            {\n                flags |= fFncDeclaration;\n            }\n            else\n            {\n                flags |= fFncNoName;\n            }\n\n            // Rewind back to the function token and let the helper handle the parsing.\n            m_pscan->SeekTo(parsedFunction);\n            pnode = ParseFncDecl<buildAST>(flags);\n            \n            if (buildAST)\n            {\n                AnalysisAssert(pnode != nullptr);\n                Assert(pnode->nop == knopFncDecl);\n\n                pnode->sxFnc.SetIsDefaultModuleExport(true);\n            }\n            break;\n        }\n    default:\nLDefault:\n        {\n            ParseNodePtr pnodeExpression = ParseExpr<buildAST>();\n\n            // Consider: Can we detect this syntax error earlier?\n            if (pnodeExpression && pnodeExpression->nop == knopComma)\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                AnalysisAssert(pnodeExpression != nullptr);\n\n                // Mark this node as the default module export. We need to make sure it is put into the correct\n                // module export slot when we emit the node.\n                pnode = CreateNode(knopExportDefault);\n                pnode->sxExportDefault.pnodeExpr = pnodeExpression;\n            }\n            break;\n        }\n    }\n\n    IdentPtr exportName = wellKnownPropertyPids._default;\n    IdentPtr localName = wellKnownPropertyPids._starDefaultStar;\n    AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, exportName, nullptr);\n\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseExportDeclaration()\n{\n    Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n    Assert(m_token.tk == tkEXPORT);\n\n    if (!IsImportOrExportStatementValidHere())\n    {\n        Error(ERRInvalidModuleImportOrExport);\n    }\n\n    ParseNodePtr pnode = nullptr;\n    IdentPtr moduleIdentifier = nullptr;\n    tokens declarationType;\n\n    // We just parsed an export token. Next valid tokens are *, {, var, let, const, async, function, class, default.\n    m_pscan->Scan();\n\n    switch (m_token.tk)\n    {\n    case tkStar:\n        m_pscan->Scan();\n\n        // A star token in an export declaration must be followed by a from clause which begins with a token 'from'.\n        moduleIdentifier = ParseImportOrExportFromClause<buildAST>(true);\n\n        if (buildAST)\n        {\n            Assert(moduleIdentifier != nullptr);\n\n            AddModuleSpecifier(moduleIdentifier);\n            IdentPtr importName = wellKnownPropertyPids._star;\n\n            AddModuleImportOrExportEntry(EnsureModuleStarExportEntryList(), importName, nullptr, nullptr, moduleIdentifier);\n        }\n\n        break;\n\n    case tkLCurly:\n        {\n            ModuleImportOrExportEntryList exportEntryList(&m_nodeAllocator);\n\n            ParseNamedImportOrExportClause<buildAST>(&exportEntryList, true);\n\n            m_pscan->Scan();\n\n            // Export clause may be followed by a from clause.\n            moduleIdentifier = ParseImportOrExportFromClause<buildAST>(false);\n\n            if (buildAST)\n            {\n                if (moduleIdentifier != nullptr)\n                {\n                    AddModuleSpecifier(moduleIdentifier);\n                }\n\n                exportEntryList.Map([this, moduleIdentifier](ModuleImportOrExportEntry& exportEntry) {\n                    if (moduleIdentifier != nullptr)\n                    {\n                        exportEntry.moduleRequest = moduleIdentifier;\n\n                        // We need to swap localname and importname when this is a re-export.\n                        exportEntry.importName = exportEntry.localName;\n                        exportEntry.localName = nullptr;\n\n                        AddModuleImportOrExportEntry(EnsureModuleIndirectExportEntryList(), &exportEntry);\n                    }\n                    else\n                    {\n                        AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), &exportEntry);\n                    }\n                });\n\n                exportEntryList.Clear();\n            }\n        }\n        break;\n\n    case tkID:\n        {\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n\n            if (wellKnownPropertyPids.let == pid)\n            {\n                declarationType = tkLET;\n                goto ParseVarDecl;\n            }\n            if (wellKnownPropertyPids.async == pid && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n            {\n                // In module export statements, async token is only valid if it's followed by function.\n                // We need to check here because ParseStatement would think 'async = 20' is a var decl.\n                RestorePoint parsedAsync;\n                m_pscan->Capture(&parsedAsync);\n                m_pscan->Scan();\n                if (m_token.tk == tkFUNCTION)\n                {\n                    // Token after async is function, rewind to the async token and let ParseStatement handle it.\n                    m_pscan->SeekTo(parsedAsync);\n                    goto ParseFunctionDecl;\n                }\n                // Token after async is not function, it's a syntax error.\n            }\n            goto ErrorToken;\n        }\n    case tkVAR:\n    case tkLET:\n    case tkCONST:\n        {\n            declarationType = m_token.tk;\n\nParseVarDecl:\n            m_pscan->Scan();\n\n            pnode = ParseVariableDeclaration<buildAST>(declarationType, m_pscan->IchMinTok());\n\n            if (buildAST)\n            {\n                ParseNodePtr temp = pnode;\n                while (temp->nop == knopList)\n                {\n                    ParseNodePtr varDeclNode = temp->sxBin.pnode1;\n                    temp = temp->sxBin.pnode2;\n\n                    AddModuleLocalExportEntry(varDeclNode);\n                }\n                AddModuleLocalExportEntry(temp);\n            }\n        }\n        break;\n\n    case tkFUNCTION:\n    case tkCLASS:\n        {\nParseFunctionDecl:\n            pnode = ParseStatement<buildAST>();\n\n            if (buildAST)\n            {\n                IdentPtr localName;\n                if (pnode->nop == knopClassDecl)\n                {\n                    pnode->sxClass.pnodeName->sxVar.sym->SetIsModuleExportStorage(true);\n                    pnode->sxClass.pnodeDeclName->sxVar.sym->SetIsModuleExportStorage(true);\n                    localName = pnode->sxClass.pnodeName->sxVar.pid;\n                }\n                else\n                {\n                    Assert(pnode->nop == knopFncDecl);\n\n                    pnode->sxFnc.GetFuncSymbol()->SetIsModuleExportStorage(true);\n                    localName = pnode->sxFnc.pid;\n                }\n                Assert(localName != nullptr);\n\n                AddModuleImportOrExportEntry(EnsureModuleLocalExportEntryList(), nullptr, localName, localName, nullptr);\n            }\n        }\n        break;\n\n    case tkDEFAULT:\n        {\n            pnode = ParseDefaultExportClause<buildAST>();\n        }\n        break;\n\n    default:\n        {\nErrorToken:\n            Error(ERRsyntax);\n        }\n    }\n\n    return pnode;\n}\n\n/***************************************************************************\nParse an expression term.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken /*= nullptr*/,\n    bool fUnaryOrParen /*= false*/,\n    _Out_opt_ BOOL* pfCanAssign /*= nullptr*/,\n    _Inout_opt_ BOOL* pfLikelyPattern /*= nullptr*/,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr*/,\n    _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    PidRefStack *savedTopAsyncRef = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    size_t iuMin;\n    IdentToken term;\n    BOOL fInNew = FALSE;\n    BOOL fCanAssign = TRUE;\n    bool isAsyncExpr = false;\n    bool isLambdaExpr = false;\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (m_token.tk)\n    {\n    case tkID:\n    {\n        PidRefStack *ref = nullptr;\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        charcount_t ichLim = m_pscan->IchLimTok();\n        size_t iecpLim = m_pscan->IecpLimTok();\n        ichMin = m_pscan->IchMinTok();\n        iecpMin  = m_pscan->IecpMinTok();\n\n        if (pid == wellKnownPropertyPids.async &&\n            m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            isAsyncExpr = true;\n        }\n\n        bool previousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(isAsyncExpr);\n        m_pscan->Scan();\n        m_pscan->SetAwaitIsKeyword(previousAwaitIsKeyword);\n\n        // We search for an Async expression (a function declaration or an async lambda expression)\n        if (isAsyncExpr && !m_pscan->FHadNewLine())\n        {\n            if (m_token.tk == tkFUNCTION)\n            {\n                goto LFunction;\n            }\n            else if (m_token.tk == tkID || m_token.tk == tkAWAIT)\n            {\n                isLambdaExpr = true;\n                goto LFunction;\n            }\n            else if (m_token.tk == tkLParen)\n            {\n                // This is potentially an async arrow function. Save the state of the async references\n                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s\n                // is detected upstream and need not be handled here.)\n                savedTopAsyncRef = pid->GetTopRef();\n            }\n        }\n\n        // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n        // a correct function ID.\n        if (m_token.tk != tkDArrow)\n        {\n            ref = this->PushPidRef(pid);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNameNode(pid);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = ichLim;\n            pnode->sxPid.SetSymRef(ref);\n        }\n        else\n        {\n            // Remember the identifier start and end in case it turns out to be a statement label.\n            term.tk = tkID;\n            term.pid = pid; // Record the identifier for detection of eval\n            term.ichMin = static_cast<charcount_t>(iecpMin);\n            term.ichLim = static_cast<charcount_t>(iecpLim);\n        }\n        CheckArgumentsUse(pid, GetCurrentFunctionNode());\n        break;\n    }\n\n    case tkTHIS:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopThis>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkLParen:\n    {\n        ichMin = m_pscan->IchMinTok();\n        iuMin = m_pscan->IecpMinTok();\n        m_pscan->Scan();\n        if (m_token.tk == tkRParen)\n        {\n            // Empty parens can only be legal as an empty parameter list to a lambda declaration.\n            // We're in a lambda if the next token is =>.\n            fAllowCall = FALSE;\n            m_pscan->Scan();\n\n            // If the token after the right paren is not => or if there was a newline between () and => this is a syntax error\n            if (!m_doingFastScan && (m_token.tk != tkDArrow || m_pscan->FHadNewLine()))\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopEmpty>();\n            }\n            break;\n        }\n\n        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n        // up function ID's.\n        uint saveNextBlockId = m_nextBlockId;\n        uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n\n        this->m_parenDepth++;\n        pnode = ParseExpr<buildAST>(koplNo, &fCanAssign, TRUE, FALSE, nullptr, nullptr /*nameLength*/, nullptr  /*pShortNameOffset*/, &term, true, nullptr, plastRParen);\n        this->m_parenDepth--;\n\n        if (buildAST && plastRParen)\n        {\n            *plastRParen = m_pscan->IchLimTok();\n        }\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n        if (m_token.tk == tkDArrow)\n        {\n            // We're going to rewind and reinterpret the expression as a parameter list.\n            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n            m_nextBlockId = saveNextBlockId;\n        }\n\n        // Emit a deferred ... error if one was parsed.\n        if (m_deferEllipsisError && m_token.tk != tkDArrow)\n        {\n            m_pscan->SeekTo(m_EllipsisErrLoc);\n            Error(ERRInvalidSpreadUse);\n        }\n        else\n        {\n            m_deferEllipsisError = false;\n        }\n        break;\n    }\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateIntNodeWithScanner(m_token.GetLong());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFlt>();\n            pnode->sxFlt.dbl = m_token.GetDouble();\n            pnode->sxFlt.maybeInt = m_token.GetDoubleMayBeInt();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateStrNodeWithScanner(m_token.GetStr());\n        }\n        else\n        {\n            // Subtract the string literal length from the total char count for the purpose\n            // of deciding whether to defer parsing and byte code generation.\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - m_pscan->IchMinTok());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkTRUE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopTrue>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFALSE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFalse>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNULL:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopNull>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkDiv:\n    case tkAsgDiv:\n        pnode = ParseRegExp<buildAST>();\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNEW:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n\n        if (m_token.tk == tkDot && m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseMetaProperty<buildAST>(tkNEW, ichMin, &fCanAssign);\n\n            m_pscan->Scan();\n        }\n        else\n        {\n            ParseNodePtr pnodeExpr = ParseTerm<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n            if (buildAST)\n            {\n                pnode = CreateCallNode(knopNew, pnodeExpr, nullptr);\n                pnode->ichMin = ichMin;\n            }\n            fInNew = TRUE;\n            fCanAssign = FALSE;\n        }\n        break;\n    }\n\n    case tkLBrack:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n        pnode = ParseArrayLiteral<buildAST>();\n        if (buildAST)\n        {\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(m_pscan->IchLimTok() - ichMin > m_funcInArray);\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - ichMin - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(tkRBrack, ERRnoRbrack);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkLCurly:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->ScanForcingPid();\n        ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(pNameHint, pHintLength);\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopObject, pnodeMemberList);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkFUNCTION:\n    {\nLFunction :\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            //\n            // Normally, deferred functions will be parsed in ParseStatement upon encountering the 'function' token. The first\n            // token of the source code of the function may not a 'function' token though, so we still need to reset this flag\n            // for the first function we parse. This can happen in compat modes, for instance, for a function expression enclosed\n            // in parentheses, where the legacy behavior was to include the parentheses in the function's source code.\n            m_grfscr &= ~fscrDeferredFncExpression;\n        }\n        ushort flags = fFncNoFlgs;\n        if (isLambdaExpr)\n        {\n            flags |= fFncLambda;\n        }\n        if (isAsyncExpr)\n        {\n            flags |= fFncAsync;\n        }\n        pnode = ParseFncDecl<buildAST>(flags, pNameHint, false, true, fUnaryOrParen);\n        if (isAsyncExpr)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        fCanAssign = FALSE;\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        fCanAssign = FALSE;\n        break;\n\n    case tkStrTmplBasic:\n    case tkStrTmplBegin:\n        pnode = ParseStringTemplateDecl<buildAST>(nullptr);\n        fCanAssign = FALSE;\n        break;\n\n    case tkSUPER:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseSuper<buildAST>(pnode, !!fAllowCall);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case tkCASE:\n    {\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr pnodeUnused;\n        pnode = ParseCase<buildAST>(&pnodeUnused);\n        break;\n    }\n\n    case tkELSE:\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        m_pscan->Scan();\n        ParseStatement<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(ERRsyntax);\n        break;\n    }\n\n    pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n\n    if (savedTopAsyncRef != nullptr &&\n        this->m_token.tk == tkDArrow)\n    {\n        // This is an async arrow function; we're going to back up and reparse it.\n        // Make sure we don't leave behind a bogus reference to the 'async' identifier.\n        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)\n        {\n            Assert(pid->GetTopRef() != nullptr);\n            pid->RemovePrevPidRef(nullptr);\n        }\n    }\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    if (pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    return pnode;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseRegExp()\n{\n    ParseNodePtr pnode = nullptr;\n\n    if (buildAST || m_doingFastScan)\n    {\n        m_pscan->RescanRegExp();\n\n        BOOL saveDeferringAST = this->m_deferringAST;\n        if (m_doingFastScan)\n        {\n            this->m_deferringAST = false;\n        }\n        pnode = CreateNodeWithScanner<knopRegExp>();\n        pnode->sxPid.regexPattern = m_token.GetRegex();\n        if (m_doingFastScan)\n        {\n            this->m_deferringAST = saveDeferringAST;\n            this->AddFastScannedRegExpNode(pnode);\n            if (!buildAST)\n            {\n                pnode = nullptr;\n            }\n        }\n#if ENABLE_BACKGROUND_PARSING\n        else if (this->IsBackgroundParser())\n        {\n            Assert(pnode->sxPid.regexPattern == nullptr);\n            this->AddBackgroundRegExpNode(pnode);\n        }\n#endif\n    }\n    else\n    {\n        m_pscan->RescanRegExpNoAST();\n    }\n    Assert(m_token.tk == tkRegExp);\n\n    return pnode;\n}\n\nBOOL Parser::NodeIsEvalName(ParseNodePtr pnode)\n{\n    //WOOB 1107758 Special case of indirect eval binds to local scope in standards mode\n    return pnode->nop == knopName && (pnode->sxPid.pid == wellKnownPropertyPids.eval);\n}\n\nBOOL Parser::NodeEqualsName(ParseNodePtr pnode, LPCOLESTR sz, uint32 cch)\n{\n    return pnode->nop == knopName &&\n        pnode->sxPid.pid->Cch() == cch &&\n        !wmemcmp(pnode->sxPid.pid->Psz(), sz, cch);\n}\n\nBOOL Parser::NodeIsIdent(ParseNodePtr pnode, IdentPtr pid)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return (pnode->sxPid.pid == pid);\n\n        case knopComma:\n            pnode = pnode->sxBin.pnode2;\n            break;\n\n        default:\n            return FALSE;\n        }\n    }\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParsePostfixOperators(\n    ParseNodePtr pnode,\n    BOOL fAllowCall,\n    BOOL fInNew,\n    BOOL isAsyncExpr,\n    BOOL *pfCanAssign,\n    _Inout_ IdentToken* pToken,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr */)\n{\n    uint16 count = 0;\n    bool callOfConstants = false;\n    if (pfIsDotOrIndex)\n    {\n        *pfIsDotOrIndex = false;\n    }\n\n    for (;;)\n    {\n        uint16 spreadArgCount = 0;\n        switch (m_token.tk)\n        {\n        case tkLParen:\n            {\n                if (fInNew)\n                {\n                    ParseNodePtr pnodeArgs = ParseArgList<buildAST>(&callOfConstants, &spreadArgCount, &count);\n                    if (buildAST)\n                    {\n                        Assert(pnode->nop == knopNew);\n                        Assert(pnode->sxCall.pnodeArgs == nullptr);\n                        pnode->sxCall.pnodeArgs = pnodeArgs;\n                        pnode->sxCall.callOfConstants = callOfConstants;\n                        pnode->sxCall.isApplyCall = false;\n                        pnode->sxCall.isEvalCall = false;\n                        pnode->sxCall.argCount = count;\n                        pnode->sxCall.spreadArgCount = spreadArgCount;\n                        pnode->ichLim = m_pscan->IchLimTok();\n                    }\n                    else\n                    {\n                        pnode = nullptr;\n                        pToken->tk = tkNone; // This is no longer an identifier\n                    }\n                    fInNew = FALSE;\n                    ChkCurTok(tkRParen, ERRnoRparen);\n                }\n                else\n                {\n                    bool fCallIsEval = false;\n                    if (!fAllowCall)\n                    {\n                        return pnode;\n                    }\n\n                    uint saveNextBlockId = m_nextBlockId;\n                    uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n\n                    if (isAsyncExpr)\n                    {\n                        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n                        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n                        // up function ID's.\n                        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n                    }\n\n                    ParseNodePtr pnodeArgs = ParseArgList<buildAST>(&callOfConstants, &spreadArgCount, &count);\n                    // We used to un-defer a deferred function body here if it was called as part of the expression that declared it.\n                    // We now detect this case up front in ParseFncDecl, which is cheaper and simpler.\n                    if (buildAST)\n                    {\n                        pnode = CreateCallNode(knopCall, pnode, pnodeArgs);\n                        Assert(pnode);\n\n                        // Detect call to \"eval\" and record it on the function.\n                        // Note: we used to leave it up to the byte code generator to detect eval calls\n                        // at global scope, but now it relies on the flag the parser sets, so set it here.\n\n                        if (count > 0 && this->NodeIsEvalName(pnode->sxCall.pnodeTarget))\n                        {\n                            this->MarkEvalCaller();\n                            fCallIsEval = true;\n                        }\n\n                        pnode->sxCall.callOfConstants = callOfConstants;\n                        pnode->sxCall.spreadArgCount = spreadArgCount;\n                        pnode->sxCall.isApplyCall = false;\n                        pnode->sxCall.isEvalCall = fCallIsEval;\n                        pnode->sxCall.argCount = count;\n                        pnode->ichLim = m_pscan->IchLimTok();\n                    }\n                    else\n                    {\n                        pnode = nullptr;\n                        if (pToken->tk == tkID && pToken->pid == wellKnownPropertyPids.eval && count > 0) // Detect eval\n                        {\n                            this->MarkEvalCaller();\n                        }\n                        pToken->tk = tkNone; // This is no longer an identifier\n                    }\n\n                    ChkCurTok(tkRParen, ERRnoRparen);\n\n                    if (isAsyncExpr)\n                    {\n                        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n                        if (m_token.tk == tkDArrow)\n                        {\n                            // We're going to rewind and reinterpret the expression as a parameter list.\n                            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n                            m_nextBlockId = saveNextBlockId;\n                        }\n                    }\n                }\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = FALSE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = false;\n                }\n                break;\n            }\n        case tkLBrack:\n            {\n                m_pscan->Scan();\n                ParseNodePtr pnodeExpr = ParseExpr<buildAST>();\n                if (buildAST)\n                {\n                    pnode = CreateBinNode(knopIndex, pnode, pnodeExpr);\n                    pnode->ichLim = m_pscan->IchLimTok();\n                }\n                else\n                {\n                    pnode = nullptr;\n                    pToken->tk = tkNone; // This is no longer an identifier\n                }\n                ChkCurTok(tkRBrack, ERRnoRbrack);\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = TRUE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = true;\n                }\n\n                if (!buildAST)\n                {\n                    break;\n                }\n\n                bool shouldConvertToDot = false;\n                if (pnode->sxBin.pnode2->nop == knopStr)\n                {\n                    // if the string is empty or contains escape character, we will not convert them to dot node\n                    shouldConvertToDot = pnode->sxBin.pnode2->sxPid.pid->Cch() > 0 && !m_pscan->IsEscapeOnLastTkStrCon();\n                }\n\n                if (shouldConvertToDot)\n                {\n                    LPCOLESTR str = pnode->sxBin.pnode2->sxPid.pid->Psz();\n                    // See if we can convert o[\"p\"] into o.p and o[\"0\"] into o[0] since they're equivalent and the latter forms\n                    // are faster\n                    uint32 uintValue;\n                    if(Js::JavascriptOperators::TryConvertToUInt32(\n                           str,\n                           pnode->sxBin.pnode2->sxPid.pid->Cch(),\n                           &uintValue) &&\n                       !Js::TaggedInt::IsOverflow(uintValue)) // the optimization is not very useful if the number can't be represented as a TaggedInt\n                    {\n                        // No need to verify that uintValue != JavascriptArray::InvalidIndex since all nonnegative TaggedInts are valid indexes\n                        auto intNode = CreateIntNodeWithScanner(uintValue); // implicit conversion from uint32 to int32\n                        pnode->sxBin.pnode2 = intNode;\n                    }\n                    // Field optimization (see GlobOpt::KillLiveElems) checks for value being a Number,\n                    // and since NaN/Infinity is a number it won't kill o.NaN/o.Infinity which would cause a problem\n                    // if we decide to hoist o.NaN/o.Infinity.\n                    // We need to keep o[\"NaN\"] and o[\"+/-Infinity\"] as array element access (we don't hoist that but we may hoist field access),\n                    // so no matter if it's killed by o[x] inside a loop, we make sure that we never hoist these.\n                    // We need to follow same logic for strings that convert to a floating point number.\n                    else\n                    {\n                        bool doConvertToProperty = false;    // Convert a[\"x\"] -> a.x.\n                        if (!Parser::IsNaNOrInfinityLiteral<true>(str))\n                        {\n                            const OLECHAR* terminalChar;\n                            double dbl = Js::NumberUtilities::StrToDbl(str, &terminalChar, m_scriptContext);\n                            bool convertsToFloat = !Js::NumberUtilities::IsNan(dbl);\n                            doConvertToProperty = !convertsToFloat;\n                        }\n\n                        if (doConvertToProperty)\n                        {\n                            pnode->sxBin.pnode2->nop = knopName;\n                            pnode->nop = knopDot;\n                            pnode->grfpn |= PNodeFlags::fpnIndexOperator;\n                        }\n                    }\n                }\n            }\n            break;\n\n        case tkDot:\n            {\n            ParseNodePtr name = nullptr;\n            OpCode opCode = knopDot;\n\n            m_pscan->Scan();\n            if (!m_token.IsIdentifier())\n            {\n                //allow reserved words in ES5 mode\n                if (!(m_token.IsReservedWord()))\n                {\n                    IdentifierExpectedError(m_token);\n                }\n            }\n            // Note: see comment above about field optimization WRT NaN/Infinity/-Infinity.\n            // Convert a.Nan, a.Infinity into a[\"NaN\"], a[\"Infinity\"].\n            // We don't care about -Infinity case here because x.-Infinity is invalid in JavaScript.\n            // Both NaN and Infinity are identifiers.\n            else if (buildAST && Parser::IsNaNOrInfinityLiteral<false>(m_token.GetIdentifier(m_phtbl)->Psz()))\n            {\n                opCode = knopIndex;\n            }\n\n            if (buildAST)\n            {\n                if (opCode == knopDot)\n                {\n                    name = CreateNameNode(m_token.GetIdentifier(m_phtbl));\n                }\n                else\n                {\n                    Assert(opCode == knopIndex);\n                    name = CreateStrNodeWithScanner(m_token.GetIdentifier(m_phtbl));\n                }\n                pnode = CreateBinNode(opCode, pnode, name);\n            }\n            else\n            {\n                pnode = nullptr;\n                pToken->tk = tkNone;\n            }\n\n            if (pfCanAssign)\n            {\n                *pfCanAssign = TRUE;\n            }\n            if (pfIsDotOrIndex)\n            {\n                *pfIsDotOrIndex = true;\n            }\n            m_pscan->Scan();\n\n            break;\n            }\n\n        case tkStrTmplBasic:\n        case tkStrTmplBegin:\n            {\n                ParseNode* templateNode = ParseStringTemplateDecl<buildAST>(pnode);\n\n                if (!buildAST)\n                {\n                    pToken->tk = tkNone; // This is no longer an identifier\n                }\n\n                pnode = templateNode;\n                if (pfCanAssign)\n                {\n                    *pfCanAssign = FALSE;\n                }\n                if (pfIsDotOrIndex)\n                {\n                    *pfIsDotOrIndex = false;\n                }\n                break;\n            }\n        default:\n            return pnode;\n        }\n    }\n}\n\n/***************************************************************************\nLook for an existing label with the given name.\n***************************************************************************/\nParseNodePtr Parser::PnodeLabel(IdentPtr pid, ParseNodePtr pnodeLabels)\n{\n    AssertMem(pid);\n    AssertNodeMemN(pnodeLabels);\n\n    StmtNest *pstmt;\n    ParseNodePtr pnodeT;\n\n    // Look in the statement stack.\n    for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n    {\n        AssertNodeMem(pstmt->pnodeStmt);\n        AssertNodeMemN(pstmt->pnodeLab);\n\n        for (pnodeT = pstmt->pnodeLab; nullptr != pnodeT;\n            pnodeT = pnodeT->sxLabel.pnodeNext)\n        {\n            Assert(knopLabel == pnodeT->nop);\n            if (pid == pnodeT->sxLabel.pid)\n                return pnodeT;\n        }\n    }\n\n    // Also look in the pnodeLabels list.\n    for (pnodeT = pnodeLabels; nullptr != pnodeT;\n        pnodeT = pnodeT->sxLabel.pnodeNext)\n    {\n        Assert(knopLabel == pnodeT->nop);\n        if (pid == pnodeT->sxLabel.pid)\n            return pnodeT;\n    }\n\n    return nullptr;\n}\n\n// Currently only ints and floats are treated as constants in function call\n// TODO: Check if we need for other constants as well\nBOOL Parser::IsConstantInFunctionCall(ParseNodePtr pnode)\n{\n    if (pnode->nop == knopInt && !Js::TaggedInt::IsOverflow(pnode->sxInt.lw))\n    {\n        return TRUE;\n    }\n\n    if (pnode->nop == knopFlt)\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\n/***************************************************************************\nParse a list of arguments.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArgList( bool *pCallOfConstants, uint16 *pSpreadArgCount, uint16 * pCount)\n{\n    ParseNodePtr pnodeArg;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    // Check for an empty list\n    Assert(m_token.tk == tkLParen);\n\n    if (m_pscan->Scan() == tkRParen)\n    {\n        return nullptr;\n    }\n\n    *pCallOfConstants = true;\n    *pSpreadArgCount = 0;\n\n    int count=0;\n    while (true)\n    {\n        // the count of arguments has to fit in an unsigned short\n        if (count > 0xffffU)\n            Error(ERRnoMemory);\n        // Allow spread in argument lists.\n        IdentToken token;\n        pnodeArg = ParseExpr<buildAST>(koplCma, nullptr, TRUE, /* fAllowEllipsis */TRUE, NULL, nullptr, nullptr, &token);\n        ++count;\n        this->MarkEscapingRef(pnodeArg, &token);\n\n        if (buildAST)\n        {\n            this->CheckArguments(pnodeArg);\n\n            if (*pCallOfConstants && !IsConstantInFunctionCall(pnodeArg))\n            {\n                *pCallOfConstants = false;\n            }\n\n            if (pnodeArg->nop == knopEllipsis)\n            {\n                (*pSpreadArgCount)++;\n            }\n\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n        if (m_token.tk != tkComma)\n        {\n            break;\n        }\n        m_pscan->Scan();\n\n        if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n        {\n            break;\n        }\n    }\n\n    if (pSpreadArgCount!=nullptr && (*pSpreadArgCount) > 0){\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(SpreadFeature, m_scriptContext);\n    }\n\n    *pCount = static_cast<uint16>(count);\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n    }\n\n    return pnodeList;\n}\n\n// Currently only ints are treated as constants in ArrayLiterals\nBOOL Parser::IsConstantInArrayLiteral(ParseNodePtr pnode)\n{\n    if (pnode->nop == knopInt && !Js::TaggedInt::IsOverflow(pnode->sxInt.lw))\n    {\n        return TRUE;\n    }\n    return FALSE;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArrayLiteral()\n{\n    ParseNodePtr pnode = nullptr;\n    bool arrayOfTaggedInts = false;\n    bool arrayOfInts = false;\n    bool arrayOfNumbers = false;\n    bool hasMissingValues = false;\n    uint count = 0;\n    uint spreadCount = 0;\n\n    ParseNodePtr pnode1 = ParseArrayList<buildAST>(&arrayOfTaggedInts, &arrayOfInts, &arrayOfNumbers, &hasMissingValues, &count, &spreadCount);\n\n    if (buildAST)\n    {\n        pnode = CreateNodeWithScanner<knopArray>();\n        pnode->sxArrLit.pnode1 = pnode1;\n        pnode->sxArrLit.arrayOfTaggedInts = arrayOfTaggedInts;\n        pnode->sxArrLit.arrayOfInts = arrayOfInts;\n        pnode->sxArrLit.arrayOfNumbers = arrayOfNumbers;\n        pnode->sxArrLit.hasMissingValues = hasMissingValues;\n        pnode->sxArrLit.count = count;\n        pnode->sxArrLit.spreadCount = spreadCount;\n\n        if (pnode->sxArrLit.pnode1)\n        {\n            this->CheckArguments(pnode->sxArrLit.pnode1);\n        }\n    }\n\n    return pnode;\n}\n\n/***************************************************************************\nCreate an ArrayLiteral node\nParse a list of array elements. [ a, b, , c, ]\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseArrayList(bool *pArrayOfTaggedInts, bool *pArrayOfInts, bool *pArrayOfNumbers, bool *pHasMissingValues, uint *count, uint *spreadCount)\n{\n    ParseNodePtr pnodeArg = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    *count = 0;\n\n    // Check for an empty list\n    if (tkRBrack == m_token.tk)\n    {\n        return nullptr;\n    }\n\n    this->m_arrayDepth++;\n    bool arrayOfTaggedInts = buildAST;\n    bool arrayOfInts = buildAST;\n    bool arrayOfNumbers = buildAST;\n    bool arrayOfVarInts = false;\n    bool hasMissingValues = false;\n\n    for (;;)\n    {\n        (*count)++;\n        if (tkComma == m_token.tk || tkRBrack == m_token.tk)\n        {\n            hasMissingValues = true;\n            arrayOfTaggedInts = false;\n            arrayOfInts = false;\n            arrayOfNumbers = false;\n            if (buildAST)\n            {\n                pnodeArg = CreateNodeWithScanner<knopEmpty>();\n            }\n        }\n        else\n        {\n            // Allow Spread in array literals.\n            pnodeArg = ParseExpr<buildAST>(koplCma, nullptr, TRUE, /* fAllowEllipsis */ TRUE);\n            if (buildAST)\n            {\n                if (pnodeArg->nop == knopEllipsis)\n                {\n                    (*spreadCount)++;\n                }\n                this->CheckArguments(pnodeArg);\n            }\n        }\n\n#if DEBUG\n        if(m_grfscr & fscrEnforceJSON && !IsJSONValid(pnodeArg))\n        {\n            Error(ERRsyntax);\n        }\n#endif\n\n        if (buildAST)\n        {\n            if (arrayOfNumbers)\n            {\n                if (pnodeArg->nop != knopInt)\n                {\n                    arrayOfTaggedInts = false;\n                    if (pnodeArg->nop != knopFlt)\n                    {\n                        // Not an array of constants.\n                        arrayOfInts = false;\n                        arrayOfNumbers = false;\n                    }\n                    else if (arrayOfInts && Js::JavascriptNumber::IsInt32OrUInt32(pnodeArg->sxFlt.dbl) && (!Js::JavascriptNumber::IsInt32(pnodeArg->sxFlt.dbl) || pnodeArg->sxFlt.dbl == -2147483648.0))\n                    {\n                        // We've seen nothing but ints, and this is a uint32 but not an int32.\n                        // Unless we see an actual float at some point, we want an array of vars\n                        // so we can work with tagged ints.\n                        arrayOfVarInts = true;\n                    }\n                    else\n                    {\n                        // Not an int array, but it may still be a float array.\n                        arrayOfInts = false;\n                    }\n                }\n                else\n                {\n                    if (Js::SparseArraySegment<int32>::IsMissingItem((int32*)&pnodeArg->sxInt.lw))\n                    {\n                        arrayOfInts = false;\n                    }\n                    if (Js::TaggedInt::IsOverflow(pnodeArg->sxInt.lw))\n                    {\n                        arrayOfTaggedInts = false;\n                    }\n                }\n            }\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n\n        if (tkComma != m_token.tk)\n        {\n            break;\n        }\n        m_pscan->Scan();\n\n        if (tkRBrack == m_token.tk)\n        {\n            break;\n        }\n    }\n\n    if (spreadCount != nullptr && *spreadCount > 0){\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(SpreadFeature, m_scriptContext);\n    }\n\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n\n        if (arrayOfVarInts && arrayOfInts)\n        {\n            arrayOfInts = false;\n            arrayOfNumbers = false;\n        }\n        *pArrayOfTaggedInts = arrayOfTaggedInts;\n        *pArrayOfInts = arrayOfInts;\n        *pArrayOfNumbers = arrayOfNumbers;\n        *pHasMissingValues = hasMissingValues;\n    }\n    this->m_arrayDepth--;\n    return pnodeList;\n}\n\nParser::MemberNameToTypeMap* Parser::CreateMemberNameMap(ArenaAllocator* pAllocator)\n{\n    Assert(pAllocator);\n    return Anew(pAllocator, MemberNameToTypeMap, pAllocator, 5);\n}\n\ntemplate<bool buildAST> void Parser::ParseComputedName(ParseNodePtr* ppnodeName, LPCOLESTR* ppNameHint, LPCOLESTR* ppFullNameHint, uint32 *pNameLength, uint32 *pShortNameOffset)\n{\n    m_pscan->Scan();\n    ParseNodePtr pnodeNameExpr = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, *ppNameHint, pNameLength, pShortNameOffset);\n    if (buildAST)\n    {\n        *ppnodeName = CreateNodeT<knopComputedName>(pnodeNameExpr->ichMin, pnodeNameExpr->ichLim);\n        (*ppnodeName)->sxUni.pnode1 = pnodeNameExpr;\n    }\n\n    if (ppFullNameHint && buildAST && CONFIG_FLAG(UseFullName))\n    {\n        *ppFullNameHint = FormatPropertyString(*ppNameHint, pnodeNameExpr, pNameLength, pShortNameOffset);\n    }\n\n    ChkCurTokNoScan(tkRBrack, ERRnoRbrack);\n}\n\n/***************************************************************************\n    Parse a list of object set/get members, e.g.:\n    { get foo(){ ... }, set bar(arg) { ... } }\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMemberGetSet(OpCode nop, LPCOLESTR* ppNameHint)\n{\n    ParseNodePtr pnodeName = nullptr;\n    Assert(nop == knopGetMember || nop == knopSetMember);\n    AssertMem(ppNameHint);\n    IdentPtr pid = nullptr;\n    bool isComputedName = false;\n\n    *ppNameHint=nullptr;\n\n    switch(m_token.tk)\n    {\n    default:\n        if (!m_token.IsReservedWord())\n        {\n            Error(ERRnoMemberIdent);\n        }\n        // fall through\n    case tkID:\n        pid = m_token.GetIdentifier(m_phtbl);\n        *ppNameHint = pid->Psz();\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n        pid = m_token.GetStr();\n        *ppNameHint = pid->Psz();\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        pid = m_pscan->PidFromLong(m_token.GetLong());\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        pid = m_pscan->PidFromDbl(m_token.GetDouble());\n        if (buildAST)\n        {\n            pnodeName = CreateStrNodeWithScanner(pid);\n        }\n        break;\n\n    case tkLBrack:\n        // Computed property name: get|set [expr] () {  }\n        if (!m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            Error(ERRnoMemberIdent);\n        }\n        LPCOLESTR emptyHint = nullptr;\n        uint32 offset = 0;\n        ParseComputedName<buildAST>(&pnodeName, &emptyHint, ppNameHint, &offset);\n\n        isComputedName = true;\n        break;\n    }\n\n    MemberType memberType;\n    ushort flags = fFncMethod | fFncNoName;\n    if (nop == knopGetMember)\n    {\n        memberType = MemberTypeGetter;\n        flags |= fFncNoArg;\n    }\n    else\n    {\n        Assert(nop == knopSetMember);\n        memberType = MemberTypeSetter;\n        flags |= fFncOneArg;\n    }\n\n    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n    ParseNodePtr pnodeFnc = ParseFncDecl<buildAST>(flags, *ppNameHint,\n        /*needsPIDOnRCurlyScan*/ false, /*resetParsingSuperRestrictionState*/ false);\n\n    if (buildAST)\n    {\n        pnodeFnc->sxFnc.SetIsAccessor();\n        return CreateBinNode(nop, pnodeName, pnodeFnc);\n    }\n    else\n    {\n        return nullptr;\n    }\n}\n\n/***************************************************************************\nParse a list of object members. e.g. { x:foo, 'y me':bar }\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseMemberList(LPCOLESTR pNameHint, uint32* pNameHintLength, tokens declarationType)\n{\n    ParseNodePtr pnodeArg = nullptr;\n    ParseNodePtr pnodeName = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    LPCOLESTR pFullNameHint = nullptr;       // A calculated full name\n    uint32 fullNameHintLength = pNameHintLength ? *pNameHintLength : 0;\n    uint32 shortNameOffset = 0;\n    bool isProtoDeclared = false;\n\n    // we get declaration tkLCurly - when the possible object pattern found under the expression.\n    bool isObjectPattern = (declarationType == tkVAR || declarationType == tkLET || declarationType == tkCONST || declarationType == tkLCurly) && IsES6DestructuringEnabled();\n\n    // Check for an empty list\n    if (tkRCurly == m_token.tk)\n    {\n        return nullptr;\n    }\n\n    ArenaAllocator tempAllocator(_u(\"MemberNames\"), m_nodeAllocator.GetPageAllocator(), Parser::OutOfMemory);\n\n    bool hasDeferredInitError = false;\n\n    for (;;)\n    {\n        bool isComputedName = false;\n#if DEBUG\n        if((m_grfscr & fscrEnforceJSON) && (tkStrCon != m_token.tk || !(m_pscan->IsDoubleQuoteOnLastTkStrCon())))\n        {\n            Error(ERRsyntax);\n        }\n#endif\n        bool isAsyncMethod = false;\n        charcount_t ichMin = 0;\n        size_t iecpMin = 0;\n        if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->ScanForcingPid();\n            if (m_token.tk == tkLParen || m_token.tk == tkColon || m_token.tk == tkRCurly || m_pscan->FHadNewLine())\n            {\n                m_pscan->SeekTo(parsedAsync);\n            }\n            else\n            {\n                isAsyncMethod = true;\n            }\n        }\n\n        bool isGenerator = m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n                           m_token.tk == tkStar;\n        ushort fncDeclFlags = fFncNoName | fFncMethod;\n        if (isGenerator)\n        {\n            if (isAsyncMethod)\n            {\n                Error(ERRsyntax);\n            }\n            m_pscan->ScanForcingPid();\n            fncDeclFlags |= fFncGenerator;\n        }\n\n        IdentPtr pidHint = nullptr;              // A name scoped to current expression\n        Token tkHint = m_token;\n        charcount_t idHintIchMin = static_cast<charcount_t>(m_pscan->IecpMinTok());\n        charcount_t idHintIchLim = static_cast< charcount_t >(m_pscan->IecpLimTok());\n        bool wrapInBrackets = false;\n        switch (m_token.tk)\n        {\n        default:\n            if (!m_token.IsReservedWord())\n            {\n                Error(ERRnoMemberIdent);\n            }\n            // allow reserved words\n            wrapInBrackets = true;\n            // fall-through\n        case tkID:\n            pidHint = m_token.GetIdentifier(m_phtbl);\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkStrCon:\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n            wrapInBrackets = true;\n            pidHint = m_token.GetStr();\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkIntCon:\n            // Object initializers with numeric labels allowed in JS6\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pidHint = m_pscan->PidFromLong(m_token.GetLong());\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            break;\n\n        case tkFltCon:\n            if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pidHint = m_pscan->PidFromDbl(m_token.GetDouble());\n            if (buildAST)\n            {\n                pnodeName = CreateStrNodeWithScanner(pidHint);\n            }\n            wrapInBrackets = true;\n            break;\n\n        case tkLBrack:\n            // Computed property name: [expr] : value\n            if (!m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n            {\n                Error(ERRnoMemberIdent);\n            }\n\n            ParseComputedName<buildAST>(&pnodeName, &pNameHint, &pFullNameHint, &fullNameHintLength, &shortNameOffset);\n\n            isComputedName = true;\n            break;\n        }\n\n        if (pFullNameHint == nullptr)\n        {\n            if (CONFIG_FLAG(UseFullName))\n            {\n                pFullNameHint = AppendNameHints(pNameHint, pidHint, &fullNameHintLength, &shortNameOffset, false, wrapInBrackets);\n            }\n            else\n            {\n                pFullNameHint = pidHint? pidHint->Psz() : nullptr;\n                fullNameHintLength = pidHint ? pidHint->Cch() : 0;\n                shortNameOffset = 0;\n            }\n        }\n\n        RestorePoint atPid;\n        m_pscan->Capture(&atPid);\n\n        m_pscan->ScanForcingPid();\n\n        if (isGenerator && m_token.tk != tkLParen)\n        {\n            Error(ERRnoLparen);\n        }\n\n        if (tkColon == m_token.tk)\n        {\n            // It is a syntax error is the production of the form __proto__ : <> occurs more than once. From B.3.1 in spec.\n            // Note that previous scan is important because only after that we can determine we have a variable.\n            if (!isComputedName && pidHint == wellKnownPropertyPids.__proto__)\n            {\n                if (isProtoDeclared)\n                {\n                    Error(ERRsyntax);\n                }\n                else\n                {\n                    isProtoDeclared = true;\n                }\n            }\n\n            m_pscan->Scan();\n            ParseNodePtr pnodeExpr = nullptr;\n            if (isObjectPattern)\n            {\n                if (m_token.tk == tkEllipsis)\n                {\n                    Error(ERRUnexpectedEllipsis);\n                }\n                pnodeExpr = ParseDestructuredVarDecl<buildAST>(declarationType, declarationType != tkLCurly, nullptr/* *hasSeenRest*/, false /*topLevel*/, false /*allowEmptyExpression*/);\n\n                if (m_token.tk != tkComma && m_token.tk != tkRCurly)\n                {\n                    if (m_token.IsOperator())\n                    {\n                        Error(ERRDestructNoOper);\n                    }\n                    Error(ERRsyntax);\n                }\n            }\n            else\n            {\n                pnodeExpr = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, pFullNameHint, &fullNameHintLength, &shortNameOffset);\n            }\n#if DEBUG\n            if((m_grfscr & fscrEnforceJSON) && !IsJSONValid(pnodeExpr))\n            {\n                Error(ERRsyntax);\n            }\n#endif\n            if (buildAST)\n            {\n                pnodeArg = CreateBinNode(isObjectPattern ? knopObjectPatternMember : knopMember, pnodeName, pnodeExpr);\n                if (pnodeArg->sxBin.pnode1->nop == knopStr)\n                {\n                    pnodeArg->sxBin.pnode1->sxPid.pid->PromoteAssignmentState();\n                }\n            }\n        }\n        else if (m_token.tk == tkLParen && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            if (isObjectPattern)\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n            // Shorthand syntax: foo() {} -> foo: function() {}\n\n            // Rewind to the PID and parse a function expression.\n            m_pscan->SeekTo(atPid);\n            this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n            ParseNodePtr pnodeFunc = ParseFncDecl<buildAST>(fncDeclFlags | (isAsyncMethod ? fFncAsync : fFncNoFlgs), pFullNameHint,\n                /*needsPIDOnRCurlyScan*/ false, /*resetParsingSuperRestrictionState*/ false);\n\n            if (isAsyncMethod)\n            {\n                pnodeFunc->sxFnc.cbMin = iecpMin;\n                pnodeFunc->ichMin = ichMin;\n            }\n            if (buildAST)\n            {\n                pnodeArg = CreateBinNode(knopMember, pnodeName, pnodeFunc);\n            }\n        }\n        else if (nullptr != pidHint) //Its either tkID/tkStrCon/tkFloatCon/tkIntCon\n        {\n            Assert(pidHint->Psz() != nullptr);\n\n            if ((pidHint == wellKnownPropertyPids.get || pidHint == wellKnownPropertyPids.set) &&\n                // get/set are only pseudo keywords when they are identifiers (i.e. not strings)\n                tkHint.tk == tkID && NextTokenIsPropertyNameStart())\n            {\n                if (isObjectPattern)\n                {\n                    Error(ERRInvalidAssignmentTarget);\n                }\n\n                LPCOLESTR pNameGetOrSet = nullptr;\n                OpCode op = pidHint == wellKnownPropertyPids.get ? knopGetMember : knopSetMember;\n\n                pnodeArg = ParseMemberGetSet<buildAST>(op, &pNameGetOrSet);\n\n                if (CONFIG_FLAG(UseFullName) && buildAST && pnodeArg->sxBin.pnode2->nop == knopFncDecl)\n                {\n                    if (m_scriptContext->GetConfig()->IsES6FunctionNameEnabled())\n                    {\n                        // displays as \"get object.funcname\" or \"set object.funcname\"\n                        uint32 getOrSetOffset = 0;\n                        LPCOLESTR intermediateHint = AppendNameHints(pNameHint, pNameGetOrSet, &fullNameHintLength, &shortNameOffset);\n                        pFullNameHint = AppendNameHints(pidHint, intermediateHint, &fullNameHintLength, &getOrSetOffset, true);\n                        shortNameOffset += getOrSetOffset;\n                    }\n                    else\n                    {\n                        // displays as \"object.funcname.get\" or \"object.funcname.set\"\n                        LPCOLESTR intermediateHint = AppendNameHints(pNameGetOrSet, pidHint, &fullNameHintLength, &shortNameOffset);\n                        pFullNameHint = AppendNameHints(pNameHint, intermediateHint, &fullNameHintLength, &shortNameOffset);\n                    }\n                }\n            }\n            else if ((m_token.tk == tkRCurly || m_token.tk == tkComma || m_token.tk == tkAsg) && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n            {\n                // Shorthand {foo} -> {foo:foo} syntax.\n                // {foo = <initializer>} supported only when on object pattern rules are being applied\n                if (tkHint.tk != tkID)\n                {\n                    Assert(tkHint.IsReservedWord()\n                        || tkHint.tk == tkIntCon || tkHint.tk == tkFltCon || tkHint.tk == tkStrCon);\n                    // All keywords are banned in non-strict mode.\n                    // Future reserved words are banned in strict mode.\n                    if (IsStrictMode() || !tkHint.IsFutureReservedWord(true))\n                    {\n                        IdentifierExpectedError(tkHint);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    CheckArgumentsUse(pidHint, GetCurrentFunctionNode());\n                }\n\n                bool couldBeObjectPattern = !isObjectPattern && m_token.tk == tkAsg;\n\n                if (couldBeObjectPattern)\n                {\n                    declarationType = tkLCurly;\n                    isObjectPattern = true;\n\n                    // This may be an error but we are deferring for favouring destructuring.\n                    hasDeferredInitError = true;\n                }\n\n                ParseNodePtr pnodeIdent = nullptr;\n                if (isObjectPattern)\n                {\n                    m_pscan->SeekTo(atPid);\n                    pnodeIdent = ParseDestructuredVarDecl<buildAST>(declarationType, declarationType != tkLCurly, nullptr/* *hasSeenRest*/, false /*topLevel*/, false /*allowEmptyExpression*/);\n\n                    if (m_token.tk != tkComma && m_token.tk != tkRCurly)\n                    {\n                        if (m_token.IsOperator())\n                        {\n                            Error(ERRDestructNoOper);\n                        }\n                        Error(ERRsyntax);\n                    }\n                }\n                else\n                {\n                    // Add a reference to the hinted name so we can bind it properly.\n                    PidRefStack *ref = PushPidRef(pidHint);\n\n                    if (buildAST)\n                    {\n                        pnodeIdent = CreateNameNode(pidHint, idHintIchMin, idHintIchLim);\n                        pnodeIdent->sxPid.SetSymRef(ref);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    pnodeArg = CreateBinNode(isObjectPattern && !couldBeObjectPattern ? knopObjectPatternMember : knopMemberShort, pnodeName, pnodeIdent);\n                }\n            }\n            else\n            {\n                Error(ERRnoColon);\n            }\n        }\n        else\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            Assert(pnodeArg->sxBin.pnode2 != nullptr);\n            if (pnodeArg->sxBin.pnode2->nop == knopFncDecl)\n            {\n                Assert(fullNameHintLength >= shortNameOffset);\n                pnodeArg->sxBin.pnode2->sxFnc.hint = pFullNameHint;\n                pnodeArg->sxBin.pnode2->sxFnc.hintLength =  fullNameHintLength;\n                pnodeArg->sxBin.pnode2->sxFnc.hintOffset  = shortNameOffset;\n            }\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeArg);\n        }\n        pidHint = nullptr;\n        pFullNameHint = nullptr;\n        if (tkComma != m_token.tk)\n        {\n            break;\n        }\n        m_pscan->ScanForcingPid();\n        if (tkRCurly == m_token.tk)\n        {\n            break;\n        }\n    }\n\n    m_hasDeferredShorthandInitError = m_hasDeferredShorthandInitError || hasDeferredInitError;\n\n    if (buildAST)\n    {\n        AssertMem(lastNodeRef);\n        AssertNodeMem(*lastNodeRef);\n        pnodeList->ichLim = (*lastNodeRef)->ichLim;\n    }\n\n    return pnodeList;\n}\n\nBOOL Parser::DeferredParse(Js::LocalFunctionId functionId)\n{\n    if ((m_grfscr & fscrDeferFncParse) != 0)\n    {\n        if (m_stoppedDeferredParse)\n        {\n            return false;\n        }\n        if (PHASE_OFF_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, functionId))\n        {\n            return false;\n        }\n        if (PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, functionId))\n        {\n            return true;\n        }\n#if ENABLE_PROFILE_INFO\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n        if (m_sourceContextInfo->sourceDynamicProfileManager != nullptr)\n        {\n            Js::ExecutionFlags flags = m_sourceContextInfo->sourceDynamicProfileManager->IsFunctionExecuted(functionId);\n            return flags != Js::ExecutionFlags_Executed;\n        }\n#endif\n#endif\n        return true;\n    }\n\n    return false;\n}\n\n//\n// Call this in ParseFncDecl only to check (and reset) if ParseFncDecl is re-parsing a deferred\n// function body. If a deferred function is called and being re-parsed, it shouldn't be deferred again.\n//\nBOOL Parser::IsDeferredFnc()\n{\n    if (m_grfscr & fscrDeferredFnc)\n    {\n        m_grfscr &= ~fscrDeferredFnc;\n        return true;\n    }\n\n    return false;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseFncDecl(ushort flags, LPCOLESTR pNameHint, const bool needsPIDOnRCurlyScan, bool resetParsingSuperRestrictionState, bool fUnaryOrParen)\n{\n    AutoParsingSuperRestrictionStateRestorer restorer(this);\n    if (resetParsingSuperRestrictionState)\n    {\n        //  ParseFncDecl will always reset m_parsingSuperRestrictionState to super disallowed unless explicitly disabled\n        this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperDisallowed;\n    }\n\n    ParseNodePtr pnodeFnc = nullptr;\n    ParseNodePtr *ppnodeVarSave = nullptr;\n    ParseNodePtr pnodeFncBlockScope = nullptr;\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n    bool funcHasName = false;\n    bool fDeclaration = flags & fFncDeclaration;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    charcount_t ichMin = this->m_pscan->IchMinTok();\n    bool wasInDeferredNestedFunc = false;\n\n    uint tryCatchOrFinallyDepthSave = this->m_tryCatchOrFinallyDepth;\n    this->m_tryCatchOrFinallyDepth = 0;\n\n    if (this->m_arrayDepth)\n    {\n        this->m_funcInArrayDepth++; // Count function depth within array literal\n    }\n\n    // Update the count of functions nested in the current parent.\n    Assert(m_pnestedCount || !buildAST);\n    uint *pnestedCountSave = m_pnestedCount;\n    if (buildAST || m_pnestedCount)\n    {\n        (*m_pnestedCount)++;\n    }\n\n    uint scopeCountNoAstSave = m_scopeCountNoAst;\n    m_scopeCountNoAst = 0;\n\n    bool noStmtContext = false;\n\n    if (fDeclaration)\n    {\n        noStmtContext = m_pstmtCur->GetNop() != knopBlock;\n\n        if (noStmtContext)\n        {\n            // We have a function declaration like \"if (a) function f() {}\". We didn't see\n            // a block scope on the way in, so we need to pretend we did. Note that this is a syntax error\n            // in strict mode.\n            if (!this->FncDeclAllowedWithoutContext(flags))\n            {\n                Error(ERRsyntax);\n            }\n            pnodeFncBlockScope = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n            if (buildAST)\n            {\n                PushFuncBlockScope(pnodeFncBlockScope, &ppnodeScopeSave, &ppnodeExprScopeSave);\n            }\n        }\n    }\n\n    // Create the node.\n    pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetDeclaration(fDeclaration);\n    pnodeFnc->sxFnc.astSize             = 0;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFnc->sxFnc.functionId = (*m_nextFunctionId)++;\n\n    // Push new parser state with this new function node\n\n    AppendFunctionToScopeList(fDeclaration, pnodeFnc);\n\n    // Start the argument list.\n    ppnodeVarSave = m_ppnodeVar;\n\n    if (buildAST)\n    {\n        pnodeFnc->sxFnc.lineNumber = m_pscan->LineCur();\n        pnodeFnc->sxFnc.columnNumber = CalculateFunctionColumnNumber();\n        pnodeFnc->sxFnc.SetNested(m_currentNodeFunc != nullptr); // If there is a current function, then we're a nested function.\n        pnodeFnc->sxFnc.SetStrictMode(IsStrictMode()); // Inherit current strict mode -- may be overridden by the function itself if it contains a strict mode directive.\n        pnodeFnc->sxFnc.firstDefaultArg = 0;\n\n        m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n    }\n    else // if !buildAST\n    {\n        wasInDeferredNestedFunc = m_inDeferredNestedFunc;\n        m_inDeferredNestedFunc = true;\n    }\n\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    AnalysisAssert(pnodeFnc);\n    pnodeFnc->sxFnc.SetIsAsync((flags & fFncAsync) != 0);\n    pnodeFnc->sxFnc.SetIsLambda(fLambda);\n    pnodeFnc->sxFnc.SetIsMethod((flags & fFncMethod) != 0);\n    pnodeFnc->sxFnc.SetIsClassMember((flags & fFncClassMember) != 0);\n    pnodeFnc->sxFnc.SetIsModule(fModule);\n\n    bool needScanRCurly = true;\n    bool result = ParseFncDeclHelper<buildAST>(pnodeFnc, pNameHint, flags, &funcHasName, fUnaryOrParen, noStmtContext, &needScanRCurly, fModule);\n    if (!result)\n    {\n        Assert(!pnodeFncBlockScope);\n\n        return pnodeFnc;\n    }\n\n    AnalysisAssert(pnodeFnc);\n\n    *m_ppnodeVar = nullptr;\n    m_ppnodeVar = ppnodeVarSave;\n\n    if (m_currentNodeFunc && (pnodeFnc->sxFnc.CallsEval() || pnodeFnc->sxFnc.ChildCallsEval()))\n    {\n        GetCurrentFunctionNode()->sxFnc.SetChildCallsEval(true);\n    }\n\n    ParseNodePtr pnodeFncParent = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n\n    // Lambdas do not have \"arguments\" and instead capture their parent's\n    // binding of \"arguments.  To ensure the arguments object of the enclosing\n    // non-lambda function is loaded propagate the UsesArguments flag up to\n    // the parent function\n    if ((flags & fFncLambda) != 0 && pnodeFnc->sxFnc.UsesArguments())\n    {\n        if (pnodeFncParent != nullptr)\n        {\n            pnodeFncParent->sxFnc.SetUsesArguments();\n        }\n        else\n        {\n            m_UsesArgumentsAtGlobal = true;\n        }\n    }\n\n    if (needScanRCurly && !fModule)\n    {\n        // Consume the next token now that we're back in the enclosing function (whose strictness may be\n        // different from the function we just finished).\n#if DBG\n        bool expectedTokenValid = m_token.tk == tkRCurly;\n        AssertMsg(expectedTokenValid, \"Invalid token expected for RCurly match\");\n#endif\n        // The next token may need to have a PID created in !buildAST mode, as we may be parsing a method with a string name.\n        if (needsPIDOnRCurlyScan)\n        {\n            m_pscan->ScanForcingPid();\n        }\n        else\n        {\n            m_pscan->Scan();\n        }\n    }\n\n    m_pnestedCount = pnestedCountSave;\n    Assert(!buildAST || !wasInDeferredNestedFunc);\n    m_inDeferredNestedFunc = wasInDeferredNestedFunc;\n\n    if (this->m_arrayDepth)\n    {\n        this->m_funcInArrayDepth--;\n        if (this->m_funcInArrayDepth == 0)\n        {\n            // We disable deferred parsing if array literals dominate.\n            // But don't do this if the array literal is dominated by function bodies.\n            if (flags & (fFncMethod | fFncClassMember) && m_token.tk != tkSColon)\n            {\n                // Class member methods have optional separators. We need to check whether we are\n                // getting the IchLim of the correct token.\n                Assert(m_pscan->m_tkPrevious == tkRCurly && needScanRCurly);\n\n                this->m_funcInArray += m_pscan->IchMinTok() - /*tkRCurly*/ 1 - ichMin;\n            }\n            else\n            {\n                this->m_funcInArray += m_pscan->IchLimTok() - ichMin;\n            }\n        }\n    }\n\n    m_scopeCountNoAst = scopeCountNoAstSave;\n\n    if (buildAST && fDeclaration && !IsStrictMode())\n    {\n        if (pnodeFnc->sxFnc.pnodeName != nullptr && pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl &&\n            GetCurrentBlock()->sxBlock.blockType == PnodeBlockType::Regular)\n        {\n            // Add a function-scoped VarDecl with the same name as the function for\n            // back compat with pre-ES6 code that declares functions in blocks. The\n            // idea is that the last executed declaration wins at the function scope\n            // level and we accomplish this by having each block scoped function\n            // declaration assign to both the block scoped \"let\" binding, as well\n            // as the function scoped \"var\" binding.\n            bool isRedecl = false;\n            ParseNodePtr vardecl = CreateVarDeclNode(pnodeFnc->sxFnc.pnodeName->sxVar.pid, STVariable, false, nullptr, false, &isRedecl);\n            vardecl->sxVar.isBlockScopeFncDeclVar = true;\n            if (isRedecl)\n            {\n                vardecl->sxVar.sym->SetHasBlockFncVarRedecl();\n            }\n        }\n    }\n\n    if (pnodeFncBlockScope)\n    {\n        Assert(pnodeFncBlockScope->sxBlock.pnodeStmt == nullptr);\n        pnodeFncBlockScope->sxBlock.pnodeStmt = pnodeFnc;\n        if (buildAST)\n        {\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n        }\n        FinishParseBlock(pnodeFncBlockScope);\n        return pnodeFncBlockScope;\n    }\n\n    this->m_tryCatchOrFinallyDepth = tryCatchOrFinallyDepthSave;\n\n    return pnodeFnc;\n}\n\nbool Parser::FncDeclAllowedWithoutContext(ushort flags)\n{\n    // Statement context required for strict mode, async functions, and generators.\n    // Note that generators aren't detected yet when this method is called; they're checked elsewhere.\n    return !IsStrictMode() && !(flags & fFncAsync);\n}\n\nuint Parser::CalculateFunctionColumnNumber()\n{\n    uint columnNumber;\n\n    if (m_pscan->IchMinTok() >= m_pscan->IchMinLine())\n    {\n        // In scenarios involving defer parse IchMinLine() can be incorrect for the first line after defer parse\n        columnNumber = m_pscan->IchMinTok() - m_pscan->IchMinLine();\n        if (m_functionBody != nullptr && m_functionBody->GetRelativeLineNumber() == m_pscan->LineCur())\n        {\n            // Adjust the column if it falls on the first line, where the re-parse is happening.\n            columnNumber += m_functionBody->GetRelativeColumnNumber();\n        }\n    }\n    else if (m_currentNodeFunc)\n    {\n        // For the first line after defer parse, compute the column relative to the column number\n        // of the lexically parent function.\n        ULONG offsetFromCurrentFunction = m_pscan->IchMinTok() - m_currentNodeFunc->ichMin;\n        columnNumber = m_currentNodeFunc->sxFnc.columnNumber + offsetFromCurrentFunction ;\n    }\n    else\n    {\n        // if there is no current function, lets give a default of 0.\n        columnNumber = 0;\n    }\n\n    return columnNumber;\n}\n\nvoid Parser::AppendFunctionToScopeList(bool fDeclaration, ParseNodePtr pnodeFnc)\n{\n    if (!fDeclaration && m_ppnodeExprScope)\n    {\n        // We're tracking function expressions separately from declarations in this scope\n        // (e.g., inside a catch scope in standards mode).\n        Assert(*m_ppnodeExprScope == nullptr);\n        *m_ppnodeExprScope = pnodeFnc;\n        m_ppnodeExprScope = &pnodeFnc->sxFnc.pnodeNext;\n    }\n    else\n    {\n        Assert(*m_ppnodeScope == nullptr);\n        *m_ppnodeScope = pnodeFnc;\n        m_ppnodeScope = &pnodeFnc->sxFnc.pnodeNext;\n    }\n}\n\n/***************************************************************************\nParse a function definition.\n***************************************************************************/\ntemplate<bool buildAST>\nbool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)\n{\n    ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();\n    // is the following correct? When buildAST is false, m_currentNodeDeferredFunc can be nullptr on transition to deferred parse from non-deferred\n    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    bool fDeclaration = (flags & fFncDeclaration) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fDeferred = false;\n    StmtNest *pstmtSave;\n    ParseNodePtr *lastNodeRef = nullptr;\n    bool fFunctionInBlock = false;\n    if (buildAST)\n    {\n        fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);\n    }\n\n    // Save the position of the scanner in case we need to inspect the name hint later\n    RestorePoint beginNameHint;\n    m_pscan->Capture(&beginNameHint);\n\n    ParseNodePtr pnodeFncExprScope = nullptr;    \n    Scope *fncExprScope = nullptr;\n    if (!fDeclaration)\n    {\n        pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);\n        fncExprScope = pnodeFncExprScope->sxBlock.scope;\n\n        // Function expression: push the new function onto the stack now so that the name (if any) will be\n        // local to the new function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    *pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);\n\n    if (fDeclaration)\n    {\n        // Declaration statement: push the new function now, after parsing the name, so the name is local to the\n        // enclosing function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())\n    {\n        // Generator decl not allowed outside stmt context. (We have to wait until we've parsed the '*' to\n        // detect generator.)\n        Error(ERRsyntax, pnodeFnc);\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);\n\n    if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);\n    }\n\n    if (fncExprScope && !*pHasName)\n    {\n        FinishParseBlock(pnodeFncExprScope);\n        m_nextBlockId--;\n        Adelete(&m_nodeAllocator, fncExprScope);\n        fncExprScope = nullptr;\n        pnodeFncExprScope = nullptr;\n    }\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.scope = fncExprScope;\n    }\n\n    // Start a new statement stack.\n    bool topLevelStmt =\n        buildAST &&\n        !fFunctionInBlock &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);\n\n    pstmtSave = m_pstmtCur;\n    SetCurrentStatement(nullptr);\n\n    // Function definition is inside the parent function's parameter scope\n    bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;\n\n    if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)\n    {\n        // Or this is a function expression or class enclosed in a parameter scope\n        isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;\n    }\n\n    Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint beginFormals;\n    m_pscan->Capture(&beginFormals);\n    BOOL fWasAlreadyStrictMode = IsStrictMode();\n    BOOL oldStrictMode = this->m_fUseStrictMode;\n\n    if (fLambda)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);\n    }\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n    if ((!fDeclaration && m_ppnodeExprScope) ||\n        isEnclosedInParamScope ||\n        (flags & (fFncNoName | fFncLambda)))\n    {\n        // NOTE: Don't defer if this is a function expression inside a construct that induces\n        // a scope nested within the current function (like a with, or a catch in ES5 mode, or\n        // any function declared inside a nested lexical block or param scope in ES6 mode).\n        // We won't be able to reconstruct the scope chain properly when we come back and\n        // try to compile just the function expression.\n        // Also shut off deferring on getter/setter or other construct with unusual text bounds\n        // (fFncNoName|fFncLambda) as these are usually trivial, and re-parsing is problematic.\n        m_grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool saveInFIB = this->m_inFIB;\n    this->m_inFIB = fFunctionInBlock || this->m_inFIB;\n\n    bool isTopLevelDeferredFunc = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }\n        ~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }\n        Parser *m_parser;\n    } flag(this);\n\n    bool doParallel = false;\n    bool parallelJobStarted = false;\n    if (buildAST)\n    {\n        bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;\n\n        BOOL isDeferredFnc = IsDeferredFnc();\n        AnalysisAssert(isDeferredFnc || pnodeFnc);\n        // These are the conditions that prohibit upfront deferral *and* redeferral.\n        isTopLevelDeferredFunc =\n            (!fLambda\n             && pnodeFnc\n             && DeferredParse(pnodeFnc->sxFnc.functionId)\n             && (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))\n             && !m_InAsmMode\n            // Don't defer a module function wrapper because we need to do export resolution at parse time\n             && !fModule\n            );\n\n        if (pnodeFnc)\n        {\n            pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));\n            pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (isTopLevelDeferredFunc)\n            {\n                // Block-scoping is the only non-heuristic reason for not deferring this function up front.\n                // So on creating the full FunctionBody at byte code gen time, verify that there is no\n                // block-scoped content visible to this function so it can remain a redeferral candidate.\n                pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            isTopLevelDeferredFunc = false;\n        }        \n\n        // These are heuristic conditions that prohibit upfront deferral but not redeferral.\n        isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && \n            (!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));\n;\n        if (!fLambda &&\n            !isDeferredFnc &&\n            !isLikelyIIFE &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(pnodeFncSave && m_currDeferredStub) &&\n            !(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))\n        {\n            doParallel = DoParallelParse(pnodeFnc);\n#if ENABLE_BACKGROUND_PARSING\n            if (doParallel)\n            {\n                BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n                Assert(bgp);\n                if (bgp->HasFailedBackgroundParseItem())\n                {\n                    Error(ERRsyntax);\n                }\n                doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);\n                if (doParallel)\n                {\n                    parallelJobStarted = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    doParallel = FastScanFormalsAndBody();\n                    if (doParallel)\n                    {\n                        // Let the foreground thread take care of marking the limit on the function node,\n                        // because in some cases this function's caller will want to change that limit,\n                        // so we don't want the background thread to try and touch it.\n                        pnodeFnc->ichLim = m_pscan->IchLimTok();\n                        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!doParallel)\n    {\n        // We don't want to, or couldn't, let the main thread scan past this function body, so parse\n        // it for real.\n        ParseNodePtr pnodeRealFnc = pnodeFnc;\n        if (parallelJobStarted)\n        {\n            // We have to deal with a failure to fast-scan the function (due to syntax error? \"/\"?) when\n            // a background thread may already have begun to work on the job. Both threads can't be allowed to\n            // operate on the same node.\n            pnodeFnc = CreateDummyFuncNode(fDeclaration);\n        }\n\n        AnalysisAssert(pnodeFnc);\n        ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n        AnalysisAssert(pnodeBlock != nullptr);\n        pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ppnodeScopeSave = m_ppnodeScope;\n        if (pnodeBlock)\n        {\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n        }\n\n        // Keep nested function declarations and expressions in the same list at function scope.\n        // (Indicate this by nulling out the current function expressions list.)\n        ppnodeExprScopeSave = m_ppnodeExprScope;\n        m_ppnodeExprScope = nullptr;\n\n        if (!skipFormals)\n        {\n            bool fLambdaParamsSave = m_reparsingLambdaParams;\n            if (fLambda)\n            {\n                m_reparsingLambdaParams = true;\n            }\n            this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);\n            m_reparsingLambdaParams = fLambdaParamsSave;\n        }\n\n        // Create function body scope\n        ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        // Set the parameter block's child to the function body block.\n        // The pnodeFnc->sxFnc.pnodeScopes list is constructed in such a way that it includes all the scopes in this list.\n        // For example if the param scope has one function and body scope has one function then the list will look like below,\n        // param scope block -> function decl from param scope -> body socpe block -> function decl from body scope.\n        *m_ppnodeScope = pnodeInnerBlock;\n        pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n        // This synthetic block scope will contain all the nested scopes.\n        m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n        pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n        // DEFER: Begin deferral here (after names are parsed and name nodes created).\n        // Create no more AST nodes until we're done.\n\n        // Try to defer this func if all these are true:\n        //  0. We are not already in deferred parsing (i.e. buildAST is true)\n        //  1. We are not re-parsing a deferred func which is being invoked.\n        //  2. Dynamic profile suggests this func can be deferred (and deferred parse is on).\n        //  3. This func is top level or defer nested func is on.\n        //  4. Optionally, the function is non-nested and not in eval, or the deferral decision was based on cached profile info,\n        //     or the function is sufficiently long. (I.e., don't defer little nested functions unless we're\n        //     confident they'll never be executed, because un-deferring nested functions is more expensive.)\n        //     NOTE: I'm disabling #4 by default, because we've found other ways to reduce the cost of un-deferral,\n        //           and we don't want to create function bodies aggressively for little functions.\n\n        // We will also temporarily defer all asm.js functions, except for the asm.js\n        // module itself, which we will never defer\n        bool strictModeTurnedOn = false;\n\n        if (isTopLevelDeferredFunc &&\n            !(this->m_grfscr & fscrEvalCode) &&\n            pnodeFnc->sxFnc.IsNested() &&\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n            m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)\n            ))\n        {\n            // Try to scan ahead to the end of the function. If we get there before we've scanned a minimum\n            // number of tokens, don't bother deferring, because it's too small.\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))\n            {\n                isTopLevelDeferredFunc = false;\n            }\n        }\n\n        Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (paramScope != nullptr)\n        {\n            if (CONFIG_FLAG(ForceSplitScope))\n            {\n                paramScope->SetCannotMergeWithBodyScope();\n            }\n            else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())\n            {\n                if (paramScope->GetCanMergeWithBodyScope())\n                {\n                    paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {\n                        if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                        {\n                            // One of the symbol has non local reference. Mark the param scope as we can't merge it with body scope.\n                            paramScope->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        Assert(pnodeFnc->sxFnc.UsesArguments());\n                        // Arguments symbol is captured in the param scope\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)\n                {\n                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function\n                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var\n                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add\n                        // the name symbol to the param scope by splitting it.\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n\n            }\n        }\n\n        if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()\n            && (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))\n        {\n            Error(ERRNonSimpleParamListArgumentsUse);\n        }\n\n        // If the param scope is merged with the body scope we want to use the param scope symbols in the body scope.\n        // So add a pid ref for the body using the param scope symbol. Note that in this case the same symbol will occur twice\n        // in the same pid ref stack.\n        if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())\n        {\n            paramScope->ForEachSymbol([this](Symbol* paramSym)\n            {\n                PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                ref->SetSym(paramSym);\n            });\n        }\n\n        if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))\n        {\n            AssertMsg(!fLambda, \"Deferring function parsing of a function does not handle lambda syntax\");\n            fDeferred = true;\n\n            this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);\n        }\n        else\n        {\n            if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda.\n            {\n                m_pscan->Scan();\n            }\n\n            if (fLambda)\n            {\n                BOOL hadNewLine = m_pscan->FHadNewLine();\n\n                // it can be the case we do not have a fat arrow here if there is a valid expression on the left hand side\n                // of the fat arrow, but that expression does not parse as a parameter list.  E.g.\n                //    a.x => { }\n                // Therefore check for it and error if not found.\n                // LS Mode : since this is a lambda we supposed to get the fat arrow, if not we will skip till we get that fat arrow.\n                ChkCurTok(tkDArrow, ERRnoDArrow);\n\n                // Newline character between arrow parameters and fat arrow is a syntax error but we want to check for\n                // this after verifying there was a => token. Otherwise we would throw the wrong error.\n                if (hadNewLine)\n                {\n                    Error(ERRsyntax);\n                }\n            }\n\n            AnalysisAssert(pnodeFnc);\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                // Add a new symbol reference for each formal in the param scope to the body scope.\n                // While inserting symbols into the symbol list we always insert at the front, so while traversing the list we will be visiting the last added\n                // formals first. Normal insertion of those into the body will reverse the order of symbols, which will eventually result in different order\n                // for scope slots allocation for the corresponding symbol in both param and body scope. Inserting them in the opposite order will help us\n                // have the same sequence for scope slots allocation in both scopes. This makes it easy to read the bytecode and may help in some optimization\n                // later.\n                paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n\n                    ParseNodePtr paramNode = nullptr;\n                    if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        m_ppnodeVar = ppnodeVarSave;\n                    }\n                    else\n                    {\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                    }\n\n                    Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                    paramNode->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!fLambda)\n                {\n                    // In split scope case ideally the arguments object should be in the param scope.\n                    // Right now referring to arguments in the param scope is a SyntaxError, so we have to\n                    // add a duplicate symbol in the body scope and copy over the value in BeginBodySope.\n                    ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);\n                    Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                }\n            }\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            m_ppnodeExprScope = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;\n                if (isEnclosedInParamScope)\n                {\n                    // if the enclosed scope is the param scope we would not have created the deferred stub.\n                    m_currDeferredStub = nullptr;\n                }\n                else if (pnodeFncSave && m_currDeferredStub)\n                {\n                    // the Deferred stub will not match for the function which are defined on lambda formals.\n                    // Since this is not determined upfront that the current function is a part of outer function or part of lambda formal until we have seen the Arrow token.\n                    // Due to that the current function may be fetching stubs from the outer function (outer of the lambda) - rather then the lambda function. The way to fix is to match\n                    // the function start with the stub. Because they should match. We need to have previous sibling concept as the lambda formals can have more than one\n                    // functions and we want to avoid getting wrong stub.\n\n                    if (pnodeFncSave->sxFnc.nestedCount == 1)\n                    {\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n\n                    if (m_prevSiblingDeferredStub == nullptr)\n                    {\n                        m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));\n                    }\n\n                    if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)\n                    {\n                        m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n                    else\n                    {\n                        m_currDeferredStub = nullptr;\n                    }\n                }\n\n                if (m_token.tk != tkLCurly && fLambda)\n                {\n                    ParseExpressionLambdaBody<true>(pnodeFnc);\n                    *pNeedScanRCurly = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);\n                }\n                m_currDeferredStub = saveCurrentStub;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);\n            }\n        }\n\n        if (pnodeInnerBlock)\n        {\n            FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);\n        }\n\n        if (!fModule && (m_token.tk == tkLCurly || !fLambda))\n        {\n            this->AddArgumentsNodeToVars(pnodeFnc);\n        }\n\n        // Restore the lists of scopes that contain function expressions.\n\n        Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n        m_ppnodeExprScope = ppnodeExprScopeSave;\n\n        AssertMem(m_ppnodeScope);\n        Assert(nullptr == *m_ppnodeScope);\n        m_ppnodeScope = ppnodeScopeSave;\n\n        if (pnodeBlock)\n        {\n            FinishParseBlock(pnodeBlock, *pNeedScanRCurly);\n        }\n\n        if (IsStrictMode() || strictModeTurnedOn)\n        {\n            this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode\n\n            if (!fWasAlreadyStrictMode)\n            {\n                // If this function turned on strict mode then we didn't check the formal\n                // parameters or function name hint for future reserved word usage. So do that now.\n                RestorePoint afterFnc;\n                m_pscan->Capture(&afterFnc);\n\n                if (*pHasName)\n                {\n                    // Rewind to the function name hint and check if the token is a reserved word.\n                    m_pscan->SeekTo(beginNameHint);\n                    m_pscan->Scan();\n                    if (pnodeFnc->sxFnc.IsGenerator())\n                    {\n                        Assert(m_token.tk == tkStar);\n                        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(flags & fFncClassMember));\n                        m_pscan->Scan();\n                    }\n                    if (m_token.IsReservedWord())\n                    {\n                        IdentifierExpectedError(m_token);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n                }\n\n                // Fast forward to formal parameter list, check for future reserved words,\n                // then restore scanner as it was.\n                m_pscan->SeekToForcingPid(beginFormals);\n                CheckStrictFormalParameters();\n                m_pscan->SeekTo(afterFnc);\n            }\n\n            if (buildAST)\n            {\n                if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = oldStrictMode;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);\n        }\n\n        if (fDeferred)\n        {\n            AnalysisAssert(pnodeFnc);\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (parallelJobStarted)\n        {\n            pnodeFnc = pnodeRealFnc;\n            m_currentNodeFunc = pnodeRealFnc;\n\n            // Let the foreground thread take care of marking the limit on the function node,\n            // because in some cases this function's caller will want to change that limit,\n            // so we don't want the background thread to try and touch it.\n            pnodeFnc->ichLim = m_pscan->IchLimTok();\n            pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        }\n    }\n\n    // after parsing asm.js module, we want to reset asm.js state before continuing\n    AnalysisAssert(pnodeFnc);\n    if (pnodeFnc->sxFnc.GetAsmjsMode())\n    {\n        m_InAsmMode = false;\n    }\n\n    // Restore the statement stack.\n    Assert(nullptr == m_pstmtCur);\n    SetCurrentStatement(pstmtSave);\n\n    if (pnodeFncExprScope)\n    {\n        FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);\n    }\n    if (!m_stoppedDeferredParse)\n    {\n        m_grfscr |= uDeferSave;\n    }\n    m_inFIB = saveInFIB;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n\n    // Restore the current function.\n    if (buildAST)\n    {\n        Assert(pnodeFnc == m_currentNodeFunc);\n\n        m_currentNodeFunc = pnodeFncSave;\n        m_pCurrentAstSize = pAstSizeSave;\n\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;\n        }\n    }\n    else\n    {\n        Assert(pnodeFnc == m_currentNodeDeferredFunc);\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);\n            m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;\n        }\n        m_currentNodeDeferredFunc = pnodeFncSave;\n    }\n\n    if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}\n\ntemplate<bool buildAST>\nvoid Parser::UpdateCurrentNodeFunc(ParseNodePtr pnodeFnc, bool fLambda)\n{\n    if (buildAST)\n    {\n        // Make this the current function and start its sub-function list.\n        m_currentNodeFunc = pnodeFnc;\n\n        Assert(m_currentNodeDeferredFunc == nullptr);\n\n        if (!fLambda)\n        {\n            m_currentNodeNonLambdaFunc = pnodeFnc;\n        }\n    }\n    else // if !buildAST\n    {\n        AnalysisAssert(pnodeFnc);\n\n        if (!fLambda)\n        {\n            m_currentNodeNonLambdaDeferredFunc = pnodeFnc;\n        }\n\n        m_currentNodeDeferredFunc = pnodeFnc;\n    }\n}\n\nvoid Parser::ParseTopLevelDeferredFunc(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncParent, LPCOLESTR pNameHint)\n{\n    // Parse a function body that is a transition point from building AST to doing fast syntax check.\n\n    pnodeFnc->sxFnc.pnodeVars = nullptr;\n    pnodeFnc->sxFnc.pnodeBody = nullptr;\n\n    this->m_deferringAST = TRUE;\n\n    // Put the scanner into \"no hashing\" mode.\n    BYTE deferFlags = m_pscan->SetDeferredParse(TRUE);\n\n    m_pscan->Scan();\n\n    ChkCurTok(tkLCurly, ERRnoLcurly);\n\n    ParseNodePtr *ppnodeVarSave = m_ppnodeVar;\n\n    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n    if (pnodeFncParent != nullptr\n        && m_currDeferredStub != nullptr\n        // We don't create stubs for function bodies in parameter scope.\n        && pnodeFnc->sxFnc.pnodeScopes->sxBlock.blockType != PnodeBlockType::Parameter)\n    {\n        // We've already parsed this function body for syntax errors on the initial parse of the script.\n        // We have information that allows us to skip it, so do so.\n\n        DeferredFunctionStub *stub = m_currDeferredStub + (pnodeFncParent->sxFnc.nestedCount - 1);\n        Assert(pnodeFnc->ichMin == stub->ichMin);\n        if (stub->fncFlags & kFunctionCallsEval)\n        {\n            this->MarkEvalCaller();\n        }\n        if (stub->fncFlags & kFunctionChildCallsEval)\n        {\n            pnodeFnc->sxFnc.SetChildCallsEval(true);\n        }\n        if (stub->fncFlags & kFunctionHasWithStmt)\n        {\n            pnodeFnc->sxFnc.SetHasWithStmt(true);\n        }\n\n        PHASE_PRINT_TRACE1(\n            Js::SkipNestedDeferredPhase,\n            _u(\"Skipping nested deferred function %d. %s: %d...%d\\n\"),\n            pnodeFnc->sxFnc.functionId, GetFunctionName(pnodeFnc, pNameHint), pnodeFnc->ichMin, stub->restorePoint.m_ichMinTok);\n\n        m_pscan->SeekTo(stub->restorePoint, m_nextFunctionId);\n        pnodeFnc->sxFnc.nestedCount = stub->nestedCount;\n        pnodeFnc->sxFnc.deferredStub = stub->deferredStubs;\n        if (stub->fncFlags & kFunctionStrictMode)\n        {\n            pnodeFnc->sxFnc.SetStrictMode(true);\n        }\n    }\n    else\n    {\n        ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true /* isSourceElementList */);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n    m_ppnodeVar = ppnodeVarSave;\n\n    // Restore the scanner's default hashing mode.\n    // Do this before we consume the next token.\n    m_pscan->SetDeferredParseFlags(deferFlags);\n\n    ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n\n#if DBG\n    pnodeFnc->sxFnc.deferredParseNextFunctionId = *this->m_nextFunctionId;\n#endif\n    this->m_deferringAST = FALSE;\n}\n\nbool Parser::DoParallelParse(ParseNodePtr pnodeFnc) const\n{\n#if ENABLE_BACKGROUND_PARSING\n    if (!PHASE_ON_RAW(Js::ParallelParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId))\n    {\n        return false;\n    }\n\n    BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n    return bgp != nullptr;\n#else\n    return false;\n#endif\n}\n\nbool Parser::ScanAheadToFunctionEnd(uint count)\n{\n    bool found = false;\n    uint curlyDepth = 0;\n\n    RestorePoint funcStart;\n    m_pscan->Capture(&funcStart);\n\n    for (uint i = 0; i < count; i++)\n    {\n        switch (m_token.tk)\n        {\n            case tkStrTmplBegin:\n            case tkStrTmplMid:\n            case tkStrTmplEnd:\n            case tkDiv:\n            case tkAsgDiv:\n            case tkScanError:\n            case tkEOF:\n                goto LEnd;\n\n            case tkLCurly:\n                UInt32Math::Inc(curlyDepth, Parser::OutOfMemory);\n                break;\n\n            case tkRCurly:\n                if (curlyDepth == 1)\n                {\n                    found = true;\n                    goto LEnd;\n                }\n                if (curlyDepth == 0)\n                {\n                    goto LEnd;\n                }\n                curlyDepth--;\n                break;\n        }\n\n        m_pscan->ScanAhead();\n    }\n\n LEnd:\n    m_pscan->SeekTo(funcStart);\n    return found;\n}\n\nbool Parser::FastScanFormalsAndBody()\n{\n    // The scanner is currently pointing just past the name of a function.\n    // The idea here is to find the end of the function body as quickly as possible,\n    // by tokenizing and tracking {}'s if possible.\n    // String templates require some extra logic but can be handled.\n\n    // The real wrinkle is \"/\" and \"/=\", which may indicate either a RegExp literal or a division, depending\n    // on the context.\n    // To handle this with minimal work, keep track of the last \";\" seen at each {} depth. If we see one of the\n    // difficult tokens, rewind to the last \";\" at the current {} depth and parse statements until we pass the\n    // point where we had to rewind. This will process the \"/\" as required.\n\n    RestorePoint funcStart;\n    m_pscan->Capture(&funcStart);\n\n    const int maxRestorePointDepth = 16;\n    struct FastScanRestorePoint\n    {\n        RestorePoint restorePoint;\n        uint parenDepth;\n        Js::LocalFunctionId functionId;\n        int blockId;\n\n        FastScanRestorePoint() : restorePoint(), parenDepth(0) {};\n    };\n    FastScanRestorePoint lastSColonAtCurlyDepth[maxRestorePointDepth];\n\n    charcount_t ichStart = m_pscan->IchMinTok();\n    uint blockIdSave = m_nextBlockId;\n    uint functionIdSave = *m_nextFunctionId;\n    uint curlyDepth = 0;\n    uint strTmplDepth = 0;\n    for (;;)\n    {\n        switch (m_token.tk)\n        {\n            case tkStrTmplBegin:\n                UInt32Math::Inc(strTmplDepth, Parser::OutOfMemory);\n                // Fall through\n\n            case tkStrTmplMid:\n            case tkLCurly:\n                UInt32Math::Inc(curlyDepth, Parser::OutOfMemory);\n                Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                break;\n\n            case tkStrTmplEnd:\n                // We can assert here, because the scanner will only return this token if we've told it we're\n                // in a string template.\n                Assert(strTmplDepth > 0);\n                strTmplDepth--;\n                break;\n\n            case tkRCurly:\n                if (curlyDepth == 1)\n                {\n                    Assert(strTmplDepth == 0);\n                    if (PHASE_TRACE1(Js::ParallelParsePhase))\n                    {\n                        Output::Print(_u(\"Finished fast seek: %d. %s -- %d...%d\\n\"),\n                                      m_currentNodeFunc->sxFnc.functionId,\n                                      GetFunctionName(m_currentNodeFunc, m_currentNodeFunc->sxFnc.hint),\n                                      ichStart, m_pscan->IchLimTok());\n                    }\n                    return true;\n                }\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    lastSColonAtCurlyDepth[curlyDepth].restorePoint.m_ichMinTok = (uint)-1;\n                }\n                curlyDepth--;\n                if (strTmplDepth > 0)\n                {\n                    m_pscan->SetScanState(Scanner_t::ScanState::ScanStateStringTemplateMiddleOrEnd);\n                }\n                break;\n\n            case tkSColon:\n                // Track the location of the \";\" (if it's outside parens, as we don't, for instance, want\n                // to track the \";\"'s in a for-loop header. If we find it's important to rewind within a paren\n                // expression, we can do something more sophisticated.)\n                if (curlyDepth < maxRestorePointDepth && lastSColonAtCurlyDepth[curlyDepth].parenDepth == 0)\n                {\n                    m_pscan->Capture(&lastSColonAtCurlyDepth[curlyDepth].restorePoint);\n                    lastSColonAtCurlyDepth[curlyDepth].functionId = *this->m_nextFunctionId;\n                    lastSColonAtCurlyDepth[curlyDepth].blockId = m_nextBlockId;\n                }\n                break;\n\n            case tkLParen:\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    UInt32Math::Inc(lastSColonAtCurlyDepth[curlyDepth].parenDepth);\n                }\n                break;\n\n            case tkRParen:\n                if (curlyDepth < maxRestorePointDepth)\n                {\n                    Assert(lastSColonAtCurlyDepth[curlyDepth].parenDepth != 0);\n                    lastSColonAtCurlyDepth[curlyDepth].parenDepth--;\n                }\n                break;\n\n            case tkID:\n            {\n                charcount_t tokLength = m_pscan->IchLimTok() - m_pscan->IchMinTok();\n                // Detect the function and class keywords so we can track function ID's.\n                // (In fast mode, the scanner doesn't distinguish keywords and doesn't point the token\n                // to a PID.)\n                // Detect try/catch/for to increment block count for them.\n                switch (tokLength)\n                {\n                case 3:\n                    if (!memcmp(m_pscan->PchMinTok(), \"try\", 3) || !memcmp(m_pscan->PchMinTok(), \"for\", 3))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                    }\n                    break;\n                case 5:\n                    if (!memcmp(m_pscan->PchMinTok(), \"catch\", 5))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                    }\n                    else if (!memcmp(m_pscan->PchMinTok(), \"class\", 5))\n                    {\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                        Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                    }\n                    break;\n                case 8:\n                    if (!memcmp(m_pscan->PchMinTok(), \"function\", 8))\n                    {\n                        // Account for the possible func expr scope or dummy block for missing {}'s around a declaration\n                        Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                        Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                    }\n                    break;\n                }\n                break;\n            }\n\n            case tkDArrow:\n                Int32Math::Inc(m_nextBlockId, &m_nextBlockId);\n                Int32Math::Inc(*this->m_nextFunctionId, (int*)this->m_nextFunctionId);\n                break;\n\n            case tkDiv:\n            case tkAsgDiv:\n            {\n                int opl;\n                OpCode nop;\n                tokens tkPrev = m_pscan->m_tkPrevious;\n                if ((m_pscan->m_phtbl->TokIsBinop(tkPrev, &opl, &nop) && nop != knopNone) ||\n                    (m_pscan->m_phtbl->TokIsUnop(tkPrev, &opl, &nop) &&\n                     nop != knopNone &&\n                     tkPrev != tkInc &&\n                     tkPrev != tkDec) ||\n                    tkPrev == tkColon ||\n                    tkPrev == tkLParen ||\n                    tkPrev == tkLBrack ||\n                    tkPrev == tkRETURN)\n                {\n                    // Previous token indicates that we're starting an expression here and can't have a\n                    // binary operator now.\n                    // Assume this is a RegExp.\n                    ParseRegExp<false>();\n                    break;\n                }\n                uint tempCurlyDepth = curlyDepth < maxRestorePointDepth ? curlyDepth : maxRestorePointDepth - 1;\n                for (; tempCurlyDepth != (uint)-1; tempCurlyDepth--)\n                {\n                    // We don't know whether we've got a RegExp or a divide. Rewind to the last safe \";\"\n                    // if we can and parse statements until we pass this point.\n                    if (lastSColonAtCurlyDepth[tempCurlyDepth].restorePoint.m_ichMinTok != -1)\n                    {\n                        break;\n                    }\n                }\n                if (tempCurlyDepth != (uint)-1)\n                {\n                    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n                    int32 *pastSizeSave = m_pCurrentAstSize;\n                    uint *pnestedCountSave = m_pnestedCount;\n                    ParseNodePtr *ppnodeScopeSave = m_ppnodeScope;\n                    ParseNodePtr *ppnodeExprScopeSave = m_ppnodeExprScope;\n\n                    ParseNodePtr pnodeFnc = CreateDummyFuncNode(true);\n                    m_ppnodeScope = &pnodeFnc->sxFnc.pnodeScopes;\n                    m_ppnodeExprScope = nullptr;\n\n                    charcount_t ichStop = m_pscan->IchLimTok();\n                    curlyDepth = tempCurlyDepth;\n                    m_pscan->SeekTo(lastSColonAtCurlyDepth[tempCurlyDepth].restorePoint);\n                    m_nextBlockId = lastSColonAtCurlyDepth[tempCurlyDepth].blockId;\n                    *this->m_nextFunctionId = lastSColonAtCurlyDepth[tempCurlyDepth].functionId;\n\n                    ParseNodePtr pnodeBlock = StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n\n                    m_pscan->Scan();\n                    do\n                    {\n                        ParseStatement<false>();\n                    }\n                    while(m_pscan->IchMinTok() < ichStop);\n\n                    FinishParseBlock(pnodeBlock);\n\n                    m_currentNodeFunc = pnodeFncSave;\n                    m_pCurrentAstSize = pastSizeSave;\n                    m_pnestedCount = pnestedCountSave;\n                    m_ppnodeScope = ppnodeScopeSave;\n                    m_ppnodeExprScope = ppnodeExprScopeSave;\n\n                    // We've already consumed the first token of the next statement, so just continue\n                    // without a further scan.\n                    continue;\n                }\n            }\n\n                // fall through to rewind to function start\n            case tkScanError:\n            case tkEOF:\n                // Unexpected token.\n                if (PHASE_TRACE1(Js::ParallelParsePhase))\n                {\n                    Output::Print(_u(\"Failed fast seek: %d. %s -- %d...%d\\n\"),\n                                  m_currentNodeFunc->sxFnc.functionId,\n                                  GetFunctionName(m_currentNodeFunc, m_currentNodeFunc->sxFnc.hint),\n                                  ichStart, m_pscan->IchLimTok());\n                }\n                m_nextBlockId = blockIdSave;\n                *m_nextFunctionId = functionIdSave;\n                m_pscan->SeekTo(funcStart);\n                return false;\n        }\n\n        m_pscan->ScanNoKeywords();\n    }\n}\n\nParseNodePtr Parser::CreateDummyFuncNode(bool fDeclaration)\n{\n    // Create a dummy node and make it look like the current function declaration.\n    // Do this in situations where we want to parse statements without impacting\n    // the state of the \"real\" AST.\n\n    ParseNodePtr pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetDeclaration(fDeclaration);\n    pnodeFnc->sxFnc.astSize             = 0;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.SetNested(m_currentNodeFunc != nullptr); // If there is a current function, then we're a nested function.\n    pnodeFnc->sxFnc.SetStrictMode(IsStrictMode()); // Inherit current strict mode -- may be overridden by the function itself if it contains a strict mode directive.\n    pnodeFnc->sxFnc.firstDefaultArg = 0;\n\n    m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n    m_currentNodeFunc = pnodeFnc;\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    return pnodeFnc;\n}\n\nvoid Parser::ParseNestedDeferredFunc(ParseNodePtr pnodeFnc, bool fLambda, bool *pNeedScanRCurly, bool *pStrictModeTurnedOn)\n{\n    // Parse a function nested inside another deferred function.\n\n    size_t lengthBeforeBody = this->GetSourceLength();\n\n    if (m_token.tk != tkLCurly && fLambda)\n    {\n        ParseExpressionLambdaBody<false>(pnodeFnc);\n        *pNeedScanRCurly = false;\n    }\n    else\n    {\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        bool* detectStrictModeOn = IsStrictMode() ? nullptr : pStrictModeTurnedOn;\n        m_ppnodeVar = &m_currentNodeDeferredFunc->sxFnc.pnodeVars;\n\n        ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true /* isSourceElementList */, detectStrictModeOn);\n\n        ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n    if (*pStrictModeTurnedOn)\n    {\n        pnodeFnc->sxFnc.SetStrictMode(true);\n    }\n\n    if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n    {\n        // Record the end of the function and the function ID increment that happens inside the function.\n        // Byte code gen will use this to build stub information to allow us to skip this function when the\n        // enclosing function is fully parsed.\n        RestorePoint *restorePoint = Anew(&m_nodeAllocator, RestorePoint);\n        m_pscan->Capture(restorePoint,\n                         *m_nextFunctionId - pnodeFnc->sxFnc.functionId - 1,\n                         lengthBeforeBody - this->GetSourceLength());\n        pnodeFnc->sxFnc.pRestorePoint = restorePoint;\n    }\n}\n\ntemplate<bool buildAST>\nbool Parser::ParseFncNames(ParseNodePtr pnodeFnc, ParseNodePtr pnodeFncParent, ushort flags, ParseNodePtr **pLastNodeRef)\n{\n    BOOL fDeclaration = flags & fFncDeclaration;\n    BOOL fIsAsync = flags & fFncAsync;\n    ParseNodePtr pnodeT;\n    charcount_t ichMinNames, ichLimNames;\n\n    // Get the names to bind to.\n    /*\n    * KaushiS [5/15/08]:\n    * ECMAScript defines a FunctionExpression as follows:\n    *\n    * \"function\" [Identifier] ( [FormalParameterList] ) { FunctionBody }\n    *\n    * The function name being optional is omitted by most real world\n    * code that uses a FunctionExpression to define a function. This however\n    * is problematic for tools because there isn't a function name that\n    * the runtime can provide.\n    *\n    * To fix this (primarily for the profiler), I'm adding simple, static\n    * name inferencing logic to the parser. When it encounters the following\n    * productions\n    *\n    *   \"var\" Identifier \"=\" FunctionExpression\n    *   \"var\" IdentifierA.IdentifierB...Identifier \"=\" FunctionExpression\n    *   Identifier = FunctionExpression\n    *   \"{\" Identifier: FunctionExpression \"}\"\n    *\n    * it associates Identifier with the function created by the\n    * FunctionExpression. This identifier is *not* the function's name. It\n    * is ignored by the runtime and is only an additional piece of information\n    * about the function (function name hint) that tools could opt to\n    * surface.\n    */\n\n    m_pscan->Scan();\n\n    // If generators are enabled then we are in a recent enough version\n    // that deferred parsing will create a parse node for pnodeFnc and\n    // it is safe to assume it is not null.\n    if (flags & fFncGenerator)\n    {\n        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n        pnodeFnc->sxFnc.SetIsGenerator();\n    }\n    else if (m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n        m_token.tk == tkStar &&\n        !(flags & fFncClassMember))\n    {\n        if (!fDeclaration)\n        {\n            bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(!fDeclaration);\n            m_pscan->Scan();\n            m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n        }\n        else\n        {\n            m_pscan->Scan();\n        }\n\n        pnodeFnc->sxFnc.SetIsGenerator();\n    }\n\n    if (fIsAsync)\n    {\n        if (pnodeFnc->sxFnc.IsGenerator())\n        {\n            Error(ERRsyntax);\n        }\n        pnodeFnc->sxFnc.SetIsAsync();\n    }\n\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.pnodeName = nullptr;\n    }\n\n    if ((m_token.tk != tkID || flags & fFncNoName)\n        && (IsStrictMode() || (pnodeFnc && pnodeFnc->sxFnc.IsGenerator()) || m_token.tk != tkYIELD || fDeclaration)) // Function expressions can have the name yield even inside generator functions\n    {\n        if (fDeclaration  ||\n            m_token.IsReservedWord())  // For example:  var x = (function break(){});\n        {\n            IdentifierExpectedError(m_token);\n        }\n        return false;\n    }\n\n    ichMinNames = m_pscan->IchMinTok();\n\n\n    Assert(m_token.tk == tkID || (m_token.tk == tkYIELD && !fDeclaration));\n\n    if (IsStrictMode())\n    {\n        CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n    }\n    Token tokenBase = m_token;\n    charcount_t ichMinBase = m_pscan->IchMinTok();\n    charcount_t ichLimBase = m_pscan->IchLimTok();\n\n    m_pscan->Scan();\n\n    IdentPtr pidBase = tokenBase.GetIdentifier(m_phtbl);\n    pnodeT = CreateDeclNode(knopVarDecl, pidBase, STFunction);\n    pnodeT->ichMin = ichMinBase;\n    pnodeT->ichLim = ichLimBase;\n\n    if (fDeclaration &&\n        pnodeFncParent &&\n        pnodeFncParent->sxFnc.pnodeName &&\n        pnodeFncParent->sxFnc.pnodeName->nop == knopVarDecl &&\n        pnodeFncParent->sxFnc.pnodeName->sxVar.pid == pidBase)\n    {\n        pnodeFncParent->sxFnc.SetNameIsHidden();\n    }\n\n    if (buildAST)\n    {\n        AnalysisAssert(pnodeFnc);\n        ichLimNames = pnodeT->ichLim;\n        AddToNodeList(&pnodeFnc->sxFnc.pnodeName, pLastNodeRef, pnodeT);\n\n        pnodeFnc->sxFnc.pnodeName->ichMin = ichMinNames;\n        pnodeFnc->sxFnc.pnodeName->ichLim = ichLimNames;\n        if (knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n        {\n            // Only one name (the common case).\n            pnodeFnc->sxFnc.pid = pnodeFnc->sxFnc.pnodeName->sxVar.pid;\n        }\n        else\n        {\n            // Multiple names. Turn the source into an IdentPtr.\n            pnodeFnc->sxFnc.pid = m_phtbl->PidHashNameLen(\n                m_pscan->PchBase() + ichMinNames, \n                m_pscan->AdjustedLast(),\n                ichLimNames - ichMinNames);\n        }\n    }\n\n    return true;\n}\n\nvoid Parser::ValidateFormals()\n{\n    ParseFncFormals<false>(nullptr, nullptr, fFncNoFlgs);\n    // Eat the tkRParen. The ParseFncDeclHelper caller expects to see it.\n    m_pscan->Scan();\n}\n\nvoid Parser::ValidateSourceElementList()\n{\n    ParseStmtList<false>(nullptr, nullptr, SM_NotUsed, true);\n}\n\nvoid Parser::UpdateOrCheckForDuplicateInFormals(IdentPtr pid, SList<IdentPtr> *formals)\n{\n    bool isStrictMode = IsStrictMode();\n    if (isStrictMode)\n    {\n        CheckStrictModeEvalArgumentsUsage(pid);\n    }\n\n    if (formals->Has(pid))\n    {\n        if (isStrictMode)\n        {\n            Error(ERRES5ArgSame);\n        }\n        else\n        {\n            Error(ERRFormalSame);\n        }\n    }\n    else\n    {\n        formals->Prepend(pid);\n    }\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseFncFormals(ParseNodePtr pnodeFnc, ParseNodePtr pnodeParentFnc, ushort flags)\n{\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fMethod = (flags & fFncMethod) != 0;\n    bool fNoArg = (flags & fFncNoArg) != 0;\n    bool fOneArg = (flags & fFncOneArg) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n\n    bool fPreviousYieldIsKeyword = false;\n    bool fPreviousAwaitIsKeyword = false;\n\n    if (fLambda)\n    {\n        fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeParentFnc != nullptr && pnodeParentFnc->sxFnc.IsGenerator());\n        fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync || (pnodeParentFnc != nullptr && pnodeParentFnc->sxFnc.IsAsync()));\n    }\n\n    Assert(!fNoArg || !fOneArg); // fNoArg and fOneArg can never be true at the same time.\n\n    // strictFormals corresponds to the StrictFormalParameters grammar production\n    // in the ES spec which just means duplicate names are not allowed\n    bool fStrictFormals = IsStrictMode() || fLambda || fMethod;\n\n    // When detecting duplicated formals pids are needed so force PID creation (unless the function should take 0 or 1 arg).\n    bool forcePid = fStrictFormals && !fNoArg && !fOneArg;\n    AutoTempForcePid autoForcePid(m_pscan, forcePid);\n\n    // Lambda's allow single formal specified by a single binding identifier without parentheses, special case it.\n    if (fLambda && m_token.tk == tkID)\n    {\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n\n        CreateVarDeclNode(pid, STFormal, false, nullptr, false);\n        CheckPidIsValid(pid);\n\n        m_pscan->Scan();\n\n        if (m_token.tk != tkDArrow)\n        {\n            Error(ERRsyntax, m_pscan->IchMinTok(), m_pscan->IchLimTok());\n        }\n\n        if (fLambda)\n        {\n            m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n            m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n        }\n\n        return;\n    }\n    else if (fLambda && m_token.tk == tkAWAIT)\n    {\n        // async await => {}\n        IdentifierExpectedError(m_token);\n    }\n\n    // Otherwise, must have a parameter list within parens.\n    ChkCurTok(tkLParen, ERRnoLparen);\n\n    // Now parse the list of arguments, if present\n    if (m_token.tk == tkRParen)\n    {\n        if (fOneArg)\n        {\n            Error(ERRSetterMustHaveOneParameter);\n        }\n    }\n    else\n    {\n        if (fNoArg)\n        {\n            Error(ERRGetterMustHaveNoParameters);\n        }\n        SList<IdentPtr> formals(&m_nodeAllocator);\n        ParseNodePtr pnodeT = nullptr;\n        bool seenRestParameter = false;\n        bool isNonSimpleParameterList = false;\n        for (Js::ArgSlot argPos = 0; ; ++argPos)\n        {\n            bool isBindingPattern = false;\n            if (m_scriptContext->GetConfig()->IsES6RestEnabled() && m_token.tk == tkEllipsis)\n            {\n                // Possible rest parameter\n                m_pscan->Scan();\n                seenRestParameter = true;\n            }\n            if (m_token.tk != tkID)\n            {\n                if (IsES6DestructuringEnabled() && IsPossiblePatternStart())\n                {\n                    // Mark that the function has a non simple parameter list before parsing the pattern since the pattern can have function definitions.\n                    this->GetCurrentFunctionNode()->sxFnc.SetHasNonSimpleParameterList();\n\n                    ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                    m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n                    ParseNodePtr * ppNodeLex = m_currentBlockInfo->m_ppnodeLex;\n                    Assert(ppNodeLex != nullptr);\n\n                    ParseNodePtr paramPattern = nullptr;\n                    ParseNodePtr pnodePattern = ParseDestructuredLiteral<buildAST>(tkLET, true /*isDecl*/, false /*topLevel*/);\n\n                    // Instead of passing the STFormal all the way on many methods, it seems it is better to change the symbol type afterward.\n                    for (ParseNodePtr lexNode = *ppNodeLex; lexNode != nullptr; lexNode = lexNode->sxVar.pnodeNext)\n                    {\n                        Assert(lexNode->IsVarLetOrConst());\n                        UpdateOrCheckForDuplicateInFormals(lexNode->sxVar.pid, &formals);\n                        lexNode->sxVar.sym->SetSymbolType(STFormal);\n                        if (m_currentNodeFunc != nullptr && lexNode->sxVar.pid == wellKnownPropertyPids.arguments)\n                        {\n                            m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                        }\n                    }\n\n                    m_ppnodeVar = ppnodeVarSave;\n                    if (buildAST)\n                    {\n                        paramPattern = CreateParamPatternNode(pnodePattern);\n\n                        // Linking the current formal parameter (which is pattern parameter) with other formals.\n                        *m_ppnodeVar = paramPattern;\n                        paramPattern->sxParamPattern.pnodeNext = nullptr;\n                        m_ppnodeVar = &paramPattern->sxParamPattern.pnodeNext;\n                    }\n\n                    isBindingPattern = true;\n                    isNonSimpleParameterList = true;\n                }\n                else\n                {\n                    IdentifierExpectedError(m_token);\n                }\n            }\n\n            if (!isBindingPattern)\n            {\n                IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n                LPCOLESTR pNameHint = pid->Psz();\n                uint32 nameHintLength = pid->Cch();\n                uint32 nameHintOffset = 0;\n\n                if (seenRestParameter)\n                {\n                    this->GetCurrentFunctionNode()->sxFnc.SetHasNonSimpleParameterList();\n                    if (flags & fFncOneArg)\n                    {\n                        // The parameter of a setter cannot be a rest parameter.\n                        Error(ERRUnexpectedEllipsis);\n                    }\n                    pnodeT = CreateDeclNode(knopVarDecl, pid, STFormal, false);\n                    pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    if (buildAST)\n                    {\n                        // When only validating formals, we won't have a function node.\n                        pnodeFnc->sxFnc.pnodeRest = pnodeT;\n                        if (!isNonSimpleParameterList)\n                        {\n                            // This is the first non-simple parameter we've seen. We need to go back\n                            // and set the Symbols of all previous parameters.\n                            MapFormalsWithoutRest(m_currentNodeFunc, [&](ParseNodePtr pnodeArg) { pnodeArg->sxVar.sym->SetIsNonSimpleParameter(true); });\n                        }\n                    }\n\n                    isNonSimpleParameterList = true;\n                }\n                else\n                {\n                    pnodeT = CreateVarDeclNode(pid, STFormal, false, nullptr, false);\n                    if (isNonSimpleParameterList)\n                    {\n                        pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    }\n                }\n\n                if (buildAST && pid == wellKnownPropertyPids.arguments)\n                {\n                    // This formal parameter overrides the built-in 'arguments' object\n                    m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                }\n\n                if (fStrictFormals)\n                {\n                    UpdateOrCheckForDuplicateInFormals(pid, &formals);\n                }\n\n                m_pscan->Scan();\n\n                if (seenRestParameter && m_token.tk != tkRParen && m_token.tk != tkAsg)\n                {\n                    Error(ERRRestLastArg);\n                }\n\n                if (m_token.tk == tkAsg && m_scriptContext->GetConfig()->IsES6DefaultArgsEnabled())\n                {\n                    if (seenRestParameter && m_scriptContext->GetConfig()->IsES6RestEnabled())\n                    {\n                        Error(ERRRestWithDefault);\n                    }\n\n                    // In defer parse mode we have to flag the function node to indicate that it has default arguments\n                    // so that it will be considered for any syntax error scenario.\n                    // Also mark it before parsing the expression as it may contain functions.\n                    ParseNode* currentFncNode = GetCurrentFunctionNode();\n                    if (!currentFncNode->sxFnc.HasDefaultArguments())\n                    {\n                        currentFncNode->sxFnc.SetHasDefaultArguments();\n                        currentFncNode->sxFnc.SetHasNonSimpleParameterList();\n                        currentFncNode->sxFnc.firstDefaultArg = argPos;\n                    }\n\n                    m_pscan->Scan();\n                    ParseNodePtr pnodeInit = ParseExpr<buildAST>(koplCma, nullptr, TRUE, FALSE, pNameHint, &nameHintLength, &nameHintOffset);\n\n                    if (buildAST && pnodeInit->nop == knopFncDecl)\n                    {\n                        Assert(nameHintLength >= nameHintOffset);\n                        pnodeInit->sxFnc.hint = pNameHint;\n                        pnodeInit->sxFnc.hintLength = nameHintLength;\n                        pnodeInit->sxFnc.hintOffset = nameHintOffset;\n                    }\n\n                    AnalysisAssert(pnodeT);\n                    pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n                    if (!isNonSimpleParameterList)\n                    {\n                        if (buildAST)\n                        {\n                            // This is the first non-simple parameter we've seen. We need to go back\n                            // and set the Symbols of all previous parameters.\n                            MapFormalsWithoutRest(m_currentNodeFunc, [&](ParseNodePtr pnodeArg) { pnodeArg->sxVar.sym->SetIsNonSimpleParameter(true); });\n                        }\n\n                        // There may be previous parameters that need to be checked for duplicates.\n                        isNonSimpleParameterList = true;\n                    }\n\n                    if (buildAST)\n                    {\n                        if (!m_currentNodeFunc->sxFnc.HasDefaultArguments())\n                        {\n                            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(DefaultArgFunction, m_scriptContext);\n                        }\n                        pnodeT->sxVar.pnodeInit = pnodeInit;\n                        pnodeT->ichLim = m_pscan->IchLimTok();\n                    }\n                }\n            }\n\n            if (isNonSimpleParameterList && m_currentScope->GetHasDuplicateFormals())\n            {\n                Error(ERRFormalSame);\n            }\n\n            if (flags & fFncOneArg)\n            {\n                if (m_token.tk != tkRParen)\n                {\n                    Error(ERRSetterMustHaveOneParameter);\n                }\n                break; //enforce only one arg\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n\n        if (seenRestParameter)\n        {\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Rest, m_scriptContext);\n        }\n\n        if (m_token.tk != tkRParen)\n        {\n            Error(ERRnoRparen);\n        }\n\n        if (this->GetCurrentFunctionNode()->sxFnc.CallsEval() || this->GetCurrentFunctionNode()->sxFnc.ChildCallsEval())\n        {\n            if (!m_scriptContext->GetConfig()->IsES6DefaultArgsSplitScopeEnabled())\n            {\n                Error(ERREvalNotSupportedInParamScope);\n            }\n            else\n            {\n                Assert(pnodeFnc->sxFnc.HasNonSimpleParameterList());\n                pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope->SetCannotMergeWithBodyScope();\n            }\n        }\n    }\n    Assert(m_token.tk == tkRParen);\n\n    if (fLambda)\n    {\n        m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n        m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n    }\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::GenerateModuleFunctionWrapper()\n{\n    ParseNodePtr pnodeFnc = ParseFncDecl<buildAST>(fFncModule, nullptr, false, true, true);\n    ParseNodePtr callNode = CreateCallNode(knopCall, pnodeFnc, nullptr);\n\n    return callNode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::GenerateEmptyConstructor(bool extends)\n{\n    ParseNodePtr pnodeFnc;\n\n    // Create the node.\n    pnodeFnc = CreateNode(knopFncDecl);\n    pnodeFnc->sxFnc.ClearFlags();\n    pnodeFnc->sxFnc.SetNested(NULL != m_currentNodeFunc);\n    pnodeFnc->sxFnc.SetStrictMode();\n    pnodeFnc->sxFnc.SetDeclaration(TRUE);\n    pnodeFnc->sxFnc.SetIsMethod(TRUE);\n    pnodeFnc->sxFnc.SetIsClassMember(TRUE);\n    pnodeFnc->sxFnc.SetIsClassConstructor(TRUE);\n    pnodeFnc->sxFnc.SetIsBaseClassConstructor(!extends);\n    pnodeFnc->sxFnc.SetHasNonThisStmt();\n    pnodeFnc->sxFnc.SetIsGeneratedDefault(TRUE);\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->ichMin = m_pscan->IchMinTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n    pnodeFnc->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFnc->sxFnc.astSize = 0;\n    pnodeFnc->sxFnc.lineNumber = m_pscan->LineCur();\n\n    pnodeFnc->sxFnc.functionId          = (*m_nextFunctionId);\n    pnodeFnc->sxFnc.pid                 = nullptr;\n    pnodeFnc->sxFnc.hint                = nullptr;\n    pnodeFnc->sxFnc.hintOffset          = 0;\n    pnodeFnc->sxFnc.hintLength          = 0;\n    pnodeFnc->sxFnc.isNameIdentifierRef = true;\n    pnodeFnc->sxFnc.nestedFuncEscapes   = false;\n    pnodeFnc->sxFnc.pnodeName           = nullptr;\n    pnodeFnc->sxFnc.pnodeScopes         = nullptr;\n    pnodeFnc->sxFnc.pnodeParams         = nullptr;\n    pnodeFnc->sxFnc.pnodeVars           = nullptr;\n    pnodeFnc->sxFnc.pnodeBody           = nullptr;\n    pnodeFnc->sxFnc.nestedCount         = 0;\n    pnodeFnc->sxFnc.pnodeNext           = nullptr;\n    pnodeFnc->sxFnc.pnodeRest           = nullptr;\n    pnodeFnc->sxFnc.deferredStub        = nullptr;\n    pnodeFnc->sxFnc.funcInfo            = nullptr;\n\n    // In order to (re-)defer the default constructor, we need to, for instance, track\n    // deferred class expression the way we track function expression, since we lose the part of the source\n    // that tells us which we have.\n    pnodeFnc->sxFnc.canBeDeferred       = false;\n\n#ifdef DBG\n    pnodeFnc->sxFnc.deferredParseNextFunctionId = *(this->m_nextFunctionId);\n#endif\n\n    AppendFunctionToScopeList(true, pnodeFnc);\n\n    if (m_nextFunctionId)\n    {\n        (*m_nextFunctionId)++;\n    }\n\n    // Update the count of functions nested in the current parent.\n    if (m_pnestedCount)\n    {\n        (*m_pnestedCount)++;\n    }\n\n    if (!buildAST)\n    {\n        return NULL;\n    }\n\n    if (m_pscan->IchMinTok() >= m_pscan->IchMinLine())\n    {\n        // In scenarios involving defer parse IchMinLine() can be incorrect for the first line after defer parse\n        pnodeFnc->sxFnc.columnNumber = m_pscan->IchMinTok() - m_pscan->IchMinLine();\n    }\n    else if (m_currentNodeFunc)\n    {\n        // For the first line after defer parse, compute the column relative to the column number\n        // of the lexically parent function.\n        ULONG offsetFromCurrentFunction = m_pscan->IchMinTok() - m_currentNodeFunc->ichMin;\n        pnodeFnc->sxFnc.columnNumber = m_currentNodeFunc->sxFnc.columnNumber + offsetFromCurrentFunction;\n    }\n    else\n    {\n        // if there is no current function, lets give a default of 0.\n        pnodeFnc->sxFnc.columnNumber = 0;\n    }\n\n    int32 * pAstSizeSave = m_pCurrentAstSize;\n    m_pCurrentAstSize = &(pnodeFnc->sxFnc.astSize);\n\n    // Make this the current function.\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    m_currentNodeFunc = pnodeFnc;\n\n    ParseNodePtr argsId = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n\n    if (extends)\n    {\n        // constructor(...args) { super(...args); }\n        //             ^^^^^^^\n        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n        IdentPtr pidargs = m_phtbl->PidHashNameLen(_u(\"args\"), sizeof(\"args\") - 1);\n        ParseNodePtr pnodeT = CreateVarDeclNode(pidargs, STFormal);\n        pnodeT->sxVar.sym->SetIsNonSimpleParameter(true);\n        pnodeFnc->sxFnc.pnodeRest = pnodeT;\n        PidRefStack *ref = this->PushPidRef(pidargs);\n\n        argsId = CreateNameNode(pidargs, pnodeFnc->ichMin, pnodeFnc->ichLim);\n\n        argsId->sxPid.symRef = ref->GetSymRef();\n        m_ppnodeVar = ppnodeVarSave;\n    }\n\n    ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n    pnodeBlock->sxBlock.pnodeScopes = pnodeInnerBlock;\n    pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n    pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n\n    if (extends)\n    {\n        // constructor(...args) { super(...args); }\n        //                        ^^^^^^^^^^^^^^^\n        Assert(argsId);\n        ParseNodePtr spreadArg = CreateUniNode(knopEllipsis, argsId, pnodeFnc->ichMin, pnodeFnc->ichLim);\n\n        ParseNodePtr superRef = CreateNodeWithScanner<knopSuper>();\n        pnodeFnc->sxFnc.SetHasSuperReference(TRUE);\n\n        ParseNodePtr callNode = CreateCallNode(knopCall, superRef, spreadArg);\n        callNode->sxCall.spreadArgCount = 1;\n        AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, callNode);\n    }\n\n    AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n\n    FinishParseBlock(pnodeInnerBlock);\n    FinishParseBlock(pnodeBlock);\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n\n    return pnodeFnc;\n}\n\ntemplate<bool buildAST>\nvoid Parser::ParseExpressionLambdaBody(ParseNodePtr pnodeLambda)\n{\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    // The lambda body is a single expression, the result of which is the return value.\n    ParseNodePtr pnodeRet = nullptr;\n\n    if (buildAST)\n    {\n        pnodeRet = CreateNodeWithScanner<knopReturn>();\n        pnodeRet->grfpn |= PNodeFlags::fpnSyntheticNode;\n        pnodeLambda->sxFnc.pnodeScopes->sxBlock.pnodeStmt = pnodeRet;\n    }\n\n    IdentToken token;\n    charcount_t lastRParen = 0;\n    ParseNodePtr result = ParseExpr<buildAST>(koplAsg, nullptr, TRUE, FALSE, nullptr, nullptr, nullptr, &token, false, nullptr, &lastRParen);\n\n    this->MarkEscapingRef(result, &token);\n\n    if (buildAST)\n    {\n        pnodeRet->sxReturn.pnodeExpr = result;\n\n        pnodeRet->ichMin = pnodeRet->sxReturn.pnodeExpr->ichMin;\n        pnodeRet->ichLim = pnodeRet->sxReturn.pnodeExpr->ichLim;\n\n        // Pushing a statement node with PushStmt<>() normally does this initialization\n        // but do it here manually since we know there is no outer statement node.\n        pnodeRet->sxStmt.grfnop = 0;\n        pnodeRet->sxStmt.pnodeOuter = nullptr;\n\n        pnodeLambda->ichLim = max(pnodeRet->ichLim, lastRParen);\n        pnodeLambda->sxFnc.cbLim = m_pscan->IecpLimTokPrevious();\n        pnodeLambda->sxFnc.pnodeScopes->ichLim = pnodeRet->ichLim;\n\n        pnodeLambda->sxFnc.pnodeBody = nullptr;\n        AddToNodeList(&pnodeLambda->sxFnc.pnodeBody, &lastNodeRef, pnodeLambda->sxFnc.pnodeScopes);\n\n        // Append an EndCode node.\n        ParseNodePtr end = CreateNodeWithScanner<knopEndCode>(pnodeRet->ichLim);\n        end->ichLim = end->ichMin; // make end code zero width at the immediate end of lambda body\n        AddToNodeList(&pnodeLambda->sxFnc.pnodeBody, &lastNodeRef, end);\n\n        // Lambda's do not have arguments binding\n        pnodeLambda->sxFnc.SetHasReferenceableBuiltInArguments(false);\n    }\n}\n\nvoid Parser::CheckStrictFormalParameters()\n{\n    if (m_token.tk == tkID)\n    {\n        // single parameter arrow function case\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        CheckStrictModeEvalArgumentsUsage(pid);\n        return;\n    }\n\n    Assert(m_token.tk == tkLParen);\n    m_pscan->ScanForcingPid();\n\n    if (m_token.tk != tkRParen)\n    {\n        SList<IdentPtr> formals(&m_nodeAllocator);\n        for (;;)\n        {\n            if (m_token.tk != tkID)\n            {\n                IdentifierExpectedError(m_token);\n            }\n\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n            CheckStrictModeEvalArgumentsUsage(pid);\n            if (formals.Has(pid))\n            {\n                Error(ERRES5ArgSame, m_pscan->IchMinTok(), m_pscan->IchLimTok());\n            }\n            else\n            {\n                formals.Prepend(pid);\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkAsg && m_scriptContext->GetConfig()->IsES6DefaultArgsEnabled())\n            {\n                m_pscan->Scan();\n                // We can avoid building the AST since we are just checking the default expression.\n                ParseNodePtr pnodeInit = ParseExpr<false>(koplCma);\n                Assert(pnodeInit == nullptr);\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n            m_pscan->ScanForcingPid();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n    }\n    Assert(m_token.tk == tkRParen);\n}\n\nvoid Parser::FinishFncNode(ParseNodePtr pnodeFnc)\n{\n    AnalysisAssert(pnodeFnc);\n\n    // Finish the AST for a function that was deferred earlier, but which we decided\n    // to finish after the fact.\n    // We assume that the name(s) and arg(s) have already got parse nodes, so\n    // we just have to do the function body.\n\n    // Save the current next function Id, and resume from the old one.\n    Js::LocalFunctionId * nextFunctionIdSave = m_nextFunctionId;\n    Js::LocalFunctionId tempNextFunctionId = pnodeFnc->sxFnc.functionId + 1;\n    this->m_nextFunctionId = &tempNextFunctionId;\n\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    uint *pnestedCountSave = m_pnestedCount;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    m_currentNodeFunc = pnodeFnc;\n    m_pCurrentAstSize = & (pnodeFnc->sxFnc.astSize);\n\n    pnodeFnc->sxFnc.nestedCount = 0;\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n\n    // Cue up the parser to the start of the function body.\n    if (pnodeFnc->sxFnc.pnodeName)\n    {\n        // Skip the name(s).\n        m_pscan->SetCurrentCharacter(pnodeFnc->sxFnc.pnodeName->ichLim, pnodeFnc->sxFnc.lineNumber);\n    }\n    else\n    {\n        m_pscan->SetCurrentCharacter(pnodeFnc->ichMin, pnodeFnc->sxFnc.lineNumber);\n        if (pnodeFnc->sxFnc.IsAccessor())\n        {\n            // Getter/setter. The node text starts with the name, so eat that.\n            m_pscan->ScanNoKeywords();\n        }\n        else\n        {\n            // Anonymous function. Skip any leading \"(\"'s and \"function\".\n            for (;;)\n            {\n                m_pscan->Scan();\n                if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async)\n                {\n                    Assert(pnodeFnc->sxFnc.IsAsync());\n                    continue;\n                }\n                if (m_token.tk == tkFUNCTION)\n                {\n                    break;\n                }\n                Assert(m_token.tk == tkLParen || m_token.tk == tkStar);\n            }\n        }\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsAsync());\n\n    // Skip the arg list.\n    m_pscan->ScanNoKeywords();\n    if (m_token.tk == tkStar)\n    {\n        Assert(pnodeFnc->sxFnc.IsGenerator());\n        m_pscan->ScanNoKeywords();\n    }\n    Assert(m_token.tk == tkLParen);\n    m_pscan->ScanNoKeywords();\n\n    if (m_token.tk != tkRParen)\n    {\n        for (;;)\n        {\n            if (m_token.tk == tkEllipsis)\n            {\n                m_pscan->ScanNoKeywords();\n            }\n\n            if (m_token.tk == tkID)\n            {\n                m_pscan->ScanNoKeywords();\n\n                if (m_token.tk == tkAsg)\n                {\n                    // Eat the default expression\n                    m_pscan->Scan();\n                    ParseExpr<false>(koplCma);\n                }\n            }\n            else if (IsPossiblePatternStart())\n            {\n                ParseDestructuredLiteralWithScopeSave(tkLET, false/*isDecl*/, false /*topLevel*/);\n            }\n            else\n            {\n                AssertMsg(false, \"Unexpected identifier prefix while fast-scanning formals\");\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                break;\n            }\n            m_pscan->ScanNoKeywords();\n\n            if (m_token.tk == tkRParen && m_scriptContext->GetConfig()->IsES7TrailingCommaEnabled())\n            {\n                break;\n            }\n        }\n    }\n\n    if (m_token.tk == tkRParen) // This might be false due to a lambda => token.\n    {\n        m_pscan->Scan();\n    }\n\n    // Finish the function body.\n    {\n        // Note that in IE8- modes, surrounding parentheses are considered part of function body. e.g. \"( function x(){} )\".\n        // We lose that context here since we start from middle of function body. So save and restore source range info.\n        ParseNodePtr* lastNodeRef = NULL;\n        const charcount_t ichLim = pnodeFnc->ichLim;\n        const size_t cbLim = pnodeFnc->sxFnc.cbLim;\n        this->FinishFncDecl(pnodeFnc, NULL, lastNodeRef);\n\n#if DBG\n        // The pnode extent may not match the original extent.\n        // We expect this to happen only when there are trailing \")\"'s.\n        // Consume them and make sure that's all we've got.\n        if (pnodeFnc->ichLim != ichLim)\n        {\n            Assert(pnodeFnc->ichLim < ichLim);\n            m_pscan->SetCurrentCharacter(pnodeFnc->ichLim);\n            while (m_pscan->IchLimTok() != ichLim)\n            {\n                m_pscan->ScanNoKeywords();\n                Assert(m_token.tk == tkRParen);\n            }\n        }\n#endif\n        pnodeFnc->ichLim = ichLim;\n        pnodeFnc->sxFnc.cbLim = cbLim;\n    }\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n    m_pnestedCount = pnestedCountSave;\n    Assert(m_pnestedCount);\n\n    Assert(tempNextFunctionId == pnodeFnc->sxFnc.deferredParseNextFunctionId);\n    this->m_nextFunctionId = nextFunctionIdSave;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n}\n\nvoid Parser::FinishFncDecl(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ParseNodePtr *lastNodeRef, bool skipCurlyBraces)\n{\n    LPCOLESTR name = NULL;\n    JS_ETW(int32 startAstSize = *m_pCurrentAstSize);\n    if (IS_JS_ETW(EventEnabledJSCRIPT_PARSE_METHOD_START()) || PHASE_TRACE1(Js::DeferParsePhase))\n    {\n        name = GetFunctionName(pnodeFnc, pNameHint);\n        m_functionBody = NULL;  // for nested functions we do not want to get the name of the top deferred function return name;\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_START(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeFnc->sxFnc.functionId, 0, m_parseType, name));\n        OUTPUT_TRACE(Js::DeferParsePhase, _u(\"Parsing function (%s) : %s (%d)\\n\"), GetParseType(), name, pnodeFnc->sxFnc.functionId);\n    }\n\n    JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_FUNC(GetScriptContext(), pnodeFnc->sxFnc.functionId, /*Undefer*/FALSE));\n\n\n    // Do the work of creating an AST for a function body.\n    // This is common to the un-deferred case and the case in which we un-defer late in the game.\n\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    if (!skipCurlyBraces)\n    {\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n    }\n\n    ParseStmtList<true>(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, SM_OnFunctionCode, true /* isSourceElementList */);\n    // Append an EndCode node.\n    AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n\n    if (!skipCurlyBraces)\n    {\n        ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n    }\n\n    pnodeFnc->ichLim = m_pscan->IchLimTok();\n    pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n#ifdef ENABLE_JS_ETW\n    int32 astSize = *m_pCurrentAstSize - startAstSize;\n    EventWriteJSCRIPT_PARSE_METHOD_STOP(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeFnc->sxFnc.functionId, astSize, m_parseType, name);\n#endif\n}\n\nvoid Parser::AddArgumentsNodeToVars(ParseNodePtr pnodeFnc)\n{\n    if((pnodeFnc->grfpn & PNodeFlags::fpnArguments_overriddenByDecl) || pnodeFnc->sxFnc.IsLambda())\n    {\n        // In any of the following cases, there is no way to reference the built-in 'arguments' variable (in the order of checks\n        // above):\n        //     - A function parameter is named 'arguments'\n        //     - There is a nested function declaration (or named function expression in compat modes) named 'arguments'\n        //     - In compat modes, the function is named arguments, does not have a var declaration named 'arguments', and does\n        //       not call 'eval'\n        pnodeFnc->sxFnc.SetHasReferenceableBuiltInArguments(false);\n    }\n    else\n    {\n        ParseNodePtr argNode = nullptr;\n        if(m_ppnodeVar == &pnodeFnc->sxFnc.pnodeVars)\n        {\n            // There were no var declarations in the function\n            argNode = CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, pnodeFnc);\n        }\n        else\n        {\n            // There were var declarations in the function, so insert an 'arguments' local at the beginning of the var list.\n            // This is done because the built-in 'arguments' variable overrides an 'arguments' var declaration until the\n            // 'arguments' variable is assigned. By putting our built-in var declaration at the beginning, an 'arguments'\n            // identifier will resolve to this symbol, which has the fpnArguments flag set, and will be the built-in arguments\n            // object until it is replaced with something else.\n            ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n            argNode = CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, pnodeFnc);\n            m_ppnodeVar = ppnodeVarSave;\n        }\n\n        Assert(argNode);\n        argNode->grfpn |= PNodeFlags::fpnArguments;\n\n        // When a function definition with the name arguments occurs in the body the declaration of the arguments symbol will\n        // be set to that function declaration. We should change it to arguments declaration from the param scope as it may be\n        // used in the param scope and we have to load the arguments.\n        argNode->sxVar.sym->SetDecl(argNode);\n\n        pnodeFnc->sxFnc.SetHasReferenceableBuiltInArguments(true);\n    }\n}\n\nLPCOLESTR Parser::GetFunctionName(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint)\n{\n    LPCOLESTR name = nullptr;\n    if(pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n    {\n        name = pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz();\n    }\n    if(name == nullptr && pNameHint != nullptr)\n    {\n        name = pNameHint;\n    }\n    if(name == nullptr && m_functionBody != nullptr)\n    {\n        name = m_functionBody->GetExternalDisplayName();\n    }\n    else if(name == nullptr)\n    {\n        name = Js::Constants::AnonymousFunction;\n    }\n    return name;\n}\n\nIdentPtr Parser::ParseClassPropertyName(IdentPtr * pidHint)\n{\n    if (m_token.tk == tkID || m_token.tk == tkStrCon || m_token.IsReservedWord())\n    {\n        IdentPtr pid;\n        if (m_token.tk == tkStrCon)\n        {\n            if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n            {\n                Error(ERRES5NoOctal);\n            }\n\n            pid = m_token.GetStr();\n        }\n        else\n        {\n            pid = m_token.GetIdentifier(m_phtbl);\n        }\n        *pidHint = pid;\n        return pid;\n    }\n    else if (m_token.tk == tkIntCon)\n    {\n        if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        return m_pscan->PidFromLong(m_token.GetLong());\n    }\n    else if (m_token.tk == tkFltCon)\n    {\n        if (m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        return m_pscan->PidFromDbl(m_token.GetDouble());\n    }\n\n    Error(ERRnoMemberIdent);\n}\n\nLPCOLESTR Parser::ConstructFinalHintNode(IdentPtr pClassName, IdentPtr pMemberName, IdentPtr pGetSet, bool isStatic, uint32* nameLength, uint32* pShortNameOffset, bool isComputedName, LPCOLESTR pMemberNameHint)\n{\n    if ((pMemberName == nullptr && !isComputedName) ||\n        (pMemberNameHint == nullptr && isComputedName) ||\n        !CONFIG_FLAG(UseFullName))\n    {\n        return nullptr;\n    }\n\n    LPCOLESTR pFinalName = isComputedName? pMemberNameHint : pMemberName->Psz();\n    uint32 fullNameHintLength = 0;\n    uint32 shortNameOffset = 0;\n    if (!isStatic)\n    {\n        // Add prototype.\n        pFinalName = AppendNameHints(wellKnownPropertyPids.prototype, pFinalName, &fullNameHintLength, &shortNameOffset);\n    }\n\n    if (pClassName)\n    {\n        uint32 classNameOffset = 0;\n        pFinalName = AppendNameHints(pClassName, pFinalName, &fullNameHintLength, &classNameOffset);\n        shortNameOffset += classNameOffset;\n    }\n\n    if (pGetSet)\n    {\n        if (m_scriptContext->GetConfig()->IsES6FunctionNameEnabled())\n        {\n            // displays as get/set prototype.funcname\n            uint32 getSetOffset = 0;\n            pFinalName = AppendNameHints(pGetSet, pFinalName, &fullNameHintLength, &getSetOffset, true);\n            shortNameOffset += getSetOffset;\n        }\n        else\n        {\n            pFinalName = AppendNameHints(pFinalName, pGetSet, &fullNameHintLength, &shortNameOffset);\n        }\n\n    }\n    if (fullNameHintLength > *nameLength)\n    {\n        *nameLength = fullNameHintLength;\n    }\n\n    if (shortNameOffset > *pShortNameOffset)\n    {\n        *pShortNameOffset = shortNameOffset;\n    }\n\n    return pFinalName;\n}\n\nclass AutoParsingSuperRestrictionStateRestorer\n{\npublic:\n    AutoParsingSuperRestrictionStateRestorer(Parser* parser) : m_parser(parser)\n    {\n        AssertMsg(this->m_parser != nullptr, \"This just should not happen\");\n        this->m_originalParsingSuperRestrictionState = this->m_parser->m_parsingSuperRestrictionState;\n    }\n    ~AutoParsingSuperRestrictionStateRestorer()\n    {\n        AssertMsg(this->m_parser != nullptr, \"This just should not happen\");\n        this->m_parser->m_parsingSuperRestrictionState = m_originalParsingSuperRestrictionState;\n    }\nprivate:\n    Parser* m_parser;\n    int m_originalParsingSuperRestrictionState;\n};\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseClassDecl(BOOL isDeclaration, LPCOLESTR pNameHint, uint32 *pHintLength, uint32 *pShortNameOffset)\n{\n    bool hasConstructor = false;\n    bool hasExtends = false;\n    IdentPtr name = nullptr;\n    ParseNodePtr pnodeName = nullptr;\n    ParseNodePtr pnodeConstructor = nullptr;\n    ParseNodePtr pnodeExtends = nullptr;\n    ParseNodePtr pnodeMembers = nullptr;\n    ParseNodePtr *lastMemberNodeRef = nullptr;\n    ParseNodePtr pnodeStaticMembers = nullptr;\n    ParseNodePtr *lastStaticMemberNodeRef = nullptr;\n    uint32 nameHintLength = pHintLength ? *pHintLength : 0;\n    uint32 nameHintOffset = pShortNameOffset ? *pShortNameOffset : 0;\n\n    ArenaAllocator tempAllocator(_u(\"ClassMemberNames\"), m_nodeAllocator.GetPageAllocator(), Parser::OutOfMemory);\n\n    ParseNodePtr pnodeClass = nullptr;\n    if (buildAST)\n    {\n        pnodeClass = CreateNode(knopClassDecl);\n\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Class, m_scriptContext);\n    }\n\n    m_pscan->Scan();\n    if (m_token.tk == tkID)\n    {\n        name = m_token.GetIdentifier(m_phtbl);\n        m_pscan->Scan();\n    }\n    else if (isDeclaration)\n    {\n        IdentifierExpectedError(m_token);\n    }\n\n    if (isDeclaration && name == wellKnownPropertyPids.arguments && GetCurrentBlockInfo()->pnodeBlock->sxBlock.blockType == Function)\n    {\n        GetCurrentFunctionNode()->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n    }\n\n    BOOL strictSave = m_fUseStrictMode;\n    m_fUseStrictMode = TRUE;\n\n    ParseNodePtr pnodeDeclName = nullptr;\n    if (isDeclaration)\n    {\n        pnodeDeclName = CreateBlockScopedDeclNode(name, knopLetDecl);\n    }\n\n    ParseNodePtr *ppnodeScopeSave = nullptr;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n    ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n    if (buildAST)\n    {\n        PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        pnodeClass->sxClass.pnodeBlock = pnodeBlock;\n    }\n\n    if (name)\n    {\n        pnodeName = CreateBlockScopedDeclNode(name, knopConstDecl);\n    }\n\n    if (m_token.tk == tkEXTENDS)\n    {\n        m_pscan->Scan();\n        pnodeExtends = ParseExpr<buildAST>();\n        hasExtends = true;\n    }\n\n    if (m_token.tk != tkLCurly)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    OUTPUT_TRACE_DEBUGONLY(Js::ES6VerboseFlag, _u(\"Parsing class (%s) : %s\\n\"), GetParseType(), name ? name->Psz() : _u(\"anonymous class\"));\n\n    RestorePoint beginClass;\n    m_pscan->Capture(&beginClass);\n\n    m_pscan->ScanForcingPid();\n\n    IdentPtr pClassNamePid = pnodeName ? pnodeName->sxVar.pid : nullptr;\n\n    for (;;)\n    {\n        if (m_token.tk == tkSColon)\n        {\n            m_pscan->ScanForcingPid();\n            continue;\n        }\n        if (m_token.tk == tkRCurly)\n        {\n            break;\n        }\n\n        bool isStatic = m_token.tk == tkSTATIC;\n        if (isStatic)\n        {\n            m_pscan->ScanForcingPid();\n        }\n\n        ushort fncDeclFlags = fFncNoName | fFncMethod | fFncClassMember;\n        charcount_t ichMin = 0;\n        size_t iecpMin = 0;\n        ParseNodePtr pnodeMemberName = nullptr;\n        IdentPtr pidHint = nullptr;\n        IdentPtr memberPid = nullptr;\n        LPCOLESTR pMemberNameHint = nullptr;\n        uint32     memberNameHintLength = 0;\n        uint32     memberNameOffset = 0;\n        bool isComputedName = false;\n        bool isAsyncMethod = false;\n\n        if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->Scan();\n            if (m_token.tk == tkLParen || m_pscan->FHadNewLine())\n            {\n                m_pscan->SeekTo(parsedAsync);\n            }\n            else\n            {\n                isAsyncMethod = true;\n            }\n        }\n\n        bool isGenerator = m_scriptContext->GetConfig()->IsES6GeneratorsEnabled() &&\n                           m_token.tk == tkStar;\n        if (isGenerator)\n        {\n            fncDeclFlags |= fFncGenerator;\n            m_pscan->ScanForcingPid();\n        }\n\n\n        if (m_token.tk == tkLBrack && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n        {\n            // Computed member name: [expr] () { }\n            LPCOLESTR emptyHint = nullptr;\n            ParseComputedName<buildAST>(&pnodeMemberName, &emptyHint, &pMemberNameHint, &memberNameHintLength, &memberNameOffset);\n            isComputedName = true;\n        }\n        else // not computed name\n        {\n            memberPid = this->ParseClassPropertyName(&pidHint);\n            if (pidHint)\n            {\n                pMemberNameHint = pidHint->Psz();\n                memberNameHintLength = pidHint->Cch();\n            }\n        }\n\n        if (buildAST && memberPid)\n        {\n            pnodeMemberName = CreateStrNodeWithScanner(memberPid);\n        }\n\n        if (!isStatic && memberPid == wellKnownPropertyPids.constructor)\n        {\n            if (hasConstructor || isAsyncMethod)\n            {\n                Error(ERRsyntax);\n            }\n            hasConstructor = true;\n            LPCOLESTR pConstructorName = nullptr;\n            uint32  constructorNameLength = 0;\n            uint32  constructorShortNameHintOffset = 0;\n            if (pnodeName && pnodeName->sxVar.pid)\n            {\n                pConstructorName = pnodeName->sxVar.pid->Psz();\n                constructorNameLength = pnodeName->sxVar.pid->Cch();\n            }\n            else\n            {\n                pConstructorName = pNameHint;\n                constructorNameLength = nameHintLength;\n                constructorShortNameHintOffset = nameHintOffset;\n            }\n\n            {\n                AutoParsingSuperRestrictionStateRestorer restorer(this);\n                this->m_parsingSuperRestrictionState = hasExtends ? ParsingSuperRestrictionState_SuperCallAndPropertyAllowed : ParsingSuperRestrictionState_SuperPropertyAllowed;\n                pnodeConstructor = ParseFncDecl<buildAST>(fncDeclFlags, pConstructorName, /* needsPIDOnRCurlyScan */ true, /* resetParsingSuperRestrictionState = */false);\n            }\n\n            if (pnodeConstructor->sxFnc.IsGenerator())\n            {\n                Error(ERRConstructorCannotBeGenerator);\n            }\n\n            Assert(constructorNameLength >= constructorShortNameHintOffset);\n            // The constructor function will get the same name as class.\n            pnodeConstructor->sxFnc.hint = pConstructorName;\n            pnodeConstructor->sxFnc.hintLength = constructorNameLength;\n            pnodeConstructor->sxFnc.hintOffset = constructorShortNameHintOffset;\n            pnodeConstructor->sxFnc.pid = pnodeName && pnodeName->sxVar.pid ? pnodeName->sxVar.pid : wellKnownPropertyPids.constructor;\n            pnodeConstructor->sxFnc.SetIsClassConstructor(TRUE);\n            pnodeConstructor->sxFnc.SetHasNonThisStmt();\n            pnodeConstructor->sxFnc.SetIsBaseClassConstructor(pnodeExtends == nullptr);\n        }\n        else\n        {\n            ParseNodePtr pnodeMember = nullptr;\n\n            bool isMemberNamedGetOrSet = false;\n            RestorePoint beginMethodName;\n            m_pscan->Capture(&beginMethodName);\n            if (memberPid == wellKnownPropertyPids.get || memberPid == wellKnownPropertyPids.set)\n            {\n                m_pscan->ScanForcingPid();\n            }\n            if (m_token.tk == tkLParen)\n            {\n                m_pscan->SeekTo(beginMethodName);\n                isMemberNamedGetOrSet = true;\n            }\n\n            if ((memberPid == wellKnownPropertyPids.get || memberPid == wellKnownPropertyPids.set) && !isMemberNamedGetOrSet)\n            {\n                bool isGetter = (memberPid == wellKnownPropertyPids.get);\n\n                if (m_token.tk == tkLBrack && m_scriptContext->GetConfig()->IsES6ObjectLiteralsEnabled())\n                {\n                    // Computed get/set member name: get|set [expr] () { }\n                    LPCOLESTR emptyHint = nullptr;\n                    ParseComputedName<buildAST>(&pnodeMemberName, &emptyHint, &pMemberNameHint, &memberNameHintLength, &memberNameOffset);\n                    isComputedName = true;\n                }\n                else // not computed name\n                {\n                    memberPid = this->ParseClassPropertyName(&pidHint);\n                }\n\n                if ((isStatic ? (memberPid == wellKnownPropertyPids.prototype) : (memberPid == wellKnownPropertyPids.constructor)) || isAsyncMethod)\n                {\n                    Error(ERRsyntax);\n                }\n                if (buildAST && memberPid && !isComputedName)\n                {\n                    pnodeMemberName = CreateStrNodeWithScanner(memberPid);\n                }\n\n                ParseNodePtr pnodeFnc = nullptr;\n                {\n                    AutoParsingSuperRestrictionStateRestorer restorer(this);\n                    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n                    pnodeFnc = ParseFncDecl<buildAST>(fncDeclFlags | (isGetter ? fFncNoArg : fFncOneArg),\n                        pidHint ? pidHint->Psz() : nullptr, /* needsPIDOnRCurlyScan */ true,\n                        /* resetParsingSuperRestrictionState */false);\n                }\n\n                pnodeFnc->sxFnc.SetIsStaticMember(isStatic);\n\n                if (buildAST)\n                {\n                    pnodeFnc->sxFnc.SetIsAccessor();\n                    pnodeMember = CreateBinNode(isGetter ? knopGetMember : knopSetMember, pnodeMemberName, pnodeFnc);\n                    pMemberNameHint = ConstructFinalHintNode(pClassNamePid, pidHint,\n                        isGetter ? wellKnownPropertyPids.get : wellKnownPropertyPids.set, isStatic,\n                        &memberNameHintLength, &memberNameOffset, isComputedName, pMemberNameHint);\n                }\n            }\n            else\n            {\n                if (isStatic && (memberPid == wellKnownPropertyPids.prototype))\n                {\n                    Error(ERRsyntax);\n                }\n\n                ParseNodePtr pnodeFnc = nullptr;\n                {\n                    AutoParsingSuperRestrictionStateRestorer restorer(this);\n                    this->m_parsingSuperRestrictionState = ParsingSuperRestrictionState_SuperPropertyAllowed;\n\n                    if (isAsyncMethod)\n                    {\n                        fncDeclFlags |= fFncAsync;\n                    }\n                    pnodeFnc = ParseFncDecl<buildAST>(fncDeclFlags, pidHint ? pidHint->Psz() : nullptr, /* needsPIDOnRCurlyScan */ true, /* resetParsingSuperRestrictionState */false);\n                    if (isAsyncMethod)\n                    {\n                        pnodeFnc->sxFnc.cbMin = iecpMin;\n                        pnodeFnc->ichMin = ichMin;\n                    }\n                }\n                pnodeFnc->sxFnc.SetIsStaticMember(isStatic);\n\n                if (buildAST)\n                {\n                    pnodeMember = CreateBinNode(knopMember, pnodeMemberName, pnodeFnc);\n                    pMemberNameHint = ConstructFinalHintNode(pClassNamePid, pidHint, nullptr /*pgetset*/, isStatic, &memberNameHintLength, &memberNameOffset, isComputedName, pMemberNameHint);\n                }\n            }\n\n            if (buildAST)\n            {\n                Assert(memberNameHintLength >= memberNameOffset);\n                pnodeMember->sxBin.pnode2->sxFnc.hint = pMemberNameHint; // Fully qualified name\n                pnodeMember->sxBin.pnode2->sxFnc.hintLength = memberNameHintLength;\n                pnodeMember->sxBin.pnode2->sxFnc.hintOffset = memberNameOffset;\n                pnodeMember->sxBin.pnode2->sxFnc.pid = memberPid; // Short name\n\n                AddToNodeList(isStatic ? &pnodeStaticMembers : &pnodeMembers, isStatic ? &lastStaticMemberNodeRef : &lastMemberNodeRef, pnodeMember);\n            }\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeClass->ichLim = m_pscan->IchLimTok();\n    }\n\n    if (!hasConstructor)\n    {\n        OUTPUT_TRACE_DEBUGONLY(Js::ES6VerboseFlag, _u(\"Generating constructor (%s) : %s\\n\"), GetParseType(), name ? name->Psz() : _u(\"anonymous class\"));\n\n        RestorePoint endClass;\n        m_pscan->Capture(&endClass);\n        m_pscan->SeekTo(beginClass);\n\n        pnodeConstructor = GenerateEmptyConstructor<buildAST>(pnodeExtends != nullptr);\n        if (buildAST)\n        {\n            if (pClassNamePid)\n            {\n                pnodeConstructor->sxFnc.hint = pClassNamePid->Psz();\n                pnodeConstructor->sxFnc.hintLength = pClassNamePid->Cch();\n                pnodeConstructor->sxFnc.hintOffset = 0;\n            }\n            else\n            {\n                Assert(nameHintLength >= nameHintOffset);\n                pnodeConstructor->sxFnc.hint = pNameHint;\n                pnodeConstructor->sxFnc.hintLength = nameHintLength;\n                pnodeConstructor->sxFnc.hintOffset = nameHintOffset;\n            }\n            pnodeConstructor->sxFnc.pid = pClassNamePid;\n        }\n\n        m_pscan->SeekTo(endClass);\n    }\n\n    if (buildAST)\n    {\n        pnodeConstructor->sxFnc.cbMin = pnodeClass->ichMin;\n        pnodeConstructor->sxFnc.cbLim = pnodeClass->ichLim;\n        pnodeConstructor->ichMin = pnodeClass->ichMin;\n        pnodeConstructor->ichLim = pnodeClass->ichLim;\n\n        PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n\n        pnodeClass->sxClass.pnodeDeclName = pnodeDeclName;\n        pnodeClass->sxClass.pnodeName = pnodeName;\n        pnodeClass->sxClass.pnodeConstructor = pnodeConstructor;\n        pnodeClass->sxClass.pnodeExtends = pnodeExtends;\n        pnodeClass->sxClass.pnodeMembers = pnodeMembers;\n        pnodeClass->sxClass.pnodeStaticMembers = pnodeStaticMembers;\n        pnodeClass->sxClass.isDefaultModuleExport = false;\n    }\n    FinishParseBlock(pnodeBlock);\n\n    m_fUseStrictMode = strictSave;\n\n    m_pscan->Scan();\n\n    return pnodeClass;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseStringTemplateDecl(ParseNodePtr pnodeTagFnc)\n{\n    ParseNodePtr pnodeStringLiterals = nullptr;\n    ParseNodePtr* lastStringLiteralNodeRef = nullptr;\n    ParseNodePtr pnodeRawStringLiterals = nullptr;\n    ParseNodePtr* lastRawStringLiteralNodeRef = nullptr;\n    ParseNodePtr pnodeSubstitutionExpressions = nullptr;\n    ParseNodePtr* lastSubstitutionExpressionNodeRef = nullptr;\n    ParseNodePtr pnodeTagFncArgs = nullptr;\n    ParseNodePtr* lastTagFncArgNodeRef = nullptr;\n    ParseNodePtr stringLiteral = nullptr;\n    ParseNodePtr stringLiteralRaw = nullptr;\n    ParseNodePtr pnodeStringTemplate = nullptr;\n    bool templateClosed = false;\n    const bool isTagged = pnodeTagFnc != nullptr;\n    uint16 stringConstantCount = 0;\n    charcount_t ichMin = 0;\n\n    Assert(m_token.tk == tkStrTmplBasic || m_token.tk == tkStrTmplBegin);\n\n    if (buildAST)\n    {\n        pnodeStringTemplate = CreateNode(knopStrTemplate);\n        pnodeStringTemplate->sxStrTemplate.countStringLiterals = 0;\n        pnodeStringTemplate->sxStrTemplate.isTaggedTemplate = isTagged ? TRUE : FALSE;\n\n        // If this is a tagged string template, we need to start building the arg list for the call\n        if (isTagged)\n        {\n            ichMin = pnodeTagFnc->ichMin;\n            AddToNodeListEscapedUse(&pnodeTagFncArgs, &lastTagFncArgNodeRef, pnodeStringTemplate);\n        }\n\n    }\n    CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StringTemplates, m_scriptContext);\n\n    OUTPUT_TRACE_DEBUGONLY(\n        Js::StringTemplateParsePhase,\n        _u(\"Starting to parse a string template (%s)...\\n\\tis tagged = %s\\n\"),\n        GetParseType(),\n        isTagged ? _u(\"true\") : _u(\"false (Raw and cooked strings will not differ!)\"));\n\n    // String template grammar\n    // `...`   Simple string template\n    // `...${  String template beginning\n    // }...${  String template middle\n    // }...`   String template end\n    while (!templateClosed)\n    {\n        // First, extract the string constant part - we always have one\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        // We are not able to pass more than a ushort worth of arguments to the tag\n        // so use that as a logical limit on the number of string constant pieces.\n        if (stringConstantCount >= USHRT_MAX)\n        {\n            Error(ERRnoMemory);\n        }\n\n        // Keep track of the string literal count (must be the same for raw strings)\n        // We use this in code gen so we don't need to count the string literals list\n        stringConstantCount++;\n\n        // If we are not creating parse nodes, there is no need to create strings\n        if (buildAST)\n        {\n            stringLiteral = CreateStrNodeWithScanner(m_token.GetStr());\n\n            AddToNodeList(&pnodeStringLiterals, &lastStringLiteralNodeRef, stringLiteral);\n\n            // We only need to collect a raw string when we are going to pass the string template to a tag\n            if (isTagged)\n            {\n                // Make the scanner create a PID for the raw string constant for the preceding scan\n                IdentPtr pid = m_pscan->GetSecondaryBufferAsPid();\n\n                stringLiteralRaw = CreateStrNodeWithScanner(pid);\n\n                // Should have gotten a raw string literal above\n                AddToNodeList(&pnodeRawStringLiterals, &lastRawStringLiteralNodeRef, stringLiteralRaw);\n            }\n            else\n            {\n#if DBG\n                // Assign the raw string for debug tracing below\n                stringLiteralRaw = stringLiteral;\n#endif\n            }\n\n            OUTPUT_TRACE_DEBUGONLY(\n                Js::StringTemplateParsePhase,\n                _u(\"Parsed string constant: \\n\\tcooked = \\\"%s\\\" \\n\\traw = \\\"%s\\\" \\n\\tdiffer = %d\\n\"),\n                stringLiteral->sxPid.pid->Psz(),\n                stringLiteralRaw->sxPid.pid->Psz(),\n                stringLiteral->sxPid.pid->Psz() == stringLiteralRaw->sxPid.pid->Psz() ? 0 : 1);\n        }\n\n        switch (m_token.tk)\n        {\n        case tkStrTmplEnd:\n        case tkStrTmplBasic:\n            // We do not need to parse an expression for either the end or basic string template tokens\n            templateClosed = true;\n            break;\n        case tkStrTmplBegin:\n        case tkStrTmplMid:\n            {\n            // In the middle or begin string template token case, we need to parse an expression next\n            m_pscan->Scan();\n\n            // Parse the contents of the curly braces as an expression\n            ParseNodePtr expression = ParseExpr<buildAST>(0);\n\n            // After parsing expression, scan should leave us with an RCurly token.\n            // Use the NoScan version so we do not automatically perform a scan - we need to\n            // set the scan state before next scan but we don't want to set that state if\n            // the token is not as expected since we'll error in that case.\n            ChkCurTokNoScan(tkRCurly, ERRnoRcurly);\n\n            // Notify the scanner that it should scan for a middle or end string template token\n            m_pscan->SetScanState(Scanner_t::ScanState::ScanStateStringTemplateMiddleOrEnd);\n            m_pscan->Scan();\n\n            if (buildAST)\n            {\n                // If we are going to call the tag function, add this expression into the list of args\n                if (isTagged)\n                {\n                    AddToNodeListEscapedUse(&pnodeTagFncArgs, &lastTagFncArgNodeRef, expression);\n                }\n                else\n                {\n                    // Otherwise add it to the substitution expression list\n                    // TODO: Store the arguments and substitution expressions in a single list?\n                    AddToNodeList(&pnodeSubstitutionExpressions, &lastSubstitutionExpressionNodeRef, expression);\n                }\n            }\n\n            if (!(m_token.tk == tkStrTmplMid || m_token.tk == tkStrTmplEnd))\n            {\n                // Scan with ScanState ScanStateStringTemplateMiddleOrEnd should only return\n                // tkStrTmpMid/End unless it is EOF or tkScanError\n                Assert(m_token.tk == tkEOF || m_token.tk == tkScanError);\n                Error(ERRsyntax);\n            }\n\n            OUTPUT_TRACE_DEBUGONLY(Js::StringTemplateParsePhase, _u(\"Parsed expression\\n\"));\n            }\n            break;\n        default:\n            Assert(false);\n            break;\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeStringTemplate->sxStrTemplate.pnodeStringLiterals = pnodeStringLiterals;\n        pnodeStringTemplate->sxStrTemplate.pnodeStringRawLiterals = pnodeRawStringLiterals;\n        pnodeStringTemplate->sxStrTemplate.pnodeSubstitutionExpressions = pnodeSubstitutionExpressions;\n        pnodeStringTemplate->sxStrTemplate.countStringLiterals = stringConstantCount;\n\n        // We should still have the last string literal.\n        // Use the char offset of the end of that constant as the end of the string template.\n        pnodeStringTemplate->ichLim = stringLiteral->ichLim;\n\n        // If this is a tagged template, we now have the argument list and can construct a call node\n        if (isTagged)\n        {\n            // Return the call node here and let the byte code generator Emit the string template automagically\n            pnodeStringTemplate = CreateCallNode(knopCall, pnodeTagFnc, pnodeTagFncArgs, ichMin, pnodeStringTemplate->ichLim);\n\n            // We need to set the arg count explicitly\n            pnodeStringTemplate->sxCall.argCount = stringConstantCount;\n        }\n    }\n\n    m_pscan->Scan();\n\n    return pnodeStringTemplate;\n}\n\nParseNodePtr Parser::CreateAsyncSpawnGenerator()\n{\n    ParseNodePtr pnodeFncGenerator = nullptr;\n\n    pnodeFncGenerator = CreateDummyFuncNode(false);\n    pnodeFncGenerator->sxFnc.functionId = (*m_nextFunctionId)++;\n\n    pnodeFncGenerator->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeFncGenerator->sxFnc.cbLim = m_pscan->IecpLimTok();\n    pnodeFncGenerator->sxFnc.lineNumber = m_pscan->LineCur();\n    pnodeFncGenerator->sxFnc.columnNumber = CalculateFunctionColumnNumber();\n    pnodeFncGenerator->sxFnc.SetNested(m_currentNodeFunc != nullptr);\n    pnodeFncGenerator->sxFnc.SetStrictMode(IsStrictMode());\n\n    pnodeFncGenerator->sxFnc.SetIsGenerator();\n    pnodeFncGenerator->sxFnc.SetIsLambda();\n    pnodeFncGenerator->sxFnc.scope = nullptr;\n\n    AppendFunctionToScopeList(false, pnodeFncGenerator);\n\n    return pnodeFncGenerator;\n}\n\nLPCOLESTR Parser::FormatPropertyString(LPCOLESTR propertyString, ParseNodePtr pNode, uint32 *fullNameHintLength, uint32 *pShortNameOffset)\n{\n    // propertyString could be null, such as 'this.foo' =\n    // propertyString could be empty, found in pattern as in (-1)[\"\"][(x = z)]\n\n    OpCode op = pNode->nop;\n    LPCOLESTR rightNode = nullptr;\n    if (propertyString == nullptr)\n    {\n        propertyString = _u(\"\");\n    }\n\n    if (op != knopInt && op != knopFlt && op != knopName && op != knopStr)\n    {\n        rightNode = _u(\"\");\n    }\n    else if (op == knopStr)\n    {\n        return AppendNameHints(propertyString, pNode->sxPid.pid, fullNameHintLength, pShortNameOffset, false, true/*add brackets*/);\n    }\n    else if(op == knopFlt)\n    {\n        rightNode = m_pscan->StringFromDbl(pNode->sxFlt.dbl);\n    }\n    else\n    {\n        rightNode = op == knopInt ? m_pscan->StringFromLong(pNode->sxInt.lw)\n            : pNode->sxPid.pid->Psz();\n    }\n\n    return AppendNameHints(propertyString, rightNode, fullNameHintLength, pShortNameOffset, false, true/*add brackets*/);\n}\n\nLPCOLESTR Parser::ConstructNameHint(ParseNodePtr pNode, uint32* fullNameHintLength, uint32 *pShortNameOffset)\n{\n    Assert(pNode != nullptr);\n    Assert(pNode->nop == knopDot || pNode->nop == knopIndex);\n    LPCOLESTR leftNode = nullptr;\n    if (pNode->sxBin.pnode1->nop == knopDot || pNode->sxBin.pnode1->nop == knopIndex)\n    {\n        leftNode = ConstructNameHint(pNode->sxBin.pnode1, fullNameHintLength, pShortNameOffset);\n    }\n    else if (pNode->sxBin.pnode1->nop == knopName)\n    {\n        leftNode = pNode->sxBin.pnode1->sxPid.pid->Psz();\n        *fullNameHintLength = pNode->sxBin.pnode1->sxPid.pid->Cch();\n        *pShortNameOffset = 0;\n    }\n\n    if (pNode->nop == knopIndex)\n    {\n        return FormatPropertyString(\n            leftNode ? leftNode : Js::Constants::AnonymousFunction, // e.g. f()[0] = function () {}\n            pNode->sxBin.pnode2, fullNameHintLength, pShortNameOffset);\n    }\n\n    Assert(pNode->sxBin.pnode2->nop == knopDot || pNode->sxBin.pnode2->nop == knopName);\n\n    LPCOLESTR rightNode = nullptr;\n    bool wrapWithBrackets = false;\n    if (pNode->sxBin.pnode2->nop == knopDot)\n    {\n        rightNode = ConstructNameHint(pNode->sxBin.pnode2, fullNameHintLength, pShortNameOffset);\n    }\n    else\n    {\n        rightNode = pNode->sxBin.pnode2->sxPid.pid->Psz();\n        wrapWithBrackets = PNodeFlags::fpnIndexOperator == (pNode->grfpn & PNodeFlags::fpnIndexOperator);\n    }\n    Assert(rightNode != nullptr);\n    return AppendNameHints(leftNode, rightNode, fullNameHintLength, pShortNameOffset, false, wrapWithBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR leftStr, uint32 leftLen, LPCOLESTR rightStr, uint32 rightLen, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    Assert(rightStr != nullptr);\n    Assert(leftLen  != 0 || wrapInBrackets);\n    Assert(rightLen != 0 || wrapInBrackets);\n\n    bool ignoreDot = rightStr[0] == _u('[') && !wrapInBrackets;//if we wrap in brackets it can be a string literal which can have brackets at the first char\n    uint32 totalLength = leftLen + rightLen + ((ignoreDot) ? 1 : 2); // 1 (for dot or [) + 1 (for null termination)\n\n    if (wrapInBrackets)\n    {\n        totalLength++; //1 for ']';\n    }\n    WCHAR * finalName = AllocateStringOfLength(totalLength);\n\n    if (leftStr != nullptr && leftLen != 0)\n    {\n        wcscpy_s(finalName, leftLen + 1, leftStr);\n    }\n\n    if (ignoreAddDotWithSpace)\n    {\n        finalName[leftLen++] = (OLECHAR)_u(' ');\n    }\n    // mutually exclusive from ignoreAddDotWithSpace which is used for getters/setters\n\n    else if (wrapInBrackets)\n    {\n        finalName[leftLen++] = (OLECHAR)_u('[');\n        finalName[totalLength-2] = (OLECHAR)_u(']');\n    }\n    else if (!ignoreDot)\n    {\n        finalName[leftLen++] = (OLECHAR)_u('.');\n    }\n    //ignore case falls through\n    js_wmemcpy_s(finalName + leftLen, rightLen, rightStr, rightLen);\n    finalName[totalLength-1] = (OLECHAR)_u('\\0');\n\n    if (pNameLength != nullptr)\n    {\n        *pNameLength = totalLength - 1;\n    }\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = leftLen;\n    }\n\n    return finalName;\n}\n\nWCHAR * Parser::AllocateStringOfLength(ULONG length)\n{\n    Assert(length > 0);\n    ULONG totalBytes;\n    if (ULongMult(length, sizeof(OLECHAR), &totalBytes) != S_OK)\n    {\n        Error(ERRnoMemory);\n    }\n    WCHAR* finalName = (WCHAR*)m_phtbl->GetAllocator()->Alloc(totalBytes);\n    if (finalName == nullptr)\n    {\n        Error(ERRnoMemory);\n    }\n    return finalName;\n}\n\nLPCOLESTR Parser::AppendNameHints(IdentPtr left, IdentPtr right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    if (left == nullptr && !wrapInBrackets)\n    {\n        if (right)\n        {\n            *pNameLength = right->Cch();\n            return right->Psz();\n        }\n        return nullptr;\n    }\n\n    uint32 leftLen = 0;\n    LPCOLESTR leftStr = _u(\"\");\n\n    if (left != nullptr) // if wrapInBrackets is true\n    {\n        leftStr = left->Psz();\n        leftLen = left->Cch();\n    }\n\n    if (right == nullptr)\n    {\n        *pNameLength = leftLen;\n        return left->Psz();\n    }\n    uint32 rightLen = right->Cch();\n\n    return AppendNameHints(leftStr, leftLen, right->Psz(), rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(IdentPtr left, LPCOLESTR right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 rightLen = (right == nullptr) ? 0 : (uint32) wcslen(right);\n\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    Assert(rightLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (left == nullptr && !wrapInBrackets)\n    {\n        *pNameLength = rightLen;\n        return right;\n    }\n\n    LPCOLESTR leftStr = _u(\"\");\n    uint32 leftLen = 0;\n\n    if (left != nullptr) // if wrapInBrackets is true\n    {\n        leftStr = left->Psz();\n        leftLen = left->Cch();\n    }\n\n    if (rightLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = leftLen;\n        return left->Psz();\n    }\n\n    return AppendNameHints(leftStr, leftLen, right, rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR left, IdentPtr right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 leftLen = (left == nullptr) ? 0 : (uint32) wcslen(left);\n\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n\n    Assert(leftLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (left == nullptr || (leftLen == 0 && !wrapInBrackets))\n    {\n        if (right != nullptr)\n        {\n            *pNameLength = right->Cch();\n            return right->Psz();\n        }\n        return nullptr;\n    }\n\n    if (right == nullptr)\n    {\n        *pNameLength = leftLen;\n        return left;\n    }\n    uint32 rightLen = right->Cch();\n\n    return AppendNameHints(left, leftLen, right->Psz(), rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\n\nLPCOLESTR Parser::AppendNameHints(LPCOLESTR left, LPCOLESTR right, uint32 *pNameLength, uint32 *pShortNameOffset, bool ignoreAddDotWithSpace, bool wrapInBrackets)\n{\n    uint32 leftLen = (left == nullptr) ? 0 : (uint32) wcslen(left);\n    uint32 rightLen = (right == nullptr) ? 0 : (uint32) wcslen(right);\n    if (pShortNameOffset != nullptr)\n    {\n        *pShortNameOffset = 0;\n    }\n    Assert(rightLen <= ULONG_MAX && leftLen <= ULONG_MAX); // name hints should not exceed ULONG_MAX characters\n\n    if (leftLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = right ? rightLen : 0;\n        return right;\n    }\n\n    if (rightLen == 0 && !wrapInBrackets)\n    {\n        *pNameLength = leftLen;\n        return left;\n    }\n\n    return AppendNameHints(left, leftLen, right, rightLen, pNameLength, pShortNameOffset, ignoreAddDotWithSpace, wrapInBrackets);\n}\n\n/**\n * Emits a spread error if there is no ambiguity, or marks defers the error for\n * when we can determine if it is a rest error or a spread error.\n *\n * The ambiguity arises when we are parsing a lambda parameter list but we have\n * not seen the => token. At this point, we are either in a parenthesized\n * expression or a parameter list, and cannot issue an error until the matching\n * RParen has been scanned.\n *\n * The actual emission of the error happens in ParseExpr, when we first know if\n * the expression is a lambda parameter list or not.\n *\n */\nvoid Parser::DeferOrEmitPotentialSpreadError(ParseNodePtr pnodeT)\n{\n    if (m_parenDepth > 0)\n    {\n        if (m_token.tk == tkRParen)\n        {\n           if (!m_deferEllipsisError)\n            {\n                // Capture only the first error instance.\n                m_pscan->Capture(&m_EllipsisErrLoc);\n                m_deferEllipsisError = true;\n            }\n        }\n        else\n        {\n            Error(ERRUnexpectedEllipsis);\n        }\n    }\n    else\n    {\n        Error(ERRInvalidSpreadUse);\n    }\n}\n\n/***************************************************************************\nParse an optional sub expression returning null if there was no expression.\nChecks for no expression by looking for a token that can follow an\nExpression grammar production.\n***************************************************************************/\ntemplate<bool buildAST>\nbool Parser::ParseOptionalExpr(ParseNodePtr* pnode, bool fUnaryOrParen, int oplMin, BOOL *pfCanAssign, BOOL fAllowIn, BOOL fAllowEllipsis, _Inout_opt_ IdentToken* pToken)\n{\n    *pnode = nullptr;\n    if (m_token.tk == tkRCurly ||\n        m_token.tk == tkRBrack ||\n        m_token.tk == tkRParen ||\n        m_token.tk == tkSColon ||\n        m_token.tk == tkColon ||\n        m_token.tk == tkComma ||\n        m_token.tk == tkLimKwd ||\n        m_pscan->FHadNewLine())\n    {\n        return false;\n    }\n\n    IdentToken token;\n    ParseNodePtr pnodeT = ParseExpr<buildAST>(oplMin, pfCanAssign, fAllowIn, fAllowEllipsis, nullptr /*pNameHint*/, nullptr /*pHintLength*/, nullptr /*pShortNameOffset*/, &token, fUnaryOrParen);\n    // Detect nested function escapes of the pattern \"return function(){...}\" or \"yield function(){...}\".\n    // Doing so in the parser allows us to disable stack-nested-functions in common cases where an escape\n    // is not detected at byte code gen time because of deferred parsing.\n    this->MarkEscapingRef(pnodeT, &token);\n    if (pToken)\n    {\n        *pToken = token;\n    }\n    *pnode = pnodeT;\n    return true;\n}\n\n/***************************************************************************\nParse a sub expression.\n'fAllowIn' indicates if the 'in' operator should be allowed in the initializing\nexpression ( it is not allowed in the context of the first expression in a  'for' loop).\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseExpr(int oplMin,\n    BOOL *pfCanAssign,\n    BOOL fAllowIn,\n    BOOL fAllowEllipsis,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken,\n    bool fUnaryOrParen,\n    _Inout_opt_ bool* pfLikelyPattern,\n    _Inout_opt_ charcount_t *plastRParen)\n{\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n    int opl;\n    OpCode nop;\n    charcount_t ichMin;\n    ParseNodePtr pnode = nullptr;\n    ParseNodePtr pnodeT = nullptr;\n    BOOL fCanAssign = TRUE;\n    bool assignmentStmt = false;\n    bool fIsDotOrIndex = false;\n    IdentToken term;\n    RestorePoint termStart;\n    uint32 hintLength = 0;\n    uint32 hintOffset = 0;\n\n    ParserState parserState;\n\n    if (pHintLength != nullptr)\n    {\n        hintLength = *pHintLength;\n    }\n\n    if (pShortNameOffset != nullptr)\n    {\n        hintOffset = *pShortNameOffset;\n    }\n\n    EnsureStackAvailable();\n\n    // Storing the state here as we need to restore this state back when we need to reparse the grammar under lambda syntax.\n    CaptureState(&parserState);\n\n    m_pscan->Capture(&termStart);\n\n    bool deferredErrorFoundOnLeftSide = false;\n    bool savedDeferredInitError = m_hasDeferredShorthandInitError;\n    m_hasDeferredShorthandInitError = false;\n\n    // Is the current token a unary operator?\n    if (m_phtbl->TokIsUnop(m_token.tk, &opl, &nop) && nop != knopNone)\n    {\n        IdentToken operandToken;\n        ichMin = m_pscan->IchMinTok();\n\n        if (nop == knopYield)\n        {\n            if (!m_pscan->YieldIsKeyword() || oplMin > opl)\n            {\n                // The case where 'yield' is scanned as a keyword (tkYIELD) but the scanner\n                // is not treating yield as a keyword (!m_pscan->YieldIsKeyword()) occurs\n                // in strict mode non-generator function contexts.\n                //\n                // That is, 'yield' is a keyword because of strict mode, but YieldExpression\n                // is not a grammar production outside of generator functions.\n                //\n                // Otherwise it is an error for a yield to appear in the context of a higher level\n                // binding operator, be it unary or binary.\n                Error(ERRsyntax);\n            }\n            if (m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                Error(ERRsyntax);\n            }\n        }\n        else if (nop == knopAwait)\n        {\n            if (!m_pscan->AwaitIsKeyword() ||\n                m_currentScope->GetScopeType() == ScopeType_Parameter)\n            {\n                // As with the 'yield' keyword, the case where 'await' is scanned as a keyword (tkAWAIT)\n                // but the scanner is not treating await as a keyword (!m_pscan->AwaitIsKeyword())\n                // occurs in strict mode non-async function contexts.\n                //\n                // That is, 'await' is a keyword because of strict mode, but AwaitExpression\n                // is not a grammar production outside of async functions.\n                //\n                // Further, await expressions are disallowed within parameter scopes.\n                Error(ERRBadAwait);\n            }\n        }\n\n        m_pscan->Scan();\n\n        if (m_token.tk == tkEllipsis) {\n            // ... cannot have a unary prefix.\n            Error(ERRUnexpectedEllipsis);\n        }\n\n        if (nop == knopYield && !m_pscan->FHadNewLine() && m_token.tk == tkStar)\n        {\n            m_pscan->Scan();\n            nop = knopYieldStar;\n        }\n\n        if (nop == knopYield)\n        {\n            if (!ParseOptionalExpr<buildAST>(&pnodeT, false, opl, NULL, TRUE, fAllowEllipsis))\n            {\n                nop = knopYieldLeaf;\n                if (buildAST)\n                {\n                    pnode = CreateNodeT<knopYieldLeaf>(ichMin, m_pscan->IchLimTok());\n                }\n            }\n        }\n        else\n        {\n            // Disallow spread after a unary operator.\n            pnodeT = ParseExpr<buildAST>(opl, &fCanAssign, TRUE, FALSE, nullptr /*hint*/, nullptr /*hintLength*/, nullptr /*hintOffset*/, &operandToken, true);\n        }\n\n        if (nop != knopYieldLeaf)\n        {\n            if (nop == knopIncPre || nop == knopDecPre)\n            {\n                if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n                {\n                    Error(JSERR_CantAssignTo);\n                }\n                TrackAssignment<buildAST>(pnodeT, &operandToken);\n                if (buildAST)\n                {\n                    if (IsStrictMode() && pnodeT->nop == knopName)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(pnodeT->sxPid.pid);\n                    }\n                }\n                else\n                {\n                    if (IsStrictMode() && operandToken.tk == tkID)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(operandToken.pid);\n                    }\n                }\n            }\n            else if (nop == knopEllipsis)\n            {\n                if (!fAllowEllipsis)\n                {\n                    DeferOrEmitPotentialSpreadError(pnodeT);\n                }\n            }\n            else if (m_token.tk == tkExpo)\n            {\n                //Unary operator on the left hand-side of ** is unexpected, except ++, -- or ...\n                Error(ERRInvalidUseofExponentiationOperator);\n            }\n\n            if (buildAST)\n            {\n                //Do not do the folding for Asm in case of KnopPos as we need this to determine the type\n                if (nop == knopPos && (pnodeT->nop == knopInt || pnodeT->nop == knopFlt) && !this->m_InAsmMode)\n                {\n                    // Fold away a unary '+' on a number.\n                    pnode = pnodeT;\n                }\n                else if (nop == knopNeg &&\n                    ((pnodeT->nop == knopInt && pnodeT->sxInt.lw != 0) ||\n                    (pnodeT->nop == knopFlt && (pnodeT->sxFlt.dbl != 0 || this->m_InAsmMode))))\n                {\n                    // Fold a unary '-' on a number into the value of the number itself.\n                    pnode = pnodeT;\n                    if (pnode->nop == knopInt)\n                    {\n                        pnode->sxInt.lw = -pnode->sxInt.lw;\n                    }\n                    else\n                    {\n                        pnode->sxFlt.dbl = -pnode->sxFlt.dbl;\n                    }\n                }\n                else\n                {\n                    pnode = CreateUniNode(nop, pnodeT);\n                    this->CheckArguments(pnode->sxUni.pnode1);\n                }\n                pnode->ichMin = ichMin;\n            }\n\n            if (nop == knopDelete)\n            {\n                if (IsStrictMode())\n                {\n                    if ((buildAST && pnode->sxUni.pnode1->nop == knopName) ||\n                        (!buildAST && operandToken.tk == tkID))\n                    {\n                        Error(ERRInvalidDelete);\n                    }\n                }\n\n                if (buildAST)\n                {\n                    ParseNodePtr pnode1 = pnode->sxUni.pnode1;\n                    if (m_currentNodeFunc)\n                    {\n                        if (pnode1->nop == knopDot || pnode1->nop == knopIndex)\n                        {\n                            // If we delete an arguments property, use the conservative,\n                            // heap-allocated arguments object.\n                            this->CheckArguments(pnode1->sxBin.pnode1);\n                        }\n                    }\n                }\n            }\n        }\n\n        fCanAssign = FALSE;\n    }\n    else\n    {\n        ichMin = m_pscan->IchMinTok();\n        BOOL fLikelyPattern = FALSE;\n        pnode = ParseTerm<buildAST>(TRUE, pNameHint, &hintLength, &hintOffset, &term, fUnaryOrParen, &fCanAssign, IsES6DestructuringEnabled() ? &fLikelyPattern : nullptr, &fIsDotOrIndex, plastRParen);\n        if (pfLikelyPattern != nullptr)\n        {\n            *pfLikelyPattern = !!fLikelyPattern;\n        }\n\n        if (m_token.tk == tkDArrow)\n        {\n            m_hasDeferredShorthandInitError = false;\n        }\n\n        if (m_token.tk == tkAsg && oplMin <= koplAsg && fLikelyPattern)\n        {\n            m_pscan->SeekTo(termStart);\n\n            // As we are reparsing from the beginning of the destructured literal we need to reset the Block IDs as well to make sure the Block IDs\n            // on the pidref stack match.\n            int saveNextBlockId = m_nextBlockId;\n            m_nextBlockId = parserState.m_nextBlockId;\n\n            ParseDestructuredLiteralWithScopeSave(tkLCurly, false/*isDecl*/, false /*topLevel*/, DIC_ShouldNotParseInitializer);\n\n            // Restore the Block ID at the end of the reparsing so it matches the one at the end of the first pass. We need to do this \n            // because we don't parse initializers during reparse and there may be additional blocks (e.g. a class declaration)\n            // in the initializers that will cause the next Block ID at the end of the reparsing to be different.\n            m_nextBlockId = saveNextBlockId;\n\n            if (buildAST)\n            {\n                pnode = ConvertToPattern(pnode);\n            }\n\n            // The left-hand side is found to be destructuring pattern - so the shorthand can have initializer.\n            m_hasDeferredShorthandInitError = false;\n        }\n\n        if (buildAST)\n        {\n            pNameHint = NULL;\n            if (pnode->nop == knopName)\n            {\n                pNameHint = pnode->sxPid.pid->Psz();\n                hintLength = pnode->sxPid.pid->Cch();\n                hintOffset = 0;\n            }\n            else if (pnode->nop == knopDot || pnode->nop == knopIndex)\n            {\n                if (CONFIG_FLAG(UseFullName))\n                {\n                    pNameHint = ConstructNameHint(pnode, &hintLength, &hintOffset);\n                }\n                else\n                {\n                    ParseNodePtr pnodeName = pnode;\n                    while (pnodeName->nop == knopDot)\n                    {\n                        pnodeName = pnodeName->sxBin.pnode2;\n                    }\n\n                    if (pnodeName->nop == knopName)\n                    {\n                        pNameHint = pnodeName->sxPid.pid->Psz();\n                        hintLength = pnodeName->sxPid.pid->Cch();\n                        hintOffset = 0;\n                    }\n                }\n            }\n        }\n\n        // Check for postfix unary operators.\n        if (!m_pscan->FHadNewLine() &&\n            (tkInc == m_token.tk || tkDec == m_token.tk))\n        {\n            if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n            }\n            TrackAssignment<buildAST>(pnode, &term);\n            fCanAssign = FALSE;\n            if (buildAST)\n            {\n                if (IsStrictMode() && pnode->nop == knopName)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnode->sxPid.pid);\n                }\n                this->CheckArguments(pnode);\n                pnode = CreateUniNode(tkInc == m_token.tk ? knopIncPost : knopDecPost, pnode);\n                pnode->ichLim = m_pscan->IchLimTok();\n            }\n            else\n            {\n                if (IsStrictMode() && term.tk == tkID)\n                {\n                    CheckStrictModeEvalArgumentsUsage(term.pid);\n                }\n                // This expression is not an identifier\n                term.tk = tkNone;\n            }\n            m_pscan->Scan();\n        }\n    }\n\n    deferredErrorFoundOnLeftSide = m_hasDeferredShorthandInitError;\n\n    // Process a sequence of operators and operands.\n    for (;;)\n    {\n        if (!m_phtbl->TokIsBinop(m_token.tk, &opl, &nop) || nop == knopNone)\n        {\n            break;\n        }\n        if ( ! fAllowIn && nop == knopIn )\n        {\n            break;\n        }\n        Assert(opl != koplNo);\n\n        if (opl == koplAsg)\n        {\n            if (m_token.tk != tkDArrow)\n            {\n                // Assignment operator. These are the only right associative\n                // binary operators. We also need to special case the left\n                // operand - it should only be a LeftHandSideExpression.\n                Assert(ParseNode::Grfnop(nop) & fnopAsg || nop == knopFncDecl);\n                TrackAssignment<buildAST>(pnode, &term);\n                if (buildAST)\n                {\n                    if (IsStrictMode() && pnode->nop == knopName)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(pnode->sxPid.pid);\n                    }\n\n                    // Assignment stmt of the form \"this.<id> = <expr>\"\n                    if (nop == knopAsg && pnode->nop == knopDot && pnode->sxBin.pnode1->nop == knopThis && pnode->sxBin.pnode2->nop == knopName)\n                    {\n                        if (pnode->sxBin.pnode2->sxPid.pid != wellKnownPropertyPids.__proto__)\n                        {\n                            assignmentStmt = true;\n                        }\n                    }\n                }\n                else\n                {\n                    if (IsStrictMode() && term.tk == tkID)\n                    {\n                        CheckStrictModeEvalArgumentsUsage(term.pid);\n                    }\n                }\n            }\n\n            if (opl < oplMin)\n            {\n                break;\n            }\n            if (m_token.tk != tkDArrow && !fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n                // No recovery necessary since this is a semantic, not structural, error.\n            }\n        }\n        else if (opl == koplExpo)\n        {\n            // ** operator is right associative\n            if (opl < oplMin)\n            {\n                break;\n            }\n\n        }\n        else if (opl <= oplMin)\n        {\n            break;\n        }\n\n        // This expression is not an identifier\n        term.tk = tkNone;\n\n        // Precedence is high enough. Consume the operator token.\n        m_pscan->Scan();\n        fCanAssign = FALSE;\n\n        // Special case the \"?:\" operator\n        if (nop == knopQmark)\n        {\n            pnodeT = ParseExpr<buildAST>(koplAsg, NULL, fAllowIn);\n            ChkCurTok(tkColon, ERRnoColon);\n            ParseNodePtr pnodeT2 = ParseExpr<buildAST>(koplAsg, NULL, fAllowIn);\n            if (buildAST)\n            {\n                pnode = CreateTriNode(nop, pnode, pnodeT, pnodeT2);\n                this->CheckArguments(pnode->sxTri.pnode2);\n                this->CheckArguments(pnode->sxTri.pnode3);\n            }\n        }\n        else if (nop == knopFncDecl)\n        {\n            ushort flags = fFncLambda;\n            size_t iecpMin = 0;\n            bool isAsyncMethod = false;\n\n            RestoreStateFrom(&parserState);\n\n            m_pscan->SeekTo(termStart);\n            if (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n            {\n                ichMin = m_pscan->IchMinTok();\n                iecpMin = m_pscan->IecpMinTok();\n\n                m_pscan->Scan();\n                if ((m_token.tk == tkID || m_token.tk == tkLParen) && !m_pscan->FHadNewLine())\n                {\n                    flags |= fFncAsync;\n                    isAsyncMethod = true;\n                }\n                else\n                {\n                    m_pscan->SeekTo(termStart);\n                }\n            }\n            pnode = ParseFncDecl<buildAST>(flags, nullptr, /* needsPIDOnRCurlyScan = */false, /* resetParsingSuperRestrictionState = */false);\n            if (isAsyncMethod)\n            {\n                pnode->sxFnc.cbMin = iecpMin;\n                pnode->ichMin = ichMin;\n            }\n        }\n        else\n        {\n            // Parse the operand, make a new node, and look for more\n            IdentToken token;\n            pnodeT = ParseExpr<buildAST>(opl, NULL, fAllowIn, FALSE, pNameHint, &hintLength, &hintOffset, &token);\n\n            // Detect nested function escapes of the pattern \"o.f = function(){...}\" or \"o[s] = function(){...}\".\n            // Doing so in the parser allows us to disable stack-nested-functions in common cases where an escape\n            // is not detected at byte code gen time because of deferred parsing.\n            if (fIsDotOrIndex && nop == knopAsg)\n            {\n                this->MarkEscapingRef(pnodeT, &token);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateBinNode(nop, pnode, pnodeT);\n                Assert(pnode->sxBin.pnode2 != NULL);\n                if (pnode->sxBin.pnode2->nop == knopFncDecl)\n                {\n                    Assert(hintLength >= hintOffset);\n                    pnode->sxBin.pnode2->sxFnc.hint = pNameHint;\n                    pnode->sxBin.pnode2->sxFnc.hintLength = hintLength;\n                    pnode->sxBin.pnode2->sxFnc.hintOffset = hintOffset;\n\n                    if (pnode->sxBin.pnode1->nop == knopDot)\n                    {\n                        pnode->sxBin.pnode2->sxFnc.isNameIdentifierRef  = false;\n                    }\n                    else if (pnode->sxBin.pnode1->nop == knopName)\n                    {\n                        PidRefStack *pidRef = pnode->sxBin.pnode1->sxPid.pid->GetTopRef();\n                        pidRef->isFuncAssignment = true;\n                    }\n                }\n                if (pnode->sxBin.pnode2->nop == knopClassDecl && pnode->sxBin.pnode1->nop == knopDot)\n                {\n                    Assert(pnode->sxBin.pnode2->sxClass.pnodeConstructor);\n                    pnode->sxBin.pnode2->sxClass.pnodeConstructor->sxFnc.isNameIdentifierRef  = false;\n                }\n            }\n            pNameHint = NULL;\n        }\n    }\n\n    if (buildAST)\n    {\n        if (!assignmentStmt)\n        {\n            // Don't set the flag for following nodes\n            switch (pnode->nop)\n            {\n            case knopName:\n            case knopInt:\n            case knopFlt:\n            case knopStr:\n            case knopRegExp:\n            case knopNull:\n            case knopFalse:\n            case knopTrue:\n                break;\n            default:\n                if (m_currentNodeFunc)\n                {\n                    m_currentNodeFunc->sxFnc.SetHasNonThisStmt();\n                }\n                else if (m_currentNodeProg)\n                {\n                    m_currentNodeProg->sxFnc.SetHasNonThisStmt();\n                }\n            }\n        }\n    }\n\n    if (m_hasDeferredShorthandInitError && !deferredErrorFoundOnLeftSide)\n    {\n        // Raise error only if it is found not on the right side of the expression.\n        // such as  <expr> = {x = 1}\n        Error(ERRnoColon);\n    }\n\n    m_hasDeferredShorthandInitError = m_hasDeferredShorthandInitError || savedDeferredInitError;\n\n    if (NULL != pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    //Track \"obj.a\" assignment patterns here - Promote the Assignment state for the property's PID.\n    // This includes =, += etc.\n    if (pnode != NULL)\n    {\n        uint nodeType = ParseNode::Grfnop(pnode->nop);\n        if (nodeType & fnopAsg)\n        {\n            if (nodeType & fnopBin)\n            {\n                ParseNodePtr lhs = pnode->sxBin.pnode1;\n\n                Assert(lhs);\n                if (lhs->nop == knopDot)\n                {\n                    ParseNodePtr propertyNode = lhs->sxBin.pnode2;\n                    if (propertyNode->nop == knopName)\n                    {\n                        propertyNode->sxPid.pid->PromoteAssignmentState();\n                    }\n                }\n            }\n            else if (nodeType & fnopUni)\n            {\n                // cases like obj.a++, ++obj.a\n                ParseNodePtr lhs = pnode->sxUni.pnode1;\n                if (lhs->nop == knopDot)\n                {\n                    ParseNodePtr propertyNode = lhs->sxBin.pnode2;\n                    if (propertyNode->nop == knopName)\n                    {\n                        propertyNode->sxPid.pid->PromoteAssignmentState();\n                    }\n                }\n            }\n        }\n    }\n    return pnode;\n}\n\ntemplate<bool buildAST>\nvoid Parser::TrackAssignment(ParseNodePtr pnodeT, IdentToken* pToken)\n{\n    if (buildAST)\n    {\n        Assert(pnodeT != nullptr);\n        if (pnodeT->nop == knopName)\n        {\n            PidRefStack *ref = pnodeT->sxPid.pid->GetTopRef();\n            Assert(ref);\n            ref->isAsg = true;\n        }\n    }\n    else\n    {\n        Assert(pToken != nullptr);\n        if (pToken->tk == tkID)\n        {\n            PidRefStack *ref = pToken->pid->GetTopRef();\n            Assert(ref);\n            ref->isAsg = true;\n        }\n    }\n}\n\nvoid PnPid::SetSymRef(PidRefStack *ref)\n{\n    Assert(symRef == nullptr);\n    this->symRef = ref->GetSymRef();\n}\n\nJs::PropertyId PnPid::PropertyIdFromNameNode() const\n{\n    Js::PropertyId propertyId;\n    Symbol *sym = this->sym;\n    if (sym)\n    {\n        propertyId = sym->GetPosition();\n    }\n    else\n    {\n        propertyId = this->pid->GetPropertyId();\n    }\n    return propertyId;\n}\n\nPidRefStack* Parser::PushPidRef(IdentPtr pid)\n{\n    if (PHASE_ON1(Js::ParallelParsePhase))\n    {\n        // NOTE: the phase check is here to protect perf. See OSG 1020424.\n        // In some LS AST-rewrite cases we lose a lot of perf searching the PID ref stack rather\n        // than just pushing on the top. This hasn't shown up as a perf issue in non-LS benchmarks.\n        return pid->FindOrAddPidRef(&m_nodeAllocator, GetCurrentBlock()->sxBlock.blockId, GetCurrentFunctionNode()->sxFnc.functionId);\n    }\n\n    Assert(GetCurrentBlock() != nullptr);\n    AssertMsg(pid != nullptr, \"PID should be created\");\n    PidRefStack *ref = pid->GetTopRef();\n    int blockId = GetCurrentBlock()->sxBlock.blockId;\n    int funcId = GetCurrentFunctionNode()->sxFnc.functionId;\n    if (!ref || (ref->GetScopeId() < blockId))\n    {\n        ref = Anew(&m_nodeAllocator, PidRefStack);\n        if (ref == nullptr)\n        {\n            Error(ERRnoMemory);\n        }\n        pid->PushPidRef(blockId, funcId, ref);\n    }\n    else if (m_reparsingLambdaParams)\n    {\n        // If we're reparsing params, then we may have pid refs left behind from the first pass. Make sure we're\n        // working with the right ref at this point.\n        ref = this->FindOrAddPidRef(pid, blockId, funcId);\n        // Fix up the function ID if we're reparsing lambda parameters.\n        ref->funcId = funcId;\n    }\n\n    return ref;\n}\n\nPidRefStack* Parser::FindOrAddPidRef(IdentPtr pid, int scopeId, Js::LocalFunctionId funcId)\n{\n    PidRefStack *ref = pid->FindOrAddPidRef(&m_nodeAllocator, scopeId, funcId);\n    if (ref == NULL)\n    {\n        Error(ERRnoMemory);\n    }\n    return ref;\n}\n\nvoid Parser::RemovePrevPidRef(IdentPtr pid, PidRefStack *ref)\n{\n    PidRefStack *prevRef = pid->RemovePrevPidRef(ref);\n    Assert(prevRef);\n    if (prevRef->GetSym() == nullptr)\n    {\n        AllocatorDelete(ArenaAllocator, &m_nodeAllocator, prevRef);\n    }\n}\n\nvoid Parser::SetPidRefsInScopeDynamic(IdentPtr pid, int blockId)\n{\n    PidRefStack *ref = pid->GetTopRef();\n    while (ref && ref->GetScopeId() >= blockId)\n    {\n        ref->SetDynamicBinding();\n        ref = ref->prev;\n    }\n}\n\nParseNode* Parser::GetFunctionBlock()\n{\n    Assert(m_currentBlockInfo != nullptr);\n    return m_currentBlockInfo->pBlockInfoFunction->pnodeBlock;\n}\n\n\nParseNode* Parser::GetCurrentBlock()\n{\n    return m_currentBlockInfo != nullptr ? m_currentBlockInfo->pnodeBlock : nullptr;\n}\n\nBlockInfoStack* Parser::GetCurrentBlockInfo()\n{\n    return m_currentBlockInfo;\n}\n\nBlockInfoStack* Parser::GetCurrentFunctionBlockInfo()\n{\n    return m_currentBlockInfo->pBlockInfoFunction;\n}\n\n/***************************************************************************\nParse a variable declaration.\n'fAllowIn' indicates if the 'in' operator should be allowed in the initializing\nexpression ( it is not allowed in the context of the first expression in a  'for' loop).\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseVariableDeclaration(\n    tokens declarationType, charcount_t ichMin,\n    BOOL fAllowIn/* = TRUE*/,\n    BOOL* pfForInOk/* = nullptr*/,\n    BOOL singleDefOnly/* = FALSE*/,\n    BOOL allowInit/* = TRUE*/,\n    BOOL isTopVarParse/* = TRUE*/,\n    BOOL isFor/* = FALSE*/,\n    BOOL* nativeForOk /*= nullptr*/)\n{\n    ParseNodePtr pnodeThis = nullptr;\n    ParseNodePtr pnodeInit;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    LPCOLESTR pNameHint = nullptr;\n    uint32     nameHintLength = 0;\n    uint32     nameHintOffset = 0;\n    Assert(declarationType == tkVAR || declarationType == tkCONST || declarationType == tkLET);\n\n    for (;;)\n    {\n        if (IsES6DestructuringEnabled() && IsPossiblePatternStart())\n        {\n            pnodeThis = ParseDestructuredLiteral<buildAST>(declarationType, true, !!isTopVarParse, DIC_None, !!fAllowIn, pfForInOk, nativeForOk);\n            if (pnodeThis != nullptr)\n            {\n                pnodeThis->ichMin = ichMin;\n            }\n        }\n        else\n        {\n            if (m_token.tk != tkID)\n            {\n                IdentifierExpectedError(m_token);\n            }\n\n            IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n            Assert(pid);\n            pNameHint = pid->Psz();\n            nameHintLength = pid->Cch();\n            nameHintOffset = 0;\n\n            if (pid == wellKnownPropertyPids.let && (declarationType == tkCONST || declarationType == tkLET))\n            {\n                Error(ERRLetIDInLexicalDecl, pnodeThis);\n            }\n\n            if (declarationType == tkVAR)\n            {\n                pnodeThis = CreateVarDeclNode(pid, STVariable);\n            }\n            else if (declarationType == tkCONST)\n            {\n                pnodeThis = CreateBlockScopedDeclNode(pid, knopConstDecl);\n                CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Const, m_scriptContext);\n            }\n            else\n            {\n                pnodeThis = CreateBlockScopedDeclNode(pid, knopLetDecl);\n                CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Let, m_scriptContext);\n            }\n\n            if (pid == wellKnownPropertyPids.arguments && m_currentNodeFunc)\n            {\n                // This var declaration may change the way an 'arguments' identifier in the function is resolved\n                if (declarationType == tkVAR)\n                {\n                    m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_varDeclaration;\n                }\n                else\n                {\n                    if (GetCurrentBlockInfo()->pnodeBlock->sxBlock.blockType == Function)\n                    {\n                        // Only override arguments if we are at the function block level.\n                        m_currentNodeFunc->grfpn |= PNodeFlags::fpnArguments_overriddenByDecl;\n                    }\n                }\n            }\n\n            if (pnodeThis)\n            {\n                pnodeThis->ichMin = ichMin;\n            }\n\n            m_pscan->Scan();\n\n            if (m_token.tk == tkAsg)\n            {\n                if (!allowInit)\n                {\n                    Error(ERRUnexpectedDefault);\n                }\n                if (pfForInOk && (declarationType == tkLET || declarationType == tkCONST || IsStrictMode()))\n                {\n                    *pfForInOk = FALSE;\n                }\n\n                m_pscan->Scan();\n                pnodeInit = ParseExpr<buildAST>(koplCma, nullptr, fAllowIn, FALSE, pNameHint, &nameHintLength, &nameHintOffset);\n                if (buildAST)\n                {\n                    AnalysisAssert(pnodeThis);\n                    pnodeThis->sxVar.pnodeInit = pnodeInit;\n                    pnodeThis->ichLim = pnodeInit->ichLim;\n\n                    if (pnodeInit->nop == knopFncDecl)\n                    {\n                        Assert(nameHintLength >= nameHintOffset);\n                        pnodeInit->sxFnc.hint = pNameHint;\n                        pnodeInit->sxFnc.hintLength = nameHintLength;\n                        pnodeInit->sxFnc.hintOffset = nameHintOffset;\n                        pnodeThis->sxVar.pid->GetTopRef()->isFuncAssignment = true;\n                    }\n                    else\n                    {\n                        this->CheckArguments(pnodeInit);\n                    }\n                    pNameHint = nullptr;\n                }\n\n                //Track var a =, let a= , const a =\n                // This is for FixedFields Constant Heuristics\n                if (pnodeThis && pnodeThis->sxVar.pnodeInit != nullptr)\n                {\n                    pnodeThis->sxVar.sym->PromoteAssignmentState();\n                    if (m_currentNodeFunc && pnodeThis->sxVar.sym->GetIsFormal())\n                    {\n                        m_currentNodeFunc->sxFnc.SetHasAnyWriteToFormals(true);\n                    }\n                }\n            }\n            else if (declarationType == tkCONST /*pnodeThis->nop == knopConstDecl*/\n                     && !singleDefOnly\n                     && !(isFor && TokIsForInOrForOf()))\n            {\n                Error(ERRUninitializedConst);\n            }\n        }\n\n        if (singleDefOnly)\n        {\n            return pnodeThis;\n        }\n\n        if (buildAST)\n        {\n            AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeThis);\n        }\n\n        if (m_token.tk != tkComma)\n        {\n            return pnodeList;\n        }\n\n        if (pfForInOk)\n        {\n            // don't allow \"for (var a, b in c)\"\n            *pfForInOk = FALSE;\n        }\n        m_pscan->Scan();\n        ichMin = m_pscan->IchMinTok();\n    }\n}\n\n/***************************************************************************\nParse try-catch-finally statement\n***************************************************************************/\n\n// The try-catch-finally tree nests the try-catch within a try-finally.\n// This matches the new runtime implementation.\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTryCatchFinally()\n{\n    this->m_tryCatchOrFinallyDepth++;\n\n    ParseNodePtr pnodeT = ParseTry<buildAST>();\n    ParseNodePtr pnodeTC = nullptr;\n    StmtNest stmt;\n    bool hasCatch = false;\n\n    if (tkCATCH == m_token.tk)\n    {\n        hasCatch = true;\n        if (buildAST)\n        {\n            pnodeTC = CreateNodeWithScanner<knopTryCatch>();\n            pnodeT->sxStmt.pnodeOuter = pnodeTC;\n            pnodeTC->sxTryCatch.pnodeTry = pnodeT;\n        }\n        PushStmt<buildAST>(&stmt, pnodeTC, knopTryCatch, nullptr, nullptr);\n\n        ParseNodePtr pnodeCatch = ParseCatch<buildAST>();\n        if (buildAST)\n        {\n            pnodeTC->sxTryCatch.pnodeCatch = pnodeCatch;\n        }\n        PopStmt(&stmt);\n    }\n    if (tkFINALLY != m_token.tk)\n    {\n        if (!hasCatch)\n        {\n            Error(ERRnoCatch);\n        }\n        Assert(!buildAST || pnodeTC);\n        return pnodeTC;\n    }\n\n    ParseNodePtr pnodeTF = nullptr;\n    if (buildAST)\n    {\n        pnodeTF = CreateNode(knopTryFinally);\n    }\n    PushStmt<buildAST>(&stmt, pnodeTF, knopTryFinally, nullptr, nullptr);\n    ParseNodePtr pnodeFinally = ParseFinally<buildAST>();\n    if (buildAST)\n    {\n        if (!hasCatch)\n        {\n            pnodeTF->sxTryFinally.pnodeTry = pnodeT;\n            pnodeT->sxStmt.pnodeOuter = pnodeTF;\n        }\n        else\n        {\n            pnodeTF->sxTryFinally.pnodeTry = CreateNode(knopTry);\n            pnodeTF->sxTryFinally.pnodeTry->sxStmt.pnodeOuter = pnodeTF;\n            pnodeTF->sxTryFinally.pnodeTry->sxTry.pnodeBody = pnodeTC;\n            pnodeTC->sxStmt.pnodeOuter = pnodeTF->sxTryFinally.pnodeTry;\n        }\n        pnodeTF->sxTryFinally.pnodeFinally = pnodeFinally;\n    }\n    PopStmt(&stmt);\n    this->m_tryCatchOrFinallyDepth--;\n    return pnodeTF;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseTry()\n{\n    ParseNodePtr pnode = nullptr;\n    StmtNest stmt;\n    Assert(tkTRY == m_token.tk);\n    if (buildAST)\n    {\n        pnode = CreateNode(knopTry);\n    }\n    m_pscan->Scan();\n    if (tkLCurly != m_token.tk)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    PushStmt<buildAST>(&stmt, pnode, knopTry, nullptr, nullptr);\n    ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n    if (buildAST)\n    {\n        pnode->sxTry.pnodeBody = pnodeBody;\n        if (pnode->sxTry.pnodeBody)\n            pnode->ichLim = pnode->sxTry.pnodeBody->ichLim;\n    }\n    PopStmt(&stmt);\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseFinally()\n{\n    ParseNodePtr pnode = nullptr;\n    StmtNest stmt;\n    Assert(tkFINALLY == m_token.tk);\n    if (buildAST)\n    {\n        pnode = CreateNode(knopFinally);\n    }\n    m_pscan->Scan();\n    if (tkLCurly != m_token.tk)\n    {\n        Error(ERRnoLcurly);\n    }\n\n    PushStmt<buildAST>(&stmt, pnode, knopFinally, nullptr, nullptr);\n    ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n    if (buildAST)\n    {\n        pnode->sxFinally.pnodeBody = pnodeBody;\n        if (!pnode->sxFinally.pnodeBody)\n            // Will only occur due to error correction.\n            pnode->sxFinally.pnodeBody = CreateNodeWithScanner<knopEmpty>();\n        else\n            pnode->ichLim = pnode->sxFinally.pnodeBody->ichLim;\n    }\n    PopStmt(&stmt);\n\n    return pnode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseCatch()\n{\n    ParseNodePtr rootNode = nullptr;\n    ParseNodePtr* ppnode = &rootNode;\n    ParseNodePtr *ppnodeExprScopeSave = nullptr;\n    ParseNodePtr pnode = nullptr;\n    ParseNodePtr pnodeCatchScope = nullptr;\n    StmtNest stmt;\n    IdentPtr pidCatch = nullptr;\n    //while (tkCATCH == m_token.tk)\n    if (tkCATCH == m_token.tk)\n    {\n        charcount_t ichMin;\n        if (buildAST)\n        {\n            ichMin = m_pscan->IchMinTok();\n        }\n        m_pscan->Scan(); //catch\n        ChkCurTok(tkLParen, ERRnoLparen); //catch(\n\n        bool isPattern = false;\n        if (tkID != m_token.tk)\n        {\n            isPattern = IsES6DestructuringEnabled() && IsPossiblePatternStart();\n            if (!isPattern)\n            {\n                IdentifierExpectedError(m_token);\n            }\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopCatch>(ichMin);\n            PushStmt<buildAST>(&stmt, pnode, knopCatch, nullptr, nullptr);\n            *ppnode = pnode;\n            ppnode = &pnode->sxCatch.pnodeNext;\n            *ppnode = nullptr;\n        }\n\n        pnodeCatchScope = StartParseBlock<buildAST>(PnodeBlockType::Regular, isPattern ? ScopeType_CatchParamPattern : ScopeType_Catch);\n\n        if (buildAST)\n        {\n            // Add this catch to the current scope list.\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pnode;\n                m_ppnodeExprScope = &pnode->sxCatch.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pnode;\n                m_ppnodeScope = &pnode->sxCatch.pnodeNext;\n            }\n\n            // Keep a list of function expressions (not declarations) at this scope.\n\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = &pnode->sxCatch.pnodeScopes;\n            pnode->sxCatch.pnodeScopes = nullptr;\n        }\n\n        if (isPattern)\n        {\n            ParseNodePtr pnodePattern = ParseDestructuredLiteral<buildAST>(tkLET, true /*isDecl*/, true /*topLevel*/, DIC_ForceErrorOnInitializer);\n            if (buildAST)\n            {\n                pnode->sxCatch.pnodeParam = CreateParamPatternNode(pnodePattern);\n                Scope *scope = pnodeCatchScope->sxBlock.scope;\n                pnode->sxCatch.scope = scope;\n            }\n        }\n        else\n        {\n            if (IsStrictMode())\n            {\n                IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n                if (pid == wellKnownPropertyPids.eval)\n                {\n                    Error(ERREvalUsage);\n                }\n                else if (pid == wellKnownPropertyPids.arguments)\n                {\n                    Error(ERRArgsUsage);\n                }\n            }\n\n            pidCatch = m_token.GetIdentifier(m_phtbl);\n            PidRefStack *ref = this->PushPidRef(pidCatch);\n\n            ParseNodePtr pnodeParam = CreateNameNode(pidCatch);\n            pnodeParam->sxPid.symRef = ref->GetSymRef();\n\n            const char16 *name = reinterpret_cast<const char16*>(pidCatch->Psz());\n            int nameLength = pidCatch->Cch();\n            SymbolName const symName(name, nameLength);\n            Symbol *sym = Anew(&m_nodeAllocator, Symbol, symName, pnodeParam, STVariable);\n            sym->SetPid(pidCatch);\n            if (sym == nullptr)\n            {\n                Error(ERRnoMemory);\n            }\n            Assert(ref->GetSym() == nullptr);\n            ref->SetSym(sym);\n\n            Scope *scope = pnodeCatchScope->sxBlock.scope;\n            scope->AddNewSymbol(sym);\n\n            if (buildAST)\n            {\n                pnode->sxCatch.pnodeParam = pnodeParam;\n                pnode->sxCatch.scope = scope;\n            }\n\n            m_pscan->Scan();\n        }\n\n        charcount_t ichLim;\n        if (buildAST)\n        {\n            ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRParen, ERRnoRparen); //catch(id[:expr])\n\n        if (tkLCurly != m_token.tk)\n        {\n            Error(ERRnoLcurly);\n        }\n\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();  //catch(id[:expr]) {block}\n        if (buildAST)\n        {\n            pnode->sxCatch.pnodeBody = pnodeBody;\n            pnode->ichLim = ichLim;\n        }\n\n        if (pnodeCatchScope != nullptr)\n        {\n            FinishParseBlock(pnodeCatchScope);\n        }\n\n        if (buildAST)\n        {\n            PopStmt(&stmt);\n\n            // Restore the lists of function expression scopes.\n\n            AssertMem(m_ppnodeExprScope);\n            Assert(*m_ppnodeExprScope == nullptr);\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n        }\n    }\n    return rootNode;\n}\n\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseCase(ParseNodePtr *ppnodeBody)\n{\n    ParseNodePtr pnodeT = nullptr;\n\n    charcount_t ichMinT = m_pscan->IchMinTok();\n    m_pscan->Scan();\n    ParseNodePtr pnodeExpr = ParseExpr<buildAST>();\n    charcount_t ichLim = m_pscan->IchLimTok();\n\n    ChkCurTok(tkColon, ERRnoColon);\n\n    if (buildAST)\n    {\n        pnodeT = CreateNodeWithScanner<knopCase>(ichMinT);\n        pnodeT->sxCase.pnodeExpr = pnodeExpr;\n        pnodeT->ichLim = ichLim;\n    }\n    ParseStmtList<buildAST>(ppnodeBody);\n\n    return pnodeT;\n}\n\n/***************************************************************************\nParse a single statement. Digest a trailing semicolon.\n***************************************************************************/\ntemplate<bool buildAST>\nParseNodePtr Parser::ParseStatement()\n{\n    ParseNodePtr *ppnodeT;\n    ParseNodePtr pnodeT;\n    ParseNodePtr pnode = nullptr;\n    LabelId* pLabelIdList = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    StmtNest stmt;\n    StmtNest *pstmt;\n    BOOL fForInOrOfOkay;\n    BOOL fCanAssign;\n    IdentPtr pid;\n    uint fnop;\n    ParseNodePtr pnodeLabel = nullptr;\n    bool expressionStmt = false;\n    bool isAsyncMethod = false;\n    tokens tok;\n#if EXCEPTION_RECOVERY\n    ParseNodePtr pParentTryCatch = nullptr;\n    ParseNodePtr pTryBlock = nullptr;\n    ParseNodePtr pTry = nullptr;\n    ParseNodePtr pParentTryCatchBlock = nullptr;\n\n    StmtNest stmtTryCatchBlock;\n    StmtNest stmtTryCatch;\n    StmtNest stmtTry;\n    StmtNest stmtTryBlock;\n#endif\n\n    if (buildAST)\n    {\n#if EXCEPTION_RECOVERY\n        if(Js::Configuration::Global.flags.SwallowExceptions)\n        {\n            // If we're swallowing exceptions, surround this statement with a try/catch block:\n            //\n            //   Before: x.y = 3;\n            //   After:  try { x.y = 3; } catch(__ehobj) { }\n            //\n            // This is done to force the runtime to recover from exceptions at the most granular\n            // possible point.  Recovering from EH dramatically improves coverage of testing via\n            // fault injection.\n\n\n            // create and push the try-catch node\n            pParentTryCatchBlock = CreateBlockNode();\n            PushStmt<buildAST>(&stmtTryCatchBlock, pParentTryCatchBlock, knopBlock, nullptr, nullptr);\n            pParentTryCatch = CreateNodeWithScanner<knopTryCatch>();\n            PushStmt<buildAST>(&stmtTryCatch, pParentTryCatch, knopTryCatch, nullptr, nullptr);\n\n            // create and push a try node\n            pTry = CreateNodeWithScanner<knopTry>();\n            PushStmt<buildAST>(&stmtTry, pTry, knopTry, nullptr, nullptr);\n            pTryBlock = CreateBlockNode();\n            PushStmt<buildAST>(&stmtTryBlock, pTryBlock, knopBlock, nullptr, nullptr);\n            // these nodes will be closed after the statement is parsed.\n        }\n#endif // EXCEPTION_RECOVERY\n    }\n\n    EnsureStackAvailable();\n\nLRestart:\n    tok = m_token.tk;\n\n    switch (tok)\n    {\n    case tkEOF:\n        if (buildAST)\n        {\n            pnode = nullptr;\n        }\n        break;\n\n    case tkFUNCTION:\n    {\nLFunctionStatement:\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            m_grfscr &= ~fscrDeferredFncExpression;\n            pnode = ParseFncDecl<buildAST>(isAsyncMethod ? fFncAsync : fFncNoFlgs, nullptr);\n        }\n        else\n        {\n            pnode = ParseFncDecl<buildAST>(fFncDeclaration | (isAsyncMethod ? fFncAsync : fFncNoFlgs), nullptr);\n        }\n        if (isAsyncMethod)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(TRUE, nullptr, nullptr, nullptr);\n        }\n        else\n        {\n            goto LDefaultToken;\n        }\n        break;\n\n    case tkID:\n        if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.let)\n        {\n            // We see \"let\" at the start of a statement. This could either be a declaration or an identifier\n            // reference. The next token determines which.\n            RestorePoint parsedLet;\n            m_pscan->Capture(&parsedLet);\n            ichMin = m_pscan->IchMinTok();\n\n            m_pscan->Scan();\n            if (this->NextTokenConfirmsLetDecl())\n            {\n                pnode = ParseVariableDeclaration<buildAST>(tkLET, ichMin);\n                goto LNeedTerminator;\n            }\n            m_pscan->SeekTo(parsedLet);\n        }\n        else if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.async && m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            RestorePoint parsedAsync;\n            m_pscan->Capture(&parsedAsync);\n            ichMin = m_pscan->IchMinTok();\n            iecpMin = m_pscan->IecpMinTok();\n\n            m_pscan->Scan();\n            if (m_token.tk == tkFUNCTION && !m_pscan->FHadNewLine())\n            {\n                isAsyncMethod = true;\n                goto LFunctionStatement;\n            }\n            m_pscan->SeekTo(parsedAsync);\n        }\n        goto LDefaultToken;\n\n    case tkCONST:\n    case tkLET:\n        ichMin = m_pscan->IchMinTok();\n\n        m_pscan->Scan();\n        pnode = ParseVariableDeclaration<buildAST>(tok, ichMin);\n        goto LNeedTerminator;\n\n    case tkVAR:\n        ichMin = m_pscan->IchMinTok();\n\n        m_pscan->Scan();\n        pnode = ParseVariableDeclaration<buildAST>(tok, ichMin);\n        goto LNeedTerminator;\n\n    case tkFOR:\n    {\n        ParseNodePtr pnodeBlock = nullptr;\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block);\n        if (buildAST)\n        {\n            PushFuncBlockScope(pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n        }\n\n        RestorePoint startExprOrIdentifier;\n        fForInOrOfOkay = TRUE;\n        fCanAssign = TRUE;\n        tok = m_token.tk;\n        BOOL nativeForOkay = TRUE;\n\n        switch (tok)\n        {\n        case tkID:\n            if (m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.let)\n            {\n                // We see \"let\" in the init part of a for loop. This could either be a declaration or an identifier\n                // reference. The next token determines which.\n                RestorePoint parsedLet;\n                m_pscan->Capture(&parsedLet);\n                auto ichMinInner = m_pscan->IchMinTok();\n\n                m_pscan->Scan();\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                if (this->NextTokenConfirmsLetDecl() && m_token.tk != tkIN)\n                {\n                    pnodeT = ParseVariableDeclaration<buildAST>(tkLET, ichMinInner\n                                                                , /*fAllowIn = */FALSE\n                                                                , /*pfForInOk = */&fForInOrOfOkay\n                                                                , /*singleDefOnly*/FALSE\n                                                                , /*allowInit*/TRUE\n                                                                , /*isTopVarParse*/TRUE\n                                                                , /*isFor*/TRUE\n                                                                , &nativeForOkay);\n                    break;\n                }\n                m_pscan->SeekTo(parsedLet);\n            }\n            goto LDefaultTokenFor;\n        case tkLET:\n        case tkCONST:\n        case tkVAR:\n            {\n                auto ichMinInner = m_pscan->IchMinTok();\n\n                m_pscan->Scan();\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                pnodeT = ParseVariableDeclaration<buildAST>(tok, ichMinInner\n                                                            , /*fAllowIn = */FALSE\n                                                            , /*pfForInOk = */&fForInOrOfOkay\n                                                            , /*singleDefOnly*/FALSE\n                                                            , /*allowInit*/TRUE\n                                                            , /*isTopVarParse*/TRUE\n                                                            , /*isFor*/TRUE\n                                                            , &nativeForOkay);\n            }\n            break;\n        case tkSColon:\n            pnodeT = nullptr;\n            fForInOrOfOkay = FALSE;\n            break;\n        default:\n            {\nLDefaultTokenFor:\n                RestorePoint exprStart;\n                tokens beforeToken = tok;\n                m_pscan->Capture(&exprStart);\n                if (IsPossiblePatternStart())\n                {\n                    m_pscan->Capture(&startExprOrIdentifier);\n                }\n                bool fLikelyPattern = false;\n                if (IsES6DestructuringEnabled() && (beforeToken == tkLBrack || beforeToken == tkLCurly))\n                {\n                    pnodeT = ParseExpr<buildAST>(koplNo,\n                        &fCanAssign,\n                        /*fAllowIn = */FALSE,\n                        /*fAllowEllipsis*/FALSE,\n                        /*pHint*/nullptr,\n                        /*pHintLength*/nullptr,\n                        /*pShortNameOffset*/nullptr,\n                        /*pToken*/nullptr,\n                        /**fUnaryOrParen*/false,\n                        &fLikelyPattern);\n                }\n                else\n                {\n                    pnodeT = ParseExpr<buildAST>(koplNo, &fCanAssign, /*fAllowIn = */FALSE);\n                }\n\n                // We would veryfiy the grammar as destructuring grammar only when  for..in/of case. As in the native for loop case the above ParseExpr call\n                // has already converted them appropriately.\n                if (fLikelyPattern && TokIsForInOrForOf())\n                {\n                    m_pscan->SeekTo(exprStart);\n                    ParseDestructuredLiteralWithScopeSave(tkNone, false/*isDecl*/, false /*topLevel*/, DIC_None, false /*allowIn*/);\n\n                    if (buildAST)\n                    {\n                        pnodeT = ConvertToPattern(pnodeT);\n                    }\n                }\n                if (buildAST)\n                {\n                    Assert(pnodeT);\n                    pnodeT->isUsed = false;\n                }\n            }\n            break;\n        }\n\n        if (TokIsForInOrForOf())\n        {\n            bool isForOf = (m_token.tk != tkIN);\n            Assert(!isForOf || (m_token.tk == tkID && m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.of));\n\n            if ((buildAST && nullptr == pnodeT) || !fForInOrOfOkay)\n            {\n                if (isForOf)\n                {\n                    Error(ERRForOfNoInitAllowed);\n                }\n                else\n                {\n                    Error(ERRForInNoInitAllowed);\n                }\n            }\n            if (!fCanAssign && PHASE_ON1(Js::EarlyReferenceErrorsPhase))\n            {\n                Error(JSERR_CantAssignTo);\n            }\n\n            m_pscan->Scan();\n            ParseNodePtr pnodeObj = ParseExpr<buildAST>(isForOf ? koplCma : koplNo);\n            charcount_t ichLim = m_pscan->IchLimTok();\n            ChkCurTok(tkRParen, ERRnoRparen);\n\n            if (buildAST)\n            {\n                if (isForOf)\n                {\n                    pnode = CreateNodeWithScanner<knopForOf>(ichMin);\n                }\n                else\n                {\n                    pnode = CreateNodeWithScanner<knopForIn>(ichMin);\n                }\n                pnode->sxForInOrForOf.pnodeBlock = pnodeBlock;\n                pnode->sxForInOrForOf.pnodeLval = pnodeT;\n                pnode->sxForInOrForOf.pnodeObj = pnodeObj;\n                pnode->ichLim = ichLim;\n                \n                TrackAssignment<true>(pnodeT, nullptr);\n            }\n            PushStmt<buildAST>(&stmt, pnode, isForOf ? knopForOf : knopForIn, pnodeLabel, pLabelIdList);\n            ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n\n            if (buildAST)\n            {\n                pnode->sxForInOrForOf.pnodeBody = pnodeBody;\n            }\n            PopStmt(&stmt);\n        }\n        else\n        {\n            if (!nativeForOkay)\n            {\n                Error(ERRDestructInit);\n            }\n\n            ChkCurTok(tkSColon, ERRnoSemic);\n            ParseNodePtr pnodeCond = nullptr;\n            if (m_token.tk != tkSColon)\n            {\n                pnodeCond = ParseExpr<buildAST>();\n                if (m_token.tk != tkSColon)\n                {\n                    Error(ERRnoSemic);\n                }\n            }\n\n            tokens tk;\n            tk = m_pscan->Scan();\n\n            ParseNodePtr pnodeIncr = nullptr;\n            if (tk != tkRParen)\n            {\n                pnodeIncr = ParseExpr<buildAST>();\n                if(pnodeIncr)\n                {\n                    pnodeIncr->isUsed = false;\n                }\n            }\n\n            charcount_t ichLim = m_pscan->IchLimTok();\n\n            ChkCurTok(tkRParen, ERRnoRparen);\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopFor>(ichMin);\n                pnode->sxFor.pnodeBlock = pnodeBlock;\n                pnode->sxFor.pnodeInverted= nullptr;\n                pnode->sxFor.pnodeInit = pnodeT;\n                pnode->sxFor.pnodeCond = pnodeCond;\n                pnode->sxFor.pnodeIncr = pnodeIncr;\n                pnode->ichLim = ichLim;\n            }\n            PushStmt<buildAST>(&stmt, pnode, knopFor, pnodeLabel, pLabelIdList);\n            ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n            if (buildAST)\n            {\n                pnode->sxFor.pnodeBody = pnodeBody;\n            }\n            PopStmt(&stmt);\n        }\n\n        if (buildAST)\n        {\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n        }\n\n        FinishParseBlock(pnodeBlock);\n\n        break;\n    }\n\n    case tkSWITCH:\n    {\n        BOOL fSeenDefault = FALSE;\n        ParseNodePtr pnodeBlock = nullptr;\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeVal = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopSwitch>(ichMin);\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopSwitch, pnodeLabel, pLabelIdList);\n        pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Regular, ScopeType_Block, nullptr, pLabelIdList);\n\n        if (buildAST)\n        {\n            pnode->sxSwitch.pnodeVal = pnodeVal;\n            pnode->sxSwitch.pnodeBlock = pnodeBlock;\n            pnode->ichLim = ichLim;\n            PushFuncBlockScope(pnode->sxSwitch.pnodeBlock, &ppnodeScopeSave, &ppnodeExprScopeSave);\n\n            pnode->sxSwitch.pnodeDefault = nullptr;\n            ppnodeT = &pnode->sxSwitch.pnodeCases;\n        }\n\n        for (;;)\n        {\n            ParseNodePtr pnodeBody = nullptr;\n            switch (m_token.tk)\n            {\n            default:\n                goto LEndSwitch;\n            case tkCASE:\n            {\n                pnodeT = this->ParseCase<buildAST>(&pnodeBody);\n                break;\n            }\n            case tkDEFAULT:\n                if (fSeenDefault)\n                {\n                    Error(ERRdupDefault);\n                    // No recovery necessary since this is a semantic, not structural, error\n                }\n                fSeenDefault = TRUE;\n                charcount_t ichMinT = m_pscan->IchMinTok();\n                m_pscan->Scan();\n                charcount_t ichMinInner = m_pscan->IchLimTok();\n                ChkCurTok(tkColon, ERRnoColon);\n                if (buildAST)\n                {\n                    pnodeT = CreateNodeWithScanner<knopCase>(ichMinT);\n                    pnode->sxSwitch.pnodeDefault = pnodeT;\n                    pnodeT->ichLim = ichMinInner;\n                    pnodeT->sxCase.pnodeExpr = nullptr;\n                }\n                ParseStmtList<buildAST>(&pnodeBody);\n                break;\n            }\n            if (buildAST)\n            {\n                if (pnodeBody)\n                {\n                    // Create a block node to contain the statement list for this case.\n                    // This helps us insert byte code to return the right value from\n                    // global/eval code.\n                    pnodeT->sxCase.pnodeBody = CreateBlockNode(pnodeT->ichMin, pnodeT->ichLim);\n                    pnodeT->sxCase.pnodeBody->grfpn |= PNodeFlags::fpnSyntheticNode; // block is not a user specifier block\n                    pnodeT->sxCase.pnodeBody->sxBlock.pnodeStmt = pnodeBody;\n                }\n                else\n                {\n                    pnodeT->sxCase.pnodeBody = nullptr;\n                }\n                *ppnodeT = pnodeT;\n                ppnodeT = &pnodeT->sxCase.pnodeNext;\n            }\n        }\nLEndSwitch:\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (buildAST)\n        {\n            *ppnodeT = nullptr;\n            PopFuncBlockScope(ppnodeScopeSave, ppnodeExprScopeSave);\n            FinishParseBlock(pnode->sxSwitch.pnodeBlock);\n        }\n        else\n        {\n            FinishParseBlock(pnodeBlock);\n        }\n        PopStmt(&stmt);\n\n        break;\n    }\n\n    case tkWHILE:\n    {\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopWhile>(ichMin);\n            pnode->sxWhile.pnodeCond = pnodeCond;\n            pnode->ichLim = ichLim;\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopWhile, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        PopStmt(&stmt);\n\n        if (buildAST)\n        {\n            pnode->sxWhile.pnodeBody = pnodeBody;\n        }\n        break;\n    }\n\n    case tkDO:\n    {\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopDoWhile>();\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopDoWhile, pnodeLabel, pLabelIdList);\n        m_pscan->Scan();\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        PopStmt(&stmt);\n        charcount_t ichMinT = m_pscan->IchMinTok();\n\n        ChkCurTok(tkWHILE, ERRnoWhile);\n        ChkCurTok(tkLParen, ERRnoLparen);\n\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode->sxWhile.pnodeBody = pnodeBody;\n            pnode->sxWhile.pnodeCond = pnodeCond;\n            pnode->ichLim = ichLim;\n            pnode->ichMin = ichMinT;\n        }\n\n        // REVIEW: Allow do...while statements to be embedded in other compound statements like if..else, or do..while?\n        //      goto LNeedTerminator;\n\n        // For now just eat the trailing semicolon if present.\n        if (m_token.tk == tkSColon)\n        {\n            if (pnode)\n            {\n                pnode->grfpn |= PNodeFlags::fpnExplicitSemicolon;\n            }\n            m_pscan->Scan();\n        }\n        else if (pnode)\n        {\n            pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n        }\n\n        break;\n    }\n\n    case tkIF:\n    {\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeCond = ParseExpr<buildAST>();\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopIf>(ichMin);\n            pnode->ichLim = m_pscan->IchLimTok();\n            pnode->sxIf.pnodeCond = pnodeCond;\n        }\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        PushStmt<buildAST>(&stmt, pnode, knopIf, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeTrue = ParseStatement<buildAST>();\n        ParseNodePtr pnodeFalse = nullptr;\n        if (m_token.tk == tkELSE)\n        {\n            m_pscan->Scan();\n            pnodeFalse = ParseStatement<buildAST>();\n        }\n        if (buildAST)\n        {\n            pnode->sxIf.pnodeTrue = pnodeTrue;\n            pnode->sxIf.pnodeFalse = pnodeFalse;\n        }\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkTRY:\n    {\n        if (buildAST)\n        {\n            pnode = CreateBlockNode();\n            pnode->grfpn |= PNodeFlags::fpnSyntheticNode; // block is not a user specifier block\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopBlock, pnodeLabel, pLabelIdList);\n        ParseNodePtr pnodeStmt = ParseTryCatchFinally<buildAST>();\n        if (buildAST)\n        {\n            pnode->sxBlock.pnodeStmt = pnodeStmt;\n        }\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkWITH:\n    {\n        if ( IsStrictMode() )\n        {\n            Error(ERRES5NoWith);\n        }\n        if (m_currentNodeFunc)\n        {\n            GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(); // Used by DeferNested\n        }\n\n        ichMin = m_pscan->IchMinTok();\n        ChkNxtTok(tkLParen, ERRnoLparen);\n        ParseNodePtr pnodeObj = ParseExpr<buildAST>();\n        if (!buildAST)\n        {\n            m_scopeCountNoAst++;\n        }\n        charcount_t ichLim = m_pscan->IchLimTok();\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopWith>(ichMin);\n        }\n        PushStmt<buildAST>(&stmt, pnode, knopWith, pnodeLabel, pLabelIdList);\n\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n        if (buildAST)\n        {\n            pnode->sxWith.pnodeObj = pnodeObj;\n            this->CheckArguments(pnode->sxWith.pnodeObj);\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pnode;\n                m_ppnodeExprScope = &pnode->sxWith.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pnode;\n                m_ppnodeScope = &pnode->sxWith.pnodeNext;\n            }\n            pnode->sxWith.pnodeNext = nullptr;\n            pnode->sxWith.scope = nullptr;\n\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = &pnode->sxWith.pnodeScopes;\n            pnode->sxWith.pnodeScopes = nullptr;\n\n            pnode->ichLim = ichLim;\n        }\n\n        PushBlockInfo(CreateBlockNode());\n        PushDynamicBlock();\n\n        ParseNodePtr pnodeBody = ParseStatement<buildAST>();\n        if (buildAST)\n        {\n            pnode->sxWith.pnodeBody = pnodeBody;\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n        }\n        else\n        {\n            m_scopeCountNoAst--;\n        }\n\n        // The dynamic block is not stored in the actual parse tree and so will not\n        // be visited by the byte code generator.  Grab the callsEval flag off it and\n        // pass on to outer block in case of:\n        // with (...) eval(...); // i.e. blockless form of with\n        bool callsEval = GetCurrentBlock()->sxBlock.GetCallsEval();\n        PopBlockInfo();\n        if (callsEval)\n        {\n            // be careful not to overwrite an existing true with false\n            GetCurrentBlock()->sxBlock.SetCallsEval(true);\n        }\n\n        PopStmt(&stmt);\n        break;\n    }\n\n    case tkLCurly:\n        pnode = ParseBlock<buildAST>(pnodeLabel, pLabelIdList);\n        break;\n\n    case tkSColon:\n        pnode = nullptr;\n        m_pscan->Scan();\n        break;\n\n    case tkBREAK:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopBreak>();\n        }\n        fnop = fnopBreak;\n        goto LGetJumpStatement;\n\n    case tkCONTINUE:\n        if (buildAST)\n        {\n            pnode = CreateNode(knopContinue);\n        }\n        fnop = fnopContinue;\n\nLGetJumpStatement:\n        m_pscan->ScanForcingPid();\n        if (tkID == m_token.tk && !m_pscan->FHadNewLine())\n        {\n            // Labeled break or continue.\n            pid = m_token.GetIdentifier(m_phtbl);\n            AssertMem(pid);\n            if (buildAST)\n            {\n                pnode->sxJump.hasExplicitTarget=true;\n                pnode->ichLim = m_pscan->IchLimTok();\n\n                m_pscan->Scan();\n                PushStmt<buildAST>(&stmt, pnode, pnode->nop, pnodeLabel, nullptr);\n                Assert(pnode->sxStmt.grfnop == 0);\n                for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    AssertNodeMem(pstmt->pnodeStmt);\n                    AssertNodeMemN(pstmt->pnodeLab);\n                    for (pnodeT = pstmt->pnodeLab; nullptr != pnodeT;\n                         pnodeT = pnodeT->sxLabel.pnodeNext)\n                    {\n                        Assert(knopLabel == pnodeT->nop);\n                        if (pid == pnodeT->sxLabel.pid)\n                        {\n                            // Found the label. Make sure we can use it. We can\n                            // break out of any statement, but we can only\n                            // continue loops.\n                            if (fnop == fnopContinue &&\n                                !(pstmt->pnodeStmt->Grfnop() & fnop))\n                            {\n                                Error(ERRbadContinue);\n                            }\n                            else\n                            {\n                                pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                                pnode->sxJump.pnodeTarget = pstmt->pnodeStmt;\n                            }\n                            PopStmt(&stmt);\n                            goto LNeedTerminator;\n                        }\n                    }\n                    pnode->sxStmt.grfnop |=\n                        (pstmt->pnodeStmt->Grfnop() & fnopCleanup);\n                }\n            }\n            else\n            {\n                m_pscan->Scan();\n                for (pstmt = m_pstmtCur; pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    LabelId* pLabelId;\n                    for (pLabelId = pstmt->pLabelId; pLabelId; pLabelId = pLabelId->next)\n                    {\n\n                        if (pid == pLabelId->pid)\n                        {\n                            // Found the label. Make sure we can use it. We can\n                            // break out of any statement, but we can only\n                            // continue loops.\n                            if (fnop == fnopContinue &&\n                                !(ParseNode::Grfnop(pstmt->op) & fnop))\n                            {\n                                Error(ERRbadContinue);\n                            }\n                            goto LNeedTerminator;\n                        }\n                    }\n                }\n            }\n            Error(ERRnoLabel);\n        }\n        else\n        {\n            // If we're doing a fast scan, we're not tracking labels, so we can't accurately do this analysis.\n            // Let the thread that's doing the full parse detect the error, if there is one.\n            if (!this->m_doingFastScan)\n            {\n                // Unlabeled break or continue.\n                if (buildAST)\n                {\n                    pnode->sxJump.hasExplicitTarget=false;\n                    PushStmt<buildAST>(&stmt, pnode, pnode->nop, pnodeLabel, nullptr);\n                    Assert(pnode->sxStmt.grfnop == 0);\n                }\n\n                for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n                {\n                    if (buildAST)\n                    {\n                        AnalysisAssert(pstmt->pnodeStmt);\n                        if (pstmt->pnodeStmt->Grfnop() & fnop)\n                        {\n                            pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                            pnode->sxJump.pnodeTarget = pstmt->pnodeStmt;\n                            PopStmt(&stmt);\n                            goto LNeedTerminator;\n                        }\n                        pnode->sxStmt.grfnop |=\n                            (pstmt->pnodeStmt->Grfnop() & fnopCleanup);\n                    }\n                    else\n                    {\n                        if (ParseNode::Grfnop(pstmt->GetNop()) & fnop)\n                        {\n                            if (!pstmt->isDeferred)\n                            {\n                                AnalysisAssert(pstmt->pnodeStmt);\n                                pstmt->pnodeStmt->sxStmt.grfnop |= fnop;\n                            }\n                            goto LNeedTerminator;\n                        }\n                    }\n                }\n                Error(fnop == fnopBreak ? ERRbadBreak : ERRbadContinue);\n            }\n            goto LNeedTerminator;\n        }\n\n    case tkRETURN:\n    {\n        if (buildAST)\n        {\n            if (nullptr == m_currentNodeFunc)\n            {\n                Error(ERRbadReturn);\n            }\n            pnode = CreateNodeWithScanner<knopReturn>();\n        }\n        m_pscan->Scan();\n        ParseNodePtr pnodeExpr = nullptr;\n        ParseOptionalExpr<buildAST>(&pnodeExpr, true);\n        if (buildAST)\n        {\n            pnode->sxReturn.pnodeExpr = pnodeExpr;\n            if (pnodeExpr)\n            {\n                this->CheckArguments(pnode->sxReturn.pnodeExpr);\n                pnode->ichLim = pnode->sxReturn.pnodeExpr->ichLim;\n            }\n            // See if return should call finally\n            PushStmt<buildAST>(&stmt, pnode, knopReturn, pnodeLabel, nullptr);\n            Assert(pnode->sxStmt.grfnop == 0);\n            for (pstmt = m_pstmtCur; nullptr != pstmt; pstmt = pstmt->pstmtOuter)\n            {\n                AssertNodeMem(pstmt->pnodeStmt);\n                AssertNodeMemN(pstmt->pnodeLab);\n                if (pstmt->pnodeStmt->Grfnop() & fnopCleanup)\n                {\n                    pnode->sxStmt.grfnop |= fnopCleanup;\n                    break;\n                }\n            }\n            PopStmt(&stmt);\n        }\n        goto LNeedTerminator;\n    }\n\n    case tkTHROW:\n    {\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopThrow, nullptr);\n        }\n        m_pscan->Scan();\n        ParseNodePtr pnode1 = nullptr;\n        if (m_token.tk != tkSColon &&\n            m_token.tk != tkRCurly &&\n            !m_pscan->FHadNewLine())\n        {\n            pnode1 = ParseExpr<buildAST>();\n        }\n        else\n        {\n            Error(ERRdanglingThrow);\n        }\n\n        if (buildAST)\n        {\n            pnode->sxUni.pnode1 = pnode1;\n            if (pnode1)\n            {\n                this->CheckArguments(pnode->sxUni.pnode1);\n                pnode->ichLim = pnode->sxUni.pnode1->ichLim;\n            }\n        }\n        goto LNeedTerminator;\n    }\n\n    case tkDEBUGGER:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopDebugger>();\n        }\n        m_pscan->Scan();\n        goto LNeedTerminator;\n\n    case tkIMPORT:\n        if (!(m_grfscr & fscrIsModuleCode))\n        {\n            goto LDefaultToken;\n        }\n\n        pnode = ParseImportDeclaration<buildAST>();\n\n        goto LNeedTerminator;\n\n    case tkEXPORT:\n        if (!(m_grfscr & fscrIsModuleCode))\n        {\n            goto LDefaultToken;\n        }\n\n        pnode = ParseExportDeclaration<buildAST>();\n\n        goto LNeedTerminator;\n\nLDefaultToken:\n    default:\n    {\n        // First check for a label via lookahead. If not found,\n        // rewind and reparse as expression statement.\n        if (m_token.tk == tkLParen || m_token.tk == tkID)\n        {\n            RestorePoint idStart;\n            m_pscan->Capture(&idStart);\n\n            // Support legacy behavior of allowing parentheses around label identifiers.\n            // Require balanced parentheses for correcting parsing.  Note unbalanced cases\n            // take care of themselves correctly by resulting in rewind and parsing as\n            // an expression statement.\n            // REVIEW[ianhall]: Can this legacy functionality be removed? Chrome does not support this parsing behavior.\n            uint parenCount = 0;\n            while (m_token.tk == tkLParen)\n            {\n                parenCount += 1;\n                m_pscan->Scan();\n            }\n\n            if (m_token.tk == tkID)\n            {\n                IdentToken tokInner;\n                tokInner.tk = tkID;\n                tokInner.ichMin = m_pscan->IchMinTok();\n                tokInner.ichLim = m_pscan->IchLimTok();\n                tokInner.pid = m_token.GetIdentifier(m_phtbl);\n\n                m_pscan->Scan();\n\n                while (parenCount > 0 && m_token.tk == tkRParen)\n                {\n                    parenCount -= 1;\n                    m_pscan->Scan();\n                }\n\n                if (parenCount == 0 && m_token.tk == tkColon)\n                {\n                    // We have a label.\n                    // TODO[ianhall]: Refactor to eliminate separate code paths for buildAST and !buildAST\n                    if (buildAST)\n                    {\n                        // See if the label is already defined.\n                        if (nullptr != PnodeLabel(tokInner.pid, pnodeLabel))\n                        {\n                            Error(ERRbadLabel);\n                        }\n                        pnodeT = CreateNodeWithScanner<knopLabel>();\n                        pnodeT->sxLabel.pid = tokInner.pid;\n                        pnodeT->sxLabel.pnodeNext = pnodeLabel;\n                        pnodeLabel = pnodeT;\n                    }\n                    else\n                    {\n                        // See if the label is already defined.\n                        if (PnodeLabelNoAST(&tokInner, pLabelIdList))\n                        {\n                            Error(ERRbadLabel);\n                        }\n                        LabelId* pLabelId = CreateLabelId(&tokInner);\n                        pLabelId->next = pLabelIdList;\n                        pLabelIdList = pLabelId;\n                    }\n                    m_pscan->Scan();\n                    goto LRestart;\n                }\n            }\n\n            // No label, rewind back to the tkID and parse an expression\n            m_pscan->SeekTo(idStart);\n        }\n\n        // Must be an expression statement.\n        pnode = ParseExpr<buildAST>();\n\n        if (m_hasDeferredShorthandInitError)\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            expressionStmt = true;\n\n            AnalysisAssert(pnode);\n            pnode->isUsed = false;\n        }\n    }\n\nLNeedTerminator:\n        // Need a semicolon, new-line, } or end-of-file.\n        // We digest a semicolon if it's there.\n        switch (m_token.tk)\n        {\n        case tkSColon:\n            m_pscan->Scan();\n            if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnExplicitSemicolon;\n            break;\n        case tkEOF:\n        case tkRCurly:\n            if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n            break;\n        default:\n            if (!m_pscan->FHadNewLine())\n            {\n                Error(ERRnoSemic);\n            }\n            else\n            {\n                if (pnode!= nullptr) pnode->grfpn |= PNodeFlags::fpnAutomaticSemicolon;\n            }\n            break;\n        }\n        break;\n    }\n\n    if (m_hasDeferredShorthandInitError)\n    {\n        Error(ERRnoColon);\n    }\n\n    if (buildAST)\n    {\n        // All non expression statements excluded from the \"this.x\" optimization\n        // Another check while parsing expressions\n        if (!expressionStmt)\n        {\n            if (m_currentNodeFunc)\n            {\n                m_currentNodeFunc->sxFnc.SetHasNonThisStmt();\n            }\n            else if (m_currentNodeProg)\n            {\n                m_currentNodeProg->sxFnc.SetHasNonThisStmt();\n            }\n        }\n\n#if EXCEPTION_RECOVERY\n        // close the try/catch block\n        if(Js::Configuration::Global.flags.SwallowExceptions)\n        {\n            // pop the try block and fill in the body\n            PopStmt(&stmtTryBlock);\n            pTryBlock->sxBlock.pnodeStmt = pnode;\n            PopStmt(&stmtTry);\n            if(pnode != nullptr)\n            {\n                pTry->ichLim = pnode->ichLim;\n            }\n            pTry->sxTry.pnodeBody = pTryBlock;\n\n\n            // create a catch block with an empty body\n            StmtNest stmtCatch;\n            ParseNodePtr pCatch;\n            pCatch = CreateNodeWithScanner<knopCatch>();\n            PushStmt<buildAST>(&stmtCatch, pCatch, knopCatch, nullptr, nullptr);\n            pCatch->sxCatch.pnodeBody = nullptr;\n            if(pnode != nullptr)\n            {\n                pCatch->ichLim = pnode->ichLim;\n            }\n            pCatch->sxCatch.grfnop = 0;\n            pCatch->sxCatch.pnodeNext = nullptr;\n\n            // create a fake name for the catch var.\n            const WCHAR *uniqueNameStr = _u(\"__ehobj\");\n            IdentPtr uniqueName = m_phtbl->PidHashNameLen(uniqueNameStr, static_cast<int32>(wcslen(uniqueNameStr)));\n\n            pCatch->sxCatch.pnodeParam = CreateNameNode(uniqueName);\n\n            // Add this catch to the current list. We don't bother adjusting the catch and function expression\n            // lists here because the catch is just an empty statement.\n\n            if (m_ppnodeExprScope)\n            {\n                Assert(*m_ppnodeExprScope == nullptr);\n                *m_ppnodeExprScope = pCatch;\n                m_ppnodeExprScope = &pCatch->sxCatch.pnodeNext;\n            }\n            else\n            {\n                Assert(m_ppnodeScope);\n                Assert(*m_ppnodeScope == nullptr);\n                *m_ppnodeScope = pCatch;\n                m_ppnodeScope = &pCatch->sxCatch.pnodeNext;\n            }\n\n            pCatch->sxCatch.pnodeScopes = nullptr;\n\n            PopStmt(&stmtCatch);\n\n            // fill in and pop the try-catch\n            pParentTryCatch->sxTryCatch.pnodeTry = pTry;\n            pParentTryCatch->sxTryCatch.pnodeCatch = pCatch;\n            PopStmt(&stmtTryCatch);\n            PopStmt(&stmtTryCatchBlock);\n\n            // replace the node that's being returned\n            pParentTryCatchBlock->sxBlock.pnodeStmt = pParentTryCatch;\n            pnode = pParentTryCatchBlock;\n        }\n#endif // EXCEPTION_RECOVERY\n\n    }\n\n    return pnode;\n}\n\nBOOL\nParser::TokIsForInOrForOf()\n{\n    return m_token.tk == tkIN ||\n        (m_token.tk == tkID &&\n         m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.of);\n}\n\n/***************************************************************************\nParse a sequence of statements.\n***************************************************************************/\ntemplate<bool buildAST>\nvoid Parser::ParseStmtList(ParseNodePtr *ppnodeList, ParseNodePtr **pppnodeLast, StrictModeEnvironment smEnvironment, const bool isSourceElementList, bool* strictModeOn)\n{\n    BOOL doneDirectives = !isSourceElementList; // directives may only exist in a SourceElementList, not a StatementList\n    BOOL seenDirectiveContainingOctal = false; // Have we seen an octal directive before a use strict directive?\n\n    BOOL old_UseStrictMode = m_fUseStrictMode;\n\n    ParseNodePtr pnodeStmt;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    if (buildAST)\n    {\n        AssertMem(ppnodeList);\n        AssertMemN(pppnodeLast);\n        *ppnodeList = nullptr;\n    }\n\n    if(CONFIG_FLAG(ForceStrictMode))\n    {\n        m_fUseStrictMode = TRUE;\n    }\n\n    for (;;)\n    {\n        switch (m_token.tk)\n        {\n        case tkCASE:\n        case tkDEFAULT:\n        case tkRCurly:\n        case tkEOF:\n            if (buildAST && nullptr != pppnodeLast)\n            {\n                *pppnodeLast = lastNodeRef;\n            }\n            if (!buildAST)\n            {\n                m_fUseStrictMode = old_UseStrictMode;\n            }\n            return;\n        }\n\n        if (doneDirectives == FALSE)\n        {\n            bool isOctalInString = false;\n            bool isUseStrictDirective = false;\n            bool isUseAsmDirective = false;\n            if (smEnvironment != SM_NotUsed && CheckForDirective(&isUseStrictDirective, &isUseAsmDirective, &isOctalInString))\n            {\n                // Ignore \"use asm\" statement when not building the AST\n                isUseAsmDirective &= buildAST;\n\n                if (isUseStrictDirective)\n                {\n                    // Functions with non-simple parameter list cannot be made strict mode\n                    if (GetCurrentFunctionNode()->sxFnc.HasNonSimpleParameterList())\n                    {\n                        Error(ERRNonSimpleParamListInStrictMode);\n                    }\n\n                    if (seenDirectiveContainingOctal)\n                    {\n                        // Directives seen before a \"use strict\" cannot contain an octal.\n                        Error(ERRES5NoOctal);\n                    }\n                    if (!buildAST)\n                    {\n                        // Turning on strict mode in deferred code.\n                        m_fUseStrictMode = TRUE;\n                        if (!m_inDeferredNestedFunc)\n                        {\n                            // Top-level deferred function, so there's a parse node\n                            Assert(m_currentNodeFunc != nullptr);\n                            m_currentNodeFunc->sxFnc.SetStrictMode();\n                        }\n                        else if (strictModeOn)\n                        {\n                            // This turns on strict mode in a deferred function, we need to go back\n                            // and re-check duplicated formals.\n                            *strictModeOn = true;\n                        }\n                    }\n                    else\n                    {\n                        if (smEnvironment == SM_OnGlobalCode)\n                        {\n                            // Turning on strict mode at the top level\n                            m_fUseStrictMode = TRUE;\n                        }\n                        else\n                        {\n                            // i.e. smEnvironment == SM_OnFunctionCode\n                            Assert(m_currentNodeFunc != nullptr);\n                            m_currentNodeFunc->sxFnc.SetStrictMode();\n                        }\n                    }\n                }\n                else if (isUseAsmDirective)\n                {\n                    if (smEnvironment != SM_OnGlobalCode) //Top level use asm doesn't mean anything.\n                    {\n                        // i.e. smEnvironment == SM_OnFunctionCode\n                        Assert(m_currentNodeFunc != nullptr);\n                        m_currentNodeFunc->sxFnc.SetAsmjsMode();\n                        m_currentNodeFunc->sxFnc.SetCanBeDeferred(false);\n                        m_InAsmMode = true;\n\n                        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(AsmJSFunction, m_scriptContext);\n                    }\n                }\n                else if (isOctalInString)\n                {\n                    seenDirectiveContainingOctal = TRUE;\n                }\n            }\n            else\n            {\n                // The first time we see anything other than a directive we can have no more directives.\n                doneDirectives = TRUE;\n            }\n        }\n\n        if (nullptr != (pnodeStmt = ParseStatement<buildAST>()))\n        {\n            if (buildAST)\n            {\n                AddToNodeList(ppnodeList, &lastNodeRef, pnodeStmt);\n            }\n        }\n    }\n}\n\ntemplate <class Fn>\nvoid Parser::VisitFunctionsInScope(ParseNodePtr pnodeScopeList, Fn fn)\n{\n    ParseNodePtr pnodeScope;\n    for (pnodeScope = pnodeScopeList; pnodeScope;)\n    {\n        switch (pnodeScope->nop)\n        {\n        case knopBlock:\n            VisitFunctionsInScope(pnodeScope->sxBlock.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxBlock.pnodeNext;\n            break;\n\n        case knopFncDecl:\n            fn(pnodeScope);\n            pnodeScope = pnodeScope->sxFnc.pnodeNext;\n            break;\n\n        case knopCatch:\n            VisitFunctionsInScope(pnodeScope->sxCatch.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            VisitFunctionsInScope(pnodeScope->sxWith.pnodeScopes, fn);\n            pnodeScope = pnodeScope->sxWith.pnodeNext;\n            break;\n\n        default:\n            AssertMsg(false, \"Unexpected node with scope list\");\n            return;\n        }\n    }\n}\n\n// Scripts above this size (minus string literals and comments) will have parsing of\n// function bodies deferred.\nULONG Parser::GetDeferralThreshold(bool isProfileLoaded)\n{\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (CONFIG_FLAG(ForceDeferParse) ||\n        PHASE_FORCE1(Js::DeferParsePhase) ||\n        Js::Configuration::Global.flags.IsEnabled(Js::ForceUndoDeferFlag))\n    {\n        return 0;\n    }\n    else if (Js::Configuration::Global.flags.IsEnabled(Js::DeferParseFlag))\n    {\n        return Js::Configuration::Global.flags.DeferParse;\n    }\n    else\n#endif\n    {\n        if (isProfileLoaded)\n        {\n            return DEFAULT_CONFIG_ProfileBasedDeferParseThreshold;\n        }\n        return DEFAULT_CONFIG_DeferParseThreshold;\n    }\n}\n\nvoid Parser::FinishDeferredFunction(ParseNodePtr pnodeScopeList)\n{\n    VisitFunctionsInScope(pnodeScopeList,\n        [this](ParseNodePtr pnodeFnc)\n    {\n        Assert(pnodeFnc->nop == knopFncDecl);\n\n        // Non-simple params (such as default) require a good amount of logic to put vars on appriopriate scopes. ParseFncDecl handles it\n        // properly (both on defer and non-defer case). This is to avoid write duplicated logic here as well. Function with non-simple-param\n        // will remain deferred untill they are called.\n        if (pnodeFnc->sxFnc.pnodeBody == nullptr && !pnodeFnc->sxFnc.HasNonSimpleParameterList())\n        {\n            // Go back and generate an AST for this function.\n            JS_ETW_INTERNAL(EventWriteJSCRIPT_PARSE_FUNC(this->GetScriptContext(), pnodeFnc->sxFnc.functionId, /*Undefer*/TRUE));\n\n            ParseNodePtr pnodeFncSave = this->m_currentNodeFunc;\n            this->m_currentNodeFunc = pnodeFnc;\n\n            ParseNodePtr pnodeFncExprBlock = nullptr;\n            if (pnodeFnc->sxFnc.pnodeName &&\n                !pnodeFnc->sxFnc.IsDeclaration())\n            {\n                // Set up the named function expression symbol so references inside the function can be bound.\n                ParseNodePtr pnodeName = pnodeFnc->sxFnc.pnodeName;\n                Assert(pnodeName->nop == knopVarDecl);\n                Assert(pnodeName->sxVar.pnodeNext == nullptr);\n\n                pnodeFncExprBlock = this->StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FuncExpr);\n                PidRefStack *ref = this->PushPidRef(pnodeName->sxVar.pid);\n                pnodeName->sxVar.symRef = ref->GetSymRef();\n                ref->SetSym(pnodeName->sxVar.sym);\n\n                Scope *fncExprScope = pnodeFncExprBlock->sxBlock.scope;\n                fncExprScope->AddNewSymbol(pnodeName->sxVar.sym);\n                pnodeFnc->sxFnc.scope = fncExprScope;\n            }\n\n            ParseNodePtr pnodeBlock = this->StartParseBlock<true>(PnodeBlockType::Parameter, ScopeType_Parameter);\n            pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n            // Add the args to the scope, since we won't re-parse those.\n            Scope *scope = pnodeBlock->sxBlock.scope;\n            auto addArgsToScope = [&](ParseNodePtr pnodeArg) {\n                if (pnodeArg->IsVarLetOrConst())\n                {\n                    PidRefStack *ref = this->PushPidRef(pnodeArg->sxVar.pid);\n                    pnodeArg->sxVar.symRef = ref->GetSymRef();\n                    if (ref->GetSym() != nullptr)\n                    {\n                        // Duplicate parameter in a configuration that allows them.\n                        // The symbol is already in the scope, just point it to the right declaration.\n                        Assert(ref->GetSym() == pnodeArg->sxVar.sym);\n                        ref->GetSym()->SetDecl(pnodeArg);\n                    }\n                    else\n                    {\n                        ref->SetSym(pnodeArg->sxVar.sym);\n                        scope->AddNewSymbol(pnodeArg->sxVar.sym);\n                    }\n                }\n            };\n            MapFormals(pnodeFnc, addArgsToScope);\n            MapFormalsFromPattern(pnodeFnc, addArgsToScope);\n\n            ParseNodePtr pnodeInnerBlock = this->StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n            pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n            // Set the parameter block's child to the function body block.\n            *m_ppnodeScope = pnodeInnerBlock;\n\n            ParseNodePtr *ppnodeScopeSave = nullptr;\n            ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n            ppnodeScopeSave = m_ppnodeScope;\n\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n            pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            ppnodeExprScopeSave = m_ppnodeExprScope;\n            m_ppnodeExprScope = nullptr;\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (scope != nullptr && !pnodeFnc->sxFnc.IsAsync())\n            {\n                if (scope->GetCanMergeWithBodyScope())\n                {\n                    scope->ForEachSymbol([this](Symbol* paramSym)\n                    {\n                        PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                        ref->SetSym(paramSym);\n                    });\n                }\n                else\n                {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                    // Add a new symbol reference for each formal in the param scope to the body scope.\n                    scope->ForEachSymbol([this](Symbol* param) {\n                        OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n                        ParseNodePtr paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                        paramNode->sxVar.sym->SetHasInit(true);\n                    });\n                }\n            }\n\n            Assert(m_currentNodeNonLambdaFunc == nullptr);\n            m_currentNodeNonLambdaFunc = pnodeFnc;\n\n            this->FinishFncNode(pnodeFnc);\n\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = nullptr;\n\n            m_ppnodeExprScope = ppnodeExprScopeSave;\n\n            AssertMem(m_ppnodeScope);\n            Assert(nullptr == *m_ppnodeScope);\n            m_ppnodeScope = ppnodeScopeSave;\n\n            this->FinishParseBlock(pnodeInnerBlock);\n\n            this->AddArgumentsNodeToVars(pnodeFnc);\n\n            this->FinishParseBlock(pnodeBlock);\n            if (pnodeFncExprBlock)\n            {\n                this->FinishParseBlock(pnodeFncExprBlock);\n            }\n\n            this->m_currentNodeFunc = pnodeFncSave;\n        }\n    });\n}\n\nvoid Parser::InitPids()\n{\n    AssertMemN(m_phtbl);\n    wellKnownPropertyPids.arguments = m_phtbl->PidHashNameLen(g_ssym_arguments.sz, g_ssym_arguments.cch);\n    wellKnownPropertyPids.async = m_phtbl->PidHashNameLen(g_ssym_async.sz, g_ssym_async.cch);\n    wellKnownPropertyPids.eval = m_phtbl->PidHashNameLen(g_ssym_eval.sz, g_ssym_eval.cch);\n    wellKnownPropertyPids.get = m_phtbl->PidHashNameLen(g_ssym_get.sz, g_ssym_get.cch);\n    wellKnownPropertyPids.set = m_phtbl->PidHashNameLen(g_ssym_set.sz, g_ssym_set.cch);\n    wellKnownPropertyPids.let = m_phtbl->PidHashNameLen(g_ssym_let.sz, g_ssym_let.cch);\n    wellKnownPropertyPids.constructor = m_phtbl->PidHashNameLen(g_ssym_constructor.sz, g_ssym_constructor.cch);\n    wellKnownPropertyPids.prototype = m_phtbl->PidHashNameLen(g_ssym_prototype.sz, g_ssym_prototype.cch);\n    wellKnownPropertyPids.__proto__ = m_phtbl->PidHashNameLen(_u(\"__proto__\"), sizeof(\"__proto__\") - 1);\n    wellKnownPropertyPids.of = m_phtbl->PidHashNameLen(_u(\"of\"), sizeof(\"of\") - 1);\n    wellKnownPropertyPids.target = m_phtbl->PidHashNameLen(_u(\"target\"), sizeof(\"target\") - 1);\n    wellKnownPropertyPids.as = m_phtbl->PidHashNameLen(_u(\"as\"), sizeof(\"as\") - 1);\n    wellKnownPropertyPids.from = m_phtbl->PidHashNameLen(_u(\"from\"), sizeof(\"from\") - 1);\n    wellKnownPropertyPids._default = m_phtbl->PidHashNameLen(_u(\"default\"), sizeof(\"default\") - 1);\n    wellKnownPropertyPids._starDefaultStar = m_phtbl->PidHashNameLen(_u(\"*default*\"), sizeof(\"*default*\") - 1);\n    wellKnownPropertyPids._star = m_phtbl->PidHashNameLen(_u(\"*\"), sizeof(\"*\") - 1);\n}\n\nvoid Parser::RestoreScopeInfo(Js::ParseableFunctionInfo* functionBody)\n{\n    if (!functionBody)\n    {\n        return;\n    }\n\n    Js::ScopeInfo* scopeInfo = functionBody->GetScopeInfo();\n    if (!scopeInfo)\n    {\n        return;\n    }\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n\n    RestoreScopeInfo(scopeInfo->GetParent()); // Recursively restore outer func scope info\n\n    Js::ScopeInfo* funcExprScopeInfo = scopeInfo->GetFuncExprScopeInfo();\n    if (funcExprScopeInfo)\n    {\n        funcExprScopeInfo->SetScopeId(m_nextBlockId);\n        ParseNodePtr pnodeFncExprScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Function, ScopeType_FuncExpr, funcExprScopeInfo->GetSymbolCount());\n        Scope *scope = pnodeFncExprScope->sxBlock.scope;\n        funcExprScopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n    }\n\n    Js::ScopeInfo* paramScopeInfo = scopeInfo->GetParamScopeInfo();\n    if (paramScopeInfo)\n    {\n        paramScopeInfo->SetScopeId(m_nextBlockId);\n        ParseNodePtr pnodeFncExprScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Parameter, ScopeType_Parameter, paramScopeInfo->GetSymbolCount());\n        Scope *scope = pnodeFncExprScope->sxBlock.scope;\n        paramScopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n    }\n\n    scopeInfo->SetScopeId(m_nextBlockId);\n    ParseNodePtr pnodeFncScope = nullptr;\n    if (scopeInfo->IsGlobalEval())\n    {\n        pnodeFncScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Regular, ScopeType_GlobalEvalBlock, scopeInfo->GetSymbolCount());\n    }\n    else\n    {\n        pnodeFncScope = StartParseBlockWithCapacity<true>(PnodeBlockType::Function, ScopeType_FunctionBody, scopeInfo->GetSymbolCount());\n    }\n    Scope *scope = pnodeFncScope->sxBlock.scope;\n    scopeInfo->GetScopeInfo(this, nullptr, nullptr, scope);\n}\n\nvoid Parser::FinishScopeInfo(Js::ParseableFunctionInfo *functionBody)\n{\n    if (!functionBody)\n    {\n        return;\n    }\n\n    Js::ScopeInfo* scopeInfo = functionBody->GetScopeInfo();\n    if (!scopeInfo)\n    {\n        return;\n    }\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackByteCodeVisitor);\n    }\n\n    int scopeId = scopeInfo->GetScopeId();\n\n    scopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n    {\n        this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n    });\n    PopScope(scopeInfo->GetScope());\n    PopStmt(&m_currentBlockInfo->pstmt);\n    PopBlockInfo();\n\n    Js::ScopeInfo *paramScopeInfo = scopeInfo->GetParamScopeInfo();\n    if (paramScopeInfo)\n    {\n        scopeId = paramScopeInfo->GetScopeId();\n        paramScopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n        {\n            this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n        });\n        PopScope(paramScopeInfo->GetScope());\n        PopStmt(&m_currentBlockInfo->pstmt);\n        PopBlockInfo();\n    }\n\n    Js::ScopeInfo *funcExprScopeInfo = scopeInfo->GetFuncExprScopeInfo();\n    if (funcExprScopeInfo)\n    {\n        scopeId = funcExprScopeInfo->GetScopeId();\n        funcExprScopeInfo->GetScope()->ForEachSymbol([this, scopeId](Symbol *sym)\n        {\n            this->BindPidRefsInScope(sym->GetPid(), sym, scopeId);\n        });\n        PopScope(funcExprScopeInfo->GetScope());\n        PopStmt(&m_currentBlockInfo->pstmt);\n        PopBlockInfo();\n    }\n\n    FinishScopeInfo(scopeInfo->GetParent());\n}\n\n/***************************************************************************\nParse the code.\n***************************************************************************/\nParseNodePtr Parser::Parse(LPCUTF8 pszSrc, size_t offset, size_t length, charcount_t charOffset, ULONG grfscr, ULONG lineNumber, Js::LocalFunctionId * nextFunctionId, CompileScriptException *pse)\n{\n    ParseNodePtr pnodeProg;\n    ParseNodePtr *lastNodeRef = nullptr;\n\n    m_nextBlockId = 0;\n\n    // Scanner should run in Running mode and not syntax coloring mode\n    grfscr &= ~fscrSyntaxColor;\n\n    if (this->m_scriptContext->IsScriptContextInDebugMode()\n#ifdef ENABLE_PREJIT\n         || Js::Configuration::Global.flags.Prejit\n#endif\n         || ((grfscr & fscrNoDeferParse) != 0)\n        )\n    {\n        // Don't do deferred parsing if debugger is attached or feature is disabled\n        // by command-line switch.\n        grfscr &= ~fscrDeferFncParse;\n    }\n    else if (!(grfscr & fscrGlobalCode) &&\n             (\n                 PHASE_OFF1(Js::Phase::DeferEventHandlersPhase) ||\n                 this->m_scriptContext->IsScriptContextInSourceRundownOrDebugMode()\n             )\n        )\n    {\n        // Don't defer event handlers in debug/rundown mode, because we need to register the document,\n        // so we need to create a full FunctionBody for the script body.\n        grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool isDeferred = (grfscr & fscrDeferredFnc) != 0;\n    bool isModuleSource = (grfscr & fscrIsModuleCode) != 0;\n\n    m_grfscr = grfscr;\n    m_length = length;\n    m_originalLength = length;\n    m_nextFunctionId = nextFunctionId;\n\n    if(m_parseType != ParseType_Deferred)\n    {\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_START(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), *m_nextFunctionId, 0, m_parseType, Js::Constants::GlobalFunction));\n        OUTPUT_TRACE(Js::DeferParsePhase, _u(\"Parsing function (%s) : %s (%d)\\n\"), GetParseType(), Js::Constants::GlobalFunction, *m_nextFunctionId);\n    }\n\n    // Give the scanner the source and get the first token\n    m_pscan->SetText(pszSrc, offset, length, charOffset, grfscr, lineNumber);\n    m_pscan->Scan();\n\n    // Make the main 'knopProg' node\n    int32 initSize = 0;\n    m_pCurrentAstSize = &initSize;\n    pnodeProg = CreateProgNodeWithScanner(isModuleSource);\n    pnodeProg->grfpn = PNodeFlags::fpnNone;\n    pnodeProg->sxFnc.pid = nullptr;\n    pnodeProg->sxFnc.pnodeName = nullptr;\n    pnodeProg->sxFnc.pnodeRest = nullptr;\n    pnodeProg->sxFnc.ClearFlags();\n    pnodeProg->sxFnc.SetNested(FALSE);\n    pnodeProg->sxFnc.astSize = 0;\n    pnodeProg->sxFnc.cbMin = m_pscan->IecpMinTok();\n    pnodeProg->sxFnc.lineNumber = lineNumber;\n    pnodeProg->sxFnc.columnNumber = 0;\n\n    if (!isDeferred || (isDeferred && grfscr & fscrGlobalCode))\n    {\n        // In the deferred case, if the global function is deferred parse (which is in no-refresh case),\n        // we will re-use the same function body, so start with the correct functionId.\n        pnodeProg->sxFnc.functionId = (*m_nextFunctionId)++;\n    }\n    else\n    {\n        pnodeProg->sxFnc.functionId = Js::Constants::NoFunctionId;\n    }\n\n    if (isModuleSource)\n    {\n        Assert(m_scriptContext->GetConfig()->IsES6ModuleEnabled());\n\n        pnodeProg->sxModule.localExportEntries = nullptr;\n        pnodeProg->sxModule.indirectExportEntries = nullptr;\n        pnodeProg->sxModule.starExportEntries = nullptr;\n        pnodeProg->sxModule.importEntries = nullptr;\n        pnodeProg->sxModule.requestedModules = nullptr;\n    }\n\n    m_pCurrentAstSize = & (pnodeProg->sxFnc.astSize);\n\n    pnodeProg->sxFnc.hint = nullptr;\n    pnodeProg->sxFnc.hintLength = 0;\n    pnodeProg->sxFnc.hintOffset = 0;\n    pnodeProg->sxFnc.isNameIdentifierRef = true;\n    pnodeProg->sxFnc.nestedFuncEscapes = false;\n\n    // initialize parsing variables\n    pnodeProg->sxFnc.pnodeNext = nullptr;\n\n    m_currentNodeFunc = nullptr;\n    m_currentNodeDeferredFunc = nullptr;\n    m_currentNodeProg = pnodeProg;\n    m_cactIdentToNodeLookup = 1;\n\n    pnodeProg->sxFnc.nestedCount = 0;\n    m_pnestedCount = &pnodeProg->sxFnc.nestedCount;\n    m_inDeferredNestedFunc = false;\n\n    pnodeProg->sxFnc.pnodeParams = nullptr;\n    pnodeProg->sxFnc.pnodeVars = nullptr;\n    pnodeProg->sxFnc.pnodeRest = nullptr;\n    m_ppnodeVar = &pnodeProg->sxFnc.pnodeVars;\n    SetCurrentStatement(nullptr);\n    AssertMsg(m_pstmtCur == nullptr, \"Statement stack should be empty when we start parse global code\");\n\n    // Create block for const's and let's\n    ParseNodePtr pnodeGlobalBlock = StartParseBlock<true>(PnodeBlockType::Global, ScopeType_Global);\n    pnodeProg->sxProg.scope = pnodeGlobalBlock->sxBlock.scope;\n    ParseNodePtr pnodeGlobalEvalBlock = nullptr;\n\n    // Don't track function expressions separately from declarations at global scope.\n    m_ppnodeExprScope = nullptr;\n\n    // This synthetic block scope will contain all the nested scopes.\n    pnodeProg->sxFnc.pnodeBodyScope = nullptr;\n    pnodeProg->sxFnc.pnodeScopes = pnodeGlobalBlock;\n    m_ppnodeScope = &pnodeGlobalBlock->sxBlock.pnodeScopes;\n\n    if ((this->m_grfscr & fscrEvalCode) &&\n        !(this->m_functionBody && this->m_functionBody->GetScopeInfo()))\n    {\n        pnodeGlobalEvalBlock = StartParseBlock<true>(PnodeBlockType::Regular, ScopeType_GlobalEvalBlock);\n        pnodeProg->sxFnc.pnodeScopes = pnodeGlobalEvalBlock;\n        m_ppnodeScope = &pnodeGlobalEvalBlock->sxBlock.pnodeScopes;\n    }\n\n    Js::ScopeInfo *scopeInfo = nullptr;\n    if (m_parseType == ParseType_Deferred && m_functionBody)\n    {\n        // this->m_functionBody can be cleared during parsing, but we need access to the scope info later.\n        scopeInfo = m_functionBody->GetScopeInfo();\n        if (scopeInfo)\n        {\n            // Create an enclosing function context.\n            m_currentNodeFunc = CreateNode(knopFncDecl);\n            m_currentNodeFunc->sxFnc.pnodeName = nullptr;\n            m_currentNodeFunc->sxFnc.functionId = m_functionBody->GetLocalFunctionId();\n            m_currentNodeFunc->sxFnc.nestedCount = m_functionBody->GetNestedCount();\n            m_currentNodeFunc->sxFnc.SetStrictMode(!!this->m_fUseStrictMode);\n\n            this->RestoreScopeInfo(scopeInfo->GetParent());\n        }\n    }\n\n    // It's possible for the module global to be defer-parsed in debug scenarios.\n    if (isModuleSource && (!isDeferred || (isDeferred && grfscr & fscrGlobalCode)))\n    {\n        ParseNodePtr moduleFunction = GenerateModuleFunctionWrapper<true>();\n        pnodeProg->sxFnc.pnodeBody = nullptr;\n        AddToNodeList(&pnodeProg->sxFnc.pnodeBody, &lastNodeRef, moduleFunction);\n    }\n    else\n    {\n        // Process a sequence of statements/declarations\n        ParseStmtList<true>(\n            &pnodeProg->sxFnc.pnodeBody,\n            &lastNodeRef,\n            SM_OnGlobalCode,\n            !(m_grfscr & fscrDeferredFncExpression) /* isSourceElementList */);\n    }\n\n    if (m_parseType == ParseType_Deferred)\n    {\n        if (scopeInfo)\n        {\n            this->FinishScopeInfo(scopeInfo->GetParent());\n        }\n    }\n\n    pnodeProg->sxProg.m_UsesArgumentsAtGlobal = m_UsesArgumentsAtGlobal;\n\n    if (IsStrictMode())\n    {\n        pnodeProg->sxFnc.SetStrictMode();\n    }\n\n#if DEBUG\n    if(m_grfscr & fscrEnforceJSON && !IsJSONValid(pnodeProg->sxFnc.pnodeBody))\n    {\n        Error(ERRsyntax);\n    }\n#endif\n\n    if (tkEOF != m_token.tk)\n        Error(ERRsyntax);\n\n    // Append an EndCode node.\n    AddToNodeList(&pnodeProg->sxFnc.pnodeBody, &lastNodeRef,\n        CreateNodeWithScanner<knopEndCode>());\n    AssertMem(lastNodeRef);\n    AssertNodeMem(*lastNodeRef);\n    Assert((*lastNodeRef)->nop == knopEndCode);\n    (*lastNodeRef)->ichMin = 0;\n    (*lastNodeRef)->ichLim = 0;\n\n    // Get the extent of the code.\n    pnodeProg->ichLim = m_pscan->IchLimTok();\n    pnodeProg->sxFnc.cbLim = m_pscan->IecpLimTok();\n\n    // Terminate the local list\n    *m_ppnodeVar = nullptr;\n\n    Assert(nullptr == *m_ppnodeScope);\n    Assert(nullptr == pnodeProg->sxFnc.pnodeNext);\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (Js::Configuration::Global.flags.IsEnabled(Js::ForceUndoDeferFlag))\n    {\n        m_stoppedDeferredParse = true;\n    }\n#endif\n\n    if (m_stoppedDeferredParse)\n    {\n        if (this->m_hasParallelJob)\n        {\n#if ENABLE_BACKGROUND_PARSING\n            BackgroundParser *bgp = static_cast<BackgroundParser*>(m_scriptContext->GetBackgroundParser());\n            Assert(bgp);\n            this->WaitForBackgroundJobs(bgp, pse);\n#endif\n        }\n\n        // Finally, see if there are any function bodies we now want to generate because we\n        // decided to stop deferring.\n        FinishDeferredFunction(pnodeProg->sxFnc.pnodeScopes);\n    }\n\n    if (pnodeGlobalEvalBlock)\n    {\n        FinishParseBlock(pnodeGlobalEvalBlock);\n    }\n    // Append block as body of pnodeProg\n    FinishParseBlock(pnodeGlobalBlock);\n\n    m_scriptContext->AddSourceSize(m_length);\n\n    if (m_parseType != ParseType_Deferred)\n    {\n        JS_ETW(EventWriteJSCRIPT_PARSE_METHOD_STOP(m_sourceContextInfo->dwHostSourceContext, GetScriptContext(), pnodeProg->sxFnc.functionId, *m_pCurrentAstSize, false, Js::Constants::GlobalFunction));\n    }\n    return pnodeProg;\n}\n\n\nbool Parser::CheckForDirective(bool* pIsUseStrict, bool *pIsUseAsm, bool* pIsOctalInString)\n{\n    // A directive is a string constant followed by a statement terminating token\n    if (m_token.tk != tkStrCon)\n        return false;\n\n    // Careful, need to check for octal before calling m_pscan->Scan()\n    // because Scan() clears the \"had octal\" flag on the scanner and\n    // m_pscan->Restore() does not restore this flag.\n    if (pIsOctalInString != nullptr)\n    {\n        *pIsOctalInString = m_pscan->IsOctOrLeadingZeroOnLastTKNumber();\n    }\n\n    Ident* pidDirective = m_token.GetStr();\n    RestorePoint start;\n    m_pscan->Capture(&start);\n    m_pscan->Scan();\n\n    bool isDirective = true;\n\n    switch (m_token.tk)\n    {\n    case tkSColon:\n    case tkEOF:\n    case tkLCurly:\n    case tkRCurly:\n        break;\n    default:\n        if (!m_pscan->FHadNewLine())\n        {\n            isDirective = false;\n        }\n        break;\n    }\n\n    if (isDirective)\n    {\n        if (pIsUseStrict != nullptr)\n        {\n            *pIsUseStrict = CheckStrictModeStrPid(pidDirective);\n        }\n        if (pIsUseAsm != nullptr)\n        {\n            *pIsUseAsm = CheckAsmjsModeStrPid(pidDirective);\n        }\n    }\n\n    m_pscan->SeekTo(start);\n    return isDirective;\n}\n\nbool Parser::CheckStrictModeStrPid(IdentPtr pid)\n{\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (Js::Configuration::Global.flags.NoStrictMode)\n        return false;\n#endif\n\n    return pid != nullptr &&\n        pid->Cch() == 10 &&\n        !m_pscan->IsEscapeOnLastTkStrCon() &&\n        wcsncmp(pid->Psz(), _u(\"use strict\"), 10) == 0;\n}\n\nbool Parser::CheckAsmjsModeStrPid(IdentPtr pid)\n{\n#ifdef ASMJS_PLAT\n    if (!CONFIG_FLAG_RELEASE(Asmjs))\n    {\n        return false;\n    }\n\n    bool isAsmCandidate = (pid != nullptr &&\n        AutoSystemInfo::Data.SSE2Available() &&\n        pid->Cch() == 7 &&\n        !m_pscan->IsEscapeOnLastTkStrCon() &&\n        wcsncmp(pid->Psz(), _u(\"use asm\"), 10) == 0);\n\n    if (isAsmCandidate && m_scriptContext->IsScriptContextInDebugMode())\n    {\n        // We would like to report this to debugger - they may choose to disable debugging.\n        // TODO : localization of the string?\n        m_scriptContext->RaiseMessageToDebugger(DEIT_ASMJS_IN_DEBUGGING, _u(\"AsmJs initialization error - AsmJs disabled due to script debugger\"), !m_sourceContextInfo->IsDynamic() ? m_sourceContextInfo->url : nullptr);\n        return false;\n    }\n\n    return isAsmCandidate && !(m_grfscr & fscrNoAsmJs);\n#else\n    return false;\n#endif\n}\n\nHRESULT Parser::ParseUtf8Source(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t length, ULONG grfsrc, CompileScriptException *pse,\n    Js::LocalFunctionId * nextFunctionId, SourceContextInfo * sourceContextInfo)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    return ParseSourceInternal( parseTree, pSrc, 0, length, 0, true, grfsrc, pse, nextFunctionId, 0, sourceContextInfo);\n}\n\nHRESULT Parser::ParseCesu8Source(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t length, ULONG grfsrc, CompileScriptException *pse,\n    Js::LocalFunctionId * nextFunctionId, SourceContextInfo * sourceContextInfo)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    return ParseSourceInternal( parseTree, pSrc, 0, length, 0, false, grfsrc, pse, nextFunctionId, 0, sourceContextInfo);\n}\n\nvoid Parser::PrepareScanner(bool fromExternal)\n{\n    // NOTE: HashTbl and Scanner are currently allocated from the CRT heap. If we want to allocate them from the\n    // parser arena, then we also need to change the way the HashTbl allocates PID's from its underlying\n    // allocator (which also currently uses the CRT heap). This is not trivial, because we still need to support\n    // heap allocation for the colorizer interface.\n\n    // create the hash table and init PID members\n    if (nullptr == (m_phtbl = HashTbl::Create(HASH_TABLE_SIZE, &m_err)))\n        Error(ERRnoMemory);\n    InitPids();\n\n    // create the scanner\n    if (nullptr == (m_pscan = Scanner_t::Create(this, m_phtbl, &m_token, &m_err, m_scriptContext)))\n        Error(ERRnoMemory);\n\n    if (fromExternal)\n        m_pscan->FromExternalSource();\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::PrepareForBackgroundParse()\n{\n    m_pscan->PrepareForBackgroundParse(m_scriptContext);\n}\n\nvoid Parser::AddBackgroundParseItem(BackgroundParseItem *const item)\n{\n    if (currBackgroundParseItem == nullptr)\n    {\n        backgroundParseItems = item;\n    }\n    else\n    {\n        currBackgroundParseItem->SetNext(item);\n    }\n    currBackgroundParseItem = item;\n}\n#endif\n\nvoid Parser::AddFastScannedRegExpNode(ParseNodePtr const pnode)\n{\n    Assert(!IsBackgroundParser());\n    Assert(m_doingFastScan);\n\n    if (fastScannedRegExpNodes == nullptr)\n    {\n        fastScannedRegExpNodes = Anew(&m_nodeAllocator, NodeDList, &m_nodeAllocator);\n    }\n    fastScannedRegExpNodes->Append(pnode);\n}\n\n#if ENABLE_BACKGROUND_PARSING\nvoid Parser::AddBackgroundRegExpNode(ParseNodePtr const pnode)\n{\n    Assert(IsBackgroundParser());\n    Assert(currBackgroundParseItem != nullptr);\n\n    currBackgroundParseItem->AddRegExpNode(pnode, &m_nodeAllocator);\n}\n#endif\n\nHRESULT Parser::ParseFunctionInBackground(ParseNodePtr pnodeFnc, ParseContext *parseContext, bool topLevelDeferred, CompileScriptException *pse)\n{\n    m_functionBody = nullptr;\n    m_parseType = ParseType_Upfront;\n    HRESULT hr = S_OK;\n    SmartFPUControl smartFpuControl;\n    uint nextFunctionId = pnodeFnc->sxFnc.functionId + 1;\n\n    this->RestoreContext(parseContext);\n    DebugOnly( m_err.fInited = TRUE; )\n    m_nextFunctionId = &nextFunctionId;\n    m_deferringAST = topLevelDeferred;\n    m_inDeferredNestedFunc = false;\n    m_scopeCountNoAst = 0;\n\n    SetCurrentStatement(nullptr);\n\n    pnodeFnc->sxFnc.pnodeVars = nullptr;\n    pnodeFnc->sxFnc.pnodeParams = nullptr;\n    pnodeFnc->sxFnc.pnodeBody = nullptr;\n    pnodeFnc->sxFnc.nestedCount = 0;\n\n    ParseNodePtr pnodeParentFnc = GetCurrentFunctionNode();\n    m_currentNodeFunc = pnodeFnc;\n    m_currentNodeDeferredFunc = nullptr;\n    m_ppnodeScope = nullptr;\n    m_ppnodeExprScope = nullptr;\n\n    m_pnestedCount = &pnodeFnc->sxFnc.nestedCount;\n    m_pCurrentAstSize = &pnodeFnc->sxFnc.astSize;\n\n    ParseNodePtr pnodeBlock = StartParseBlock<true>(PnodeBlockType::Function, ScopeType_FunctionBody);\n    pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n    m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n\n    try\n    {\n        m_pscan->Scan();\n\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n        this->ParseFncFormals<true>(pnodeFnc, pnodeParentFnc, fFncNoFlgs);\n\n        if (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n        }\n\n        ChkCurTok(tkLCurly, ERRnoLcurly);\n\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n        // Put the scanner into \"no hashing\" mode.\n        BYTE deferFlags = m_pscan->SetDeferredParse(topLevelDeferred);\n\n        // Process a sequence of statements/declarations\n        if (topLevelDeferred)\n        {\n            ParseStmtList<false>(nullptr, nullptr, SM_DeferredParse, true);\n        }\n        else\n        {\n            ParseNodePtr *lastNodeRef = nullptr;\n            ParseStmtList<true>(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, SM_OnFunctionCode, true);\n            AddArgumentsNodeToVars(pnodeFnc);\n            // Append an EndCode node.\n            AddToNodeList(&pnodeFnc->sxFnc.pnodeBody, &lastNodeRef, CreateNodeWithScanner<knopEndCode>());\n        }\n\n        // Restore the scanner's default hashing mode.\n        m_pscan->SetDeferredParseFlags(deferFlags);\n\n#if DBG\n        pnodeFnc->sxFnc.deferredParseNextFunctionId = *this->m_nextFunctionId;\n#endif\n        this->m_deferringAST = FALSE;\n\n        // Append block as body of pnodeProg\n        FinishParseBlock(pnodeBlock);\n    }\n    catch(ParseExceptionObject& e)\n    {\n        m_err.m_hr = e.GetError();\n        hr = pse->ProcessError( m_pscan, m_err.m_hr, nullptr);\n    }\n\n    if (IsStrictMode())\n    {\n        pnodeFnc->sxFnc.SetStrictMode();\n    }\n\n    if (topLevelDeferred)\n    {\n        pnodeFnc->sxFnc.pnodeVars = nullptr;\n    }\n\n    m_grfscr |= uDeferSave;\n\n    Assert(nullptr == *m_ppnodeScope);\n\n    return hr;\n}\n\nHRESULT Parser::ParseSourceWithOffset(__out ParseNodePtr* parseTree, LPCUTF8 pSrc, size_t offset, size_t cbLength, charcount_t cchOffset,\n        bool isCesu8, ULONG grfscr, CompileScriptException *pse, Js::LocalFunctionId * nextFunctionId, ULONG lineNumber, SourceContextInfo * sourceContextInfo,\n        Js::ParseableFunctionInfo* functionInfo)\n{\n    m_functionBody = functionInfo;\n    if (m_functionBody)\n    {\n        m_currDeferredStub = m_functionBody->GetDeferredStubs();\n        m_InAsmMode = grfscr & fscrNoAsmJs ? false : m_functionBody->GetIsAsmjsMode();\n    }\n    m_deferAsmJs = !m_InAsmMode;\n    m_parseType = ParseType_Deferred;\n    return ParseSourceInternal( parseTree, pSrc, offset, cbLength, cchOffset, !isCesu8, grfscr, pse, nextFunctionId, lineNumber, sourceContextInfo);\n}\n\nbool Parser::IsStrictMode() const\n{\n    return (m_fUseStrictMode ||\n           (m_currentNodeFunc != nullptr && m_currentNodeFunc->sxFnc.GetStrictMode()));\n}\n\nBOOL Parser::ExpectingExternalSource()\n{\n    return m_fExpectExternalSource;\n}\n\nSymbol *PnFnc::GetFuncSymbol()\n{\n    if (pnodeName &&\n        pnodeName->nop == knopVarDecl)\n    {\n        return pnodeName->sxVar.sym;\n    }\n    return nullptr;\n}\n\nvoid PnFnc::SetFuncSymbol(Symbol *sym)\n{\n    Assert(pnodeName &&\n           pnodeName->nop == knopVarDecl);\n    pnodeName->sxVar.sym = sym;\n}\n\nParseNodePtr PnFnc::GetParamScope() const\n{\n    if (this->pnodeScopes == nullptr)\n    {\n        return nullptr;\n    }\n    Assert(this->pnodeScopes->nop == knopBlock &&\n           this->pnodeScopes->sxBlock.pnodeNext == nullptr);\n    return this->pnodeScopes->sxBlock.pnodeScopes;\n}\n\nParseNodePtr PnFnc::GetBodyScope() const\n{\n    if (this->pnodeBodyScope == nullptr)\n    {\n        return nullptr;\n    }\n    Assert(this->pnodeBodyScope->nop == knopBlock &&\n           this->pnodeBodyScope->sxBlock.pnodeNext == nullptr);\n    return this->pnodeBodyScope->sxBlock.pnodeScopes;\n}\n\n// Create node versions with explicit token limits\nParseNodePtr Parser::CreateNode(OpCode nop, charcount_t ichMin, charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    Assert(nop >= 0 && nop < knopLim);\n    ParseNodePtr pnode;\n    __analysis_assume(nop < knopLim);\n    int cb = nop >= 0 && nop < knopLim ? g_mpnopcbNode[nop] : kcbPnNone;\n\n    pnode = (ParseNodePtr)m_nodeAllocator.Alloc(cb);\n    Assert(pnode);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += cb;\n\n    InitNode(nop,pnode);\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateNameNode(IdentPtr pid,charcount_t ichMin,charcount_t ichLim) {\n  ParseNodePtr pnode = CreateNodeT<knopName>(ichMin,ichLim);\n  pnode->sxPid.pid = pid;\n  pnode->sxPid.sym=NULL;\n  pnode->sxPid.symRef=NULL;\n  return pnode;\n}\n\nParseNodePtr Parser::CreateUniNode(OpCode nop, ParseNodePtr pnode1, charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnUni));\n\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnUni);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnUni;\n\n    InitNode(nop, pnode);\n\n    pnode->sxUni.pnode1 = pnode1;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateBinNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2,charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    ParseNodePtr pnode = StaticCreateBinNode(nop, pnode1, pnode2, &m_nodeAllocator);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnBin;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateTriNode(OpCode nop, ParseNodePtr pnode1,\n                                   ParseNodePtr pnode2, ParseNodePtr pnode3,\n                                   charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnTri));\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnTri);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnTri;\n\n    InitNode(nop, pnode);\n\n    pnode->sxTri.pnodeNext = NULL;\n    pnode->sxTri.pnode1 = pnode1;\n    pnode->sxTri.pnode2 = pnode2;\n    pnode->sxTri.pnode3 = pnode3;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}\n\nbool PnBlock::HasBlockScopedContent() const\n{\n    // A block has its own content if a let, const, or function is declared there.\n\n    if (this->pnodeLexVars != nullptr || this->blockType == Parameter)\n    {\n        return true;\n    }\n\n    // The enclosing scopes can contain functions and other things, so walk the list\n    // looking specifically for functions.\n\n    for (ParseNodePtr pnode = this->pnodeScopes; pnode;)\n    {\n        switch (pnode->nop) {\n\n        case knopFncDecl:\n            return true;\n\n        case knopBlock:\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n\n        case knopCatch:\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n\n        default:\n            Assert(UNREACHED);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nclass ByteCodeGenerator;\n\n// Copy AST; this works mostly on expressions for now\nParseNode* Parser::CopyPnode(ParseNode *pnode) {\n    if (pnode==NULL)\n        return NULL;\n    switch (pnode->nop) {\n        //PTNODE(knopName       , \"name\"        ,None    ,Pid  ,fnopLeaf)\n    case knopName: {\n      ParseNode* nameNode=CreateNameNode(pnode->sxPid.pid,pnode->ichMin,pnode->ichLim);\n      nameNode->sxPid.sym=pnode->sxPid.sym;\n      return nameNode;\n    }\n      //PTNODE(knopInt        , \"int const\"    ,None    ,Int  ,fnopLeaf|fnopConst)\n  case knopInt:\n    return pnode;\n      //PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n  case knopFlt:\n    return pnode;\n      //PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopStr:\n    return pnode;\n      //PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopRegExp:\n    return pnode;\n    break;\n      //PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n  case knopThis:\n    return CreateNodeT<knopThis>(pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n  case knopNull:\n    return pnode;\n      //PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n  case knopFalse:\n    {\n      ParseNode* ret = CreateNodeT<knopFalse>(pnode->ichMin, pnode->ichLim);\n      ret->location = pnode->location;\n      return ret;\n    }\n      //PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n  case knopTrue:\n    {\n        ParseNode* ret = CreateNodeT<knopTrue>(pnode->ichMin, pnode->ichLim);\n        ret->location = pnode->location;\n        return ret;\n    }\n      //PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n  case knopEmpty:\n    return CreateNodeT<knopEmpty>(pnode->ichMin,pnode->ichLim);\n      // Unary operators.\n      //PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n      //PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n      //PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n      //PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n      //PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni    , fnopUni)\n      //PTNODE(knopDecPost    , \"-- post\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopDecPre     , \"-- pre\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n      //PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n      //PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n      //PTNODE(knopDelete     , \"delete\"    ,None    ,Uni  ,fnopUni)\n  case knopNot:\n  case knopNeg:\n  case knopPos:\n  case knopLogNot:\n  case knopEllipsis:\n  case knopIncPost:\n  case knopDecPost:\n  case knopIncPre:\n  case knopDecPre:\n  case knopTypeof:\n  case knopVoid:\n  case knopDelete:\n    return CreateUniNode(pnode->nop,CopyPnode(pnode->sxUni.pnode1),pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n      //PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n  case knopArray:\n  case knopObject:\n    // TODO: need to copy arr\n    Assert(false);\n    break;\n      // Binary operators\n      //PTNODE(knopAdd        , \"+\"            ,Add     ,Bin  ,fnopBin)\n      //PTNODE(knopSub        , \"-\"            ,Sub     ,Bin  ,fnopBin)\n      //PTNODE(knopMul        , \"*\"            ,Mul     ,Bin  ,fnopBin)\n      //PTNODE(knopExpo       , \"**\"           ,Expo     ,Bin  ,fnopBin)\n      //PTNODE(knopDiv        , \"/\"            ,Div     ,Bin  ,fnopBin)\n      //PTNODE(knopMod        , \"%\"            ,Mod     ,Bin  ,fnopBin)\n      //PTNODE(knopOr         , \"|\"            ,BitOr   ,Bin  ,fnopBin)\n      //PTNODE(knopXor        , \"^\"            ,BitXor  ,Bin  ,fnopBin)\n      //PTNODE(knopAnd        , \"&\"            ,BitAnd  ,Bin  ,fnopBin)\n      //PTNODE(knopEq         , \"==\"        ,EQ      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopNe         , \"!=\"        ,NE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopLt         , \"<\"            ,LT      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopLe         , \"<=\"        ,LE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopGe         , \">=\"        ,GE      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopGt         , \">\"            ,GT      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopEqv        , \"===\"        ,Eqv     ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopIn         , \"in\"        ,In      ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopInstOf     , \"instanceof\",InstOf  ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopNEqv       , \"!==\"        ,NEqv    ,Bin  ,fnopBin|fnopRel)\n      //PTNODE(knopComma      , \",\"            ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopLsh        , \"<<\"        ,Lsh     ,Bin  ,fnopBin)\n      //PTNODE(knopRsh        , \">>\"        ,Rsh     ,Bin  ,fnopBin)\n      //PTNODE(knopRs2        , \">>>\"        ,Rs2     ,Bin  ,fnopBin)\n  case knopAdd:\n  case knopSub:\n  case knopMul:\n  case knopExpo:\n  case knopDiv:\n  case knopMod:\n  case knopOr:\n  case knopXor:\n  case knopAnd:\n  case knopEq:\n  case knopNe:\n  case knopLt:\n  case knopLe:\n  case knopGe:\n  case knopGt:\n  case knopEqv:\n  case knopIn:\n  case knopInstOf:\n  case knopNEqv:\n  case knopComma:\n  case knopLogOr:\n  case knopLogAnd:\n  case knopLsh:\n  case knopRsh:\n  case knopRs2:\n      //PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsg:\n      //PTNODE(knopDot        , \".\"            ,None    ,Bin  ,fnopBin)\n  case knopDot:\n      //PTNODE(knopAsgAdd     , \"+=\"        ,Add     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAdd:\n      //PTNODE(knopAsgSub     , \"-=\"        ,Sub     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgSub:\n      //PTNODE(knopAsgMul     , \"*=\"        ,Mul     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMul:\n      //PTNODE(knopAsgDiv     , \"/=\"        ,Div     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgExpo:\n      //PTNODE(knopAsgExpo    , \"**=\"       ,Expo    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgDiv:\n      //PTNODE(knopAsgMod     , \"%=\"        ,Mod     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMod:\n      //PTNODE(knopAsgAnd     , \"&=\"        ,BitAnd  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAnd:\n      //PTNODE(knopAsgXor     , \"^=\"        ,BitXor  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgXor:\n      //PTNODE(knopAsgOr      , \"|=\"        ,BitOr   ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgOr:\n      //PTNODE(knopAsgLsh     , \"<<=\"        ,Lsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgLsh:\n      //PTNODE(knopAsgRsh     , \">>=\"        ,Rsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRsh:\n      //PTNODE(knopAsgRs2     , \">>>=\"        ,Rs2     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRs2:\n      //PTNODE(knopMember     , \":\"            ,None    ,Bin  ,fnopBin)\n  case knopMember:\n  case knopMemberShort:\n      //PTNODE(knopIndex      , \"[]\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopList       , \"<list>\"    ,None    ,Bin  ,fnopNone)\n\n  case knopIndex:\n  case knopList:\n    return CreateBinNode(pnode->nop,CopyPnode(pnode->sxBin.pnode1),\n                         CopyPnode(pnode->sxBin.pnode2),pnode->ichMin,pnode->ichLim);\n\n      //PTNODE(knopCall       , \"()\"        ,None    ,Bin  ,fnopBin)\n      //PTNODE(knopNew        , \"new\"        ,None    ,Bin  ,fnopBin)\n  case knopNew:\n  case knopCall:\n    return CreateCallNode(pnode->nop,CopyPnode(pnode->sxCall.pnodeTarget),\n                         CopyPnode(pnode->sxCall.pnodeArgs),pnode->ichMin,pnode->ichLim);\n      //PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n  case knopQmark:\n    return CreateTriNode(pnode->nop,CopyPnode(pnode->sxTri.pnode1),\n                         CopyPnode(pnode->sxTri.pnode2),CopyPnode(pnode->sxTri.pnode3),\n                         pnode->ichMin,pnode->ichLim);\n      // General nodes.\n      //PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n    case knopVarDecl: {\n      ParseNode* copyNode=CreateNodeT<knopVarDecl>(pnode->ichMin,pnode->ichLim);\n      copyNode->sxVar.pnodeInit=CopyPnode(pnode->sxVar.pnodeInit);\n      copyNode->sxVar.sym=pnode->sxVar.sym;\n      // TODO: mult-decl\n      Assert(pnode->sxVar.pnodeNext==NULL);\n      copyNode->sxVar.pnodeNext=NULL;\n      return copyNode;\n    }\n      //PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n      //PTNODE(knopProg       , \"program\"    ,None    ,Fnc  ,fnopNone)\n  case knopFncDecl:\n  case knopProg:\n    Assert(false);\n    break;\n      //PTNODE(knopEndCode    , \"<endcode>\"    ,None    ,None ,fnopNone)\n  case knopEndCode:\n    break;\n      //PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n  case knopDebugger:\n    break;\n      //PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n    case knopFor: {\n      ParseNode* copyNode=CreateNodeT<knopFor>(pnode->ichMin,pnode->ichLim);\n      copyNode->sxFor.pnodeInverted=NULL;\n      copyNode->sxFor.pnodeInit=CopyPnode(pnode->sxFor.pnodeInit);\n      copyNode->sxFor.pnodeCond=CopyPnode(pnode->sxFor.pnodeCond);\n      copyNode->sxFor.pnodeIncr=CopyPnode(pnode->sxFor.pnodeIncr);\n      copyNode->sxFor.pnodeBody=CopyPnode(pnode->sxFor.pnodeBody);\n      return copyNode;\n    }\n      //PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n  case knopIf:\n    Assert(false);\n    break;\n      //PTNODE(knopWhile      , \"while\"        ,None    ,While,fnopBreak|fnopContinue)\n  case knopWhile:\n    Assert(false);\n    break;\n      //PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n  case knopDoWhile:\n    Assert(false);\n    break;\n      //PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n  case knopForIn:\n    Assert(false);\n    break;\n  case knopForOf:\n    Assert(false);\n    break;\n      //PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n  case knopReturn: {\n    ParseNode* copyNode=CreateNodeT<knopReturn>(pnode->ichMin,pnode->ichLim);\n    copyNode->sxReturn.pnodeExpr=CopyPnode(pnode->sxReturn.pnodeExpr);\n    return copyNode;\n  }\n      //PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n  case knopBlock: {\n    ParseNode* copyNode=CreateBlockNode(pnode->ichMin,pnode->ichLim,pnode->sxBlock.blockType);\n    if (pnode->grfpn & PNodeFlags::fpnSyntheticNode) {\n        // fpnSyntheticNode is sometimes set on PnodeBlockType::Regular blocks which\n        // CreateBlockNode() will not automatically set for us, so set it here if it's\n        // specified on the source node.\n        copyNode->grfpn |= PNodeFlags::fpnSyntheticNode;\n    }\n    copyNode->sxBlock.pnodeStmt=CopyPnode(pnode->sxBlock.pnodeStmt);\n    return copyNode;\n  }\n      //PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n  case knopWith:\n    Assert(false);\n    break;\n      //PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n  case knopBreak:\n    Assert(false);\n    break;\n      //PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n  case knopContinue:\n    Assert(false);\n    break;\n      //PTNODE(knopLabel      , \"label\"        ,None    ,Label,fnopNone)\n  case knopLabel:\n    Assert(false);\n    break;\n      //PTNODE(knopSwitch     , \"switch\"    ,None    ,Switch,fnopBreak)\n  case knopSwitch:\n    Assert(false);\n    break;\n      //PTNODE(knopCase       , \"case\"        ,None    ,Case ,fnopNone)\n  case knopCase:\n    Assert(false);\n    break;\n      //PTNODE(knopTryFinally,\"try-finally\",None,TryFinally,fnopCleanup)\n  case knopTryFinally:\n    Assert(false);\n    break;\n  case knopFinally:\n    Assert(false);\n    break;\n      //PTNODE(knopCatch      , \"catch\"     ,None    ,Catch,fnopNone)\n  case knopCatch:\n    Assert(false);\n    break;\n      //PTNODE(knopTryCatch      , \"try-catch\" ,None    ,TryCatch  ,fnopCleanup)\n  case knopTryCatch:\n    Assert(false);\n    break;\n      //PTNODE(knopTry        , \"try\"       ,None    ,Try  ,fnopCleanup)\n  case knopTry:\n    Assert(false);\n    break;\n      //PTNODE(knopThrow      , \"throw\"     ,None    ,Uni  ,fnopNone)\n  case knopThrow:\n    Assert(false);\n    break;\n  default:\n    Assert(false);\n    break;\n    }\n    return NULL;\n}\n\n// Returns true when str is string for Nan, Infinity or -Infinity.\n// Does not check for double number value being in NaN/Infinity range.\n// static\ntemplate<bool CheckForNegativeInfinity>\ninline bool Parser::IsNaNOrInfinityLiteral(LPCOLESTR str)\n{\n    // Note: wcscmp crashes when one of the parameters is NULL.\n    return str &&\n           (wcscmp(_u(\"NaN\"), str) == 0 ||\n           wcscmp(_u(\"Infinity\"), str) == 0 ||\n               (CheckForNegativeInfinity && wcscmp(_u(\"-Infinity\"), str) == 0));\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseSuper(ParseNodePtr pnode, bool fAllowCall)\n{\n    ParseNodePtr currentNodeFunc = GetCurrentFunctionNode();\n\n    if (buildAST) {\n        pnode = CreateNodeWithScanner<knopSuper>();\n    }\n\n    m_pscan->ScanForcingPid();\n\n    switch (m_token.tk)\n    {\n    case tkDot:     // super.prop\n    case tkLBrack:  // super[foo]\n    case tkLParen:  // super(args)\n        break;\n\n    default:\n        Error(ERRInvalidSuper);\n        break;\n    }\n\n    if (!fAllowCall && (m_token.tk == tkLParen))\n    {\n        Error(ERRInvalidSuper); // new super() is not allowed\n    }\n    else if (this->m_parsingSuperRestrictionState == ParsingSuperRestrictionState_SuperCallAndPropertyAllowed)\n    {\n        // Any super access is good within a class constructor\n    }\n    else if (this->m_parsingSuperRestrictionState == ParsingSuperRestrictionState_SuperPropertyAllowed)\n    {\n        if (m_token.tk == tkLParen)\n        {\n            if ((this->m_grfscr & fscrEval) == fscrNil)\n            {\n                // Cannot call super within a class member\n                Error(ERRInvalidSuper);\n            }\n            else\n            {\n                Js::JavascriptFunction * caller = nullptr;\n                if (Js::JavascriptStackWalker::GetCaller(&caller, m_scriptContext))\n                {\n                    Js::FunctionBody * callerBody = caller->GetFunctionBody();\n                    Assert(callerBody);\n                    if (!callerBody->GetFunctionInfo()->GetAllowDirectSuper())\n                    {\n                        Error(ERRInvalidSuper);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        // Anything else is an error\n        Error(ERRInvalidSuper);\n    }\n\n    currentNodeFunc->sxFnc.SetHasSuperReference(TRUE);\n    CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Super, m_scriptContext);\n    return pnode;\n}\n\nvoid Parser::AppendToList(ParseNodePtr *node, ParseNodePtr nodeToAppend)\n{\n    Assert(nodeToAppend);\n    ParseNodePtr* lastPtr = node;\n    while ((*lastPtr) && (*lastPtr)->nop == knopList)\n    {\n        lastPtr = &(*lastPtr)->sxBin.pnode2;\n    }\n    auto last = (*lastPtr);\n    if (last)\n    {\n        *lastPtr = CreateBinNode(knopList, last, nodeToAppend, last->ichMin, nodeToAppend->ichLim);\n    }\n    else\n    {\n        *lastPtr = nodeToAppend;\n    }\n}\n\nParseNodePtr Parser::ConvertArrayToArrayPattern(ParseNodePtr pnode)\n{\n    Assert(pnode->nop == knopArray);\n    pnode->nop = knopArrayPattern;\n\n    ForEachItemRefInList(&pnode->sxArrLit.pnode1, [&](ParseNodePtr *itemRef) {\n        ParseNodePtr item = *itemRef;\n        if (item->nop == knopEllipsis)\n        {\n            itemRef = &item->sxUni.pnode1;\n            item = *itemRef;\n            if (!(item->nop == knopName\n                  || item->nop == knopDot\n                  || item->nop == knopIndex\n                  || item->nop == knopArray\n                  || item->nop == knopObject))\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n        }\n        else if (item->nop == knopAsg)\n        {\n            itemRef = &item->sxBin.pnode1;\n            item = *itemRef;\n        }\n\n        if (item->nop == knopArray)\n        {\n            ConvertArrayToArrayPattern(item);\n        }\n        else if (item->nop == knopObject)\n        {\n            *itemRef = ConvertObjectToObjectPattern(item);\n        }\n        else if (item->nop == knopName)\n        {\n            TrackAssignment<true>(item, nullptr);\n        }\n    });\n\n    return pnode;\n}\n\nParseNodePtr Parser::CreateParamPatternNode(ParseNodePtr pnode1)\n{\n    ParseNodePtr paramPatternNode = CreateNode(knopParamPattern, pnode1->ichMin, pnode1->ichLim);\n    paramPatternNode->sxParamPattern.pnode1 = pnode1;\n    paramPatternNode->sxParamPattern.pnodeNext = nullptr;\n    paramPatternNode->sxParamPattern.location = Js::Constants::NoRegister;\n    return paramPatternNode;\n}\n\nParseNodePtr Parser::ConvertObjectToObjectPattern(ParseNodePtr pnodeMemberList)\n{\n    charcount_t ichMin = m_pscan->IchMinTok();\n    charcount_t ichLim = m_pscan->IchLimTok();\n    ParseNodePtr pnodeMemberNodeList = nullptr;\n    if (pnodeMemberList != nullptr && pnodeMemberList->nop == knopObject)\n    {\n        ichMin = pnodeMemberList->ichMin;\n        ichLim = pnodeMemberList->ichLim;\n        pnodeMemberList = pnodeMemberList->sxUni.pnode1;\n    }\n\n    ForEachItemInList(pnodeMemberList, [&](ParseNodePtr item) {\n        ParseNodePtr memberNode = ConvertMemberToMemberPattern(item);\n        AppendToList(&pnodeMemberNodeList, memberNode);\n    });\n\n    return CreateUniNode(knopObjectPattern, pnodeMemberNodeList, ichMin, ichLim);\n}\n\nParseNodePtr Parser::GetRightSideNodeFromPattern(ParseNodePtr pnode)\n{\n    Assert(pnode != nullptr);\n    ParseNodePtr rightNode = nullptr;\n    OpCode op = pnode->nop;\n    if (op == knopObject)\n    {\n        rightNode = ConvertObjectToObjectPattern(pnode);\n    }\n    else if (op == knopArray)\n    {\n        rightNode = ConvertArrayToArrayPattern(pnode);\n    }\n    else\n    {\n        rightNode = pnode;\n        if (op == knopName)\n        {\n            TrackAssignment<true>(pnode, nullptr);\n        }\n    }\n\n    return rightNode;\n}\n\nParseNodePtr Parser::ConvertMemberToMemberPattern(ParseNodePtr pnodeMember)\n{\n    if (pnodeMember->nop == knopObjectPatternMember)\n    {\n        return pnodeMember;\n    }\n\n    Assert(pnodeMember->nop == knopMember || pnodeMember->nop == knopMemberShort);\n\n    ParseNodePtr rightNode = GetRightSideNodeFromPattern(pnodeMember->sxBin.pnode2);\n    ParseNodePtr resultNode = CreateBinNode(knopObjectPatternMember, pnodeMember->sxBin.pnode1, rightNode);\n    resultNode->ichMin = pnodeMember->ichMin;\n    resultNode->ichLim = pnodeMember->ichLim;\n    return resultNode;\n}\n\nParseNodePtr Parser::ConvertToPattern(ParseNodePtr pnode)\n{\n    if (pnode != nullptr)\n    {\n        if (pnode->nop == knopArray)\n        {\n            ConvertArrayToArrayPattern(pnode);\n        }\n        else if (pnode->nop == knopObject)\n        {\n            pnode = ConvertObjectToObjectPattern(pnode);\n        }\n    }\n    return pnode;\n}\n\n// This essentially be called for verifying the structure of the current tree with satisfying the destructuring grammar.\nvoid Parser::ParseDestructuredLiteralWithScopeSave(tokens declarationType,\n    bool isDecl,\n    bool topLevel,\n    DestructuringInitializerContext initializerContext/* = DIC_None*/,\n    bool allowIn /*= true*/)\n{\n    // We are going to parse the text again to validate the current grammar as Destructuring. Saving some scopes and\n    // AST related information before the validation parsing and later they will be restored.\n\n    ParseNodePtr pnodeFncSave = m_currentNodeFunc;\n    ParseNodePtr pnodeDeferredFncSave = m_currentNodeDeferredFunc;\n    if (m_currentNodeDeferredFunc == nullptr)\n    {\n        m_currentNodeDeferredFunc = m_currentNodeFunc;\n    }\n    int32 *pAstSizeSave = m_pCurrentAstSize;\n    uint *pNestedCountSave = m_pnestedCount;\n    ParseNodePtr *ppnodeScopeSave = m_ppnodeScope;\n    ParseNodePtr *ppnodeExprScopeSave = m_ppnodeExprScope;\n\n    ParseNodePtr newTempScope = nullptr;\n    m_ppnodeScope = &newTempScope;\n\n    int32 newTempAstSize = 0;\n    m_pCurrentAstSize = &newTempAstSize;\n\n    uint newTempNestedCount = 0;\n    m_pnestedCount = &newTempNestedCount;\n\n    m_ppnodeExprScope = nullptr;\n\n    charcount_t funcInArraySave = m_funcInArray;\n    uint funcInArrayDepthSave = m_funcInArrayDepth;\n\n    // we need to reset this as we are going to parse the grammar again.\n    m_hasDeferredShorthandInitError = false;\n\n    ParseDestructuredLiteral<false>(declarationType, isDecl, topLevel, initializerContext, allowIn);\n\n    m_currentNodeFunc = pnodeFncSave;\n    m_currentNodeDeferredFunc = pnodeDeferredFncSave;\n    m_pCurrentAstSize = pAstSizeSave;\n    m_pnestedCount = pNestedCountSave;\n    m_ppnodeScope = ppnodeScopeSave;\n    m_ppnodeExprScope = ppnodeExprScopeSave;\n    m_funcInArray = funcInArraySave;\n    m_funcInArrayDepth = funcInArrayDepthSave;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredLiteral(tokens declarationType,\n    bool isDecl,\n    bool topLevel/* = true*/,\n    DestructuringInitializerContext initializerContext/* = DIC_None*/,\n    bool allowIn/* = true*/,\n    BOOL *forInOfOkay/* = nullptr*/,\n    BOOL *nativeForOkay/* = nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    Assert(IsPossiblePatternStart());\n    if (m_token.tk == tkLCurly)\n    {\n        pnode = ParseDestructuredObjectLiteral<buildAST>(declarationType, isDecl, topLevel);\n    }\n    else\n    {\n        pnode = ParseDestructuredArrayLiteral<buildAST>(declarationType, isDecl, topLevel);\n    }\n\n    return ParseDestructuredInitializer<buildAST>(pnode, isDecl, topLevel, initializerContext, allowIn, forInOfOkay, nativeForOkay);\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredInitializer(ParseNodePtr lhsNode,\n    bool isDecl,\n    bool topLevel,\n    DestructuringInitializerContext initializerContext,\n    bool allowIn,\n    BOOL *forInOfOkay,\n    BOOL *nativeForOkay)\n{\n    m_pscan->Scan();\n    if (topLevel && nativeForOkay == nullptr)\n    {\n        if (initializerContext != DIC_ForceErrorOnInitializer && m_token.tk != tkAsg)\n        {\n            // e.g. var {x};\n            Error(ERRDestructInit);\n        }\n        else if (initializerContext == DIC_ForceErrorOnInitializer && m_token.tk == tkAsg)\n        {\n            // e.g. catch([x] = [0])\n            Error(ERRDestructNotInit);\n        }\n    }\n\n    if (m_token.tk != tkAsg || initializerContext == DIC_ShouldNotParseInitializer)\n    {\n        if (topLevel && nativeForOkay != nullptr)\n        {\n            // Native loop should have destructuring initializer\n            *nativeForOkay = FALSE;\n        }\n\n        return lhsNode;\n    }\n\n    if (forInOfOkay)\n    {\n        *forInOfOkay = FALSE;\n    }\n\n    m_pscan->Scan();\n\n\n    bool alreadyHasInitError = m_hasDeferredShorthandInitError;\n\n    ParseNodePtr pnodeDefault = ParseExpr<buildAST>(koplCma, nullptr, allowIn);\n\n    if (m_hasDeferredShorthandInitError && !alreadyHasInitError)\n    {\n        Error(ERRnoColon);\n    }\n\n    ParseNodePtr pnodeDestructAsg = nullptr;\n    if (buildAST)\n    {\n        Assert(lhsNode != nullptr);\n\n        pnodeDestructAsg = CreateNodeWithScanner<knopAsg>();\n        pnodeDestructAsg->sxBin.pnode1 = lhsNode;\n        pnodeDestructAsg->sxBin.pnode2 = pnodeDefault;\n        pnodeDestructAsg->ichMin = lhsNode->ichMin;\n        pnodeDestructAsg->ichLim = pnodeDefault->ichLim;\n    }\n    return pnodeDestructAsg;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredObjectLiteral(tokens declarationType, bool isDecl, bool topLevel/* = true*/)\n{\n    Assert(m_token.tk == tkLCurly);\n    charcount_t ichMin = m_pscan->IchMinTok();\n    m_pscan->Scan();\n\n    if (!isDecl)\n    {\n        declarationType = tkLCurly;\n    }\n    ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(nullptr/*pNameHint*/, nullptr/*pHintLength*/, declarationType);\n    Assert(m_token.tk == tkRCurly);\n\n    ParseNodePtr objectPatternNode = nullptr;\n    if (buildAST)\n    {\n        charcount_t ichLim = m_pscan->IchLimTok();\n        objectPatternNode = CreateUniNode(knopObjectPattern, pnodeMemberList, ichMin, ichLim);\n    }\n    return objectPatternNode;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredVarDecl(tokens declarationType, bool isDecl, bool *hasSeenRest, bool topLevel/* = true*/, bool allowEmptyExpression/* = true*/)\n{\n    ParseNodePtr pnodeElem = nullptr;\n    int parenCount = 0;\n    bool seenRest = false;\n\n    // Save the Block ID prior to the increments, so we can restore it back.\n    int originalCurrentBlockId = GetCurrentBlock()->sxBlock.blockId;\n\n    // Eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkLParen)\n        {\n            m_pscan->Scan();\n            ++parenCount;\n\n            // Match the block increment we do upon entering parenthetical expressions\n            // so that the block ID's will match on reparsing of parameters.\n            GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n        }\n    }\n\n    if (m_token.tk == tkEllipsis)\n    {\n        // As per ES 2015 : Rest can have left-hand-side-expression when on assignment expression, but under declaration only binding identifier is allowed\n        // But spec is going to change for this one to allow LHS-expression both on expression and declaration - so making that happen early.\n\n        seenRest = true;\n        m_pscan->Scan();\n\n        // Eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early.\n        if (!isDecl)\n        {\n            while (m_token.tk == tkLParen)\n            {\n                m_pscan->Scan();\n                ++parenCount;\n\n                // Match the block increment we do upon entering parenthetical expressions\n                // so that the block ID's will match on reparsing of parameters.\n                GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n            }\n        }\n\n        if (m_token.tk != tkID && m_token.tk != tkSUPER && m_token.tk != tkLCurly && m_token.tk != tkLBrack)\n        {\n            if (isDecl)\n            {\n                Error(ERRnoIdent);\n            }\n            else\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n        }\n    }\n\n    if (IsPossiblePatternStart())\n    {\n        // Go recursively\n        pnodeElem = ParseDestructuredLiteral<buildAST>(declarationType, isDecl, false /*topLevel*/, seenRest ? DIC_ShouldNotParseInitializer : DIC_None);\n        if (!isDecl)\n        {\n            BOOL fCanAssign;\n            IdentToken token;\n            // Look for postfix operator\n            pnodeElem = ParsePostfixOperators<buildAST>(pnodeElem, TRUE, FALSE, FALSE, &fCanAssign, &token);\n        }\n    }\n    else if (m_token.tk == tkSUPER || m_token.tk == tkID)\n    {\n        if (isDecl)\n        {\n            charcount_t ichMin = m_pscan->IchMinTok();\n            pnodeElem = ParseVariableDeclaration<buildAST>(declarationType, ichMin\n                ,/* fAllowIn */false, /* pfForInOk */nullptr, /* singleDefOnly */true, /* allowInit */!seenRest, false /*topLevelParse*/);\n\n        }\n        else\n        {\n            BOOL fCanAssign;\n            IdentToken token;\n            // We aren't declaring anything, so scan the ID reference manually.\n            pnodeElem = ParseTerm<buildAST>(/* fAllowCall */ m_token.tk != tkSUPER, nullptr /*pNameHint*/, nullptr /*pHintLength*/, nullptr /*pShortNameOffset*/, &token, false,\n                                                             &fCanAssign);\n\n            // In this destructuring case we can force error here as we cannot assign.\n\n            if (!fCanAssign)\n            {\n                Error(ERRInvalidAssignmentTarget);\n            }\n\n            if (buildAST)\n            {\n                if (IsStrictMode() && pnodeElem != nullptr && pnodeElem->nop == knopName)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeElem->sxPid.pid);\n                }\n            }\n            else\n            {\n                if (IsStrictMode() && token.tk == tkID)\n                {\n                    CheckStrictModeEvalArgumentsUsage(token.pid);\n                }\n                token.tk = tkNone;\n            }\n        }\n    }\n    else if (!((m_token.tk == tkComma || m_token.tk == tkRBrack || m_token.tk == tkRCurly) && allowEmptyExpression))\n    {\n        if (m_token.IsOperator())\n        {\n            Error(ERRDestructNoOper);\n        }\n        Error(ERRDestructIDRef);\n    }\n\n    // Swallow RParens before a default expression, if any.\n    // We eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early. We need to do the same for right parentheses.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n            --parenCount;\n        }\n    }\n\n    if (hasSeenRest != nullptr)\n    {\n        *hasSeenRest = seenRest;\n    }\n\n    if (m_token.tk == tkAsg)\n    {\n        // Parse the initializer.\n        if (seenRest)\n        {\n            Error(ERRRestWithDefault);\n        }\n        m_pscan->Scan();\n\n        bool alreadyHasInitError = m_hasDeferredShorthandInitError;\n        ParseNodePtr pnodeInit = ParseExpr<buildAST>(koplCma);\n\n        if (m_hasDeferredShorthandInitError && !alreadyHasInitError)\n        {\n            Error(ERRnoColon);\n        }\n\n        if (buildAST)\n        {\n            pnodeElem = CreateBinNode(knopAsg, pnodeElem, pnodeInit);\n        }\n    }\n\n    if (buildAST && seenRest)\n    {\n        ParseNodePtr pnodeRest = CreateNodeWithScanner<knopEllipsis>();\n        pnodeRest->sxUni.pnode1 = pnodeElem;\n        pnodeElem = pnodeRest;\n    }\n\n    // We eat the left parentheses only when its not a declaration. This will make sure we throw syntax errors early. We need to do the same for right parentheses.\n    if (!isDecl)\n    {\n        while (m_token.tk == tkRParen)\n        {\n            m_pscan->Scan();\n            --parenCount;\n        }\n\n        // Restore the Block ID of the current block after the parsing of destructured variable declarations and initializers.\n        GetCurrentBlock()->sxBlock.blockId = originalCurrentBlockId;\n    }\n\n    if (!(m_token.tk == tkComma || m_token.tk == tkRBrack || m_token.tk == tkRCurly))\n    {\n        if (m_token.IsOperator())\n        {\n            Error(ERRDestructNoOper);\n        }\n        Error(ERRsyntax);\n    }\n\n    if (parenCount != 0)\n    {\n        Error(ERRnoRparen);\n    }\n    return pnodeElem;\n}\n\ntemplate <bool buildAST>\nParseNodePtr Parser::ParseDestructuredArrayLiteral(tokens declarationType, bool isDecl, bool topLevel)\n{\n    Assert(m_token.tk == tkLBrack);\n    charcount_t ichMin = m_pscan->IchMinTok();\n\n    m_pscan->Scan();\n\n    ParseNodePtr pnodeDestructArr = nullptr;\n    ParseNodePtr pnodeList = nullptr;\n    ParseNodePtr *lastNodeRef = nullptr;\n    uint count = 0;\n    bool hasMissingValues = false;\n    bool seenRest = false;\n\n    if (m_token.tk != tkRBrack)\n    {\n        while (true)\n        {\n            ParseNodePtr pnodeElem = ParseDestructuredVarDecl<buildAST>(declarationType, isDecl, &seenRest, topLevel);\n            if (buildAST)\n            {\n                if (pnodeElem == nullptr && buildAST)\n                {\n                    pnodeElem = CreateNodeWithScanner<knopEmpty>();\n                    hasMissingValues = true;\n                }\n                AddToNodeListEscapedUse(&pnodeList, &lastNodeRef, pnodeElem);\n            }\n            count++;\n\n            if (m_token.tk == tkRBrack)\n            {\n                break;\n            }\n\n            if (m_token.tk != tkComma)\n            {\n                Error(ERRDestructNoOper);\n            }\n\n            if (seenRest) // Rest must be in the last position.\n            {\n                Error(ERRDestructRestLast);\n            }\n\n            m_pscan->Scan();\n\n            // break if we have the trailing comma as well, eg. [a,]\n            if (m_token.tk == tkRBrack)\n            {\n                break;\n            }\n        }\n    }\n\n    if (buildAST)\n    {\n        pnodeDestructArr = CreateNodeWithScanner<knopArrayPattern>();\n        pnodeDestructArr->sxArrLit.pnode1 = pnodeList;\n        pnodeDestructArr->sxArrLit.arrayOfTaggedInts = false;\n        pnodeDestructArr->sxArrLit.arrayOfInts = false;\n        pnodeDestructArr->sxArrLit.arrayOfNumbers = false;\n        pnodeDestructArr->sxArrLit.hasMissingValues = hasMissingValues;\n        pnodeDestructArr->sxArrLit.count = count;\n        pnodeDestructArr->sxArrLit.spreadCount = seenRest ? 1 : 0;\n        pnodeDestructArr->ichMin = ichMin;\n        pnodeDestructArr->ichLim = m_pscan->IchLimTok();\n\n        if (pnodeDestructArr->sxArrLit.pnode1)\n        {\n            this->CheckArguments(pnodeDestructArr->sxArrLit.pnode1);\n        }\n    }\n\n    return pnodeDestructArr;\n}\n\nvoid Parser::CaptureContext(ParseContext *parseContext) const\n{\n    parseContext->pszSrc = m_pscan->PchBase();\n    parseContext->length = this->m_originalLength;\n    parseContext->characterOffset = m_pscan->IchMinTok();\n    parseContext->offset = parseContext->characterOffset + m_pscan->m_cMultiUnits;\n    parseContext->grfscr = this->m_grfscr;\n    parseContext->lineNumber = m_pscan->LineCur();\n\n    parseContext->pnodeProg = this->m_currentNodeProg;\n    parseContext->fromExternal = m_pscan->IsFromExternalSource();\n    parseContext->strictMode = this->IsStrictMode();\n    parseContext->sourceContextInfo = this->m_sourceContextInfo;\n    parseContext->currentBlockInfo = this->m_currentBlockInfo;\n    parseContext->nextBlockId = this->m_nextBlockId;\n}\n\nvoid Parser::RestoreContext(ParseContext *const parseContext)\n{\n    m_sourceContextInfo = parseContext->sourceContextInfo;\n    m_currentBlockInfo = parseContext->currentBlockInfo;\n    m_nextBlockId = parseContext->nextBlockId;\n    m_grfscr = parseContext->grfscr;\n    m_length = parseContext->length;\n    m_pscan->SetText(parseContext->pszSrc, parseContext->offset, parseContext->length, parseContext->characterOffset, parseContext->grfscr, parseContext->lineNumber);\n    m_currentNodeProg = parseContext->pnodeProg;\n    m_fUseStrictMode = parseContext->strictMode;\n}\n\nclass ByteCodeGenerator;\n#if DBG_DUMP\n\n#define INDENT_SIZE 2\n\nvoid PrintPnodeListWIndent(ParseNode *pnode,int indentAmt);\nvoid PrintFormalsWIndent(ParseNode *pnode, int indentAmt);\n\n\nvoid Indent(int indentAmt) {\n    for (int i=0;i<indentAmt;i++) {\n        Output::Print(_u(\" \"));\n    }\n}\n\nvoid PrintBlockType(PnodeBlockType type)\n{\n    switch (type)\n    {\n    case Global:\n        Output::Print(_u(\"(Global)\"));\n        break;\n    case Function:\n        Output::Print(_u(\"(Function)\"));\n        break;\n    case Regular:\n        Output::Print(_u(\"(Regular)\"));\n        break;\n    case Parameter:\n        Output::Print(_u(\"(Parameter)\"));\n        break;\n    default:\n        Output::Print(_u(\"(unknown blocktype)\"));\n        break;\n    }\n}\n\nvoid PrintScopesWIndent(ParseNode *pnode,int indentAmt) {\n    ParseNode *scope = nullptr;\n    bool firstOnly = false;\n    switch(pnode->nop)\n    {\n    case knopProg:\n    case knopFncDecl: scope = pnode->sxFnc.pnodeScopes; break;\n    case knopBlock: scope = pnode->sxBlock.pnodeScopes; break;\n    case knopCatch: scope = pnode->sxCatch.pnodeScopes; break;\n    case knopWith: scope = pnode->sxWith.pnodeScopes; break;\n    case knopSwitch: scope = pnode->sxSwitch.pnodeBlock; firstOnly = true; break;\n    case knopFor: scope = pnode->sxFor.pnodeBlock; firstOnly = true; break;\n    case knopForIn: scope = pnode->sxForInOrForOf.pnodeBlock; firstOnly = true; break;\n    case knopForOf: scope = pnode->sxForInOrForOf.pnodeBlock; firstOnly = true; break;\n    }\n    if (scope) {\n        Output::Print(_u(\"[%4d, %4d): \"), scope->ichMin, scope->ichLim);\n        Indent(indentAmt);\n        Output::Print(_u(\"Scopes: \"));\n        ParseNode *next = nullptr;\n        ParseNode *syntheticBlock = nullptr;\n        while (scope) {\n            switch (scope->nop) {\n            case knopFncDecl: Output::Print(_u(\"knopFncDecl\")); next = scope->sxFnc.pnodeNext; break;\n            case knopBlock: Output::Print(_u(\"knopBlock\")); PrintBlockType(scope->sxBlock.blockType); next = scope->sxBlock.pnodeNext; break;\n            case knopCatch: Output::Print(_u(\"knopCatch\")); next = scope->sxCatch.pnodeNext; break;\n            case knopWith: Output::Print(_u(\"knopWith\")); next = scope->sxWith.pnodeNext; break;\n            default: Output::Print(_u(\"unknown\")); break;\n            }\n            if (firstOnly) {\n                next = nullptr;\n                syntheticBlock = scope;\n            }\n            if (scope->grfpn & fpnSyntheticNode) {\n                Output::Print(_u(\" synthetic\"));\n                if (scope->nop == knopBlock)\n                    syntheticBlock = scope;\n            }\n            Output::Print(_u(\" (%d-%d)\"), scope->ichMin, scope->ichLim);\n            if (next) Output::Print(_u(\", \"));\n            scope = next;\n        }\n        Output::Print(_u(\"\\n\"));\n        if (syntheticBlock || firstOnly) {\n            PrintScopesWIndent(syntheticBlock, indentAmt + INDENT_SIZE);\n        }\n    }\n}\n\nvoid PrintPnodeWIndent(ParseNode *pnode,int indentAmt) {\n    if (pnode==NULL)\n        return;\n\n    Output::Print(_u(\"[%4d, %4d): \"), pnode->ichMin, pnode->ichLim);\n    switch (pnode->nop) {\n        //PTNODE(knopName       , \"name\"        ,None    ,Pid  ,fnopLeaf)\n  case knopName:\n      Indent(indentAmt);\n      if (pnode->sxPid.pid!=NULL) {\n        Output::Print(_u(\"id: %s\\n\"),pnode->sxPid.pid->Psz());\n      }\n      else {\n        Output::Print(_u(\"name node\\n\"));\n      }\n      break;\n      //PTNODE(knopInt        , \"int const\"    ,None    ,Int  ,fnopLeaf|fnopConst)\n  case knopInt:\n      Indent(indentAmt);\n      Output::Print(_u(\"%d\\n\"),pnode->sxInt.lw);\n      break;\n      //PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n  case knopFlt:\n      Indent(indentAmt);\n      Output::Print(_u(\"%lf\\n\"),pnode->sxFlt.dbl);\n      break;\n      //PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopStr:\n      Indent(indentAmt);\n      Output::Print(_u(\"\\\"%s\\\"\\n\"),pnode->sxPid.pid->Psz());\n      break;\n      //PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n  case knopRegExp:\n      Indent(indentAmt);\n      Output::Print(_u(\"/%x/\\n\"),pnode->sxPid.regexPattern);\n      break;\n      //PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n  case knopThis:\n      Indent(indentAmt);\n      Output::Print(_u(\"this\\n\"));\n      break;\n      //PTNODE(knopSuper      , \"super\"       ,None    ,None ,fnopLeaf)\n  case knopSuper:\n      Indent(indentAmt);\n      Output::Print(_u(\"super\\n\"));\n      break;\n      //PTNODE(knopNewTarget  , \"new.target\"  ,None    ,None ,fnopLeaf)\n  case knopNewTarget:\n      Indent(indentAmt);\n      Output::Print(_u(\"new.target\\n\"));\n      break;\n      //PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n  case knopNull:\n      Indent(indentAmt);\n      Output::Print(_u(\"null\\n\"));\n      break;\n      //PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n  case knopFalse:\n      Indent(indentAmt);\n      Output::Print(_u(\"false\\n\"));\n      break;\n      //PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n  case knopTrue:\n      Indent(indentAmt);\n      Output::Print(_u(\"true\\n\"));\n      break;\n      //PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n  case knopEmpty:\n      Indent(indentAmt);\n      Output::Print(_u(\"empty\\n\"));\n      break;\n      // Unary operators.\n      //PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n  case knopNot:\n      Indent(indentAmt);\n      Output::Print(_u(\"~\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n  case knopNeg:\n      Indent(indentAmt);\n      Output::Print(_u(\"U-\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n  case knopPos:\n      Indent(indentAmt);\n      Output::Print(_u(\"U+\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n  case knopLogNot:\n      Indent(indentAmt);\n      Output::Print(_u(\"!\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni    , fnopUni)\n  case knopEllipsis:\n      Indent(indentAmt);\n      Output::Print(_u(\"...<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIncPost    , \"++ post\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n  case knopIncPost:\n      Indent(indentAmt);\n      Output::Print(_u(\"<expr>++\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDecPost    , \"-- post\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n  case knopDecPost:\n      Indent(indentAmt);\n      Output::Print(_u(\"<expr>--\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n  case knopIncPre:\n      Indent(indentAmt);\n      Output::Print(_u(\"++<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDecPre     , \"-- pre\"    ,Dec     ,Uni  ,fnopUni|fnopAsg)\n  case knopDecPre:\n      Indent(indentAmt);\n      Output::Print(_u(\"--<expr>\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n  case knopTypeof:\n      Indent(indentAmt);\n      Output::Print(_u(\"typeof\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n  case knopVoid:\n      Indent(indentAmt);\n      Output::Print(_u(\"void\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDelete     , \"delete\"    ,None    ,Uni  ,fnopUni)\n  case knopDelete:\n      Indent(indentAmt);\n      Output::Print(_u(\"delete\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n\n  case knopArrayPattern:\n      Indent(indentAmt);\n      Output::Print(_u(\"Array Pattern\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n  case knopObjectPattern:\n      Indent(indentAmt);\n      Output::Print(_u(\"Object Pattern\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n  case knopArray:\n      Indent(indentAmt);\n      Output::Print(_u(\"Array Literal\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n  case knopObject:\n      Indent(indentAmt);\n      Output::Print(_u(\"Object Literal\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      // Binary and Ternary Operators\n      //PTNODE(knopAdd        , \"+\"            ,Add     ,Bin  ,fnopBin)\n  case knopAdd:\n      Indent(indentAmt);\n      Output::Print(_u(\"+\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopSub        , \"-\"            ,Sub     ,Bin  ,fnopBin)\n  case knopSub:\n      Indent(indentAmt);\n      Output::Print(_u(\"-\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopMul        , \"*\"            ,Mul     ,Bin  ,fnopBin)\n  case knopMul:\n      Indent(indentAmt);\n      Output::Print(_u(\"*\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDiv        , \"/\"            ,Div     ,Bin  ,fnopBin)\n  case knopExpo:\n      Indent(indentAmt);\n      Output::Print(_u(\"**\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2, indentAmt + INDENT_SIZE);\n      break;\n      //PTNODE(knopExpo        , \"**\"            ,Expo     ,Bin  ,fnopBin)\n\n  case knopDiv:\n      Indent(indentAmt);\n      Output::Print(_u(\"/\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopMod        , \"%\"            ,Mod     ,Bin  ,fnopBin)\n  case knopMod:\n      Indent(indentAmt);\n      Output::Print(_u(\"%\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopOr         , \"|\"            ,BitOr   ,Bin  ,fnopBin)\n  case knopOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"|\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopXor        , \"^\"            ,BitXor  ,Bin  ,fnopBin)\n  case knopXor:\n      Indent(indentAmt);\n      Output::Print(_u(\"^\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAnd        , \"&\"            ,BitAnd  ,Bin  ,fnopBin)\n  case knopAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEq         , \"==\"        ,EQ      ,Bin  ,fnopBin|fnopRel)\n  case knopEq:\n      Indent(indentAmt);\n      Output::Print(_u(\"==\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNe         , \"!=\"        ,NE      ,Bin  ,fnopBin|fnopRel)\n  case knopNe:\n      Indent(indentAmt);\n      Output::Print(_u(\"!=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLt         , \"<\"            ,LT      ,Bin  ,fnopBin|fnopRel)\n  case knopLt:\n      Indent(indentAmt);\n      Output::Print(_u(\"<\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLe         , \"<=\"        ,LE      ,Bin  ,fnopBin|fnopRel)\n  case knopLe:\n      Indent(indentAmt);\n      Output::Print(_u(\"<=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopGe         , \">=\"        ,GE      ,Bin  ,fnopBin|fnopRel)\n  case knopGe:\n      Indent(indentAmt);\n      Output::Print(_u(\">=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopGt         , \">\"            ,GT      ,Bin  ,fnopBin|fnopRel)\n  case knopGt:\n      Indent(indentAmt);\n      Output::Print(_u(\">\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopCall       , \"()\"        ,None    ,Bin  ,fnopBin)\n  case knopCall:\n      Indent(indentAmt);\n      Output::Print(_u(\"Call\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDot        , \".\"            ,None    ,Bin  ,fnopBin)\n  case knopDot:\n      Indent(indentAmt);\n      Output::Print(_u(\".\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n  case knopAsg:\n      Indent(indentAmt);\n      Output::Print(_u(\"=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopInstOf     , \"instanceof\",InstOf  ,Bin  ,fnopBin|fnopRel)\n  case knopInstOf:\n      Indent(indentAmt);\n      Output::Print(_u(\"instanceof\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIn         , \"in\"        ,In      ,Bin  ,fnopBin|fnopRel)\n  case knopIn:\n      Indent(indentAmt);\n      Output::Print(_u(\"in\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEqv        , \"===\"        ,Eqv     ,Bin  ,fnopBin|fnopRel)\n  case knopEqv:\n      Indent(indentAmt);\n      Output::Print(_u(\"===\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNEqv       , \"!==\"        ,NEqv    ,Bin  ,fnopBin|fnopRel)\n  case knopNEqv:\n      Indent(indentAmt);\n      Output::Print(_u(\"!==\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopComma      , \",\"            ,None    ,Bin  ,fnopBin)\n  case knopComma:\n      Indent(indentAmt);\n      Output::Print(_u(\",\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n  case knopLogOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"||\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n  case knopLogAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&&\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopLsh        , \"<<\"        ,Lsh     ,Bin  ,fnopBin)\n  case knopLsh:\n      Indent(indentAmt);\n      Output::Print(_u(\"<<\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopRsh        , \">>\"        ,Rsh     ,Bin  ,fnopBin)\n  case knopRsh:\n      Indent(indentAmt);\n      Output::Print(_u(\">>\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopRs2        , \">>>\"        ,Rs2     ,Bin  ,fnopBin)\n  case knopRs2:\n      Indent(indentAmt);\n      Output::Print(_u(\">>>\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopNew        , \"new\"        ,None    ,Bin  ,fnopBin)\n  case knopNew:\n      Indent(indentAmt);\n      Output::Print(_u(\"new\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIndex      , \"[]\"        ,None    ,Bin  ,fnopBin)\n  case knopIndex:\n      Indent(indentAmt);\n      Output::Print(_u(\"[]\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n  case knopQmark:\n      Indent(indentAmt);\n      Output::Print(_u(\"?:\\n\"));\n      PrintPnodeWIndent(pnode->sxTri.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxTri.pnode2,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxTri.pnode3,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgAdd     , \"+=\"        ,Add     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAdd:\n      Indent(indentAmt);\n      Output::Print(_u(\"+=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgSub     , \"-=\"        ,Sub     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgSub:\n      Indent(indentAmt);\n      Output::Print(_u(\"-=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgMul     , \"*=\"        ,Mul     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMul:\n      Indent(indentAmt);\n      Output::Print(_u(\"*=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgDiv     , \"/=\"        ,Div     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgExpo:\n      Indent(indentAmt);\n      Output::Print(_u(\"**=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2, indentAmt + INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgExpo     , \"**=\"       ,Expo     ,Bin  ,fnopBin|fnopAsg)\n\n  case knopAsgDiv:\n      Indent(indentAmt);\n      Output::Print(_u(\"/=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgMod     , \"%=\"        ,Mod     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgMod:\n      Indent(indentAmt);\n      Output::Print(_u(\"%=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgAnd     , \"&=\"        ,BitAnd  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgAnd:\n      Indent(indentAmt);\n      Output::Print(_u(\"&=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgXor     , \"^=\"        ,BitXor  ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgXor:\n      Indent(indentAmt);\n      Output::Print(_u(\"^=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgOr      , \"|=\"        ,BitOr   ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgOr:\n      Indent(indentAmt);\n      Output::Print(_u(\"|=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgLsh     , \"<<=\"        ,Lsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgLsh:\n      Indent(indentAmt);\n      Output::Print(_u(\"<<=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgRsh     , \">>=\"        ,Rsh     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRsh:\n      Indent(indentAmt);\n      Output::Print(_u(\">>=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopAsgRs2     , \">>>=\"        ,Rs2     ,Bin  ,fnopBin|fnopAsg)\n  case knopAsgRs2:\n      Indent(indentAmt);\n      Output::Print(_u(\">>>=\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n\n  case knopComputedName:\n      Indent(indentAmt);\n      Output::Print(_u(\"ComputedProperty\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n\n      //PTNODE(knopMember     , \":\"            ,None    ,Bin  ,fnopBin)\n  case knopMember:\n  case knopMemberShort:\n  case knopObjectPatternMember:\n      Indent(indentAmt);\n      Output::Print(_u(\":\\n\"));\n      PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxBin.pnode2,indentAmt+INDENT_SIZE);\n      break;\n      // General nodes.\n      //PTNODE(knopList       , \"<list>\"    ,None    ,Bin  ,fnopNone)\n  case knopList:\n      Indent(indentAmt);\n      Output::Print(_u(\"List\\n\"));\n      PrintPnodeListWIndent(pnode,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n  case knopVarDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"var %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n  case knopConstDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"const %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n  case knopLetDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"let %s\\n\"),pnode->sxVar.pid->Psz());\n      if (pnode->sxVar.pnodeInit!=NULL)\n          PrintPnodeWIndent(pnode->sxVar.pnodeInit,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n  case knopFncDecl:\n      Indent(indentAmt);\n      if (pnode->sxFnc.pid!=NULL)\n      {\n          Output::Print(_u(\"fn decl %d nested %d name %s (%d-%d)\\n\"),pnode->sxFnc.IsDeclaration(),pnode->sxFnc.IsNested(),\n              pnode->sxFnc.pid->Psz(), pnode->ichMin, pnode->ichLim);\n      }\n      else\n      {\n          Output::Print(_u(\"fn decl %d nested %d anonymous (%d-%d)\\n\"),pnode->sxFnc.IsDeclaration(),pnode->sxFnc.IsNested(),pnode->ichMin,pnode->ichLim);\n      }\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintFormalsWIndent(pnode->sxFnc.pnodeParams, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFnc.pnodeRest, indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFnc.pnodeBody, indentAmt + INDENT_SIZE);\n      if (pnode->sxFnc.pnodeBody == nullptr)\n      {\n          Output::Print(_u(\"[%4d, %4d): \"), pnode->ichMin, pnode->ichLim);\n          Indent(indentAmt + INDENT_SIZE);\n          Output::Print(_u(\"<parse deferred body>\\n\"));\n      }\n      break;\n      //PTNODE(knopProg       , \"program\"    ,None    ,Fnc  ,fnopNone)\n  case knopProg:\n      Indent(indentAmt);\n      Output::Print(_u(\"program\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeListWIndent(pnode->sxFnc.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopEndCode    , \"<endcode>\"    ,None    ,None ,fnopNone)\n  case knopEndCode:\n      Indent(indentAmt);\n      Output::Print(_u(\"<endcode>\\n\"));\n      break;\n      //PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n  case knopDebugger:\n      Indent(indentAmt);\n      Output::Print(_u(\"<debugger>\\n\"));\n      break;\n      //PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n  case knopFor:\n      Indent(indentAmt);\n      Output::Print(_u(\"for\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeInit,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeIncr,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxFor.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n  case knopIf:\n      Indent(indentAmt);\n      Output::Print(_u(\"if\\n\"));\n      PrintPnodeWIndent(pnode->sxIf.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxIf.pnodeTrue,indentAmt+INDENT_SIZE);\n      if (pnode->sxIf.pnodeFalse!=NULL)\n          PrintPnodeWIndent(pnode->sxIf.pnodeFalse,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopWhile      , \"while\"        ,None    ,While,fnopBreak|fnopContinue)\n  case knopWhile:\n      Indent(indentAmt);\n      Output::Print(_u(\"while\\n\"));\n      PrintPnodeWIndent(pnode->sxWhile.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWhile.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n  case knopDoWhile:\n      Indent(indentAmt);\n      Output::Print(_u(\"do\\n\"));\n      PrintPnodeWIndent(pnode->sxWhile.pnodeCond,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWhile.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n  case knopForIn:\n      Indent(indentAmt);\n      Output::Print(_u(\"forIn\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeLval,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n  case knopForOf:\n      Indent(indentAmt);\n      Output::Print(_u(\"forOf\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeLval,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxForInOrForOf.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n  case knopReturn:\n      Indent(indentAmt);\n      Output::Print(_u(\"return\\n\"));\n      if (pnode->sxReturn.pnodeExpr!=NULL)\n          PrintPnodeWIndent(pnode->sxReturn.pnodeExpr,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n  case knopBlock:\n      Indent(indentAmt);\n      Output::Print(_u(\"block \"));\n      if (pnode->grfpn & fpnSyntheticNode)\n          Output::Print(_u(\"synthetic \"));\n      PrintBlockType(pnode->sxBlock.blockType);\n      Output::Print(_u(\"(%d-%d)\\n\"),pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      if (pnode->sxBlock.pnodeStmt!=NULL)\n          PrintPnodeWIndent(pnode->sxBlock.pnodeStmt,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n  case knopWith:\n      Indent(indentAmt);\n      Output::Print(_u(\"with (%d-%d)\\n\"), pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWith.pnodeObj,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxWith.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n  case knopBreak:\n      Indent(indentAmt);\n      Output::Print(_u(\"break\\n\"));\n      // TODO: some representation of target\n      break;\n      //PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n  case knopContinue:\n      Indent(indentAmt);\n      Output::Print(_u(\"continue\\n\"));\n      // TODO: some representation of target\n      break;\n      //PTNODE(knopLabel      , \"label\"        ,None    ,Label,fnopNone)\n  case knopLabel:\n      Indent(indentAmt);\n      Output::Print(_u(\"label %s\"),pnode->sxLabel.pid->Psz());\n      // TODO: print labeled statement\n      break;\n      //PTNODE(knopSwitch     , \"switch\"    ,None    ,Switch,fnopBreak)\n  case knopSwitch:\n      Indent(indentAmt);\n      Output::Print(_u(\"switch\\n\"));\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      for (ParseNode *pnodeT = pnode->sxSwitch.pnodeCases; NULL != pnodeT;pnodeT = pnodeT->sxCase.pnodeNext) {\n          PrintPnodeWIndent(pnodeT,indentAmt+2);\n      }\n      break;\n      //PTNODE(knopCase       , \"case\"        ,None    ,Case ,fnopNone)\n  case knopCase:\n      Indent(indentAmt);\n      Output::Print(_u(\"case\\n\"));\n      PrintPnodeWIndent(pnode->sxCase.pnodeExpr,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCase.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTryFinally,\"try-finally\",None,TryFinally,fnopCleanup)\n  case knopTryFinally:\n      PrintPnodeWIndent(pnode->sxTryFinally.pnodeTry,indentAmt);\n      PrintPnodeWIndent(pnode->sxTryFinally.pnodeFinally,indentAmt);\n      break;\n  case knopFinally:\n      Indent(indentAmt);\n      Output::Print(_u(\"finally\\n\"));\n      PrintPnodeWIndent(pnode->sxFinally.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopCatch      , \"catch\"     ,None    ,Catch,fnopNone)\n  case knopCatch:\n      Indent(indentAmt);\n      Output::Print(_u(\"catch (%d-%d)\\n\"), pnode->ichMin,pnode->ichLim);\n      PrintScopesWIndent(pnode, indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCatch.pnodeParam,indentAmt+INDENT_SIZE);\n//      if (pnode->sxCatch.pnodeGuard!=NULL)\n//          PrintPnodeWIndent(pnode->sxCatch.pnodeGuard,indentAmt+INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxCatch.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopTryCatch      , \"try-catch\" ,None    ,TryCatch  ,fnopCleanup)\n  case knopTryCatch:\n      PrintPnodeWIndent(pnode->sxTryCatch.pnodeTry,indentAmt);\n      PrintPnodeWIndent(pnode->sxTryCatch.pnodeCatch,indentAmt);\n      break;\n      //PTNODE(knopTry        , \"try\"       ,None    ,Try  ,fnopCleanup)\n  case knopTry:\n      Indent(indentAmt);\n      Output::Print(_u(\"try\\n\"));\n      PrintPnodeWIndent(pnode->sxTry.pnodeBody,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopThrow      , \"throw\"     ,None    ,Uni  ,fnopNone)\n  case knopThrow:\n      Indent(indentAmt);\n      Output::Print(_u(\"throw\\n\"));\n      PrintPnodeWIndent(pnode->sxUni.pnode1,indentAmt+INDENT_SIZE);\n      break;\n      //PTNODE(knopClassDecl, \"classDecl\", None , Class, fnopLeaf)\n  case knopClassDecl:\n      Indent(indentAmt);\n      Output::Print(_u(\"class %s\"), pnode->sxClass.pnodeName->sxVar.pid->Psz());\n      if (pnode->sxClass.pnodeExtends != nullptr)\n      {\n          Output::Print(_u(\" extends \"));\n          PrintPnodeWIndent(pnode->sxClass.pnodeExtends, 0);\n      }\n      else {\n          Output::Print(_u(\"\\n\"));\n      }\n\n      PrintPnodeWIndent(pnode->sxClass.pnodeConstructor,   indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxClass.pnodeMembers,       indentAmt + INDENT_SIZE);\n      PrintPnodeWIndent(pnode->sxClass.pnodeStaticMembers, indentAmt + INDENT_SIZE);\n      break;\n  case knopStrTemplate:\n      Indent(indentAmt);\n      Output::Print(_u(\"string template\\n\"));\n      PrintPnodeListWIndent(pnode->sxStrTemplate.pnodeSubstitutionExpressions, indentAmt + INDENT_SIZE);\n      break;\n  case knopYieldStar:\n      Indent(indentAmt);\n      Output::Print(_u(\"yield*\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopYield:\n  case knopYieldLeaf:\n      Indent(indentAmt);\n      Output::Print(_u(\"yield\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopAwait:\n      Indent(indentAmt);\n      Output::Print(_u(\"await\\n\"));\n      PrintPnodeListWIndent(pnode->sxUni.pnode1, indentAmt + INDENT_SIZE);\n      break;\n  case knopExportDefault:\n      Indent(indentAmt);\n      Output::Print(_u(\"export default\\n\"));\n      PrintPnodeListWIndent(pnode->sxExportDefault.pnodeExpr, indentAmt + INDENT_SIZE);\n      break;\n  default:\n      Output::Print(_u(\"unhandled pnode op %d\\n\"),pnode->nop);\n      break;\n    }\n}\n\nvoid PrintPnodeListWIndent(ParseNode *pnode,int indentAmt) {\n    if (pnode!=NULL) {\n        while(pnode->nop==knopList) {\n            PrintPnodeWIndent(pnode->sxBin.pnode1,indentAmt);\n            pnode = pnode->sxBin.pnode2;\n        }\n        PrintPnodeWIndent(pnode,indentAmt);\n    }\n}\n\nvoid PrintFormalsWIndent(ParseNode *pnodeArgs, int indentAmt)\n{\n    for (ParseNode *pnode = pnodeArgs; pnode != nullptr; pnode = pnode->GetFormalNext())\n    {\n        PrintPnodeWIndent(pnode->nop == knopParamPattern ? pnode->sxParamPattern.pnode1 : pnode, indentAmt);\n    }\n}\n\nvoid PrintPnode(ParseNode *pnode) {\n    PrintPnodeWIndent(pnode,0);\n}\n\nvoid ParseNode::Dump()\n{\n    switch(nop)\n    {\n    case knopFncDecl:\n    case knopProg:\n        LPCOLESTR name = Js::Constants::AnonymousFunction;\n        if(this->sxFnc.pnodeName)\n        {\n            name = this->sxFnc.pnodeName->sxVar.pid->Psz();\n        }\n\n        Output::Print(_u(\"%s (%d) [%d, %d]:\\n\"), name, this->sxFnc.functionId, this->sxFnc.lineNumber, this->sxFnc.columnNumber);\n        Output::Print(_u(\"hasArguments: %s callsEval:%s childCallsEval:%s HasReferenceableBuiltInArguments:%s ArgumentsObjectEscapes:%s HasWith:%s HasThis:%s HasOnlyThis:%s \\n\"),\n            IsTrueOrFalse(this->sxFnc.HasHeapArguments()),\n            IsTrueOrFalse(this->sxFnc.CallsEval()),\n            IsTrueOrFalse(this->sxFnc.ChildCallsEval()),\n            IsTrueOrFalse(this->sxFnc.HasReferenceableBuiltInArguments()),\n            IsTrueOrFalse(this->sxFnc.GetArgumentsObjectEscapes()),\n            IsTrueOrFalse(this->sxFnc.HasWithStmt()),\n            IsTrueOrFalse(this->sxFnc.HasThisStmt()),\n            IsTrueOrFalse(this->sxFnc.HasOnlyThisStmts()));\n        if(this->sxFnc.funcInfo)\n        {\n            this->sxFnc.funcInfo->Dump();\n        }\n        break;\n    }\n}\n#endif\n\nDeferredFunctionStub * BuildDeferredStubTree(ParseNode *pnodeFnc, Recycler *recycler)\n{\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    uint nestedCount = pnodeFnc->sxFnc.nestedCount;\n    if (nestedCount == 0)\n    {\n        return nullptr;\n    }\n\n    if (pnodeFnc->sxFnc.deferredStub)\n    {\n        return pnodeFnc->sxFnc.deferredStub;\n    }\n\n    DeferredFunctionStub *deferredStubs = RecyclerNewArray(recycler, DeferredFunctionStub, nestedCount);\n    uint i = 0;\n\n    ParseNode *pnodeBlock = pnodeFnc->sxFnc.pnodeBodyScope;\n    Assert(pnodeBlock != nullptr\n        && pnodeBlock->nop == knopBlock\n        && (pnodeBlock->sxBlock.blockType == PnodeBlockType::Function\n            || pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter));\n\n    for (ParseNode *pnodeChild = pnodeBlock->sxBlock.pnodeScopes; pnodeChild != nullptr;)\n    {\n\n        if (pnodeChild->nop != knopFncDecl)\n        {\n            // We only expect to find a function body block in a parameter scope block.\n            Assert(pnodeChild->nop == knopBlock\n                && (pnodeBlock->sxBlock.blockType == PnodeBlockType::Parameter\n                    || pnodeChild->sxBlock.blockType == PnodeBlockType::Function));\n            pnodeChild = pnodeChild->sxBlock.pnodeNext;\n            continue;\n        }\n        AssertOrFailFast(i < nestedCount);\n\n        if (pnodeChild->sxFnc.pnodeBody != nullptr)\n        {\n            // Anomalous case of a non-deferred function nested within a deferred one.\n            // Work around by discarding the stub tree.\n            return nullptr;\n        }\n\n        if (pnodeChild->sxFnc.IsGeneratedDefault())\n        {\n            ++i;\n            pnodeChild = pnodeChild->sxFnc.pnodeNext;\n            continue;\n        }\n\n        AnalysisAssertOrFailFast(i < nestedCount);\n\n        deferredStubs[i].fncFlags = pnodeChild->sxFnc.fncFlags;\n        deferredStubs[i].nestedCount = pnodeChild->sxFnc.nestedCount;\n        deferredStubs[i].restorePoint = *pnodeChild->sxFnc.pRestorePoint;\n        deferredStubs[i].deferredStubs = BuildDeferredStubTree(pnodeChild, recycler);\n        deferredStubs[i].ichMin = pnodeChild->ichMin;\n        ++i;\n        pnodeChild = pnodeChild->sxFnc.pnodeNext;\n    }\n\n    return deferredStubs;\n}\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n#include \"RuntimeByteCodePch.h\"\n#include \"FormalsUtil.h\"\n#include \"Language/AsmJs.h\"\n\nvoid EmitReference(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitAssignment(ParseNode *asgnNode, ParseNode *lhs, Js::RegSlot rhsLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitLoad(ParseNode *rhs, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitCall(ParseNode* pnode, Js::RegSlot rhsLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, BOOL fReturnValue, BOOL fEvaluateComponents, BOOL fHasNewTarget, Js::RegSlot overrideThisLocation = Js::Constants::NoRegister);\nvoid EmitSuperFieldPatch(FuncInfo* funcInfo, ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator);\n\nvoid EmitUseBeforeDeclaration(Symbol *sym, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitUseBeforeDeclarationRuntimeError(ByteCodeGenerator *byteCodeGenerator, Js::RegSlot location);\nvoid VisitClearTmpRegs(ParseNode * pnode, ByteCodeGenerator * byteCodeGenerator, FuncInfo * funcInfo);\n\nbool CallTargetIsArray(ParseNode *pnode)\n{\n    return pnode->nop == knopName && pnode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::Array;\n}\n\n#define STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \\\nif ((isTopLevel)) \\\n{ \\\n    byteCodeGenerator->StartStatement(pnode); \\\n}\n\n#define ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \\\nif ((isTopLevel)) \\\n{ \\\n    byteCodeGenerator->EndStatement(pnode); \\\n}\n\nBOOL MayHaveSideEffectOnNode(ParseNode *pnode, ParseNode *pnodeSE)\n{\n    // Try to determine whether pnodeSE may kill the named var represented by pnode.\n\n    if (pnode->nop == knopComputedName)\n    {\n        pnode = pnode->sxUni.pnode1;\n    }\n\n    if (pnode->nop != knopName)\n    {\n        // Only investigating named vars here.\n        return false;\n    }\n\n    uint fnop = ParseNode::Grfnop(pnodeSE->nop);\n    if (fnop & fnopLeaf)\n    {\n        // pnodeSE is a leaf and can't kill anything.\n        return false;\n    }\n\n    if (fnop & fnopAsg)\n    {\n        // pnodeSE is an assignment (=, ++, +=, etc.)\n        // Trying to examine the LHS of pnodeSE caused small perf regressions,\n        // maybe because of code layout or some other subtle effect.\n        return true;\n    }\n\n    if (fnop & fnopUni)\n    {\n        // pnodeSE is a unary op, so recurse to the source (if present - e.g., [] may have no opnd).\n        if (pnodeSE->nop == knopTempRef)\n        {\n            return false;\n        }\n        else\n        {\n            return pnodeSE->sxUni.pnode1 && MayHaveSideEffectOnNode(pnode, pnodeSE->sxUni.pnode1);\n        }\n    }\n    else if (fnop & fnopBin)\n    {\n        // pnodeSE is a binary (or ternary) op, so recurse to the sources (if present).\n        if (pnodeSE->nop == knopQmark)\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode1) ||\n                MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode2) ||\n                MayHaveSideEffectOnNode(pnode, pnodeSE->sxTri.pnode3);\n        }\n        else if (pnodeSE->nop == knopCall || pnodeSE->nop == knopNew)\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxCall.pnodeTarget) ||\n                (pnodeSE->sxCall.pnodeArgs && MayHaveSideEffectOnNode(pnode, pnodeSE->sxCall.pnodeArgs));\n        }\n        else\n        {\n            return MayHaveSideEffectOnNode(pnode, pnodeSE->sxBin.pnode1) ||\n                (pnodeSE->sxBin.pnode2 && MayHaveSideEffectOnNode(pnode, pnodeSE->sxBin.pnode2));\n        }\n    }\n    else if (pnodeSE->nop == knopList)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nbool IsCallOfConstants(ParseNode *pnode);\nbool BlockHasOwnScope(ParseNode* pnodeBlock, ByteCodeGenerator *byteCodeGenerator);\nbool CreateNativeArrays(ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\n\nbool IsArguments(ParseNode *pnode)\n{\n    for (;;)\n    {\n        switch (pnode->nop)\n        {\n        case knopName:\n            return pnode->sxPid.sym && pnode->sxPid.sym->GetIsArguments();\n\n        case knopCall:\n        case knopNew:\n            if (IsArguments(pnode->sxCall.pnodeTarget))\n            {\n                return true;\n            }\n\n            if (pnode->sxCall.pnodeArgs)\n            {\n                ParseNode *pnodeArg = pnode->sxCall.pnodeArgs;\n                while (pnodeArg->nop == knopList)\n                {\n                    if (IsArguments(pnodeArg->sxBin.pnode1))\n                        return true;\n\n                    pnodeArg = pnodeArg->sxBin.pnode2;\n                }\n\n                pnode = pnodeArg;\n                break;\n            }\n\n            return false;\n\n        case knopArray:\n            if (pnode->sxArrLit.arrayOfNumbers || pnode->sxArrLit.count == 0)\n            {\n                return false;\n            }\n\n            pnode = pnode->sxUni.pnode1;\n            break;\n\n        case knopQmark:\n            if (IsArguments(pnode->sxTri.pnode1) || IsArguments(pnode->sxTri.pnode2))\n            {\n                return true;\n            }\n\n            pnode = pnode->sxTri.pnode3;\n            break;\n\n            //\n            // Cases where we don't check for \"arguments\" yet.\n            // Assume that they might have it. Disable the optimization is such scenarios\n            //\n        case knopList:\n        case knopObject:\n        case knopVarDecl:\n        case knopConstDecl:\n        case knopLetDecl:\n        case knopFncDecl:\n        case knopClassDecl:\n        case knopFor:\n        case knopIf:\n        case knopDoWhile:\n        case knopWhile:\n        case knopForIn:\n        case knopForOf:\n        case knopReturn:\n        case knopBlock:\n        case knopBreak:\n        case knopContinue:\n        case knopLabel:\n        case knopTypeof:\n        case knopThrow:\n        case knopWith:\n        case knopFinally:\n        case knopTry:\n        case knopTryCatch:\n        case knopTryFinally:\n        case knopArrayPattern:\n        case knopObjectPattern:\n        case knopParamPattern:\n            return true;\n\n        default:\n        {\n            uint flags = ParseNode::Grfnop(pnode->nop);\n            if (flags&fnopUni)\n            {\n                Assert(pnode->sxUni.pnode1);\n\n                pnode = pnode->sxUni.pnode1;\n                break;\n            }\n            else if (flags&fnopBin)\n            {\n                Assert(pnode->sxBin.pnode1 && pnode->sxBin.pnode2);\n\n                if (IsArguments(pnode->sxBin.pnode1))\n                {\n                    return true;\n                }\n\n                pnode = pnode->sxBin.pnode2;\n                break;\n            }\n\n            return false;\n        }\n\n        }\n    }\n}\n\nbool ApplyEnclosesArgs(ParseNode* fncDecl, ByteCodeGenerator* byteCodeGenerator);\nvoid Emit(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue, bool isConstructorCall = false, ParseNode *bindPnode = nullptr, bool isTopLevel = false);\nvoid EmitComputedFunctionNameVar(ParseNode *nameNode, ParseNode *exprNode, ByteCodeGenerator *byteCodeGenerator);\nvoid EmitBinaryOpnds(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nbool IsExpressionStatement(ParseNode* stmt, const Js::ScriptContext *const scriptContext);\nvoid EmitInvoke(Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitInvoke(Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, Js::RegSlot arg1Location);\n\nstatic const Js::OpCode nopToOp[knopLim] =\n{\n#define OP(x) Br##x##_A\n#define PTNODE(nop,sn,pc,nk,grfnop,json) Js::OpCode::pc,\n#include \"ptlist.h\"\n};\nstatic const Js::OpCode nopToCMOp[knopLim] =\n{\n#define OP(x) Cm##x##_A\n#define PTNODE(nop,sn,pc,nk,grfnop,json) Js::OpCode::pc,\n#include \"ptlist.h\"\n};\n\nJs::OpCode ByteCodeGenerator::ToChkUndeclOp(Js::OpCode op) const\n{\n    switch (op)\n    {\n    case Js::OpCode::StLocalSlot:\n        return Js::OpCode::StLocalSlotChkUndecl;\n\n    case Js::OpCode::StInnerSlot:\n        return Js::OpCode::StInnerSlotChkUndecl;\n\n    case Js::OpCode::StEnvSlot:\n        return Js::OpCode::StEnvSlotChkUndecl;\n\n    case Js::OpCode::StObjSlot:\n        return Js::OpCode::StObjSlotChkUndecl;\n\n    case Js::OpCode::StLocalObjSlot:\n        return Js::OpCode::StLocalObjSlotChkUndecl;\n\n    case Js::OpCode::StInnerObjSlot:\n        return Js::OpCode::StInnerObjSlotChkUndecl;\n\n    case Js::OpCode::StEnvObjSlot:\n        return Js::OpCode::StEnvObjSlotChkUndecl;\n\n    default:\n        AssertMsg(false, \"Unknown opcode for chk undecl mapping\");\n        return Js::OpCode::InvalidOpCode;\n    }\n}\n\n// Tracks a register slot let/const property for the passed in debugger block/catch scope.\n// debuggerScope         - The scope to add the variable to.\n// symbol                - The symbol that represents the register property.\n// funcInfo              - The function info used to store the property into the tracked debugger register slot list.\n// flags                 - The flags to assign to the property.\n// isFunctionDeclaration - Whether or not the register is a function declaration, which requires that its byte code offset be updated immediately.\nvoid ByteCodeGenerator::TrackRegisterPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol *symbol,\n    FuncInfo *funcInfo,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    Assert(debuggerScope);\n    Assert(symbol);\n    Assert(funcInfo);\n\n    Js::RegSlot location = symbol->GetLocation();\n\n    Js::DebuggerScope *correctDebuggerScope = debuggerScope;\n    if (debuggerScope->scopeType != Js::DiagExtraScopesType::DiagBlockScopeDirect && debuggerScope->scopeType != Js::DiagExtraScopesType::DiagCatchScopeDirect)\n    {\n        // We have to get the appropriate scope and add property over there.\n        // Make sure the scope is created whether we're in debug mode or not, because we\n        // need the empty scopes present during reparsing for debug mode.\n        correctDebuggerScope = debuggerScope->GetSiblingScope(location, Writer()->GetFunctionWrite());\n    }\n\n    if (this->ShouldTrackDebuggerMetadata() && !symbol->GetIsTrackedForDebugger())\n    {\n        // Only track the property if we're in debug mode since it's only needed by the debugger.\n        Js::PropertyId propertyId = symbol->EnsurePosition(this);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            correctDebuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ true,\n            flags,\n            isFunctionDeclaration);\n\n        Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n        byteCodeFunction->InsertSymbolToRegSlotList(location, propertyId, funcInfo->varRegsCount);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\nvoid ByteCodeGenerator::TrackActivationObjectPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol *symbol,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    Assert(debuggerScope);\n    Assert(symbol);\n\n    // Only need to track activation object properties in debug mode.\n    if (ShouldTrackDebuggerMetadata() && !symbol->GetIsTrackedForDebugger())\n    {\n        Js::RegSlot location = symbol->GetLocation();\n        Js::PropertyId propertyId = symbol->EnsurePosition(this);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            debuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ false,\n            flags,\n            isFunctionDeclaration);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\nvoid ByteCodeGenerator::TrackSlotArrayPropertyForDebugger(\n    Js::DebuggerScope *debuggerScope,\n    Symbol* symbol,\n    Js::PropertyId propertyId,\n    Js::DebuggerScopePropertyFlags flags /*= Js::DebuggerScopePropertyFlags_None*/,\n    bool isFunctionDeclaration /*= false*/)\n{\n    // Note: Slot array properties are tracked even in non-debug mode in order to support slot array serialization\n    // of let/const variables between non-debug and debug mode (for example, when a slot array var escapes and is retrieved\n    // after a debugger attach or for WWA apps).  They are also needed for heap enumeration.\n    Assert(debuggerScope);\n    Assert(symbol);\n\n    if (!symbol->GetIsTrackedForDebugger())\n    {\n        Js::RegSlot location = symbol->GetScopeSlot();\n        Assert(location != Js::Constants::NoRegister);\n        Assert(propertyId != Js::Constants::NoProperty);\n\n        this->Writer()->AddPropertyToDebuggerScope(\n            debuggerScope,\n            location,\n            propertyId,\n            /*shouldConsumeRegister*/ false,\n            flags,\n            isFunctionDeclaration);\n\n        symbol->SetIsTrackedForDebugger(true);\n    }\n}\n\n// Tracks a function declaration inside a block scope for the debugger metadata's current scope (let binding).\nvoid ByteCodeGenerator::TrackFunctionDeclarationPropertyForDebugger(Symbol *functionDeclarationSymbol, FuncInfo *funcInfoParent)\n{\n    Assert(functionDeclarationSymbol);\n    Assert(funcInfoParent);\n    AssertMsg(functionDeclarationSymbol->GetIsBlockVar(), \"We should only track inner function let bindings for the debugger.\");\n\n    // Note: we don't have to check symbol->GetIsTrackedForDebugger, as we are not doing actual work here,\n    //       which is done in other Track* functions that we call.\n\n    if (functionDeclarationSymbol->IsInSlot(funcInfoParent))\n    {\n        if (functionDeclarationSymbol->GetScope()->GetIsObject())\n        {\n            this->TrackActivationObjectPropertyForDebugger(\n                this->Writer()->GetCurrentDebuggerScope(),\n                functionDeclarationSymbol,\n                Js::DebuggerScopePropertyFlags_None,\n                true /*isFunctionDeclaration*/);\n        }\n        else\n        {\n            // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n            // Note that slot array inner function bindings are tracked even in non-debug mode in order\n            // to keep the lifetime of the closure binding that could escape around for heap enumeration.\n            functionDeclarationSymbol->EnsureScopeSlot(funcInfoParent);\n            functionDeclarationSymbol->EnsurePosition(this);\n            this->TrackSlotArrayPropertyForDebugger(\n                this->Writer()->GetCurrentDebuggerScope(),\n                functionDeclarationSymbol,\n                functionDeclarationSymbol->GetPosition(),\n                Js::DebuggerScopePropertyFlags_None,\n                true /*isFunctionDeclaration*/);\n        }\n    }\n    else\n    {\n        this->TrackRegisterPropertyForDebugger(\n            this->Writer()->GetCurrentDebuggerScope(),\n            functionDeclarationSymbol,\n            funcInfoParent,\n            Js::DebuggerScopePropertyFlags_None,\n            true /*isFunctionDeclaration*/);\n    }\n}\n\n// Updates the byte code offset of the property with the passed in location and ID.\n// Used to track let/const variables that are in the dead zone debugger side.\n// location                 - The activation object, scope slot index, or register location for the property.\n// propertyId               - The ID of the property to update.\n// shouldConsumeRegister    - Whether or not the a register should be consumed (used for reg slot locations).\nvoid ByteCodeGenerator::UpdateDebuggerPropertyInitializationOffset(Js::RegSlot location, Js::PropertyId propertyId, bool shouldConsumeRegister)\n{\n    Assert(this->Writer());\n    Js::DebuggerScope* currentDebuggerScope = this->Writer()->GetCurrentDebuggerScope();\n    Assert(currentDebuggerScope);\n    if (currentDebuggerScope != nullptr)\n    {\n        this->Writer()->UpdateDebuggerPropertyInitializationOffset(\n            currentDebuggerScope,\n            location,\n            propertyId,\n            shouldConsumeRegister);\n    }\n}\n\nvoid ByteCodeGenerator::LoadHeapArguments(FuncInfo *funcInfo)\n{\n    if (funcInfo->GetHasCachedScope())\n    {\n        this->LoadCachedHeapArguments(funcInfo);\n    }\n    else\n    {\n        this->LoadUncachedHeapArguments(funcInfo);\n    }\n}\n\nvoid GetFormalArgsArray(ByteCodeGenerator *byteCodeGenerator, FuncInfo * funcInfo, Js::PropertyIdArray *propIds)\n{\n    Assert(funcInfo);\n    Assert(propIds);\n    Assert(byteCodeGenerator);\n\n    bool hadDuplicates = false;\n    Js::ArgSlot i = 0;\n\n    auto processArg = [&](ParseNode *pnode)\n    {\n        if (pnode->IsVarLetOrConst())\n        {\n            Assert(i < propIds->count);\n            Symbol *sym = pnode->sxVar.sym;\n            Assert(sym);\n            Js::PropertyId symPos = sym->EnsurePosition(byteCodeGenerator);\n\n            //\n            // Check if the function has any same name parameters\n            // For the same name param, only the last one will be passed the correct propertyid\n            // For remaining dup param names, pass Constants::NoProperty\n            //\n            for (Js::ArgSlot j = 0; j < i; j++)\n            {\n                if (propIds->elements[j] == symPos)\n                {\n                    // Found a dup parameter name\n                    propIds->elements[j] = Js::Constants::NoProperty;\n                    hadDuplicates = true;\n                    break;\n                }\n            }\n            propIds->elements[i] = symPos;\n        }\n        else\n        {\n            propIds->elements[i] = Js::Constants::NoProperty;\n        }\n        ++i;\n    };\n    MapFormals(funcInfo->root, processArg);\n\n    propIds->hadDuplicates = hadDuplicates;\n}\n\nvoid ByteCodeGenerator::LoadUncachedHeapArguments(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetHasHeapArguments());\n\n    Scope *scope = funcInfo->GetBodyScope();\n    Assert(scope);\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n    \n\n    Js::OpCode opcode = !funcInfo->root->sxFnc.HasNonSimpleParameterList() ? Js::OpCode::LdHeapArguments : Js::OpCode::LdLetHeapArguments;\n    bool hasRest = funcInfo->root->sxFnc.pnodeRest != nullptr;\n    uint count = funcInfo->inArgsCount + (hasRest ? 1 : 0) - 1;\n    if (count == 0)\n    {\n        // If no formals to function (only \"this\"), then no need to create the scope object.\n        // Leave both the arguments location and the propertyIds location as null.\n        Assert(funcInfo->root->sxFnc.pnodeParams == nullptr && !hasRest);\n    }\n    else if (!NeedScopeObjectForArguments(funcInfo, funcInfo->root))\n    {\n        // We may not need a scope object for arguments, e.g. strict mode with no eval.\n    }\n    else if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        // Pass the frame object and ID array to the runtime, and put the resulting Arguments object\n        // at the expected location.\n\n        Js::PropertyIdArray *propIds = funcInfo->GetParsedFunctionBody()->AllocatePropertyIdArrayForFormals(count * sizeof(Js::PropertyId), count, 0);\n        GetFormalArgsArray(this, funcInfo, propIds);\n    }\n\n    this->m_writer.Reg1(opcode, argumentsLoc);\n    EmitLocalPropInit(argSym->GetLocation(), argSym, funcInfo);\n}\n\nvoid ByteCodeGenerator::LoadCachedHeapArguments(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetHasHeapArguments());\n\n    Scope *scope = funcInfo->GetBodyScope();\n    Assert(scope);\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n\n    Js::OpCode op = !funcInfo->root->sxFnc.HasNonSimpleParameterList() ? Js::OpCode::LdHeapArgsCached : Js::OpCode::LdLetHeapArgsCached;\n\n    this->m_writer.Reg1(op, argumentsLoc);\n    EmitLocalPropInit(argumentsLoc, argSym, funcInfo);\n}\n\nJs::JavascriptArray* ByteCodeGenerator::BuildArrayFromStringList(ParseNode* stringNodeList, uint arrayLength, Js::ScriptContext* scriptContext)\n{\n    Assert(stringNodeList);\n\n    uint index = 0;\n    Js::Var str;\n    IdentPtr pid;\n    Js::JavascriptArray* pArr = scriptContext->GetLibrary()->CreateArray(arrayLength);\n\n    while (stringNodeList->nop == knopList)\n    {\n        Assert(stringNodeList->sxBin.pnode1->nop == knopStr);\n\n        pid = stringNodeList->sxBin.pnode1->sxPid.pid;\n        str = Js::JavascriptString::NewCopyBuffer(pid->Psz(), pid->Cch(), scriptContext);\n        pArr->SetItemWithAttributes(index, str, PropertyEnumerable);\n\n        stringNodeList = stringNodeList->sxBin.pnode2;\n        index++;\n    }\n\n    Assert(stringNodeList->nop == knopStr);\n\n    pid = stringNodeList->sxPid.pid;\n    str = Js::JavascriptString::NewCopyBuffer(pid->Psz(), pid->Cch(), scriptContext);\n    pArr->SetItemWithAttributes(index, str, PropertyEnumerable);\n\n    return pArr;\n}\n\n// For now, this just assigns field ids for the current script.\n// Later, we will combine this information with the global field id map.\n// This temporary code will not work if a global member is accessed both with and without a LHS.\nvoid ByteCodeGenerator::AssignPropertyIds(Js::ParseableFunctionInfo* functionInfo)\n{\n    globalScope->ForEachSymbol([this, functionInfo](Symbol * sym)\n    {\n        this->AssignPropertyId(sym, functionInfo);\n    });\n}\n\nvoid ByteCodeGenerator::InitBlockScopedContent(ParseNode *pnodeBlock, Js::DebuggerScope* debuggerScope, FuncInfo *funcInfo)\n{\n    Assert(pnodeBlock->nop == knopBlock);\n\n    auto genBlockInit = [this, debuggerScope, funcInfo](ParseNode *pnode)\n    {\n        // Only check if the scope is valid when let/const vars are in the scope.  If there are no let/const vars,\n        // the debugger scope will not be created.\n        AssertMsg(debuggerScope, \"Missing a case of scope tracking in BeginEmitBlock.\");\n\n        FuncInfo *funcInfo = this->TopFuncInfo();\n        Symbol *sym = pnode->sxVar.sym;\n        Scope *scope = sym->GetScope();\n\n        if (sym->GetIsGlobal())\n        {\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n            if (this->flags & fscrEval)\n            {\n                AssertMsg(this->IsConsoleScopeEval(), \"Let/Consts cannot be in global scope outside of console eval\");\n                Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ? Js::OpCode::InitUndeclConsoleConstFld : Js::OpCode::InitUndeclConsoleLetFld;\n                this->m_writer.ElementScopedU(op, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n            else\n            {\n                Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                    Js::OpCode::InitUndeclRootConstFld : Js::OpCode::InitUndeclRootLetFld;\n                this->m_writer.ElementRootU(op, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n        }\n        else if (sym->IsInSlot(funcInfo) || (scope->GetIsObject() && sym->NeedsSlotAlloc(funcInfo)))\n        {\n            if (scope->GetIsObject())\n            {\n                Js::RegSlot scopeLocation = scope->GetLocation();\n                Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n                if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n                {\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n\n                    Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                        Js::OpCode::InitUndeclLocalConstFld : Js::OpCode::InitUndeclLocalLetFld;\n\n                    this->m_writer.ElementP(op, ByteCodeGenerator::ReturnRegister, cacheId);\n                }\n                else\n                {\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n\n                    Js::OpCode op = (sym->GetDecl()->nop == knopConstDecl) ?\n                        Js::OpCode::InitUndeclConstFld : Js::OpCode::InitUndeclLetFld;\n\n                    this->m_writer.ElementPIndexed(op, ByteCodeGenerator::ReturnRegister, scope->GetInnerScopeIndex(), cacheId);\n                }\n\n                TrackActivationObjectPropertyForDebugger(debuggerScope, sym, pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n            else\n            {\n                Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg1(Js::OpCode::InitUndecl, tmpReg);\n                this->EmitLocalPropInit(tmpReg, sym, funcInfo);\n                funcInfo->ReleaseTmpRegister(tmpReg);\n\n                // Slot array properties are tracked in non-debug mode as well because they need to stay\n                // around for heap enumeration and escaping during attach/detach.\n                TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(this), pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n        }\n        else if (!sym->GetIsModuleExportStorage())\n        {\n            if (sym->GetDecl()->sxVar.isSwitchStmtDecl)\n            {\n                // let/const declared in a switch is the only case of a variable that must be checked for\n                // use-before-declaration dynamically within its own function.\n                this->m_writer.Reg1(Js::OpCode::InitUndecl, sym->GetLocation());\n            }\n            // Syms that begin in register may be delay-captured. In debugger mode, such syms\n            // will live only in slots, so tell the debugger to find them there.\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(this), pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n            else \n            {\n                TrackRegisterPropertyForDebugger(debuggerScope, sym, funcInfo, pnode->nop == knopConstDecl ? Js::DebuggerScopePropertyFlags_Const : Js::DebuggerScopePropertyFlags_None);\n            }\n        }\n    };\n\n    IterateBlockScopedVariables(pnodeBlock, genBlockInit);\n}\n\n// Records the start of a debugger scope if the passed in node has any let/const variables (or is not a block node).\n// If it has no let/const variables, nullptr will be returned as no scope will be created.\nJs::DebuggerScope* ByteCodeGenerator::RecordStartScopeObject(ParseNode *pnodeBlock, Js::DiagExtraScopesType scopeType, Js::RegSlot scopeLocation /*= Js::Constants::NoRegister*/, int* index /*= nullptr*/)\n{\n    Assert(pnodeBlock);\n    if (pnodeBlock->nop == knopBlock && !pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        // In order to reduce allocations now that we track debugger scopes in non-debug mode,\n        // don't add a block to the chain if it has no let/const variables at all.\n        return nullptr;\n    }\n\n    return this->Writer()->RecordStartScopeObject(scopeType, scopeLocation, index);\n}\n\n// Records the end of the current scope, but only if the current block has block scoped content.\n// Otherwise, a scope would not have been added (see ByteCodeGenerator::RecordStartScopeObject()).\nvoid ByteCodeGenerator::RecordEndScopeObject(ParseNode *pnodeBlock)\n{\n    Assert(pnodeBlock);\n    if (pnodeBlock->nop == knopBlock && !pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        return;\n    }\n\n    this->Writer()->RecordEndScopeObject();\n}\n\nvoid BeginEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Js::DebuggerScope* debuggerScope = nullptr;\n\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        byteCodeGenerator->PushScope(scope);\n\n        Js::RegSlot scopeLocation = scope->GetLocation();\n        if (scope->GetMustInstantiate())\n        {\n            Assert(scopeLocation == Js::Constants::NoRegister);\n            scopeLocation = funcInfo->FirstInnerScopeReg() + scope->GetInnerScopeIndex();\n\n            if (scope->GetIsObject())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInObject, scopeLocation);\n\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::NewBlockScope, scope->GetInnerScopeIndex());\n            }\n            else\n            {\n                int scopeIndex = Js::DebuggerScope::InvalidScopeIndex;\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInSlot, scopeLocation, &scopeIndex);\n\n                // TODO: Handle heap enumeration\n                int scopeSlotCount = scope->GetScopeSlotCount();\n                byteCodeGenerator->Writer()->Num3(Js::OpCode::NewInnerScopeSlots, scope->GetInnerScopeIndex(), scopeSlotCount + Js::ScopeSlots::FirstSlotIndex, scopeIndex);\n            }\n        }\n        else\n        {\n            // In the direct register access case, there is no block scope emitted but we can still track\n            // the start and end offset of the block.  The location registers for let/const variables will still be\n            // captured along with this range in InitBlockScopedContent().\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeDirect);\n        }\n\n        bool const isGlobalEvalBlockScope = scope->IsGlobalEvalBlockScope();\n        Js::RegSlot frameDisplayLoc = Js::Constants::NoRegister;\n        Js::RegSlot tmpInnerEnvReg = Js::Constants::NoRegister;\n        ParseNodePtr pnodeScope;\n        for (pnodeScope = pnodeBlock->sxBlock.pnodeScopes; pnodeScope;)\n        {\n            switch (pnodeScope->nop)\n            {\n            case knopFncDecl:\n                if (pnodeScope->sxFnc.IsDeclaration())\n                {\n                    // The frameDisplayLoc register's lifetime has to be controlled by this function. We can't let\n                    // it be released by DefineOneFunction, because further iterations of this loop can allocate\n                    // temps, and we can't let frameDisplayLoc be re-purposed until this loop completes.\n                    // So we'll supply a temp that we allocate and release here.\n                    if (frameDisplayLoc == Js::Constants::NoRegister)\n                    {\n                        if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n                        {\n                            frameDisplayLoc = funcInfo->frameDisplayRegister;\n                        }\n                        else\n                        {\n                            frameDisplayLoc = funcInfo->GetEnvRegister();\n                        }\n                        tmpInnerEnvReg = funcInfo->AcquireTmpRegister();\n                        frameDisplayLoc = byteCodeGenerator->PrependLocalScopes(frameDisplayLoc, tmpInnerEnvReg, funcInfo);\n                    }\n                    byteCodeGenerator->DefineOneFunction(pnodeScope, funcInfo, true, frameDisplayLoc);\n                }\n\n                // If this is the global eval block scope, the function is actually assigned to the global\n                // so we don't need to keep the registers.\n                if (isGlobalEvalBlockScope)\n                {\n                    funcInfo->ReleaseLoc(pnodeScope);\n                    pnodeScope->location = Js::Constants::NoRegister;\n                }\n                pnodeScope = pnodeScope->sxFnc.pnodeNext;\n                break;\n\n            case knopBlock:\n                pnodeScope = pnodeScope->sxBlock.pnodeNext;\n                break;\n\n            case knopCatch:\n                pnodeScope = pnodeScope->sxCatch.pnodeNext;\n                break;\n\n            case knopWith:\n                pnodeScope = pnodeScope->sxWith.pnodeNext;\n                break;\n            }\n        }\n\n        if (tmpInnerEnvReg != Js::Constants::NoRegister)\n        {\n            funcInfo->ReleaseTmpRegister(tmpInnerEnvReg);\n        }\n\n        if (pnodeBlock->sxBlock.scope->IsGlobalEvalBlockScope() && funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            Scope* globalEvalBlockScope = funcInfo->GetGlobalEvalBlockScope();\n            byteCodeGenerator->EmitInitCapturedThis(funcInfo, globalEvalBlockScope);\n        }\n    }\n    else\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        if (scope)\n        {\n            if (scope->GetMustInstantiate())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInObject);\n            }\n            else\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeDirect);\n            }\n        }\n        else\n        {\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnodeBlock, Js::DiagExtraScopesType::DiagBlockScopeInSlot);\n        }\n    }\n\n    byteCodeGenerator->InitBlockScopedContent(pnodeBlock, debuggerScope, funcInfo);\n}\n\nvoid EndEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        Scope *scope = pnodeBlock->sxBlock.scope;\n        Assert(scope);\n        Assert(scope == byteCodeGenerator->GetCurrentScope());\n        byteCodeGenerator->PopScope();\n    }\n\n    byteCodeGenerator->RecordEndScopeObject(pnodeBlock);\n}\n\nvoid CloneEmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (BlockHasOwnScope(pnodeBlock, byteCodeGenerator))\n    {\n        // Only let variables have observable behavior when there are per iteration\n        // bindings.  const variables do not since they are immutable.  Therefore,\n        // (and the spec agrees), only create new scope clones if the loop variable\n        // is a let declaration.\n        bool isConst = false;\n        pnodeBlock->sxBlock.scope->ForEachSymbolUntil([&isConst](Symbol * const sym) {\n            // Exploit the fact that a for loop sxBlock can only have let and const\n            // declarations, and can only have one or the other, regardless of how\n            // many syms there might be.  Thus only check the first sym.\n            isConst = sym->GetDecl()->nop == knopConstDecl;\n            return true;\n        });\n\n        if (!isConst)\n        {\n            Scope *scope = pnodeBlock->sxBlock.scope;\n            Assert(scope == byteCodeGenerator->GetCurrentScope());\n\n            if (scope->GetMustInstantiate())\n            {\n                Js::OpCode op = scope->GetIsObject() ? Js::OpCode::CloneBlockScope : Js::OpCode::CloneInnerScopeSlots;\n\n                byteCodeGenerator->Writer()->Unsigned1(op, scope->GetInnerScopeIndex());\n            }\n        }\n    }\n}\n\nvoid EmitBlock(ParseNode *pnodeBlock, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    Assert(pnodeBlock->nop == knopBlock);\n    ParseNode *pnode = pnodeBlock->sxBlock.pnodeStmt;\n    if (pnode == nullptr)\n    {\n        return;\n    }\n\n    BeginEmitBlock(pnodeBlock, byteCodeGenerator, funcInfo);\n\n    ParseNode *pnodeLastValStmt = pnodeBlock->sxBlock.pnodeLastValStmt;\n\n    while (pnode->nop == knopList)\n    {\n        ParseNode* stmt = pnode->sxBin.pnode1;\n        if (stmt == pnodeLastValStmt)\n        {\n            // This is the last guaranteed return value, so any potential return values have to be\n            // copied to the return register from this point forward.\n            pnodeLastValStmt = nullptr;\n        }\n        byteCodeGenerator->EmitTopLevelStatement(stmt, funcInfo, fReturnValue && (pnodeLastValStmt == nullptr));\n        pnode = pnode->sxBin.pnode2;\n    }\n\n    if (pnode == pnodeLastValStmt)\n    {\n        pnodeLastValStmt = nullptr;\n    }\n    byteCodeGenerator->EmitTopLevelStatement(pnode, funcInfo, fReturnValue && (pnodeLastValStmt == nullptr));\n\n    EndEmitBlock(pnodeBlock, byteCodeGenerator, funcInfo);\n}\n\nvoid ClearTmpRegs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* emitFunc)\n{\n    if (emitFunc->IsTmpReg(pnode->location))\n    {\n        pnode->location = Js::Constants::NoRegister;\n    }\n}\n\nvoid ByteCodeGenerator::EmitTopLevelStatement(ParseNode *stmt, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    if (stmt->nop == knopFncDecl && stmt->sxFnc.IsDeclaration())\n    {\n        // Function declarations (not function-declaration RHS's) are already fully processed.\n        // Skip them here so the temp registers don't get messed up.\n        return;\n    }\n\n    if (stmt->nop == knopName || stmt->nop == knopDot)\n    {\n        // Generating span for top level names are mostly useful in debugging mode, because user can debug it even though no side-effect expected.\n        // But the name can have runtime error, e.g., foo.bar; // where foo is not defined.\n        // At this time we need to throw proper line number and offset. so recording on all modes will be useful.\n        StartStatement(stmt);\n        Writer()->Empty(Js::OpCode::Nop);\n        EndStatement(stmt);\n    }\n\n    Emit(stmt, this, funcInfo, fReturnValue, false/*isConstructorCall*/, nullptr/*bindPnode*/, true/*isTopLevel*/);\n    if (funcInfo->IsTmpReg(stmt->location))\n    {\n        if (!stmt->isUsed && !fReturnValue)\n        {\n            m_writer.Reg1(Js::OpCode::Unused, stmt->location);\n        }\n        funcInfo->ReleaseLoc(stmt);\n    }\n}\n\n// ByteCodeGenerator::DefineFunctions\n//\n// Emit byte code for scope-wide function definitions before any calls in the scope, regardless of lexical\n// order. Note that stores to the closure array are not emitted until we see the knopFncDecl in the tree\n// to make sure that sources of the stores have been defined.\nvoid ByteCodeGenerator::DefineFunctions(FuncInfo *funcInfoParent)\n{\n    // DefineCachedFunctions doesn't depend on whether the user vars are declared or not, so\n    // we'll just overload this variable to mean that the functions getting called again and we don't need to do anything\n    if (funcInfoParent->GetHasCachedScope())\n    {\n        this->DefineCachedFunctions(funcInfoParent);\n    }\n    else\n    {\n        this->DefineUncachedFunctions(funcInfoParent);\n    }\n}\n\n// Iterate over all child functions in a function's parameter and body scopes.\ntemplate<typename Fn>\nvoid MapContainerScopeFunctions(ParseNode* pnodeScope, Fn fn)\n{\n    auto mapFncDeclsInScopeList = [&](ParseNode *pnodeHead)\n    {\n        for (ParseNode *pnode = pnodeHead; pnode != nullptr;)\n        {\n            switch (pnode->nop)\n            {\n            case knopFncDecl:\n                fn(pnode);\n                pnode = pnode->sxFnc.pnodeNext;\n                break;\n\n            case knopBlock:\n                pnode = pnode->sxBlock.pnodeNext;\n                break;\n\n            case knopCatch:\n                pnode = pnode->sxCatch.pnodeNext;\n                break;\n\n            case knopWith:\n                pnode = pnode->sxWith.pnodeNext;\n                break;\n\n            default:\n                AssertMsg(false, \"Unexpected opcode in tree of scopes\");\n                return;\n            }\n        }\n    };\n    pnodeScope->sxFnc.MapContainerScopes(mapFncDeclsInScopeList);\n}\n\nvoid ByteCodeGenerator::DefineCachedFunctions(FuncInfo *funcInfoParent)\n{\n    ParseNode *pnodeParent = funcInfoParent->root;\n    uint slotCount = 0;\n\n    auto countFncSlots = [&](ParseNode *pnodeFnc)\n    {\n        if (pnodeFnc->sxFnc.GetFuncSymbol() != nullptr && pnodeFnc->sxFnc.IsDeclaration())\n        {\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, countFncSlots);\n\n    if (slotCount == 0)\n    {\n        return;\n    }\n\n    size_t extraBytesActual = AllocSizeMath::Mul(slotCount, sizeof(Js::FuncInfoEntry));\n    // Reg2Aux takes int for byteCount so we need to convert to int. OOM if we can't because it would truncate data.\n    if (extraBytesActual > INT_MAX)\n    {\n        Js::Throw::OutOfMemory();\n    }\n    int extraBytes = (int)extraBytesActual;\n\n    Js::FuncInfoArray *info = AnewPlus(alloc, extraBytes, Js::FuncInfoArray, slotCount);\n\n    slotCount = 0;\n\n    auto fillEntries = [&](ParseNode *pnodeFnc)\n    {\n        Symbol *sym = pnodeFnc->sxFnc.GetFuncSymbol();\n        if (sym != nullptr && (pnodeFnc->sxFnc.IsDeclaration()))\n        {\n            AssertMsg(!pnodeFnc->sxFnc.IsGenerator(), \"Generator functions are not supported by InitCachedFuncs but since they always escape they should disable function caching\");\n            Js::FuncInfoEntry *entry = &info->elements[slotCount];\n            entry->nestedIndex = pnodeFnc->sxFnc.nestedIndex;\n            entry->scopeSlot = sym->GetScopeSlot();\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, fillEntries);\n\n    m_writer.AuxNoReg(Js::OpCode::InitCachedFuncs,\n        info,\n        sizeof(Js::FuncInfoArray) + extraBytes,\n        sizeof(Js::FuncInfoArray) + extraBytes);\n\n    slotCount = 0;\n    auto defineOrGetCachedFunc = [&](ParseNode *pnodeFnc)\n    {\n        Symbol *sym = pnodeFnc->sxFnc.GetFuncSymbol();\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            // Do we need to define the function here (i.e., is it not one of our cached locals)?\n            // Only happens if the sym is null (e.g., function x.y(){}).\n            if (sym == nullptr)\n            {\n                this->DefineOneFunction(pnodeFnc, funcInfoParent);\n            }\n            else if (!sym->IsInSlot(funcInfoParent) && sym->GetLocation() != Js::Constants::NoRegister)\n            {\n                // If it was defined by InitCachedFuncs, do we need to put it in a register rather than a slot?\n                m_writer.Reg1Unsigned1(Js::OpCode::GetCachedFunc, sym->GetLocation(), slotCount);\n            }\n            // The \"x = function() {...}\" case is being generated on the fly, during emission,\n            // so the caller expects to be able to release this register.\n            funcInfoParent->ReleaseLoc(pnodeFnc);\n            pnodeFnc->location = Js::Constants::NoRegister;\n            slotCount++;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, defineOrGetCachedFunc);\n\n    AdeletePlus(alloc, extraBytes, info);\n}\n\nvoid ByteCodeGenerator::DefineUncachedFunctions(FuncInfo *funcInfoParent)\n{\n    ParseNode *pnodeParent = funcInfoParent->root;\n    auto defineCheck = [&](ParseNode *pnodeFnc)\n    {\n        Assert(pnodeFnc->nop == knopFncDecl);\n\n        //\n        // Don't define the function upfront in following cases\n        // 1. x = function() {...};\n        //    Don't define the function for all modes.\n        //    Such a function can only be accessed via the LHS, so we define it at the assignment point\n        //    rather than the scope entry to save a register (and possibly save the whole definition).\n        //\n        // 2. x = function f() {...};\n        //    f is not visible in the enclosing scope.\n        //    Such function expressions should be emitted only at the assignment point, as can be used only\n        //    after the assignment. Might save register.\n        //\n\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            this->DefineOneFunction(pnodeFnc, funcInfoParent);\n            // The \"x = function() {...}\" case is being generated on the fly, during emission,\n            // so the caller expects to be able to release this register.\n            funcInfoParent->ReleaseLoc(pnodeFnc);\n            pnodeFnc->location = Js::Constants::NoRegister;\n        }\n    };\n    MapContainerScopeFunctions(pnodeParent, defineCheck);\n}\n\nvoid EmitAssignmentToFuncName(ParseNode *pnodeFnc, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfoParent)\n{\n    // Assign the location holding the func object reference to the given name.\n    Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n\n    if (sym != nullptr && !sym->GetIsFuncExpr())\n    {\n        if (sym->GetIsModuleExportStorage())\n        {\n            byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n        }\n        else if (sym->GetIsGlobal())\n        {\n            Js::PropertyId propertyId = sym->GetPosition();\n            byteCodeGenerator->EmitGlobalFncDeclInit(pnodeFnc->location, propertyId, funcInfoParent);\n            if (byteCodeGenerator->GetFlags() & fscrEval && !funcInfoParent->GetIsStrictMode())\n            {\n                byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n            }\n        }\n        else\n        {\n            if (sym->NeedsSlotAlloc(funcInfoParent))\n            {\n                if (!sym->GetHasNonCommittedReference() ||\n                    (funcInfoParent->GetParsedFunctionBody()->DoStackNestedFunc()))\n                {\n                    // No point in trying to optimize if there are no references before we have to commit to slot.\n                    // And not safe to delay putting a stack function in the slot, since we may miss boxing.\n                    sym->SetIsCommittedToSlot();\n                }\n            }\n\n            if (sym->GetScope()->GetFunc() != byteCodeGenerator->TopFuncInfo())\n            {\n                byteCodeGenerator->EmitPropStore(pnodeFnc->location, sym, nullptr, funcInfoParent);\n            }\n            else if (!sym->GetIsBlockVar() || sym->HasRealBlockVarRef() || sym->GetScope()->GetIsObject())\n            {\n                byteCodeGenerator->EmitLocalPropInit(pnodeFnc->location, sym, funcInfoParent);\n            }\n\n            Symbol * fncScopeSym = sym->GetFuncScopeVarSym();\n\n            if (fncScopeSym)\n            {\n                if (fncScopeSym->GetIsGlobal() && byteCodeGenerator->GetFlags() & fscrEval)\n                {\n                    Js::PropertyId propertyId = fncScopeSym->GetPosition();\n                    byteCodeGenerator->EmitGlobalFncDeclInit(pnodeFnc->location, propertyId, funcInfoParent);\n                }\n                else\n                {\n                    byteCodeGenerator->EmitPropStore(pnodeFnc->location, fncScopeSym, nullptr, funcInfoParent, false, false, /* isFncDeclVar */true);\n                }\n            }\n        }\n    }\n}\n\nJs::RegSlot ByteCodeGenerator::DefineOneFunction(ParseNode *pnodeFnc, FuncInfo *funcInfoParent, bool generateAssignment, Js::RegSlot regEnv, Js::RegSlot frameDisplayTemp)\n{\n    Assert(pnodeFnc->nop == knopFncDecl);\n\n    funcInfoParent->AcquireLoc(pnodeFnc);\n\n    if (regEnv == Js::Constants::NoRegister)\n    {\n        // If the child needs a closure, find a heap-allocated frame to pass to it.\n        if (frameDisplayTemp != Js::Constants::NoRegister)\n        {\n            // We allocated a temp to hold a local frame display value. Use that.\n            // It's likely that the FD is on the stack, and we used the temp to load it back.\n            regEnv = frameDisplayTemp;\n        }\n        else if (funcInfoParent->frameDisplayRegister != Js::Constants::NoRegister)\n        {\n            // This function has built a frame display, so pass it down.\n            regEnv = funcInfoParent->frameDisplayRegister;\n        }\n        else\n        {\n            // This function has no captured locals but inherits a closure environment, so pass it down.\n            regEnv = funcInfoParent->GetEnvRegister();\n        }\n\n        regEnv = this->PrependLocalScopes(regEnv, Js::Constants::NoRegister, funcInfoParent);\n    }\n\n    // AssertMsg(funcInfo->nonLocalSymbols == 0 || regEnv != funcInfoParent->nullConstantRegister,\n    // \"We need a closure for the nested function\");\n\n    // If we are in a parameter scope and it is not merged with body scope then we have to create the child function as an inner function\n    if (regEnv == funcInfoParent->frameDisplayRegister || regEnv == funcInfoParent->GetEnvRegister())\n    {\n        m_writer.NewFunction(pnodeFnc->location, pnodeFnc->sxFnc.nestedIndex, pnodeFnc->sxFnc.IsCoroutine());\n    }\n    else\n    {\n        m_writer.NewInnerFunction(pnodeFnc->location, pnodeFnc->sxFnc.nestedIndex, regEnv, pnodeFnc->sxFnc.IsCoroutine());\n    }\n\n    if (funcInfoParent->IsGlobalFunction() && (this->flags & fscrEval))\n    {\n        // A function declared at global scope in eval is untrackable,\n        // so make sure the caller's cached scope is invalidated.\n        this->funcEscapes = true;\n    }\n    else\n    {\n        if (pnodeFnc->sxFnc.IsDeclaration())\n        {\n            Symbol * funcSymbol = pnodeFnc->sxFnc.GetFuncSymbol();\n            if (funcSymbol)\n            {\n                // In the case where a let/const declaration is the same symbol name\n                // as the function declaration (shadowing case), the let/const var and\n                // the function declaration symbol are the same and share the same flags\n                // (particularly, sym->GetIsBlockVar() for this code path).\n                //\n                // For example:\n                // let a = 0;       // <-- sym->GetIsBlockVar() = true\n                // function b(){}   // <-- sym2->GetIsBlockVar() = false\n                //\n                // let x = 0;       // <-- sym3->GetIsBlockVar() = true\n                // function x(){}   // <-- sym3->GetIsBlockVar() = true\n                //\n                // In order to tell if the function is actually part\n                // of a block scope, we compare against the function scope here.\n                // Note that having a function with the same name as a let/const declaration\n                // is a redeclaration error, but we're pushing the fix for this out since it's\n                // a bit involved.\n                Assert(funcInfoParent->GetBodyScope() != nullptr && funcSymbol->GetScope() != nullptr);\n                bool isFunctionDeclarationInBlock = funcSymbol->GetIsBlockVar();\n\n                // Track all vars/lets/consts register slot function declarations.\n                if (ShouldTrackDebuggerMetadata()\n                    // If this is a let binding function declaration at global level, we want to\n                    // be sure to track the register location as well.\n                    && !(funcInfoParent->IsGlobalFunction() && !isFunctionDeclarationInBlock))\n                {\n                    if (!funcSymbol->IsInSlot(funcInfoParent))\n                    {\n                        funcInfoParent->byteCodeFunction->GetFunctionBody()->InsertSymbolToRegSlotList(funcSymbol->GetName(), pnodeFnc->location, funcInfoParent->varRegsCount);\n                    }\n                }\n\n                if (isFunctionDeclarationInBlock)\n                {\n                    // We only track inner let bindings for the debugger side.\n                    this->TrackFunctionDeclarationPropertyForDebugger(funcSymbol, funcInfoParent);\n                }\n            }\n        }\n    }\n\n    if (pnodeFnc->sxFnc.IsDefaultModuleExport())\n    {\n        this->EmitAssignmentToDefaultModuleExport(pnodeFnc, funcInfoParent);\n    }\n\n    if (pnodeFnc->sxFnc.pnodeName == nullptr || !generateAssignment)\n    {\n        return regEnv;\n    }\n\n    EmitAssignmentToFuncName(pnodeFnc, this, funcInfoParent);\n\n    return regEnv;\n}\n\nvoid ByteCodeGenerator::DefineUserVars(FuncInfo *funcInfo)\n{\n    // Initialize scope-wide variables on entry to the scope. TODO: optimize by detecting uses that are always reached\n    // by an existing initialization.\n\n    BOOL fGlobal = funcInfo->IsGlobalFunction();\n    ParseNode *pnode;\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // Global declarations need a temp register to hold the init value, but the node shouldn't get a register.\n    // Just assign one on the fly and re-use it for all initializations.\n    Js::RegSlot tmpReg = fGlobal ? funcInfo->AcquireTmpRegister() : Js::Constants::NoRegister;\n\n    for (pnode = funcInfo->root->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n    {\n        Symbol* sym = pnode->sxVar.sym;\n\n        if (sym != nullptr && !(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n        {\n            if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n            {\n                // The init node was bound to the catch object, because it's inside a catch and has the\n                // same name as the catch object. But we want to define a user var at function scope,\n                // so find the right symbol. (We'll still assign the RHS value to the catch object symbol.)\n                // This also applies to a var declaration in the same scope as a let declaration.\n#if DBG\n                if (!sym->GetIsCatch())\n                {\n                    // Assert that catch cannot be at function scope and let and var at function scope is redeclaration error.\n                    Assert(funcInfo->bodyScope != sym->GetScope());\n                }\n#endif\n                sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                Assert(sym && !sym->GetIsCatch() && !sym->GetIsBlockVar());\n            }\n\n            if (sym->GetSymbolType() == STVariable && !sym->GetIsModuleExportStorage())\n            {\n                if (fGlobal)\n                {\n                    Js::PropertyId propertyId = sym->EnsurePosition(this);\n                    // We do need to initialize some globals to avoid JS errors on loading undefined variables.\n                    // But we first need to make sure we're not trashing built-ins.\n\n                    if (this->flags & fscrEval)\n                    {\n                        if (funcInfo->byteCodeFunction->GetIsStrictMode())\n                        {\n                            // Check/Init the property of the frame object\n                            this->m_writer.ElementRootU(Js::OpCode::LdLocalElemUndef,\n                                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                        }\n                        else\n                        {\n                            // The check and the init involve the first element in the scope chain.\n                            this->m_writer.ElementScopedU(\n                                Js::OpCode::LdElemUndefScoped, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                        }\n                    }\n                    else\n                    {\n                        this->m_writer.ElementU(Js::OpCode::LdElemUndef, ByteCodeGenerator::RootObjectRegister,\n                            funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                    }\n                }\n                else if (!sym->GetIsArguments())\n                {\n                    if (sym->NeedsSlotAlloc(funcInfo))\n                    {\n                        if (!sym->GetHasNonCommittedReference() ||\n                            (sym->GetHasFuncAssignment() && funcInfo->GetParsedFunctionBody()->DoStackNestedFunc()))\n                        {\n                            // No point in trying to optimize if there are no references before we have to commit to slot.\n                            // And not safe to delay putting a stack function in the slot, since we may miss boxing.\n                            sym->SetIsCommittedToSlot();\n                        }\n                    }\n\n                    // Undef-initialize the home location if it is a register (not closure-captured, or else capture\n                    // is delayed) or a property of an object.\n                    if ((!sym->GetHasInit() && !sym->IsInSlot(funcInfo)) ||\n                        (funcInfo->bodyScope->GetIsObject() && !funcInfo->GetHasCachedScope()))\n                    {\n                        // If the  current symbol is the duplicate arguments symbol created in the body for split\n                        // scope then load undef only if the arguments symbol is used in the body.\n                        if (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments())\n                        {\n                            Js::RegSlot reg = sym->GetLocation();\n                            if (reg == Js::Constants::NoRegister)\n                            {\n                                Assert(sym->IsInSlot(funcInfo));\n                                reg = funcInfo->AcquireTmpRegister();\n                            }\n                            this->m_writer.Reg1(Js::OpCode::LdUndef, reg);\n                            this->EmitLocalPropInit(reg, sym, funcInfo);\n\n                            if (ShouldTrackDebuggerMetadata() && !sym->GetHasInit() && !sym->IsInSlot(funcInfo))\n                            {\n                                byteCodeFunction->InsertSymbolToRegSlotList(sym->GetName(), reg, funcInfo->varRegsCount);\n                            }\n\n                            funcInfo->ReleaseTmpRegister(reg);\n                        }\n                    }\n                }\n                else if (ShouldTrackDebuggerMetadata())\n                {\n                    if (!sym->GetHasInit() && !sym->IsInSlot(funcInfo))\n                    {\n                        Js::RegSlot reg = sym->GetLocation();\n                        if (reg != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(sym->GetName(), reg, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n                sym->SetHasInit(TRUE);\n            }\n        }\n\n    }\n    if (tmpReg != Js::Constants::NoRegister)\n    {\n        funcInfo->ReleaseTmpRegister(tmpReg);\n    }\n\n    for (int i = 0; i < funcInfo->nonUserNonTempRegistersToInitialize.Count(); ++i)\n    {\n        m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->nonUserNonTempRegistersToInitialize.Item(i));\n    }\n}\n\nvoid ByteCodeGenerator::InitBlockScopedNonTemps(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    // Initialize all non-temp register variables on entry to the enclosing func - in particular,\n    // those with lifetimes that begin after the start of user code and may not be initialized normally.\n    // This protects us from, for instance, trying to restore garbage on bailout.\n    // It was originally done in debugger mode only, but we do it always to avoid issues with boxing\n    // garbage on exit from jitted loop bodies.\n    while (pnode)\n    {\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n        {\n            // If this is a block-scoped function, initialize it.\n            ParseNode *pnodeName = pnode->sxFnc.pnodeName;\n            if (!pnode->sxFnc.IsMethod() && pnodeName && pnodeName->nop == knopVarDecl)\n            {\n                Symbol *sym = pnodeName->sxVar.sym;\n                Assert(sym);\n                if (sym->GetLocation() != Js::Constants::NoRegister &&\n                    sym->GetScope()->IsBlockScope(funcInfo) &&\n                    sym->GetScope()->GetFunc() == funcInfo)\n                {\n                    this->m_writer.Reg1(Js::OpCode::LdUndef, sym->GetLocation());\n                }\n            }\n\n            // No need to recurse to the nested scopes, as they belong to a nested function.\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n        }\n\n        case knopBlock:\n        {\n            Scope *scope = pnode->sxBlock.scope;\n            if (scope)\n            {\n                if (scope->IsBlockScope(funcInfo))\n                {\n                    Js::RegSlot scopeLoc = scope->GetLocation();\n                    if (scopeLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(scopeLoc))\n                    {\n                        this->m_writer.Reg1(Js::OpCode::LdUndef, scopeLoc);\n                    }\n                }\n                auto fnInit = [this, funcInfo](ParseNode *pnode)\n                {\n                    Symbol *sym = pnode->sxVar.sym;\n                    if (!sym->IsInSlot(funcInfo) && !sym->GetIsGlobal() && !sym->GetIsModuleImport())\n                    {\n                        this->m_writer.Reg1(Js::OpCode::InitUndecl, pnode->sxVar.sym->GetLocation());\n                    }\n                };\n                IterateBlockScopedVariables(pnode, fnInit);\n            }\n            InitBlockScopedNonTemps(pnode->sxBlock.pnodeScopes, funcInfo);\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n        }\n        case knopCatch:\n            InitBlockScopedNonTemps(pnode->sxCatch.pnodeScopes, funcInfo);\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n        {\n            Js::RegSlot withLoc = pnode->location;\n            AssertMsg(withLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(withLoc),\n                \"We should put with objects at known stack locations in debug mode\");\n            this->m_writer.Reg1(Js::OpCode::LdUndef, withLoc);\n            InitBlockScopedNonTemps(pnode->sxWith.pnodeScopes, funcInfo);\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n        }\n\n        default:\n            Assert(false);\n            return;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeObjectInit(FuncInfo *funcInfo)\n{\n    Assert(!funcInfo->byteCodeFunction->GetFunctionBody()->DoStackNestedFunc());\n\n    if (!funcInfo->GetHasCachedScope() /* || forcing scope/inner func caching */)\n    {\n        return;\n    }\n\n    Scope* currentScope = funcInfo->GetCurrentChildScope();\n    uint slotCount = currentScope->GetScopeSlotCount();\n    uint cachedFuncCount = 0;\n    Js::PropertyId firstFuncSlot = Js::Constants::NoProperty;\n    Js::PropertyId firstVarSlot = Js::Constants::NoProperty;\n    uint extraAlloc = (slotCount + Js::ActivationObjectEx::ExtraSlotCount()) * sizeof(Js::PropertyId);\n\n    // Create and fill the array of local property ID's.\n    // They all have slots assigned to them already (if they need them): see StartEmitFunction.\n    \n    Js::PropertyIdArray *propIds = funcInfo->GetParsedFunctionBody()->AllocatePropertyIdArrayForFormals(extraAlloc, slotCount, Js::ActivationObjectEx::ExtraSlotCount());\n    \n    ParseNode *pnodeFnc = funcInfo->root;\n    ParseNode *pnode;\n    Symbol *sym;\n\n    if (funcInfo->GetFuncExprNameReference() && pnodeFnc->sxFnc.GetFuncSymbol()->GetScope() == funcInfo->GetBodyScope())\n    {\n        Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.GetFuncSymbol(), propIds, this);\n    }\n\n    if (funcInfo->GetHasArguments())\n    {\n        // Because the arguments object can access all instances of same-named formals (\"function(x,x){...}\"),\n        // be sure we initialize any duplicate appearances of a formal parameter to \"NoProperty\".\n        Js::PropertyId slot = 0;\n        auto initArg = [&](ParseNode *pnode)\n        {\n            if (pnode->IsVarLetOrConst())\n            {\n                Symbol *sym = pnode->sxVar.sym;\n                Assert(sym);\n                if (sym->GetScopeSlot() == slot)\n                {\n                    // This is the last appearance of the formal, so record the ID.\n                    Symbol::SaveToPropIdArray(sym, propIds, this);\n                }\n                else\n                {\n                    // This is an earlier duplicate appearance of the formal, so use NoProperty as a placeholder\n                    // since this slot can't be accessed by name.\n                    Assert(sym->GetScopeSlot() != Js::Constants::NoProperty && sym->GetScopeSlot() > slot);\n                    propIds->elements[slot] = Js::Constants::NoProperty;\n                }\n            }\n            else\n            {\n                // This is for patterns\n                propIds->elements[slot] = Js::Constants::NoProperty;\n            }\n            slot++;\n        };\n        MapFormalsWithoutRest(pnodeFnc, initArg);\n\n        // If the rest is in the slot - we need to keep that slot.\n        if (pnodeFnc->sxFnc.pnodeRest != nullptr && pnodeFnc->sxFnc.pnodeRest->sxVar.sym->IsInSlot(funcInfo))\n        {\n            Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.pnodeRest->sxVar.sym, propIds, this);\n        }\n    }\n    else\n    {\n        MapFormals(pnodeFnc, [&](ParseNode *pnode)\n        {\n            if (pnode->IsVarLetOrConst())\n            {\n                Symbol::SaveToPropIdArray(pnode->sxVar.sym, propIds, this);\n            }\n        });\n    }\n\n    auto saveFunctionVarsToPropIdArray = [&](ParseNode *pnodeFunction)\n    {\n        if (pnodeFunction->sxFnc.IsDeclaration())\n        {\n            ParseNode *pnodeName = pnodeFunction->sxFnc.pnodeName;\n            if (pnodeName != nullptr)\n            {\n                while (pnodeName->nop == knopList)\n                {\n                    if (pnodeName->sxBin.pnode1->nop == knopVarDecl)\n                    {\n                        sym = pnodeName->sxBin.pnode1->sxVar.sym;\n                        if (sym)\n                        {\n                            Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);\n                        }\n                    }\n                    pnodeName = pnodeName->sxBin.pnode2;\n                }\n                if (pnodeName->nop == knopVarDecl)\n                {\n                    sym = pnodeName->sxVar.sym;\n                    if (sym)\n                    {\n                        Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);\n                        cachedFuncCount++;\n                    }\n                }\n            }\n        }\n    };\n    MapContainerScopeFunctions(pnodeFnc, saveFunctionVarsToPropIdArray);\n\n    if (currentScope->GetScopeType() != ScopeType_Parameter)\n    {\n        for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n            {\n                if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                {\n                    sym = currentScope->FindLocalSymbol(sym->GetName());\n                }\n                Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n            }\n        }\n\n        ParseNode *pnodeBlock = pnodeFnc->sxFnc.pnodeScopes;\n        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n        }\n\n        pnodeBlock = pnodeFnc->sxFnc.pnodeBodyScope;\n        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)\n        {\n            sym = pnode->sxVar.sym;\n            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);\n        }\n    }\n    else\n    {\n        Assert(!currentScope->GetCanMergeWithBodyScope());\n    }\n\n    if (funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->thisScopeSlot] = Js::PropertyIds::_lexicalThisSlotSymbol;\n    }\n    if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->newTargetScopeSlot] = Js::PropertyIds::_lexicalNewTargetSymbol;\n    }\n    if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->superScopeSlot] = Js::PropertyIds::_superReferenceSymbol;\n    }\n    if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n    {\n        propIds->elements[funcInfo->superCtorScopeSlot] = Js::PropertyIds::_superCtorReferenceSymbol;\n    }\n\n    // Write the first func slot and first var slot into the auxiliary data\n    Js::PropertyId *slots = propIds->elements + slotCount;\n    slots[0] = cachedFuncCount;\n    slots[1] = firstFuncSlot;\n    slots[2] = firstVarSlot;\n    slots[3] = funcInfo->GetParsedFunctionBody()->NewObjectLiteral();\n\n    propIds->hasNonSimpleParams = funcInfo->root->sxFnc.HasNonSimpleParameterList();\n    \n    funcInfo->GetParsedFunctionBody()->SetHasCachedScopePropIds(true);\n}\n\nvoid ByteCodeGenerator::SetClosureRegisters(FuncInfo* funcInfo, Js::FunctionBody* byteCodeFunction)\n{\n    if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalFrameDisplayRegister(funcInfo->frameDisplayRegister);\n    }\n\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalClosureRegister(funcInfo->frameObjRegister);\n        byteCodeFunction->SetHasScopeObject(true);\n    }\n    else if (funcInfo->frameSlotsRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetLocalClosureRegister(funcInfo->frameSlotsRegister);\n    }\n\n    if (funcInfo->paramSlotsRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->MapAndSetParamClosureRegister(funcInfo->paramSlotsRegister);\n    }\n}\n\nvoid ByteCodeGenerator::FinalizeRegisters(FuncInfo * funcInfo, Js::FunctionBody * byteCodeFunction)\n{\n    if (byteCodeFunction->IsCoroutine())\n    {\n        // EmitYield uses 'false' to create the IteratorResult object\n        funcInfo->AssignFalseConstRegister();\n    }\n\n    if (funcInfo->NeedEnvRegister())\n    {\n        bool constReg = !funcInfo->GetIsTopLevelEventHandler() && funcInfo->IsGlobalFunction() && !(this->flags & fscrEval);\n        funcInfo->AssignEnvRegister(constReg);\n    }\n\n    // Set the function body's constant count before emitting anything so that the byte code writer\n    // can distinguish constants from variables.\n    byteCodeFunction->CheckAndSetConstantCount(funcInfo->constRegsCount);\n\n    this->SetClosureRegisters(funcInfo, byteCodeFunction);\n\n    if (this->IsInDebugMode())\n    {\n        // Give permanent registers to the inner scopes in debug mode.\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n        if (innerScopeCount)\n        {\n            funcInfo->SetFirstInnerScopeReg(funcInfo->NextVarRegister());\n            for (uint i = 1; i < innerScopeCount; i++)\n            {\n                funcInfo->NextVarRegister();\n            }\n        }\n    }\n\n    // NOTE: The FB expects the yield reg to be the final non-temp.\n    if (byteCodeFunction->IsCoroutine())\n    {\n        funcInfo->AssignYieldRegister();\n    }\n\n    Js::RegSlot firstTmpReg = funcInfo->varRegsCount;\n    funcInfo->SetFirstTmpReg(firstTmpReg);\n    byteCodeFunction->SetFirstTmpReg(funcInfo->RegCount());\n}\n\nvoid ByteCodeGenerator::InitScopeSlotArray(FuncInfo * funcInfo)\n{\n    // Record slots info for ScopeSlots/ScopeObject.\n    uint scopeSlotCount = funcInfo->bodyScope->GetScopeSlotCount();\n    Assert(funcInfo->paramScope == nullptr || funcInfo->paramScope->GetScopeSlotCount() == 0 || !funcInfo->paramScope->GetCanMergeWithBodyScope());\n    uint scopeSlotCountForParamScope = funcInfo->paramScope != nullptr ? funcInfo->paramScope->GetScopeSlotCount() : 0;\n\n    if (scopeSlotCount == 0 && scopeSlotCountForParamScope == 0)\n    {\n        return;\n    }\n\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    if (scopeSlotCount > 0 || scopeSlotCountForParamScope > 0)\n    {\n        byteCodeFunction->SetScopeSlotArraySizes(scopeSlotCount, scopeSlotCountForParamScope);\n    }\n\n    // TODO: Need to add property ids for the case when scopeSlotCountForParamSCope is non-zero\n    if (scopeSlotCount)\n    {\n        Js::PropertyId *propertyIdsForScopeSlotArray = RecyclerNewArrayLeafZ(scriptContext->GetRecycler(), Js::PropertyId, scopeSlotCount);\n        byteCodeFunction->SetPropertyIdsForScopeSlotArray(propertyIdsForScopeSlotArray, scopeSlotCount, scopeSlotCountForParamScope);\n        AssertMsg(!byteCodeFunction->IsReparsed() || byteCodeFunction->m_wasEverAsmjsMode || byteCodeFunction->scopeSlotArraySize == scopeSlotCount,\n            \"The slot array size is different between debug and non-debug mode\");\n#if DEBUG\n        for (UINT i = 0; i < scopeSlotCount; i++)\n        {\n            propertyIdsForScopeSlotArray[i] = Js::Constants::NoProperty;\n        }\n#endif\n        auto setPropertyIdForScopeSlotArray =\n            [scopeSlotCount, propertyIdsForScopeSlotArray]\n            (Js::PropertyId slot, Js::PropertyId propId)\n        {\n            if (slot < 0 || (uint)slot >= scopeSlotCount)\n            {\n                Js::Throw::FatalInternalError();\n            }\n            propertyIdsForScopeSlotArray[slot] = propId;\n        };\n\n        auto setPropIdsForScopeSlotArray = [funcInfo, setPropertyIdForScopeSlotArray](Symbol *const sym)\n        {\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                if (funcInfo->IsInnerArgumentsSymbol(sym) && !funcInfo->GetHasArguments())\n                {\n                    // In split scope case we have a duplicate symbol for arguments in the body (innerArgumentsSymbol).\n                    // But if arguments is not referenced in the body we don't have to allocate scope slot for it.\n                    // If we allocate one, then the debugger will assume that the arguments symbol is there and skip creating the fake one.\n                }\n                else\n                {\n                    // All properties should get correct propertyId here.\n                    Assert(sym->HasScopeSlot()); // We can't allocate scope slot now. Any symbol needing scope slot must have allocated it before this point.\n                    setPropertyIdForScopeSlotArray(sym->GetScopeSlot(), sym->EnsurePosition(funcInfo));\n                }\n            }\n        };\n\n        funcInfo->GetBodyScope()->ForEachSymbol(setPropIdsForScopeSlotArray);\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->thisScopeSlot, Js::PropertyIds::_lexicalThisSlotSymbol);\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->newTargetScopeSlot, Js::PropertyIds::_lexicalNewTargetSymbol);\n        }\n\n        if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->superScopeSlot, Js::PropertyIds::_superReferenceSymbol);\n        }\n\n        if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n        {\n            setPropertyIdForScopeSlotArray(funcInfo->superCtorScopeSlot, Js::PropertyIds::_superCtorReferenceSymbol);\n        }\n\n#if DEBUG\n        for (UINT i = 0; i < scopeSlotCount; i++)\n        {\n            Assert(propertyIdsForScopeSlotArray[i] != Js::Constants::NoProperty\n                || funcInfo->frameObjRegister != Js::Constants::NoRegister); // ScopeObject may have unassigned entries, e.g. for same-named parameters\n        }\n#endif\n    }\n}\n\n// temporarily load all constants and special registers in a single block\nvoid ByteCodeGenerator::LoadAllConstants(FuncInfo *funcInfo)\n{\n    Symbol *sym;\n\n    Js::FunctionBody *byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    byteCodeFunction->CreateConstantTable();\n\n    if (funcInfo->nullConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordNullObject(byteCodeFunction->MapRegSlot(funcInfo->nullConstantRegister));\n    }\n\n    if (funcInfo->undefinedConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordUndefinedObject(byteCodeFunction->MapRegSlot(funcInfo->undefinedConstantRegister));\n    }\n\n    if (funcInfo->trueConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordTrueObject(byteCodeFunction->MapRegSlot(funcInfo->trueConstantRegister));\n    }\n\n    if (funcInfo->falseConstantRegister != Js::Constants::NoRegister)\n    {\n        byteCodeFunction->RecordFalseObject(byteCodeFunction->MapRegSlot(funcInfo->falseConstantRegister));\n    }\n\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        m_writer.RecordObjectRegister(funcInfo->frameObjRegister);\n        if (!funcInfo->GetApplyEnclosesArgs())\n        {\n            this->EmitScopeObjectInit(funcInfo);\n        }\n\n#if DBG\n        uint count = 0;\n        funcInfo->GetBodyScope()->ForEachSymbol([&](Symbol *const sym)\n        {\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                // All properties should get correct propertyId here.\n                count++;\n            }\n        });\n\n        if (funcInfo->GetParamScope() != nullptr)\n        {\n            funcInfo->GetParamScope()->ForEachSymbol([&](Symbol *const sym)\n            {\n                if (sym->NeedsSlotAlloc(funcInfo))\n                {\n                    // All properties should get correct propertyId here.\n                    count++;\n                }\n            });\n        }\n\n        // A reparse should result in the same size of the activation object.\n        // Exclude functions which were created from the ByteCodeCache.\n        AssertMsg(!byteCodeFunction->IsReparsed() || byteCodeFunction->HasGeneratedFromByteCodeCache() ||\n            byteCodeFunction->scopeObjectSize == count || byteCodeFunction->m_wasEverAsmjsMode,\n            \"The activation object size is different between debug and non-debug mode\");\n        byteCodeFunction->scopeObjectSize = count;\n#endif\n    }\n    else if (funcInfo->frameSlotsRegister != Js::Constants::NoRegister)\n    {\n        int scopeSlotCount = funcInfo->bodyScope->GetScopeSlotCount();\n        int paramSlotCount = funcInfo->paramScope->GetScopeSlotCount();\n        if (scopeSlotCount == 0 && paramSlotCount == 0)\n        {\n            AssertMsg(funcInfo->frameDisplayRegister != Js::Constants::NoRegister, \"Why do we need scope slots?\");\n            m_writer.Reg1(Js::OpCode::LdC_A_Null, funcInfo->frameSlotsRegister);\n        }\n    }\n\n    if (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject())\n    {\n        byteCodeFunction->MapAndSetFuncExprScopeRegister(funcInfo->funcExprScope->GetLocation());\n        byteCodeFunction->SetEnvDepth((uint16)-1);\n    }\n\n    bool thisLoadedFromParams = false;\n\n    if (funcInfo->NeedEnvRegister())\n    {\n        byteCodeFunction->MapAndSetEnvRegister(funcInfo->GetEnvRegister());\n        if (funcInfo->GetIsTopLevelEventHandler())\n        {\n            byteCodeFunction->MapAndSetThisRegisterForEventHandler(funcInfo->thisPointerRegister);\n            // The environment is the namespace hierarchy starting with \"this\".\n            Assert(!funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n            thisLoadedFromParams = true;\n            this->InvalidateCachedOuterScopes(funcInfo);\n        }\n        else if (funcInfo->IsGlobalFunction() && !(this->flags & fscrEval))\n        {\n            Assert(funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n\n            if (funcInfo->GetIsStrictMode())\n            {\n                byteCodeFunction->RecordStrictNullDisplayConstant(byteCodeFunction->MapRegSlot(funcInfo->GetEnvRegister()));\n            }\n            else\n            {\n                byteCodeFunction->RecordNullDisplayConstant(byteCodeFunction->MapRegSlot(funcInfo->GetEnvRegister()));\n            }\n        }\n        else\n        {\n            // environment may be required to load \"this\"\n            Assert(!funcInfo->RegIsConst(funcInfo->GetEnvRegister()));\n            this->InvalidateCachedOuterScopes(funcInfo);\n        }\n    }\n\n    if (funcInfo->frameDisplayRegister != Js::Constants::NoRegister)\n    {\n        m_writer.RecordFrameDisplayRegister(funcInfo->frameDisplayRegister);\n    }\n\n    // new.target may be used to construct the 'this' register so make sure to load it first\n    if (funcInfo->newTargetRegister != Js::Constants::NoRegister)\n    {\n        this->LoadNewTargetObject(funcInfo);\n    }\n\n    if (funcInfo->thisPointerRegister != Js::Constants::NoRegister)\n    {\n        this->LoadThisObject(funcInfo, thisLoadedFromParams);\n    }\n\n    this->RecordAllIntConstants(funcInfo);\n    this->RecordAllStrConstants(funcInfo);\n    this->RecordAllStringTemplateCallsiteConstants(funcInfo);\n\n    funcInfo->doubleConstantToRegister.Map([byteCodeFunction](double d, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordFloatConstant(byteCodeFunction->MapRegSlot(location), d);\n    });\n\n    if (funcInfo->GetHasArguments())\n    {\n        sym = funcInfo->GetArgumentsSymbol();\n        Assert(sym);\n        Assert(funcInfo->GetHasHeapArguments());\n\n        if (funcInfo->GetCallsEval() || (!funcInfo->GetApplyEnclosesArgs()))\n        {\n            this->LoadHeapArguments(funcInfo);\n        }\n\n    }\n    else if (!funcInfo->IsGlobalFunction() && !IsInNonDebugMode())\n    {\n        uint count = funcInfo->inArgsCount + (funcInfo->root->sxFnc.pnodeRest != nullptr ? 1 : 0) - 1;\n        if (count != 0)\n        {\n            Js::PropertyIdArray *propIds = RecyclerNewPlus(scriptContext->GetRecycler(), count * sizeof(Js::PropertyId), Js::PropertyIdArray, count, 0);\n\n            GetFormalArgsArray(this, funcInfo, propIds);\n            byteCodeFunction->SetPropertyIdsOfFormals(propIds);\n        }\n    }\n\n    //\n    // If the function is a function expression with a name,\n    // load the function object at runtime to its activation object.\n    //\n    sym = funcInfo->root->sxFnc.GetFuncSymbol();\n    bool funcExprWithName = !funcInfo->IsGlobalFunction() && sym && sym->GetIsFuncExpr();\n\n    if (funcExprWithName)\n    {\n        if (funcInfo->GetFuncExprNameReference() ||\n            (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject()))\n        {\n            //\n            // x = function f(...) { ... }\n            // A named function expression's name (Symbol:f) belongs to the enclosing scope.\n            // Thus there are no uses of 'f' within the scope of the function (as references to 'f'\n            // are looked up in the closure). So, we can't use f's register as it is from the enclosing\n            // scope's register namespace. So use a tmp register.\n            // In ES5 mode though 'f' is *not* a part of the enclosing scope. So we always assign 'f' a register\n            // from it's register namespace, which LdFuncExpr can use.\n            //\n            Js::RegSlot ldFuncExprDst = sym->GetLocation();\n            this->m_writer.Reg1(Js::OpCode::LdFuncExpr, ldFuncExprDst);\n\n            if (sym->IsInSlot(funcInfo))\n            {\n                Js::RegSlot scopeLocation;\n                AnalysisAssert(funcInfo->funcExprScope);\n\n                if (funcInfo->funcExprScope->GetIsObject())\n                {\n                    scopeLocation = funcInfo->funcExprScope->GetLocation();\n                    this->m_writer.Property(Js::OpCode::StFuncExpr, sym->GetLocation(), scopeLocation,\n                        funcInfo->FindOrAddReferencedPropertyId(sym->GetPosition()));\n                }\n                else if (funcInfo->bodyScope->GetIsObject())\n                {\n                    this->m_writer.ElementU(Js::OpCode::StLocalFuncExpr, sym->GetLocation(),\n                        funcInfo->FindOrAddReferencedPropertyId(sym->GetPosition()));\n                }\n                else\n                {\n                    Assert(sym->HasScopeSlot());\n                    this->m_writer.SlotI1(Js::OpCode::StLocalSlot, sym->GetLocation(),\n                                          sym->GetScopeSlot() + Js::ScopeSlots::FirstSlotIndex);\n                }\n            }\n            else if (ShouldTrackDebuggerMetadata())\n            {\n                funcInfo->byteCodeFunction->GetFunctionBody()->InsertSymbolToRegSlotList(sym->GetName(), sym->GetLocation(), funcInfo->varRegsCount);\n            }\n        }\n    }\n}\n\nvoid ByteCodeGenerator::InvalidateCachedOuterScopes(FuncInfo *funcInfo)\n{\n    Assert(funcInfo->GetEnvRegister() != Js::Constants::NoRegister);\n\n    // Walk the scope stack, from funcInfo outward, looking for scopes that have been cached.\n\n    Scope *scope = funcInfo->GetBodyScope()->GetEnclosingScope();\n    uint32 envIndex = 0;\n\n    while (scope && scope->GetFunc() == funcInfo)\n    {\n        // Skip over FuncExpr Scope and parameter scope for current funcInfo to get to the first enclosing scope of the outer function.\n        scope = scope->GetEnclosingScope();\n    }\n\n    for (; scope; scope = scope->GetEnclosingScope())\n    {\n        FuncInfo *func = scope->GetFunc();\n        if (scope == func->GetBodyScope())\n        {\n            if (func->Escapes() && func->GetHasCachedScope())\n            {\n                Assert(scope->GetIsObject());\n                this->m_writer.Unsigned1(Js::OpCode::InvalCachedScope, envIndex);\n            }\n        }\n        if (scope->GetMustInstantiate())\n        {\n            envIndex++;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::LoadThisObject(FuncInfo *funcInfo, bool thisLoadedFromParams)\n{\n    if (this->scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled() && funcInfo->IsClassConstructor())\n    {\n        // Derived class constructors initialize 'this' to be Undecl except \"extends null\" cases\n        //   - we'll check this value during a super call and during 'this' access\n        //\n        // Base class constructors or \"extends null\" cases initialize 'this' to a new object using new.target\n        if (funcInfo->IsBaseClassConstructor())\n        {\n            EmitBaseClassConstructorThisObject(funcInfo);\n        }\n        else\n        {\n            Js::ByteCodeLabel thisLabel = this->Writer()->DefineLabel();\n            Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n\n            Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n            this->Writer()->Reg1(Js::OpCode::LdFuncObj, tmpReg);\n            this->Writer()->BrReg1(Js::OpCode::BrOnBaseConstructorKind, thisLabel, tmpReg);  // branch when [[ConstructorKind]]==\"base\"\n            funcInfo->ReleaseTmpRegister(tmpReg);\n\n            this->m_writer.Reg1(Js::OpCode::InitUndecl, funcInfo->thisPointerRegister);  // not \"extends null\" case\n            this->Writer()->Br(Js::OpCode::Br, skipLabel);\n\n            this->Writer()->MarkLabel(thisLabel);\n            EmitBaseClassConstructorThisObject(funcInfo);  // \"extends null\" case\n\n            this->Writer()->MarkLabel(skipLabel);\n        }\n    }\n    else if (!funcInfo->IsGlobalFunction() || (this->flags & fscrEval))\n    {\n        //\n        // thisLoadedFromParams would be true for the event Handler case,\n        // \"this\" would have been loaded from parameters to put in the environment\n        //\n        if (!thisLoadedFromParams && !funcInfo->IsLambda())\n        {\n            m_writer.ArgIn0(funcInfo->thisPointerRegister);\n        }\n        if (!(this->flags & fscrEval) || !funcInfo->IsGlobalFunction())\n        {\n            // we don't want to emit 'this' for eval, because 'this' value in eval is equal to 'this' value of caller\n            // and does not depend on \"use strict\" inside of eval.\n            // so we pass 'this' directly in GlobalObject::EntryEval()\n            EmitThis(funcInfo, funcInfo->thisPointerRegister);\n        }\n    }\n    else\n    {\n        Assert(funcInfo->IsGlobalFunction());\n        Js::RegSlot root = funcInfo->nullConstantRegister;\n        EmitThis(funcInfo, root);\n    }\n}\n\nvoid ByteCodeGenerator::LoadNewTargetObject(FuncInfo *funcInfo)\n{\n    if (funcInfo->IsClassConstructor())\n    {\n        Assert(!funcInfo->IsLambda());\n\n        m_writer.ArgIn0(funcInfo->newTargetRegister);\n    }\n    else if (funcInfo->IsLambda() && !(this->flags & fscrEval))\n    {\n        Scope *scope;\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n        if (scope->GetFunc()->IsGlobalFunction())\n        {\n            m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);\n        }\n        else\n        {\n            Js::PropertyId slot = scope->GetFunc()->newTargetScopeSlot;\n            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->newTargetRegister);\n        }\n    }\n    else if ((funcInfo->IsGlobalFunction() || funcInfo->IsLambda()) && (this->flags & fscrEval))\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else if (funcInfo->NeedEnvRegister())\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor.\n            m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);\n            return;\n        }\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalNewTargetSymbol, false, false);\n        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->newTargetRegister, cacheId);\n    }\n    else if (funcInfo->IsGlobalFunction())\n    {\n        m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);\n    }\n    else\n    {\n        m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeSlotLoadThis(FuncInfo *funcInfo, Js::RegSlot regLoc, bool chkUndecl)\n{\n    FuncInfo* nonLambdaFunc = funcInfo;\n    if (funcInfo->IsLambda())\n    {\n        nonLambdaFunc = FindEnclosingNonLambda();\n    }\n\n    if (nonLambdaFunc->IsClassConstructor() && !nonLambdaFunc->IsBaseClassConstructor())\n    {\n        // If we are in a derived class constructor and we have a scope slot for 'this',\n        // we need to load 'this' from the scope slot. This is to support the case where\n        // the call to initialize 'this' via super() is inside a lambda since the lambda\n        // can't assign to the 'this' register of the parent constructor.\n        if (nonLambdaFunc->thisScopeSlot != Js::Constants::NoRegister)\n        {\n            Js::PropertyId slot = nonLambdaFunc->thisScopeSlot;\n\n            EmitInternalScopedSlotLoad(funcInfo, slot, regLoc, chkUndecl);\n        }\n        else if (funcInfo->thisPointerRegister != Js::Constants::NoRegister && chkUndecl)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);\n        }\n        else if (chkUndecl)\n        {\n            // If we don't have a scope slot for 'this' we know that super could not have\n            // been called inside a lambda so we can check to see if we called\n            // super and assigned to the this register already. If not, this should trigger\n            // a ReferenceError.\n            EmitUseBeforeDeclarationRuntimeError(this, Js::Constants::NoRegister);\n        }\n    }\n    else if (this->flags & fscrEval && (funcInfo->IsGlobalFunction() || (funcInfo->IsLambda() && nonLambdaFunc->IsGlobalFunction()))\n        && funcInfo->GetBodyScope()->GetIsObject())\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else if (funcInfo->NeedEnvRegister())\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor\n            return;\n        }\n\n        // CONSIDER [tawoll] - Should we add a ByteCodeGenerator flag (fscrEvalWithClassConstructorParent) and avoid doing this runtime check?\n        Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n        this->Writer()->BrReg1(Js::OpCode::BrNotUndecl_A, skipLabel, funcInfo->thisPointerRegister);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalThisSlotSymbol, false, false);\n        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->thisPointerRegister, cacheId);\n        if (chkUndecl)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);\n        }\n\n        this->Writer()->MarkLabel(skipLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitScopeSlotStoreThis(FuncInfo *funcInfo, Js::RegSlot regLoc, bool chkUndecl)\n{\n    if (this->flags & fscrEval && (funcInfo->IsGlobalFunction() || (funcInfo->IsLambda() && FindEnclosingNonLambda()->IsGlobalFunction())))\n    {\n        Js::RegSlot scopeLocation;\n\n        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n        {\n            scopeLocation = funcInfo->frameDisplayRegister;\n        }\n        else\n        {\n            scopeLocation = funcInfo->GetEnvRegister();\n        }\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalThisSlotSymbol, false, true);\n        this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo->byteCodeFunction->GetIsStrictMode()), funcInfo->thisPointerRegister, cacheId);\n    }\n    else if (regLoc != Js::Constants::NoRegister)\n    {\n        EmitInternalScopedSlotStore(funcInfo, regLoc, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitSuperCall(FuncInfo* funcInfo, ParseNode* pnode, BOOL fReturnValue)\n{\n    Assert(pnode->sxCall.pnodeTarget->nop == knopSuper);\n\n    FuncInfo* nonLambdaFunc = funcInfo;\n\n    if (funcInfo->IsLambda())\n    {\n        nonLambdaFunc = this->FindEnclosingNonLambda();\n    }\n\n    if (nonLambdaFunc->IsBaseClassConstructor())\n    {\n        // super() is not allowed in base class constructors. If we detect this, emit a ReferenceError and skip making the call.\n        this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_ClassSuperInBaseClass));\n        return;\n    }\n    else\n    {\n        EmitSuperFieldPatch(funcInfo, pnode, this);\n        pnode->isUsed = true;\n    }\n\n    // We already know pnode->sxCall.pnodeTarget->nop is super but we can't use the super register in case\n    // this is an eval and we will load super dynamically from the scope using ScopedLdHomeObj.\n    // That means we'll have to rely on the location of the call target to be sure.\n    // We have to make sure to allocate the location for the node now, before we try to branch on it.\n    Emit(pnode->sxCall.pnodeTarget, this, funcInfo, false, /*isConstructorCall*/ true); // reuse isConstructorCall (\"new super()\" is illegal)\n\n    //\n    // if (super is class constructor) {\n    //   _this = new.target;\n    // } else {\n    //   _this = NewScObjFull(new.target);\n    // }\n    //\n    // temp = super.call(_this, new.target); // CallFlag_New | CallFlag_NewTarget | CallFlag_ExtraArg\n    // if (temp is object) {\n    //   _this = temp;\n    // }\n    //\n    // if (UndeclBlockVar === this) {\n    //   this = _this;\n    // } else {\n    //   throw ReferenceError;\n    // }\n    //\n    funcInfo->AcquireLoc(pnode);\n    Js::RegSlot thisForSuperCall = funcInfo->AcquireTmpRegister();\n    Js::ByteCodeLabel useNewTargetForThisLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel makeCallLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel useSuperCallResultLabel = this->Writer()->DefineLabel();\n    Js::ByteCodeLabel doneLabel = this->Writer()->DefineLabel();\n\n    Js::RegSlot tmpReg = this->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnode->sxCall.pnodeTarget->location, funcInfo);\n    this->Writer()->BrReg1(Js::OpCode::BrOnClassConstructor, useNewTargetForThisLabel, tmpReg);\n\n    this->Writer()->Reg2(Js::OpCode::NewScObjectNoCtorFull, thisForSuperCall, funcInfo->newTargetRegister);\n    this->Writer()->Br(Js::OpCode::Br, makeCallLabel);\n\n    this->Writer()->MarkLabel(useNewTargetForThisLabel);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, thisForSuperCall, funcInfo->newTargetRegister);\n\n    this->Writer()->MarkLabel(makeCallLabel);\n    EmitCall(pnode, Js::Constants::NoRegister, this, funcInfo, fReturnValue, /*fEvaluateComponents*/ true, /*fHasNewTarget*/ true, thisForSuperCall);\n\n    // We have to use another temp for the this value before assigning to this register.\n    // This is because IRBuilder does not expect us to use the value of a temp after potentially assigning to that same temp.\n    // Ex:\n    // _this = new.target;\n    // temp = super.call(_this);\n    // if (temp is object) {\n    //   _this = temp; // creates a new sym for _this as it was previously used\n    // }\n    // this = _this; // tries to loads a value from the old sym (which is dead)\n    Js::RegSlot valueForThis = funcInfo->AcquireTmpRegister();\n\n    this->Writer()->BrReg1(Js::OpCode::BrOnObject_A, useSuperCallResultLabel, pnode->location);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, valueForThis, thisForSuperCall);\n    this->Writer()->Br(Js::OpCode::Br, doneLabel);\n    this->Writer()->MarkLabel(useSuperCallResultLabel);\n    this->Writer()->Reg2(Js::OpCode::Ld_A, valueForThis, pnode->location);\n    this->Writer()->MarkLabel(doneLabel);\n\n    // The call is done and we know what we will bind to 'this' so let's check to see if 'this' is already decl.\n    // We may need to load 'this' from the scope slot.\n    EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister, false);\n\n    Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();\n    Js::RegSlot tmpUndeclReg = funcInfo->AcquireTmpRegister();\n    this->Writer()->Reg1(Js::OpCode::InitUndecl, tmpUndeclReg);\n    this->Writer()->BrReg2(Js::OpCode::BrSrEq_A, skipLabel, funcInfo->thisPointerRegister, tmpUndeclReg);\n    funcInfo->ReleaseTmpRegister(tmpUndeclReg);\n\n    this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_ClassThisAlreadyAssigned));\n    this->Writer()->MarkLabel(skipLabel);\n\n    this->Writer()->Reg2(Js::OpCode::StrictLdThis, funcInfo->thisPointerRegister, valueForThis);\n    funcInfo->ReleaseTmpRegister(valueForThis);\n    funcInfo->ReleaseTmpRegister(thisForSuperCall);\n\n    // We already assigned the result of super() to the 'this' register but we need to store it in the scope slot, too. If there is one.\n    this->EmitScopeSlotStoreThis(funcInfo, nonLambdaFunc->thisScopeSlot);\n}\n\nvoid ByteCodeGenerator::EmitClassConstructorEndCode(FuncInfo *funcInfo)\n{\n    if (funcInfo->thisPointerRegister != Js::Constants::NoRegister)\n    {\n        // We need to try and load 'this' from the scope slot, if there is one.\n        EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister);\n        this->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitBaseClassConstructorThisObject(FuncInfo *funcInfo)\n{\n    this->Writer()->Reg2(Js::OpCode::NewScObjectNoCtorFull, funcInfo->thisPointerRegister, funcInfo->newTargetRegister);\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotLoad(FuncInfo *funcInfo, Js::RegSlot slot, Js::RegSlot symbolRegister, bool chkUndecl)\n{\n    Scope* scope = nullptr;\n\n    if (funcInfo->IsLambda())\n    {\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, symbolRegister, chkUndecl);\n    }\n    else\n    {\n        scope = funcInfo->GetBodyScope();\n\n        EmitInternalScopedSlotLoad(funcInfo, scope, -1, slot, symbolRegister, chkUndecl);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotLoad(FuncInfo *funcInfo, Scope *scope, Js::PropertyId envIndex, Js::RegSlot slot, Js::RegSlot symbolRegister, bool chkUndecl)\n{\n    Assert(slot != Js::Constants::NoProperty);\n    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, symbolRegister);\n    Js::OpCode opcode;\n\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    opcode = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n    slot += (scope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n    if (envIndex != -1)\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n    {\n        this->m_writer.SlotI1(opcode, symbolRegister, slot, profileId);\n    }\n    else\n    {\n        this->m_writer.Slot(opcode, symbolRegister, scopeLocation, slot, profileId);\n    }\n\n    if (chkUndecl)\n    {\n        this->m_writer.Reg1(Js::OpCode::ChkUndecl, symbolRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopedSlotStore(FuncInfo *funcInfo, Js::RegSlot slot, Js::RegSlot symbolRegister)\n{\n    Assert(slot != Js::Constants::NoProperty);\n\n    Scope* scope = nullptr;\n    Js::OpCode opcode;\n\n    Js::PropertyId envIndex = -1;\n    if (funcInfo->IsLambda())\n    {\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n    }\n    else\n    {\n        scope = funcInfo->GetBodyScope();\n    }\n\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    opcode = this->GetStSlotOp(scope, envIndex, scopeLocation, false, funcInfo);\n    slot += (scope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n    if (envIndex != -1)\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot);\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n    {\n        this->m_writer.SlotI1(opcode, symbolRegister, slot);\n    }\n    else if (scope->GetIsObject())\n    {\n        this->m_writer.Slot(opcode, symbolRegister, scopeLocation, slot);\n    }\n    else\n    {\n        this->m_writer.SlotI2(opcode, symbolRegister, scope->GetInnerScopeIndex(), slot);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInternalScopeObjInit(FuncInfo *funcInfo, Scope *scope, Js::RegSlot valueLocation, Js::PropertyId propertyId)\n{\n    Js::RegSlot scopeLocation = scope->GetLocation();\n    Js::OpCode opcode = this->GetInitFldOp(scope, scopeLocation, funcInfo);\n    if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n        this->m_writer.ElementP(opcode, valueLocation, cacheId);\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n        this->m_writer.ElementPIndexed(opcode, valueLocation, scope->GetInnerScopeIndex(), cacheId);\n    }\n    else\n    {\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n        this->m_writer.PatchableProperty(opcode, valueLocation, scopeLocation, cacheId);\n    }\n}\n\nvoid ByteCodeGenerator::GetEnclosingNonLambdaScope(FuncInfo *funcInfo, Scope * &scope, Js::PropertyId &envIndex)\n{\n    Assert(funcInfo->IsLambda());\n    envIndex = -1;\n    for (scope = GetCurrentScope(); scope; scope = scope->GetEnclosingScope())\n    {\n        if (scope->GetMustInstantiate() && scope->GetFunc() != funcInfo)\n        {\n            envIndex++;\n        }\n        if (((scope == scope->GetFunc()->GetBodyScope() || scope == scope->GetFunc()->GetParamScope()) && !scope->GetFunc()->IsLambda()) || scope->IsGlobalEvalBlockScope())\n        {\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitThis(FuncInfo *funcInfo, Js::RegSlot fromRegister)\n{\n    if (funcInfo->IsLambda())\n    {\n        Scope *scope;\n        Js::PropertyId envIndex = -1;\n        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n        FuncInfo* parent = scope->GetFunc();\n\n        if (parent->IsGlobalFunction())\n        {\n            if (this->flags & fscrEval)\n            {\n                scope = parent->GetGlobalEvalBlockScope();\n                Js::PropertyId slot = parent->thisScopeSlot;\n                EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);\n            }\n            else\n            {\n                // Always load global object via LdThis of null to get the possibly protected via secureHostObject global object.\n                this->m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, funcInfo->nullConstantRegister, this->GetModuleID());\n            }\n        }\n        else if (!parent->IsClassConstructor() || parent->IsBaseClassConstructor())\n        {\n            // In a lambda inside a derived class constructor, 'this' should be loaded from the scope slot whenever 'this' is accessed.\n            // It's safe to load 'this' into the register for base class constructors because there is no complex assignment to 'this'\n            // via super call chain.\n            Js::PropertyId slot = parent->thisScopeSlot;\n            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);\n        }\n    }\n    else if (funcInfo->byteCodeFunction->GetIsStrictMode() && (!funcInfo->IsGlobalFunction() || this->flags & fscrEval))\n    {\n        m_writer.Reg2(Js::OpCode::StrictLdThis, funcInfo->thisPointerRegister, fromRegister);\n    }\n    else\n    {\n        m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, fromRegister, this->GetModuleID());\n    }\n}\n\nvoid ByteCodeGenerator::EmitLoadFormalIntoRegister(ParseNode *pnodeFormal, Js::RegSlot pos, FuncInfo *funcInfo)\n{\n    if (pnodeFormal->IsVarLetOrConst())\n    {\n        // Get the param from its argument position into its assigned register.\n        // The position should match the location, otherwise, it has been shadowed by parameter with the same name\n        Symbol *formal = pnodeFormal->sxVar.sym;\n        if (formal->GetLocation() + 1 == pos)\n        {\n            // Transfer to the frame object, etc., if necessary.\n            this->EmitLocalPropInit(formal->GetLocation(), formal, funcInfo);\n        }\n\n        if (ShouldTrackDebuggerMetadata() && !formal->IsInSlot(funcInfo))\n        {\n            Assert(!formal->GetHasInit());\n            funcInfo->GetParsedFunctionBody()->InsertSymbolToRegSlotList(formal->GetName(), formal->GetLocation(), funcInfo->varRegsCount);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::HomeArguments(FuncInfo *funcInfo)\n{\n    // Transfer formal parameters to their home locations on the local frame.\n    if (funcInfo->GetHasArguments())\n    {\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            // Since we don't have to iterate over arguments here, we'll trust the location to be correct.\n            EmitLoadFormalIntoRegister(funcInfo->root->sxFnc.pnodeRest, funcInfo->root->sxFnc.pnodeRest->sxVar.sym->GetLocation() + 1, funcInfo);\n        }\n\n        // The arguments object creation helper does this work for us.\n        return;\n    }\n\n    Js::ArgSlot pos = 1;\n    auto loadFormal = [&](ParseNode *pnodeFormal)\n    {\n        EmitLoadFormalIntoRegister(pnodeFormal, pos, funcInfo);\n        pos++;\n    };\n    MapFormals(funcInfo->root, loadFormal);\n}\n\nvoid ByteCodeGenerator::DefineLabels(FuncInfo *funcInfo)\n{\n    funcInfo->singleExit = m_writer.DefineLabel();\n    SList<ParseNode *>::Iterator iter(&funcInfo->targetStatements);\n    while (iter.Next())\n    {\n        ParseNode * node = iter.Data();\n        node->sxStmt.breakLabel = m_writer.DefineLabel();\n        node->sxStmt.continueLabel = m_writer.DefineLabel();\n        node->emitLabels = true;\n    }\n}\n\nvoid ByteCodeGenerator::EmitGlobalBody(FuncInfo *funcInfo)\n{\n    // Emit global code (global scope or eval), fixing up the return register with the implicit\n    // return value.\n    ParseNode *pnode = funcInfo->root->sxFnc.pnodeBody;\n    ParseNode *pnodeLastVal = funcInfo->root->sxProg.pnodeLastValStmt;\n    if (pnodeLastVal == nullptr)\n    {\n        // We're not guaranteed to compute any values, so fix up the return register at the top\n        // in case.\n        this->m_writer.Reg1(Js::OpCode::LdUndef, ReturnRegister);\n    }\n\n    while (pnode->nop == knopList)\n    {\n        ParseNode *stmt = pnode->sxBin.pnode1;\n        if (stmt == pnodeLastVal)\n        {\n            pnodeLastVal = nullptr;\n        }\n        if (pnodeLastVal == nullptr && (this->flags & fscrReturnExpression))\n        {\n            EmitTopLevelStatement(stmt, funcInfo, true);\n        }\n        else\n        {\n            // Haven't hit the post-dominating return value yet,\n            // so don't bother with the return register.\n            EmitTopLevelStatement(stmt, funcInfo, false);\n        }\n        pnode = pnode->sxBin.pnode2;\n    }\n    EmitTopLevelStatement(pnode, funcInfo, false);\n}\n\nvoid ByteCodeGenerator::EmitFunctionBody(FuncInfo *funcInfo)\n{\n    // Emit a function body. Only explicit returns and the implicit \"undef\" at the bottom\n    // get copied to the return register.\n    ParseNode *pnodeBody = funcInfo->root->sxFnc.pnodeBody;\n    ParseNode *pnode = pnodeBody;\n    while (pnode->nop == knopList)\n    {\n        ParseNode *stmt = pnode->sxBin.pnode1;\n        if (stmt->CapturesSyms())\n        {\n            CapturedSymMap *map = funcInfo->EnsureCapturedSymMap();\n            SList<Symbol*> *list = map->Item(stmt);\n            FOREACH_SLIST_ENTRY(Symbol*, sym, list)\n            {\n                if (!sym->GetIsCommittedToSlot())\n                {\n                    Assert(sym->GetLocation() != Js::Constants::NoProperty);\n                    sym->SetIsCommittedToSlot();\n                    ParseNode *decl = sym->GetDecl();\n                    Assert(decl);\n                    if (PHASE_TRACE(Js::DelayCapturePhase, funcInfo->byteCodeFunction))\n                    {\n                        Output::Print(_u(\"--- DelayCapture: Committed symbol '%s' to slot.\\n\"), sym->GetName());\n                        Output::Flush();\n                    }\n                    // REVIEW[ianhall]: HACK to work around this causing an error due to sym not yet being initialized\n                    // what is this doing? Why are we assigning sym to itself?\n                    bool old = sym->GetNeedDeclaration();\n                    sym->SetNeedDeclaration(false);\n                    this->EmitPropStore(sym->GetLocation(), sym, sym->GetPid(), funcInfo, decl->nop == knopLetDecl, decl->nop == knopConstDecl);\n                    sym->SetNeedDeclaration(old);\n                }\n            }\n            NEXT_SLIST_ENTRY;\n        }\n        EmitTopLevelStatement(stmt, funcInfo, false);\n        pnode = pnode->sxBin.pnode2;\n    }\n    Assert(!pnode->CapturesSyms());\n    EmitTopLevelStatement(pnode, funcInfo, false);\n}\n\nvoid ByteCodeGenerator::EmitProgram(ParseNode *pnodeProg)\n{\n    // Indicate that the binding phase is over.\n    this->isBinding = false;\n    this->trackEnvDepth = true;\n    AssignPropertyIds(pnodeProg->sxFnc.funcInfo->byteCodeFunction);\n\n    int32 initSize = this->maxAstSize / AstBytecodeRatioEstimate;\n\n    // Use the temp allocator in bytecode write temp buffer.\n    m_writer.InitData(this->alloc, initSize);\n\n#ifdef LOG_BYTECODE_AST_RATIO\n    // log the max Ast size\n    Output::Print(_u(\"Max Ast size: %d\"), initSize);\n#endif\n\n    Assert(pnodeProg && pnodeProg->nop == knopProg);\n\n    if (this->parentScopeInfo)\n    {\n        // Scope stack is already set up the way we want it, so don't visit the global scope.\n        // Start emitting with the nested scope (i.e., the deferred function).\n        this->EmitScopeList(pnodeProg->sxProg.pnodeScopes);\n    }\n    else\n    {\n        this->EmitScopeList(pnodeProg);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInitCapturedThis(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        // Ensure space for the this slot\n        this->EmitInternalScopeObjInit(funcInfo, scope, funcInfo->thisPointerRegister, Js::PropertyIds::_lexicalThisSlotSymbol);\n    }\n    else\n    {\n        this->EmitInternalScopedSlotStore(funcInfo, funcInfo->thisScopeSlot, funcInfo->thisPointerRegister);\n    }\n}\n\nvoid ByteCodeGenerator::EmitInitCapturedNewTarget(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        // Ensure space for the new.target slot\n        this->EmitInternalScopeObjInit(funcInfo, scope, funcInfo->newTargetRegister, Js::PropertyIds::_lexicalNewTargetSymbol);\n    }\n    else\n    {\n        this->EmitInternalScopedSlotStore(funcInfo, funcInfo->newTargetScopeSlot, funcInfo->newTargetRegister);\n    }\n}\n\nvoid EmitDestructuredObject(ParseNode *lhs, Js::RegSlot rhsLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\nvoid EmitDestructuredValueOrInitializer(ParseNodePtr lhsElementNode, Js::RegSlot rhsLocation, ParseNodePtr initializer, bool isNonPatternAssignmentTarget, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo);\n\nvoid ByteCodeGenerator::PopulateFormalsScope(uint beginOffset, FuncInfo *funcInfo, ParseNode *pnode)\n{\n    Js::DebuggerScope *debuggerScope = nullptr;\n    auto processArg = [&](ParseNode *pnodeArg) {\n        if (pnodeArg->IsVarLetOrConst())\n        {\n            if (debuggerScope == nullptr)\n            {\n                debuggerScope = RecordStartScopeObject(pnode, funcInfo->paramScope && funcInfo->paramScope->GetIsObject() ? Js::DiagParamScopeInObject : Js::DiagParamScope);\n                debuggerScope->SetBegin(beginOffset);\n            }\n\n            debuggerScope->AddProperty(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym->EnsurePosition(funcInfo), Js::DebuggerScopePropertyFlags_None);\n        }\n    };\n\n    MapFormals(pnode, processArg);\n    MapFormalsFromPattern(pnode, processArg);\n\n    if (debuggerScope != nullptr)\n    {\n        RecordEndScopeObject(pnode);\n    }\n}\n\nvoid ByteCodeGenerator::EmitDefaultArgs(FuncInfo *funcInfo, ParseNode *pnode)\n{\n    uint beginOffset = m_writer.GetCurrentOffset();\n\n    auto emitDefaultArg = [&](ParseNode *pnodeArg)\n    {\n        if (pnodeArg->nop == knopParamPattern)\n        {\n            this->StartStatement(pnodeArg);\n\n            Assert(pnodeArg->sxParamPattern.location != Js::Constants::NoRegister);\n            ParseNodePtr pnode1 = pnodeArg->sxParamPattern.pnode1;\n\n            if (pnode1->IsPattern())\n            {\n                EmitAssignment(nullptr, pnode1, pnodeArg->sxParamPattern.location, this, funcInfo);\n            }\n            else\n            {\n                Assert(pnode1->nop == knopAsg);\n                Assert(pnode1->sxBin.pnode1->IsPattern());\n                EmitDestructuredValueOrInitializer(pnode1->sxBin.pnode1,\n                    pnodeArg->sxParamPattern.location,\n                    pnode1->sxBin.pnode2,\n                    false /*isNonPatternAssignmentTarget*/,\n                    this,\n                    funcInfo);\n            }\n            this->EndStatement(pnodeArg);\n            return;\n        }\n        else if (pnodeArg->IsVarLetOrConst())\n        {\n            Js::RegSlot location = pnodeArg->sxVar.sym->GetLocation();\n\n            if (pnodeArg->sxVar.pnodeInit == nullptr)\n            {\n                // Since the formal hasn't been initialized in LdLetHeapArguments, we'll initialize it here.\n                pnodeArg->sxVar.sym->SetNeedDeclaration(false);\n                EmitPropStore(location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                return;\n            }\n\n            // Load the default argument if we got undefined, skip RHS evaluation otherwise.\n            Js::ByteCodeLabel noDefaultLabel = this->m_writer.DefineLabel();\n            Js::ByteCodeLabel endLabel = this->m_writer.DefineLabel();\n            this->StartStatement(pnodeArg);\n            // Let us use strict not equal to differentiate between null and undefined\n            m_writer.BrReg2(Js::OpCode::BrSrNeq_A, noDefaultLabel, location, funcInfo->undefinedConstantRegister);\n\n            Emit(pnodeArg->sxVar.pnodeInit, this, funcInfo, false);\n            pnodeArg->sxVar.sym->SetNeedDeclaration(false); // After emit to prevent foo(a = a)\n\n            if (funcInfo->GetHasArguments() && pnodeArg->sxVar.sym->IsInSlot(funcInfo))\n            {\n                EmitPropStore(pnodeArg->sxVar.pnodeInit->location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                m_writer.Br(endLabel);\n            }\n            else\n            {\n                EmitAssignment(nullptr, pnodeArg, pnodeArg->sxVar.pnodeInit->location, this, funcInfo);\n            }\n\n            funcInfo->ReleaseLoc(pnodeArg->sxVar.pnodeInit);\n\n            m_writer.MarkLabel(noDefaultLabel);\n\n            if (funcInfo->GetHasArguments() && pnodeArg->sxVar.sym->IsInSlot(funcInfo))\n            {\n                EmitPropStore(location, pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo, true);\n\n                m_writer.MarkLabel(endLabel);\n            }\n\n            this->EndStatement(pnodeArg);\n        }\n    };\n\n    // If the function is async, we wrap the default arguments in a try catch and reject a Promise in case of error.\n    if (pnode->sxFnc.IsAsync())\n    {\n        uint cacheId;\n        Js::ByteCodeLabel catchLabel = m_writer.DefineLabel();\n        Js::ByteCodeLabel doneLabel = m_writer.DefineLabel();\n        Js::RegSlot catchArgLocation = funcInfo->AcquireTmpRegister();\n        Js::RegSlot promiseLocation = funcInfo->AcquireTmpRegister();\n        Js::RegSlot rejectLocation = funcInfo->AcquireTmpRegister();\n\n        // try\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n        m_writer.Br(Js::OpCode::TryCatch, catchLabel);\n\n        // Rest cannot have a default argument, so we ignore it.\n        MapFormalsWithoutRest(pnode, emitDefaultArg);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n        m_writer.Empty(Js::OpCode::Leave);\n        m_writer.Br(doneLabel);\n\n        // catch\n        m_writer.MarkLabel(catchLabel);\n        m_writer.Reg1(Js::OpCode::Catch, catchArgLocation);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n        m_writer.Empty(Js::OpCode::Nop);\n\n        // return Promise.reject(error);\n        cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(Js::PropertyIds::Promise, false, false);\n        m_writer.PatchableRootProperty(Js::OpCode::LdRootFld, promiseLocation, cacheId, false, false);\n\n        EmitInvoke(rejectLocation, promiseLocation, Js::PropertyIds::reject, this, funcInfo, catchArgLocation);\n\n        m_writer.Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, rejectLocation);\n\n        m_writer.RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n        m_writer.Empty(Js::OpCode::Leave);\n        m_writer.Br(funcInfo->singleExit);\n        m_writer.Empty(Js::OpCode::Leave);\n\n        m_writer.MarkLabel(doneLabel);\n\n        this->SetHasTry(true);\n\n        funcInfo->ReleaseTmpRegister(rejectLocation);\n        funcInfo->ReleaseTmpRegister(promiseLocation);\n        funcInfo->ReleaseTmpRegister(catchArgLocation);\n    }\n    else\n    {\n        // Rest cannot have a default argument, so we ignore it.\n        MapFormalsWithoutRest(pnode, emitDefaultArg);\n    }\n\n    if (m_writer.GetCurrentOffset() > beginOffset)\n    {\n        PopulateFormalsScope(beginOffset, funcInfo, pnode);\n    }\n}\n\nvoid ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n{\n    Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));\n    FuncInfo *funcInfo = pnode->sxFnc.funcInfo;\n    Assert(funcInfo != nullptr);\n\n    if (funcInfo->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;\n    deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));\n    deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),\n        funcInfo->root,\n        !!(this->flags & fscrEvalCode),\n        ((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));\n\n    deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);\n    if (pnode->sxFnc.HasDefaultArguments())\n    {\n        deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);\n    }\n\n    if (funcInfo->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            deferParseFunction->BuildDeferredStubs(funcInfo->root);\n        }\n        Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // We've now done a full parse of this function, so we no longer need to remember the extents\n    // and attributes of the top-level nested functions. (The above code has run for all of those,\n    // so they have pointers to the stub sub-trees they need.)\n    byteCodeFunction->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!funcInfo->IsGlobalFunction())\n        {\n            // Note: Do not set the stack nested func flag if the function has been redeferred and recompiled.\n            // In that case the flag already has the value we want.\n            if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)\n            {\n#if DBG\n                byteCodeFunction->SetCanDoStackNestedFunc();\n#endif\n                if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    byteCodeFunction->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (byteCodeFunction->DoStackNestedFunc())\n        {\n            uint nestedCount = byteCodeFunction->GetNestedCount();\n            for (uint i = 0; i < nestedCount; i++)\n            {\n                Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);\n                if (nested->IsFunctionBody())\n                {\n                    nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (byteCodeFunction->GetByteCode() != nullptr)\n        {\n            // Previously compiled function nested within a re-deferred and re-compiled function.\n            return;\n        }\n\n        // Bug : 301517\n        // In the debug mode the hasOnlyThis optimization needs to be disabled, since user can break in this function\n        // and do operation on 'this' and its property, which may not be defined yet.\n        if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            byteCodeFunction->SetHasOnlyThisStmts(true);\n        }\n\n        if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))\n            {\n                bool applyEnclosesArgs = true;\n                for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)\n                {\n                    Symbol* sym = pnodeVar->sxVar.sym;\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                    {\n                        applyEnclosesArgs = false;\n                        break;\n                    }\n                }\n                auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)\n                {\n                    if (*applyEnclosesArgs)\n                    {\n                        for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)\n                        {\n                            Symbol* sym = lexvar->sxVar.sym;\n                            if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                            {\n                                *applyEnclosesArgs = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);\n                funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);\n            }\n        }\n\n        InitScopeSlotArray(funcInfo);\n        FinalizeRegisters(funcInfo, byteCodeFunction);\n        DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);\n\n        // Reserve temp registers for the inner scopes. We prefer temps because the JIT will then renumber them\n        // and see different lifetimes. (Note that debug mode requires permanent registers. See FinalizeRegisters.)\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n            if (innerScopeCount)\n            {\n                funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());\n                for (uint i = 1; i < innerScopeCount; i++)\n                {\n                    funcInfo->AcquireTmpRegister();\n                }\n            }\n        }\n\n        funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,\n            alloc,\n            funcInfo->RegCount() // Pass the actual register count. // TODO: Check if we can reduce this count\n            );\n        funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n\n        byteCodeFunction->AllocateLiteralRegexArray();\n        m_callSiteId = 0;\n        m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), funcInfo);\n\n        this->inPrologue = true;\n\n        // Class constructors do not have a [[call]] slot but we don't implement a generic way to express this.\n        // What we do is emit a check for the new flag here. If we don't have CallFlags_New set, the opcode will throw.\n        // We need to do this before emitting 'this' since the base class constructor will try to construct a new object.\n        if (funcInfo->IsClassConstructor())\n        {\n            m_writer.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* currentScope = funcInfo->GetCurrentChildScope();\n        Scope* paramScope = funcInfo->GetParamScope();\n        Scope* bodyScope = funcInfo->GetBodyScope();\n\n        // For now, emit all constant loads at top of function (should instead put in closest dominator of uses).\n        LoadAllConstants(funcInfo);\n        HomeArguments(funcInfo);\n\n        if (!currentScope->GetCanMergeWithBodyScope())\n        {\n            byteCodeFunction->SetParamAndBodyScopeNotMerged();\n\n            // Pop the body scope before emitting the default args\n            PopScope();\n            Assert(this->GetCurrentScope() == paramScope);\n        }\n\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            byteCodeFunction->SetHasRestParameter();\n        }\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))\n        {\n            EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);\n        }\n\n        // Any function with a super reference or an eval call inside a method or a constructor needs to load super,\n        if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))\n            // unless we are already inside the 'global' scope inside an eval (in which case 'ScopedLdHomeObj' is emitted at every 'super' reference).\n            && !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))\n        {\n            if (funcInfo->IsLambda())\n            {\n                Scope *scope;\n                Js::PropertyId envIndex = -1;\n                GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n                FuncInfo* parent = scope->GetFunc();\n\n                if (!parent->IsGlobalFunction())\n                {\n                    // lambda in non-global scope (eval and non-eval)\n                    EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);\n                    if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & fscrEval))\n                {\n                    // lambda in non-eval global scope\n                    m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);\n                }\n                // lambda in eval global scope: ScopedLdHomeObj will handle error throwing\n            }\n            else\n            {\n                m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);\n\n                if (funcInfo->superCtorRegister != Js::Constants::NoRegister) // super() is allowed only in derived class constructors\n                {\n                    m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);\n                }\n\n                if (!funcInfo->IsGlobalFunction())\n                {\n                    if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        // Stash the super reference in case something inside the eval or lambda references it.\n                        uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n                        }\n                    }\n                    else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        // While the diag locals walker will pick up super from scoped slots or an activation object,\n                        // it will not pick it up when it is only in a register.\n                        byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(funcInfo, bodyScope);\n        }\n\n        // We don't want to load super if we are already in an eval. ScopedLdHomeObj will take care of loading super in that case.\n        if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())\n        {\n            if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);\n            }\n\n            if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);\n            }\n        }\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        ::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        DefineLabels(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n\n            EmitDefaultArgs(funcInfo, pnode);\n\n            if (!currentScope->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == paramScope);\n                // Push the body scope\n                PushScope(bodyScope);\n\n                funcInfo->SetCurrentChildScope(bodyScope);\n\n                // Mark the beginning of the body scope so that new scope slots can be created.\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(funcInfo);\n\n        // Emit all scope-wide function definitions before emitting function bodies\n        // so that calls may reference functions they precede lexically.\n        // Note, global eval scope is a fake local scope and is handled as if it were\n        // a lexical block instead of a true global scope, so do not define the functions\n        // here. They will be defined during BeginEmitBlock.\n        if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            // This only handles function declarations, which param scope cannot have any.\n            DefineFunctions(funcInfo);\n        }\n\n        DefineUserVars(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))\n        {\n            // If we didn't create a scope object and didn't have default args, we still need to transfer the formals to their slots.\n            MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });\n        }\n\n        // Rest needs to trigger use before declaration until all default args have been processed.\n        if (pnode->sxFnc.pnodeRest != nullptr)\n        {\n            pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n        {\n            // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n            // We have to do this after the rest param is marked as false for need declaration.\n            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n            paramScope->ForEachSymbol([&](Symbol* param) {\n                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));\n                if (param->GetIsArguments() && !funcInfo->GetHasArguments())\n                {\n                    // Do not copy the arguments to the body if it is not used\n                }\n                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol\n                                                                     // is expected to stay inside the function expression scope\n                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))\n                {\n                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                    // Walking the scope chain is not possible at this time.\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))\n                    {\n                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);\n                    }\n\n                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            });\n\n            // In split scope as the body has a separate closure we have to copy the value of this and other special slots\n            // from param scope to the body scope\n            auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)\n            {\n                if (dest != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = src;\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(op, tempReg, slot);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            };\n            copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n\n        this->inPrologue = false;\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EmitGlobalBody(funcInfo);\n        }\n        else\n        {\n            EmitFunctionBody(funcInfo);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n        ::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        if (!this->IsInDebugMode())\n        {\n            // Release the temp registers that we reserved for inner scopes above.\n            if (innerScopeCount)\n            {\n                Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;\n                for (uint i = 0; i < innerScopeCount; i++)\n                {\n                    funcInfo->ReleaseTmpRegister(tmpReg);\n                    tmpReg--;\n                }\n            }\n        }\n\n        Assert(funcInfo->firstTmpReg == firstTmpReg);\n        Assert(funcInfo->curTmpReg == firstTmpReg);\n        Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());\n\n        byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);\n        byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);\n        byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());\n\n        // Do a uint32 add just to verify that we haven't overflowed the reg slot type.\n        UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);\n\n#if DBG_DUMP\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                m_writer.ByteCodeDataSize(),\n                m_writer.AuxiliaryDataSize(),\n                m_writer.AuxiliaryContextDataSize(),\n                m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),\n                funcInfo->name);\n\n            this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(funcInfo);\n        this->MapReferencedPropertyIds(funcInfo);\n\n        Assert(this->TopFuncInfo() == funcInfo);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        m_writer.SetCallSiteCount(m_callSiteId);\n#ifdef LOG_BYTECODE_AST_RATIO\n        m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);\n#else\n        m_writer.End();\n#endif\n    }\n    catch (...)\n    {\n        // Failed to generate byte-code for this function body (likely OOM or stack overflow). Notify the function body so that\n        // it can revert intermediate state changes that may have taken place during byte code generation before the failure.\n        byteCodeFunction->ResetByteCodeGenState();\n        m_writer.Reset();\n        throw;\n    }\n\n#ifdef PERF_HINT\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())\n    {\n        if (byteCodeFunction->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);\n        }\n\n        if (funcInfo->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);\n        }\n        else if (funcInfo->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);\n        }\n    }\n#endif\n\n\n    byteCodeFunction->SetInitialDefaultEntryPoint();\n    byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode()) // debug mode mismatch\n    {\n        if (m_utf8SourceInfo->GetIsLibraryCode())\n        {\n            Assert(!byteCodeFunction->IsInDebugMode()); // Library script byteCode is never in debug mode\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if DBG_DUMP\n    if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        pnode->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(byteCodeFunction);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))\n    {\n        byteCodeFunction->DumpScopes();\n    }\n#endif\n#if ENABLE_NATIVE_CODEGEN\n    if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);\n    }\n#endif\n}\n\nvoid ByteCodeGenerator::MapCacheIdsToPropertyIds(FuncInfo *funcInfo)\n{\n    Js::FunctionBody *functionBody = funcInfo->GetParsedFunctionBody();\n    uint rootObjectLoadInlineCacheStart = funcInfo->GetInlineCacheCount();\n    uint rootObjectLoadMethodInlineCacheStart = rootObjectLoadInlineCacheStart + funcInfo->GetRootObjectLoadInlineCacheCount();\n    uint rootObjectStoreInlineCacheStart = rootObjectLoadMethodInlineCacheStart + funcInfo->GetRootObjectLoadMethodInlineCacheCount();\n    uint totalFieldAccessInlineCacheCount = rootObjectStoreInlineCacheStart + funcInfo->GetRootObjectStoreInlineCacheCount();\n\n    functionBody->CreateCacheIdToPropertyIdMap(rootObjectLoadInlineCacheStart, rootObjectLoadMethodInlineCacheStart,\n        rootObjectStoreInlineCacheStart, totalFieldAccessInlineCacheCount, funcInfo->GetIsInstInlineCacheCount());\n\n    if (totalFieldAccessInlineCacheCount == 0)\n    {\n        return;\n    }\n\n    funcInfo->inlineCacheMap->Map([functionBody](Js::RegSlot regSlot, FuncInfo::InlineCacheIdMap *inlineCacheIdMap)\n    {\n        inlineCacheIdMap->Map([functionBody](Js::PropertyId propertyId, FuncInfo::InlineCacheList* inlineCacheList)\n        {\n            if (inlineCacheList)\n            {\n                inlineCacheList->Iterate([functionBody, propertyId](InlineCacheUnit cacheUnit)\n                {\n                    CompileAssert(offsetof(InlineCacheUnit, cacheId) == offsetof(InlineCacheUnit, loadCacheId));\n                    if (cacheUnit.loadCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.loadCacheId, propertyId);\n                    }\n                    if (cacheUnit.loadMethodCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.loadMethodCacheId, propertyId);\n                    }\n                    if (cacheUnit.storeCacheId != -1)\n                    {\n                        functionBody->SetPropertyIdForCacheId(cacheUnit.storeCacheId, propertyId);\n                    }\n                });\n            }\n        });\n    });\n\n    funcInfo->rootObjectLoadInlineCacheMap->Map([functionBody, rootObjectLoadInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectLoadInlineCacheStart, propertyId);\n    });\n    funcInfo->rootObjectLoadMethodInlineCacheMap->Map([functionBody, rootObjectLoadMethodInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectLoadMethodInlineCacheStart, propertyId);\n    });\n    funcInfo->rootObjectStoreInlineCacheMap->Map([functionBody, rootObjectStoreInlineCacheStart](Js::PropertyId propertyId, uint cacheId)\n    {\n        functionBody->SetPropertyIdForCacheId(cacheId + rootObjectStoreInlineCacheStart, propertyId);\n    });\n\n    SListBase<uint>::Iterator valueOfIter(&funcInfo->valueOfStoreCacheIds);\n    while (valueOfIter.Next())\n    {\n        functionBody->SetPropertyIdForCacheId(valueOfIter.Data(), Js::PropertyIds::valueOf);\n    }\n\n    SListBase<uint>::Iterator toStringIter(&funcInfo->toStringStoreCacheIds);\n    while (toStringIter.Next())\n    {\n        functionBody->SetPropertyIdForCacheId(toStringIter.Data(), Js::PropertyIds::toString);\n    }\n\n#if DBG\n    functionBody->VerifyCacheIdToPropertyIdMap();\n#endif\n}\n\nvoid ByteCodeGenerator::MapReferencedPropertyIds(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *functionBody = funcInfo->GetParsedFunctionBody();\n    uint referencedPropertyIdCount = funcInfo->GetReferencedPropertyIdCount();\n    functionBody->CreateReferencedPropertyIdMap(referencedPropertyIdCount);\n\n    funcInfo->referencedPropertyIdToMapIndex->Map([functionBody](Js::PropertyId propertyId, uint mapIndex)\n    {\n        functionBody->SetReferencedPropertyIdWithMapIndex(mapIndex, propertyId);\n    });\n\n#if DBG\n    functionBody->VerifyReferencedPropertyIdMap();\n#endif\n}\n\nvoid ByteCodeGenerator::EmitScopeList(ParseNode *pnode, ParseNode *breakOnBodyScopeNode)\n{\n    while (pnode)\n    {\n        if (breakOnBodyScopeNode != nullptr && breakOnBodyScopeNode == pnode)\n        {\n            break;\n        }\n\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n#ifdef ASMJS_PLAT\n            if (pnode->sxFnc.GetAsmjsMode())\n            {\n                Js::ExclusiveContext context(this, GetScriptContext());\n                if (Js::AsmJSCompiler::Compile(&context, pnode, pnode->sxFnc.pnodeParams))\n                {\n                    pnode = pnode->sxFnc.pnodeNext;\n                    break;\n                }\n                else if (CONFIG_FLAG(AsmJsStopOnError))\n                {\n                    exit(JSERR_AsmJsCompileError);\n                }\n                else\n                {\n                    // if asm.js parse error happened, reparse with asm.js disabled.\n                    throw Js::AsmJsParseException();\n                }\n            }\n#endif\n            // FALLTHROUGH\n        case knopProg:\n            if (pnode->sxFnc.funcInfo)\n            {\n                FuncInfo* funcInfo = pnode->sxFnc.funcInfo;\n                Scope* paramScope = funcInfo->GetParamScope();\n\n                if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n                {\n                    funcInfo->SetCurrentChildScope(paramScope);\n                }\n                else\n                {\n                    funcInfo->SetCurrentChildScope(funcInfo->GetBodyScope());\n                }\n                this->StartEmitFunction(pnode);\n\n                // Persist outer func scope info if nested func is deferred\n                if (CONFIG_FLAG(DeferNested))\n                {\n                    FuncInfo* parentFunc = TopFuncInfo();\n                    Js::ScopeInfo::SaveScopeInfoForDeferParse(this, parentFunc, funcInfo);\n                    PushFuncInfo(_u(\"StartEmitFunction\"), funcInfo);\n                }\n\n                if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n                {\n                    // Before emitting the body scoped functions let us switch the special scope slot to use the body ones\n                    pnode->sxFnc.funcInfo->UseInnerSpecialScopeSlots();\n                    this->EmitScopeList(pnode->sxFnc.pnodeBodyScope->sxBlock.pnodeScopes);\n                }\n                else\n                {\n                    this->EmitScopeList(pnode->sxFnc.pnodeScopes);\n                }\n\n                this->EmitOneFunction(pnode);\n                this->EndEmitFunction(pnode);\n\n                Assert(pnode->sxFnc.pnodeBody == nullptr || funcInfo->isReused || funcInfo->GetCurrentChildScope() == funcInfo->GetBodyScope());\n                funcInfo->SetCurrentChildScope(nullptr);\n            }\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n\n        case knopBlock:\n            this->StartEmitBlock(pnode);\n            this->EmitScopeList(pnode->sxBlock.pnodeScopes);\n            this->EndEmitBlock(pnode);\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n\n        case knopCatch:\n            this->StartEmitCatch(pnode);\n            this->EmitScopeList(pnode->sxCatch.pnodeScopes);\n            this->EndEmitCatch(pnode);\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n\n        case knopWith:\n            this->StartEmitWith(pnode);\n            this->EmitScopeList(pnode->sxWith.pnodeScopes);\n            this->EndEmitWith(pnode);\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n\n        default:\n            AssertMsg(false, \"Unexpected opcode in tree of scopes\");\n            break;\n        }\n    }\n}\n\nvoid EnsureFncDeclScopeSlot(ParseNode *pnodeFnc, FuncInfo *funcInfo)\n{\n    if (pnodeFnc->sxFnc.pnodeName)\n    {\n        Assert(pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl);\n        Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n        // If this function is shadowing the arguments symbol in body then skip it.\n        // We will allocate scope slot for the arguments symbol during EmitLocalPropInit.\n        if (sym && !sym->GetIsArguments())\n        {\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n}\n\n// Similar to EnsureFncScopeSlot visitor function, but verifies that a slot is needed before assigning it.\nvoid CheckFncDeclScopeSlot(ParseNode *pnodeFnc, FuncInfo *funcInfo)\n{\n    if (pnodeFnc->sxFnc.pnodeName && pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl)\n    {\n        Assert(pnodeFnc->sxFnc.pnodeName->nop == knopVarDecl);\n        Symbol *sym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n        if (sym && sym->NeedsSlotAlloc(funcInfo))\n        {\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EnsureSpecialScopeSlots(FuncInfo* funcInfo, Scope* scope)\n{\n    if (scope->GetIsObject())\n    {\n        if (funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n\n        if (((!funcInfo->IsLambda() && funcInfo->GetCallsEval())\n            || funcInfo->isSuperLexicallyCaptured))\n        {\n            if (funcInfo->superRegister != Js::Constants::NoRegister)\n            {\n                funcInfo->EnsureSuperScopeSlot();\n            }\n\n            if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n            {\n                funcInfo->EnsureSuperCtorScopeSlot();\n            }\n        }\n\n        if (funcInfo->isNewTargetLexicallyCaptured)\n        {\n            funcInfo->EnsureNewTargetScopeSlot();\n        }\n    }\n    else\n    {\n        // Don't rely on the Emit() pass to assign scope slots where needed, because peeps/shortcuts\n        // may cause some expressions not to be emitted. Assign the slots we need before we start\n        // emitting the prolog.\n        // TODO: Investigate moving detection of non-local references to Emit() so we don't assign\n        // slots to symbols that are never referenced in emitted code.\n\n        if (funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n\n        if (funcInfo->isSuperLexicallyCaptured)\n        {\n            funcInfo->EnsureSuperScopeSlot();\n        }\n\n        if (funcInfo->isSuperCtorLexicallyCaptured)\n        {\n            funcInfo->EnsureSuperCtorScopeSlot();\n        }\n\n        if (funcInfo->isNewTargetLexicallyCaptured)\n        {\n            funcInfo->EnsureNewTargetScopeSlot();\n        }\n    }\n}\n\nvoid ByteCodeGenerator::InitSpecialScopeSlots(FuncInfo* funcInfo)\n{\n    if (funcInfo->bodyScope->GetIsObject())\n    {\n        // In split scope make sure to do init fld for the duplicate special scope slots\n        if (funcInfo->innerThisScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_lexicalThisSlotSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->thisPointerRegister, cacheId);\n        }\n        if (funcInfo->innerSuperScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n        }\n        if (funcInfo->innerSuperCtorScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n        }\n        if (funcInfo->innerNewTargetScopeSlot != Js::Constants::NoProperty)\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->bodyScope->GetLocation(), Js::PropertyIds::_lexicalNewTargetSymbol, false, true);\n            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->newTargetRegister, cacheId);\n        }\n    }\n}\n\nvoid ByteCodeGenerator::StartEmitFunction(ParseNode *pnodeFnc)\n{\n    Assert(pnodeFnc->nop == knopFncDecl || pnodeFnc->nop == knopProg);\n\n    FuncInfo *funcInfo = pnodeFnc->sxFnc.funcInfo;\n\n    if (funcInfo->byteCodeFunction->IsFunctionParsed())\n    {\n        if (!(flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n        {\n            // Only set the environment depth if it's truly known (i.e., not in eval or event handler).\n            funcInfo->GetParsedFunctionBody()->SetEnvDepth(this->envDepth);\n        }\n\n        if (pnodeFnc->sxFnc.FIBPreventsDeferral())\n        {\n            for (Scope *scope = this->currentScope; scope; scope = scope->GetEnclosingScope())\n            {\n                if (scope->GetScopeType() != ScopeType_FunctionBody && \n                    scope->GetScopeType() != ScopeType_Global &&\n                    scope->GetScopeType() != ScopeType_GlobalEvalBlock &&\n                    scope->GetMustInstantiate())\n                {\n                    funcInfo->byteCodeFunction->SetAttributes((Js::FunctionInfo::Attributes)(funcInfo->byteCodeFunction->GetAttributes() & ~Js::FunctionInfo::Attributes::CanDefer));\n                    break;\n                }\n            }\n        }\n    }\n\n    if (funcInfo->GetCallsEval())\n    {\n        funcInfo->byteCodeFunction->SetDontInline(true);\n    }\n\n    Scope * const funcExprScope = funcInfo->funcExprScope;\n    if (funcExprScope)\n    {\n        if (funcInfo->GetCallsEval())\n        {\n            Assert(funcExprScope->GetIsObject());\n        }\n\n        if (funcExprScope->GetIsObject())\n        {\n            funcExprScope->SetCapturesAll(true);\n            funcExprScope->SetMustInstantiate(true);\n            PushScope(funcExprScope);\n        }\n        else\n        {\n            Symbol *sym = funcInfo->root->sxFnc.GetFuncSymbol();\n            if (funcInfo->paramScope->GetCanMergeWithBodyScope())\n            {\n                funcInfo->bodyScope->AddSymbol(sym);\n            }\n            else\n            {\n                funcInfo->paramScope->AddSymbol(sym);\n            }\n            sym->EnsureScopeSlot(funcInfo);\n        }\n    }\n\n    Scope * const bodyScope = funcInfo->GetBodyScope();\n    Scope * const paramScope = funcInfo->GetParamScope();\n\n    if (pnodeFnc->nop != knopProg)\n    {\n        if (!bodyScope->GetIsObject() && NeedObjectAsFunctionScope(funcInfo, pnodeFnc))\n        {\n            Assert(bodyScope->GetIsObject());\n        }\n\n        if (bodyScope->GetIsObject())\n        {\n            bodyScope->SetLocation(funcInfo->frameObjRegister);\n        }\n        else\n        {\n            bodyScope->SetLocation(funcInfo->frameSlotsRegister);\n        }\n\n        if (!paramScope->GetCanMergeWithBodyScope())\n        {\n            if (paramScope->GetIsObject())\n            {\n                paramScope->SetLocation(funcInfo->frameObjRegister);\n            }\n            else\n            {\n                paramScope->SetLocation(funcInfo->frameSlotsRegister);\n            }\n        }\n\n        if (bodyScope->GetIsObject())\n        {\n            // Win8 908700: Disable under F12 debugger because there are too many cached scopes holding onto locals.\n            funcInfo->SetHasCachedScope(\n                !PHASE_OFF(Js::CachedScopePhase, funcInfo->byteCodeFunction) &&\n                !funcInfo->Escapes() &&\n                funcInfo->frameObjRegister != Js::Constants::NoRegister &&\n                !ApplyEnclosesArgs(pnodeFnc, this) &&\n                funcInfo->paramScope->GetCanMergeWithBodyScope() && // There is eval in the param scope\n                (PHASE_FORCE(Js::CachedScopePhase, funcInfo->byteCodeFunction) || !IsInDebugMode())\n#if ENABLE_TTD\n                && !funcInfo->GetParsedFunctionBody()->GetScriptContext()->GetThreadContext()->IsRuntimeInTTDMode()\n#endif\n            );\n\n            if (funcInfo->GetHasCachedScope())\n            {\n                Assert(funcInfo->funcObjRegister == Js::Constants::NoRegister);\n                Symbol *funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n                if (funcSym && funcSym->GetIsFuncExpr())\n                {\n                    if (funcSym->GetLocation() == Js::Constants::NoRegister)\n                    {\n                        funcInfo->funcObjRegister = funcInfo->NextVarRegister();\n                    }\n                    else\n                    {\n                        funcInfo->funcObjRegister = funcSym->GetLocation();\n                    }\n                }\n                else\n                {\n                    funcInfo->funcObjRegister = funcInfo->NextVarRegister();\n                }\n                Assert(funcInfo->funcObjRegister != Js::Constants::NoRegister);\n            }\n\n            ParseNode *pnode;\n            Symbol *sym;\n\n            if (funcInfo->GetHasArguments())\n            {\n                // Process function's formal parameters\n                MapFormals(pnodeFnc, [&](ParseNode *pnode)\n                {\n                    if (pnode->IsVarLetOrConst())\n                    {\n                        pnode->sxVar.sym->EnsureScopeSlot(funcInfo);\n                    }\n                });\n\n                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });\n\n                // Only allocate scope slot for \"arguments\" when really necessary. \"hasDeferredChild\"\n                // doesn't require scope slot for \"arguments\" because inner functions can't access\n                // outer function's arguments directly.\n                sym = funcInfo->GetArgumentsSymbol();\n                Assert(sym);\n                if (sym->NeedsSlotAlloc(funcInfo))\n                {\n                    sym->EnsureScopeSlot(funcInfo);\n                }\n            }\n\n            sym = funcInfo->root->sxFnc.GetFuncSymbol();\n\n            if (sym && sym->NeedsSlotAlloc(funcInfo))\n            {\n                if (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject())\n                {\n                    sym->SetScopeSlot(0);\n                }\n                else if (funcInfo->GetFuncExprNameReference())\n                {\n                    sym->EnsureScopeSlot(funcInfo);\n                }\n            }\n\n            if (!funcInfo->GetHasArguments())\n            {\n                Symbol *formal;\n                Js::ArgSlot pos = 1;\n                auto moveArgToReg = [&](ParseNode *pnode)\n                {\n                    if (pnode->IsVarLetOrConst())\n                    {\n                        formal = pnode->sxVar.sym;\n                        // Get the param from its argument position into its assigned register.\n                        // The position should match the location; otherwise, it has been shadowed by parameter with the same name.\n                        if (formal->GetLocation() + 1 == pos)\n                        {\n                            pnode->sxVar.sym->EnsureScopeSlot(funcInfo);\n                        }\n                    }\n                    pos++;\n                };\n                MapFormals(pnodeFnc, moveArgToReg);\n                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });\n            }\n\n            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);\n\n            auto ensureFncDeclScopeSlots = [&](ParseNode *pnodeScope)\n            {\n                for (pnode = pnodeScope; pnode;)\n                {\n                    switch (pnode->nop)\n                    {\n                    case knopFncDecl:\n                        if (pnode->sxFnc.IsDeclaration())\n                        {\n                            EnsureFncDeclScopeSlot(pnode, funcInfo);\n                        }\n                        pnode = pnode->sxFnc.pnodeNext;\n                        break;\n                    case knopBlock:\n                        pnode = pnode->sxBlock.pnodeNext;\n                        break;\n                    case knopCatch:\n                        pnode = pnode->sxCatch.pnodeNext;\n                        break;\n                    case knopWith:\n                        pnode = pnode->sxWith.pnodeNext;\n                        break;\n                    }\n                }\n            };\n            pnodeFnc->sxFnc.MapContainerScopes(ensureFncDeclScopeSlots);\n\n            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n            {\n                sym = pnode->sxVar.sym;\n                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n                {\n                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                    {\n                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                    }\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments()\n                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            }\n\n            if (pnodeFnc->sxFnc.pnodeBody)\n            {\n                Assert(pnodeFnc->sxFnc.pnodeScopes->nop == knopBlock);\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);\n            }\n        }\n        else\n        {\n            ParseNode *pnode;\n            Symbol *sym;\n\n            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);\n\n            pnodeFnc->sxFnc.MapContainerScopes([&](ParseNode *pnodeScope) { this->EnsureFncScopeSlots(pnodeScope, funcInfo); });\n\n            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n            {\n                sym = pnode->sxVar.sym;\n                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))\n                {\n                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n                    {\n                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n                    }\n                    if (sym->GetSymbolType() == STVariable && sym->NeedsSlotAlloc(funcInfo) && !sym->GetIsArguments()\n                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            }\n\n            auto ensureScopeSlot = [&](ParseNode *pnode)\n            {\n                if (pnode->IsVarLetOrConst())\n                {\n                    sym = pnode->sxVar.sym;\n                    if (sym->GetSymbolType() == STFormal && sym->NeedsSlotAlloc(funcInfo))\n                    {\n                        sym->EnsureScopeSlot(funcInfo);\n                    }\n                }\n            };\n            // Process function's formal parameters\n            MapFormals(pnodeFnc, ensureScopeSlot);\n            MapFormalsFromPattern(pnodeFnc, ensureScopeSlot);\n\n            if (funcInfo->GetHasArguments())\n            {\n                sym = funcInfo->GetArgumentsSymbol();\n                Assert(sym);\n\n                // There is no eval so the arguments may be captured in a lambda.\n                // But we cannot relay on slots getting allocated while the lambda is emitted as the function body may be reparsed.\n                sym->EnsureScopeSlot(funcInfo);\n            }\n\n            if (pnodeFnc->sxFnc.pnodeBody)\n            {\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeScopes, funcInfo);\n                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);\n            }\n        }\n\n        if (!paramScope->GetCanMergeWithBodyScope() && bodyScope->GetScopeSlotCount() == 0 && !bodyScope->GetHasOwnLocalInClosure())\n        {\n            // When we have split scope the body scope may be wrongly marked as must instantiate even though the capture occurred\n            // in param scope. This check is to make sure if no capture occurs in body scope make in not must instantiate.\n            bodyScope->SetMustInstantiate(false);\n        }\n        else\n        {\n            bodyScope->SetMustInstantiate(funcInfo->frameObjRegister != Js::Constants::NoRegister || funcInfo->frameSlotsRegister != Js::Constants::NoRegister);\n        }\n        paramScope->SetMustInstantiate(!paramScope->GetCanMergeWithBodyScope());\n    }\n    else\n    {\n        bool newScopeForEval = (funcInfo->byteCodeFunction->GetIsStrictMode() && (this->GetFlags() & fscrEval));\n\n        if (newScopeForEval)\n        {\n            Assert(bodyScope->GetIsObject());\n        }\n    }\n\n    if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n    {\n        ParseNodePtr paramBlock = pnodeFnc->sxFnc.pnodeScopes;\n        Assert(paramBlock->nop == knopBlock && paramBlock->sxBlock.blockType == Parameter);\n\n        PushScope(paramScope);\n\n        // While emitting the functions we have to stop when we see the body scope block.\n        // Otherwise functions defined in the body scope will not be able to get the right references.\n        this->EmitScopeList(paramBlock->sxBlock.pnodeScopes, pnodeFnc->sxFnc.pnodeBodyScope);\n        Assert(this->GetCurrentScope() == paramScope);\n    }\n\n    PushScope(bodyScope);\n}\n\nvoid ByteCodeGenerator::EmitModuleExportAccess(Symbol* sym, Js::OpCode opcode, Js::RegSlot location, FuncInfo* funcInfo)\n{\n    if (EnsureSymbolModuleSlots(sym, funcInfo))\n    {\n        this->Writer()->SlotI2(opcode, location, sym->GetModuleIndex(), sym->GetScopeSlot());\n    }\n    else\n    {\n        this->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(ERRInvalidExportName));\n\n        if (opcode == Js::OpCode::LdModuleSlot)\n        {\n            this->Writer()->Reg1(Js::OpCode::LdUndef, location);\n        }\n    }\n}\n\nbool ByteCodeGenerator::EnsureSymbolModuleSlots(Symbol* sym, FuncInfo* funcInfo)\n{\n    Assert(sym->GetIsModuleExportStorage());\n\n    if (sym->GetModuleIndex() != Js::Constants::NoProperty && sym->GetScopeSlot() != Js::Constants::NoProperty)\n    {\n        return true;\n    }\n\n    Js::JavascriptLibrary* library = this->GetScriptContext()->GetLibrary();\n    library->EnsureModuleRecordList();\n    uint moduleIndex = this->GetModuleID();\n    uint moduleSlotIndex;\n    Js::SourceTextModuleRecord* moduleRecord = library->GetModuleRecord(moduleIndex);\n\n    if (sym->GetIsModuleImport())\n    {\n        Js::PropertyId localImportNameId = sym->EnsurePosition(funcInfo);\n        Js::ModuleNameRecord* moduleNameRecord = nullptr;\n        if (!moduleRecord->ResolveImport(localImportNameId, &moduleNameRecord))\n        {\n            return false;\n        }\n\n        AnalysisAssert(moduleNameRecord != nullptr);\n        Assert(moduleNameRecord->module->IsSourceTextModuleRecord());\n        Js::SourceTextModuleRecord* resolvedModuleRecord = (Js::SourceTextModuleRecord*)moduleNameRecord->module;\n\n        moduleIndex = resolvedModuleRecord->GetModuleId();\n        moduleSlotIndex = resolvedModuleRecord->GetLocalExportSlotIndexByLocalName(moduleNameRecord->bindingName);\n    }\n    else\n    {\n        Js::PropertyId exportNameId = sym->EnsurePosition(funcInfo);\n        moduleSlotIndex = moduleRecord->GetLocalExportSlotIndexByLocalName(exportNameId);\n    }\n\n    sym->SetModuleIndex(moduleIndex);\n    sym->SetScopeSlot(moduleSlotIndex);\n\n    return true;\n}\n\nvoid ByteCodeGenerator::EmitAssignmentToDefaultModuleExport(ParseNode* pnode, FuncInfo* funcInfo)\n{\n    // We are assigning pnode to the default export of the current module.\n    uint moduleIndex = this->GetModuleID();\n\n    Js::JavascriptLibrary* library = this->GetScriptContext()->GetLibrary();\n    library->EnsureModuleRecordList();\n    Js::SourceTextModuleRecord* moduleRecord = library->GetModuleRecord(moduleIndex);\n    uint moduleSlotIndex = moduleRecord->GetLocalExportSlotIndexByExportName(Js::PropertyIds::default_);\n\n    this->Writer()->SlotI2(Js::OpCode::StModuleSlot, pnode->location, moduleIndex, moduleSlotIndex);\n}\n\nvoid ByteCodeGenerator::EnsureLetConstScopeSlots(ParseNode *pnodeBlock, FuncInfo *funcInfo)\n{\n    bool callsEval = pnodeBlock->sxBlock.GetCallsEval() || pnodeBlock->sxBlock.GetChildCallsEval();\n    auto ensureLetConstSlots = ([this, funcInfo, callsEval](ParseNode *pnode)\n    {\n        Symbol *sym = pnode->sxVar.sym;\n        if (callsEval || sym->NeedsSlotAlloc(funcInfo))\n        {\n            sym->EnsureScopeSlot(funcInfo);\n            this->ProcessCapturedSym(sym);\n        }\n    });\n    IterateBlockScopedVariables(pnodeBlock, ensureLetConstSlots);\n}\n\nvoid ByteCodeGenerator::EnsureFncScopeSlots(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    while (pnode)\n    {\n        switch (pnode->nop)\n        {\n        case knopFncDecl:\n            if (pnode->sxFnc.IsDeclaration())\n            {\n                CheckFncDeclScopeSlot(pnode, funcInfo);\n            }\n            pnode = pnode->sxFnc.pnodeNext;\n            break;\n        case knopBlock:\n            pnode = pnode->sxBlock.pnodeNext;\n            break;\n        case knopCatch:\n            pnode = pnode->sxCatch.pnodeNext;\n            break;\n        case knopWith:\n            pnode = pnode->sxWith.pnodeNext;\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitFunction(ParseNode *pnodeFnc)\n{\n    Assert(pnodeFnc->nop == knopFncDecl || pnodeFnc->nop == knopProg);\n    Assert(pnodeFnc->nop == knopFncDecl && currentScope->GetEnclosingScope() != nullptr || pnodeFnc->nop == knopProg);\n\n    PopScope(); // function body\n\n    FuncInfo *funcInfo = pnodeFnc->sxFnc.funcInfo;\n\n    Scope* paramScope = funcInfo->paramScope;\n    if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n    {\n        Assert(this->GetCurrentScope() == paramScope);\n        PopScope(); // Pop the param scope\n    }\n\n    Scope *scope = funcInfo->funcExprScope;\n    if (scope && scope->GetMustInstantiate())\n    {\n        Assert(currentScope == scope);\n        PopScope();\n    }\n\n    if (CONFIG_FLAG(DeferNested))\n    {\n        Assert(funcInfo == this->TopFuncInfo());\n        PopFuncInfo(_u(\"EndEmitFunction\"));\n    }\n}\n\nvoid ByteCodeGenerator::StartEmitCatch(ParseNode *pnodeCatch)\n{\n    Assert(pnodeCatch->nop == knopCatch);\n\n    Scope *scope = pnodeCatch->sxCatch.scope;\n    FuncInfo *funcInfo = scope->GetFunc();\n\n    // Catch scope is a dynamic object if it can be passed to a scoped lookup helper (i.e., eval is present or we're in an event handler).\n    if (funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n    {\n        scope->SetIsObject();\n    }\n\n    if (pnodeCatch->sxCatch.pnodeParam->nop == knopParamPattern)\n    {\n        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval());\n        scope->SetMustInstantiate(scope->Count() > 0 && (scope->GetMustInstantiate() || scope->GetCapturesAll() || funcInfo->IsGlobalFunction()));\n\n        Parser::MapBindIdentifier(pnodeCatch->sxCatch.pnodeParam->sxParamPattern.pnode1, [&](ParseNodePtr item)\n        {\n            Symbol *sym = item->sxVar.sym;\n            if (funcInfo->IsGlobalFunction())\n            {\n                sym->SetIsGlobalCatch(true);\n            }\n\n            Assert(sym->GetScopeSlot() == Js::Constants::NoProperty);\n            if (sym->NeedsSlotAlloc(funcInfo))\n            {\n                sym->EnsureScopeSlot(funcInfo);\n            }\n        });\n\n        // In the case of pattern we will always going to push the scope.\n        PushScope(scope);\n    }\n    else\n    {\n        Symbol *sym = pnodeCatch->sxCatch.pnodeParam->sxPid.sym;\n\n        // Catch object is stored in the catch scope if there may be an ambiguous lookup or a var declaration that hides it.\n        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || sym->GetHasNonLocalReference());\n        scope->SetMustInstantiate(scope->GetCapturesAll() || funcInfo->IsGlobalFunction());\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            sym->SetIsGlobalCatch(true);\n        }\n\n        if (scope->GetMustInstantiate())\n        {\n            if (sym->IsInSlot(funcInfo))\n            {\n                // Since there is only one symbol we are pushing to slot.\n                // Also in order to make IsInSlot to return true - forcing the sym-has-non-local-reference.\n                this->ProcessCapturedSym(sym);\n                sym->EnsureScopeSlot(funcInfo);\n            }\n        }\n\n        PushScope(scope);\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitCatch(ParseNode *pnodeCatch)\n{\n    Assert(pnodeCatch->nop == knopCatch);\n    Assert(currentScope == pnodeCatch->sxCatch.scope);\n    PopScope();\n}\n\nvoid ByteCodeGenerator::StartEmitBlock(ParseNode *pnodeBlock)\n{\n    if (!BlockHasOwnScope(pnodeBlock, this))\n    {\n        return;\n    }\n\n    Assert(pnodeBlock->nop == knopBlock);\n\n    PushBlock(pnodeBlock);\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (pnodeBlock->sxBlock.GetCallsEval() || pnodeBlock->sxBlock.GetChildCallsEval() || (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))\n    {\n        Assert(scope->GetIsObject());\n    }\n\n    // TODO: Consider nested deferred parsing.\n    if (scope->GetMustInstantiate())\n    {\n        FuncInfo *funcInfo = scope->GetFunc();\n        if (scope->IsGlobalEvalBlockScope() && funcInfo->isThisLexicallyCaptured)\n        {\n            funcInfo->EnsureThisScopeSlot();\n        }\n        this->EnsureFncScopeSlots(pnodeBlock->sxBlock.pnodeScopes, funcInfo);\n        this->EnsureLetConstScopeSlots(pnodeBlock, funcInfo);\n        PushScope(scope);\n    }\n}\n\nvoid ByteCodeGenerator::EndEmitBlock(ParseNode *pnodeBlock)\n{\n    if (!BlockHasOwnScope(pnodeBlock, this))\n    {\n        return;\n    }\n\n    Assert(pnodeBlock->nop == knopBlock);\n\n    Scope *scope = pnodeBlock->sxBlock.scope;\n    if (scope && scope->GetMustInstantiate())\n    {\n        Assert(currentScope == pnodeBlock->sxBlock.scope);\n        PopScope();\n    }\n\n    PopBlock();\n}\n\nvoid ByteCodeGenerator::StartEmitWith(ParseNode *pnodeWith)\n{\n    Assert(pnodeWith->nop == knopWith);\n\n    Scope *scope = pnodeWith->sxWith.scope;\n\n    Assert(scope->GetIsObject());\n\n    PushScope(scope);\n}\n\nvoid ByteCodeGenerator::EndEmitWith(ParseNode *pnodeWith)\n{\n    Assert(pnodeWith->nop == knopWith);\n    Assert(currentScope == pnodeWith->sxWith.scope);\n\n    PopScope();\n}\n\nJs::RegSlot ByteCodeGenerator::PrependLocalScopes(Js::RegSlot evalEnv, Js::RegSlot tempLoc, FuncInfo *funcInfo)\n{\n    Scope *currScope = this->currentScope;\n    Scope *funcScope = funcInfo->GetCurrentChildScope() ? funcInfo->GetCurrentChildScope() : funcInfo->GetBodyScope();\n\n    if (currScope == funcScope)\n    {\n        return evalEnv;\n    }\n\n    bool acquireTempLoc = tempLoc == Js::Constants::NoRegister;\n    if (acquireTempLoc)\n    {\n        tempLoc = funcInfo->AcquireTmpRegister();\n    }\n\n    // The with/catch objects must be prepended to the environment we pass to eval() or to a func declared inside with,\n    // but the list must first be reversed so that innermost scopes appear first in the list.\n    while (currScope != funcScope)\n    {\n        Scope *innerScope;\n        for (innerScope = currScope; innerScope->GetEnclosingScope() != funcScope; innerScope = innerScope->GetEnclosingScope())\n            ;\n        if (innerScope->GetMustInstantiate())\n        {\n            if (!innerScope->HasInnerScopeIndex())\n            {\n                if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n                {\n                    this->m_writer.Reg2(Js::OpCode::LdInnerFrameDisplayNoParent, tempLoc, innerScope->GetLocation());\n                }\n                else\n                {\n                    this->m_writer.Reg3(Js::OpCode::LdInnerFrameDisplay, tempLoc, innerScope->GetLocation(), evalEnv);\n                }\n            }\n            else\n            {\n                if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n                {\n                    this->m_writer.Reg1Unsigned1(Js::OpCode::LdIndexedFrameDisplayNoParent, tempLoc, innerScope->GetInnerScopeIndex());\n                }\n                else\n                {\n                    this->m_writer.Reg2Int1(Js::OpCode::LdIndexedFrameDisplay, tempLoc, evalEnv, innerScope->GetInnerScopeIndex());\n                }\n            }\n            evalEnv = tempLoc;\n        }\n        funcScope = innerScope;\n    }\n\n    if (acquireTempLoc)\n    {\n        funcInfo->ReleaseTmpRegister(tempLoc);\n    }\n    return evalEnv;\n}\n\nvoid ByteCodeGenerator::EmitLoadInstance(Symbol *sym, IdentPtr pid, Js::RegSlot *pThisLocation, Js::RegSlot *pInstLocation, FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::RegSlot thisLocation = *pThisLocation;\n    Js::RegSlot instLocation = *pInstLocation;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym != nullptr && sym->GetIsModuleExportStorage())\n    {\n        *pInstLocation = Js::Constants::NoRegister;\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n\n        if (scope != symScope)\n        {\n            // We're not sure where the function is (eval/with/etc).\n            // So we're going to need registers to hold the instance where we (dynamically) find\n            // the function, and possibly to hold the \"this\" pointer we will pass to it.\n            // Assign them here so that they can't overlap with the scopeLocation assigned below.\n            // Otherwise we wind up with temp lifetime confusion in the IRBuilder. (Win8 281689)\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = funcInfo->AcquireTmpRegister();\n                // The \"this\" pointer will not be the same as the instance, so give it its own register.\n                thisLocation = funcInfo->AcquireTmpRegister();\n            }\n        }\n\n        if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj, tmpReg,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::OpCode op = unwrapWithObj ? Js::OpCode::UnwrapWithObj : Js::OpCode::Ld_A;\n\n            this->m_writer.Reg2(op, instLocation, tmpReg);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg2(op, thisLocation, tmpReg);\n            }\n\n            funcInfo->ReleaseTmpRegister(tmpReg);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            Assert(scope->GetIsObject());\n            this->m_writer.Reg1(Js::OpCode::LdLocalObj, instLocation);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg1(Js::OpCode::LdLocalObj, thisLocation);\n            }\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::OpCode op = unwrapWithObj ? Js::OpCode::UnwrapWithObj : Js::OpCode::Ld_A;\n            this->m_writer.Reg2(op, instLocation, scopeLocation);\n            if (thisLocation != Js::Constants::NoRegister)\n            {\n                this->m_writer.Reg2(op, thisLocation, scopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        if (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents))\n        {\n            // Load of a symbol with unknown scope from within eval.\n            // Get it from the closure environment.\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = funcInfo->AcquireTmpRegister();\n            }\n\n            // TODO: It should be possible to avoid this double call to ScopedLdInst by having it return both\n            // results at once. The reason for the uncertainty here is that we don't know whether the callee\n            // belongs to a \"with\" object. If it does, we have to pass the \"with\" object as \"this\"; in all other\n            // cases, we pass \"undefined\". For now, there are apparently no significant performance issues.\n            Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n            if (thisLocation == Js::Constants::NoRegister)\n            {\n                thisLocation = funcInfo->AcquireTmpRegister();\n            }\n            this->m_writer.ScopedProperty2(Js::OpCode::ScopedLdInst, instLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId), thisLocation);\n        }\n        else\n        {\n            if (instLocation == Js::Constants::NoRegister)\n            {\n                instLocation = ByteCodeGenerator::RootObjectRegister;\n            }\n            else\n            {\n                this->m_writer.Reg2(Js::OpCode::Ld_A, instLocation, ByteCodeGenerator::RootObjectRegister);\n            }\n\n            if (thisLocation == Js::Constants::NoRegister)\n            {\n                thisLocation = funcInfo->undefinedConstantRegister;\n            }\n            else\n            {\n                this->m_writer.Reg2(Js::OpCode::Ld_A, thisLocation, funcInfo->undefinedConstantRegister);\n            }\n        }\n    }\n    else if (instLocation != Js::Constants::NoRegister)\n    {\n        if (envIndex != -1)\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj, instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.Reg1Unsigned1(Js::OpCode::LdInnerScope, instLocation, scope->GetInnerScopeIndex());\n        }\n        else if (symScope != funcInfo->GetBodyScope())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, instLocation, scopeLocation);\n        }\n        else\n        {\n            Assert(funcInfo->frameObjRegister != Js::Constants::NoRegister);\n            this->m_writer.Reg1(Js::OpCode::LdLocalObj, instLocation);\n        }\n\n        if (thisLocation != Js::Constants::NoRegister)\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, thisLocation, funcInfo->undefinedConstantRegister);\n        }\n        else\n        {\n            thisLocation = funcInfo->undefinedConstantRegister;\n        }\n    }\n\n    *pThisLocation = thisLocation;\n    *pInstLocation = instLocation;\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitGlobalFncDeclInit(Js::RegSlot rhsLocation, Js::PropertyId propertyId, FuncInfo * funcInfo)\n{\n    // Note: declared variables and assignments in the global function go to the root object directly.\n    if (this->flags & fscrEval)\n    {\n        // Func decl's always get their init values before any use, so we don't pre-initialize the property to undef.\n        // That means that we have to use ScopedInitFld so that we initialize the property on the right instance\n        // even if the instance doesn't have the property yet (i.e., collapse the init-to-undef and the store\n        // into one operation). See WOOB 1121763 and 1120973.\n        this->m_writer.ScopedProperty(Js::OpCode::ScopedInitFunc, rhsLocation,\n            funcInfo->FindOrAddReferencedPropertyId(propertyId));\n    }\n    else\n    {\n        this->EmitPatchableRootProperty(Js::OpCode::InitRootFld, rhsLocation, propertyId, false, true, funcInfo);\n    }\n}\n\nvoid\nByteCodeGenerator::EmitPatchableRootProperty(Js::OpCode opcode,\n    Js::RegSlot regSlot, Js::PropertyId propertyId, bool isLoadMethod, bool isStore, FuncInfo * funcInfo)\n{\n    uint cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, isLoadMethod, isStore);\n    this->m_writer.PatchableRootProperty(opcode, regSlot, cacheId, isLoadMethod, isStore);\n}\n\nvoid ByteCodeGenerator::EmitLocalPropInit(Js::RegSlot rhsLocation, Symbol *sym, FuncInfo *funcInfo)\n{\n    Scope *scope = sym->GetScope();\n\n    // Check consistency of sym->IsInSlot.\n    Assert(sym->NeedsSlotAlloc(funcInfo) || sym->GetScopeSlot() == Js::Constants::NoProperty);\n\n    // Arrived at the scope in which the property was defined.\n    if (sym->NeedsSlotAlloc(funcInfo))\n    {\n        // The property is in memory rather than register. We'll have to load it from the slots.\n        if (scope->GetIsObject())\n        {\n            Assert(!this->TopFuncInfo()->GetParsedFunctionBody()->DoStackNestedFunc());\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n            Js::RegSlot objReg;\n            if (scope->HasInnerScopeIndex())\n            {\n                objReg = funcInfo->InnerScopeToRegSlot(scope);\n            }\n            else\n            {\n                objReg = scope->GetLocation();\n            }\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(objReg, propertyId, false, true);\n            Js::OpCode op = this->GetInitFldOp(scope, objReg, funcInfo, sym->GetIsNonSimpleParameter());\n            if (objReg != Js::Constants::NoRegister && objReg == funcInfo->frameObjRegister)\n            {\n                this->m_writer.ElementP(op, rhsLocation, cacheId);\n            }\n            else if (scope->HasInnerScopeIndex())\n            {\n                this->m_writer.ElementPIndexed(op, rhsLocation, scope->GetInnerScopeIndex(), cacheId);\n            }\n            else\n            {\n                this->m_writer.PatchableProperty(op, rhsLocation, scope->GetLocation(), cacheId);\n            }\n        }\n        else\n        {\n            // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            Js::RegSlot slotReg = scope->GetCanMerge() ? funcInfo->frameSlotsRegister : scope->GetLocation();\n            // Now store the property to its slot.\n            Js::OpCode op = this->GetStSlotOp(scope, -1, slotReg, false, funcInfo);\n\n            if (slotReg != Js::Constants::NoRegister && slotReg == funcInfo->frameSlotsRegister)\n            {\n                this->m_writer.SlotI1(op, rhsLocation, slot + Js::ScopeSlots::FirstSlotIndex);\n            }\n            else\n            {\n                this->m_writer.SlotI2(op, rhsLocation, scope->GetInnerScopeIndex(), slot + Js::ScopeSlots::FirstSlotIndex);\n            }\n        }\n    }\n    if (sym->GetLocation() != Js::Constants::NoRegister && rhsLocation != sym->GetLocation())\n    {\n        this->m_writer.Reg2(Js::OpCode::Ld_A, sym->GetLocation(), rhsLocation);\n    }\n}\n\nJs::OpCode\nByteCodeGenerator::GetStSlotOp(Scope *scope, int envIndex, Js::RegSlot scopeLocation, bool chkBlockVar, FuncInfo *funcInfo)\n{\n    Js::OpCode op;\n\n    if (envIndex != -1)\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::StEnvObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::StEnvSlot;\n        }\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameSlotsRegister)\n    {\n        op = Js::OpCode::StLocalSlot;\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = Js::OpCode::StLocalObjSlot;\n    }\n    else\n    {\n        Assert(scope->HasInnerScopeIndex());\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::StInnerObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::StInnerSlot;\n        }\n    }\n\n    if (chkBlockVar)\n    {\n        op = this->ToChkUndeclOp(op);\n    }\n\n    return op;\n}\n\nJs::OpCode\nByteCodeGenerator::GetInitFldOp(Scope *scope, Js::RegSlot scopeLocation, FuncInfo *funcInfo, bool letDecl)\n{\n    Js::OpCode op;\n\n    if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = letDecl ? Js::OpCode::InitLocalLetFld : Js::OpCode::InitLocalFld;\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        op = letDecl ? Js::OpCode::InitInnerLetFld : Js::OpCode::InitInnerFld;\n    }\n    else\n    {\n        op = letDecl ? Js::OpCode::InitLetFld : Js::OpCode::InitFld;\n    }\n\n    return op;\n}\n\nvoid ByteCodeGenerator::EmitPropStore(Js::RegSlot rhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo, bool isLetDecl, bool isConstDecl, bool isFncDeclVar)\n{\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::PropertyId envIndex = -1;\n    Scope *symScope = sym == nullptr || sym->GetIsGlobal() ? this->globalScope : sym->GetScope();\n    Assert(symScope);\n    // isFncDeclVar denotes that the symbol being stored to here is the var\n    // binding of a function declaration and we know we want to store directly\n    // to it, skipping over any dynamic scopes that may lie in between.\n    Scope *scope = nullptr;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    bool scopeAcquired = false;\n    Js::OpCode op;\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n\n        EmitModuleExportAccess(sym, Js::OpCode::StModuleSlot, rhsLocation, funcInfo);\n        return;\n    }\n\n    if (isFncDeclVar)\n    {\n        // async functions allow for the fncDeclVar to be in the body or parameter scope\n        // of the parent function, so we need to calculate envIndex in lieu of the while\n        // loop below.\n        do\n        {\n            scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        } while (scope != symScope);\n        Assert(scope == symScope);\n        scopeLocation = scope->GetLocation();\n    }\n\n    while (!isFncDeclVar)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n        if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        Js::RegSlot unwrappedScopeLocation = scopeLocation;\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.PatchableProperty(\n                Js::OpCode::StFld,\n                rhsLocation,\n                instLocation,\n                funcInfo->FindOrAddInlineCacheId(instLocation, propertyId, false, true));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementP(Js::OpCode::StLocalFld, rhsLocation,\n                funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, true);\n            this->m_writer.PatchableProperty(Js::OpCode::StFld, rhsLocation, scopeLocation, cacheId);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        EmitUseBeforeDeclarationRuntimeError(this, Js::Constants::NoRegister);\n        // Intentionally continue on to do normal EmitPropStore behavior so\n        // that the bytecode ends up well-formed for the backend.  This is\n        // in contrast to EmitPropLoad and EmitPropTypeof where they both\n        // tell EmitUseBeforeDeclarationRuntimeError to emit a LdUndef in place\n        // of their load and then they skip emitting their own bytecode.\n        // Potayto potahto.\n    }\n\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->frameDisplayRegister, propertyId, false, true);\n                this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo), rhsLocation, cacheId);\n            }\n            else\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, true);\n                bool isConsoleScopeLetConst = this->IsConsoleScopeEval() && (isLetDecl || isConstDecl);\n                // In \"eval\", store to a symbol with unknown scope goes through the closure environment.\n                this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo, isConsoleScopeLetConst), rhsLocation, cacheId);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, true);\n\n            // In \"eval\", store to a symbol with unknown scope goes through the closure environment.\n            this->m_writer.ElementP(GetScopedStFldOpCode(funcInfo), rhsLocation, cacheId);\n        }\n        else\n        {\n            this->EmitPatchableRootProperty(GetStFldOpCode(funcInfo, true, isLetDecl, isConstDecl, false), rhsLocation, propertyId, false, true, funcInfo);\n        }\n    }\n    else if (sym->GetIsFuncExpr())\n    {\n        // Store to function expr variable.\n\n        // strict mode: we need to throw type error\n        if (funcInfo->byteCodeFunction->GetIsStrictMode())\n        {\n            // Note that in this case the sym's location belongs to the parent function, so we can't use it.\n            // It doesn't matter which register we use, as long as it's valid for this function.\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_CantAssignToReadOnly));\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            // This is a case where const reassignment can't be proven statically (e.g., eval, with) so\n            // we have to catch it at runtime.\n            this->m_writer.W1(\n                Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        bool chkBlockVar = !isLetDecl && !isConstDecl && NeedCheckBlockVar(sym, scope, funcInfo);\n\n        // The property is in memory rather than register. We'll have to load it from the slots.\n        op = this->GetStSlotOp(scope, envIndex, scopeLocation, chkBlockVar, funcInfo);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, rhsLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var),\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, rhsLocation,\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n        else\n        {\n            Assert(scope->HasInnerScopeIndex());\n            this->m_writer.SlotI2(op, rhsLocation, scope->GetInnerScopeIndex(),\n                slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex));\n        }\n\n        if (this->ShouldTrackDebuggerMetadata() && (isLetDecl || isConstDecl))\n        {\n            Js::PropertyId location = scope->GetIsObject() ? sym->GetLocation() : slot;\n            this->UpdateDebuggerPropertyInitializationOffset(location, sym->GetPosition(), false);\n        }\n    }\n    else if (isConstDecl)\n    {\n        this->m_writer.Reg2(Js::OpCode::InitConst, sym->GetLocation(), rhsLocation);\n\n        if (this->ShouldTrackDebuggerMetadata())\n        {\n            this->UpdateDebuggerPropertyInitializationOffset(sym->GetLocation(), sym->GetPosition());\n        }\n    }\n    else\n    {\n        if (!isConstDecl && sym->GetDecl() && sym->GetDecl()->nop == knopConstDecl)\n        {\n            // This is a case where const reassignment can't be proven statically (e.g., eval, with) so\n            // we have to catch it at runtime.\n            this->m_writer.W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(ERRAssignmentToConst));\n        }\n        if (rhsLocation != sym->GetLocation())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, sym->GetLocation(), rhsLocation);\n\n            if (this->ShouldTrackDebuggerMetadata() && isLetDecl)\n            {\n                this->UpdateDebuggerPropertyInitializationOffset(sym->GetLocation(), sym->GetPosition());\n            }\n        }\n    }\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n\n    if (scopeAcquired)\n    {\n        funcInfo->ReleaseTmpRegister(scopeLocation);\n    }\n}\n\nJs::OpCode\nByteCodeGenerator::GetLdSlotOp(Scope *scope, int envIndex, Js::RegSlot scopeLocation, FuncInfo *funcInfo)\n{\n    Js::OpCode op;\n\n    if (envIndex != -1)\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::LdEnvObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::LdEnvSlot;\n        }\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameSlotsRegister)\n    {\n        op = Js::OpCode::LdLocalSlot;\n    }\n    else if (scopeLocation != Js::Constants::NoRegister &&\n        scopeLocation == funcInfo->frameObjRegister)\n    {\n        op = Js::OpCode::LdLocalObjSlot;\n    }\n    else if (scope->HasInnerScopeIndex())\n    {\n        if (scope->GetIsObject())\n        {\n            op = Js::OpCode::LdInnerObjSlot;\n        }\n        else\n        {\n            op = Js::OpCode::LdInnerSlot;\n        }\n    }\n    else\n    {\n        Assert(scope->GetIsObject());\n        op = Js::OpCode::LdObjSlot;\n    }\n\n    return op;\n}\n\nvoid ByteCodeGenerator::EmitPropLoad(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, get it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just copy the value to the lhsLocation.\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        EmitModuleExportAccess(sym, Js::OpCode::LdModuleSlot, lhsLocation, funcInfo);\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            break;\n        }\n\n        scopeLocation = scope->GetLocation();\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.PatchableProperty(\n                Js::OpCode::LdFld,\n                lhsLocation,\n                instLocation,\n                funcInfo->FindOrAddInlineCacheId(instLocation, propertyId, false, false));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementP(Js::OpCode::LdLocalFld, lhsLocation,\n                funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, false));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, propertyId, false, false);\n            this->m_writer.PatchableProperty(Js::OpCode::LdFld, lhsLocation, scopeLocation, cacheId);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        // Ensure this symbol has a slot if it needs one.\n        if (sym->IsInSlot(funcInfo))\n        {\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            funcInfo->FindOrAddSlotProfileId(scope, slot);\n        }\n\n        EmitUseBeforeDeclarationRuntimeError(this, lhsLocation);\n    }\n    else if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->frameDisplayRegister, propertyId, false, false);\n                this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n            }\n            else\n            {\n                uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, false);\n\n                // Load of a symbol with unknown scope from within eval\n                // Get it from the closure environment.\n                this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->GetEnvRegister(), propertyId, false, false);\n\n            // Load of a symbol with unknown scope from within eval or event handler.\n            // Get it from the closure environment.\n            this->m_writer.ElementP(Js::OpCode::ScopedLdFld, lhsLocation, cacheId);\n        }\n        else\n        {\n            // Special case non-writable built-ins\n            // TODO: support non-writable global property in general by detecting what attribute the property have current?\n            // But can't be done if we are byte code serialized, because the attribute might be different for use fields\n            // next time we run. May want to catch that in the JIT.\n            Js::OpCode opcode = Js::OpCode::LdRootFld;\n\n            // These properties are non-writable\n            switch (propertyId)\n            {\n            case Js::PropertyIds::NaN:\n                opcode = Js::OpCode::LdNaN;\n                break;\n            case Js::PropertyIds::Infinity:\n                opcode = Js::OpCode::LdInfinity;\n                break;\n            case Js::PropertyIds::undefined:\n                opcode = Js::OpCode::LdUndef;\n                break;\n            }\n\n            if (opcode == Js::OpCode::LdRootFld)\n            {\n                this->EmitPatchableRootProperty(Js::OpCode::LdRootFld, lhsLocation, propertyId, false, false, funcInfo);\n            }\n            else\n            {\n                this->Writer()->Reg1(opcode, lhsLocation);\n            }\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, slot);\n        bool chkBlockVar = NeedCheckBlockVar(sym, scope, funcInfo);\n        Js::OpCode op;\n\n        // Now get the property from its slot.\n        op = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n        slot = slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, lhsLocation, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, lhsLocation, slot, profileId);\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.SlotI2(op, lhsLocation, scope->GetInnerScopeIndex(), slot, profileId);\n        }\n        else\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.Slot(op, lhsLocation, scopeLocation, slot, profileId);\n        }\n\n        if (chkBlockVar)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, lhsLocation);\n        }\n    }\n    else\n    {\n        if (lhsLocation != sym->GetLocation())\n        {\n            this->m_writer.Reg2(Js::OpCode::Ld_A, lhsLocation, sym->GetLocation());\n        }\n        if (sym->GetIsBlockVar() && ((sym->GetDecl()->nop == knopLetDecl || sym->GetDecl()->nop == knopConstDecl) && sym->GetDecl()->sxVar.isSwitchStmtDecl))\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, lhsLocation);\n        }\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nbool ByteCodeGenerator::NeedCheckBlockVar(Symbol* sym, Scope* scope, FuncInfo* funcInfo) const\n{\n    bool tdz = sym->GetIsBlockVar()\n        && (scope->GetFunc() != funcInfo || ((sym->GetDecl()->nop == knopLetDecl || sym->GetDecl()->nop == knopConstDecl) && sym->GetDecl()->sxVar.isSwitchStmtDecl));\n\n    return tdz || sym->GetIsNonSimpleParameter();\n}\n\nvoid ByteCodeGenerator::EmitPropDelete(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, delete it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just return false.\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            scopeLocation = ByteCodeGenerator::RootObjectRegister;\n        }\n        else if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(\n                Js::OpCode::BrOnNoEnvProperty,\n                nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(\n                Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->m_writer.Property(Js::OpCode::DeleteFld, lhsLocation, instLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->m_writer.ElementU(Js::OpCode::DeleteLocalFld, lhsLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            this->m_writer.Property(Js::OpCode::DeleteFld, lhsLocation, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents))\n        {\n            this->m_writer.ScopedProperty(Js::OpCode::ScopedDeleteFld, lhsLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            this->m_writer.Property(Js::OpCode::DeleteRootFld, lhsLocation, ByteCodeGenerator::RootObjectRegister,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n    }\n    else\n    {\n        // The delete will look like a non-local reference, so make sure a slot is reserved.\n        sym->EnsureScopeSlot(funcInfo);\n        this->m_writer.Reg1(Js::OpCode::LdFalse, lhsLocation);\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EmitTypeOfFld(FuncInfo * funcInfo, Js::PropertyId propertyId, Js::RegSlot value, Js::RegSlot instance, Js::OpCode ldFldOp)\n{\n\n    uint cacheId;\n    Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n    switch (ldFldOp)\n    {\n    case Js::OpCode::LdRootFldForTypeOf:\n        cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, false, false);\n        this->Writer()->PatchableRootProperty(ldFldOp, tmpReg, cacheId, false, false);\n        break;\n\n    case Js::OpCode::LdLocalFld:\n    case Js::OpCode::ScopedLdFldForTypeOf:\n        cacheId = funcInfo->FindOrAddInlineCacheId(instance, propertyId, false, false);\n        this->Writer()->ElementP(ldFldOp, tmpReg, cacheId);\n        break;\n\n    default:\n        cacheId = funcInfo->FindOrAddInlineCacheId(instance, propertyId, false, false);\n        this->Writer()->PatchableProperty(ldFldOp, tmpReg, instance, cacheId);\n        break;\n    }\n\n    this->Writer()->Reg2(Js::OpCode::Typeof, value, tmpReg);\n    funcInfo->ReleaseTmpRegister(tmpReg);\n}\n\nvoid ByteCodeGenerator::EmitPropTypeof(Js::RegSlot lhsLocation, Symbol *sym, IdentPtr pid, FuncInfo *funcInfo)\n{\n    // If sym belongs to a parent frame, delete it from the closure environment.\n    // If it belongs to this func, but there's a non-local reference, get it from the heap-allocated frame.\n    // (TODO: optimize this by getting the sym from its normal location if there are no non-local defs.)\n    // Otherwise, just return false\n\n    Js::ByteCodeLabel doneLabel = 0;\n    bool fLabelDefined = false;\n    Js::RegSlot scopeLocation = Js::Constants::NoRegister;\n    Js::PropertyId envIndex = -1;\n    Scope *scope = nullptr;\n    Scope *symScope = sym ? sym->GetScope() : this->globalScope;\n    Assert(symScope);\n\n    if (sym && sym->GetIsModuleExportStorage())\n    {\n        Js::RegSlot tmpLocation = funcInfo->AcquireTmpRegister();\n        EmitModuleExportAccess(sym, Js::OpCode::LdModuleSlot, tmpLocation, funcInfo);\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, tmpLocation);\n        funcInfo->ReleaseTmpRegister(tmpLocation);\n        return;\n    }\n\n    for (;;)\n    {\n        scope = this->FindScopeForSym(symScope, scope, &envIndex, funcInfo);\n        if (scope == this->globalScope)\n        {\n            scopeLocation = ByteCodeGenerator::RootObjectRegister;\n        }\n        else if (envIndex == -1)\n        {\n            Assert(funcInfo == scope->GetFunc());\n            scopeLocation = scope->GetLocation();\n        }\n\n        if (scope == symScope)\n        {\n            break;\n        }\n\n        // Found a scope to which the property may have been added.\n        Assert(scope && scope->GetIsDynamic());\n\n        if (!fLabelDefined)\n        {\n            fLabelDefined = true;\n            doneLabel = this->m_writer.DefineLabel();\n        }\n\n        Js::ByteCodeLabel nextLabel = this->m_writer.DefineLabel();\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n\n        bool unwrapWithObj = scope->GetScopeType() == ScopeType_With && scriptContext->GetConfig()->IsES6UnscopablesEnabled();\n        if (envIndex != -1)\n        {\n            this->m_writer.BrEnvProperty(Js::OpCode::BrOnNoEnvProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId),\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            Js::RegSlot instLocation = funcInfo->AcquireTmpRegister();\n\n            Assert(scope->GetIsObject());\n            this->m_writer.SlotI1(Js::OpCode::LdEnvObj,\n                instLocation,\n                envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var));\n\n            if (unwrapWithObj)\n            {\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, instLocation, instLocation);\n            }\n\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, instLocation, Js::OpCode::LdFldForTypeOf);\n\n            funcInfo->ReleaseTmpRegister(instLocation);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister && scopeLocation == funcInfo->frameObjRegister)\n        {\n            this->m_writer.BrLocalProperty(Js::OpCode::BrOnNoLocalProperty, nextLabel,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Assert(!unwrapWithObj);\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, scopeLocation, Js::OpCode::LdLocalFld);\n        }\n        else\n        {\n            this->m_writer.BrProperty(Js::OpCode::BrOnNoProperty, nextLabel, scopeLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n\n            Js::RegSlot unwrappedScopeLocation = Js::Constants::NoRegister;\n            if (unwrapWithObj)\n            {\n                unwrappedScopeLocation = funcInfo->AcquireTmpRegister();\n                this->m_writer.Reg2(Js::OpCode::UnwrapWithObj, unwrappedScopeLocation, scopeLocation);\n                scopeLocation = unwrappedScopeLocation;\n            }\n\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, scopeLocation, Js::OpCode::LdFldForTypeOf);\n\n            if (unwrapWithObj)\n            {\n                funcInfo->ReleaseTmpRegister(unwrappedScopeLocation);\n            }\n        }\n\n        this->m_writer.Br(doneLabel);\n        this->m_writer.MarkLabel(nextLabel);\n    }\n\n    // Arrived at the scope in which the property was defined.\n    if (sym && sym->GetNeedDeclaration() && scope->GetFunc() == funcInfo)\n    {\n        // Ensure this symbol has a slot if it needs one.\n        if (sym->IsInSlot(funcInfo))\n        {\n            Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n            funcInfo->FindOrAddSlotProfileId(scope, slot);\n        }\n\n        EmitUseBeforeDeclarationRuntimeError(this, lhsLocation);\n    }\n    else if (sym == nullptr || sym->GetIsGlobal())\n    {\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(this) : pid->GetPropertyId();\n        if (this->flags & fscrEval)\n        {\n            if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())\n            {\n                this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->frameDisplayRegister, Js::OpCode::ScopedLdFldForTypeOf);\n            }\n            else\n            {\n                this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->GetEnvRegister(), Js::OpCode::ScopedLdFldForTypeOf);\n            }\n        }\n        else if (this->flags & (fscrImplicitThis | fscrImplicitParents))\n        {\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, funcInfo->GetEnvRegister(), Js::OpCode::ScopedLdFldForTypeOf);\n        }\n        else\n        {\n            this->EmitTypeOfFld(funcInfo, propertyId, lhsLocation, ByteCodeGenerator::RootObjectRegister, Js::OpCode::LdRootFldForTypeOf);\n        }\n    }\n    else if (sym->IsInSlot(funcInfo) || envIndex != -1)\n    {\n        // Make sure the property has a slot. This will bump up the size of the slot array if necessary.\n        Js::PropertyId slot = sym->EnsureScopeSlot(funcInfo);\n        Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(scope, slot);\n        Js::RegSlot tmpLocation = funcInfo->AcquireTmpRegister();\n        bool chkBlockVar = NeedCheckBlockVar(sym, scope, funcInfo);\n        Js::OpCode op;\n\n        op = this->GetLdSlotOp(scope, envIndex, scopeLocation, funcInfo);\n        slot = slot + (sym->GetScope()->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n        if (envIndex != -1)\n        {\n            this->m_writer.SlotI2(op, tmpLocation, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot, profileId);\n        }\n        else if (scopeLocation != Js::Constants::NoRegister &&\n            (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))\n        {\n            this->m_writer.SlotI1(op, tmpLocation, slot, profileId);\n        }\n        else if (scope->HasInnerScopeIndex())\n        {\n            this->m_writer.SlotI2(op, tmpLocation, scope->GetInnerScopeIndex(), slot, profileId);\n        }\n        else\n        {\n            Assert(scope->GetIsObject());\n            this->m_writer.Slot(op, tmpLocation, scopeLocation, slot, profileId);\n        }\n\n        if (chkBlockVar)\n        {\n            this->m_writer.Reg1(Js::OpCode::ChkUndecl, tmpLocation);\n        }\n\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, tmpLocation);\n        funcInfo->ReleaseTmpRegister(tmpLocation);\n    }\n    else\n    {\n        this->m_writer.Reg2(Js::OpCode::Typeof, lhsLocation, sym->GetLocation());\n    }\n\n    if (fLabelDefined)\n    {\n        this->m_writer.MarkLabel(doneLabel);\n    }\n}\n\nvoid ByteCodeGenerator::EnsureNoRedeclarations(ParseNode *pnodeBlock, FuncInfo *funcInfo)\n{\n    // Emit dynamic runtime checks for variable re-declarations. Only necessary for global functions (script or eval).\n    // In eval only var declarations can cause redeclaration, and only in non-strict mode, because let/const variables\n    // remain local to the eval code.\n\n    Assert(pnodeBlock->nop == knopBlock);\n    Assert(pnodeBlock->sxBlock.blockType == PnodeBlockType::Global || pnodeBlock->sxBlock.scope->GetScopeType() == ScopeType_GlobalEvalBlock);\n\n    if (!(this->flags & fscrEvalCode))\n    {\n        IterateBlockScopedVariables(pnodeBlock, [this](ParseNode *pnode)\n        {\n            FuncInfo *funcInfo = this->TopFuncInfo();\n            Symbol *sym = pnode->sxVar.sym;\n\n            Assert(sym->GetIsGlobal());\n\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n            this->m_writer.ElementRootU(Js::OpCode::EnsureNoRootFld, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        });\n    }\n\n    for (ParseNode *pnode = funcInfo->root->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)\n    {\n        Symbol* sym = pnode->sxVar.sym;\n\n        if (sym == nullptr || pnode->sxVar.isBlockScopeFncDeclVar)\n            continue;\n\n        if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))\n        {\n            // The init node was bound to the catch object, because it's inside a catch and has the\n            // same name as the catch object. But we want to define a user var at function scope,\n            // so find the right symbol. (We'll still assign the RHS value to the catch object symbol.)\n            // This also applies to a var declaration in the same scope as a let declaration.\n\n            // Assert that catch cannot be at function scope and let and var at function scope is redeclaration error.\n            Assert(sym->GetIsCatch() || funcInfo->bodyScope != sym->GetScope());\n            sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());\n            Assert(sym && !sym->GetIsCatch() && !sym->GetIsBlockVar());\n        }\n\n        Assert(sym->GetIsGlobal());\n\n        if (sym->GetSymbolType() == STVariable)\n        {\n            Js::PropertyId propertyId = sym->EnsurePosition(this);\n\n            if (this->flags & fscrEval)\n            {\n                if (!funcInfo->byteCodeFunction->GetIsStrictMode())\n                {\n                    this->m_writer.ScopedProperty(Js::OpCode::ScopedEnsureNoRedeclFld, ByteCodeGenerator::RootObjectRegister,\n                        funcInfo->FindOrAddReferencedPropertyId(propertyId));\n                }\n            }\n            else\n            {\n                this->m_writer.ElementRootU(Js::OpCode::EnsureNoRootRedeclFld, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n        }\n    }\n}\n\nvoid ByteCodeGenerator::RecordAllIntConstants(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->constantToRegister.Map([byteCodeFunction](unsigned int val, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordIntConstant(byteCodeFunction->MapRegSlot(location), val);\n    });\n}\n\nvoid ByteCodeGenerator::RecordAllStrConstants(FuncInfo * funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->stringToRegister.Map([byteCodeFunction](IdentPtr pid, Js::RegSlot location)\n    {\n        byteCodeFunction->RecordStrConstant(byteCodeFunction->MapRegSlot(location), pid->Psz(), pid->Cch());\n    });\n}\n\nvoid ByteCodeGenerator::RecordAllStringTemplateCallsiteConstants(FuncInfo* funcInfo)\n{\n    Js::FunctionBody *byteCodeFunction = this->TopFuncInfo()->GetParsedFunctionBody();\n    funcInfo->stringTemplateCallsiteRegisterMap.Map([byteCodeFunction](ParseNodePtr pnode, Js::RegSlot location)\n    {\n        Js::ScriptContext* scriptContext = byteCodeFunction->GetScriptContext();\n        Js::JavascriptLibrary* library = scriptContext->GetLibrary();\n        Js::RecyclableObject* callsiteObject = library->TryGetStringTemplateCallsiteObject(pnode);\n\n        if (callsiteObject == nullptr)\n        {\n            Js::RecyclableObject* rawArray = ByteCodeGenerator::BuildArrayFromStringList(pnode->sxStrTemplate.pnodeStringRawLiterals, pnode->sxStrTemplate.countStringLiterals, scriptContext);\n            rawArray->Freeze();\n\n            callsiteObject = ByteCodeGenerator::BuildArrayFromStringList(pnode->sxStrTemplate.pnodeStringLiterals, pnode->sxStrTemplate.countStringLiterals, scriptContext);\n            callsiteObject->SetPropertyWithAttributes(Js::PropertyIds::raw, rawArray, PropertyNone, nullptr);\n            callsiteObject->Freeze();\n\n            library->AddStringTemplateCallsiteObject(callsiteObject);\n        }\n\n        byteCodeFunction->RecordConstant(byteCodeFunction->MapRegSlot(location), callsiteObject);\n    });\n}\n\nbool IsApplyArgs(ParseNode* callNode)\n{\n    ParseNode* target = callNode->sxCall.pnodeTarget;\n    ParseNode* args = callNode->sxCall.pnodeArgs;\n    if ((target != nullptr) && (target->nop == knopDot))\n    {\n        ParseNode* lhsNode = target->sxBin.pnode1;\n        if ((lhsNode != nullptr) && ((lhsNode->nop == knopDot) || (lhsNode->nop == knopName)) && !IsArguments(lhsNode))\n        {\n            ParseNode* nameNode = target->sxBin.pnode2;\n            if (nameNode != nullptr)\n            {\n                bool nameIsApply = nameNode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::apply;\n                if (nameIsApply && args != nullptr && args->nop == knopList)\n                {\n                    ParseNode* arg1 = args->sxBin.pnode1;\n                    ParseNode* arg2 = args->sxBin.pnode2;\n                    if ((arg1 != nullptr) && (arg1->nop == knopThis) && (arg2 != nullptr) && (arg2->nop == knopName) && (arg2->sxPid.sym != nullptr))\n                    {\n                        return arg2->sxPid.sym->GetIsArguments();\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvoid PostCheckApplyEnclosesArgs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, ApplyCheck* applyCheck)\n{\n    if ((pnode == nullptr) || (!applyCheck->matches))\n    {\n        return;\n    }\n\n    if (pnode->nop == knopCall)\n    {\n        if ((!pnode->isUsed) && IsApplyArgs(pnode))\n        {\n            if (!applyCheck->insideApplyCall)\n            {\n                applyCheck->matches = false;\n            }\n            applyCheck->insideApplyCall = false;\n        }\n    }\n}\n\nvoid CheckApplyEnclosesArgs(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, ApplyCheck* applyCheck)\n{\n    if ((pnode == nullptr) || (!applyCheck->matches))\n    {\n        return;\n    }\n\n    switch (pnode->nop)\n    {\n    case knopName:\n    {\n        Symbol* sym = pnode->sxPid.sym;\n        if (sym != nullptr)\n        {\n            if (sym->GetIsArguments())\n            {\n                if (!applyCheck->insideApplyCall)\n                {\n                    applyCheck->matches = false;\n                }\n            }\n        }\n        break;\n    }\n\n    case knopCall:\n        if ((!pnode->isUsed) && IsApplyArgs(pnode))\n        {\n            // no nested apply calls\n            if (applyCheck->insideApplyCall)\n            {\n                applyCheck->matches = false;\n            }\n            else\n            {\n                applyCheck->insideApplyCall = true;\n                applyCheck->sawApply = true;\n                pnode->sxCall.isApplyCall = true;\n            }\n        }\n        break;\n    }\n}\n\nunsigned int CountArguments(ParseNode *pnode, BOOL *pSideEffect = nullptr)\n{\n    // If the caller passed us a pSideEffect, it wants to know whether there are potential\n    // side-effects in the argument list. We need to know this so that the call target\n    // operands can be preserved if necessary.\n    // For now, treat any non-leaf op as a potential side-effect. This causes no detectable slowdowns,\n    // but we can be more precise if we need to be.\n    if (pSideEffect)\n    {\n        *pSideEffect = FALSE;\n    }\n\n    unsigned int argCount = 1;\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            argCount++;\n            if (pSideEffect && !(ParseNode::Grfnop(pnode->sxBin.pnode1->nop) & fnopLeaf))\n            {\n                *pSideEffect = TRUE;\n            }\n            pnode = pnode->sxBin.pnode2;\n        }\n        argCount++;\n        if (pSideEffect && !(ParseNode::Grfnop(pnode->nop) & fnopLeaf))\n        {\n            *pSideEffect = TRUE;\n        }\n    }\n\n    return argCount;\n}\n\nvoid SaveOpndValue(ParseNode *pnode, FuncInfo *funcInfo)\n{\n    // Save a local name to a register other than its home location.\n    // This guards against side-effects in cases like x.foo(x = bar()).\n    Symbol *sym = nullptr;\n    if (pnode->nop == knopName)\n    {\n        sym = pnode->sxPid.sym;\n    }\n    else if (pnode->nop == knopComputedName)\n    {\n        ParseNode *pnode1 = pnode->sxUni.pnode1;\n        if (pnode1->nop == knopName)\n        {\n            sym = pnode1->sxPid.sym;\n        }\n    }\n\n    if (sym == nullptr)\n    {\n        return;\n    }\n\n    // If the target is a local being kept in its home location,\n    // protect the target's value in the event the home location is overwritten.\n    if (pnode->location != Js::Constants::NoRegister &&\n        sym->GetScope()->GetFunc() == funcInfo &&\n        pnode->location == sym->GetLocation())\n    {\n        pnode->location = funcInfo->AcquireTmpRegister();\n    }\n}\n\nvoid ByteCodeGenerator::StartStatement(ParseNode* node)\n{\n    Assert(TopFuncInfo() != nullptr);\n    m_writer.StartStatement(node, TopFuncInfo()->curTmpReg - TopFuncInfo()->firstTmpReg);\n}\n\nvoid ByteCodeGenerator::EndStatement(ParseNode* node)\n{\n    m_writer.EndStatement(node);\n}\n\nvoid ByteCodeGenerator::StartSubexpression(ParseNode* node)\n{\n    Assert(TopFuncInfo() != nullptr);\n    m_writer.StartSubexpression(node);\n}\n\nvoid ByteCodeGenerator::EndSubexpression(ParseNode* node)\n{\n    m_writer.EndSubexpression(node);\n}\n\nvoid EmitReference(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // Generate code for the LHS of an assignment.\n    switch (pnode->nop)\n    {\n    case knopDot:\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        break;\n\n    case knopIndex:\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Emit(pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n        break;\n\n    case knopName:\n        break;\n\n    case knopArrayPattern:\n    case knopObjectPattern:\n        break;\n\n    case knopCall:\n    case knopNew:\n        // Emit the operands of a call that will be used as a LHS.\n        // These have to be emitted before the RHS, but they have to persist until\n        // the end of the expression.\n        // Emit the call target operands first.\n        switch (pnode->sxCall.pnodeTarget->nop)\n        {\n        case knopDot:\n        case knopIndex:\n            funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n            EmitReference(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            break;\n\n        case knopName:\n        {\n            Symbol *sym = pnode->sxCall.pnodeTarget->sxPid.sym;\n            if (!sym || sym->GetLocation() == Js::Constants::NoRegister)\n            {\n                funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n            }\n            if (sym && (sym->IsInSlot(funcInfo) || sym->GetScope()->GetFunc() != funcInfo))\n            {\n                // Can't get the value from the assigned register, so load it here.\n                EmitLoad(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            }\n            else\n            {\n                // EmitLoad will check for needsDeclaration and emit the Use Before Declaration error\n                // bytecode op as necessary, but EmitReference does not check this (by design). So we\n                // must manually check here.\n                EmitUseBeforeDeclaration(pnode->sxCall.pnodeTarget->sxPid.sym, byteCodeGenerator, funcInfo);\n                EmitReference(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            }\n            break;\n        }\n        default:\n            EmitLoad(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo);\n            break;\n        }\n\n        // Now the arg list. We evaluate everything now and emit the ArgOut's later.\n        if (pnode->sxCall.pnodeArgs)\n        {\n            ParseNode *pnodeArg = pnode->sxCall.pnodeArgs;\n            while (pnodeArg->nop == knopList)\n            {\n                Emit(pnodeArg->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n                pnodeArg = pnodeArg->sxBin.pnode2;\n            }\n            Emit(pnodeArg, byteCodeGenerator, funcInfo, false);\n        }\n        break;\n\n    default:\n        Emit(pnode, byteCodeGenerator, funcInfo, false);\n        break;\n    }\n}\n\nvoid EmitGetIterator(Js::RegSlot iteratorLocation, Js::RegSlot iterableLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorNext(Js::RegSlot itemLocation, Js::RegSlot iteratorLocation, Js::RegSlot nextInputLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorClose(Js::RegSlot iteratorLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorComplete(Js::RegSlot doneLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\nvoid EmitIteratorValue(Js::RegSlot valueLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo);\n\nvoid EmitDestructuredElement(ParseNode *elem, Js::RegSlot sourceLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo *funcInfo)\n{\n    switch (elem->nop)\n    {\n    case knopVarDecl:\n    case knopLetDecl:\n    case knopConstDecl:\n        // We manually need to set NeedDeclaration since the node won't be visited.\n        elem->sxVar.sym->SetNeedDeclaration(false);\n        break;\n\n    default:\n        EmitReference(elem, byteCodeGenerator, funcInfo);\n    }\n\n    EmitAssignment(nullptr, elem, sourceLocation, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseReference(elem);\n}\n\nvoid EmitDestructuredRestArray(ParseNode *elem,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::RegSlot restArrayLocation = funcInfo->AcquireTmpRegister();\n    bool isAssignmentTarget = !(elem->sxUni.pnode1->IsPattern() || elem->sxUni.pnode1->IsVarLetOrConst());\n\n    if (isAssignmentTarget)\n    {\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n        EmitReference(elem->sxUni.pnode1, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n    }\n\n    byteCodeGenerator->Writer()->Reg1Unsigned1(\n        Js::OpCode::NewScArray,\n        restArrayLocation,\n        ByteCodeGenerator::DefaultArraySize);\n\n    // BytecodeGen can't convey to IRBuilder that some of the temporaries used here are live. When we\n    // have a rest parameter, a counter is used in a loop for the array index, but there is no way to\n    // convey this is live on the back edge.\n    // As a workaround, we have a persistent var reg that is used for the loop counter\n    Js::RegSlot counterLocation = elem->location;\n    // TODO[ianhall]: Is calling EnregisterConstant() during Emit phase allowed?\n    Js::RegSlot zeroConstantReg = byteCodeGenerator->EnregisterConstant(0);\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, counterLocation, zeroConstantReg);\n\n    // loopTop:\n    Js::ByteCodeLabel loopTop = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->MarkLabel(loopTop);\n\n    Js::RegSlot itemLocation = funcInfo->AcquireTmpRegister();\n\n    EmitIteratorNext(itemLocation, iteratorLocation, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n    Js::ByteCodeLabel iteratorDone = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, iteratorDone, doneLocation);\n\n    Js::RegSlot valueLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorValue(valueLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->Writer()->Element(\n        ByteCodeGenerator::GetStElemIOpCode(funcInfo),\n        valueLocation, restArrayLocation, counterLocation);\n    funcInfo->ReleaseTmpRegister(valueLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n    funcInfo->ReleaseTmpRegister(itemLocation);\n\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Incr_A, counterLocation, counterLocation);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->Writer()->Br(loopTop);\n\n    // iteratorDone:\n    byteCodeGenerator->Writer()->MarkLabel(iteratorDone);\n\n    ParseNode *restElem = elem->sxUni.pnode1;\n    if (isAssignmentTarget)\n    {\n        EmitAssignment(nullptr, restElem, restArrayLocation, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseReference(restElem);\n    }\n    else\n    {\n        EmitDestructuredElement(restElem, restArrayLocation, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(restArrayLocation);\n}\n\nvoid EmitDestructuredArray(\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo);\n\nvoid EmitIteratorCloseIfNotDone(Js::RegSlot iteratorLocation, Js::RegSlot doneLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::ByteCodeLabel skipCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, skipCloseLabel, doneLocation);\n\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCloseLabel);\n}\n\n/*\n  EmitDestructuredArray(lhsArray, rhs):\n    iterator = rhs[@@iterator]\n\n    if lhsArray empty\n      return\n\n    for each element in lhsArray except rest\n      value = iterator.next()\n      if element is a nested destructured array\n        EmitDestructuredArray(element, value)\n      else\n        if value is undefined and there is an initializer\n          evaluate initializer\n          evaluate element reference\n          element = initializer\n        else\n          element = value\n\n    if lhsArray has a rest element\n      rest = []\n      while iterator is not done\n        value = iterator.next()\n        rest.append(value)\n*/\nvoid EmitDestructuredArrayCore(\n    ParseNode *list,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo\n    )\n{\n    Assert(list != nullptr);\n\n    ParseNode *elem = nullptr;\n    while (list != nullptr)\n    {\n        ParseNode *init = nullptr;\n\n        if (list->nop == knopList)\n        {\n            elem = list->sxBin.pnode1;\n        }\n        else\n        {\n            elem = list;\n        }\n\n        if (elem->nop == knopEllipsis)\n        {\n            break;\n        }\n\n        switch (elem->nop)\n        {\n        case knopAsg:\n            // An assignment node will always have an initializer\n            init = elem->sxBin.pnode2;\n            elem = elem->sxBin.pnode1;\n            break;\n\n        case knopVarDecl:\n        case knopLetDecl:\n        case knopConstDecl:\n            init = elem->sxVar.pnodeInit;\n            break;\n\n        default:\n            break;\n        }\n\n        byteCodeGenerator->StartStatement(elem);\n\n        bool isAssignmentTarget = !(elem->IsPattern() || elem->IsVarLetOrConst());\n\n        if (isAssignmentTarget)\n        {\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n            EmitReference(elem, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n        Js::RegSlot itemLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorNext(itemLocation, iteratorLocation, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n        Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorComplete(doneLocation, itemLocation, byteCodeGenerator, funcInfo);\n\n        if (elem->nop == knopEmpty)\n        {\n            if (list->nop == knopList)\n            {\n                list = list->sxBin.pnode2;\n                funcInfo->ReleaseTmpRegister(doneLocation);\n                funcInfo->ReleaseTmpRegister(itemLocation);\n                continue;\n            }\n            else\n            {\n                Assert(list->nop == knopEmpty);\n                EmitIteratorCloseIfNotDone(iteratorLocation, doneLocation, byteCodeGenerator, funcInfo);\n                funcInfo->ReleaseTmpRegister(doneLocation);\n                funcInfo->ReleaseTmpRegister(itemLocation);\n                break;\n            }\n        }\n\n        // If the iterator hasn't completed, skip assigning undefined.\n        Js::ByteCodeLabel iteratorAlreadyDone = byteCodeGenerator->Writer()->DefineLabel();\n        byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, iteratorAlreadyDone, doneLocation);\n\n        // We're not done with the iterator, so assign the .next() value.\n        Js::RegSlot valueLocation = funcInfo->AcquireTmpRegister();\n        EmitIteratorValue(valueLocation, itemLocation, byteCodeGenerator, funcInfo);\n        Js::ByteCodeLabel beforeDefaultAssign = byteCodeGenerator->Writer()->DefineLabel();\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n        byteCodeGenerator->Writer()->Br(beforeDefaultAssign);\n\n        // iteratorAlreadyDone:\n        byteCodeGenerator->Writer()->MarkLabel(iteratorAlreadyDone);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocation, funcInfo->undefinedConstantRegister);\n\n        // beforeDefaultAssign:\n        byteCodeGenerator->Writer()->MarkLabel(beforeDefaultAssign);\n\n        if (elem->IsPattern())\n        {\n            // If we get an undefined value and have an initializer, use it in place of undefined.\n            if (init != nullptr)\n            {\n                /*\n                the IR builder uses two symbols for a temp register in the if else path\n                R9 <- R3\n                if (...)\n                R9 <- R2\n                R10 = R9.<property>  // error -> IR creates a new lifetime for the if path, and the direct path dest is not referenced\n                hence we have to create a new temp\n\n                TEMP REG USED TO FIX THIS PRODUCES THIS\n                R9 <- R3\n                if (BrEq_A R9, R3)\n                R10 <- R2               :\n                else\n                R10 <- R9               : skipdefault\n                ...  = R10[@@iterator]  : loadIter\n                */\n\n                // Temp Register\n                Js::RegSlot valueLocationTmp = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->StartStatement(init);\n\n                Js::ByteCodeLabel skipDefault = byteCodeGenerator->Writer()->DefineLabel();\n                Js::ByteCodeLabel loadIter = byteCodeGenerator->Writer()->DefineLabel();\n\n                // check value is undefined\n                byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrNeq_A, skipDefault, valueLocation, funcInfo->undefinedConstantRegister);\n\n                // Evaluate the default expression and assign it.\n                Emit(init, byteCodeGenerator, funcInfo, false);\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocationTmp, init->location);\n                funcInfo->ReleaseLoc(init);\n\n                // jmp to loadIter\n                byteCodeGenerator->Writer()->Br(loadIter);\n\n                // skipDefault:\n                byteCodeGenerator->Writer()->MarkLabel(skipDefault);\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, valueLocationTmp, valueLocation);\n\n                // loadIter:\n                // @@iterator\n                byteCodeGenerator->Writer()->MarkLabel(loadIter);\n                byteCodeGenerator->EndStatement(init);\n\n                if (elem->nop == knopObjectPattern)\n                {\n                    EmitDestructuredObject(elem, valueLocationTmp, byteCodeGenerator, funcInfo);\n                }\n                else\n                {\n                    // Recursively emit a destructured array using the current .next() as the RHS.\n                    EmitDestructuredArray(elem, valueLocationTmp, byteCodeGenerator, funcInfo);\n                }\n\n                funcInfo->ReleaseTmpRegister(valueLocationTmp);\n            }\n            else\n            {\n                if (elem->nop == knopObjectPattern)\n                {\n                    EmitDestructuredObject(elem, valueLocation, byteCodeGenerator, funcInfo);\n                }\n                else\n                {\n                    // Recursively emit a destructured array using the current .next() as the RHS.\n                    EmitDestructuredArray(elem, valueLocation, byteCodeGenerator, funcInfo);\n                }\n            }\n        }\n        else\n        {\n            EmitDestructuredValueOrInitializer(elem, valueLocation, init, isAssignmentTarget, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n        if (list->nop != knopList)\n        {\n            EmitIteratorCloseIfNotDone(iteratorLocation, doneLocation, byteCodeGenerator, funcInfo);\n        }\n\n        funcInfo->ReleaseTmpRegister(valueLocation);\n        funcInfo->ReleaseTmpRegister(doneLocation);\n        funcInfo->ReleaseTmpRegister(itemLocation);\n\n        if (isAssignmentTarget)\n        {\n            funcInfo->ReleaseReference(elem);\n        }\n\n        byteCodeGenerator->EndStatement(elem);\n\n        if (list->nop == knopList)\n        {\n            list = list->sxBin.pnode2;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    // If we saw a rest element, emit the rest array.\n    if (elem != nullptr && elem->nop == knopEllipsis)\n    {\n        EmitDestructuredRestArray(elem,\n            iteratorLocation,\n            shouldCallReturnFunctionLocation,\n            shouldCallReturnFunctionLocationFinally,\n            byteCodeGenerator,\n            funcInfo);\n    }\n}\n\n// Generating\n// try {\n//    CallIteratorClose\n// } catch (e) {\n//    do nothing \n// }\n\nvoid EmitTryCatchAroundClose(\n    Js::RegSlot iteratorLocation,\n    Js::ByteCodeLabel endLabel,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    //\n    // There is no need to add TryScopeRecord here as we are going to call 'return' function and there is not yield expression here.\n\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->Br(endLabel);\n\n    byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n    Js::RegSlot catchParamLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, catchParamLocation);\n    funcInfo->ReleaseTmpRegister(catchParamLocation);\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n}\n\nstruct ByteCodeGenerator::TryScopeRecord : public JsUtil::DoublyLinkedListElement<TryScopeRecord>\n{\n    Js::OpCode op;\n    Js::ByteCodeLabel label;\n    Js::RegSlot reg1;\n    Js::RegSlot reg2;\n\n    TryScopeRecord(Js::OpCode op, Js::ByteCodeLabel label) : op(op), label(label), reg1(Js::Constants::NoRegister), reg2(Js::Constants::NoRegister) { }\n    TryScopeRecord(Js::OpCode op, Js::ByteCodeLabel label, Js::RegSlot r1, Js::RegSlot r2) : op(op), label(label), reg1(r1), reg2(r2) { }\n};\n\n// Generating\n// catch(e) {\n//      if (shouldCallReturn)\n//          CallReturnWhichWrappedByTryCatch\n//      throw e;\n// }\nvoid EmitTopLevelCatch(Js::ByteCodeLabel catchLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnLocation,\n    Js::RegSlot shouldCallReturnLocationFinally,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Js::ByteCodeLabel afterCatchBlockLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->Br(afterCatchBlockLabel);\n    byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n\n    Js::RegSlot catchParamLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, catchParamLocation);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForCatch(Js::OpCode::ResumeCatch, catchLabel);\n    if (funcInfo->byteCodeFunction->IsCoroutine())\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForCatch);\n    }\n\n    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnLocationFinally);\n    EmitTryCatchAroundClose(iteratorLocation, skipCallCloseLabel, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);\n\n    // Rethrow the exception.\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Throw, catchParamLocation);\n\n    funcInfo->ReleaseTmpRegister(catchParamLocation);\n\n    if (funcInfo->byteCodeFunction->IsCoroutine())\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n    byteCodeGenerator->Writer()->MarkLabel(afterCatchBlockLabel);\n}\n\n// Generating\n// finally {\n//      if (shouldCallReturn)\n//          CallReturn\n// }\n\nvoid EmitTopLevelFinally(Js::ByteCodeLabel finallyLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnLocation,\n    Js::RegSlot yieldExceptionLocation,\n    Js::RegSlot yieldOffsetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    Js::ByteCodeLabel afterFinallyBlockLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    byteCodeGenerator->Writer()->Br(afterFinallyBlockLabel);\n    byteCodeGenerator->Writer()->MarkLabel(finallyLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForFinally(Js::OpCode::ResumeFinally, finallyLabel, yieldExceptionLocation, yieldOffsetLocation);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForFinally);\n    }\n\n    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);\n    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        funcInfo->ReleaseTmpRegister(yieldOffsetLocation);\n        funcInfo->ReleaseTmpRegister(yieldExceptionLocation);\n    }\n\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n    byteCodeGenerator->Writer()->Empty(Js::OpCode::LeaveNull);\n    byteCodeGenerator->Writer()->MarkLabel(afterFinallyBlockLabel);\n}\n\nvoid EmitCatchAndFinallyBlocks(Js::ByteCodeLabel catchLabel,\n    Js::ByteCodeLabel finallyLabel,\n    Js::RegSlot iteratorLocation,\n    Js::RegSlot shouldCallReturnFunctionLocation,\n    Js::RegSlot shouldCallReturnFunctionLocationFinally,\n    Js::RegSlot yieldExceptionLocation,\n    Js::RegSlot yieldOffsetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo\n    )\n{\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    EmitTopLevelCatch(catchLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        byteCodeGenerator,\n        funcInfo);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n    }\n\n    EmitTopLevelFinally(finallyLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocationFinally,\n        yieldExceptionLocation,\n        yieldOffsetLocation,\n        byteCodeGenerator,\n        funcInfo);\n\n    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocationFinally);\n    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocation);\n}\n\n// Emit a wrapper try..finaly block around the destructuring elements\nvoid EmitDestructuredArray(\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(lhs);\n    Js::RegSlot iteratorLocation = funcInfo->AcquireTmpRegister();\n\n    EmitGetIterator(iteratorLocation, rhsLocation, byteCodeGenerator, funcInfo);\n\n    Assert(lhs->nop == knopArrayPattern);\n    ParseNode *list = lhs->sxArrLit.pnode1;\n\n    if (list == nullptr)\n    { // Handline this case ([] = obj);\n        EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);\n\n        // No elements to bind or assign.\n        funcInfo->ReleaseTmpRegister(iteratorLocation);\n        byteCodeGenerator->EndStatement(lhs);\n        return;\n    }\n\n    // This variable facilitates on when to call the return function (which is Iterator close). When we are emitting bytecode for destructuring element\n    // this variable will be set to true.\n    Js::RegSlot shouldCallReturnFunctionLocation = funcInfo->AcquireTmpRegister();\n    Js::RegSlot shouldCallReturnFunctionLocationFinally = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    byteCodeGenerator->SetHasFinally(true);\n    byteCodeGenerator->SetHasTry(true);\n    byteCodeGenerator->TopFuncInfo()->byteCodeFunction->SetDontInline(true);\n\n    Js::RegSlot regException = Js::Constants::NoRegister;\n    Js::RegSlot regOffset = Js::Constants::NoRegister;\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    if (isCoroutine)\n    {\n        regException = funcInfo->AcquireTmpRegister();\n        regOffset = funcInfo->AcquireTmpRegister();\n    }\n\n    // Insert try node here \n    Js::ByteCodeLabel finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTryFinally(Js::OpCode::TryFinallyWithYield, finallyLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n        tryRecForTryFinally.reg1 = regException;\n        tryRecForTryFinally.reg2 = regOffset;\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTryFinally);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n    }\n\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n    }\n\n    EmitDestructuredArrayCore(list,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        byteCodeGenerator,\n        funcInfo);\n\n    EmitCatchAndFinallyBlocks(catchLabel,\n        finallyLabel,\n        iteratorLocation,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        regException,\n        regOffset,\n        byteCodeGenerator,\n        funcInfo);\n\n    funcInfo->ReleaseTmpRegister(iteratorLocation);\n\n    byteCodeGenerator->EndStatement(lhs);\n}\n\nvoid EmitNameInvoke(Js::RegSlot lhsLocation,\n    Js::RegSlot objectLocation,\n    ParseNodePtr nameNode,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo)\n{\n    Assert(nameNode != nullptr);\n    if (nameNode->nop == knopComputedName)\n    {\n        ParseNodePtr pnode1 = nameNode->sxUni.pnode1;\n        Emit(pnode1, byteCodeGenerator, funcInfo, false/*isConstructorCall*/);\n\n        byteCodeGenerator->Writer()->Element(Js::OpCode::LdElemI_A, lhsLocation, objectLocation, pnode1->location);\n        funcInfo->ReleaseLoc(pnode1);\n    }\n    else\n    {\n        Assert(nameNode->nop == knopName || nameNode->nop == knopStr);\n        Symbol *sym = nameNode->sxPid.sym;\n        Js::PropertyId propertyId = sym ? sym->EnsurePosition(byteCodeGenerator) : nameNode->sxPid.pid->GetPropertyId();\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(objectLocation, propertyId, false/*isLoadMethod*/, false/*isStore*/);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, lhsLocation, objectLocation, cacheId);\n    }\n}\n\nvoid EmitDestructuredValueOrInitializer(ParseNodePtr lhsElementNode,\n    Js::RegSlot rhsLocation,\n    ParseNodePtr initializer,\n    bool isNonPatternAssignmentTarget,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // If we have initializer we need to see if the destructured value is undefined or not - if it is undefined we need to assign initializer\n\n    Js::ByteCodeLabel useDefault = -1;\n    Js::ByteCodeLabel end = -1;\n    Js::RegSlot rhsLocationTmp = rhsLocation;\n\n    if (initializer != nullptr)\n    {\n        rhsLocationTmp = funcInfo->AcquireTmpRegister();\n\n        useDefault = byteCodeGenerator->Writer()->DefineLabel();\n        end = byteCodeGenerator->Writer()->DefineLabel();\n\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrEq_A, useDefault, rhsLocation, funcInfo->undefinedConstantRegister);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocationTmp, rhsLocation);\n\n        byteCodeGenerator->Writer()->Br(end);\n        byteCodeGenerator->Writer()->MarkLabel(useDefault);\n\n        Emit(initializer, byteCodeGenerator, funcInfo, false/*isConstructorCall*/);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocationTmp, initializer->location);\n        funcInfo->ReleaseLoc(initializer);\n\n        byteCodeGenerator->Writer()->MarkLabel(end);\n    }\n\n    if (lhsElementNode->nop == knopArrayPattern)\n    {\n        EmitDestructuredArray(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else if (lhsElementNode->nop == knopObjectPattern)\n    {\n        EmitDestructuredObject(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else if (isNonPatternAssignmentTarget)\n    {\n        EmitAssignment(nullptr, lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitDestructuredElement(lhsElementNode, rhsLocationTmp, byteCodeGenerator, funcInfo);\n    }\n\n    if (initializer != nullptr)\n    {\n        funcInfo->ReleaseTmpRegister(rhsLocationTmp);\n    }\n}\n\nvoid EmitDestructuredObjectMember(ParseNodePtr memberNode,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Assert(memberNode->nop == knopObjectPatternMember);\n\n    Js::RegSlot nameLocation = funcInfo->AcquireTmpRegister();\n    EmitNameInvoke(nameLocation, rhsLocation, memberNode->sxBin.pnode1, byteCodeGenerator, funcInfo);\n\n    // Imagine we are transforming\n    // {x:x1} = {} to x1 = {}.x  (here x1 is the second node of the member but that is our lhsnode)\n\n    ParseNodePtr lhsElementNode = memberNode->sxBin.pnode2;\n    ParseNodePtr init = nullptr;\n    if (lhsElementNode->IsVarLetOrConst())\n    {\n        init = lhsElementNode->sxVar.pnodeInit;\n    }\n    else if (lhsElementNode->nop == knopAsg)\n    {\n        init = lhsElementNode->sxBin.pnode2;\n        lhsElementNode = lhsElementNode->sxBin.pnode1;\n    }\n\n    EmitDestructuredValueOrInitializer(lhsElementNode, nameLocation, init, false /*isNonPatternAssignmentTarget*/, byteCodeGenerator, funcInfo);\n\n    funcInfo->ReleaseTmpRegister(nameLocation);\n}\n\nvoid EmitDestructuredObject(ParseNode *lhs,\n    Js::RegSlot rhsLocationOrig,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    Assert(lhs->nop == knopObjectPattern);\n    ParseNodePtr pnode1 = lhs->sxUni.pnode1;\n\n    byteCodeGenerator->StartStatement(lhs);\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    Js::RegSlot rhsLocation = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, rhsLocation, rhsLocationOrig);\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrNeq_A, skipThrow, rhsLocation, funcInfo->undefinedConstantRegister);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ObjectCoercible));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n\n    if (pnode1 != nullptr)\n    {\n        Assert(pnode1->nop == knopList || pnode1->nop == knopObjectPatternMember);\n\n        ParseNodePtr current = pnode1;\n        while (current->nop == knopList)\n        {\n            ParseNodePtr memberNode = current->sxBin.pnode1;\n            EmitDestructuredObjectMember(memberNode, rhsLocation, byteCodeGenerator, funcInfo);\n            current = current->sxBin.pnode2;\n        }\n        EmitDestructuredObjectMember(current, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(rhsLocation);\n    byteCodeGenerator->EndStatement(lhs);\n}\n\nvoid EmitAssignment(\n    ParseNode *asgnNode,\n    ParseNode *lhs,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    switch (lhs->nop)\n    {\n        // assignment to a local or global variable\n    case knopVarDecl:\n    case knopLetDecl:\n    case knopConstDecl:\n    {\n        Symbol *sym = lhs->sxVar.sym;\n        Assert(sym != nullptr);\n        byteCodeGenerator->EmitPropStore(rhsLocation, sym, nullptr, funcInfo, lhs->nop == knopLetDecl, lhs->nop == knopConstDecl);\n        break;\n    }\n\n    case knopName:\n    {\n        byteCodeGenerator->EmitPropStore(rhsLocation, lhs->sxPid.sym, lhs->sxPid.pid, funcInfo);\n        break;\n    }\n\n    // x.y =\n    case knopDot:\n    {\n        // PutValue(x, \"y\", rhs)\n        Js::PropertyId propertyId = lhs->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(lhs->sxBin.pnode1->location, propertyId, false, true);\n        if (lhs->sxBin.pnode1->nop == knopSuper)\n        {\n            Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n            byteCodeGenerator->Writer()->PatchablePropertyWithThisPtr(Js::OpCode::StSuperFld, rhsLocation, tmpReg, funcInfo->thisPointerRegister, cacheId);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->PatchableProperty(\n                ByteCodeGenerator::GetStFldOpCode(funcInfo, false, false, false, false), rhsLocation, lhs->sxBin.pnode1->location, cacheId);\n        }\n\n        break;\n    }\n\n    case knopIndex:\n    {\n        byteCodeGenerator->Writer()->Element(\n            ByteCodeGenerator::GetStElemIOpCode(funcInfo),\n            rhsLocation, lhs->sxBin.pnode1->location, lhs->sxBin.pnode2->location);\n        break;\n    }\n\n    case knopObjectPattern:\n    {\n        Assert(byteCodeGenerator->IsES6DestructuringEnabled());\n        // Copy the rhs value to be the result of the assignment if needed.\n        if (asgnNode != nullptr)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n        return EmitDestructuredObject(lhs, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    case knopArrayPattern:\n    {\n        Assert(byteCodeGenerator->IsES6DestructuringEnabled());\n        // Copy the rhs value to be the result of the assignment if needed.\n        if (asgnNode != nullptr)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n        return EmitDestructuredArray(lhs, rhsLocation, byteCodeGenerator, funcInfo);\n    }\n\n    case knopArray:\n    case knopObject:\n        // Assignment to array/object can get through to byte code gen when the parser fails to convert destructuring\n        // assignment to pattern (because of structural mismatch between LHS & RHS?). Revisit when we nail\n        // down early vs. runtime errors for destructuring.\n        byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAssignTo));\n        break;\n\n    default:\n        Assert(!PHASE_ON1(Js::EarlyReferenceErrorsPhase));\n        byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAssignTo));\n        break;\n    }\n\n    if (asgnNode != nullptr)\n    {\n        // We leave it up to the caller to pass this node only if the assignment expression is used.\n        if (asgnNode->location != rhsLocation)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, asgnNode->location, rhsLocation);\n        }\n    }\n}\n\nvoid EmitLoad(\n    ParseNode *lhs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // Emit the instructions to load the value into the LHS location. Do not assign/free any temps\n    // in the process.\n    // We usually get here as part of an op-equiv expression: x.y += z;\n    // In such a case, x has to be emitted first, then the value of x.y loaded (by this function), then z emitted.\n    switch (lhs->nop)\n    {\n\n        // load of a local or global variable\n    case knopName:\n    {\n        funcInfo->AcquireLoc(lhs);\n        byteCodeGenerator->EmitPropLoad(lhs->location, lhs->sxPid.sym, lhs->sxPid.pid, funcInfo);\n        break;\n    }\n\n    // = x.y\n    case knopDot:\n    {\n        // get field id for \"y\"\n        Js::PropertyId propertyId = lhs->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(lhs->sxBin.pnode1->location, propertyId, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, lhs->location, lhs->sxBin.pnode1->location, cacheId);\n        break;\n    }\n\n    case knopIndex:\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Element(\n            Js::OpCode::LdElemI_A, lhs->location, lhs->sxBin.pnode1->location, lhs->sxBin.pnode2->location);\n        break;\n\n        // f(x) +=\n    case knopCall:\n        funcInfo->AcquireLoc(lhs);\n        EmitReference(lhs, byteCodeGenerator, funcInfo);\n        EmitCall(lhs, /*rhs=*/ Js::Constants::NoRegister, byteCodeGenerator, funcInfo, /*fReturnValue=*/ false, /*fEvaluateComponents=*/ false, /*fHasNewTarget=*/ false);\n        break;\n\n    default:\n        funcInfo->AcquireLoc(lhs);\n        Emit(lhs, byteCodeGenerator, funcInfo, false);\n        break;\n    }\n}\n\nvoid EmitList(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            byteCodeGenerator->EmitTopLevelStatement(pnode->sxBin.pnode1, funcInfo, false);\n            pnode = pnode->sxBin.pnode2;\n        }\n        byteCodeGenerator->EmitTopLevelStatement(pnode, funcInfo, false);\n    }\n}\n\nvoid EmitSpreadArgToListBytecodeInstr(ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, Js::RegSlot argLoc, Js::ProfileId callSiteId, Js::ArgSlot &argIndex)\n{\n    Js::RegSlot regVal = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, argLoc);\n    byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, regVal, callSiteId);\n    funcInfo->ReleaseTmpRegister(regVal);\n}\n\nsize_t EmitArgs(\n    ParseNode *pnode,\n    BOOL fAssignRegs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr\n    )\n{\n    Js::ArgSlot argIndex = 0;\n    Js::ArgSlot spreadIndex = 0;\n\n    if (pnode != nullptr)\n    {\n        while (pnode->nop == knopList)\n        {\n            // If this is a put, the arguments have already been evaluated (see EmitReference).\n            // We just need to emit the ArgOut instructions.\n            if (fAssignRegs)\n            {\n                Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            }\n\n            if (pnode->sxBin.pnode1->nop == knopEllipsis)\n            {\n                Assert(spreadIndices != nullptr);\n                spreadIndices->elements[spreadIndex++] = argIndex + 1; // account for 'this'\n                EmitSpreadArgToListBytecodeInstr(byteCodeGenerator, funcInfo, pnode->sxBin.pnode1->location, callSiteId, argIndex);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, pnode->sxBin.pnode1->location, callSiteId);\n            }\n            if (fAssignRegs)\n            {\n                funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n            }\n\n            pnode = pnode->sxBin.pnode2;\n        }\n\n        // If this is a put, the call target has already been evaluated (see EmitReference).\n        if (fAssignRegs)\n        {\n            Emit(pnode, byteCodeGenerator, funcInfo, false);\n        }\n\n        if (pnode->nop == knopEllipsis)\n        {\n            Assert(spreadIndices != nullptr);\n            spreadIndices->elements[spreadIndex++] = argIndex + 1; // account for 'this'\n            EmitSpreadArgToListBytecodeInstr(byteCodeGenerator, funcInfo, pnode->location, callSiteId, argIndex);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->ArgOut<true>(++argIndex, pnode->location, callSiteId);\n        }\n\n        if (fAssignRegs)\n        {\n            funcInfo->ReleaseLoc(pnode);\n        }\n    }\n\n    return argIndex;\n}\n\nvoid EmitArgListStart(\n    Js::RegSlot thisLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId)\n{\n    if (thisLocation != Js::Constants::NoRegister)\n    {\n        // Emit the \"this\" object.\n        byteCodeGenerator->Writer()->ArgOut<true>(0, thisLocation, callSiteId);\n    }\n}\n\nJs::ArgSlot EmitArgListEnd(\n    ParseNode *pnode,\n    Js::RegSlot rhsLocation,\n    Js::RegSlot thisLocation,\n    Js::RegSlot evalLocation,\n    Js::RegSlot newTargetLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    size_t argIndex,\n    Js::ProfileId callSiteId)\n{\n    BOOL fEvalInModule = false;\n    BOOL fIsPut = (rhsLocation != Js::Constants::NoRegister);\n    BOOL fIsEval = (evalLocation != Js::Constants::NoRegister);\n    BOOL fHasNewTarget = (newTargetLocation != Js::Constants::NoRegister);\n\n    Js::ArgSlot argSlotIndex = (Js::ArgSlot) argIndex;\n    static const Js::ArgSlot maxExtraArgSlot = 4;  // max(extraEvalArg, extraArg), where extraEvalArg==2 (moduleRoot,env), extraArg==4 (this, eval, evalInModule, newTarget)\n\n    // check for integer overflow with margin for increments below to calculate argument count\n    if ((size_t)argSlotIndex != argIndex || argSlotIndex + maxExtraArgSlot < argSlotIndex)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    Js::ArgSlot evalIndex;\n\n    if (fIsPut)\n    {\n        // Emit the assigned value as an additional operand. Note that the value has already been evaluated.\n        // We just need to emit the ArgOut instruction.\n        argSlotIndex++;\n        byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex, rhsLocation, callSiteId);\n    }\n\n    if (fIsEval && argSlotIndex > 0)\n    {\n        Assert(!fHasNewTarget);\n\n        // Pass the frame display as an extra argument to \"eval\".\n        // Do this only if eval is called with some args\n        Js::RegSlot evalEnv;\n        if (funcInfo->IsGlobalFunction() && !(funcInfo->GetIsStrictMode() && byteCodeGenerator->GetFlags() & fscrEval))\n        {\n            // Use current environment as the environment for the function being called when:\n            // - this is the root global function (not an eval's global function)\n            // - this is an eval's global function that is not in strict mode (see else block)\n            evalEnv = funcInfo->GetEnvRegister();\n        }\n        else\n        {\n            // Use the frame display as the environment for the function being called when:\n            // - this is not a global function and thus it will have its own scope\n            // - this is an eval's global function that is in strict mode, since in strict mode the eval's global function\n            //   has its own scope\n            evalEnv = funcInfo->frameDisplayRegister;\n        }\n\n        evalEnv = byteCodeGenerator->PrependLocalScopes(evalEnv, evalLocation, funcInfo);\n\n        Js::ModuleID moduleID = byteCodeGenerator->GetModuleID();\n        if (moduleID != kmodGlobal)\n        {\n            // Pass both the module root and the environment.\n            fEvalInModule = true;\n            byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex + 1, ByteCodeGenerator::RootObjectRegister, callSiteId);\n            evalIndex = argSlotIndex + 2;\n        }\n        else\n        {\n            // Just pass the environment.\n            evalIndex = argSlotIndex + 1;\n        }\n\n        if (evalEnv == funcInfo->GetEnvRegister() || evalEnv == funcInfo->frameDisplayRegister)\n        {\n            byteCodeGenerator->Writer()->ArgOutEnv(evalIndex);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->ArgOut<false>(evalIndex, evalEnv, callSiteId);\n        }\n    }\n\n    if (fHasNewTarget)\n    {\n        Assert(!fIsEval);\n\n        byteCodeGenerator->Writer()->ArgOut<true>(argSlotIndex + 1, newTargetLocation, callSiteId);\n    }\n\n    Js::ArgSlot argIntCount = argSlotIndex + 1 + (Js::ArgSlot)fIsEval + (Js::ArgSlot)fEvalInModule + (Js::ArgSlot)fHasNewTarget;\n\n    // eval and no args passed, return 1 as argument count\n    if (fIsEval && pnode == nullptr)\n    {\n        return 1;\n    }\n\n    return argIntCount;\n}\n\nJs::ArgSlot EmitArgList(\n    ParseNode *pnode,\n    Js::RegSlot rhsLocation,\n    Js::RegSlot thisLocation,\n    Js::RegSlot newTargetLocation,\n    BOOL fIsEval,\n    BOOL fAssignRegs,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    uint16 spreadArgCount = 0,\n    Js::AuxArray<uint32> **spreadIndices = nullptr)\n{\n    // This function emits the arguments for a call.\n    // ArgOut's with uses immediately following defs.\n\n    EmitArgListStart(thisLocation, byteCodeGenerator, funcInfo, callSiteId);\n\n    Js::RegSlot evalLocation = Js::Constants::NoRegister;\n\n    //\n    // If Emitting arguments for eval and assigning registers, get a tmpLocation for eval.\n    // This would be used while generating frameDisplay in EmitArgListEnd.\n    //\n    if (fIsEval)\n    {\n        evalLocation = funcInfo->AcquireTmpRegister();\n    }\n\n    if (spreadArgCount > 0)\n    {\n        const size_t extraAlloc = spreadArgCount * sizeof(uint32);\n        Assert(spreadIndices != nullptr);\n        *spreadIndices = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<uint32>, spreadArgCount);\n    }\n\n    size_t argIndex = EmitArgs(pnode, fAssignRegs, byteCodeGenerator, funcInfo, callSiteId, spreadIndices == nullptr ? nullptr : *spreadIndices);\n\n    Js::ArgSlot argumentsCount = EmitArgListEnd(pnode, rhsLocation, thisLocation, evalLocation, newTargetLocation, byteCodeGenerator, funcInfo, argIndex, callSiteId);\n\n    if (fIsEval)\n    {\n        funcInfo->ReleaseTmpRegister(evalLocation);\n    }\n\n    return argumentsCount;\n}\n\nvoid EmitConstantArgsToVarArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) Js::Var *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        if (args->sxBin.pnode1->nop == knopInt)\n        {\n            int value = args->sxBin.pnode1->sxInt.lw;\n            vars[index++] = Js::TaggedInt::ToVarUnchecked(value);\n        }\n        else if (args->sxBin.pnode1->nop == knopFlt)\n        {\n            Js::Var number = Js::JavascriptNumber::New(args->sxBin.pnode1->sxFlt.dbl, byteCodeGenerator->GetScriptContext());\n#if ! FLOATVAR\n            byteCodeGenerator->GetScriptContext()->BindReference(number);\n#endif\n            vars[index++] = number;\n        }\n        else\n        {\n            AnalysisAssert(false);\n        }\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    if (args->nop == knopInt)\n    {\n        int value = args->sxInt.lw;\n        vars[index++] = Js::TaggedInt::ToVarUnchecked(value);\n    }\n    else if (args->nop == knopFlt)\n    {\n        Js::Var number = Js::JavascriptNumber::New(args->sxFlt.dbl, byteCodeGenerator->GetScriptContext());\n#if ! FLOATVAR\n        byteCodeGenerator->GetScriptContext()->BindReference(number);\n#endif\n        vars[index++] = number;\n    }\n    else\n    {\n        AnalysisAssert(false);\n    }\n}\n\nvoid EmitConstantArgsToIntArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) int32 *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        Assert(args->sxBin.pnode1->nop == knopInt);\n        vars[index++] = args->sxBin.pnode1->sxInt.lw;\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    Assert(args->nop == knopInt);\n    vars[index++] = args->sxInt.lw;\n\n    Assert(index == argCount);\n}\n\nvoid EmitConstantArgsToFltArray(ByteCodeGenerator *byteCodeGenerator, __out_ecount(argCount) double *vars, ParseNode *args, uint argCount)\n{\n    uint index = 0;\n    while (args->nop == knopList && index < argCount)\n    {\n        OpCode nop = args->sxBin.pnode1->nop;\n        if (nop == knopInt)\n        {\n            vars[index++] = (double)args->sxBin.pnode1->sxInt.lw;\n        }\n        else\n        {\n            Assert(nop == knopFlt);\n            vars[index++] = args->sxBin.pnode1->sxFlt.dbl;\n        }\n        args = args->sxBin.pnode2;\n    }\n\n    if (index == argCount)\n    {\n        Assert(false);\n        Js::Throw::InternalError();\n        return;\n    }\n\n    if (args->nop == knopInt)\n    {\n        vars[index++] = (double)args->sxInt.lw;\n    }\n    else\n    {\n        Assert(args->nop == knopFlt);\n        vars[index++] = args->sxFlt.dbl;\n    }\n\n    Assert(index == argCount);\n}\n\n//\n// Called when we have new Ctr(constant, constant...)\n//\nJs::ArgSlot EmitNewObjectOfConstants(\n    ParseNode *pnode,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    unsigned int argCount)\n{\n    EmitArgListStart(Js::Constants::NoRegister, byteCodeGenerator, funcInfo, Js::Constants::NoProfileId);\n\n    // Create the vars array\n    Js::VarArrayVarCount *vars = AnewPlus(byteCodeGenerator->GetAllocator(), (argCount - 1) * sizeof(Js::Var), Js::VarArrayVarCount, Js::TaggedInt::ToVarUnchecked(argCount - 1));\n\n    // Emit all constants to the vars array\n    EmitConstantArgsToVarArray(byteCodeGenerator, vars->elements, pnode->sxCall.pnodeArgs, argCount - 1);\n\n    // Finish the arg list\n    Js::ArgSlot actualArgCount = EmitArgListEnd(\n        pnode->sxCall.pnodeArgs,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        Js::Constants::NoRegister,\n        byteCodeGenerator,\n        funcInfo,\n        argCount - 1,\n        Js::Constants::NoProfileId);\n\n    // Make sure the cacheId to regSlot map in the ByteCodeWriter is left in a consistent state after writing NewScObject_A\n    byteCodeGenerator->Writer()->RemoveEntryForRegSlotFromCacheIdMap(pnode->sxCall.pnodeTarget->location);\n\n    // Generate the opcode with vars\n    byteCodeGenerator->Writer()->AuxiliaryContext(\n        Js::OpCode::NewScObject_A,\n        funcInfo->AcquireLoc(pnode),\n        vars,\n        sizeof(Js::VarArray) + (argCount - 1) * sizeof(Js::Var),\n        pnode->sxCall.pnodeTarget->location);\n\n    AdeletePlus(byteCodeGenerator->GetAllocator(), (argCount - 1) * sizeof(Js::VarArrayVarCount), vars);\n\n    return actualArgCount;\n}\n\nvoid EmitMethodFld(bool isRoot, bool isScoped, Js::RegSlot location, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, bool registerCacheIdForCall = true)\n{\n    Js::OpCode opcode;\n    if (!isRoot)\n    {\n        if (callObjLocation == funcInfo->frameObjRegister)\n        {\n            opcode = Js::OpCode::LdLocalMethodFld;\n        }\n        else\n        {\n            opcode = Js::OpCode::LdMethodFld;\n        }\n    }\n    else if (isScoped)\n    {\n        opcode = Js::OpCode::ScopedLdMethodFld;\n    }\n    else\n    {\n        opcode = Js::OpCode::LdRootMethodFld;\n    }\n\n    if (isScoped || !isRoot)\n    {\n        Assert(isScoped || !isRoot || callObjLocation == ByteCodeGenerator::RootObjectRegister);\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(callObjLocation, propertyId, true, false);\n        if (callObjLocation == funcInfo->frameObjRegister)\n        {\n            byteCodeGenerator->Writer()->ElementP(opcode, location, cacheId, false /*isCtor*/, registerCacheIdForCall);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->PatchableProperty(opcode, location, callObjLocation, cacheId, false /*isCtor*/, registerCacheIdForCall);\n        }\n    }\n    else\n    {\n        uint cacheId = funcInfo->FindOrAddRootObjectInlineCacheId(propertyId, true, false);\n        byteCodeGenerator->Writer()->PatchableRootProperty(opcode, location, cacheId, true, false, registerCacheIdForCall);\n    }\n}\n\nvoid EmitMethodFld(ParseNode *pnode, Js::RegSlot callObjLocation, Js::PropertyId propertyId, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, bool registerCacheIdForCall = true)\n{\n    // Load a call target of the form x.y(). (Call target may be a plain knopName if we're getting it from\n    // the global object, etc.)\n    bool isRoot = pnode->nop == knopName && (pnode->sxPid.sym == nullptr || pnode->sxPid.sym->GetIsGlobal());\n    bool isScoped = (byteCodeGenerator->GetFlags() & fscrEval) != 0 ||\n        (isRoot && callObjLocation != ByteCodeGenerator::RootObjectRegister);\n\n    EmitMethodFld(isRoot, isScoped, pnode->location, callObjLocation, propertyId, byteCodeGenerator, funcInfo, registerCacheIdForCall);\n}\n\n// lhs.apply(this, arguments);\nvoid EmitApplyCall(ParseNode* pnode, Js::RegSlot rhsLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo, BOOL fReturnValue)\n{\n    ParseNode* applyNode = pnode->sxCall.pnodeTarget;\n    ParseNode* thisNode = pnode->sxCall.pnodeArgs->sxBin.pnode1;\n    Assert(applyNode->nop == knopDot);\n\n    ParseNode* funcNode = applyNode->sxBin.pnode1;\n    Js::ByteCodeLabel slowPath = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel afterSlowPath = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel argsAlreadyCreated = byteCodeGenerator->Writer()->DefineLabel();\n\n    Assert(applyNode->nop == knopDot);\n\n    Emit(funcNode, byteCodeGenerator, funcInfo, false);\n\n    funcInfo->AcquireLoc(applyNode);\n    Js::PropertyId propertyId = applyNode->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n    // As we won't be emitting a call instruction for apply, no need to register the cacheId for apply\n    // load to be associated with the call. This is also required, as in the absence of a corresponding\n    // call for apply, we won't remove the entry for \"apply\" cacheId from\n    // ByteCodeWriter::callRegToLdFldCacheIndexMap, which is contrary to our assumption that we would\n    // have removed an entry from a map upon seeing its corresponding call.\n    EmitMethodFld(applyNode, funcNode->location, propertyId, byteCodeGenerator, funcInfo, false /*registerCacheIdForCall*/);\n\n    Symbol *argSym = funcInfo->GetArgumentsSymbol();\n    Assert(argSym && argSym->GetIsArguments());\n    Js::RegSlot argumentsLoc = argSym->GetLocation();\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdArgumentsFromFrame, argumentsLoc);\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrNotNull_A, argsAlreadyCreated, argumentsLoc);\n\n    // If apply is overridden, bail to slow path.\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFncNeqApply, slowPath, applyNode->location);\n\n    // Note: acquire and release a temp register for this stack arg pointer instead of trying to stash it\n    // in funcInfo->stackArgReg. Otherwise, we'll needlessly load and store it in jitted loop bodies and\n    // may crash if we try to unbox it on the store.\n    Js::RegSlot stackArgReg = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdStackArgPtr, stackArgReg);\n\n    Js::RegSlot argCountLocation = funcInfo->AcquireTmpRegister();\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdArgCnt, argCountLocation);\n    byteCodeGenerator->Writer()->Reg5(Js::OpCode::ApplyArgs, funcNode->location, funcNode->location, thisNode->location, stackArgReg, argCountLocation);\n\n    funcInfo->ReleaseTmpRegister(argCountLocation);\n    funcInfo->ReleaseTmpRegister(stackArgReg);\n    funcInfo->ReleaseLoc(applyNode);\n    funcInfo->ReleaseLoc(funcNode);\n\n    // Clear these nodes as they are going to be used to re-generate the slow path.\n    VisitClearTmpRegs(applyNode, byteCodeGenerator, funcInfo);\n    VisitClearTmpRegs(funcNode, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Br(afterSlowPath);\n\n    // slow path\n    byteCodeGenerator->Writer()->MarkLabel(slowPath);\n    if (funcInfo->frameObjRegister != Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->EmitScopeObjectInit(funcInfo);\n    }\n    byteCodeGenerator->LoadHeapArguments(funcInfo);\n\n    byteCodeGenerator->Writer()->MarkLabel(argsAlreadyCreated);\n    EmitCall(pnode, rhsLocation, byteCodeGenerator, funcInfo, fReturnValue, /*fEvaluateComponents*/true, /*fHasNewTarget*/false);\n    byteCodeGenerator->Writer()->MarkLabel(afterSlowPath);\n}\n\nvoid EmitMethodElem(ParseNode *pnode, Js::RegSlot callObjLocation, Js::RegSlot indexLocation, ByteCodeGenerator *byteCodeGenerator)\n{\n    // Load a call target of the form x[y]().\n    byteCodeGenerator->Writer()->Element(Js::OpCode::LdMethodElem, pnode->location, callObjLocation, indexLocation);\n}\n\nvoid EmitCallTargetNoEvalComponents(\n    ParseNode *pnodeTarget,\n    BOOL fSideEffectArgs,\n    Js::RegSlot *thisLocation,\n    Js::RegSlot *callObjLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // We first get a reference to the call target, then evaluate the arguments, then\n    // evaluate the call target.\n\n    // - emit reference to target\n    //    - copy instance to scratch reg if necessary.\n    //    - assign this\n    //    - assign instance for dynamic/global name\n    // - emit args\n    // - do call (CallFld/Elem/I)\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n        *thisLocation = pnodeTarget->sxBin.pnode1->location;\n        *callObjLocation = pnodeTarget->sxBin.pnode1->location;\n        break;\n\n    case knopIndex:\n        *thisLocation = pnodeTarget->sxBin.pnode1->location;\n        *callObjLocation = pnodeTarget->sxBin.pnode1->location;\n        break;\n\n    case knopName:\n        // If the call target is a name, do some extra work to get its instance and the \"this\" pointer.\n        byteCodeGenerator->EmitLoadInstance(pnodeTarget->sxPid.sym, pnodeTarget->sxPid.pid, thisLocation, callObjLocation, funcInfo);\n        if (*thisLocation == Js::Constants::NoRegister)\n        {\n            *thisLocation = funcInfo->undefinedConstantRegister;\n        }\n\n        break;\n\n    default:\n        *thisLocation = funcInfo->undefinedConstantRegister;\n        break;\n    }\n}\n\nvoid EmitSuperMethodBegin(\n    ParseNode *pnodeTarget,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    FuncInfo *parentFuncInfo = funcInfo;\n    if (parentFuncInfo->IsLambda())\n    {\n        parentFuncInfo = byteCodeGenerator->FindEnclosingNonLambda();\n    }\n\n    if (pnodeTarget->sxBin.pnode1->nop == knopSuper && parentFuncInfo->IsClassConstructor() && !parentFuncInfo->IsBaseClassConstructor())\n    {\n        byteCodeGenerator->EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister, /*chkUndecl*/ true);\n    }\n}\n\nvoid EmitCallTarget(\n    ParseNode *pnodeTarget,\n    BOOL fSideEffectArgs,\n    Js::RegSlot *thisLocation,\n    Js::RegSlot *callObjLocation,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    // - emit target\n    //    - assign this\n    // - emit args\n    // - do call\n\n    // The call target is fully evaluated before the argument list. Note that we're not handling\n    // put-call cases here currently, as such cases only apply to host objects\n    // and are very unlikely to behave differently depending on the order of evaluation.\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs)\n        {\n            // Though we're done with target evaluation after this point, still protect opnd1 from\n            // arg side-effects as it's the \"this\" pointer.\n            SaveOpndValue(pnodeTarget->sxBin.pnode1, funcInfo);\n        }\n\n        if ((pnodeTarget->sxBin.pnode2->nop == knopName) && ((pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::apply) || (pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::call)))\n        {\n            pnodeTarget->sxBin.pnode1->SetIsCallApplyTargetLoad();\n        }\n\n        Emit(pnodeTarget->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Js::PropertyId propertyId = pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n        \n        Js::RegSlot protoLocation =\n            (pnodeTarget->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            pnodeTarget->sxBin.pnode1->location;\n\n        EmitSuperMethodBegin(pnodeTarget, byteCodeGenerator, funcInfo);\n        EmitMethodFld(pnodeTarget, protoLocation, propertyId, byteCodeGenerator, funcInfo);\n\n        // Function calls on the 'super' object should maintain current 'this' pointer\n        *thisLocation = (pnodeTarget->sxBin.pnode1->nop == knopSuper) ? funcInfo->thisPointerRegister : pnodeTarget->sxBin.pnode1->location;\n        break;\n    }\n\n    case knopIndex:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs || !(ParseNode::Grfnop(pnodeTarget->sxBin.pnode2->nop) & fnopLeaf))\n        {\n            // Though we're done with target evaluation after this point, still protect opnd1 from\n            // arg or opnd2 side-effects as it's the \"this\" pointer.\n            SaveOpndValue(pnodeTarget->sxBin.pnode1, funcInfo);\n        }\n        Emit(pnodeTarget->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        Emit(pnodeTarget->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot indexLocation = pnodeTarget->sxBin.pnode2->location;\n\n        Js::RegSlot protoLocation =\n            (pnodeTarget->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            pnodeTarget->sxBin.pnode1->location;\n\n        EmitSuperMethodBegin(pnodeTarget, byteCodeGenerator, funcInfo);\n        EmitMethodElem(pnodeTarget, protoLocation, indexLocation, byteCodeGenerator);\n\n        funcInfo->ReleaseLoc(pnodeTarget->sxBin.pnode2); // don't release indexLocation until after we use it.\n\n        // Function calls on the 'super' object should maintain current 'this' pointer\n        *thisLocation = (pnodeTarget->sxBin.pnode1->nop == knopSuper) ? funcInfo->thisPointerRegister : pnodeTarget->sxBin.pnode1->location;\n        break;\n    }\n\n    case knopClassDecl:\n    {\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false);\n        // We won't always have an assigned this register (e.g. class expression calls.) We need undefined in this case.\n        *thisLocation = funcInfo->thisPointerRegister == Js::Constants::NoRegister ? funcInfo->undefinedConstantRegister : funcInfo->thisPointerRegister;\n        break;\n    }\n\n    case knopSuper:\n    {\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false, /*isConstructorCall*/ true);  // reuse isConstructorCall (\"new super()\" is illegal)\n\n        // Super calls should always use the new.target register unless we don't have one.\n        // That could happen if we have an eval('super()') outside of a class constructor.\n        if (funcInfo->newTargetRegister != Js::Constants::NoRegister)\n        {\n            *thisLocation = funcInfo->newTargetRegister;\n        }\n        else\n        {\n            *thisLocation = funcInfo->thisPointerRegister;\n        }\n        break;\n    }\n\n    case knopName:\n    {\n        funcInfo->AcquireLoc(pnodeTarget);\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        if (fSideEffectArgs)\n        {\n            SaveOpndValue(pnodeTarget, funcInfo);\n        }\n        byteCodeGenerator->EmitLoadInstance(pnodeTarget->sxPid.sym, pnodeTarget->sxPid.pid, thisLocation, callObjLocation, funcInfo);\n        if (*callObjLocation != Js::Constants::NoRegister)\n        {\n            // Load the call target as a property of the instance.\n            Js::PropertyId propertyId = pnodeTarget->sxPid.PropertyIdFromNameNode();\n            EmitMethodFld(pnodeTarget, *callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n            break;\n        }\n\n        // FALL THROUGH to evaluate call target.\n    }\n\n    default:\n        // Assign the call target operand(s), putting them into expression temps if necessary to protect\n        // them from side-effects.\n        Emit(pnodeTarget, byteCodeGenerator, funcInfo, false);\n        *thisLocation = funcInfo->undefinedConstantRegister;\n        break;\n    }\n\n    // \"This\" pointer should have been assigned by the above.\n    Assert(*thisLocation != Js::Constants::NoRegister);\n}\n\nvoid EmitCallI(\n    ParseNode *pnode,\n    BOOL fEvaluateComponents,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    BOOL fHasNewTarget,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit a call where the target is in a register, because it's either a local name or an expression we've\n    // already evaluated.\n\n    ParseNode *pnodeTarget = pnode->sxBin.pnode1;\n    Js::OpCode op;\n    Js::CallFlags callFlags = Js::CallFlags::CallFlags_None;\n    uint spreadExtraAlloc = 0;\n\n    Js::ArgSlot actualArgSlotCount = (Js::ArgSlot) actualArgCount;\n\n    // check for integer overflow\n    if ((size_t)actualArgSlotCount != actualArgCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    if (fIsPut)\n    {\n        if (pnode->sxCall.spreadArgCount > 0)\n        {\n            // TODO(tcare): We are disallowing spread with CallIPut for the moment. See DEVDIV2: 876387\n            //              When CallIPut is migrated to the CallIExtended layout, this can be removed.\n            byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_CantAsgCall));\n        }\n        // Grab a tmp register for the call result.\n        Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n        byteCodeGenerator->Writer()->CallI(Js::OpCode::CallIFlags, tmpReg, pnodeTarget->location, actualArgSlotCount, callSiteId, Js::CallFlags::CallFlags_NewTarget);\n        funcInfo->ReleaseTmpRegister(tmpReg);\n    }\n    else\n    {\n        if (fEvaluateComponents)\n        {\n            // Release the call target operands we assigned above. If we didn't assign them here,\n            // we'll need them later, so we can't re-use them for the result of the call.\n            funcInfo->ReleaseLoc(pnodeTarget);\n        }\n        // Grab a register for the call result.\n        if (pnode->isUsed)\n        {\n            funcInfo->AcquireLoc(pnode);\n        }\n\n        if (fIsEval)\n        {\n            op = Js::OpCode::CallIExtendedFlags;\n            callFlags = Js::CallFlags::CallFlags_ExtraArg;\n        }\n        else\n        {\n            bool isSuperCall = pnodeTarget->nop == knopSuper;\n\n            if (isSuperCall)\n            {\n                callFlags = Js::CallFlags_New;\n            }\n            if (fHasNewTarget)\n            {\n                callFlags = (Js::CallFlags) (callFlags | Js::CallFlags::CallFlags_ExtraArg | Js::CallFlags::CallFlags_NewTarget);\n            }\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                op = (isSuperCall || fHasNewTarget) ? Js::OpCode::CallIExtendedFlags : Js::OpCode::CallIExtended;\n            }\n            else\n            {\n                op = (isSuperCall || fHasNewTarget) ? Js::OpCode::CallIFlags : Js::OpCode::CallI;\n            }\n        }\n\n        if (op == Js::OpCode::CallI || op == Js::OpCode::CallIFlags)\n        {\n            if (pnodeTarget->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnodeTarget->location, funcInfo);\n                byteCodeGenerator->Writer()->CallI(op, pnode->location, tmpReg, actualArgSlotCount, callSiteId, callFlags);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallI(op, pnode->location, pnodeTarget->location, actualArgSlotCount, callSiteId, callFlags);\n            }\n        }\n        else\n        {\n            uint spreadIndicesSize = 0;\n            Js::CallIExtendedOptions options = Js::CallIExtended_None;\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                Assert(spreadIndices != nullptr);\n                spreadExtraAlloc = spreadIndices->count * sizeof(uint32);\n                spreadIndicesSize = sizeof(*spreadIndices) + spreadExtraAlloc;\n                options = Js::CallIExtended_SpreadArgs;\n            }\n\n            if (pnodeTarget->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdFuncObjProto, pnodeTarget->location, funcInfo);\n                byteCodeGenerator->Writer()->CallIExtended(op, pnode->location, tmpReg, actualArgSlotCount, options, spreadIndices, spreadIndicesSize, callSiteId, callFlags);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallIExtended(op, pnode->location, pnodeTarget->location, actualArgSlotCount, options, spreadIndices, spreadIndicesSize, callSiteId, callFlags);\n            }\n        }\n\n        if (pnode->sxCall.spreadArgCount > 0)\n        {\n            Assert(spreadExtraAlloc != 0);\n            AdeletePlus(byteCodeGenerator->GetAllocator(), spreadExtraAlloc, spreadIndices);\n        }\n    }\n}\n\nvoid EmitCallInstrNoEvalComponents(\n    ParseNode *pnode,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    Js::RegSlot thisLocation,\n    Js::RegSlot callObjLocation,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit the call instruction. The call target is a reference at this point, and we evaluate\n    // it as part of doing the actual call.\n    // Note that we don't handle the (fEvaluateComponents == TRUE) case in this function.\n    // (This function is only called on the !fEvaluateComponents branch in EmitCall.)\n\n    ParseNode *pnodeTarget = pnode->sxBin.pnode1;\n\n    switch (pnodeTarget->nop)\n    {\n    case knopDot:\n    {\n        Assert(pnodeTarget->sxBin.pnode2->nop == knopName);\n        Js::PropertyId propertyId = pnodeTarget->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        EmitMethodFld(pnodeTarget, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    break;\n\n    case knopIndex:\n    {\n        EmitMethodElem(pnodeTarget, pnodeTarget->sxBin.pnode1->location, pnodeTarget->sxBin.pnode2->location, byteCodeGenerator);\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    break;\n\n    case knopName:\n    {\n        if (callObjLocation != Js::Constants::NoRegister)\n        {\n            // We still have to get the property from its instance, so emit CallFld.\n            if (thisLocation != callObjLocation)\n            {\n                funcInfo->ReleaseTmpRegister(thisLocation);\n            }\n            funcInfo->ReleaseTmpRegister(callObjLocation);\n\n            Js::PropertyId propertyId = pnodeTarget->sxPid.PropertyIdFromNameNode();\n            EmitMethodFld(pnodeTarget, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n            EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n            break;\n        }\n    }\n    // FALL THROUGH\n\n    default:\n        EmitCallI(pnode, /*fEvaluateComponents*/ FALSE, fIsPut, fIsEval, /*fHasNewTarget*/ FALSE, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n        break;\n    }\n}\n\nvoid EmitCallInstr(\n    ParseNode *pnode,\n    BOOL fIsPut,\n    BOOL fIsEval,\n    BOOL fHasNewTarget,\n    Js::RegSlot thisLocation,\n    Js::RegSlot callObjLocation,\n    uint32 actualArgCount,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    Js::ProfileId callSiteId,\n    Js::AuxArray<uint32> *spreadIndices = nullptr)\n{\n    // Emit a call instruction. The call target has been fully evaluated already, so we always\n    // emit a CallI through the register that holds the target value.\n    // Note that we don't handle !fEvaluateComponents cases at this point.\n    // (This function is only called on the fEvaluateComponents branch in EmitCall.)\n\n    if (thisLocation != Js::Constants::NoRegister)\n    {\n        funcInfo->ReleaseTmpRegister(thisLocation);\n    }\n\n    if (callObjLocation != Js::Constants::NoRegister &&\n        callObjLocation != thisLocation)\n    {\n        funcInfo->ReleaseTmpRegister(callObjLocation);\n    }\n\n    EmitCallI(pnode, /*fEvaluateComponents*/ TRUE, fIsPut, fIsEval, fHasNewTarget, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n}\n\nvoid EmitNew(ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::ArgSlot argCount = pnode->sxCall.argCount;\n    argCount++; // include \"this\"\n\n    BOOL fSideEffectArgs = FALSE;\n    unsigned int tmpCount = CountArguments(pnode->sxCall.pnodeArgs, &fSideEffectArgs);\n    Assert(argCount == tmpCount);\n\n    if (argCount != (Js::ArgSlot)argCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    byteCodeGenerator->StartStatement(pnode);\n\n    // Start call, allocate out param space\n    funcInfo->StartRecordingOutArgs(argCount);\n\n    // Assign the call target operand(s), putting them into expression temps if necessary to protect\n    // them from side-effects.\n    if (fSideEffectArgs)\n    {\n        SaveOpndValue(pnode->sxCall.pnodeTarget, funcInfo);\n    }\n\n    if (pnode->sxCall.pnodeTarget->nop == knopSuper)\n    {\n        EmitSuperFieldPatch(funcInfo, pnode, byteCodeGenerator);\n    }\n\n    Emit(pnode->sxCall.pnodeTarget, byteCodeGenerator, funcInfo, false, true);\n\n    if (pnode->sxCall.pnodeArgs == nullptr)\n    {\n        funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n        Js::OpCode op = (CreateNativeArrays(byteCodeGenerator, funcInfo)\n            && CallTargetIsArray(pnode->sxCall.pnodeTarget))\n            ? Js::OpCode::NewScObjArray : Js::OpCode::NewScObject;\n        Assert(argCount == 1);\n\n        Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(op);\n        byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argCount);\n        byteCodeGenerator->Writer()->CallI(op, funcInfo->AcquireLoc(pnode),\n            pnode->sxCall.pnodeTarget->location, argCount, callSiteId);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argCount);\n        uint32 actualArgCount = 0;\n\n        if (IsCallOfConstants(pnode))\n        {\n            funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n            actualArgCount = EmitNewObjectOfConstants(pnode, byteCodeGenerator, funcInfo, argCount);\n        }\n        else\n        {\n            Js::OpCode op;\n            if ((CreateNativeArrays(byteCodeGenerator, funcInfo) && CallTargetIsArray(pnode->sxCall.pnodeTarget)))\n            {\n                op = pnode->sxCall.spreadArgCount > 0 ? Js::OpCode::NewScObjArraySpread : Js::OpCode::NewScObjArray;\n            }\n            else\n            {\n                op = pnode->sxCall.spreadArgCount > 0 ? Js::OpCode::NewScObjectSpread : Js::OpCode::NewScObject;\n            }\n\n            Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(op);\n\n\n            Js::AuxArray<uint32> *spreadIndices = nullptr;\n            actualArgCount = EmitArgList(pnode->sxCall.pnodeArgs, Js::Constants::NoRegister, Js::Constants::NoRegister, Js::Constants::NoRegister,\n                false, true, byteCodeGenerator, funcInfo, callSiteId, pnode->sxCall.spreadArgCount, &spreadIndices);\n            funcInfo->ReleaseLoc(pnode->sxCall.pnodeTarget);\n\n\n            if (pnode->sxCall.spreadArgCount > 0)\n            {\n                Assert(spreadIndices != nullptr);\n                uint spreadExtraAlloc = spreadIndices->count * sizeof(uint32);\n                uint spreadIndicesSize = sizeof(*spreadIndices) + spreadExtraAlloc;\n                byteCodeGenerator->Writer()->CallIExtended(op, funcInfo->AcquireLoc(pnode), pnode->sxCall.pnodeTarget->location,\n                    (uint16)actualArgCount, Js::CallIExtended_SpreadArgs,\n                    spreadIndices, spreadIndicesSize, callSiteId);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->CallI(op, funcInfo->AcquireLoc(pnode), pnode->sxCall.pnodeTarget->location,\n                    (uint16)actualArgCount, callSiteId);\n            }\n        }\n\n        Assert(argCount == actualArgCount);\n    }\n\n    // End call, pop param space\n    funcInfo->EndRecordingOutArgs(argCount);\n    return;\n}\n\nvoid EmitCall(\n    ParseNode* pnode,\n    Js::RegSlot rhsLocation,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo,\n    BOOL fReturnValue,\n    BOOL fEvaluateComponents,\n    BOOL fHasNewTarget,\n    Js::RegSlot overrideThisLocation)\n{\n    BOOL fIsPut = (rhsLocation != Js::Constants::NoRegister);\n    // If the call returns a float, we'll note this in the byte code.\n    Js::RegSlot thisLocation = Js::Constants::NoRegister;\n    Js::RegSlot callObjLocation = Js::Constants::NoRegister;\n    Js::RegSlot newTargetLocation = Js::Constants::NoRegister;\n    BOOL fSideEffectArgs = FALSE;\n    ParseNode *pnodeTarget = pnode->sxCall.pnodeTarget;\n    ParseNode *pnodeArgs = pnode->sxCall.pnodeArgs;\n    uint16 spreadArgCount = pnode->sxCall.spreadArgCount;\n\n    if (CreateNativeArrays(byteCodeGenerator, funcInfo) && CallTargetIsArray(pnode->sxCall.pnodeTarget)) {\n        // some minifiers (potentially incorrectly) assume that \"v = new Array()\" and \"v = Array()\" are equivalent,\n        // and replace the former with the latter to save 4 characters. What that means for us is that it, at least\n        // initially, uses the \"Call\" path. We want to guess that it _is_ just \"new Array()\" and change over to the\n        // \"new\" path, since then our native array handling can kick in.\n        /*EmitNew(pnode, byteCodeGenerator, funcInfo);\n        return;*/\n    }\n\n    unsigned int argCount = CountArguments(pnode->sxCall.pnodeArgs, &fSideEffectArgs) + (unsigned int)fIsPut;\n\n    BOOL fIsEval = !fIsPut && pnode->sxCall.isEvalCall;\n\n    if (fIsEval)\n    {\n        Assert(!fHasNewTarget);\n\n        //\n        // \"eval\" takes the closure environment as an extra argument\n        // Pass the closure env only if some argument is passed\n        // For just eval(), don't pass the closure environment\n        //\n        if (argCount > 1)\n        {\n            // Check the module ID as well. If it's not the global (default) module,\n            // we need to pass the root to eval so it can do the right global lookups.\n            // (Passing the module root is the least disruptive way to get the module ID\n            // to the helper, given the current set of byte codes. Once we have a full set\n            // of byte code ops taking immediate opnds, passing the ID is more intuitive.)\n            Js::ModuleID moduleID = byteCodeGenerator->GetModuleID();\n            if (moduleID == kmodGlobal)\n            {\n                argCount++;\n            }\n            else\n            {\n                // Module ID must be passed\n                argCount += 2;\n            }\n        }\n    }\n\n    if (fHasNewTarget)\n    {\n        Assert(!fIsEval);\n\n        // When we need to pass new.target explicitly, it is passed as an extra argument.\n        // This is similar to how eval passes an extra argument for the frame display and is\n        // used to support cases where we need to pass both 'this' and new.target as part of\n        // a function call.\n        // OpCode::LdNewTarget knows how to look at the call flags and fetch this argument.\n        argCount++;\n        newTargetLocation = funcInfo->newTargetRegister;\n\n        Assert(newTargetLocation != Js::Constants::NoRegister);\n    }\n\n    Js::ArgSlot argSlotCount = (Js::ArgSlot)argCount;\n\n    if (argCount != (unsigned int)argSlotCount)\n    {\n        Js::Throw::OutOfMemory();\n    }\n\n    if (fReturnValue)\n    {\n        pnode->isUsed = true;\n    }\n\n    //\n    // Set up the call.\n    //\n\n    if (!fEvaluateComponents)\n    {\n        EmitCallTargetNoEvalComponents(pnodeTarget, fSideEffectArgs, &thisLocation, &callObjLocation, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitCallTarget(pnodeTarget, fSideEffectArgs, &thisLocation, &callObjLocation, byteCodeGenerator, funcInfo);\n    }\n\n    bool releaseThisLocation = true;\n    // If we are strictly overriding the this location, ignore what the call target set this location to.\n    if (overrideThisLocation != Js::Constants::NoRegister)\n    {\n        thisLocation = overrideThisLocation;\n        releaseThisLocation = false;\n    }\n\n    // Evaluate the arguments (nothing mode-specific here).\n    // Start call, allocate out param space\n    funcInfo->StartRecordingOutArgs(argSlotCount);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, argSlotCount);\n    Js::AuxArray<uint32> *spreadIndices;\n    Js::ArgSlot actualArgCount = EmitArgList(pnodeArgs, rhsLocation, thisLocation, newTargetLocation, fIsEval, fEvaluateComponents, byteCodeGenerator, funcInfo, callSiteId, spreadArgCount, &spreadIndices);\n    Assert(argSlotCount == actualArgCount);\n\n    if (!fEvaluateComponents)\n    {\n        EmitCallInstrNoEvalComponents(pnode, fIsPut, fIsEval, thisLocation, callObjLocation, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n    else\n    {\n        EmitCallInstr(pnode, fIsPut, fIsEval, fHasNewTarget, releaseThisLocation ? thisLocation : Js::Constants::NoRegister, callObjLocation, actualArgCount, byteCodeGenerator, funcInfo, callSiteId, spreadIndices);\n    }\n\n    // End call, pop param space\n    funcInfo->EndRecordingOutArgs(argSlotCount);\n}\n\nvoid EmitInvoke(\n    Js::RegSlot location,\n    Js::RegSlot callObjLocation,\n    Js::PropertyId propertyId,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo)\n{\n    EmitMethodFld(false, false, location, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n\n    funcInfo->StartRecordingOutArgs(1);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, 1);\n    EmitArgListStart(callObjLocation, byteCodeGenerator, funcInfo, callSiteId);\n\n    byteCodeGenerator->Writer()->CallI(Js::OpCode::CallI, location, location, 1, callSiteId);\n}\n\nvoid EmitInvoke(\n    Js::RegSlot location,\n    Js::RegSlot callObjLocation,\n    Js::PropertyId propertyId,\n    ByteCodeGenerator* byteCodeGenerator,\n    FuncInfo* funcInfo,\n    Js::RegSlot arg1Location)\n{\n    EmitMethodFld(false, false, location, callObjLocation, propertyId, byteCodeGenerator, funcInfo);\n\n    funcInfo->StartRecordingOutArgs(2);\n\n    Js::ProfileId callSiteId = byteCodeGenerator->GetNextCallSiteId(Js::OpCode::CallI);\n\n    byteCodeGenerator->Writer()->StartCall(Js::OpCode::StartCall, 2);\n    EmitArgListStart(callObjLocation, byteCodeGenerator, funcInfo, callSiteId);\n    byteCodeGenerator->Writer()->ArgOut<true>(1, arg1Location, callSiteId);\n\n    byteCodeGenerator->Writer()->CallI(Js::OpCode::CallI, location, location, 2, callSiteId);\n}\n\nvoid EmitComputedFunctionNameVar(ParseNode *nameNode, ParseNode *exprNode, ByteCodeGenerator *byteCodeGenerator)\n{\n    AssertMsg(exprNode != nullptr, \"callers of this function should pass in a valid expression Node\");\n\n    if (nameNode == nullptr)\n    {\n        return;\n    }\n\n    if ((exprNode->nop == knopFncDecl && (exprNode->sxFnc.pnodeName == nullptr || exprNode->sxFnc.pnodeName->nop != knopVarDecl)))\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetComputedNameVar, exprNode->location, nameNode->location);\n    }\n}\n\nvoid EmitMemberNode(ParseNode *memberNode, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, ParseNode* parentNode, bool useStore, bool* isObjectEmpty = nullptr)\n{\n    ParseNode *nameNode = memberNode->sxBin.pnode1;\n    ParseNode *exprNode = memberNode->sxBin.pnode2;\n\n    bool isFncDecl = exprNode->nop == knopFncDecl;\n    bool isClassMember = isFncDecl && exprNode->sxFnc.IsClassMember();\n\n    // Moved SetComputedNameVar before LdFld of prototype because loading the prototype undefers the function TypeHandler\n    // which makes this bytecode too late to influence the function.name.\n    if (nameNode->nop == knopComputedName)\n    {\n        // Computed property name\n        // Transparently pass the name expr\n        // The Emit will replace this with a temp register if necessary to preserve the value.\n        nameNode->location = nameNode->sxUni.pnode1->location;\n        EmitBinaryOpnds(nameNode, exprNode, byteCodeGenerator, funcInfo);\n        if (isFncDecl && !exprNode->sxFnc.IsClassConstructor())\n        {\n            EmitComputedFunctionNameVar(nameNode, exprNode, byteCodeGenerator);\n        }\n    }\n\n    // Classes allocates a RegSlot as part of Instance Methods EmitClassInitializers,\n    // but if we don't have any members then we don't need to load the prototype.\n    Assert(isClassMember == (isObjectEmpty != nullptr));\n    if (isClassMember && *isObjectEmpty)\n    {\n        *isObjectEmpty = false;\n        int cacheId = funcInfo->FindOrAddInlineCacheId(parentNode->location, Js::PropertyIds::prototype, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, objectLocation, parentNode->location, cacheId);\n    }\n\n    if (nameNode->nop == knopComputedName)\n    {\n        Assert(memberNode->nop == knopGetMember || memberNode->nop == knopSetMember || memberNode->nop == knopMember);\n\n        Js::OpCode setOp = memberNode->nop == knopGetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberGetComputedName : Js::OpCode::InitGetElemI) :\n            memberNode->nop == knopSetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberSetComputedName : Js::OpCode::InitSetElemI) :\n            (isClassMember ? Js::OpCode::InitClassMemberComputedName : Js::OpCode::InitComputedProperty);\n\n        byteCodeGenerator->Writer()->Element(setOp, exprNode->location, objectLocation, nameNode->location, true);\n\n        // Class and object members need a reference back to the class.\n        if (isFncDecl)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, exprNode->location, objectLocation);\n        }\n\n        funcInfo->ReleaseLoc(exprNode);\n        funcInfo->ReleaseLoc(nameNode);\n\n        return;\n    }\n\n    Js::OpCode stFldOpCode = (Js::OpCode)0;\n    if (useStore)\n    {\n        stFldOpCode = ByteCodeGenerator::GetStFldOpCode(funcInfo, false, false, false, isClassMember);\n    }\n\n    Emit(exprNode, byteCodeGenerator, funcInfo, false);\n    Js::PropertyId propertyId = nameNode->sxPid.PropertyIdFromNameNode();\n\n    if (Js::PropertyIds::name == propertyId\n        && exprNode->nop == knopFncDecl\n        && exprNode->sxFnc.IsStaticMember()\n        && parentNode != nullptr && parentNode->nop == knopClassDecl\n        && parentNode->sxClass.pnodeConstructor != nullptr)\n    {\n        Js::ParseableFunctionInfo* nameFunc = parentNode->sxClass.pnodeConstructor->sxFnc.funcInfo->byteCodeFunction->GetParseableFunctionInfo();\n        nameFunc->SetIsStaticNameFunction(true);\n    }\n\n    if (memberNode->nop == knopMember || memberNode->nop == knopMemberShort)\n    {\n        // The internal prototype should be set only if the production is of the form PropertyDefinition : PropertyName : AssignmentExpression\n        if (propertyId == Js::PropertyIds::__proto__ && memberNode->nop != knopMemberShort && (exprNode->nop != knopFncDecl || !exprNode->sxFnc.IsMethod()))\n        {\n            byteCodeGenerator->Writer()->Property(Js::OpCode::InitProto, exprNode->location, objectLocation,\n                funcInfo->FindOrAddReferencedPropertyId(propertyId));\n        }\n        else\n        {\n            uint cacheId = funcInfo->FindOrAddInlineCacheId(objectLocation, propertyId, false, true);\n            Js::OpCode patchablePropertyOpCode;\n\n            if (useStore)\n            {\n                patchablePropertyOpCode = stFldOpCode;\n            }\n            else if (isClassMember)\n            {\n                patchablePropertyOpCode = Js::OpCode::InitClassMember;\n            }\n            else\n            {\n                patchablePropertyOpCode = Js::OpCode::InitFld;\n            }\n\n            byteCodeGenerator->Writer()->PatchableProperty(patchablePropertyOpCode, exprNode->location, objectLocation, cacheId);\n        }\n    }\n    else\n    {\n        Assert(memberNode->nop == knopGetMember || memberNode->nop == knopSetMember);\n\n        Js::OpCode setOp = memberNode->nop == knopGetMember ?\n            (isClassMember ? Js::OpCode::InitClassMemberGet : Js::OpCode::InitGetFld) :\n            (isClassMember ? Js::OpCode::InitClassMemberSet : Js::OpCode::InitSetFld);\n\n        byteCodeGenerator->Writer()->Property(setOp, exprNode->location, objectLocation, funcInfo->FindOrAddReferencedPropertyId(propertyId));\n    }\n\n    // Class and object members need a reference back to the class.\n    if (isFncDecl)\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, exprNode->location, objectLocation);\n    }\n\n    funcInfo->ReleaseLoc(exprNode);\n\n    if (propertyId == Js::PropertyIds::valueOf)\n    {\n        byteCodeGenerator->GetScriptContext()->optimizationOverrides.SetSideEffects(Js::SideEffects_ValueOf);\n    }\n    else if (propertyId == Js::PropertyIds::toString)\n    {\n        byteCodeGenerator->GetScriptContext()->optimizationOverrides.SetSideEffects(Js::SideEffects_ToString);\n    }\n}\n\nvoid EmitClassInitializers(ParseNode *memberList, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, ParseNode* parentNode, bool isObjectEmpty)\n{\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            ParseNode *memberNode = memberList->sxBin.pnode1;\n            EmitMemberNode(memberNode, objectLocation, byteCodeGenerator, funcInfo, parentNode, /*useStore*/ false, &isObjectEmpty);\n            memberList = memberList->sxBin.pnode2;\n        }\n        EmitMemberNode(memberList, objectLocation, byteCodeGenerator, funcInfo, parentNode, /*useStore*/ false, &isObjectEmpty);\n    }\n}\n\nvoid EmitObjectInitializers(ParseNode *memberList, Js::RegSlot objectLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    ParseNode *pmemberList = memberList;\n    unsigned int argCount = 0;\n    uint32  value;\n    Js::PropertyId propertyId;\n\n    //\n    // 1. Add all non-int property ids to a dictionary propertyIds with value true\n    // 2. Get the count of propertyIds\n    // 3. Create a propertyId array of size count\n    // 4. Put the propIds in the auxiliary area\n    // 5. Get the objectLiteralCacheId\n    // 6. Generate propId inits with values\n    //\n\n    // Handle propertyId collision\n    typedef JsUtil::BaseHashSet<Js::PropertyId, ArenaAllocator, PowerOf2SizePolicy> PropertyIdSet;\n    PropertyIdSet* propertyIds = Anew(byteCodeGenerator->GetAllocator(), PropertyIdSet, byteCodeGenerator->GetAllocator(), 17);\n\n    bool hasComputedName = false;\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            if (memberList->sxBin.pnode1->sxBin.pnode1->nop == knopComputedName)\n            {\n                hasComputedName = true;\n                break;\n            }\n\n            propertyId = memberList->sxBin.pnode1->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value))\n            {\n                propertyIds->Item(propertyId);\n            }\n\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        if (memberList->sxBin.pnode1->nop != knopComputedName && !hasComputedName)\n        {\n            propertyId = memberList->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value))\n            {\n                propertyIds->Item(propertyId);\n            }\n        }\n    }\n\n    argCount = propertyIds->Count();\n\n    memberList = pmemberList;\n    if ((memberList == nullptr) || (argCount == 0))\n    {\n        // Empty literal or numeric property only object literal\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::NewScObjectSimple, objectLocation);\n    }\n    else\n    {\n        Js::PropertyIdArray *propIds = AnewPlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::PropertyId), Js::PropertyIdArray, argCount, 0);\n\n        if (propertyIds->ContainsKey(Js::PropertyIds::__proto__))\n        {\n            // Always record whether the initializer contains __proto__ no matter if current environment has it enabled\n            // or not, in case the bytecode is later run with __proto__ enabled.\n            propIds->has__proto__ = true;\n        }\n\n        unsigned int argIndex = 0;\n        while (memberList->nop == knopList)\n        {\n            if (memberList->sxBin.pnode1->sxBin.pnode1->nop == knopComputedName)\n            {\n                break;\n            }\n            propertyId = memberList->sxBin.pnode1->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value) && propertyIds->Remove(propertyId))\n            {\n                propIds->elements[argIndex] = propertyId;\n                argIndex++;\n            }\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        if (memberList->sxBin.pnode1->nop != knopComputedName && !hasComputedName)\n        {\n            propertyId = memberList->sxBin.pnode1->sxPid.PropertyIdFromNameNode();\n            if (!byteCodeGenerator->GetScriptContext()->IsNumericPropertyId(propertyId, &value) && propertyIds->Remove(propertyId))\n            {\n                propIds->elements[argIndex] = propertyId;\n                argIndex++;\n            }\n        }\n\n        uint32 literalObjectId = funcInfo->GetParsedFunctionBody()->NewObjectLiteral();\n\n        // Generate the opcode with propIds and cacheId\n        byteCodeGenerator->Writer()->Auxiliary(Js::OpCode::NewScObjectLiteral, objectLocation, propIds, sizeof(Js::PropertyIdArray) + argCount * sizeof(Js::PropertyId), literalObjectId);\n\n        Adelete(byteCodeGenerator->GetAllocator(), propertyIds);\n\n        AdeletePlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::PropertyId), propIds);\n    }\n\n    memberList = pmemberList;\n\n    bool useStore = false;\n    // Generate the actual assignment to those properties\n    if (memberList != nullptr)\n    {\n        while (memberList->nop == knopList)\n        {\n            ParseNode *memberNode = memberList->sxBin.pnode1;\n\n            if (memberNode->sxBin.pnode1->nop == knopComputedName)\n            {\n                useStore = true;\n            }\n\n            byteCodeGenerator->StartSubexpression(memberNode);\n            EmitMemberNode(memberNode, objectLocation, byteCodeGenerator, funcInfo, nullptr, useStore);\n            byteCodeGenerator->EndSubexpression(memberNode);\n            memberList = memberList->sxBin.pnode2;\n        }\n\n        byteCodeGenerator->StartSubexpression(memberList);\n        EmitMemberNode(memberList, objectLocation, byteCodeGenerator, funcInfo, nullptr, useStore);\n        byteCodeGenerator->EndSubexpression(memberList);\n    }\n}\n\nvoid EmitStringTemplate(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Assert(pnode->sxStrTemplate.pnodeStringLiterals);\n\n    // For a tagged string template, we will create the callsite constant object as part of the FunctionBody constants table.\n    // We only need to emit code for non-tagged string templates here.\n    if (!pnode->sxStrTemplate.isTaggedTemplate)\n    {\n        // If we have no substitutions and this is not a tagged template, we can emit just the single cooked string.\n        if (pnode->sxStrTemplate.pnodeSubstitutionExpressions == nullptr)\n        {\n            Assert(pnode->sxStrTemplate.pnodeStringLiterals->nop != knopList);\n\n            funcInfo->AcquireLoc(pnode);\n            Emit(pnode->sxStrTemplate.pnodeStringLiterals, byteCodeGenerator, funcInfo, false);\n\n            Assert(pnode->location != pnode->sxStrTemplate.pnodeStringLiterals->location);\n\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxStrTemplate.pnodeStringLiterals->location);\n            funcInfo->ReleaseLoc(pnode->sxStrTemplate.pnodeStringLiterals);\n        }\n        else\n        {\n            // If we have substitutions but no tag function, we can skip the callSite object construction (and also ignore raw strings).\n            funcInfo->AcquireLoc(pnode);\n\n            // First string must be a list node since we have substitutions.\n            AssertMsg(pnode->sxStrTemplate.pnodeStringLiterals->nop == knopList, \"First string in the list must be a knopList node.\");\n\n            ParseNode* stringNodeList = pnode->sxStrTemplate.pnodeStringLiterals;\n\n            // Emit the first string and load that into the pnode location.\n            Emit(stringNodeList->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n\n            Assert(pnode->location != stringNodeList->sxBin.pnode1->location);\n\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, stringNodeList->sxBin.pnode1->location);\n            funcInfo->ReleaseLoc(stringNodeList->sxBin.pnode1);\n\n            ParseNode* expressionNodeList = pnode->sxStrTemplate.pnodeSubstitutionExpressions;\n            ParseNode* stringNode;\n            ParseNode* expressionNode;\n\n            // Now append the substitution expressions and remaining string constants via normal add operator\n            // We will always have one more string constant than substitution expression\n            // `strcon1 ${expr1} strcon2 ${expr2} strcon3` = strcon1 + expr1 + strcon2 + expr2 + strcon3\n            //\n            // strcon1 --- step 1 (above)\n            // expr1   \\__ step 2\n            // strcon2 /\n            // expr2   \\__ step 3\n            // strcon3 /\n            while (stringNodeList->nop == knopList)\n            {\n                // If the current head of the expression list is a list, fetch the node and walk the list.\n                if (expressionNodeList->nop == knopList)\n                {\n                    expressionNode = expressionNodeList->sxBin.pnode1;\n                    expressionNodeList = expressionNodeList->sxBin.pnode2;\n                }\n                else\n                {\n                    // This is the last element of the expression list.\n                    expressionNode = expressionNodeList;\n                }\n\n                // Emit the expression and append it to the string we're building.\n                Emit(expressionNode, byteCodeGenerator, funcInfo, false);\n\n                Js::RegSlot toStringLocation = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Str, toStringLocation, expressionNode->location);\n                byteCodeGenerator->Writer()->Reg3(Js::OpCode::Add_A, pnode->location, pnode->location, toStringLocation);\n                funcInfo->ReleaseTmpRegister(toStringLocation);\n                funcInfo->ReleaseLoc(expressionNode);\n\n                // Move to the next string in the list - we already got ahead of the expressions in the first string literal above.\n                stringNodeList = stringNodeList->sxBin.pnode2;\n\n                // If the current head of the string literal list is also a list node, need to fetch the actual string literal node.\n                if (stringNodeList->nop == knopList)\n                {\n                    stringNode = stringNodeList->sxBin.pnode1;\n                }\n                else\n                {\n                    // This is the last element of the string literal list.\n                    stringNode = stringNodeList;\n                }\n\n                // Emit the string node following the previous expression and append it to the string.\n                // This is either just some string in the list or it is the last string.\n                Emit(stringNode, byteCodeGenerator, funcInfo, false);\n                byteCodeGenerator->Writer()->Reg3(Js::OpCode::Add_A, pnode->location, pnode->location, stringNode->location);\n                funcInfo->ReleaseLoc(stringNode);\n            }\n        }\n    }\n}\n\nvoid SetNewArrayElements(ParseNode *pnode, Js::RegSlot arrayLocation, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    ParseNode *args = pnode->sxUni.pnode1;\n    uint argCount = pnode->sxArrLit.count;\n    uint spreadCount = pnode->sxArrLit.spreadCount;\n    bool nativeArrays = CreateNativeArrays(byteCodeGenerator, funcInfo);\n\n    bool arrayIntOpt = nativeArrays && pnode->sxArrLit.arrayOfInts;\n    if (arrayIntOpt)\n    {\n        int extraAlloc = argCount * sizeof(int32);\n        Js::AuxArray<int> *ints = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<int32>, argCount);\n        EmitConstantArgsToIntArray(byteCodeGenerator, ints->elements, args, argCount);\n        Assert(!pnode->sxArrLit.hasMissingValues);\n        byteCodeGenerator->Writer()->Auxiliary(\n            Js::OpCode::NewScIntArray,\n            pnode->location,\n            ints,\n            sizeof(Js::AuxArray<int>) + extraAlloc,\n            argCount);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, ints);\n        return;\n    }\n\n    bool arrayNumOpt = nativeArrays && pnode->sxArrLit.arrayOfNumbers;\n    if (arrayNumOpt)\n    {\n        int extraAlloc = argCount * sizeof(double);\n        Js::AuxArray<double> *doubles = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<double>, argCount);\n        EmitConstantArgsToFltArray(byteCodeGenerator, doubles->elements, args, argCount);\n        Assert(!pnode->sxArrLit.hasMissingValues);\n        byteCodeGenerator->Writer()->Auxiliary(\n            Js::OpCode::NewScFltArray,\n            pnode->location,\n            doubles,\n            sizeof(Js::AuxArray<double>) + extraAlloc,\n            argCount);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, doubles);\n        return;\n    }\n\n    bool arrayLitOpt = pnode->sxArrLit.arrayOfTaggedInts && pnode->sxArrLit.count > 1;\n    Assert(!arrayLitOpt || !nativeArrays);\n\n    Js::RegSlot spreadArrLoc = arrayLocation;\n    Js::AuxArray<uint32> *spreadIndices = nullptr;\n    const uint extraAlloc = spreadCount * sizeof(uint32);\n    if (pnode->sxArrLit.spreadCount > 0)\n    {\n        arrayLocation = funcInfo->AcquireTmpRegister();\n        spreadIndices = AnewPlus(byteCodeGenerator->GetAllocator(), extraAlloc, Js::AuxArray<uint32>, spreadCount);\n    }\n\n    byteCodeGenerator->Writer()->Reg1Unsigned1(\n        pnode->sxArrLit.hasMissingValues ? Js::OpCode::NewScArrayWithMissingValues : Js::OpCode::NewScArray,\n        arrayLocation,\n        argCount);\n\n    if (args != nullptr)\n    {\n        Js::OpCode opcode;\n        Js::RegSlot arrLoc;\n        if (argCount == 1 && !byteCodeGenerator->Writer()->DoProfileNewScArrayOp(Js::OpCode::NewScArray))\n        {\n            opcode = Js::OpCode::StArrItemC_CI4;\n            arrLoc = arrayLocation;\n        }\n        else if (arrayLitOpt)\n        {\n            opcode = Js::OpCode::StArrSegItem_A;\n            arrLoc = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdArrHead, arrLoc, arrayLocation);\n        }\n        else if (Js::JavascriptArray::HasInlineHeadSegment(argCount))\n        {\n            // The head segment will be allocated inline as an interior pointer. To keep the array alive, the set operation\n            // should be done relative to the array header to keep it alive (instead of the array segment).\n            opcode = Js::OpCode::StArrInlineItem_CI4;\n            arrLoc = arrayLocation;\n        }\n        else if (argCount <= Js::JavascriptArray::MaxInitialDenseLength)\n        {\n            opcode = Js::OpCode::StArrSegItem_CI4;\n            arrLoc = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdArrHead, arrLoc, arrayLocation);\n        }\n        else\n        {\n            opcode = Js::OpCode::StArrItemI_CI4;\n            arrLoc = arrayLocation;\n        }\n\n        if (arrayLitOpt)\n        {\n            Js::VarArray *vars = AnewPlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::Var), Js::VarArray, argCount);\n\n            EmitConstantArgsToVarArray(byteCodeGenerator, vars->elements, args, argCount);\n\n            // Generate the opcode with vars\n            byteCodeGenerator->Writer()->Auxiliary(Js::OpCode::StArrSegItem_A, arrLoc, vars, sizeof(Js::VarArray) + argCount * sizeof(Js::Var), argCount);\n\n            AdeletePlus(byteCodeGenerator->GetAllocator(), argCount * sizeof(Js::Var), vars);\n        }\n        else\n        {\n            uint i = 0;\n            unsigned spreadIndex = 0;\n            Js::RegSlot rhsLocation;\n            while (args->nop == knopList)\n            {\n                if (args->sxBin.pnode1->nop != knopEmpty)\n                {\n                    Emit(args->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n                    rhsLocation = args->sxBin.pnode1->location;\n                    Js::RegSlot regVal = rhsLocation;\n                    if (args->sxBin.pnode1->nop == knopEllipsis)\n                    {\n                        AnalysisAssert(spreadIndices);\n                        regVal = funcInfo->AcquireTmpRegister();\n                        byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, rhsLocation);\n                        spreadIndices->elements[spreadIndex++] = i;\n                    }\n\n                    byteCodeGenerator->Writer()->ElementUnsigned1(opcode, regVal, arrLoc, i);\n\n                    if (args->sxBin.pnode1->nop == knopEllipsis)\n                    {\n                        funcInfo->ReleaseTmpRegister(regVal);\n                    }\n\n                    funcInfo->ReleaseLoc(args->sxBin.pnode1);\n                }\n\n                args = args->sxBin.pnode2;\n                i++;\n            }\n\n            if (args->nop != knopEmpty)\n            {\n                Emit(args, byteCodeGenerator, funcInfo, false);\n                rhsLocation = args->location;\n                Js::RegSlot regVal = rhsLocation;\n                if (args->nop == knopEllipsis)\n                {\n                    regVal = funcInfo->AcquireTmpRegister();\n                    byteCodeGenerator->Writer()->Reg2(Js::OpCode::LdCustomSpreadIteratorList, regVal, rhsLocation);\n                    AnalysisAssert(spreadIndices);\n                    spreadIndices->elements[spreadIndex] = i;\n                }\n\n                byteCodeGenerator->Writer()->ElementUnsigned1(opcode, regVal, arrLoc, i);\n\n                if (args->nop == knopEllipsis)\n                {\n                    funcInfo->ReleaseTmpRegister(regVal);\n                }\n\n                funcInfo->ReleaseLoc(args);\n                i++;\n            }\n            Assert(i <= argCount);\n        }\n\n        if (arrLoc != arrayLocation)\n        {\n            funcInfo->ReleaseTmpRegister(arrLoc);\n        }\n    }\n\n    if (pnode->sxArrLit.spreadCount > 0)\n    {\n        byteCodeGenerator->Writer()->Reg2Aux(Js::OpCode::SpreadArrayLiteral, spreadArrLoc, arrayLocation, spreadIndices, sizeof(Js::AuxArray<uint32>) + extraAlloc, extraAlloc);\n        AdeletePlus(byteCodeGenerator->GetAllocator(), extraAlloc, spreadIndices);\n        funcInfo->ReleaseTmpRegister(arrayLocation);\n    }\n}\n\n// FIX: TODO: mixed-mode expressions (arithmetic expressions mixed with boolean expressions); current solution\n// will not short-circuit in some cases and is not complete (for example: var i=(x==y))\n// This uses Aho and Ullman style double-branch generation (p. 494 ASU); we will need to peephole optimize or replace\n// with special case for single-branch style.\nvoid EmitBooleanExpression(ParseNode *expr, Js::ByteCodeLabel trueLabel, Js::ByteCodeLabel falseLabel, ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(expr);\n    switch (expr->nop)\n    {\n\n    case knopLogOr:\n    {\n        Js::ByteCodeLabel leftFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxBin.pnode1, trueLabel, leftFalse, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftFalse);\n        EmitBooleanExpression(expr->sxBin.pnode2, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        break;\n    }\n\n    case knopLogAnd:\n    {\n        Js::ByteCodeLabel leftTrue = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxBin.pnode1, leftTrue, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftTrue);\n        EmitBooleanExpression(expr->sxBin.pnode2, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        break;\n    }\n\n    case knopLogNot:\n        EmitBooleanExpression(expr->sxUni.pnode1, falseLabel, trueLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxUni.pnode1);\n        break;\n\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        EmitBinaryOpnds(expr->sxBin.pnode1, expr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->BrReg2(nopToOp[expr->nop], trueLabel, expr->sxBin.pnode1->location,\n            expr->sxBin.pnode2->location);\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    case knopTrue:\n        byteCodeGenerator->Writer()->Br(trueLabel);\n        break;\n    case knopFalse:\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    default:\n        // Note: we usually release the temp assigned to a node after we Emit it.\n        // But in this case, EmitBooleanExpression is just a wrapper around a normal Emit call,\n        // and the caller of EmitBooleanExpression expects to be able to release this register.\n\n        Emit(expr, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n        byteCodeGenerator->Writer()->Br(falseLabel);\n        break;\n    }\n\n    byteCodeGenerator->EndStatement(expr);\n}\n\nvoid EmitGeneratingBooleanExpression(ParseNode *expr, Js::ByteCodeLabel trueLabel, bool truefallthrough, Js::ByteCodeLabel falseLabel, bool falsefallthrough, Js::RegSlot writeto,\n    ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    switch (expr->nop)\n    {\n\n    case knopLogOr:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        Js::ByteCodeLabel leftFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode1, trueLabel, false, leftFalse, true, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftFalse);\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode2, trueLabel, truefallthrough, falseLabel, falsefallthrough, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n\n    case knopLogAnd:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        Js::ByteCodeLabel leftTrue = byteCodeGenerator->Writer()->DefineLabel();\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode1, leftTrue, true, falseLabel, false, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        byteCodeGenerator->Writer()->MarkLabel(leftTrue);\n        EmitGeneratingBooleanExpression(expr->sxBin.pnode2, trueLabel, truefallthrough, falseLabel, falsefallthrough, writeto, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n\n    case knopLogNot:\n    {\n        byteCodeGenerator->StartStatement(expr);\n        // this time we want a boolean expression, since Logical Not is nice and only returns true or false\n        Js::ByteCodeLabel emitTrue = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel emitFalse = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(expr->sxUni.pnode1, emitFalse, emitTrue, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(emitTrue);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, writeto);\n        byteCodeGenerator->Writer()->Br(trueLabel);\n        byteCodeGenerator->Writer()->MarkLabel(emitFalse);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, writeto);\n        if (!falsefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        funcInfo->ReleaseLoc(expr->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    }\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        byteCodeGenerator->StartStatement(expr);\n        EmitBinaryOpnds(expr->sxBin.pnode1, expr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode2);\n        funcInfo->ReleaseLoc(expr->sxBin.pnode1);\n        funcInfo->AcquireLoc(expr);\n        byteCodeGenerator->Writer()->Reg3(nopToCMOp[expr->nop], expr->location, expr->sxBin.pnode1->location,\n            expr->sxBin.pnode2->location);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n        // The inliner likes small bytecode\n        if (!(truefallthrough || falsefallthrough))\n        {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        else if (truefallthrough && !falsefallthrough) {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n        }\n        else if (falsefallthrough && !truefallthrough) {\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    case knopTrue:\n        byteCodeGenerator->StartStatement(expr);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, writeto);\n        if (!truefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(trueLabel);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    case knopFalse:\n        byteCodeGenerator->StartStatement(expr);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, writeto);\n        if (!falsefallthrough)\n        {\n            byteCodeGenerator->Writer()->Br(falseLabel);\n        }\n        byteCodeGenerator->EndStatement(expr);\n        break;\n    default:\n        // Note: we usually release the temp assigned to a node after we Emit it.\n        // But in this case, EmitBooleanExpression is just a wrapper around a normal Emit call,\n        // and the caller of EmitBooleanExpression expects to be able to release this register.\n\n        // For diagnostics purposes, register the name and dot to the statement list.\n        if (expr->nop == knopName || expr->nop == knopDot)\n        {\n            byteCodeGenerator->StartStatement(expr);\n            Emit(expr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n            // The inliner likes small bytecode\n            if (!(truefallthrough || falsefallthrough))\n            {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n                byteCodeGenerator->Writer()->Br(falseLabel);\n            }\n            else if (truefallthrough && !falsefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n            }\n            else if (falsefallthrough && !truefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            }\n            byteCodeGenerator->EndStatement(expr);\n        }\n        else\n        {\n            Emit(expr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, writeto, expr->location);\n            // The inliner likes small bytecode\n            if (!(truefallthrough || falsefallthrough))\n            {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n                byteCodeGenerator->Writer()->Br(falseLabel);\n            }\n            else if (truefallthrough && !falsefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, falseLabel, expr->location);\n            }\n            else if (falsefallthrough && !truefallthrough) {\n                byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, trueLabel, expr->location);\n            }\n        }\n        break;\n    }\n}\n\n// used by while and for loops\nvoid EmitLoop(\n    ParseNode *loopNode,\n    ParseNode *cond,\n    ParseNode *body,\n    ParseNode *incr,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue,\n    BOOL doWhile = FALSE,\n    ParseNode *forLoopBlock = nullptr)\n{\n    // Need to increment loop count whether we are going to profile or not for HasLoop()\n\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxLoop.loopId = loopId;\n\n    if (doWhile)\n    {\n        Emit(body, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(body);\n        if (loopNode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.continueLabel);\n        }\n        if (!ByteCodeGenerator::IsFalse(cond) ||\n            byteCodeGenerator->IsInDebugMode())\n        {\n            EmitBooleanExpression(cond, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoc(cond);\n    }\n    else\n    {\n        if (cond)\n        {\n            if (!(cond->nop == knopInt &&\n                cond->sxInt.lw != 0))\n            {\n                Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n                EmitBooleanExpression(cond, trueLabel, continuePastLoop, byteCodeGenerator, funcInfo);\n                byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n            }\n            funcInfo->ReleaseLoc(cond);\n        }\n        Emit(body, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(body);\n\n        if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled() &&\n            forLoopBlock != nullptr)\n        {\n            CloneEmitBlock(forLoopBlock, byteCodeGenerator, funcInfo);\n        }\n\n        if (loopNode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.continueLabel);\n        }\n\n        if (incr != nullptr)\n        {\n            Emit(incr, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(incr);\n        }\n\n        byteCodeGenerator->Writer()->Br(loopEntrance);\n    }\n\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxStmt.breakLabel);\n    }\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n}\n\nvoid ByteCodeGenerator::EmitInvertedLoop(ParseNode* outerLoop, ParseNode* invertedLoop, FuncInfo* funcInfo)\n{\n    Js::ByteCodeLabel invertedLoopLabel = this->m_writer.DefineLabel();\n    Js::ByteCodeLabel afterInvertedLoop = this->m_writer.DefineLabel();\n\n    // emit branch around original\n    Emit(outerLoop->sxFor.pnodeInit, this, funcInfo, false);\n    funcInfo->ReleaseLoc(outerLoop->sxFor.pnodeInit);\n    this->m_writer.BrS(Js::OpCode::BrNotHasSideEffects, invertedLoopLabel, Js::SideEffects_Any);\n\n    // emit original\n    EmitLoop(outerLoop, outerLoop->sxFor.pnodeCond, outerLoop->sxFor.pnodeBody,\n        outerLoop->sxFor.pnodeIncr, this, funcInfo, false);\n\n    // clear temporary registers since inverted loop may share nodes with\n    // emitted original loop\n    VisitClearTmpRegs(outerLoop, this, funcInfo);\n\n    // emit branch around inverted\n    this->m_writer.Br(afterInvertedLoop);\n    this->m_writer.MarkLabel(invertedLoopLabel);\n\n    // Emit a zero trip test for the original outer-loop\n    Js::ByteCodeLabel zeroTrip = this->m_writer.DefineLabel();\n    ParseNode* testNode = this->GetParser()->CopyPnode(outerLoop->sxFor.pnodeCond);\n    EmitBooleanExpression(testNode, zeroTrip, afterInvertedLoop, this, funcInfo);\n    this->m_writer.MarkLabel(zeroTrip);\n    funcInfo->ReleaseLoc(testNode);\n\n    // emit inverted\n    Emit(invertedLoop->sxFor.pnodeInit, this, funcInfo, false);\n    funcInfo->ReleaseLoc(invertedLoop->sxFor.pnodeInit);\n    EmitLoop(invertedLoop, invertedLoop->sxFor.pnodeCond, invertedLoop->sxFor.pnodeBody,\n        invertedLoop->sxFor.pnodeIncr, this, funcInfo, false);\n    this->m_writer.MarkLabel(afterInvertedLoop);\n}\n\nvoid EmitGetIterator(Js::RegSlot iteratorLocation, Js::RegSlot iterableLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get iterator object from the iterable\n    EmitInvoke(iteratorLocation, iterableLocation, Js::PropertyIds::_symbolIterator, byteCodeGenerator, funcInfo);\n\n    // throw TypeError if the result is not an object\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, iteratorLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n}\n\nvoid EmitIteratorNext(Js::RegSlot itemLocation, Js::RegSlot iteratorLocation, Js::RegSlot nextInputLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // invoke next() on the iterator\n    if (nextInputLocation == Js::Constants::NoRegister)\n    {\n        EmitInvoke(itemLocation, iteratorLocation, Js::PropertyIds::next, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        EmitInvoke(itemLocation, iteratorLocation, Js::PropertyIds::next, byteCodeGenerator, funcInfo, nextInputLocation);\n    }\n\n    // throw TypeError if the result is not an object\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, itemLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n}\n\n// Generating\n// if (hasReturnFunction) {\n//     value = Call Retrun;\n//     if (value != Object) \n//        throw TypeError;\n// }\n\nvoid EmitIteratorClose(Js::RegSlot iteratorLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    Js::RegSlot returnLocation = funcInfo->AcquireTmpRegister();\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel noReturn = byteCodeGenerator->Writer()->DefineLabel();\n\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorLocation, Js::PropertyIds::return_, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, returnLocation, iteratorLocation, cacheId);\n\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrEq_A, noReturn, returnLocation, funcInfo->undefinedConstantRegister);\n\n    EmitInvoke(returnLocation, iteratorLocation, Js::PropertyIds::return_, byteCodeGenerator, funcInfo);\n\n    // throw TypeError if the result is not an Object\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, returnLocation);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n    byteCodeGenerator->Writer()->MarkLabel(noReturn);\n\n    funcInfo->ReleaseTmpRegister(returnLocation);\n}\n\nvoid EmitIteratorComplete(Js::RegSlot doneLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get the iterator result's \"done\" property\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorResultLocation, Js::PropertyIds::done, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, doneLocation, iteratorResultLocation, cacheId);\n\n    // Do not need to do ToBoolean explicitly with current uses of EmitIteratorComplete since BrTrue_A does this.\n    // Add a ToBoolean controlled by template flag if needed for new uses later on.\n}\n\nvoid EmitIteratorValue(Js::RegSlot valueLocation, Js::RegSlot iteratorResultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    // get the iterator result's \"value\" property\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorResultLocation, Js::PropertyIds::value, false, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, valueLocation, iteratorResultLocation, cacheId);\n}\n\nvoid EmitForInOfLoopBody(ParseNode *loopNode,\n    Js::ByteCodeLabel loopEntrance,\n    Js::ByteCodeLabel continuePastLoop,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue)\n{\n    if (loopNode->sxForInOrForOf.pnodeLval->nop != knopVarDecl &&\n        loopNode->sxForInOrForOf.pnodeLval->nop != knopLetDecl &&\n        loopNode->sxForInOrForOf.pnodeLval->nop != knopConstDecl)\n    {\n        EmitReference(loopNode->sxForInOrForOf.pnodeLval, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        Symbol * sym = loopNode->sxForInOrForOf.pnodeLval->sxVar.sym;\n        sym->SetNeedDeclaration(false);\n    }\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        BeginEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n\n    EmitAssignment(nullptr, loopNode->sxForInOrForOf.pnodeLval, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    // The StartStatement is already done in the caller of this function.\n    byteCodeGenerator->EndStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    funcInfo->ReleaseReference(loopNode->sxForInOrForOf.pnodeLval);\n\n    Emit(loopNode->sxForInOrForOf.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n    funcInfo->ReleaseLoc(loopNode->sxForInOrForOf.pnodeBody);\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n\n    funcInfo->ReleaseTmpRegister(loopNode->sxForInOrForOf.itemLocation);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxForInOrForOf.continueLabel);\n    }\n    byteCodeGenerator->Writer()->Br(loopEntrance);\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    if (loopNode->emitLabels)\n    {\n        byteCodeGenerator->Writer()->MarkLabel(loopNode->sxForInOrForOf.breakLabel);\n    }\n}\n\nvoid EmitForIn(ParseNode *loopNode,\n    Js::ByteCodeLabel loopEntrance,\n    Js::ByteCodeLabel continuePastLoop,\n    ByteCodeGenerator *byteCodeGenerator,\n    FuncInfo *funcInfo,\n    BOOL fReturnValue)\n{\n    Assert(loopNode->nop == knopForIn);\n    Assert(loopNode->location == Js::Constants::NoRegister);\n\n    // Grab registers for the enumerator and for the current enumerated item.\n    // The enumerator register will be released after this call returns.\n    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();\n\n    uint forInLoopLevel = funcInfo->AcquireForInLoopLevel();\n\n    // get enumerator from the collection\n    byteCodeGenerator->Writer()->Reg1Unsigned1(Js::OpCode::InitForInEnumerator, loopNode->sxForInOrForOf.pnodeObj->location, forInLoopLevel);\n\n    // The StartStatement is already done in the caller of the current function, which is EmitForInOrForOf\n    byteCodeGenerator->EndStatement(loopNode);\n\n    // Need to increment loop count whether we are going into profile or not for HasLoop()\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxForInOrForOf.loopId = loopId;\n\n    // The EndStatement will happen in the EmitForInOfLoopBody function\n    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    // branch past loop when MoveAndGetNext returns nullptr\n    byteCodeGenerator->Writer()->BrReg1Unsigned1(Js::OpCode::BrOnEmpty, continuePastLoop, loopNode->sxForInOrForOf.itemLocation, forInLoopLevel);\n    \n    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    funcInfo->ReleaseForInLoopLevel(forInLoopLevel);\n\n    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitForInOrForOf(ParseNode *loopNode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue)\n{\n    bool isForIn = (loopNode->nop == knopForIn);\n    Assert(isForIn || loopNode->nop == knopForOf);\n\n    BeginEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->StartStatement(loopNode);\n    if (!isForIn)\n    {\n        funcInfo->AcquireLoc(loopNode);\n    }\n\n    // Record the branch bytecode offset.\n    // This is used for \"ignore exception\" and \"set next stmt\" scenarios. See ProbeContainer::GetNextUserStatementOffsetForAdvance:\n    // If there is a branch recorded between current offset and next stmt offset, we'll use offset of the branch recorded,\n    // otherwise use offset of next stmt.\n    // The idea here is that when we bail out after ignore exception, we need to bail out to the beginning of the ForIn,\n    // but currently ForIn stmt starts at the condition part, which is needed for correct handling of break point on ForIn\n    // (break every time on the loop back edge) and correct display of current statement under debugger.\n    // See WinBlue 231880 for details.\n    byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_All);\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled() &&\n        loopNode->sxForInOrForOf.pnodeBlock->sxBlock.HasBlockScopedContent())\n    {\n        byteCodeGenerator->Writer()->RecordForInOrOfCollectionScope();\n    }\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    if (loopNode->sxForInOrForOf.pnodeLval->nop == knopVarDecl)\n    {\n        EmitReference(loopNode->sxForInOrForOf.pnodeLval, byteCodeGenerator, funcInfo);\n    }\n\n    Emit(loopNode->sxForInOrForOf.pnodeObj, byteCodeGenerator, funcInfo, false); // evaluate collection expression\n    funcInfo->ReleaseLoc(loopNode->sxForInOrForOf.pnodeObj);\n\n    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n        if (loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope != nullptr)\n        {\n            loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope->ForEachSymbol([](Symbol *sym) {\n                sym->SetIsTrackedForDebugger(false);\n            });\n        }\n    }\n\n    if (isForIn)\n    {\n        EmitForIn(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n        if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n        {\n            EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n        }\n\n        return;\n    }\n\n    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrNeq_A, skipThrow, loopNode->sxForInOrForOf.pnodeObj->location, funcInfo->undefinedConstantRegister);\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ObjectCoercible));\n    byteCodeGenerator->Writer()->MarkLabel(skipThrow);\n\n    Js::RegSlot regException = Js::Constants::NoRegister;\n    Js::RegSlot regOffset = Js::Constants::NoRegister;\n\n    // These two temp variables store the information of return function to be called or not.\n    // one variable is used for catch block and one is used for finally block. These variable will be set to true when we think that return function\n    // to be called on abrupt loop break. \n    // Why two variables? since these are temps and JIT does like not flow if single variable is used in multiple blocks.\n    Js::RegSlot shouldCallReturnFunctionLocation = funcInfo->AcquireTmpRegister();\n    Js::RegSlot shouldCallReturnFunctionLocationFinally = funcInfo->AcquireTmpRegister();\n\n    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();\n\n    if (isCoroutine)\n    {\n        regException = funcInfo->AcquireTmpRegister();\n        regOffset = funcInfo->AcquireTmpRegister();\n    }\n\n    // Grab registers for the enumerator and for the current enumerated item.\n    // The enumerator register will be released after this call returns.\n    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();\n\n    // We want call profile information on the @@iterator call, so instead of adding a GetForOfIterator bytecode op\n    // to do all the following work in a helper do it explicitly in bytecode so that the @@iterator call is exposed\n    // to the profiler and JIT.\n\n    byteCodeGenerator->SetHasFinally(true);\n    byteCodeGenerator->SetHasTry(true);\n    byteCodeGenerator->TopFuncInfo()->byteCodeFunction->SetDontInline(true);\n\n    // do a ToObject on the collection\n    Js::RegSlot tmpObj = funcInfo->AcquireTmpRegister();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Obj, tmpObj, loopNode->sxForInOrForOf.pnodeObj->location);\n\n    EmitGetIterator(loopNode->location, tmpObj, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseTmpRegister(tmpObj);\n\n    // The whole loop is surrounded with try..catch..finally - in order to capture the abrupt completion.\n    Js::ByteCodeLabel finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTryFinally(Js::OpCode::TryFinallyWithYield, finallyLabel);\n\n    if (isCoroutine)\n    {\n        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n        tryRecForTryFinally.reg1 = regException;\n        tryRecForTryFinally.reg2 = regOffset;\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTryFinally);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n    }\n\n    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n    ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n    if (isCoroutine)\n    {\n        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n    }\n\n    byteCodeGenerator->EndStatement(loopNode);\n\n    // Need to increment loop count whether we are going into profile or not for HasLoop()\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    loopNode->sxForInOrForOf.loopId = loopId;\n\n    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);\n\n    EmitIteratorNext(loopNode->sxForInOrForOf.itemLocation, loopNode->location, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    // branch past loop if the result's done property is truthy\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, continuePastLoop, doneLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n\n    // otherwise put result's value property in itemLocation\n    EmitIteratorValue(loopNode->sxForInOrForOf.itemLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);\n\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);\n    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);\n\n    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);\n\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    EmitCatchAndFinallyBlocks(catchLabel,\n        finallyLabel,\n        loopNode->location,\n        shouldCallReturnFunctionLocation,\n        shouldCallReturnFunctionLocationFinally,\n        regException,\n        regOffset,\n        byteCodeGenerator,\n        funcInfo);\n\n    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n    {\n        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitArrayLiteral(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    funcInfo->AcquireLoc(pnode);\n    ParseNode *args = pnode->sxUni.pnode1;\n    if (args == nullptr)\n    {\n        byteCodeGenerator->Writer()->Reg1Unsigned1(\n            pnode->sxArrLit.hasMissingValues ? Js::OpCode::NewScArrayWithMissingValues : Js::OpCode::NewScArray,\n            pnode->location,\n            ByteCodeGenerator::DefaultArraySize);\n    }\n    else\n    {\n        SetNewArrayElements(pnode, pnode->location, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitJumpCleanup(ParseNode *pnode, ParseNode *pnodeTarget, ByteCodeGenerator *byteCodeGenerator, FuncInfo * funcInfo)\n{\n    for (; pnode != pnodeTarget; pnode = pnode->sxStmt.pnodeOuter)\n    {\n        switch (pnode->nop)\n        {\n        case knopTry:\n        case knopCatch:\n        case knopFinally:\n            // We insert OpCode::Leave when there is a 'return' inside try/catch/finally.\n            // This is for flow control and does not participate in identifying boundaries of try/catch blocks,\n            // thus we shouldn't call RecordCrossFrameEntryExitRecord() here.\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            break;\n\n        case knopForOf:\n#if ENABLE_PROFILE_INFO\n            if (Js::DynamicProfileInfo::EnableImplicitCallFlags(funcInfo->GetParsedFunctionBody()))\n            {\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::ProfiledLoopEnd, pnode->sxLoop.loopId);\n            }\n#endif\n            // The ForOf loop code is wrapped around try..catch..finally - Forcing couple Leave bytecode over here\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n            break;\n\n#if ENABLE_PROFILE_INFO\n        case knopWhile:\n        case knopDoWhile:\n        case knopFor:\n        case knopForIn:\n            if (Js::DynamicProfileInfo::EnableImplicitCallFlags(funcInfo->GetParsedFunctionBody()))\n            {\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::ProfiledLoopEnd, pnode->sxLoop.loopId);\n            }\n            break;\n#endif\n\n        }\n    }\n}\n\nvoid EmitBinaryOpnds(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // If opnd2 can overwrite opnd1, make sure the value of opnd1 is stashed away.\n    if (MayHaveSideEffectOnNode(pnode1, pnode2))\n    {\n        SaveOpndValue(pnode1, funcInfo);\n    }\n\n    Emit(pnode1, byteCodeGenerator, funcInfo, false);\n\n    if (pnode1->nop == knopComputedName && pnode2->nop == knopClassDecl &&\n        (pnode2->sxClass.pnodeConstructor == nullptr || pnode2->sxClass.pnodeConstructor->nop != knopVarDecl))\n    {\n        Emit(pnode2, byteCodeGenerator, funcInfo, false, false, pnode1);\n    }\n    else\n    {\n        Emit(pnode2, byteCodeGenerator, funcInfo, false);\n    }\n}\n\nvoid EmitBinaryReference(ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fLoadLhs)\n{\n    // Make sure that the RHS of an assignment doesn't kill the opnd's of the expression on the LHS.\n    switch (pnode1->nop)\n    {\n    case knopName:\n        if (fLoadLhs && MayHaveSideEffectOnNode(pnode1, pnode2))\n        {\n            // Given x op y, y may kill x, so stash x.\n            // Note that this only matters if we're loading x prior to the op.\n            SaveOpndValue(pnode1, funcInfo);\n        }\n        break;\n    case knopDot:\n        if (fLoadLhs)\n        {\n            // We're loading the value of the LHS before the RHS, so make sure the LHS gets a register first.\n            funcInfo->AcquireLoc(pnode1);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode2))\n        {\n            // Given x.y op z, z may kill x, so stash x away.\n            SaveOpndValue(pnode1->sxBin.pnode1, funcInfo);\n        }\n        break;\n    case knopIndex:\n        if (fLoadLhs)\n        {\n            // We're loading the value of the LHS before the RHS, so make sure the LHS gets a register first.\n            funcInfo->AcquireLoc(pnode1);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode2) ||\n            MayHaveSideEffectOnNode(pnode1->sxBin.pnode1, pnode1->sxBin.pnode2))\n        {\n            // Given x[y] op z, y or z may kill x, so stash x away.\n            SaveOpndValue(pnode1->sxBin.pnode1, funcInfo);\n        }\n        if (MayHaveSideEffectOnNode(pnode1->sxBin.pnode2, pnode2))\n        {\n            // Given x[y] op z, z may kill y, so stash y away.\n            // But make sure that x gets a register before y.\n            funcInfo->AcquireLoc(pnode1->sxBin.pnode1);\n            SaveOpndValue(pnode1->sxBin.pnode2, funcInfo);\n        }\n        break;\n    }\n\n    if (fLoadLhs)\n    {\n        // Emit code to load the value of the LHS.\n        EmitLoad(pnode1, byteCodeGenerator, funcInfo);\n    }\n    else\n    {\n        // Emit code to evaluate the LHS opnds, but don't load the LHS's value.\n        EmitReference(pnode1, byteCodeGenerator, funcInfo);\n    }\n\n    // Evaluate the RHS.\n    Emit(pnode2, byteCodeGenerator, funcInfo, false);\n}\n\nvoid EmitUseBeforeDeclarationRuntimeError(ByteCodeGenerator * byteCodeGenerator, Js::RegSlot location)\n{\n    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_UseBeforeDeclaration));\n\n    if (location != Js::Constants::NoRegister)\n    {\n        // Optionally load something into register in order to do not confuse IRBuilder. This value will never be used.\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, location);\n    }\n}\n\nvoid EmitUseBeforeDeclaration(Symbol *sym, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    // Don't emit static use-before-declaration error in a closure or dynamic scope case. We detect such cases with dynamic checks,\n    // if necessary.\n    if (sym != nullptr &&\n        !sym->GetIsModuleExportStorage() &&\n        sym->GetNeedDeclaration() &&\n        byteCodeGenerator->GetCurrentScope()->HasStaticPathToAncestor(sym->GetScope()) &&\n        sym->GetScope()->GetFunc() == funcInfo)\n    {\n        EmitUseBeforeDeclarationRuntimeError(byteCodeGenerator, Js::Constants::NoRegister);\n    }\n}\n\nvoid EmitBinary(Js::OpCode opcode, ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(pnode);\n    EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n    funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg3(opcode,\n        pnode->location,\n        pnode->sxBin.pnode1->location,\n        pnode->sxBin.pnode2->location);\n    byteCodeGenerator->EndStatement(pnode);\n}\n\nbool CollectConcat(ParseNode *pnodeAdd, DListCounted<ParseNode *, ArenaAllocator>& concatOpnds, ArenaAllocator *arenaAllocator)\n{\n    Assert(pnodeAdd->nop == knopAdd);\n    Assert(pnodeAdd->CanFlattenConcatExpr());\n\n    bool doConcatString = false;\n    DList<ParseNode*, ArenaAllocator> pnodeStack(arenaAllocator);\n    pnodeStack.Prepend(pnodeAdd->sxBin.pnode2);\n    ParseNode * pnode = pnodeAdd->sxBin.pnode1;\n    while (true)\n    {\n        if (!pnode->CanFlattenConcatExpr())\n        {\n            concatOpnds.Append(pnode);\n        }\n        else if (pnode->nop == knopStr)\n        {\n            concatOpnds.Append(pnode);\n\n            // Detect if there are any string larger then the append size limit.\n            // If there are, we can do concat; otherwise, still use add so we will not lose the AddLeftDead opportunities.\n            doConcatString = doConcatString || !Js::CompoundString::ShouldAppendChars(pnode->sxPid.pid->Cch());\n        }\n        else\n        {\n            Assert(pnode->nop == knopAdd);\n            pnodeStack.Prepend(pnode->sxBin.pnode2);\n            pnode = pnode->sxBin.pnode1;\n            continue;\n        }\n\n        if (pnodeStack.Empty())\n        {\n            break;\n        }\n\n        pnode = pnodeStack.Head();\n        pnodeStack.RemoveHead();\n    }\n\n    return doConcatString;\n}\n\nvoid EmitConcat3(ParseNode *pnode, ParseNode *pnode1, ParseNode *pnode2, ParseNode *pnode3, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    byteCodeGenerator->StartStatement(pnode);\n    if (MayHaveSideEffectOnNode(pnode1, pnode2) || MayHaveSideEffectOnNode(pnode1, pnode3))\n    {\n        SaveOpndValue(pnode1, funcInfo);\n    }\n\n    if (MayHaveSideEffectOnNode(pnode2, pnode3))\n    {\n        SaveOpndValue(pnode2, funcInfo);\n    }\n\n    Emit(pnode1, byteCodeGenerator, funcInfo, false);\n    Emit(pnode2, byteCodeGenerator, funcInfo, false);\n    Emit(pnode3, byteCodeGenerator, funcInfo, false);\n    funcInfo->ReleaseLoc(pnode3);\n    funcInfo->ReleaseLoc(pnode2);\n    funcInfo->ReleaseLoc(pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg4(Js::OpCode::Concat3,\n        pnode->location,\n        pnode1->location,\n        pnode2->location,\n        pnode3->location);\n    byteCodeGenerator->EndStatement(pnode);\n}\n\nvoid EmitNewConcatStrMulti(ParseNode *pnode, uint8 count, ParseNode *pnode1, ParseNode *pnode2, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    EmitBinaryOpnds(pnode1, pnode2, byteCodeGenerator, funcInfo);\n    funcInfo->ReleaseLoc(pnode2);\n    funcInfo->ReleaseLoc(pnode1);\n    funcInfo->AcquireLoc(pnode);\n    byteCodeGenerator->Writer()->Reg3B1(Js::OpCode::NewConcatStrMulti,\n        pnode->location,\n        pnode1->location,\n        pnode2->location,\n        count);\n}\n\nvoid EmitAdd(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo)\n{\n    Assert(pnode->nop == knopAdd);\n\n    if (pnode->CanFlattenConcatExpr())\n    {\n        // We should only have a string concat if the feature is on.\n        Assert(!PHASE_OFF1(Js::ByteCodeConcatExprOptPhase));\n        DListCounted<ParseNode*, ArenaAllocator> concatOpnds(byteCodeGenerator->GetAllocator());\n        bool doConcatString = CollectConcat(pnode, concatOpnds, byteCodeGenerator->GetAllocator());\n        if (doConcatString)\n        {\n            uint concatCount = concatOpnds.Count();\n            Assert(concatCount >= 2);\n\n            // Don't do concatN if the number is too high\n            // CONSIDER: although we could have done multiple ConcatNs\n            if (concatCount > 2 && concatCount <= UINT8_MAX)\n            {\n#if DBG\n                char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];\n#endif\n                ParseNode * pnode1 = concatOpnds.Head();\n                concatOpnds.RemoveHead();\n                ParseNode * pnode2 = concatOpnds.Head();\n                concatOpnds.RemoveHead();\n                if (concatCount == 3)\n                {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ByteCodeConcatExprOptPhase, _u(\"%s(%s) offset:#%d : Concat3\\n\"),\n                        funcInfo->GetParsedFunctionBody()->GetDisplayName(),\n                        funcInfo->GetParsedFunctionBody()->GetDebugNumberSet(debugStringBuffer),\n                        byteCodeGenerator->Writer()->ByteCodeDataSize());\n                    EmitConcat3(pnode, pnode1, pnode2, concatOpnds.Head(), byteCodeGenerator, funcInfo);\n                    return;\n                }\n\n                OUTPUT_TRACE_DEBUGONLY(Js::ByteCodeConcatExprOptPhase, _u(\"%s(%s) offset:#%d: ConcatMulti %d\\n\"),\n                    funcInfo->GetParsedFunctionBody()->GetDisplayName(),\n                    funcInfo->GetParsedFunctionBody()->GetDebugNumberSet(debugStringBuffer),\n                    byteCodeGenerator->Writer()->ByteCodeDataSize(), concatCount);\n                byteCodeGenerator->StartStatement(pnode);\n                funcInfo->AcquireLoc(pnode);\n\n                // CONSIDER: this may cause the backend not able CSE repeating pattern within the concat.\n                EmitNewConcatStrMulti(pnode, (uint8)concatCount, pnode1, pnode2, byteCodeGenerator, funcInfo);\n\n                uint i = 2;\n                do\n                {\n                    ParseNode * currNode = concatOpnds.Head();\n                    concatOpnds.RemoveHead();\n                    ParseNode * currNode2 = concatOpnds.Head();\n                    concatOpnds.RemoveHead();\n\n                    EmitBinaryOpnds(currNode, currNode2, byteCodeGenerator, funcInfo);\n                    funcInfo->ReleaseLoc(currNode2);\n                    funcInfo->ReleaseLoc(currNode);\n                    byteCodeGenerator->Writer()->Reg3B1(\n                        Js::OpCode::SetConcatStrMultiItem2, pnode->location, currNode->location, currNode2->location, (uint8)i);\n                    i += 2;\n                } while (concatOpnds.Count() > 1);\n\n                if (!concatOpnds.Empty())\n                {\n                    ParseNode * currNode = concatOpnds.Head();\n                    Emit(currNode, byteCodeGenerator, funcInfo, false);\n                    funcInfo->ReleaseLoc(currNode);\n                    byteCodeGenerator->Writer()->Reg2B1(\n                        Js::OpCode::SetConcatStrMultiItem, pnode->location, currNode->location, (uint8)i);\n                    i++;\n                }\n\n                Assert(concatCount == i);\n                byteCodeGenerator->EndStatement(pnode);\n                return;\n            }\n        }\n\n        // Since we collected all the node already, let's just emit them instead of doing it recursively.\n        byteCodeGenerator->StartStatement(pnode);\n        ParseNode * currNode = concatOpnds.Head();\n        concatOpnds.RemoveHead();\n        ParseNode * currNode2 = concatOpnds.Head();\n        concatOpnds.RemoveHead();\n\n        EmitBinaryOpnds(currNode, currNode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(currNode2);\n        funcInfo->ReleaseLoc(currNode);\n        Js::RegSlot dstReg = funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg3(\n            Js::OpCode::Add_A, dstReg, currNode->location, currNode2->location);\n        while (!concatOpnds.Empty())\n        {\n            currNode = concatOpnds.Head();\n            concatOpnds.RemoveHead();\n            Emit(currNode, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(currNode);\n            byteCodeGenerator->Writer()->Reg3(\n                Js::OpCode::Add_A, dstReg, dstReg, currNode->location);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n    }\n    else\n    {\n        EmitBinary(Js::OpCode::Add_A, pnode, byteCodeGenerator, funcInfo);\n    }\n}\n\nvoid EmitSuperFieldPatch(FuncInfo* funcInfo, ParseNode* pnode, ByteCodeGenerator* byteCodeGenerator)\n{\n    ParseNodePtr propFuncNode = funcInfo->root;\n\n    if (byteCodeGenerator->GetFlags() & fscrEval)\n    {\n        // If we are inside an eval, ScopedLdHomeObj will take care of the patch.\n        return;\n    }\n\n    if (funcInfo->IsLambda())\n    {\n        FuncInfo *parent = byteCodeGenerator->FindEnclosingNonLambda();\n        propFuncNode = parent->root;\n    }\n\n    // No need to emit a LdFld for the constructor.\n    if (propFuncNode->sxFnc.IsClassConstructor())\n    {\n        return;\n    }\n\n    if (!propFuncNode->sxFnc.IsClassMember() || propFuncNode->sxFnc.pid == nullptr)\n    {\n        // Non-methods will fail lookup.\n        return;\n    }\n    if (propFuncNode->sxFnc.pid->GetPropertyId() == Js::Constants::NoProperty)\n    {\n        byteCodeGenerator->AssignPropertyId(propFuncNode->sxFnc.pid);\n    }\n\n    // Load the current method's property ID from super instead of using super directly.\n    Js::RegSlot superLoc = funcInfo->superRegister;\n    pnode->sxCall.pnodeTarget->location = Js::Constants::NoRegister;\n    Js::RegSlot superPropLoc = funcInfo->AcquireLoc(pnode->sxCall.pnodeTarget);\n    Js::PropertyId propertyId = propFuncNode->sxFnc.pid->GetPropertyId();\n    uint cacheId = funcInfo->FindOrAddInlineCacheId(superLoc, propertyId, true, false);\n    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdMethodFld, superPropLoc, superLoc, cacheId);\n\n    propFuncNode->sxFnc.pnodeName = nullptr;\n}\n\n\n\nvoid ByteCodeGenerator::EmitLeaveOpCodesBeforeYield()\n{\n    for (TryScopeRecord* node = this->tryScopeRecordsList.Tail(); node != nullptr; node = node->Previous())\n    {\n        switch (node->op)\n        {\n        case Js::OpCode::TryFinallyWithYield:\n            this->Writer()->Empty(Js::OpCode::LeaveNull);\n            break;\n        case Js::OpCode::TryCatch:\n        case Js::OpCode::ResumeFinally:\n        case Js::OpCode::ResumeCatch:\n            this->Writer()->Empty(Js::OpCode::Leave);\n            break;\n        default:\n            AssertMsg(false, \"Unexpected OpCode before Yield in the Try-Catch-Finally cache for generator!\");\n            break;\n        }\n    }\n}\n\nvoid ByteCodeGenerator::EmitTryBlockHeadersAfterYield()\n{\n    for (TryScopeRecord* node = this->tryScopeRecordsList.Head(); node != nullptr; node = node->Next())\n    {\n        switch (node->op)\n        {\n        case Js::OpCode::TryCatch:\n            this->Writer()->Br(node->op, node->label);\n            break;\n        case Js::OpCode::TryFinallyWithYield:\n        case Js::OpCode::ResumeFinally:\n            this->Writer()->BrReg2(node->op, node->label, node->reg1, node->reg2);\n            break;\n        case Js::OpCode::ResumeCatch:\n            this->Writer()->Empty(node->op);\n            break;\n        default:\n            AssertMsg(false, \"Unexpected OpCode after yield in the Try-Catch-Finally cache for generator!\");\n            break;\n        }\n    }\n}\n\nvoid EmitYield(Js::RegSlot inputLocation, Js::RegSlot resultLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo,\n    Js::RegSlot yieldStarIterator = Js::Constants::NoRegister)\n{\n    // If the bytecode emitted by this function is part of 'yield*', inputLocation is the object\n    // returned by the iterable's next/return/throw method. Otherwise, it is the yielded value.\n    if (yieldStarIterator == Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::NewScObjectSimple, funcInfo->yieldRegister);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->yieldRegister, Js::PropertyIds::value, false, true);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::StFld, inputLocation, funcInfo->yieldRegister, cacheId);\n\n        cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->yieldRegister, Js::PropertyIds::done, false, true);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::StFld, funcInfo->falseConstantRegister, funcInfo->yieldRegister, cacheId);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, funcInfo->yieldRegister, inputLocation);\n    }\n\n    byteCodeGenerator->EmitLeaveOpCodesBeforeYield();\n    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Yield, funcInfo->yieldRegister, funcInfo->yieldRegister);\n    byteCodeGenerator->EmitTryBlockHeadersAfterYield();\n\n    if (yieldStarIterator == Js::Constants::NoRegister)\n    {\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::ResumeYield, resultLocation, funcInfo->yieldRegister);\n    }\n    else\n    {\n        byteCodeGenerator->Writer()->Reg3(Js::OpCode::ResumeYieldStar, resultLocation, funcInfo->yieldRegister, yieldStarIterator);\n    }\n}\n\nvoid EmitYieldStar(ParseNode* yieldStarNode, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)\n{\n    funcInfo->AcquireLoc(yieldStarNode);\n\n    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();\n    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();\n\n    Js::RegSlot iteratorLocation = funcInfo->AcquireTmpRegister();\n\n    // Evaluate operand\n    Emit(yieldStarNode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n    funcInfo->ReleaseLoc(yieldStarNode->sxUni.pnode1);\n\n    EmitGetIterator(iteratorLocation, yieldStarNode->sxUni.pnode1->location, byteCodeGenerator, funcInfo);\n\n    // Call the iterator's next()\n    EmitIteratorNext(yieldStarNode->location, iteratorLocation, funcInfo->undefinedConstantRegister, byteCodeGenerator, funcInfo);\n\n    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);\n    // since a yield* doesn't have a user defined body, we cannot return from this loop\n    // which means we don't need to support EmitJumpCleanup() and there do not need to\n    // remember the loopId like the loop statements do.\n\n    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();\n    EmitIteratorComplete(doneLocation, yieldStarNode->location, byteCodeGenerator, funcInfo);\n\n    // branch past the loop if the done property is truthy\n    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, continuePastLoop, doneLocation);\n    funcInfo->ReleaseTmpRegister(doneLocation);\n\n    EmitYield(yieldStarNode->location, yieldStarNode->location, byteCodeGenerator, funcInfo, iteratorLocation);\n\n    funcInfo->ReleaseTmpRegister(iteratorLocation);\n\n    byteCodeGenerator->Writer()->Br(loopEntrance);\n    byteCodeGenerator->Writer()->MarkLabel(continuePastLoop);\n    byteCodeGenerator->Writer()->ExitLoop(loopId);\n\n    // Put the iterator result's value in yieldStarNode->location.\n    // It will be used as the result value of the yield* operator expression.\n    EmitIteratorValue(yieldStarNode->location, yieldStarNode->location, byteCodeGenerator, funcInfo);\n}\n\nvoid TrackIntConstantsOnGlobalUserObject(ByteCodeGenerator *byteCodeGenerator, bool isSymGlobalAndSingleAssignment, Js::PropertyId propertyId)\n{\n    if (isSymGlobalAndSingleAssignment)\n    {\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalUserObject(propertyId);\n    }\n}\n\nvoid TrackIntConstantsOnGlobalObject(ByteCodeGenerator *byteCodeGenerator, bool isSymGlobalAndSingleAssignment, Js::PropertyId propertyId)\n{\n    if (isSymGlobalAndSingleAssignment)\n    {\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalObject(propertyId);\n    }\n}\n\nvoid TrackIntConstantsOnGlobalObject(ByteCodeGenerator *byteCodeGenerator, Symbol *sym)\n{\n    if (sym && sym->GetIsGlobal() && sym->IsAssignedOnce())\n    {\n        Js::PropertyId propertyId = sym->EnsurePosition(byteCodeGenerator);\n        byteCodeGenerator->GetScriptContext()->TrackIntConstPropertyOnGlobalObject(propertyId);\n    }\n}\n\nvoid TrackMemberNodesInObjectForIntConstants(ByteCodeGenerator *byteCodeGenerator, ParseNodePtr objNode)\n{\n    Assert(objNode->nop == knopObject);\n    Assert(ParseNode::Grfnop(objNode->nop) & fnopUni);\n\n    ParseNodePtr memberList = objNode->sxUni.pnode1;\n\n    while (memberList != nullptr)\n    {\n        ParseNodePtr memberNode = memberList->nop == knopList ? memberList->sxBin.pnode1 : memberList;\n        ParseNodePtr memberNameNode = memberNode->sxBin.pnode1;\n        ParseNodePtr memberValNode = memberNode->sxBin.pnode2;\n\n        if (memberNameNode->nop != knopComputedName && memberValNode->nop == knopInt)\n        {\n            Js::PropertyId propertyId = memberNameNode->sxPid.PropertyIdFromNameNode();\n            TrackIntConstantsOnGlobalUserObject(byteCodeGenerator, true, propertyId);\n        }\n\n        memberList = memberList->nop == knopList ? memberList->sxBin.pnode2 : nullptr;\n    }\n}\n\nvoid TrackGlobalIntAssignmentsForknopDotProps(ParseNodePtr knopDotNode, ByteCodeGenerator * byteCodeGenerator)\n{\n    Assert(knopDotNode->nop == knopDot);\n\n    ParseNodePtr objectNode = knopDotNode->sxBin.pnode1;\n    ParseNodePtr propertyNode = knopDotNode->sxBin.pnode2;\n    bool isSymGlobalAndSingleAssignment = false;\n\n    if (objectNode->nop == knopName)\n    {\n        Symbol * sym = objectNode->sxVar.sym;\n        isSymGlobalAndSingleAssignment = sym && sym->GetIsGlobal() && sym->IsAssignedOnce() && propertyNode->sxPid.pid->IsSingleAssignment();\n        Js::PropertyId propertyId = propertyNode->sxPid.PropertyIdFromNameNode();\n        TrackIntConstantsOnGlobalUserObject(byteCodeGenerator, isSymGlobalAndSingleAssignment, propertyId);\n    }\n    else if (objectNode->nop == knopThis)\n    {\n        // Assume knopThis always refer to GlobalObject\n        // Cases like \"this.a = \"\n        isSymGlobalAndSingleAssignment = propertyNode->sxPid.pid->IsSingleAssignment();\n        Js::PropertyId propertyId = propertyNode->sxPid.PropertyIdFromNameNode();\n        TrackIntConstantsOnGlobalObject(byteCodeGenerator, isSymGlobalAndSingleAssignment, propertyId);\n    }\n}\n\nvoid TrackGlobalIntAssignments(ParseNodePtr pnode, ByteCodeGenerator * byteCodeGenerator)\n{\n    // Track the Global Int Constant properties' assignments here.\n    uint nodeType = ParseNode::Grfnop(pnode->nop);\n    if (nodeType & fnopAsg)\n    {\n        if (nodeType & fnopBin)\n        {\n            ParseNodePtr lhs = pnode->sxBin.pnode1;\n            ParseNodePtr rhs = pnode->sxBin.pnode2;\n\n            Assert(lhs && rhs);\n\n            // Don't track other than integers and objects with member nodes.\n            if (rhs->nop == knopObject && (ParseNode::Grfnop(rhs->nop) & fnopUni))\n            {\n                TrackMemberNodesInObjectForIntConstants(byteCodeGenerator, rhs);\n            }\n            else if (rhs->nop != knopInt &&\n                ((rhs->nop != knopLsh && rhs->nop != knopRsh) || (rhs->sxBin.pnode1->nop != knopInt || rhs->sxBin.pnode2->nop != knopInt)))\n            {\n                return;\n            }\n\n            if (lhs->nop == knopName)\n            {\n                // Handle \"a = <Integer>\" cases here\n                Symbol * sym = lhs->sxVar.sym;\n                TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n            }\n            else if (lhs->nop == knopDot && lhs->sxBin.pnode2->nop == knopName)\n            {\n                // Cases like \"obj.a = <Integer>\"\n                TrackGlobalIntAssignmentsForknopDotProps(lhs, byteCodeGenerator);\n            }\n        }\n        else if (nodeType & fnopUni)\n        {\n            ParseNodePtr lhs = pnode->sxUni.pnode1;\n\n            if (lhs->nop == knopName)\n            {\n                // Cases like \"a++\"\n                Symbol * sym = lhs->sxVar.sym;\n                TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n            }\n            else if (lhs->nop == knopDot && lhs->sxBin.pnode2->nop == knopName)\n            {\n                // Cases like \"obj.a++\"\n                TrackGlobalIntAssignmentsForknopDotProps(lhs, byteCodeGenerator);\n            }\n        }\n    }\n}\n\nvoid Emit(ParseNode *pnode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue, bool isConstructorCall, ParseNode * bindPnode, bool isTopLevel)\n{\n    if (pnode == nullptr)\n    {\n        return;\n    }\n\n    ThreadContext::ProbeCurrentStackNoDispose(Js::Constants::MinStackByteCodeVisitor, byteCodeGenerator->GetScriptContext());\n\n    TrackGlobalIntAssignments(pnode, byteCodeGenerator);\n\n    // printNop(pnode->nop);\n    switch (pnode->nop)\n    {\n    case knopList:\n        EmitList(pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopInt:\n        // currently, these are loaded at the top\n        break;\n        // PTNODE(knopFlt        , \"flt const\"    ,None    ,Flt  ,fnopLeaf|fnopConst)\n    case knopFlt:\n        // currently, these are loaded at the top\n        break;\n        // PTNODE(knopStr        , \"str const\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n    case knopStr:\n        // TODO: protocol for combining string constants\n        break;\n        // PTNODE(knopRegExp     , \"reg expr\"    ,None    ,Pid  ,fnopLeaf|fnopConst)\n    case knopRegExp:\n        funcInfo->GetParsedFunctionBody()->SetLiteralRegex(pnode->sxPid.regexPatternIndex, pnode->sxPid.regexPattern);\n        byteCodeGenerator->Writer()->Reg1Unsigned1(Js::OpCode::NewRegEx, funcInfo->AcquireLoc(pnode), pnode->sxPid.regexPatternIndex);\n        break;          // PTNODE(knopThis       , \"this\"        ,None    ,None ,fnopLeaf)\n    case knopThis:\n        // enregistered\n        // Try to load 'this' from a scope slot if we are in a derived class constructor with scope slots. Otherwise, this is a nop.\n        byteCodeGenerator->EmitScopeSlotLoadThis(funcInfo, funcInfo->thisPointerRegister);\n        break;\n        // PTNODE(knopNewTarget      , \"new.target\"       ,None    , None        , fnopLeaf)\n    case knopNewTarget:\n        break;\n        // PTNODE(knopSuper      , \"super\"       ,None    , None        , fnopLeaf)\n    case knopSuper:\n        if (!funcInfo->IsClassMember())\n        {\n            FuncInfo* nonLambdaFunc = funcInfo;\n            if (funcInfo->IsLambda())\n            {\n                nonLambdaFunc = byteCodeGenerator->FindEnclosingNonLambda();\n            }\n\n            if (nonLambdaFunc->IsGlobalFunction())\n            {\n                if ((byteCodeGenerator->GetFlags() & fscrEval))\n                {\n                    byteCodeGenerator->Writer()->Reg1(isConstructorCall ? Js::OpCode::ScopedLdFuncObj : Js::OpCode::ScopedLdHomeObj, funcInfo->AcquireLoc(pnode));\n                }\n                else\n                {\n                    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_BadSuperReference));\n                }\n            }\n        }\n        break;\n        // PTNODE(knopNull       , \"null\"        ,Null    ,None ,fnopLeaf)\n    case knopNull:\n        // enregistered\n        break;\n        // PTNODE(knopFalse      , \"false\"        ,False   ,None ,fnopLeaf)\n    case knopFalse:\n        // enregistered\n        break;\n        // PTNODE(knopTrue       , \"true\"        ,True    ,None ,fnopLeaf)\n    case knopTrue:\n        // enregistered\n        break;\n        // PTNODE(knopEmpty      , \"empty\"        ,Empty   ,None ,fnopLeaf)\n    case knopEmpty:\n        break;\n        // Unary operators.\n    // PTNODE(knopNot        , \"~\"            ,BitNot  ,Uni  ,fnopUni)\n    case knopNot:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Not_A, funcInfo->AcquireLoc(pnode), pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopNeg        , \"unary -\"    ,Neg     ,Uni  ,fnopUni)\n    case knopNeg:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Neg_A, pnode->location, pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopPos        , \"unary +\"    ,Pos     ,Uni  ,fnopUni)\n    case knopPos:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg2(\n            Js::OpCode::Conv_Num, funcInfo->AcquireLoc(pnode), pnode->sxUni.pnode1->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopLogNot     , \"!\"            ,LogNot  ,Uni  ,fnopUni)\n    case knopLogNot:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // For boolean expressions that compute a result, we have to burn a register for the result\n        // so that the back end can identify it cheaply as a single temp lifetime. Revisit this if we do\n        // full-on renaming in the back end.\n        funcInfo->AcquireLoc(pnode);\n        if (pnode->sxUni.pnode1->nop == knopInt)\n        {\n            int32 value = pnode->sxUni.pnode1->sxInt.lw;\n            Js::OpCode op = value ? Js::OpCode::LdFalse : Js::OpCode::LdTrue;\n            byteCodeGenerator->Writer()->Reg1(op, pnode->location);\n        }\n        else\n        {\n            Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, pnode->location);\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, doneLabel, pnode->sxUni.pnode1->location);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, pnode->location);\n            byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        }\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopEllipsis     , \"...\"       ,Spread  ,Uni         , fnopUni)\n    case knopEllipsis:\n    {\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        // Transparently pass the location of the array.\n        pnode->location = pnode->sxUni.pnode1->location;\n        break;\n    }\n    // PTNODE(knopIncPost    , \"post++\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n    case knopIncPost:\n    case knopDecPost:\n        // FALL THROUGH to the faster pre-inc/dec case if the result of the expression is not needed.\n        if (pnode->isUsed || fReturnValue)\n        {\n            byteCodeGenerator->StartStatement(pnode);\n            Js::OpCode op = Js::OpCode::Add_A;\n            if (pnode->nop == knopDecPost)\n            {\n                op = Js::OpCode::Sub_A;\n            }\n            // Grab a register for the expression result.\n            funcInfo->AcquireLoc(pnode);\n\n            // Load the initial value, convert it (this is the expression result), and increment it.\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Num, pnode->location, pnode->sxUni.pnode1->location);\n\n            Js::RegSlot incDecResult = pnode->sxUni.pnode1->location;\n            if (funcInfo->RegIsConst(incDecResult))\n            {\n                // Avoid letting the add/sub overwrite a constant reg, as this may actually change the\n                // contents of the constant table.\n                incDecResult = funcInfo->AcquireTmpRegister();\n            }\n\n            Js::RegSlot oneReg = funcInfo->constantToRegister.LookupWithKey(1, Js::Constants::NoRegister);\n            Assert(oneReg != Js::Constants::NoRegister);\n            byteCodeGenerator->Writer()->Reg3(op, incDecResult, pnode->location, oneReg);\n\n            // Store the incremented value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, incDecResult, byteCodeGenerator, funcInfo);\n\n            // Release the incremented value and the l-value.\n            if (incDecResult != pnode->sxUni.pnode1->location)\n            {\n                funcInfo->ReleaseTmpRegister(incDecResult);\n            }\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n            byteCodeGenerator->EndStatement(pnode);\n\n            break;\n        }\n        else\n        {\n            pnode->nop = (pnode->nop == knopIncPost) ? knopIncPre : knopDecPre;\n        }\n        // FALL THROUGH to the fast pre-inc/dec case if the result of the expression is not needed.\n\n    // PTNODE(knopIncPre     , \"++ pre\"    ,Inc     ,Uni  ,fnopUni|fnopAsg)\n    case knopIncPre:\n    case knopDecPre:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n        Js::OpCode op = Js::OpCode::Incr_A;\n        if (pnode->nop == knopDecPre)\n        {\n            op = Js::OpCode::Decr_A;\n        }\n\n        // Assign a register for the result only if the result is used or the operand can't be assigned to\n        // (i.e., is a constant).\n        if (pnode->isUsed || fReturnValue)\n        {\n            funcInfo->AcquireLoc(pnode);\n\n            // Load the initial value and increment it (this is the expression result).\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->Writer()->Reg2(op, pnode->location, pnode->sxUni.pnode1->location);\n\n            // Store the incremented value and release the l-value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n        }\n        else\n        {\n            // Load the initial value and increment it (this is the expression result).\n            EmitLoad(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo);\n\n            Js::RegSlot incDecResult = pnode->sxUni.pnode1->location;\n            if (funcInfo->RegIsConst(incDecResult))\n            {\n                // Avoid letting the add/sub overwrite a constant reg, as this may actually change the\n                // contents of the constant table.\n                incDecResult = funcInfo->AcquireTmpRegister();\n            }\n\n            byteCodeGenerator->Writer()->Reg2(op, incDecResult, pnode->sxUni.pnode1->location);\n\n            // Store the incremented value and release the l-value.\n            EmitAssignment(nullptr, pnode->sxUni.pnode1, incDecResult, byteCodeGenerator, funcInfo);\n            if (incDecResult != pnode->sxUni.pnode1->location)\n            {\n                funcInfo->ReleaseTmpRegister(incDecResult);\n            }\n            funcInfo->ReleaseLoad(pnode->sxUni.pnode1);\n        }\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    // PTNODE(knopTypeof     , \"typeof\"    ,None    ,Uni  ,fnopUni)\n    case knopTypeof:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        ParseNode* pnodeOpnd = pnode->sxUni.pnode1;\n        switch (pnodeOpnd->nop)\n        {\n        case knopDot:\n        {\n            Emit(pnodeOpnd->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            Js::PropertyId propertyId = pnodeOpnd->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n            Assert(pnodeOpnd->sxBin.pnode2->nop == knopName);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n\n            byteCodeGenerator->EmitTypeOfFld(funcInfo, propertyId, pnode->location, pnodeOpnd->sxBin.pnode1->location, Js::OpCode::LdFldForTypeOf);\n            break;\n        }\n\n        case knopIndex:\n        {\n            EmitBinaryOpnds(pnodeOpnd->sxBin.pnode1, pnodeOpnd->sxBin.pnode2, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode2);\n            funcInfo->ReleaseLoc(pnodeOpnd->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Element(Js::OpCode::TypeofElem, pnode->location, pnodeOpnd->sxBin.pnode1->location, pnodeOpnd->sxBin.pnode2->location);\n            break;\n        }\n        case knopName:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->EmitPropTypeof(pnode->location, pnodeOpnd->sxPid.sym, pnodeOpnd->sxPid.pid, funcInfo);\n            break;\n        }\n\n        default:\n            Emit(pnodeOpnd, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pnodeOpnd);\n            byteCodeGenerator->Writer()->Reg2(\n                Js::OpCode::Typeof, funcInfo->AcquireLoc(pnode), pnodeOpnd->location);\n            break;\n        }\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopVoid       , \"void\"        ,Void    ,Uni  ,fnopUni)\n    case knopVoid:\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, funcInfo->AcquireLoc(pnode));\n        break;\n        // PTNODE(knopArray      , \"arr cnst\"    ,None    ,Uni  ,fnopUni)\n    case knopArray:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitArrayLiteral(pnode, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopObject     , \"obj cnst\"    ,None    ,Uni  ,fnopUni)\n    case knopObject:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        funcInfo->AcquireLoc(pnode);\n        EmitObjectInitializers(pnode->sxUni.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n        // PTNODE(knopComputedName, \"[name]\"      ,None    ,Uni  ,fnopUni)\n    case knopComputedName:\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        if (pnode->location == Js::Constants::NoRegister)\n        {\n            // The name is some expression with no home location. We can just re-use the register.\n            pnode->location = pnode->sxUni.pnode1->location;\n        }\n        else if (pnode->location != pnode->sxUni.pnode1->location)\n        {\n            // The name had to be protected from side-effects of the RHS.\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxUni.pnode1->location);\n        }\n        break;\n        // Binary and Ternary Operators\n    case knopAdd:\n        EmitAdd(pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopSub:\n    case knopMul:\n    case knopExpo:\n    case knopDiv:\n    case knopMod:\n    case knopOr:\n    case knopXor:\n    case knopAnd:\n    case knopLsh:\n    case knopRsh:\n    case knopRs2:\n    case knopIn:\n        EmitBinary(nopToOp[pnode->nop], pnode, byteCodeGenerator, funcInfo);\n        break;\n    case knopInstOf:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        uint cacheId = funcInfo->NewIsInstInlineCache();\n        byteCodeGenerator->Writer()->Reg3C(nopToOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n            pnode->sxBin.pnode2->location, cacheId);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n    }\n    break;\n    case knopEq:\n    case knopEqv:\n    case knopNEqv:\n    case knopNe:\n    case knopLt:\n    case knopLe:\n    case knopGe:\n    case knopGt:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg3(nopToCMOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n            pnode->sxBin.pnode2->location);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    case knopNew:\n    {\n        EmitNew(pnode, byteCodeGenerator, funcInfo);\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopDelete:\n    {\n        ParseNode *pexpr = pnode->sxUni.pnode1;\n        byteCodeGenerator->StartStatement(pnode);\n        switch (pexpr->nop)\n        {\n        case knopName:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->EmitPropDelete(pnode->location, pexpr->sxPid.sym, pexpr->sxPid.pid, funcInfo);\n            break;\n        }\n        case knopDot:\n        {\n            Emit(pexpr->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n            Js::PropertyId propertyId = pexpr->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            \n            if (pexpr->sxBin.pnode1->nop == knopSuper)\n            {\n                byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeReferenceError, SCODE_CODE(JSERR_DeletePropertyWithSuper));\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->Property(Js::OpCode::DeleteFld, pnode->location, pexpr->sxBin.pnode1->location,\n                    funcInfo->FindOrAddReferencedPropertyId(propertyId));\n            }\n\n            break;\n        }\n        case knopIndex:\n        {\n            EmitBinaryOpnds(pexpr->sxBin.pnode1, pexpr->sxBin.pnode2, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode2);\n            funcInfo->ReleaseLoc(pexpr->sxBin.pnode1);\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Element(Js::OpCode::DeleteElemI_A, pnode->location, pexpr->sxBin.pnode1->location, pexpr->sxBin.pnode2->location);\n            break;\n        }\n        case knopThis:\n        {\n            funcInfo->AcquireLoc(pnode);\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, pnode->location);\n            break;\n        }\n        default:\n        {\n            Emit(pexpr, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pexpr);\n            byteCodeGenerator->Writer()->Reg2(\n                Js::OpCode::Delete_A, funcInfo->AcquireLoc(pnode), pexpr->location);\n            break;\n        }\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopCall:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n\n        if (pnode->sxCall.pnodeTarget->nop == knopSuper)\n        {\n            byteCodeGenerator->EmitSuperCall(funcInfo, pnode, fReturnValue);\n        }\n        else\n        {\n            if (pnode->sxCall.isApplyCall && funcInfo->GetApplyEnclosesArgs())\n            {\n                // TODO[ianhall]: Can we remove the ApplyCall bytecode gen time optimization?\n                EmitApplyCall(pnode, Js::Constants::NoRegister, byteCodeGenerator, funcInfo, fReturnValue);\n            }\n            else\n            {\n                EmitCall(pnode, Js::Constants::NoRegister, byteCodeGenerator, funcInfo, fReturnValue, /*fEvaluateComponents*/ true, /*fHasNewTarget*/ false);\n            }\n        }\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n    case knopIndex:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitBinaryOpnds(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n\n        Js::RegSlot callObjLocation = pnode->sxBin.pnode1->location;\n\n        Js::RegSlot protoLocation =\n            (pnode->sxBin.pnode1->nop == knopSuper) ?\n            byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo) :\n            callObjLocation;\n\n        EmitSuperMethodBegin(pnode, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->Element(\n            Js::OpCode::LdElemI_A, pnode->location, protoLocation, pnode->sxBin.pnode2->location);\n\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // this is MemberExpression as rvalue\n    case knopDot:\n    {\n        Emit(pnode->sxBin.pnode1, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode1);\n        funcInfo->AcquireLoc(pnode);\n        Js::PropertyId propertyId = pnode->sxBin.pnode2->sxPid.PropertyIdFromNameNode();\n\n        Js::RegSlot callObjLocation = pnode->sxBin.pnode1->location;\n        Js::RegSlot protoLocation = callObjLocation;\n        EmitSuperMethodBegin(pnode, byteCodeGenerator, funcInfo);\n\n        uint cacheId = funcInfo->FindOrAddInlineCacheId(callObjLocation, propertyId, false, false);\n        if (pnode->IsCallApplyTargetLoad())\n        {\n            if (pnode->sxBin.pnode1->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFldForCallApplyTarget, pnode->location, tmpReg, cacheId);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFldForCallApplyTarget, pnode->location, protoLocation, cacheId);\n            }\n        }\n        else\n        {\n            if (pnode->sxBin.pnode1->nop == knopSuper)\n            {\n                Js::RegSlot tmpReg = byteCodeGenerator->EmitLdObjProto(Js::OpCode::LdHomeObjProto, funcInfo->superRegister, funcInfo);\n                byteCodeGenerator->Writer()->PatchablePropertyWithThisPtr(Js::OpCode::LdSuperFld, pnode->location, tmpReg, funcInfo->thisPointerRegister, cacheId, isConstructorCall);\n            }\n            else\n            {\n                byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, pnode->location, callObjLocation, cacheId, isConstructorCall);\n            }\n        }\n\n        break;\n    }\n\n    // PTNODE(knopAsg        , \"=\"            ,None    ,Bin  ,fnopBin|fnopAsg)\n    case knopAsg:\n    {\n        ParseNode *lhs = pnode->sxBin.pnode1;\n        ParseNode *rhs = pnode->sxBin.pnode2;\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->isUsed || fReturnValue)\n        {\n            // If the assignment result is used, grab a register to hold it and pass it to EmitAssignment,\n            // which will copy the assigned value there.\n            funcInfo->AcquireLoc(pnode);\n            EmitBinaryReference(lhs, rhs, byteCodeGenerator, funcInfo, false);\n            EmitAssignment(pnode, lhs, rhs->location, byteCodeGenerator, funcInfo);\n        }\n        else\n        {\n            EmitBinaryReference(lhs, rhs, byteCodeGenerator, funcInfo, false);\n            EmitAssignment(nullptr, lhs, rhs->location, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoc(rhs);\n        if (!(byteCodeGenerator->IsES6DestructuringEnabled() && (lhs->IsPattern())))\n        {\n            funcInfo->ReleaseReference(lhs);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    }\n\n    case knopName:\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->EmitPropLoad(pnode->location, pnode->sxPid.sym, pnode->sxPid.pid, funcInfo);\n        break;\n\n    case knopComma:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        // The parser marks binary opnd pnodes as used, but value of the first opnd of a comma is not used.\n        // Easier to correct this here than to check every binary op in the parser.\n        ParseNode *pnode1 = pnode->sxBin.pnode1;\n        pnode1->isUsed = false;\n        if (pnode1->nop == knopComma)\n        {\n            // Spot fix for giant comma expressions that send us into OOS if we use a simple recursive\n            // algorithm. Instead of recursing on comma LHS's, iterate over them, pushing the RHS's onto\n            // a stack. (This suggests a model for removing recursion from Emit altogether...)\n            ArenaAllocator *alloc = byteCodeGenerator->GetAllocator();\n            SList<ParseNode *> rhsStack(alloc);\n            do\n            {\n                rhsStack.Push(pnode1->sxBin.pnode2);\n                pnode1 = pnode1->sxBin.pnode1;\n                pnode1->isUsed = false;\n            } while (pnode1->nop == knopComma);\n\n            Emit(pnode1, byteCodeGenerator, funcInfo, false);\n            if (funcInfo->IsTmpReg(pnode1->location))\n            {\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnode1->location);\n            }\n\n            while (!rhsStack.Empty())\n            {\n                ParseNode *pnodeRhs = rhsStack.Pop();\n                pnodeRhs->isUsed = false;\n                Emit(pnodeRhs, byteCodeGenerator, funcInfo, false);\n                if (funcInfo->IsTmpReg(pnodeRhs->location))\n                {\n                    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnodeRhs->location);\n                }\n                funcInfo->ReleaseLoc(pnodeRhs);\n            }\n        }\n        else\n        {\n            Emit(pnode1, byteCodeGenerator, funcInfo, false);\n            if (funcInfo->IsTmpReg(pnode1->location))\n            {\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::Unused, pnode1->location);\n            }\n        }\n        funcInfo->ReleaseLoc(pnode1);\n\n        pnode->sxBin.pnode2->isUsed = pnode->isUsed || fReturnValue;\n        Emit(pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, false);\n        funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n        funcInfo->AcquireLoc(pnode);\n        if (pnode->sxBin.pnode2->isUsed && pnode->location != pnode->sxBin.pnode2->location)\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxBin.pnode2->location);\n        }\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n    }\n    break;\n\n    // The binary logical ops && and || resolve to the value of the left-hand expression if its\n    // boolean value short-circuits the operation, and to the value of the right-hand expression\n    // otherwise. (In other words, the \"truth\" of the right-hand expression is never tested.)\n    // PTNODE(knopLogOr      , \"||\"        ,None    ,Bin  ,fnopBin)\n    case knopLogOr:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // We use a single dest here for the whole generating boolean expr, because we were poorly\n        // optimizing the previous version where we had a dest for each level\n        funcInfo->AcquireLoc(pnode);\n        EmitGeneratingBooleanExpression(pnode, doneLabel, true, doneLabel, true, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopLogAnd     , \"&&\"        ,None    ,Bin  ,fnopBin)\n    case knopLogAnd:\n    {\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        Js::ByteCodeLabel doneLabel = byteCodeGenerator->Writer()->DefineLabel();\n        // We use a single dest here for the whole generating boolean expr, because we were poorly\n        // optimizing the previous version where we had a dest for each level\n        funcInfo->AcquireLoc(pnode);\n        EmitGeneratingBooleanExpression(pnode, doneLabel, true, doneLabel, true, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(doneLabel);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    }\n    // PTNODE(knopQmark      , \"?\"            ,None    ,Tri  ,fnopBin)\n    case knopQmark:\n    {\n        Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel falseLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel skipLabel = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(pnode->sxTri.pnode1, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode1);\n\n        // For boolean expressions that compute a result, we have to burn a register for the result\n        // so that the back end can identify it cheaply as a single temp lifetime. Revisit this if we do\n        // full-on renaming in the back end.\n        funcInfo->AcquireLoc(pnode);\n\n        Emit(pnode->sxTri.pnode2, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxTri.pnode2->location);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode2);\n\n        // Record the branch bytecode offset\n        byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_FromCurrentToNext);\n\n        byteCodeGenerator->Writer()->Br(skipLabel);\n\n        byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n        Emit(pnode->sxTri.pnode3, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxTri.pnode3->location);\n        funcInfo->ReleaseLoc(pnode->sxTri.pnode3);\n\n        byteCodeGenerator->Writer()->MarkLabel(skipLabel);\n\n        break;\n    }\n\n    case knopAsgAdd:\n    case knopAsgSub:\n    case knopAsgMul:\n    case knopAsgDiv:\n    case knopAsgExpo:\n    case knopAsgMod:\n    case knopAsgAnd:\n    case knopAsgXor:\n    case knopAsgOr:\n    case knopAsgLsh:\n    case knopAsgRsh:\n    case knopAsgRs2:\n        byteCodeGenerator->StartStatement(pnode);\n        // Assign a register for the result only if the result is used or the LHS can't be assigned to\n        // (i.e., is a constant).\n        if (pnode->isUsed || fReturnValue || funcInfo->RegIsConst(pnode->sxBin.pnode1->location))\n        {\n            // If the assign-op result is used, grab a register to hold it.\n            funcInfo->AcquireLoc(pnode);\n\n            // Grab a register for the initial value and load it.\n            EmitBinaryReference(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, true);\n            funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n            // Do the arithmetic, store the result, and release the l-value.\n            byteCodeGenerator->Writer()->Reg3(nopToOp[pnode->nop], pnode->location, pnode->sxBin.pnode1->location,\n                pnode->sxBin.pnode2->location);\n\n            EmitAssignment(pnode, pnode->sxBin.pnode1, pnode->location, byteCodeGenerator, funcInfo);\n        }\n        else\n        {\n            // Grab a register for the initial value and load it.\n            EmitBinaryReference(pnode->sxBin.pnode1, pnode->sxBin.pnode2, byteCodeGenerator, funcInfo, true);\n            funcInfo->ReleaseLoc(pnode->sxBin.pnode2);\n            // Do the arithmetic, store the result, and release the l-value.\n            byteCodeGenerator->Writer()->Reg3(nopToOp[pnode->nop], pnode->sxBin.pnode1->location, pnode->sxBin.pnode1->location,\n                pnode->sxBin.pnode2->location);\n            EmitAssignment(nullptr, pnode->sxBin.pnode1, pnode->sxBin.pnode1->location, byteCodeGenerator, funcInfo);\n        }\n        funcInfo->ReleaseLoad(pnode->sxBin.pnode1);\n\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n\n        // General nodes.\n        // PTNODE(knopTempRef      , \"temp ref\"  ,None   ,Uni ,fnopUni)\n    case knopTempRef:\n        // TODO: check whether mov is necessary\n        funcInfo->AcquireLoc(pnode);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxUni.pnode1->location);\n        break;\n        // PTNODE(knopTemp      , \"temp\"        ,None   ,None ,fnopLeaf)\n    case knopTemp:\n        // Emit initialization code\n        if (pnode->sxVar.pnodeInit != nullptr)\n        {\n            byteCodeGenerator->StartStatement(pnode);\n            Emit(pnode->sxVar.pnodeInit, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, pnode->location, pnode->sxVar.pnodeInit->location);\n            funcInfo->ReleaseLoc(pnode->sxVar.pnodeInit);\n            byteCodeGenerator->EndStatement(pnode);\n        }\n        break;\n        // PTNODE(knopVarDecl    , \"varDcl\"    ,None    ,Var  ,fnopNone)\n    case knopVarDecl:\n    case knopConstDecl:\n    case knopLetDecl:\n    {\n        // Emit initialization code\n        ParseNodePtr initNode = pnode->sxVar.pnodeInit;\n        AssertMsg(pnode->nop != knopConstDecl || initNode != nullptr, \"knopConstDecl expected to have an initializer\");\n\n        if (initNode != nullptr || pnode->nop == knopLetDecl)\n        {\n            Symbol *sym = pnode->sxVar.sym;\n            Js::RegSlot rhsLocation;\n\n            byteCodeGenerator->StartStatement(pnode);\n\n            if (initNode != nullptr)\n            {\n                Emit(initNode, byteCodeGenerator, funcInfo, false);\n                rhsLocation = initNode->location;\n\n                if (initNode->nop == knopObject)\n                {\n                    TrackMemberNodesInObjectForIntConstants(byteCodeGenerator, initNode);\n                }\n                else if (initNode->nop == knopInt)\n                {\n                    TrackIntConstantsOnGlobalObject(byteCodeGenerator, sym);\n                }\n            }\n            else\n            {\n                Assert(pnode->nop == knopLetDecl);\n                rhsLocation = funcInfo->AcquireTmpRegister();\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, rhsLocation);\n            }\n\n            if (pnode->nop != knopVarDecl)\n            {\n                Assert(sym->GetDecl() == pnode);\n                sym->SetNeedDeclaration(false);\n            }\n\n            EmitAssignment(nullptr, pnode, rhsLocation, byteCodeGenerator, funcInfo);\n            funcInfo->ReleaseTmpRegister(rhsLocation);\n\n            byteCodeGenerator->EndStatement(pnode);\n        }\n        break;\n    }\n    // PTNODE(knopFncDecl    , \"fncDcl\"    ,None    ,Fnc  ,fnopLeaf)\n    case knopFncDecl:\n        // The \"function declarations\" were emitted in DefineFunctions()\n        if (!pnode->sxFnc.IsDeclaration())\n        {\n            byteCodeGenerator->DefineOneFunction(pnode, funcInfo, false);\n        }\n        break;\n        // PTNODE(knopClassDecl, \"class\"    ,None    ,None ,fnopLeaf)\n    case knopClassDecl:\n    {\n        funcInfo->AcquireLoc(pnode);\n\n        Assert(pnode->sxClass.pnodeConstructor);\n        pnode->sxClass.pnodeConstructor->location = pnode->location;\n\n        BeginEmitBlock(pnode->sxClass.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        // Extends\n        if (pnode->sxClass.pnodeExtends)\n        {\n            // We can't do StartStatement/EndStatement for pnodeExtends here because the load locations may differ between\n            // defer and nondefer parse modes.\n            Emit(pnode->sxClass.pnodeExtends, byteCodeGenerator, funcInfo, false);\n        }\n\n        // Constructor\n        Emit(pnode->sxClass.pnodeConstructor, byteCodeGenerator, funcInfo, false);\n        EmitComputedFunctionNameVar(bindPnode, pnode->sxClass.pnodeConstructor, byteCodeGenerator);\n        if (pnode->sxClass.pnodeExtends)\n        {\n            byteCodeGenerator->StartStatement(pnode->sxClass.pnodeExtends);\n            byteCodeGenerator->Writer()->InitClass(pnode->location, pnode->sxClass.pnodeExtends->location);\n            byteCodeGenerator->EndStatement(pnode->sxClass.pnodeExtends);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->InitClass(pnode->location);\n        }\n\n        Js::RegSlot protoLoc = funcInfo->AcquireTmpRegister(); //register set if we have Instance Methods\n        int cacheId = funcInfo->FindOrAddInlineCacheId(pnode->location, Js::PropertyIds::prototype, false, false);\n        byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, protoLoc, pnode->location, cacheId);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::SetHomeObj, pnode->location, protoLoc);\n\n        // Static Methods\n        EmitClassInitializers(pnode->sxClass.pnodeStaticMembers, pnode->location, byteCodeGenerator, funcInfo, pnode, /*isObjectEmpty*/ false);\n\n        // Instance Methods\n        EmitClassInitializers(pnode->sxClass.pnodeMembers, protoLoc, byteCodeGenerator, funcInfo, pnode, /*isObjectEmpty*/ true);\n        funcInfo->ReleaseTmpRegister(protoLoc);\n\n        // Emit name binding.\n        if (pnode->sxClass.pnodeName)\n        {\n            Symbol * sym = pnode->sxClass.pnodeName->sxVar.sym;\n            sym->SetNeedDeclaration(false);\n            byteCodeGenerator->EmitPropStore(pnode->location, sym, nullptr, funcInfo, false, true);\n        }\n\n        EndEmitBlock(pnode->sxClass.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        if (pnode->sxClass.pnodeExtends)\n        {\n            funcInfo->ReleaseLoc(pnode->sxClass.pnodeExtends);\n        }\n\n        if (pnode->sxClass.pnodeDeclName)\n        {\n            Symbol * sym = pnode->sxClass.pnodeDeclName->sxVar.sym;\n            sym->SetNeedDeclaration(false);\n            byteCodeGenerator->EmitPropStore(pnode->location, sym, nullptr, funcInfo, true, false);\n        }\n\n        if (pnode->sxClass.IsDefaultModuleExport())\n        {\n            byteCodeGenerator->EmitAssignmentToDefaultModuleExport(pnode, funcInfo);\n        }\n\n        break;\n    }\n    case knopStrTemplate:\n        STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        EmitStringTemplate(pnode, byteCodeGenerator, funcInfo);\n        ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode);\n        break;\n    case knopEndCode:\n        byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_All);\n\n        // load undefined for the fallthrough case:\n        if (!funcInfo->IsGlobalFunction())\n        {\n            if (funcInfo->IsClassConstructor())\n            {\n                // For class constructors, we need to explicitly load 'this' into the return register.\n                byteCodeGenerator->EmitClassConstructorEndCode(funcInfo);\n            }\n            else\n            {\n                // In the global function, implicit return values are copied to the return register, and if\n                // necessary the return register is initialized at the top. Don't clobber the value here.\n                byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, ByteCodeGenerator::ReturnRegister);\n            }\n        }\n\n        // Label for non-fall-through return\n        byteCodeGenerator->Writer()->MarkLabel(funcInfo->singleExit);\n\n        if (funcInfo->GetHasCachedScope())\n        {\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::CommitScope);\n        }\n        byteCodeGenerator->StartStatement(pnode);\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Ret);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopDebugger   , \"debugger\"    ,None    ,None ,fnopNone)\n    case knopDebugger:\n        byteCodeGenerator->StartStatement(pnode);\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Break);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopFor        , \"for\"        ,None    ,For  ,fnopBreak|fnopContinue)\n    case knopFor:\n        if (pnode->sxFor.pnodeInverted != nullptr)\n        {\n            byteCodeGenerator->EmitInvertedLoop(pnode, pnode->sxFor.pnodeInverted, funcInfo);\n        }\n        else\n        {\n            BeginEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n            Emit(pnode->sxFor.pnodeInit, byteCodeGenerator, funcInfo, false);\n            funcInfo->ReleaseLoc(pnode->sxFor.pnodeInit);\n            if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())\n            {\n                CloneEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n            }\n            EmitLoop(pnode,\n                pnode->sxFor.pnodeCond,\n                pnode->sxFor.pnodeBody,\n                pnode->sxFor.pnodeIncr,\n                byteCodeGenerator,\n                funcInfo,\n                fReturnValue,\n                FALSE,\n                pnode->sxFor.pnodeBlock);\n            EndEmitBlock(pnode->sxFor.pnodeBlock, byteCodeGenerator, funcInfo);\n        }\n        break;\n        // PTNODE(knopIf         , \"if\"        ,None    ,If   ,fnopNone)\n    case knopIf:\n    {\n        byteCodeGenerator->StartStatement(pnode);\n\n        Js::ByteCodeLabel trueLabel = byteCodeGenerator->Writer()->DefineLabel();\n        Js::ByteCodeLabel falseLabel = byteCodeGenerator->Writer()->DefineLabel();\n        EmitBooleanExpression(pnode->sxIf.pnodeCond, trueLabel, falseLabel, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxIf.pnodeCond);\n\n        byteCodeGenerator->EndStatement(pnode);\n\n        byteCodeGenerator->Writer()->MarkLabel(trueLabel);\n        Emit(pnode->sxIf.pnodeTrue, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnode->sxIf.pnodeTrue);\n        if (pnode->sxIf.pnodeFalse != nullptr)\n        {\n            // has else clause\n            Js::ByteCodeLabel skipLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n            // Record the branch bytecode offset\n            byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_FromCurrentToNext);\n\n            // then clause skips else clause\n            byteCodeGenerator->Writer()->Br(skipLabel);\n            // generate code for else clause\n            byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n            Emit(pnode->sxIf.pnodeFalse, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnode->sxIf.pnodeFalse);\n            byteCodeGenerator->Writer()->MarkLabel(skipLabel);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->MarkLabel(falseLabel);\n        }\n\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        break;\n    }\n    case knopWhile:\n        EmitLoop(pnode,\n            pnode->sxWhile.pnodeCond,\n            pnode->sxWhile.pnodeBody,\n            nullptr,\n            byteCodeGenerator,\n            funcInfo,\n            fReturnValue);\n        break;\n        // PTNODE(knopDoWhile    , \"do-while\"    ,None    ,While,fnopBreak|fnopContinue)\n    case knopDoWhile:\n        EmitLoop(pnode,\n            pnode->sxWhile.pnodeCond,\n            pnode->sxWhile.pnodeBody,\n            nullptr,\n            byteCodeGenerator,\n            funcInfo,\n            fReturnValue,\n            true);\n        break;\n        // PTNODE(knopForIn      , \"for in\"    ,None    ,ForIn,fnopBreak|fnopContinue|fnopCleanup)\n    case knopForIn:\n        EmitForInOrForOf(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n        break;\n    case knopForOf:\n        EmitForInOrForOf(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n        break;\n        // PTNODE(knopReturn     , \"return\"    ,None    ,Uni  ,fnopNone)\n    case knopReturn:\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxReturn.pnodeExpr != nullptr)\n        {\n            if (pnode->sxReturn.pnodeExpr->location == Js::Constants::NoRegister)\n            {\n                // No need to burn a register for the return value. If we need a temp, use R0 directly.\n                pnode->sxReturn.pnodeExpr->location = ByteCodeGenerator::ReturnRegister;\n            }\n            Emit(pnode->sxReturn.pnodeExpr, byteCodeGenerator, funcInfo, fReturnValue);\n            if (pnode->sxReturn.pnodeExpr->location != ByteCodeGenerator::ReturnRegister)\n            {\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, pnode->sxReturn.pnodeExpr->location);\n            }\n            funcInfo->GetParsedFunctionBody()->SetHasNoExplicitReturnValue(false);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdUndef, ByteCodeGenerator::ReturnRegister);\n        }\n        if (funcInfo->IsClassConstructor())\n        {\n            // return expr; // becomes like below:\n            //\n            // if (IsObject(expr)) {\n            //   return expr;\n            // } else if (IsBaseClassConstructor) {\n            //   return this;\n            // } else if (!IsUndefined(expr)) {\n            //   throw TypeError;\n            // }\n\n            Js::ByteCodeLabel returnExprLabel = byteCodeGenerator->Writer()->DefineLabel();\n            byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, returnExprLabel, ByteCodeGenerator::ReturnRegister);\n\n            if (funcInfo->IsBaseClassConstructor())\n            {\n                byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, funcInfo->thisPointerRegister);\n            }\n            else\n            {\n                Js::ByteCodeLabel returnThisLabel = byteCodeGenerator->Writer()->DefineLabel();\n                byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrSrEq_A, returnThisLabel, ByteCodeGenerator::ReturnRegister, funcInfo->undefinedConstantRegister);\n                byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ClassDerivedConstructorInvalidReturnType));\n                byteCodeGenerator->Writer()->MarkLabel(returnThisLabel);\n                byteCodeGenerator->EmitClassConstructorEndCode(funcInfo);\n            }\n\n            byteCodeGenerator->Writer()->MarkLabel(returnExprLabel);\n        }\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, nullptr, byteCodeGenerator, funcInfo);\n        }\n\n        byteCodeGenerator->Writer()->Br(funcInfo->singleExit);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopLabel:\n        break;\n        // PTNODE(knopBlock      , \"{}\"        ,None    ,Block,fnopNone)\n    case knopBlock:\n        if (pnode->sxBlock.pnodeStmt != nullptr)\n        {\n            EmitBlock(pnode, byteCodeGenerator, funcInfo, fReturnValue);\n            if (pnode->emitLabels)\n            {\n                byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n            }\n        }\n        break;\n        // PTNODE(knopWith       , \"with\"        ,None    ,With ,fnopCleanup)\n    case knopWith:\n    {\n        Assert(pnode->sxWith.pnodeObj != nullptr);\n        byteCodeGenerator->StartStatement(pnode);\n        // Copy the with object to a temp register (the location assigned to pnode) so that if the with object\n        // is overwritten in the body, the lookups are not affected.\n        funcInfo->AcquireLoc(pnode);\n        Emit(pnode->sxWith.pnodeObj, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot regVal = (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled()) ? funcInfo->AcquireTmpRegister() : pnode->location;\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Obj, regVal, pnode->sxWith.pnodeObj->location);\n        if (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled())\n        {\n            byteCodeGenerator->Writer()->Reg2(Js::OpCode::NewWithObject, pnode->location, regVal);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n\n#ifdef PERF_HINT\n        if (PHASE_TRACE1(Js::PerfHintPhase))\n        {\n            WritePerfHint(PerfHints::HasWithBlock, funcInfo->byteCodeFunction->GetFunctionBody(), byteCodeGenerator->Writer()->GetCurrentOffset() - 1);\n        }\n#endif\n        if (pnode->sxWith.pnodeBody != nullptr)\n        {\n            Scope *scope = pnode->sxWith.scope;\n            scope->SetLocation(pnode->location);\n            byteCodeGenerator->PushScope(scope);\n\n            Js::DebuggerScope *debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagExtraScopesType::DiagWithScope, regVal);\n\n            if (byteCodeGenerator->ShouldTrackDebuggerMetadata())\n            {\n                byteCodeGenerator->Writer()->AddPropertyToDebuggerScope(debuggerScope, regVal, Js::Constants::NoProperty, /*shouldConsumeRegister*/ true, Js::DebuggerScopePropertyFlags_WithObject);\n            }\n\n            Emit(pnode->sxWith.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnode->sxWith.pnodeBody);\n            byteCodeGenerator->PopScope();\n\n            byteCodeGenerator->RecordEndScopeObject(pnode);\n        }\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        if (byteCodeGenerator->GetScriptContext()->GetConfig()->IsES6UnscopablesEnabled())\n        {\n            funcInfo->ReleaseTmpRegister(regVal);\n        }\n        funcInfo->ReleaseLoc(pnode->sxWith.pnodeObj);\n        break;\n    }\n    // PTNODE(knopBreak      , \"break\"        ,None    ,Jump ,fnopNone)\n    case knopBreak:\n        Assert(pnode->sxJump.pnodeTarget->emitLabels);\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, pnode->sxJump.pnodeTarget, byteCodeGenerator, funcInfo);\n        }\n        byteCodeGenerator->Writer()->Br(pnode->sxJump.pnodeTarget->sxStmt.breakLabel);\n        if (pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopContinue:\n        Assert(pnode->sxJump.pnodeTarget->emitLabels);\n        byteCodeGenerator->StartStatement(pnode);\n        if (pnode->sxStmt.grfnop & fnopCleanup)\n        {\n            EmitJumpCleanup(pnode, pnode->sxJump.pnodeTarget, byteCodeGenerator, funcInfo);\n        }\n        byteCodeGenerator->Writer()->Br(pnode->sxJump.pnodeTarget->sxStmt.continueLabel);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n        // PTNODE(knopContinue   , \"continue\"    ,None    ,Jump ,fnopNone)\n    case knopSwitch:\n    {\n        BOOL fHasDefault = false;\n        Assert(pnode->sxSwitch.pnodeVal != nullptr);\n        byteCodeGenerator->StartStatement(pnode);\n        Emit(pnode->sxSwitch.pnodeVal, byteCodeGenerator, funcInfo, false);\n\n        Js::RegSlot regVal = funcInfo->AcquireTmpRegister();\n\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::BeginSwitch, regVal, pnode->sxSwitch.pnodeVal->location);\n\n        BeginEmitBlock(pnode->sxSwitch.pnodeBlock, byteCodeGenerator, funcInfo);\n\n        byteCodeGenerator->EndStatement(pnode);\n\n        // TODO: if all cases are compile-time constants, emit a switch statement in the byte\n        // code so the BE can optimize it.\n\n        ParseNode *pnodeCase;\n        for (pnodeCase = pnode->sxSwitch.pnodeCases; pnodeCase; pnodeCase = pnodeCase->sxCase.pnodeNext)\n        {\n            // Jump to the first case body if this one doesn't match. Make sure any side-effects of the case\n            // expression take place regardless.\n            pnodeCase->sxCase.labelCase = byteCodeGenerator->Writer()->DefineLabel();\n            if (pnodeCase == pnode->sxSwitch.pnodeDefault)\n            {\n                fHasDefault = true;\n                continue;\n            }\n            Emit(pnodeCase->sxCase.pnodeExpr, byteCodeGenerator, funcInfo, false);\n            byteCodeGenerator->Writer()->BrReg2(\n                Js::OpCode::Case, pnodeCase->sxCase.labelCase, regVal, pnodeCase->sxCase.pnodeExpr->location);\n            funcInfo->ReleaseLoc(pnodeCase->sxCase.pnodeExpr);\n        }\n\n        // No explicit case value matches. Jump to the default arm (if any) or break out altogether.\n        if (fHasDefault)\n        {\n            byteCodeGenerator->Writer()->Br(Js::OpCode::EndSwitch, pnode->sxSwitch.pnodeDefault->sxCase.labelCase);\n        }\n        else\n        {\n            if (!pnode->emitLabels)\n            {\n                pnode->sxStmt.breakLabel = byteCodeGenerator->Writer()->DefineLabel();\n            }\n            byteCodeGenerator->Writer()->Br(Js::OpCode::EndSwitch, pnode->sxStmt.breakLabel);\n        }\n        // Now emit the case arms to which we jump on matching a case value.\n        for (pnodeCase = pnode->sxSwitch.pnodeCases; pnodeCase; pnodeCase = pnodeCase->sxCase.pnodeNext)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnodeCase->sxCase.labelCase);\n            Emit(pnodeCase->sxCase.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n            funcInfo->ReleaseLoc(pnodeCase->sxCase.pnodeBody);\n        }\n\n        EndEmitBlock(pnode->sxSwitch.pnodeBlock, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseTmpRegister(regVal);\n        funcInfo->ReleaseLoc(pnode->sxSwitch.pnodeVal);\n\n        if (!fHasDefault || pnode->emitLabels)\n        {\n            byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        }\n        break;\n    }\n\n    case knopTryCatch:\n    {\n        Js::ByteCodeLabel catchLabel = (Js::ByteCodeLabel) - 1;\n\n        ParseNode *pnodeTry = pnode->sxTryCatch.pnodeTry;\n        Assert(pnodeTry);\n        ParseNode *pnodeCatch = pnode->sxTryCatch.pnodeCatch;\n        Assert(pnodeCatch);\n\n        catchLabel = byteCodeGenerator->Writer()->DefineLabel();\n\n        // Note: try uses OpCode::Leave which causes a return to parent interpreter thunk,\n        // same for catch block. Thus record cross interpreter frame entry/exit records for them.\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ true);\n\n        byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);\n\n        ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n        }\n\n        Emit(pnodeTry->sxTry.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeTry->sxTry.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(/* isEnterBlock = */ false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->Br(pnode->sxStmt.breakLabel);\n        byteCodeGenerator->Writer()->MarkLabel(catchLabel);\n        Assert(pnodeCatch->sxCatch.pnodeParam);\n        ParseNode *pnodeObj = pnodeCatch->sxCatch.pnodeParam;\n        Js::RegSlot location;\n\n        bool acquiredTempLocation = false;\n\n        Js::DebuggerScope *debuggerScope = nullptr;\n        Js::DebuggerScopePropertyFlags debuggerPropertyFlags = Js::DebuggerScopePropertyFlags_CatchObject;\n\n        bool isPattern = pnodeObj->nop == knopParamPattern;\n\n        if (isPattern)\n        {\n            location = pnodeObj->sxParamPattern.location;\n        }\n        else\n        {\n            location = pnodeObj->sxPid.sym->GetLocation();\n        }\n\n        if (location == Js::Constants::NoRegister)\n        {\n            location = funcInfo->AcquireLoc(pnodeObj);\n            acquiredTempLocation = true;\n        }\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, location);\n\n        Scope *scope = pnodeCatch->sxCatch.scope;\n        byteCodeGenerator->PushScope(scope);\n\n        if (scope->GetMustInstantiate())\n        {\n            Assert(scope->GetLocation() == Js::Constants::NoRegister);\n            if (scope->GetIsObject())\n            {\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeInObject, funcInfo->InnerScopeToRegSlot(scope));\n                byteCodeGenerator->Writer()->Unsigned1(Js::OpCode::NewPseudoScope, scope->GetInnerScopeIndex());\n            }\n            else\n            {\n\n                int index = Js::DebuggerScope::InvalidScopeIndex;\n                debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeInSlot, funcInfo->InnerScopeToRegSlot(scope), &index);\n                byteCodeGenerator->Writer()->Num3(Js::OpCode::NewInnerScopeSlots, scope->GetInnerScopeIndex(), scope->GetScopeSlotCount() + Js::ScopeSlots::FirstSlotIndex, index);\n            }\n        }\n        else\n        {\n            debuggerScope = byteCodeGenerator->RecordStartScopeObject(pnode, Js::DiagCatchScopeDirect, location);\n        }\n\n        auto ParamTrackAndInitialization = [&](Symbol *sym, bool initializeParam, Js::RegSlot location)\n        {\n            if (sym->IsInSlot(funcInfo))\n            {\n                Assert(scope->GetMustInstantiate());\n                if (scope->GetIsObject())\n                {\n                    Js::OpCode op = (sym->GetDecl()->nop == knopLetDecl) ? Js::OpCode::InitUndeclLetFld :\n                        byteCodeGenerator->GetInitFldOp(scope, scope->GetLocation(), funcInfo, false);\n\n                    Js::PropertyId propertyId = sym->EnsurePosition(byteCodeGenerator);\n                    uint cacheId = funcInfo->FindOrAddInlineCacheId(funcInfo->InnerScopeToRegSlot(scope), propertyId, false, true);\n                    byteCodeGenerator->Writer()->ElementPIndexed(op, location, scope->GetInnerScopeIndex(), cacheId);\n\n                    byteCodeGenerator->TrackActivationObjectPropertyForDebugger(debuggerScope, sym, debuggerPropertyFlags);\n                }\n                else\n                {\n                    byteCodeGenerator->TrackSlotArrayPropertyForDebugger(debuggerScope, sym, sym->EnsurePosition(byteCodeGenerator), debuggerPropertyFlags);\n                    if (initializeParam)\n                    {\n                        byteCodeGenerator->EmitLocalPropInit(location, sym, funcInfo);\n                    }\n                    else\n                    {\n                        Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();\n                        byteCodeGenerator->Writer()->Reg1(Js::OpCode::InitUndecl, tmpReg);\n                        byteCodeGenerator->EmitLocalPropInit(tmpReg, sym, funcInfo);\n                        funcInfo->ReleaseTmpRegister(tmpReg);\n                    }\n                }\n            }\n            else\n            {\n                byteCodeGenerator->TrackRegisterPropertyForDebugger(debuggerScope, sym, funcInfo, debuggerPropertyFlags);\n                if (initializeParam)\n                {\n                    byteCodeGenerator->EmitLocalPropInit(location, sym, funcInfo);\n                }\n                else\n                {\n                    byteCodeGenerator->Writer()->Reg1(Js::OpCode::InitUndecl, location);\n                }\n            }\n        };\n\n        if (isPattern)\n        {\n            Parser::MapBindIdentifier(pnodeObj->sxParamPattern.pnode1, [&](ParseNodePtr item)\n            {\n                Js::RegSlot itemLocation = item->sxVar.sym->GetLocation();\n                if (itemLocation == Js::Constants::NoRegister)\n                {\n                    // The var has no assigned register, meaning it's captured, so we have no reg to write to.\n                    // Emit the designated return reg in the byte code to avoid asserting on bad register.\n                    itemLocation = ByteCodeGenerator::ReturnRegister;\n                }\n                ParamTrackAndInitialization(item->sxVar.sym, false /*initializeParam*/, itemLocation);\n            });\n            byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n            // Now emitting bytecode for destructuring pattern\n            byteCodeGenerator->StartStatement(pnodeCatch);\n            ParseNodePtr pnode1 = pnodeObj->sxParamPattern.pnode1;\n            Assert(pnode1->IsPattern());\n            EmitAssignment(nullptr, pnode1, location, byteCodeGenerator, funcInfo);\n            byteCodeGenerator->EndStatement(pnodeCatch);\n        }\n        else\n        {\n            ParamTrackAndInitialization(pnodeObj->sxPid.sym, true /*initializeParam*/, location);\n            if (scope->GetMustInstantiate())\n            {\n                pnodeObj->sxPid.sym->SetIsGlobalCatch(true);\n            }\n            byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n            // Allow a debugger to stop on the 'catch (e)'\n            byteCodeGenerator->StartStatement(pnodeCatch);\n            byteCodeGenerator->Writer()->Empty(Js::OpCode::Nop);\n            byteCodeGenerator->EndStatement(pnodeCatch);\n        }\n\n        ByteCodeGenerator::TryScopeRecord tryRecForCatch(Js::OpCode::ResumeCatch, catchLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForCatch);\n        }\n\n        Emit(pnodeCatch->sxCatch.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->PopScope();\n\n        byteCodeGenerator->RecordEndScopeObject(pnode);\n\n        funcInfo->ReleaseLoc(pnodeCatch->sxCatch.pnodeBody);\n\n        if (acquiredTempLocation)\n        {\n            funcInfo->ReleaseLoc(pnodeObj);\n        }\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        break;\n    }\n\n    case knopTryFinally:\n    {\n        Js::ByteCodeLabel finallyLabel = (Js::ByteCodeLabel) - 1;\n\n        ParseNode *pnodeTry = pnode->sxTryFinally.pnodeTry;\n        Assert(pnodeTry);\n        ParseNode *pnodeFinally = pnode->sxTryFinally.pnodeFinally;\n        Assert(pnodeFinally);\n\n        // If we yield from the finally block after an exception, we have to store the exception object for the future next call.\n        // When we yield from the Try-Finally the offset to the end of the Try block is needed for the branch instruction.\n        Js::RegSlot regException = Js::Constants::NoRegister;\n        Js::RegSlot regOffset = Js::Constants::NoRegister;\n\n        finallyLabel = byteCodeGenerator->Writer()->DefineLabel();\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n        // [CONSIDER][aneeshd] Ideally the TryFinallyWithYield opcode needs to be used only if there is a yield expression.\n        // For now, if the function is generator we are using the TryFinallyWithYield.\n        ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryFinallyWithYield, finallyLabel);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            regException = funcInfo->AcquireTmpRegister();\n            regOffset = funcInfo->AcquireTmpRegister();\n            byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);\n            tryRecForTry.reg1 = regException;\n            tryRecForTry.reg2 = regOffset;\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);\n        }\n        else\n        {\n            byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);\n        }\n\n        // Increasing the stack as we will be storing the additional values when we enter try..finally.\n        funcInfo->StartRecordingOutArgs(1);\n\n        Emit(pnodeTry->sxTry.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeTry->sxTry.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n        }\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        // Note: although we don't use OpCode::Leave for finally block,\n        // OpCode::LeaveNull causes a return to parent interpreter thunk.\n        // This has to be on offset prior to offset of 1st statement of finally.\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);\n\n        byteCodeGenerator->Writer()->Br(pnode->sxStmt.breakLabel);\n        byteCodeGenerator->Writer()->MarkLabel(finallyLabel);\n\n        ByteCodeGenerator::TryScopeRecord tryRecForFinally(Js::OpCode::ResumeFinally, finallyLabel, regException, regOffset);\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForFinally);\n        }\n\n        Emit(pnodeFinally->sxFinally.pnodeBody, byteCodeGenerator, funcInfo, fReturnValue);\n        funcInfo->ReleaseLoc(pnodeFinally->sxFinally.pnodeBody);\n\n        if (funcInfo->byteCodeFunction->IsCoroutine())\n        {\n            byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();\n            funcInfo->ReleaseTmpRegister(regOffset);\n            funcInfo->ReleaseTmpRegister(regException);\n        }\n\n        funcInfo->EndRecordingOutArgs(1);\n\n        byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);\n\n        byteCodeGenerator->Writer()->Empty(Js::OpCode::LeaveNull);\n\n        byteCodeGenerator->Writer()->MarkLabel(pnode->sxStmt.breakLabel);\n        break;\n    }\n    case knopThrow:\n        byteCodeGenerator->StartStatement(pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->Writer()->Reg1(Js::OpCode::Throw, pnode->sxUni.pnode1->location);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopYieldLeaf:\n        byteCodeGenerator->StartStatement(pnode);\n        funcInfo->AcquireLoc(pnode);\n        EmitYield(funcInfo->undefinedConstantRegister, pnode->location, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopAwait:\n    case knopYield:\n        byteCodeGenerator->StartStatement(pnode);\n        funcInfo->AcquireLoc(pnode);\n        Emit(pnode->sxUni.pnode1, byteCodeGenerator, funcInfo, false);\n        EmitYield(pnode->sxUni.pnode1->location, pnode->location, byteCodeGenerator, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxUni.pnode1);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopYieldStar:\n        byteCodeGenerator->StartStatement(pnode);\n        EmitYieldStar(pnode, byteCodeGenerator, funcInfo);\n        byteCodeGenerator->EndStatement(pnode);\n        break;\n    case knopExportDefault:\n        Emit(pnode->sxExportDefault.pnodeExpr, byteCodeGenerator, funcInfo, false);\n        byteCodeGenerator->EmitAssignmentToDefaultModuleExport(pnode->sxExportDefault.pnodeExpr, funcInfo);\n        funcInfo->ReleaseLoc(pnode->sxExportDefault.pnodeExpr);\n        pnode = pnode->sxExportDefault.pnodeExpr;\n        break;\n    default:\n        AssertMsg(0, \"emit unhandled pnode op\");\n        break;\n    }\n\n    if (fReturnValue && IsExpressionStatement(pnode, byteCodeGenerator->GetScriptContext()))\n    {\n        // If this statement may produce the global function's return value, copy its result to the return register.\n        // fReturnValue implies global function, which implies that \"return\" is a parse error.\n        Assert(funcInfo->IsGlobalFunction());\n        Assert(pnode->nop != knopReturn);\n        byteCodeGenerator->Writer()->Reg2(Js::OpCode::Ld_A, ByteCodeGenerator::ReturnRegister, pnode->location);\n    }\n}\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\nWScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");\n\nvar tests = [\n  { \n    name: \"Split parameter scope in function definition\", \n    body: function () { \n        function f1(a = 10, b = function () { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Function defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f2(a = 10, b = function () { return a; }, c = b() + a) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            assert.areEqual(20, c, \"Initial value of the third parameter in the body scope should be twice the value of the first parameter\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f2()(), \"Function defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f3(a = 10, b = function () { return a; }) { \n            assert.areEqual(1, a, \"Initial value of parameter in the body scope should be the same as the one passed in\"); \n            var a = 20; \n            assert.areEqual(20, a, \"Assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(f3(1)(), 1, \"Function defined in the param scope captures the formals from the param scope even when the default expression is not applied for that param\"); \n\n        (function (a = 10, b = a += 10, c = function () { return a + b; }) { \n            assert.areEqual(20, a, \"Initial value of parameter in the body scope should be same as the corresponding symbol's final value in the param scope\"); \n            var a2 = 40; \n            (function () { assert.areEqual(40, a2, \"Symbols defined in the body scope should be unaffected by the duplicate formal symbols\"); })(); \n            assert.areEqual(40, c(), \"Function defined in param scope uses the formals from param scope even when executed inside the body\"); \n        })(); \n\n        (function (a = 10, b = function () { assert.areEqual(10, a, \"Function defined in the param scope captures the formals from the param scope when executed from the param scope\"); }, c = b()) { \n        })(); \n\n        function f4(a = 10, b = function () { return a; }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f4()(), \"Even if the formals are not redeclared in the function body the symbol in the param scope and body scope are different\"); \n\n        function f5(a = 10, b = function () { return function () { return a; }; }) { \n            var a = 20; \n            return b; \n        } \n        assert.areEqual(10, f5()()(), \"Parameter scope works fine with nested functions\"); \n\n        var a1 = 10; \n        function f6(a, b = function () { a; return a1; }) { \n            assert.areEqual(undefined, a1, \"Inside the function body the assignment hasn't happened yet\"); \n            var a1 = 20; \n            assert.areEqual(20, a1, \"Assignment to the symbol inside the function changes the value\"); \n            return b; \n        } \n        assert.areEqual(10, f6()(), \"Function in the param scope correctly binds to the outer variable\"); \n         \n        function f7(a = 10, b = { iFnc () { return a; } }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f7().iFnc(), \"Function definition inside the object literal should capture the formal from the param scope\");\n        \n        var f8 = function (a, b = ((function() { assert.areEqual('string1', a, \"First arguemnt receives the right value\"); })(), 1), c) {\n            var d = 'string3';\n            (function () { assert.areEqual('string3', d, \"Var declaration in the body is initialized properly\"); })();\n            return c;\n        };\n\n        assert.areEqual('string2', f8('string1', undefined, 'string2'), \"Function returns the third argument properly\");\n        \n        function f9() {\n            var f10 = function (a = function () { c; }, b, c) {\n                assert.areEqual(1, c, \"Third argument is properly populated\");\n                arguments;\n                function f11() {};\n            };\n            f10(undefined, undefined, 1);\n        }\n        f9();\n        f9();\n        \n        function f12() {\n            var result = ((a = (w = a => a * a) => w) => a)()()(10); \n            \n            assert.areEqual(100, result, \"The inner lambda function properly maps to the right symbol for a\");\n        };\n        f12();\n    } \n }, \n { \n    name: \"Split parameter scope and function expressions with name\", \n    body: function () { \n        function f1(a = 10, b = function c() { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope of the method should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope of the method updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Function expression defined in the param scope captures the formals from the param scope not body scope\"); \n         \n        function f2(a = 10, b = function c(recurse = true) { return recurse ? c(false) : a; }) { \n            return b; \n        } \n        assert.areEqual(10, f2()(), \"Recursive function expression defined in the param scope captures the formals from the param scope not body scope\");\n        \n        assert.areEqual(10, f2()(), \"Recursive function expression defined in the param scope captures the formals from the param scope not body scope\");\n\n        var f3 = function f4 (a = function ( ) { b; return f4(20); }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f3()(), \"Recursive call to the function from the param scope returns the right value\");\n\n        var f5 = function f6 (a = function ( ) { b; return f6; }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f5()()(20), \"Recursive call to the function from the param scope returns the right value\");\n        \n        var f7 = function f8 (a = function ( ) { b; }, b) {\n            if (a == 20) {\n                return 10;\n            }\n            var a = function () { return f8(20); };\n            return a;\n        }\n        assert.areEqual(10, f7()(), \"Recursive call to the function from the body scope returns the right value\");\n        \n        var f9 = function f10 (a = function ( ) { b; return f10(20); }, b) {\n            eval(\"\");\n            if (a == 20) {\n                return 10;\n            }\n            return a;\n        }\n        assert.areEqual(10, f9()(), \"Recursive call to the function from the param scope returns the right value when eval is there in the body\");\n        \n        var f11 = function f12 (a = function ( ) { b; }, b) {\n            eval(\"\");\n            if (a == 20) {\n                return 10;\n            }\n            var a = function () { return f12(20); };\n            return a;\n        }\n        assert.areEqual(10, f11()(), \"Recursive call to the function from the body scope returns the right value when eval is there in the body\");\n\n        function f13() {\n            var a = function jnvgfg(sfgnmj = function ccunlk() { jnvgfg(undefined, 1); }, b) {\n                if (b) {\n                    assert.areEqual(undefined, jnvgfg, \"This refers to the instance in the body and the value of the function expression is not copied over\");\n                }\n                var jnvgfg = 10;\n                if (!b) {\n                    sfgnmj();\n                    return 100;\n                }\n            };\n            assert.areEqual(100, a(), \"After the recursion the right value is returned by the split scoped function\");\n        };\n        f13();\n\n    } \n }, \n { \n    name: \"Split parameter scope in member functions\", \n    body: function () { \n       var o1 = { \n           f(a = 10, b = function () { return a; }) { \n               assert.areEqual(10, a, \"Initial value of parameter in the body scope of the method should be the same as the one in param scope\"); \n               var a = 20; \n               assert.areEqual(20, a, \"New assignment in the body scope of the method updates the variable's value in body scope\"); \n                return b; \n            } \n        } \n        assert.areEqual(o1.f()(), 10, \"Function defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n         \n        var o2 = { \n            f1(a = 10, b = function () { return { f2 () { return a; } } }) { \n                var a = 20; \n                c = function () { return { f2 () { return a; } } }; \n                return [b, c]; \n            } \n        } \n        var result = o2.f1(); \n        assert.areEqual(10, result[0]().f2(), \"Short hand method defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n        assert.areEqual(20, result[1]().f2(), \"Short hand method defined in the param scope of the object method captures the formals from the param scope not body scope\"); \n    } \n  },\n  { \n    name: \"Arrow functions in split param scope\", \n    body: function () { \n        function f1(a = 10, b = () => { return a; }) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f1()(), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope\"); \n\n        function f2(a = 10, b = () => { return a; }) { \n            assert.areEqual(1, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(1, f2(1)(), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope even when value is passed\"); \n\n        function f3(a = 10, b = () => a) { \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\"); \n            var a = 20; \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\"); \n            return b; \n        } \n        assert.areEqual(10, f3()(), \"Arrow functions with concise body defined in the param scope captures the formals from the param scope not body scope\"); \n\n        ((a = 10, b = a += 10, c = () => { assert.areEqual(20, a, \"Value of the first formal inside the lambda should be same as the default value\"); return a + b; }, d = c() * 10) => { \n            assert.areEqual(d, 400, \"Initial value of the formal parameter inside the body should be the same as final value from the param scope\"); \n        })(); \n\n        function f4(a = 10, b = () => { return () => a; }) { \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f4()()(), \"Nested lambda should capture the formal param value from the param scope\"); \n\n        assert.throws(function f4(a = () => x) { var x = 1; a(); }, ReferenceError, \"Lambdas in param scope shouldn't be able to access the variables from body\", \"'x' is undefined\"); \n        assert.throws(function f5() { (function (a = () => x) { var x = 1; return a; })()(); }, ReferenceError, \"Lambdas in param scope shouldn't be able to access the variables from body\", \"'x' is undefined\"); \n        assert.throws((a = () => 10, b = a() + c, c = 10) => {}, ReferenceError, \"Formals defined to the right shouldn't be usable in lambdas\", \"Use before declaration\"); \n    } \n  },\n  { \n    name: \"Split parameter scope with Rest\", \n    body: function () { \n        var arr = [2, 3, 4]; \n        function f1(a = 10, b = function () { return a; }, ...c) { \n            assert.areEqual(arr.length, c.length, \"Rest parameter should contain the same number of elements as the spread arg\"); \n            for (i = 0; i < arr.length; i++) { \n                assert.areEqual(arr[i], c[i], \"Elements in the rest and the spread should be in the same order\"); \n            } \n            return b; \n        } \n        assert.areEqual(f1(undefined, undefined, ...arr)(), 10, \"Presence of rest parameter shouldn't affect the binding\"); \n\n        ((a = 10, b = () => a, ...c) => { \n            assert.areEqual(arr.length, c.length, \"Rest parameter should contain the same number of elements as the spread arg\"); \n            for (i = 0; i < arr.length; i++) { \n                assert.areEqual(arr[i], c[i], \"Elements in the rest and the spread should be in the same order\"); \n            } \n            return b; \n        })(undefined, undefined, ...arr); \n    } \n  },\n  { \n    name: \"Split parameter scope with this\", \n    body: function () { \n        function f1(a = this.x, b = function() { assert.areEqual(100, this.x, \"this object for the function in param scope is passed from the final call site\"); return a; }) { \n            assert.areEqual(10, this.x, \"this objects property retains the value from param scope\"); \n            a = 20; \n            return b; \n        } \n        assert.areEqual(10, f1.call({x : 10}).call({x : 100}), \"Arrow functions defined in the param scope captures the formals from the param scope not body scope\"); \n         \n        (function (a = this.x, b = function() {this.x = 20; return a;}) { \n            assert.areEqual(10, this.x, \"this objects property retains the value in param scope before the inner function call\"); \n            b.call(this); \n            assert.areEqual(20, this.x, \"Update to a this's property from the param scope is reflected in the body scope\"); \n        }).call({x : 10}); \n         \n        this.x = 10; \n        ((a = this.x, b = function() { a; this.x = 20; }) => { \n            assert.areEqual(10, this.x, \"this objects property retains the value in param scope before the inner function call in lambda\"); \n            b.call(this); \n            assert.areEqual(20, this.x, \"Update to a this's property from the param scope of lambda function is reflected in the body scope\"); \n        })(); \n         \n        function f2(a = function() { return this.x; }, b = this.y, c = a.call({x : 20}) + b) { \n            assert.areEqual(undefined, this.x, \"this object remains unaffected\"); \n            return c; \n        } \n        assert.areEqual(30, f2.call({y : 10}), \"Properties are accessed from the right this object\"); \n\n        var thisObj = {x : 1, y : 20 };\n        function f3(a, b = () => { a; this.x = 10; return this.y; }) {\n            assert.areEqual(1, this.x, \"Assignment from the param scope has not happened yet\");\n            assert.areEqual(20, this.y, \"y property of the this object is not affected\");\n            return b; \n        } \n        assert.areEqual(20, f3.call(thisObj)(), \"Lambda defined in the param scope returns the right property value from thisObj\"); \n        assert.areEqual(10, thisObj.x, \"Assignment from the param scope method updates thisObj's property\"); \n\n        function f4(a, b = () => { a; return this; }) {\n            return b;\n        }\n        assert.areEqual(thisObj, f4.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\"); \n        \n        var thisObj = { x : 1 };\n        function f5() {\n            return (a = this, b = function() { return a; }) => b;\n        }\n        assert.areEqual(thisObj, f5.call(thisObj)()(), \"This object is returned properly from the inner lambda method's child function\");\n\n        function f6(a, b = function () { return a; }) {\n            return (a = this, b = function() { return a; }) => b;\n        }\n        assert.areEqual(thisObj, f6.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a split scoped function\");\n\n        function f7(a, b = function () { return a; }) {\n            function f8() {\n                return (a = this, b = function() { return a; }) => b;\n            }\n            return f8.call(this);\n        }\n        assert.areEqual(thisObj, f7.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a nested split scoped function\");\n\n        function f9(a, b = function () { return a; }) {\n            function f10(c, d = function () { c; }) {\n                return (a = this, b = function() { return a; }) => b;\n            }\n            return f10.call(this);\n        }\n        assert.areEqual(thisObj, f9.call(thisObj)()(), \"This object is returned properly from the inner lambda defnied inside a double nested split scoped function\");\n        \n        function f11(a = this.x * 10, b = () => { a; return this; }) {\n            assert.areEqual(10, a, \"this should be accessible in the parameter scope\");\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            assert.isTrue(eval(\"thisObj == this\"), \"Eval should be able to access the this object properly\");\n            return b;\n        }\n        assert.areEqual(thisObj, f11.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\"); \n\n        function f12(a = this.x * 10, b = () => { a; return this; }) {\n            var c = 100;\n            assert.areEqual(10, a, \"this should be accessible in the parameter scope\");\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            assert.isTrue(eval(\"thisObj == this\"), \"Eval should be able to access the this object properly\");\n            assert.areEqual(thisObj, (() => this)(), \"Lambda should capture the this object from body properly\");\n            assert.areEqual(100, c, \"Body variable should be unaffected by the slot allocation of this object\");\n            return b;\n        }\n        assert.areEqual(thisObj, f12.call(thisObj)(), \"Lambda defined in the param scope returns the right this object\");\n\n        function f13(a = 10, b = () => { a; return this; }) {\n            var c = 100;\n            assert.areEqual(thisObj, this, \"Body scope should get the right value for this object\");\n            var d = () => this;\n            this.x = 5;\n            assert.isTrue(eval(\"this.x == 5\"), \"Eval should be able to access the this object properly after the field is updated\");\n            assert.isTrue(eval(\"d().x == 5\"), \"Lambda should capture the this symbol from the body properly\");\n            assert.isTrue(eval(\"a == 10\"), \"Eval should be able to access the first parameter properly\");\n            assert.isTrue(eval(\"b().x == 5\"), \"Lambda from the param scope should capture the this symbol properly\");\n            assert.isTrue(eval(\"d().x == 5\"), \"Lambda should capture the this symbol from the body properly\");\n            return b;\n        }\n        assert.areEqual(5, f13.call(thisObj)().x, \"Lambda defined in the param scope returns the same this object as the one in body\"); \n    } \n  },\n  { \n    name: \"Split parameter scope and class\", \n    body: function () { \n        class c { \n            f(a = 10, d, b = function () { return a; }, c) { \n                assert.areEqual(10, a, \"Initial value of parameter in the body scope in class method should be the same as the one in param scope\"); \n                var a = 20; \n                assert.areEqual(20, a, \"Assignment in the class method body updates the value of the variable\"); \n                return b; \n            } \n        } \n        assert.areEqual(10, (new c()).f()(), \"Method defined in the param scope of the class should capture the formal from the param scope itself\"); \n\n        function f1(a = 10, d, b = class { method1() { return a; } }, c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        var result = f1(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined in param scope should capture the formals form that param scope itself\"); \n\n        class c2 { \n            f1(a = 10, d, b = function () { a = this.f2(); return a; }, c) { \n                assert.areEqual(30, this.f2(), \"this object in the body points to the right this object\"); \n                return b; \n            }; \n            f2() { \n                return 30; \n            } \n        } \n        var f2Obj = new c2(); \n        assert.areEqual(100, f2Obj.f1().call({f2() { return 100; }}), \"Method defined in the param uses its own this object while updating the formal\"); \n\n        function f2(a = 10, d, b = class { method1() { return class { method2() { return a; }} } }, c) { \n            a = 20; \n            return b; \n        } \n        var obj1 = f2(); \n        var obj2 = (new obj1()).method1(); \n        assert.areEqual(10, (new obj2()).method2(), \"Nested class definition in the param scope should capture the formals from the param scope\"); \n\n        var actualArray = [2, 3, 4]; \n        class c3 { \n            f(a = 10, b = () => { return c; }, ...c) { \n                assert.areEqual(actualArray.length, c.length, \"Rest param and the actual array should have the same length\"); \n                for (var i = 0; i < c.length; i++) { \n                    assert.areEqual(actualArray[i], c[i], \"Rest parameter should have the same value as the actual array\"); \n                } \n                c = []; \n                return b; \n            } \n        } \n        result = (new c3()).f(undefined, undefined, ...[2, 3, 4])(); \n        assert.areEqual(actualArray.length, result.length, \"The result and the actual array should have the same length\"); \n        for (var i = 0; i < result.length; i++) { \n            assert.areEqual(actualArray[i], result[i], \"The result array should have the same value as the actual array\"); \n        } \n\n        class c4 { \n            f({x:x = 10, y:y = () => { return x; }}) { \n                assert.areEqual(10, x, \"Initial value of destructure parameter in the body scope in class method should be the same as the one in param scope\"); \n                x = 20; \n                assert.areEqual(20, x, \"Assignment in the class method body updates the value of the variable\"); \n                return y; \n            } \n        } \n        assert.areEqual(10, (new c4()).f({})(), \"The method defined as the default destructured value of the parameter should capture the formal from the param scope\");\n        \n        function f3(a = 10, d, b = (function () { return a; }, class { method1() { return a; } }), c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        result = f3(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after another function definition, in the param scope should capture the formals form that param scope itself\"); \n        \n        function f4(a = 10, d, b = (function () { return a; }, class {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f4(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after another class definition, in the param scope should capture the formals form that param scope itself\");\n         \n        function f5(a = 10, d, b = (function () { return a; }, class {}, function () {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f5(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after a function and class, in the param scope should capture the formals form that param scope itself\");\n        \n        function f6(a = 10, d, b = (function () { return a; }, class {}, function (a, b = () => a) {}, class { method1() { return a; } }), c) { \n            var a = 20; \n            return b; \n        } \n        result = f6(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class defined, after a split scope function, in the param scope should capture the formals form that param scope itself\");\n        \n        function f7(a = 10, d, b = (function () { return a; }, class c1 { method1() { return a; } }), c) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return b; \n        } \n        result = f7(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class with name defined, after another function definition, in the param scope should capture the formals form that param scope itself\");\n        \n        function f8(a = 10, d, b = class c1 { method1() { return a; } }, c = (function () { return a; }, class c2 extends b { method2() { return a * a; } })) { \n            var a = 20; \n            assert.areEqual(10, (new b()).method1(), \"Class method defined within the param scope should capture the formal from the param scope\"); \n            return c; \n        } \n        result = f8(); \n        assert.areEqual(10, (new result()).method1(), \"Methods defined in a class extending another class defined, after another function definition, in the param scope should capture the formals form that param scope itself\");\n        assert.areEqual(100, (new result()).method2(), \"Method in the derived class returns the right value\");\n    } \n  },\n  { \n    name: \"Split parameter scope in generator methods\", \n    body: function () { \n        function *f1(a = 10, d, b = function () { return a; }, c) { \n            yield a; \n            var a = 20; \n            yield a; \n            yield b; \n        } \n        var f1Obj = f1(); \n        assert.areEqual(10, f1Obj.next().value, \"Initial value of the parameter in the body scope should be the same as the final value of the parameter in param scope\"); \n        assert.areEqual(20, f1Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(10, f1Obj.next().value(), \"Function defined in the param scope captures the formal from the param scope itself\"); \n\n        function *f2(a = 10, d, b = function () { return a; }, c) { \n            yield a; \n            a = 20; \n            yield a; \n            yield b; \n        } \n        var f2Obj = f2(); \n        assert.areEqual(10, f2Obj.next().value, \"Initial value of the parameter in the body scope should be the same as the final value of the parameter in param scope\"); \n        assert.areEqual(20, f2Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(10, f2Obj.next().value(), \"Function defined in the param scope captures the formal from the param scope itself even if it is not redeclared in the body\"); \n\n        function *f3(a = 10, d, b = function *() { yield a + c; }, c = 100) { \n            a = 20; \n            yield a; \n            yield b; \n        } \n        var f3Obj = f3(); \n        assert.areEqual(20, f3Obj.next().value, \"Assignment in the body scope updates the variable's value\"); \n        assert.areEqual(110, f3Obj.next().value().next().value, \"Function defined in the param scope captures the formals from the param scope\"); \n\n        function *f4(a = 10, d, b = function *() { yield a; }, c) { \n            var a = 20; \n            yield function *() { yield a; }; \n            yield b; \n        } \n        var f4Obj = f4(); \n        assert.areEqual(20, f4Obj.next().value().next().value, \"Generator defined inside the body captures the symbol from the body scope\"); \n        assert.areEqual(10, f4Obj.next().value().next().value, \"Function defined in the param scope captures the formal from param scope even if it is captured in the body scope\"); \n    } \n  },\n  { \n    name: \"Split parameter scope with destructuring\", \n    body: function () { \n        function f1( {a:a1, b:b1}, c = function() { return a1 + b1; } ) { \n            assert.areEqual(10, a1, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            assert.areEqual(20, b1, \"Initial value of the second destructuring parameter in the body scope should be the same as the one in param scope\"); \n            a1 = 1; \n            b1 = 2; \n            assert.areEqual(1, a1, \"New assignment in the body scope updates the first formal's value in body scope\"); \n            assert.areEqual(2, b1, \"New assignment in the body scope updates the second formal's value in body scope\"); \n            assert.areEqual(30, c(), \"The param scope method should return the sum of the destructured formals from the param scope\"); \n            return c; \n        } \n        assert.areEqual(30, f1({ a : 10, b : 20 })(), \"Returned method should return the sum of the destructured formals from the param scope\"); \n\n        function f2({x:x = 10, y:y = function () { return x; }}) { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(20, x, \"Assignment in the body updates the formal's value\"); \n            return y; \n        } \n        assert.areEqual(10, f2({ })(), \"Returned method should return the value of the destructured formal from the param scope\"); \n         \n        function f3({y:y = function () { return x; }, x:x = 10}) { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(20, x, \"Assignment in the body updates the formal's value\"); \n            return y; \n        } \n        assert.areEqual(10, f3({ })(), \"Returned method should return the value of the destructured formal from the param scope even if declared after\"); \n         \n        (({x:x = 10, y:y = function () { return x; }}) => { \n            assert.areEqual(10, x, \"Initial value of the first destructuring parameter in the body scope should be the same as the one in param scope\"); \n            x = 20; \n            assert.areEqual(10, y(), \"Assignment in the body does not affect the formal captured from the param scope\"); \n        })({}); \n    } \n  },\n  { \n    name: \"Nested split scopes\", \n    body: function () { \n          function f1(a = 10, b = function () { return a; }, c) { \n              function iFnc(d = 100, e = 200, pf1 = function () { return d + e; }) { \n                  d = 1000; \n                  e = 2000; \n                  pf2 = function () { return d + e; }; \n                  return [pf1, pf2]; \n              } \n              return [b].concat(iFnc()); \n          } \n          var result = f1(); \n          assert.areEqual(10, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope\"); \n          assert.areEqual(300, result[1](), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope\"); \n          assert.areEqual(3000, result[2](), \"Function defined in the body scope of the inner function should capture the symbols from its body scope\"); \n\n          function f2(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              c = 2000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc()]; \n          } \n          result = f2(); \n          assert.areEqual(10, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope even if formals are with the same name in inner function\"); \n          assert.areEqual(300, result[1](), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope  if formals are with the same name in the outer function\"); \n\n          function f3(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              c = 2000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc]; \n          } \n          assert.areEqual(300, f3()[1]()(), \"Function defined in the param scope of the inner function should capture the right formals even if the inner function is executed outside\"); \n\n          function f4(a = 10, b = function () { return a; }, c) { \n              a = 1000; \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc(undefined, b, c)]; \n          } \n          result = f4(1, undefined, 3); \n          assert.areEqual(1, result[0](), \"Function defined in the param scope of the outer function correctly captures the passed in value for the formal\"); \n          assert.areEqual(1, result[1](), \"Function defined in the param scope of the inner function is replaced by the function definition from the param scope of the outer function\"); \n\n          function f5(a = 10, b = function () { return a; }, c) { \n              function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                  a = 1000; \n                  c = 2000; \n                  return b; \n              } \n              return [b, iFnc(a, undefined, c)]; \n          } \n          result = f5(1, undefined, 3); \n          assert.areEqual(1, result[0](), \"Function defined in the param scope of the outer function correctly captures the passed in value for the formal\"); \n          assert.areEqual(4, result[1](), \"Function defined in the param scope of the inner function captures the passed values for the formals\"); \n\n          function f6(a , b, c) { \n              function iFnc(a = 1, b = function () { return a + c; }, c = 2) { \n                  a = 10; \n                  c = 20; \n                  return b; \n              } \n              return iFnc; \n          } \n          assert.areEqual(3, f6()()(), \"Function defined in the param scope captures the formals when defined inside another method without split scope\"); \n\n          function f7(a = 10 , b = 20, c = function () { return a + b; }) { \n              return (function () { \n                  function iFnc(a = 100, b = function () { return a + c; }, c = 200) { \n                      a = 1000; \n                      c = 2000; \n                      return b; \n                  } \n                  return [c, iFnc]; \n              })(); \n          } \n          result = f7(); \n          assert.areEqual(30, result[0](), \"Function defined in the param scope of the outer function should capture the symbols from its own param scope even in nested case\"); \n          assert.areEqual(300, result[1]()(), \"Function defined in the param scope of the inner function should capture the symbols from its own param scope even when nested inside a normal method and a split scope\"); \n\n          function f8(a = 1, b = function (d = 10, e = function () { return a + d; }) { assert.areEqual(d, 10, \"Split scope function defined in param scope should capture the right formal value\"); d = 20; return e; }, c) { \n              a = 2; \n              return b; \n          } \n          assert.areEqual(11, f8()()(), \"Split scope function defined within the param scope should capture the formals from the corresponding param scopes\"); \n\n          function f9(a = 1, b = function () { return function (d = 10, e = function () { return a + d; }) { d = 20; return e; } }, c) { \n              a = 2; \n              return b; \n          } \n          assert.areEqual(11, f9()()()(), \"Split scope function defined within the param scope should capture the formals from the corresponding param scope in nested scope\"); \n    }   \n  }, \n  {\n    name: \"Split scope with symbol shadowing\",\n    body: function () {\n          function f1(a = 10, b = function () { return a; }) {\n              assert.areEqual(100, a(), \"Function definition inside the body is hoisted\");\n              function a () {\n                  return 100;\n              }\n              return b;\n        }\n        assert.areEqual(10, f1()(), \"Function definition in the param scope captures the symbol from the param scope\");\n\n        function f2(a = 10, b = function () { return a; }, c = b) {\n            a = 20;\n            assert.areEqual(20, b(), \"Function definition in the body scope captures the body symbol\");\n            function b() {\n                return a;\n            }\n            return [c, b];\n        }\n        var result = f2();\n        assert.areEqual(10, result[0](), \"Function definition in the param scope captures the param scope symbol\");\n        assert.areEqual(20, result[1](), \"Function definition in the body captures the body symbol\");\n        \n        var g = 1;\n        function f3(a = 10, b = function () { a; return g;}) {\n            assert.areEqual(10, g(), \"Function definition inside the body is unaffected by the outer variable\");\n            function g() {\n                return 10;\n            }\n            return b;\n        }\n        assert.areEqual(1, f3()(), \"Function definition in the param scope captures the outer scoped var\");\n        \n        function f4(a = x1, b = function g() {\n            a;\n            return function h() {\n                assert.areEqual(10, x1, \"x1 is captured from the outer scope\");\n            };\n        }) {\n            var x1 = 100;\n            b()();\n        };\n        var x1 = 10;\n        f4();\n        \n        var x2 = 1;\n        function f5(a = x2, b = function() { a; return x2; }) {\n            {\n                function x2() {\n                }\n            }\n            var x2 = 2;\n            return b;\n        }\n        assert.areEqual(1, f5()(), \"Symbol capture at the param scope is unaffected by the inner definitions\");\n        \n        var x3 = 1;\n        function f6(a = x3, b = function(_x) { a; return x3; }) {\n            var x3 = 2;\n            return b;\n        }\n        assert.areEqual(1, f6()(), \"Symbol capture at the param scope is unaffected by other references in the body and param\");\n    }\n  },\n  {\n    name : \"Split scope and arguments symbol\",\n    body : function () {\n        assert.throws(function () { eval(\"function f(a = arguments, b = () => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f1() { function f2(a = arguments, b = () => a) { } }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope inside another function\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = arguments, b = () => a, c = eval('')) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with eval\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = arguments = [1, 2], b = () => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = a = arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list with split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, b = () => { a; arguments}) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list when captured in lambda method\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = (c = arguments) => a) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list when captured in a lambda in split scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, b = () => a, c = () => { return arguments; }) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list in split scope when captured by a lambda method\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 10, b = () => a, c = () => () => arguments) { }\"); }, SyntaxError, \"Use of arguments symbol is not allowed in non-simple parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, arguments = function () { return a; } ) { }\"); }, SyntaxError, \"Use of arguments as a parameter name is not allowed in non-simple parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a, arguments = function () { return a; }}) { }\"); }, SyntaxError, \"Use of arguments as a parameter name is not allowed in destructuring parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a = arguments}, b = function () { return a; } ) { }\"); }, SyntaxError, \"Use of arguments is not allowed in destructuring parameter list in split scope when captured by nested lambda\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments[0]) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = 1, b = () => arguments[0]) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope at any position\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments[0] + b, b = 10) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope at any position\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { var arguments }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even when duplicate definition occurs in the body\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a = () => arguments) { function arguments() { } }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even when duplicate definition occurs in the body\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(arguments, b = () => arguments) { }\"); }, SyntaxError, \"Arguments cannot be captured in the param scope even if it is a formal shadowing the actual arguments\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f({a, arguments}, b = () => a) { }\"); }, SyntaxError, \"Arguments cannot be used as a formal name when one of the formal is captured\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        assert.throws(function () { eval(\"function f(a, {arguments, b = () => arguments}) { }\"); }, SyntaxError, \"Arguments cannot be used as a formal name when one of the formal is captured\", \"Use of 'arguments' in non-simple parameter list is not supported when one of the formals is captured\");\n        \n        function f1(a, b = () => a) {\n            eval(\"\");\n            b = () => { return arguments; };\n            assert.areEqual(1, arguments[0], \"Arguments object receives the first parameter properly\");\n            assert.areEqual(1, b()[0], \"First argument receives the right value passed in\");\n            assert.areEqual(undefined, b()[1], \"Second argument receives the right value passed in\");\n            assert.areEqual(2, arguments.length, \"Arguments should have only two elements in it\");\n        }\n        f1(1, undefined);\n        \n        function f2(a, b = () => { return a; }) {\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            (() => { arguments = [3, 4]; a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f2(1, undefined, 2)(), \"Param scope method properly captures the first parameter\");\n        \n        function f3(a, b = () => { return a; }) {\n            eval(\"\");\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            (() => { arguments = [3, 4]; a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f3(1, undefined, 2)(), \"Param scope method properly captures the first parameter, with eval in the body\");\n        \n        function f4(a, b = function () { a; } ) {\n            var c = 10;\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            eval(\"\");\n        }\n        f4(1);\n        \n        function f5(a, b = function () { a; } ) {\n            var c = 10;\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            eval(\"\");\n        }\n        f5(1);\n        \n        function f6(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n        }\n        f6(1);\n        \n        function f7(a, b = function () { a; } ) {\n            assert.areEqual(5, arguments(), \"Function definition is hoisted\");\n            function arguments() { return 5; }\n        }\n        f7(1);\n        \n        function f8(a, b = function () { a; } ) {\n            assert.areEqual(5, arguments(), \"Function definition is hoisted\");\n            function arguments() { return 5; }\n            eval(\"\");\n        }\n        f8(1);\n        \n        function f9(a, b = function () { a; } ) {\n            assert.areEqual(1, eval(\"a\"), \"Eval should be able to access the first argument properly\");\n            assert.areEqual(1, eval(\"arguments[0]\"), \"Eval should be able to access the first argument properly from arguments object\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual(100, eval(\"arguments\"), \"Updated value of arguments is visible in eval\");\n            assert.areEqual(1, eval(\"a\"), \"First argument remains unchanged after the arguments are updated\");\n        }\n        f9(1);\n        \n        function f10(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n        }\n        f10(1);\n        \n        function f11(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            eval(\"\");\n        }\n        f11(1);\n        \n        function f12(a, b = function () { a; } ) {\n            assert.areEqual(1, arguments[0], \"Arguments symbol properly receives the passed in values\");\n            b = () => arguments;\n            assert.areEqual(1, b()[0], \"Lambda captures the right arguments symbol\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual(100, b(), \"Lambda now gives the updated value\");\n            eval(\"\");\n        }\n        f12(1);\n        \n        function f13(a, b = () => { return a; }) {\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            ((c = arguments = [3, 4]) => { a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f13(1, undefined, 2)(), \"Param scope method properly captures the first parameter\");\n        \n        function f14(a, b = () => { return a; }) {\n            eval(\"\");\n            a = 10;\n            assert.areEqual(1, arguments[0], \"First argument is properly received\");\n            assert.areEqual(2, arguments[2], \"Third argument is properly received\");\n            assert.areEqual(3, arguments.length, \"Only three arguments are passed in\");\n            ((c = arguments = [3, 4]) => { a; })();\n            assert.areEqual(3, arguments[0], \"Arguments symbol is updated with the new value when the lambda is executed\");\n            assert.areEqual(4, arguments[1], \"New array is properly assigned to arguments symbol\");\n            assert.areEqual(2, arguments.length, \"New array has only elements\");\n            \n            return b;\n        }\n        assert.areEqual(1, f14(1, undefined, 2)(), \"Param scope method properly captures the first parameter, with eval in the body\");\n        \n        function f15(a, b = function () { a; }, ...c) {\n            assert.areEqual(1, arguments[0], \"Checking first argument\");\n            assert.areEqual(undefined, arguments[1], \"Checking second argument\");\n            assert.areEqual(2, arguments[2], \"Checking third argument\");\n            assert.areEqual(3, arguments[3], \"Checking fourth argument\");\n            assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n            var arguments = 100;\n            assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n            assert.areEqual([2, 3], c, \"Rest should remain unaffected when arguments is updated\");\n            eval(\"\");\n        }\n        f15(1, undefined, 2, 3);\n        \n        var f16 = function f17(a, b = function () { a; }, ...c) {\n            if (a === 1) {\n                assert.areEqual(1, arguments[0], \"Checking first argument\");\n                assert.areEqual(undefined, arguments[1], \"Checking second argument\");\n                assert.areEqual(2, arguments[2], \"Checking third argument\");\n                assert.areEqual(3, arguments[3], \"Checking fourth argument\");\n                assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n                return f17(undefined, undefined, ...c);\n            } else {\n                assert.areEqual(undefined, arguments[0], \"Checking first argument on the recursive call\");\n                assert.areEqual(undefined, arguments[1], \"Checking second argument on the recursive call\");\n                assert.areEqual(2, arguments[2], \"Checking third argument on the recursive call\");\n                assert.areEqual(3, arguments[3], \"Checking fourth argument on the recursive call\");\n                assert.areEqual([2, 3], c, \"Rest argument should get the trailing parameters properly\");\n                var arguments = 100;\n                assert.areEqual(100, arguments, \"Arguments is updated after the assignment\");\n                assert.areEqual([2, 3], c, \"Rest should remain unaffected when arguments is updated\");\n                return eval(\"c\");\n            }\n        }\n        assert.areEqual([2, 3], f16(1, undefined, 2, 3), \"Rest should remain unaffected when arguments is updated\");\n\n        function f18(a, b = function arguments(c) {\n            if (!c) {\n                return arguments.callee(a, 10, 20);\n            }\n            return arguments;\n        }) {\n            assert.areEqual(10, b()[1], \"Function defined in the param scope can be called recursively\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol is unaffected by the function expression\");\n        }\n        f18(1);\n\n        function f19(a, b = arguments) {\n            var c = function arguments(c) {\n                if (!arguments.length) {\n                    return arguments.callee(a, 10, 20, 30);\n                }\n                return arguments;\n            }\n            assert.areEqual(30, c()[3], \"In the function body the arguments function expression with name is not visible\");\n            assert.areEqual(1, b[0], \"In the param scope arguments symbol referes to the passed in values\");\n        }\n        f19(1, undefined, 2, 3, 4);\n\n        function f20(a, b = function arguments(c) {\n            if (!c) {\n                return arguments.callee(a, 10, 20);\n            }\n            return eval(\"arguments\");\n        }) {\n            assert.areEqual(1, b()[0], \"Function defined in the param scope can be called recursively when eval occurs in its body\");\n            assert.areEqual(1, arguments[0], \"Arguments symbol is unaffected by the function expression\");\n        }\n        f20(1);\n\n        function f21(a, b = arguments) {\n            var c = function arguments(c) {\n                if (!arguments.length) {\n                    return arguments.callee(a, 10, 20, 30);\n                }\n                return arguments;\n            }\n            assert.areEqual(30, c()[3], \"In the function body the arguments function expression with name is not visible when eval is there in the body\");\n            assert.areEqual(3, eval(\"b[3]\"), \"In the param scope arguments symbol referes to the passed in values\");\n        }\n        f21(1, undefined, 2, 3, 4);\n\n        function f22(a, b = () => a) {\n            assert.areEqual(1, arguments[0], \"Function in block causes a var declaration to be hoisted and the initial value should be same as the arguments symbol\");\n            {\n                {\n                    function arguments() {\n                        return 10;\n                    }\n                }\n            }\n            assert.areEqual(1, b(), \"Function defined in the param scope should be able to capture the formal even when arguments in overwritten the body\");\n            assert.areEqual(10, arguments(), \"Hoisted var binding is updated after the block is exected\");\n        }\n        f22(1);\n\n        function f23(a, b = () => a) {\n            function f16() {\n                eval(\"\");\n                this.arguments = 1;\n            }\n\n            a = 10;\n            var obj = new f16();\n            \n            function arguments() {\n                return 10;\n            }\n            assert.areEqual(1, obj.arguments, \"Inner function with eval should add the property named arguments when duplicate arguments definition occurs in the parent body\");\n            assert.areEqual(1, b(), \"Formal captured from the param scope should be constrained to the param scope\");\n        };\n        f23(1);\n    }  \n  },\n  {\n    name: \"Split scope and super call\",\n    body: function () {\n        class c1 {\n            constructor() {\n                return { x : 1 };\n            }\n        };\n\n        class c2 extends c1 {\n            constructor(a = 1, b = () => { assert.areEqual(1, super().x, \"Super is accessible in the param scope\"); return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                return {};\n            }\n        }\n        new c2();\n\n        class c3 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                (() => assert.areEqual(1, super().x, \"Lambda should be able to access the super method properly in the body\"))();\n                a = 10;\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c3();\n\n        class c4 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                assert.areEqual(1, eval(\"super().x\"), \"Eval should be able to access the super property properly\");\n            }\n        }\n        new c4();\n\n        class c5 extends c1 {\n            constructor(a = super().x, b = () => { return a; }) {\n                assert.areEqual(1, a, \"First formal calls the super from the param scope\");\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c5();\n    }\n  },\n  {\n    name: \"Split scope and super property\",\n    body: function () {\n        class c1 {\n            foo () {\n                return 1;\n            }\n        };\n\n        class c2 extends c1 {\n            foo(a = 1, b = () => { assert.areEqual(1, super.foo(), \"Super property access works fine from a lambda defined in the param scope\"); return a; }) {\n                a = 20;\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c2()).foo();\n\n        class c3 extends c1 {\n            foo(a = 1, b = () => { return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(1, super.foo(), \"Super property access works fine from a lambda defined in the body scope\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c3()).foo();\n\n        class c4 extends c1 {\n            foo(a = 1, b = () => { return a; }) {\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n                assert.areEqual(1, eval(\"super.foo()\"), \"Eval should be able to access the super property properly from the body scope\");\n            }\n        }\n        (new c4()).foo();\n\n        class c5 extends c1 {\n            foo(a = super.foo(), b = () => { return a; }) {\n                assert.areEqual(1, a, \"First formal uses the super property from the param scope\");\n                var c = 10;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                a = 20;\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        (new c5()).foo();\n    }\n  },\n  {\n    name: \"Split scope and new.target\",\n    body: function () {\n        class c1 {\n            constructor(newTarget) {\n                assert.isTrue(newTarget == new.target, \"Base class should receive the right value for new.target\"); \n            }\n        };\n\n        class c2 extends c1 {\n            constructor(a = 1, b = () => { assert.isTrue(new.target == c2, \"new.target should have the derived class value in the param scope\"); return a; }) {\n                super(c2);\n                var c = 10;\n                a = 20;\n                (() => assert.areEqual(10, c, \"Allocation of scope slot for super property shouldn't affect the body variables\"))();\n                assert.areEqual(1, b(), \"Function defined in the param scope should capture the formal\");\n            }\n        }\n        new c2();\n\n        class c3 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                super(c3);\n                var c = 10;\n                (() => assert.isTrue(new.target == c3, \"new.target should be the derived class in the body scope when captured by lambda\"))();\n                assert.isTrue(new.target == c3, \"new.target should be the derived class in the body scope\");\n            }\n        }\n        new c3();\n\n        class c4 extends c1 {\n            constructor(a = 1, b = () => { return a; }) {\n                super(c4);\n                assert.isTrue(eval(\"new.target == c4\"), \"new.target should be the derived class inside eval\");\n                assert.isTrue(new.target == c4, \"new.target should be the derived class in the body scope\");\n            }\n        }\n        new c4();\n\n        class c5 extends c1 {\n            constructor(a = new.target, b = () => { return a; }) {\n                super(c5);\n                assert.isTrue(a == c5, \"new.target accessed from the param scope should work fine\");\n            }\n        }\n        new c5();\n    }\n  },\n  { \n    name: \"Split parameter scope and eval\", \n    body: function () { \n        function g() { \n            return 3 * 3; \n        } \n\n        function f1(h = () => eval(\"g()\")) {\n            assert.areEqual(6, g(), \"Right method is called in the body scope\");\n            function g() { \n                return 2 * 3; \n            }\n            return h();\n        }\n        assert.areEqual(9, f1(), \"Paramater scope remains split\");\n\n        function f2(h = () => eval(\"g()\")) {\n            assert.areEqual(6, eval(\"g()\"), \"Right method is called in the body scope\");\n            function g() { \n                return 2 * 3; \n            }\n            return h();\n        }\n        assert.areEqual(9, f2(), \"Paramater scope remains split\");\n    }\n  },\n  {  \n    name: \"Split parameter scope with eval in body\",  \n    body: function () {  \n        function f1(a = 10, b = function () { return a; }) {   \n            assert.areEqual(10, a, \"Initial value of parameter in the body scope should be the same as the one in param scope\");  \n            assert.areEqual(10, eval('a'), \"Initial value of parameter in the body scope in eval should be the same as the one in param scope\");  \n            var a = 20;   \n            assert.areEqual(20, a, \"New assignment in the body scope updates the variable's value in body scope\");  \n            assert.areEqual(20, eval('a'), \"New assignment in the body scope updates the variable's value when evaluated through eval in body scope\");  \n            return b;   \n        }   \n        assert.areEqual(10, f1()(), \"Function defined in the param scope captures the formals from the param scope not body scope with eval\");  \n          \n        function f2(a = 10, b = function () { return a; }) {   \n            assert.areEqual(10, eval('b()'), \"Eval of the function from param scope should return the right value for the formal\");  \n            var a = 20;   \n            assert.areEqual(10, eval('b()'), \"Eval of the function from param scope should return the right value for the formal even after assignment to the corresponding body symbol\");  \n            return b;   \n        }   \n        assert.areEqual(10, f2()(), \"Function defined in the param scope captures the formals from the param scope not body scope with eval\");  \n          \n        function f3(a = 10, b = function () { return a; }) {   \n            assert.areEqual(100, eval('b()'), \"Eval of the function from body scope should return the right value for the formal\");  \n            var a = 20;   \n            function b () { return a * a; }  \n            assert.areEqual(400, eval('b()'), \"Eval of the function from body scope should return the right value after assignment to the corresponding body symbol\");  \n            return b;   \n        }   \n        assert.areEqual(400, f3()(), \"Function defined in the body scope captures the symbol from the body scope with eval\");\n        \n        function f4 (a, b, c = function () { b; }, d = 1) {\n            var e = 10;\n            assert.areEqual(2, arguments[0], \"Unmapped arguments value has the expected value in the body\");\n            (function () {\n                eval('');\n            }());\n        };\n        f4.call(1, 2);\n    }  \n  },\n  {\n    name: \"Split scope and with\",\n    body: function () {\n          function f1(a, b, c = function () { a; }) {\n            with ({}) {\n                var d = function () {\n                    return 10;\n                };\n                assert.areEqual(10, d(), \"With inside a split scope function should work fine\");\n            }\n          }\n          f1();\n          \n          function f2(a, b, c = function () { a; }) {\n            var d = function () {\n                return 10;\n            };\n            with ({}) {\n                assert.areEqual(10, d(), \"With inside a split scope function should be able to access the function definition from the body\");\n            }\n          }\n          f2();\n          \n          function f3(a, b = function () { return 10; }, c = function () { a; }) {\n            with ({}) {\n                assert.areEqual(10, b(), \"With inside a split scope function should be able to access the function definition from the param scope\");\n            }\n          }\n          f3();\n\n          function f4(a, b = function () { return 10; }, c = function () { a; }) {\n            var d = {\n                e : function () { return 10; }\n            };\n            e = function () { return 100; };\n            with (d) {\n                assert.areEqual(10, e(), \"With should use the function definition inside the object not the one from body\");\n            }\n          }\n          f4();\n\n          function f5(a, b = { d : function () { return 10; } }, c = function () { a; }) {\n            var d = { };\n            with (b) {\n                assert.areEqual(10, d(), \"With should use the function definition inside the object from the param scope not the one from body\");\n            }\n          }\n          f5();\n          \n          var v6 = 100\n          function f6(a, b, c = function () { a; }, e = function () { with({}) { assert.areEqual(100, v6, \"With inside param scope should be able to access var from outside\"); } }, f = e()) {\n            var v6 = { };\n          }\n          f6();\n\n          function f7(a, b, c = function () { a; }) {\n            with ({}) {\n                assert.areEqual(100, v6, \"With inside body scope should be able to access var from outside\");\n            }\n          }\n          f7();\n          \n          function f8() {\n            function f9() {\n                return 1;\n            }\n            var v1 = 10;\n            function f10(a = 10, b = function f11() {\n                a;\n                assert.areEqual(10, v1, \"Function in the param scope should be able to access the outside variable\");\n                with ({}) {\n                    assert.areEqual(1, f9(), \"With construct inside a param scoped function should be able to execute functions from outside\");\n                }\n            }) {\n                b();\n            };\n            f10();\n          }\n          f8();\n          f8();\n          \n          function f12() {\n            function f13() {\n                return 1;\n            }\n            var v2 = 100;\n            function f14(a = 10, b = function () {\n                assert.areEqual(10, a, \"Function in the param scope should be able to access the formal from parent\");\n                return function () {\n                    assert.areEqual(10, a, \"Function nested in the param scope should be able to access the formal from the split scoped function\");\n                    assert.areEqual(100, v2, \"Function in the param scope should be able to access the outside variable\");\n                    with ({}) {\n                        assert.areEqual(1, f13(), \"With construct inside a param scoped function should be able to execute functions from outside\");\n                    }\n                };\n            }) {\n                b()();\n            };\n            f14();\n          }\n          f12();\n          f12();\n    }  \n  },\n  { \n    name: \"Basic eval in parameter scope\", \n    body: function () { \n        assert.areEqual(1, \n                        function (a = eval(\"1\")) { return a; }(), \n                        \"Eval with static constant works in parameter scope\"); \n\n        { \n            let b = 2; \n            assert.areEqual(2, \n                            function (a = eval(\"b\")) { return a; }(), \n                            \"Eval with parent var reference works in parameter scope\"); \n        } \n\n        assert.areEqual(1, \n                        function (a, b = eval(\"arguments[0]\")) { return b; }(1), \n                        \"Eval with arguments reference works in parameter scope\"); \n\n        function testSelf(a = eval(\"testSelf(1)\")) { \n            return a; \n        } \n        assert.areEqual(1, testSelf(1), \"Eval with reference to the current function works in parameter scope\"); \n\n        var testSelfExpr = function (a = eval(\"testSelfExpr(1)\")) { \n            return a; \n        } \n        assert.areEqual(1, testSelfExpr(), \"Eval with reference to the current function expression works in parameter scope\"); \n\n        { \n            let a = 1, b = 2, c = 3; \n            function testEvalRef(a = eval(\"a\"), b = eval(\"b\"), c = eval(\"c\")) { \n                return [a, b, c]; \n            } \n            assert.throws(function () { testEvalRef(); }, \n                        ReferenceError, \n                        \"Eval with reference to the current formal throws\", \n                        \"Use before declaration\"); \n\n            function testEvalRef2(x = eval(\"a\"), y = eval(\"b\"), z = eval(\"c\")) { \n                return [x, y, z]; \n            } \n            assert.areEqual([1, 2, 3], testEvalRef2(), \"Eval with references works in parameter scope\"); \n        }\n\n        function f1(a = 10, b = () => eval(\"a\")) {\n            assert.areEqual(10, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f1();\n\n        function f2(a = 10, b = () => eval(\"a\")) {\n            a = 20;\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope even when there is no eval in the body\");\n        }\n        f2();\n\n        function f3(a = 10, b = function () { return eval(\"a\"); }) {\n            a = 20;\n            assert.areEqual(10, b(), \"Eval in the param scope captures the symbol from the param scope even when there is no eval in the body\");\n        }\n        f3();\n\n        function f4(a = 10, b = () => eval(\"a\"), c = a = 30) {\n            assert.areEqual(30, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(30, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f4();\n\n        function f5(a = 10, b = () => eval(\"a\")) {\n            assert.areEqual(30, eval(\"a\"), \"In the body initial value of the symbol should be same as the final value from param scope\");\n            var a = 20;\n            assert.areEqual(20, eval(\"a\"), \"In the body after assignment the symbol value is updated\");\n            assert.areEqual(30, b(), \"Eval in the param scope captures the symbol from the param scope\");\n        }\n        f5(30);\n    } \n  }, \n  { \n    name: \"Eval declarations in parameter scope\", \n    body: function() { \n        // Redeclarations of formals - var \n        assert.throws(function () { return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                        ReferenceError, \n                        \"Redeclaring the current formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n        assert.doesNotThrow(function () { \"use strict\"; return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                            \"Redeclaring the current formal using var inside a strict mode eval does not throw\"); \n        assert.doesNotThrow(function () { \"use strict\"; return function (a = eval(\"var a = 2\"), b = a) { return [a, b]; }() }, \n                            \"Redeclaring the current formal using var inside a strict mode function eval does not throw\"); \n\n        assert.throws(function () { function foo(a = eval(\"var b\"), b, c = b) { return [a, b, c]; } foo(); }, \n                        ReferenceError, \n                        \"Redeclaring a future formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n\n        assert.throws(function () { function foo(a, b = eval(\"var a\"), c = a) { return [a, b, c]; } foo(); }, \n                        ReferenceError, \n                        \"Redeclaring a previous formal using var inside an eval throws\", \n                        \"Let/Const redeclaration\"); \n\n        // Let and const do not leak outside of an eval, so the test cases below should never throw. \n        // Redeclarations of formals - let \n        assert.doesNotThrow(function (a = eval(\"let a\")) { return a; }, \n                            \"Attempting to redeclare the current formal using let inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a = eval(\"let b\"), b) { return [a, b]; }, \n                            \"Attempting to redeclare a future formal using let inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a, b = eval(\"let a\")) { return [a, b]; }, \n                            \"Attempting to redeclare a previous formal using let inside an eval does not leak\"); \n\n        // Redeclarations of formals - const \n        assert.doesNotThrow(function (a = eval(\"const a = 1\")) { return a; }, \n                            \"Attempting to redeclare the current formal using const inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a = eval(\"const b = 1\"), b) { return [a, b]; }, \n                            \"Attempting to redeclare a future formal using const inside an eval does not leak\"); \n\n        assert.doesNotThrow(function (a, b = eval(\"const a = 1\")) { return [a, b]; }, \n                            \"Attempting to redeclare a previous formal using const inside an eval does not leak\"); \n\n        // Conditional declarations \n        function test(x = eval(\"var a1 = 1; let b1 = 2; const c1 = 3;\")) { \n            // none should be visible \n            assert.throws(function () { a1 }, ReferenceError, \"Ignoring the default value does not result in an eval declaration leaking\", \"'a1' is undefined\"); \n            assert.throws(function () { b1 }, ReferenceError, \"Let declarations do not leak out of eval to parameter scope\",   \"'b1' is undefined\"); \n            assert.throws(function () { c1 }, ReferenceError, \"Const declarations do not leak out of eval to parameter scope when x is \", \"'c1' is undefined\"); \n        } \n        test(); \n\n        // Redefining locals \n        function foo(a = eval(\"var x = 1; assert.areEqual(1, x, 'Variable declared inside eval is accessible within eval');\")) { \n            assert.areEqual(undefined, x, \"Var declaration from eval is not visible in the body\"); \n            var x = 10; \n            assert.areEqual(10, x, \"Var declaration from eval uses its new value in the body declaration\"); \n        } \n        assert.doesNotThrow(function() { foo(); }, \"Redefining a local var with an eval var does not throw\"); \n\n        // Function bodies defined in eval\n        function funcArrow(a = eval(\"() => 1\"), b = a) { function a() { return 10; }; return [a(), b()]; }\n        assert.areEqual([10,1], funcArrow(), \"Defining an arrow function body inside an eval works at default parameter scope\");\n\n        function funcDecl(a = eval(\"(function foo() { return 1; })\"), b = a()) { return [a(), b]; }\n        assert.areEqual([1, 1], funcDecl(), \"Defining a function inside an eval works at default parameter scope\");\n\n        function funcDecl(a = eval(\"function foo() { return 1; }; foo\"), b = a()) { return [a(), b]; }\n        assert.areEqual([1, 1], funcDecl(), \"Defining a function inside an eval works at default parameter scope\");\n\n        function genFuncDecl(a = eval(\"(function *foo() { yield 1; return 2; })\"), b = a(), c = b.next()) { return [c, b.next()]; }\n        assert.areEqual([{value : 1, done : false}, {value : 2, done : true}], genFuncDecl(), \"Declaring a generator function inside an eval works at default parameter scope\");\n\n        function funcExpr(a = eval(\"f = function foo() { return 1; }\"), b = f()) { return [a(), b, f()]; }\n        assert.areEqual([1, 1, 1], funcExpr(), \"Declaring a function inside an eval works at default parameter scope\");\n\n        assert.throws(function () { eval(\"function foo(a = eval('b'), b) {}; foo();\"); }, ReferenceError, \"Future default references using eval are not allowed\", \"Use before declaration\");\n    } \n  }, \n]; \n\n\ntestRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" }); \n"], "filenames": ["lib/Parser/Parse.cpp", "lib/Runtime/ByteCode/ByteCodeEmitter.cpp", "test/es6/default-splitscope.js"], "buggy_code_start_loc": [5200, 3321, 161], "buggy_code_end_loc": [5200, 3331, 161], "fixing_code_start_loc": [5201, 3322, 162], "fixing_code_end_loc": [5214, 3334, 178], "type": "CWE-119", "message": "A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka \"Scripting Engine Memory Corruption Vulnerability.\"", "other": {"cve": {"id": "CVE-2017-0152", "sourceIdentifier": "secure@microsoft.com", "published": "2017-07-17T13:18:11.250", "lastModified": "2017-07-21T16:27:14.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka \"Scripting Engine Memory Corruption Vulnerability.\""}, {"lang": "es", "value": "Se presenta una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo remota en la manera en que el motor de scripting de Microsoft afectado renderiza durante el manejo de objetos en memoria en los navegadores de Microsoft. La vulnerabilidad podr\u00eda corromper la memoria de tal manera que un atacante podr\u00eda ejecutar c\u00f3digo arbitrario en el contexto del usuario actual. Un atacante que exploto con \u00e9xito la vulnerabilidad podr\u00eda obtener los mismos derechos de usuario que el usuario actual, tambi\u00e9n se conoce como \"Scripting Engine Memory Corruption Vulnerability."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge:*:*:*:*:*:*:*:*", "matchCriteriaId": "8BD5B232-95EA-4F8E-8C7D-7976877AD243"}]}]}], "references": [{"url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517", "source": "secure@microsoft.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517"}}