{"buggy_code": ["function zsh_stats() {\n  fc -l 1 \\\n    | awk '{ CMD[$2]++; count++; } END { for (a in CMD) print CMD[a] \" \" CMD[a]*100/count \"% \" a }' \\\n    | grep -v \"./\" | sort -nr | head -n 20 | column -c3 -s \" \" -t | nl\n}\n\nfunction uninstall_oh_my_zsh() {\n  env ZSH=\"$ZSH\" sh \"$ZSH/tools/uninstall.sh\"\n}\n\nfunction upgrade_oh_my_zsh() {\n  echo >&2 \"${fg[yellow]}Note: \\`$0\\` is deprecated. Use \\`omz update\\` instead.$reset_color\"\n  omz update\n}\n\nfunction open_command() {\n  local open_cmd\n\n  # define the open command\n  case \"$OSTYPE\" in\n    darwin*)  open_cmd='open' ;;\n    cygwin*)  open_cmd='cygstart' ;;\n    linux*)   [[ \"$(uname -r)\" != *icrosoft* ]] && open_cmd='nohup xdg-open' || {\n                open_cmd='cmd.exe /c start \"\"'\n                [[ -e \"$1\" ]] && { 1=\"$(wslpath -w \"${1:a}\")\" || return 1 }\n              } ;;\n    msys*)    open_cmd='start \"\"' ;;\n    *)        echo \"Platform $OSTYPE not supported\"\n              return 1\n              ;;\n  esac\n\n  ${=open_cmd} \"$@\" &>/dev/null\n}\n\n# take functions\n\n# mkcd is equivalent to takedir\nfunction mkcd takedir() {\n  mkdir -p $@ && cd ${@:$#}\n}\n\nfunction takeurl() {\n  local data thedir\n  data=\"$(mktemp)\"\n  curl -L \"$1\" > \"$data\"\n  tar xf \"$data\"\n  thedir=\"$(tar tf \"$data\" | head -n 1)\"\n  rm \"$data\"\n  cd \"$thedir\"\n}\n\nfunction takegit() {\n  git clone \"$1\"\n  cd \"$(basename ${1%%.git})\"\n}\n\nfunction take() {\n  if [[ $1 =~ ^(https?|ftp).*\\.tar\\.(gz|bz2|xz)$ ]]; then\n    takeurl \"$1\"\n  elif [[ $1 =~ ^([A-Za-z0-9]\\+@|https?|git|ssh|ftps?|rsync).*\\.git/?$ ]]; then\n    takegit \"$1\"\n  else\n    takedir \"$@\"\n  fi\n}\n\n#\n# Get the value of an alias.\n#\n# Arguments:\n#    1. alias - The alias to get its value from\n# STDOUT:\n#    The value of alias $1 (if it has one).\n# Return value:\n#    0 if the alias was found,\n#    1 if it does not exist\n#\nfunction alias_value() {\n    (( $+aliases[$1] )) && echo $aliases[$1]\n}\n\n#\n# Try to get the value of an alias,\n# otherwise return the input.\n#\n# Arguments:\n#    1. alias - The alias to get its value from\n# STDOUT:\n#    The value of alias $1, or $1 if there is no alias $1.\n# Return value:\n#    Always 0\n#\nfunction try_alias_value() {\n    alias_value \"$1\" || echo \"$1\"\n}\n\n#\n# Set variable \"$1\" to default value \"$2\" if \"$1\" is not yet defined.\n#\n# Arguments:\n#    1. name - The variable to set\n#    2. val  - The default value\n# Return value:\n#    0 if the variable exists, 3 if it was set\n#\nfunction default() {\n    (( $+parameters[$1] )) && return 0\n    typeset -g \"$1\"=\"$2\"   && return 3\n}\n\n#\n# Set environment variable \"$1\" to default value \"$2\" if \"$1\" is not yet defined.\n#\n# Arguments:\n#    1. name - The env variable to set\n#    2. val  - The default value\n# Return value:\n#    0 if the env variable exists, 3 if it was set\n#\nfunction env_default() {\n    [[ ${parameters[$1]} = *-export* ]] && return 0\n    export \"$1=$2\" && return 3\n}\n\n\n# Required for $langinfo\nzmodload zsh/langinfo\n\n# URL-encode a string\n#\n# Encodes a string using RFC 2396 URL-encoding (%-escaped).\n# See: https://www.ietf.org/rfc/rfc2396.txt\n#\n# By default, reserved characters and unreserved \"mark\" characters are\n# not escaped by this function. This allows the common usage of passing\n# an entire URL in, and encoding just special characters in it, with\n# the expectation that reserved and mark characters are used appropriately.\n# The -r and -m options turn on escaping of the reserved and mark characters,\n# respectively, which allows arbitrary strings to be fully escaped for\n# embedding inside URLs, where reserved characters might be misinterpreted.\n#\n# Prints the encoded string on stdout.\n# Returns nonzero if encoding failed.\n#\n# Usage:\n#  omz_urlencode [-r] [-m] [-P] <string>\n#\n#    -r causes reserved characters (;/?:@&=+$,) to be escaped\n#\n#    -m causes \"mark\" characters (_.!~*''()-) to be escaped\n#\n#    -P causes spaces to be encoded as '%20' instead of '+'\nfunction omz_urlencode() {\n  emulate -L zsh\n  local -a opts\n  zparseopts -D -E -a opts r m P\n\n  local in_str=$1\n  local url_str=\"\"\n  local spaces_as_plus\n  if [[ -z $opts[(r)-P] ]]; then spaces_as_plus=1; fi\n  local str=\"$in_str\"\n\n  # URLs must use UTF-8 encoding; convert str to UTF-8 if required\n  local encoding=$langinfo[CODESET]\n  local safe_encodings\n  safe_encodings=(UTF-8 utf8 US-ASCII)\n  if [[ -z ${safe_encodings[(r)$encoding]} ]]; then\n    str=$(echo -E \"$str\" | iconv -f $encoding -t UTF-8)\n    if [[ $? != 0 ]]; then\n      echo \"Error converting string from $encoding to UTF-8\" >&2\n      return 1\n    fi\n  fi\n\n  # Use LC_CTYPE=C to process text byte-by-byte\n  local i byte ord LC_ALL=C\n  export LC_ALL\n  local reserved=';/?:@&=+$,'\n  local mark='_.!~*''()-'\n  local dont_escape=\"[A-Za-z0-9\"\n  if [[ -z $opts[(r)-r] ]]; then\n    dont_escape+=$reserved\n  fi\n  # $mark must be last because of the \"-\"\n  if [[ -z $opts[(r)-m] ]]; then\n    dont_escape+=$mark\n  fi\n  dont_escape+=\"]\"\n\n  # Implemented to use a single printf call and avoid subshells in the loop,\n  # for performance (primarily on Windows).\n  local url_str=\"\"\n  for (( i = 1; i <= ${#str}; ++i )); do\n    byte=\"$str[i]\"\n    if [[ \"$byte\" =~ \"$dont_escape\" ]]; then\n      url_str+=\"$byte\"\n    else\n      if [[ \"$byte\" == \" \" && -n $spaces_as_plus ]]; then\n        url_str+=\"+\"\n      else\n        ord=$(( [##16] #byte ))\n        url_str+=\"%$ord\"\n      fi\n    fi\n  done\n  echo -E \"$url_str\"\n}\n\n# URL-decode a string\n#\n# Decodes a RFC 2396 URL-encoded (%-escaped) string.\n# This decodes the '+' and '%' escapes in the input string, and leaves\n# other characters unchanged. Does not enforce that the input is a\n# valid URL-encoded string. This is a convenience to allow callers to\n# pass in a full URL or similar strings and decode them for human\n# presentation.\n#\n# Outputs the encoded string on stdout.\n# Returns nonzero if encoding failed.\n#\n# Usage:\n#   omz_urldecode <urlstring>  - prints decoded string followed by a newline\nfunction omz_urldecode {\n  emulate -L zsh\n  local encoded_url=$1\n\n  # Work bytewise, since URLs escape UTF-8 octets\n  local caller_encoding=$langinfo[CODESET]\n  local LC_ALL=C\n  export LC_ALL\n\n  # Change + back to ' '\n  local tmp=${encoded_url:gs/+/ /}\n  # Protect other escapes to pass through the printf unchanged\n  tmp=${tmp:gs/\\\\/\\\\\\\\/}\n  # Handle %-escapes by turning them into `\\xXX` printf escapes\n  tmp=${tmp:gs/%/\\\\x/}\n  local decoded\n  eval \"decoded=\\$'$tmp'\"\n\n  # Now we have a UTF-8 encoded string in the variable. We need to re-encode\n  # it if caller is in a non-UTF-8 locale.\n  local safe_encodings\n  safe_encodings=(UTF-8 utf8 US-ASCII)\n  if [[ -z ${safe_encodings[(r)$caller_encoding]} ]]; then\n    decoded=$(echo -E \"$decoded\" | iconv -f UTF-8 -t $caller_encoding)\n    if [[ $? != 0 ]]; then\n      echo \"Error converting string from UTF-8 to $caller_encoding\" >&2\n      return 1\n    fi\n  fi\n\n  echo -E \"$decoded\"\n}\n"], "fixing_code": ["function zsh_stats() {\n  fc -l 1 \\\n    | awk '{ CMD[$2]++; count++; } END { for (a in CMD) print CMD[a] \" \" CMD[a]*100/count \"% \" a }' \\\n    | grep -v \"./\" | sort -nr | head -n 20 | column -c3 -s \" \" -t | nl\n}\n\nfunction uninstall_oh_my_zsh() {\n  env ZSH=\"$ZSH\" sh \"$ZSH/tools/uninstall.sh\"\n}\n\nfunction upgrade_oh_my_zsh() {\n  echo >&2 \"${fg[yellow]}Note: \\`$0\\` is deprecated. Use \\`omz update\\` instead.$reset_color\"\n  omz update\n}\n\nfunction open_command() {\n  local open_cmd\n\n  # define the open command\n  case \"$OSTYPE\" in\n    darwin*)  open_cmd='open' ;;\n    cygwin*)  open_cmd='cygstart' ;;\n    linux*)   [[ \"$(uname -r)\" != *icrosoft* ]] && open_cmd='nohup xdg-open' || {\n                open_cmd='cmd.exe /c start \"\"'\n                [[ -e \"$1\" ]] && { 1=\"$(wslpath -w \"${1:a}\")\" || return 1 }\n              } ;;\n    msys*)    open_cmd='start \"\"' ;;\n    *)        echo \"Platform $OSTYPE not supported\"\n              return 1\n              ;;\n  esac\n\n  ${=open_cmd} \"$@\" &>/dev/null\n}\n\n# take functions\n\n# mkcd is equivalent to takedir\nfunction mkcd takedir() {\n  mkdir -p $@ && cd ${@:$#}\n}\n\nfunction takeurl() {\n  local data thedir\n  data=\"$(mktemp)\"\n  curl -L \"$1\" > \"$data\"\n  tar xf \"$data\"\n  thedir=\"$(tar tf \"$data\" | head -n 1)\"\n  rm \"$data\"\n  cd \"$thedir\"\n}\n\nfunction takegit() {\n  git clone \"$1\"\n  cd \"$(basename ${1%%.git})\"\n}\n\nfunction take() {\n  if [[ $1 =~ ^(https?|ftp).*\\.tar\\.(gz|bz2|xz)$ ]]; then\n    takeurl \"$1\"\n  elif [[ $1 =~ ^([A-Za-z0-9]\\+@|https?|git|ssh|ftps?|rsync).*\\.git/?$ ]]; then\n    takegit \"$1\"\n  else\n    takedir \"$@\"\n  fi\n}\n\n#\n# Get the value of an alias.\n#\n# Arguments:\n#    1. alias - The alias to get its value from\n# STDOUT:\n#    The value of alias $1 (if it has one).\n# Return value:\n#    0 if the alias was found,\n#    1 if it does not exist\n#\nfunction alias_value() {\n    (( $+aliases[$1] )) && echo $aliases[$1]\n}\n\n#\n# Try to get the value of an alias,\n# otherwise return the input.\n#\n# Arguments:\n#    1. alias - The alias to get its value from\n# STDOUT:\n#    The value of alias $1, or $1 if there is no alias $1.\n# Return value:\n#    Always 0\n#\nfunction try_alias_value() {\n    alias_value \"$1\" || echo \"$1\"\n}\n\n#\n# Set variable \"$1\" to default value \"$2\" if \"$1\" is not yet defined.\n#\n# Arguments:\n#    1. name - The variable to set\n#    2. val  - The default value\n# Return value:\n#    0 if the variable exists, 3 if it was set\n#\nfunction default() {\n    (( $+parameters[$1] )) && return 0\n    typeset -g \"$1\"=\"$2\"   && return 3\n}\n\n#\n# Set environment variable \"$1\" to default value \"$2\" if \"$1\" is not yet defined.\n#\n# Arguments:\n#    1. name - The env variable to set\n#    2. val  - The default value\n# Return value:\n#    0 if the env variable exists, 3 if it was set\n#\nfunction env_default() {\n    [[ ${parameters[$1]} = *-export* ]] && return 0\n    export \"$1=$2\" && return 3\n}\n\n\n# Required for $langinfo\nzmodload zsh/langinfo\n\n# URL-encode a string\n#\n# Encodes a string using RFC 2396 URL-encoding (%-escaped).\n# See: https://www.ietf.org/rfc/rfc2396.txt\n#\n# By default, reserved characters and unreserved \"mark\" characters are\n# not escaped by this function. This allows the common usage of passing\n# an entire URL in, and encoding just special characters in it, with\n# the expectation that reserved and mark characters are used appropriately.\n# The -r and -m options turn on escaping of the reserved and mark characters,\n# respectively, which allows arbitrary strings to be fully escaped for\n# embedding inside URLs, where reserved characters might be misinterpreted.\n#\n# Prints the encoded string on stdout.\n# Returns nonzero if encoding failed.\n#\n# Usage:\n#  omz_urlencode [-r] [-m] [-P] <string>\n#\n#    -r causes reserved characters (;/?:@&=+$,) to be escaped\n#\n#    -m causes \"mark\" characters (_.!~*''()-) to be escaped\n#\n#    -P causes spaces to be encoded as '%20' instead of '+'\nfunction omz_urlencode() {\n  emulate -L zsh\n  local -a opts\n  zparseopts -D -E -a opts r m P\n\n  local in_str=$1\n  local url_str=\"\"\n  local spaces_as_plus\n  if [[ -z $opts[(r)-P] ]]; then spaces_as_plus=1; fi\n  local str=\"$in_str\"\n\n  # URLs must use UTF-8 encoding; convert str to UTF-8 if required\n  local encoding=$langinfo[CODESET]\n  local safe_encodings\n  safe_encodings=(UTF-8 utf8 US-ASCII)\n  if [[ -z ${safe_encodings[(r)$encoding]} ]]; then\n    str=$(echo -E \"$str\" | iconv -f $encoding -t UTF-8)\n    if [[ $? != 0 ]]; then\n      echo \"Error converting string from $encoding to UTF-8\" >&2\n      return 1\n    fi\n  fi\n\n  # Use LC_CTYPE=C to process text byte-by-byte\n  local i byte ord LC_ALL=C\n  export LC_ALL\n  local reserved=';/?:@&=+$,'\n  local mark='_.!~*''()-'\n  local dont_escape=\"[A-Za-z0-9\"\n  if [[ -z $opts[(r)-r] ]]; then\n    dont_escape+=$reserved\n  fi\n  # $mark must be last because of the \"-\"\n  if [[ -z $opts[(r)-m] ]]; then\n    dont_escape+=$mark\n  fi\n  dont_escape+=\"]\"\n\n  # Implemented to use a single printf call and avoid subshells in the loop,\n  # for performance (primarily on Windows).\n  local url_str=\"\"\n  for (( i = 1; i <= ${#str}; ++i )); do\n    byte=\"$str[i]\"\n    if [[ \"$byte\" =~ \"$dont_escape\" ]]; then\n      url_str+=\"$byte\"\n    else\n      if [[ \"$byte\" == \" \" && -n $spaces_as_plus ]]; then\n        url_str+=\"+\"\n      else\n        ord=$(( [##16] #byte ))\n        url_str+=\"%$ord\"\n      fi\n    fi\n  done\n  echo -E \"$url_str\"\n}\n\n# URL-decode a string\n#\n# Decodes a RFC 2396 URL-encoded (%-escaped) string.\n# This decodes the '+' and '%' escapes in the input string, and leaves\n# other characters unchanged. Does not enforce that the input is a\n# valid URL-encoded string. This is a convenience to allow callers to\n# pass in a full URL or similar strings and decode them for human\n# presentation.\n#\n# Outputs the encoded string on stdout.\n# Returns nonzero if encoding failed.\n#\n# Usage:\n#   omz_urldecode <urlstring>  - prints decoded string followed by a newline\nfunction omz_urldecode {\n  emulate -L zsh\n  local encoded_url=$1\n\n  # Work bytewise, since URLs escape UTF-8 octets\n  local caller_encoding=$langinfo[CODESET]\n  local LC_ALL=C\n  export LC_ALL\n\n  # Change + back to ' '\n  local tmp=${encoded_url:gs/+/ /}\n  # Protect other escapes to pass through the printf unchanged\n  tmp=${tmp:gs/\\\\/\\\\\\\\/}\n  # Handle %-escapes by turning them into `\\xXX` printf escapes\n  tmp=${tmp:gs/%/\\\\x/}\n  local decoded=\"$(printf -- \"$tmp\")\"\n\n  # Now we have a UTF-8 encoded string in the variable. We need to re-encode\n  # it if caller is in a non-UTF-8 locale.\n  local -a safe_encodings\n  safe_encodings=(UTF-8 utf8 US-ASCII)\n  if [[ -z ${safe_encodings[(r)$caller_encoding]} ]]; then\n    decoded=$(echo -E \"$decoded\" | iconv -f UTF-8 -t $caller_encoding)\n    if [[ $? != 0 ]]; then\n      echo \"Error converting string from UTF-8 to $caller_encoding\" >&2\n      return 1\n    fi\n  fi\n\n  echo -E \"$decoded\"\n}\n"], "filenames": ["lib/functions.zsh"], "buggy_code_start_loc": [240], "buggy_code_end_loc": [246], "fixing_code_start_loc": [240], "fixing_code_end_loc": [245], "type": "CWE-78", "message": "ohmyzsh is vulnerable to Improper Neutralization of Special Elements used in an OS Command", "other": {"cve": {"id": "CVE-2021-3934", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-12T12:15:07.460", "lastModified": "2021-12-08T21:52:12.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ohmyzsh is vulnerable to Improper Neutralization of Special Elements used in an OS Command"}, {"lang": "es", "value": "ohmyzsh es vulnerable a una Neutralizaci\u00f3n Inapropiada de Elementos Especiales usados en un Comando del Sistema Operativo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:planetargon:oh_my_zsh:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-11-11", "matchCriteriaId": "80FD5E81-3E73-4921-925C-E55098EAE4B1"}]}]}], "references": [{"url": "https://github.com/ohmyzsh/ohmyzsh/commit/6cb41b70a6d04301fd50cd5862ecd705ba226c0e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ad2b5c3f-a3ce-4407-94dc-354c723310ce", "source": "security@huntr.dev", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/ohmyzsh/ohmyzsh/commit/6cb41b70a6d04301fd50cd5862ecd705ba226c0e"}}