{"buggy_code": ["import re\n\nfrom flask import (Response, current_app, request, redirect as flask_redirect,\n                   url_for as flask_url_for)\nfrom flask_unchained.string_utils import kebab_case, right_replace, snake_case\nfrom flask_unchained._compat import is_local_proxy\nfrom py_meta_utils import _missing\nfrom typing import *\nfrom urllib.parse import urlsplit, quote as urlquote\nfrom werkzeug.routing import BuildError, UnicodeConverter\n\nfrom .attr_constants import CONTROLLER_ROUTES_ATTR, REMOVE_SUFFIXES_ATTR\n\n\nPARAM_NAME_RE = re.compile(r'<(\\w+:)?(?P<param_name>\\w+)>')\n\n\nclass StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)\n\n\ndef controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)\n\n\ndef get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]\n\n\ndef url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)\n\n\ndef join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'\n\n\ndef method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')\n\n\ndef encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=\")\n\n\n# modified from flask_security.utils.get_post_action_redirect\ndef redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')\n\n\ndef rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)\n\n\ndef _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default\n\n\ndef _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'\n\n\n# modified from flask_security.utils.validate_redirect_url\ndef _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True\n\n\n__all__ = [\n    'controller_name',\n    'get_param_tuples',\n    'join',\n    'method_name_to_url',\n    'redirect',\n    'rename_parent_resource_param_name',\n    'url_for',\n]\n", "alembic==1.5.8\napispec==4.4.1\napispec_webframeworks==0.5.2\nbcrypt==3.2.0\nbeautifulsoup4==4.9.3\nblinker==1.4\ncelery==4.4.7\nclick==7.1.2\ndill==0.3.3\nemail-validator==1.1.2\nflask==1.1.2\nflask-admin==1.5.8\nflask_babelex==0.9.4\nflask-graphql==2.0.1\nflask-login==0.5.0\nflask-marshmallow==0.14.0\nflask_migrate==2.7.0\nflask-oauthlib==0.9.5\nflask-principal==0.4.0\nflask-session==0.3.2\nflask-sqlalchemy-unchained==0.7.4\nflask_wtf==0.14.3\ngraphene==2.1.8\ngraphene-sqlalchemy==2.3.0\ngraphql-core>=2.3.2,<3\ngraphql-relay>=2.0.1,<3\ngraphql-server-core>=1.2.0,<2\nIPython==7.16.1\nitsdangerous==1.1.0\njedi==0.17.2\njinja2==2.11.3\nlxml==4.6.3\nmarkupsafe==1.1.1\nmarshmallow==3.12.1\nmarshmallow-sqlalchemy==0.25\nnetworkx==2.5.1\npasslib==1.7.4\npy-meta-utils==0.7.8\npy-yaml-fixtures==0.6.1\npyterminalsize\npyqt5==5.15.4\nspeaklater==1.3\nsqlalchemy==1.3.24\nsqlalchemy-unchained==0.11.0\nqtconsole==4.7.7\nwerkzeug==1.0.1\nwtforms==2.3.3\nwtforms_sqlalchemy==0.2\n", "import pytest\n\nfrom werkzeug.routing import BuildError\n\nfrom flask_unchained.bundles.controller import Controller, Resource\nfrom flask_unchained.bundles.controller.utils import (\n    controller_name, get_param_tuples, join,\n    method_name_to_url, url_for, _validate_redirect_url)\nfrom py_meta_utils import deep_getattr\n\n\ndef test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'\n\n\nclass TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'\n\n\nclass TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]\n\n\nclass TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)\n\n\nclass TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'\n\n\nclass TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'\n\n\nclass TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='works.com')\n            assert result is True\n            monkeypatch.undo()\n"], "fixing_code": ["import re\n\nfrom flask import (Response, current_app, request, redirect as flask_redirect,\n                   url_for as flask_url_for)\nfrom flask_unchained.string_utils import kebab_case, right_replace, snake_case\nfrom flask_unchained._compat import is_local_proxy\nfrom py_meta_utils import _missing\nfrom typing import *\nfrom urllib.parse import urlsplit, quote as urlquote\nfrom werkzeug.routing import BuildError, UnicodeConverter\n\nfrom .attr_constants import CONTROLLER_ROUTES_ATTR, REMOVE_SUFFIXES_ATTR\n\n\nPARAM_NAME_RE = re.compile(r'<(\\w+:)?(?P<param_name>\\w+)>')\n\n\nclass StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)\n\n\ndef controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)\n\n\ndef get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]\n\n\ndef url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)\n\n\ndef join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'\n\n\ndef method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')\n\n\ndef encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=<>\")\n\n\n# modified from flask_security.utils.get_post_action_redirect\ndef redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')\n\n\ndef rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)\n\n\ndef _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default\n\n\ndef _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'\n\n\n# modified from flask_security.utils.validate_redirect_url\ndef _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True\n\n\n__all__ = [\n    'controller_name',\n    'get_param_tuples',\n    'join',\n    'method_name_to_url',\n    'redirect',\n    'rename_parent_resource_param_name',\n    'url_for',\n]\n", "alembic==1.5.8\napispec==4.4.1\napispec_webframeworks==0.5.2\nbcrypt==3.2.0\nbeautifulsoup4==4.9.3\nblinker==1.4\ncelery==4.4.7\nclick==7.1.2\ndill==0.3.3\nemail-validator==1.1.2\nflask==1.1.2\nflask-admin==1.5.8\nflask_babelex==0.9.4\nflask-graphql==2.0.1\nflask-login==0.5.0\nflask-marshmallow==0.14.0\nflask_migrate==2.7.0\nflask-oauthlib==0.9.5\nflask-principal==0.4.0\nflask-session==0.3.2\nflask-sqlalchemy==2.5.1\nflask-sqlalchemy-unchained==0.7.4\nflask_wtf==0.14.3\ngraphene==2.1.8\ngraphene-sqlalchemy==2.3.0\ngraphql-core>=2.3.2,<3\ngraphql-relay>=2.0.1,<3\ngraphql-server-core>=1.2.0,<2\nIPython==7.16.1\nitsdangerous==1.1.0\njedi==0.17.2\njinja2==2.11.3\nlxml==4.6.3\nmarkupsafe==1.1.1\nmarshmallow==3.12.1\nmarshmallow-sqlalchemy==0.25\nnetworkx==2.5.1\npasslib==1.7.4\npy-meta-utils==0.7.8\npy-yaml-fixtures==0.6.1\npyterminalsize\npyqt5==5.15.4\nspeaklater==1.3\nsqlalchemy==1.3.24\nsqlalchemy-unchained==0.11.0\nqtconsole==4.7.7\nwerkzeug==1.0.1\nwtforms==2.3.3\nwtforms_sqlalchemy==0.2\n", "import pytest\n\nfrom werkzeug.routing import BuildError\n\nfrom flask_unchained.bundles.controller import Controller, Resource\nfrom flask_unchained.bundles.controller.utils import (\n    controller_name, get_param_tuples, join,\n    method_name_to_url, url_for, _validate_redirect_url)\nfrom py_meta_utils import deep_getattr\n\n\ndef test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'\n\n\nclass TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'\n\n\nclass TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]\n\n\nclass TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)\n\n\nclass TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'\n\n\nclass TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'\n\n\nclass TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n        assert _validate_redirect_url('///evil.com') is False\n        assert _validate_redirect_url('\\\\\\\\\\\\evil.com') is False\n        assert _validate_redirect_url('\\x00evil.com') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    def test_it_requires_same_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'https://example.com')\n            assert _validate_redirect_url('http://example.com/foo') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='http://works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='https://works.com')\n    def test_it_requires_same_external_server_name_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is False\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='http://works.com')\n            assert result is True\n            monkeypatch.undo()\n"], "filenames": ["flask_unchained/bundles/controller/utils.py", "requirements.txt", "tests/bundles/controller/test_utils.py"], "buggy_code_start_loc": [188, 20, 192], "buggy_code_end_loc": [189, 20, 212], "fixing_code_start_loc": [188, 21, 193], "fixing_code_end_loc": [189, 22, 228], "type": "CWE-601", "message": "This affects the package Flask-Unchained before 0.9.0. When using the the _validate_redirect_url function, it is possible to bypass URL validation and redirect a user to an arbitrary URL by providing multiple back slashes such as \\\\\\evil.com/path. This vulnerability is only exploitable if an alternative WSGI server other than Werkzeug is used, or the default behaviour of Werkzeug is modified using 'autocorrect_location_header=False.", "other": {"cve": {"id": "CVE-2021-23393", "sourceIdentifier": "report@snyk.io", "published": "2021-06-11T00:15:09.273", "lastModified": "2021-06-22T16:53:53.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package Flask-Unchained before 0.9.0. When using the the _validate_redirect_url function, it is possible to bypass URL validation and redirect a user to an arbitrary URL by providing multiple back slashes such as \\\\\\evil.com/path. This vulnerability is only exploitable if an alternative WSGI server other than Werkzeug is used, or the default behaviour of Werkzeug is modified using 'autocorrect_location_header=False."}, {"lang": "es", "value": "Esto afecta al paquete Flask-Unchained versiones anteriores a 0.9.0. Cuando se usa la funci\u00f3n _validate_redirect_url, es posible omitir la comprobaci\u00f3n de la URL y redireccionar a un usuario a una URL arbitraria proporcionando m\u00faltiples barras invertidas, como por ejemplo \\\\\\evil.com/path. Esta vulnerabilidad s\u00f3lo es explotable si un servidor WSGI alternativo a Werkzeug es usado, o se modifica el comportamiento por defecto de Werkzeug usando \"autocorrect_location_header=False"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flask_unchained_project:flask_unchained:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "4491B634-FD96-4E0C-9584-EB97EBC710F1"}]}]}], "references": [{"url": "https://github.com/briancappello/flask-unchained/commit/71e36b28166f9ffbe0a991f51127f0984f7e6a40", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-PYTHON-FLASKUNCHAINED-1293189", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/briancappello/flask-unchained/commit/71e36b28166f9ffbe0a991f51127f0984f7e6a40"}}