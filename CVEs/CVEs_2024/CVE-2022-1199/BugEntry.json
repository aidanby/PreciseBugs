{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n * Copyright (C) Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Darryl Miles G7LED (dlm@g7led.demon.co.uk)\n * Copyright (C) Steven Whitehouse GW7RRM (stevew@acm.org)\n * Copyright (C) Joerg Reuter DL1BKE (jreuter@yaina.de)\n * Copyright (C) Hans-Joachim Hetscher DD8NE (dd8ne@bnv-bamberg.de)\n * Copyright (C) Hans Alblas PE1AYX (hans@esrac.ele.tue.nl)\n * Copyright (C) Frederic Rible F1OAT (frible@teaser.fr)\n */\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <net/net_namespace.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\n\n\nHLIST_HEAD(ax25_list);\nDEFINE_SPINLOCK(ax25_list_lock);\n\nstatic const struct proto_ops ax25_proto_ops;\n\nstatic void ax25_free_sock(struct sock *sk)\n{\n\tax25_cb_put(sk_to_ax25(sk));\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void ax25_cb_del(ax25_cb *ax25)\n{\n\tif (!hlist_unhashed(&ax25->ax25_node)) {\n\t\tspin_lock_bh(&ax25_list_lock);\n\t\thlist_del_init(&ax25->ax25_node);\n\t\tspin_unlock_bh(&ax25_list_lock);\n\t\tax25_cb_put(ax25);\n\t}\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int ax25_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\t/* Reject non AX.25 devices */\n\tif (dev->type != ARPHRD_AX25)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tax25_dev_device_up(dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tax25_kill_by_device(dev);\n\t\tax25_rt_device_down(dev);\n\t\tax25_dev_device_down(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nvoid ax25_cb_add(ax25_cb *ax25)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_cb_hold(ax25);\n\thlist_add_head(&ax25->ax25_node, &ax25_list);\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the SABM we have just\n *\treceived.\n */\nstruct sock *ax25_find_listener(ax25_address *addr, int digi,\n\tstruct net_device *dev, int type)\n{\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif ((s->iamdigi && !digi) || (!s->iamdigi && digi))\n\t\t\tcontinue;\n\t\tif (s->sk && !ax25cmp(&s->source_addr, addr) &&\n\t\t    s->sk->sk_type == type && s->sk->sk_state == TCP_LISTEN) {\n\t\t\t/* If device is null we match any device */\n\t\t\tif (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {\n\t\t\t\tsock_hold(s->sk);\n\t\t\t\tspin_unlock(&ax25_list_lock);\n\t\t\t\treturn s->sk;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\n\treturn NULL;\n}\n\n/*\n *\tFind an AX.25 socket given both ends.\n */\nstruct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&ax25_list_lock);\n\n\treturn sk;\n}\n\n/*\n *\tFind an AX.25 control block given both ends. It will only pick up\n *\tfloating AX.25 control blocks or non Raw socket bound control blocks.\n */\nax25_cb *ax25_find_cb(const ax25_address *src_addr, ax25_address *dest_addr,\n\tax25_digi *digi, struct net_device *dev)\n{\n\tax25_cb *s;\n\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && s->sk->sk_type != SOCK_SEQPACKET)\n\t\t\tcontinue;\n\t\tif (s->ax25_dev == NULL)\n\t\t\tcontinue;\n\t\tif (ax25cmp(&s->source_addr, src_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->ax25_dev->dev == dev) {\n\t\t\tif (digi != NULL && digi->ndigi != 0) {\n\t\t\t\tif (s->digipeat == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ax25digicmp(s->digipeat, digi) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (s->digipeat != NULL && s->digipeat->ndigi != 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tax25_cb_hold(s);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\n\t\t\treturn s;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(ax25_find_cb);\n\nvoid ax25_send_to_raw(ax25_address *addr, struct sk_buff *skb, int proto)\n{\n\tax25_cb *s;\n\tstruct sk_buff *copy;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 &&\n\t\t    s->sk->sk_type == SOCK_RAW &&\n\t\t    s->sk->sk_protocol == proto &&\n\t\t    s->ax25_dev->dev == skb->dev &&\n\t\t    atomic_read(&s->sk->sk_rmem_alloc) <= s->sk->sk_rcvbuf) {\n\t\t\tif ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (sock_queue_rcv_skb(s->sk, copy) != 0)\n\t\t\t\tkfree_skb(copy);\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid ax25_destroy_socket(ax25_cb *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void ax25_destroy_timer(struct timer_list *t)\n{\n\tax25_cb *ax25 = from_timer(ax25, t, dtimer);\n\tstruct sock *sk;\n\n\tsk=ax25->sk;\n\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tax25_destroy_socket(ax25);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork. Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid ax25_destroy_socket(ax25_cb *ax25)\n{\n\tstruct sk_buff *skb;\n\n\tax25_cb_del(ax25);\n\n\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25_clear_queues(ax25);\t/* Flush the queues */\n\n\tif (ax25->sk != NULL) {\n\t\twhile ((skb = skb_dequeue(&ax25->sk->sk_receive_queue)) != NULL) {\n\t\t\tif (skb->sk != ax25->sk) {\n\t\t\t\t/* A pending connection */\n\t\t\t\tax25_cb *sax25 = sk_to_ax25(skb->sk);\n\n\t\t\t\t/* Queue the unaccepted socket for death */\n\t\t\t\tsock_orphan(skb->sk);\n\n\t\t\t\t/* 9A4GL: hack to release unaccepted sockets */\n\t\t\t\tskb->sk->sk_state = TCP_LISTEN;\n\n\t\t\t\tax25_start_heartbeat(sax25);\n\t\t\t\tsax25->state = AX25_STATE_0;\n\t\t\t}\n\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tskb_queue_purge(&ax25->sk->sk_write_queue);\n\t}\n\n\tif (ax25->sk != NULL) {\n\t\tif (sk_has_allocations(ax25->sk)) {\n\t\t\t/* Defer: outstanding buffers */\n\t\t\ttimer_setup(&ax25->dtimer, ax25_destroy_timer, 0);\n\t\t\tax25->dtimer.expires  = jiffies + 2 * HZ;\n\t\t\tadd_timer(&ax25->dtimer);\n\t\t} else {\n\t\t\tstruct sock *sk=ax25->sk;\n\t\t\tax25->sk=NULL;\n\t\t\tsock_put(sk);\n\t\t}\n\t} else {\n\t\tax25_cb_put(ax25);\n\t}\n}\n\n/*\n * dl1bke 960311: set parameters for existing AX.25 connections,\n *\t\t  includes a KILL command to abort any connection.\n *\t\t  VERY useful for debugging ;-)\n */\nstatic int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)\n{\n\tstruct ax25_ctl_struct ax25_ctl;\n\tax25_digi digi;\n\tax25_dev *ax25_dev;\n\tax25_cb *ax25;\n\tunsigned int k;\n\tint ret = 0;\n\n\tif (copy_from_user(&ax25_ctl, arg, sizeof(ax25_ctl)))\n\t\treturn -EFAULT;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&ax25_ctl.port_addr)) == NULL)\n\t\treturn -ENODEV;\n\n\tif (ax25_ctl.digi_count > AX25_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif (ax25_ctl.arg > ULONG_MAX / HZ && ax25_ctl.cmd != AX25_KILL)\n\t\treturn -EINVAL;\n\n\tdigi.ndigi = ax25_ctl.digi_count;\n\tfor (k = 0; k < digi.ndigi; k++)\n\t\tdigi.calls[k] = ax25_ctl.digi_addr[k];\n\n\tif ((ax25 = ax25_find_cb(&ax25_ctl.source_addr, &ax25_ctl.dest_addr, &digi, ax25_dev->dev)) == NULL)\n\t\treturn -ENOTCONN;\n\n\tswitch (ax25_ctl.cmd) {\n\tcase AX25_KILL:\n\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\tif (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\n\t\t\tax25_dama_off(ax25);\n#endif\n\t\tax25_disconnect(ax25, ENETRESET);\n\t\tbreak;\n\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 7)\n\t\t\t\tgoto einval_put;\n\t\t} else {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 63)\n\t\t\t\tgoto einval_put;\n\t\t}\n\t\tax25->window = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->rtt = (ax25_ctl.arg * HZ) / 2;\n\t\tax25->t1  = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t2 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 31)\n\t\t\tgoto einval_put;\n\t\tax25->n2count = 0;\n\t\tax25->n2 = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t3 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (ax25_ctl.arg > ULONG_MAX / (60 * HZ))\n\t\t\tgoto einval_put;\n\n\t\tax25->idle = ax25_ctl.arg * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535)\n\t\t\tgoto einval_put;\n\t\tax25->paclen = ax25_ctl.arg;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto einval_put;\n\t  }\n\nout_put:\n\tax25_cb_put(ax25);\n\treturn ret;\n\neinval_put:\n\tret = -EINVAL;\n\tgoto out_put;\n}\n\nstatic void ax25_fillin_cb_from_dev(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->rtt     = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]) / 2;\n\tax25->t1      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]);\n\tax25->t2      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T2]);\n\tax25->t3      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T3]);\n\tax25->n2      = ax25_dev->values[AX25_VALUES_N2];\n\tax25->paclen  = ax25_dev->values[AX25_VALUES_PACLEN];\n\tax25->idle    = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_IDLE]);\n\tax25->backoff = ax25_dev->values[AX25_VALUES_BACKOFF];\n\n\tif (ax25_dev->values[AX25_VALUES_AXDEFMODE]) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_EWINDOW];\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_WINDOW];\n\t}\n}\n\n/*\n *\tFill in a created AX.25 created control block with the default\n *\tvalues for a particular device.\n */\nvoid ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\n\t/*\n\t * No device, use kernel / AX.25 spec default values\n\t */\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}\n\n/*\n * Create an empty AX.25 control block.\n */\nax25_cb *ax25_create_cb(void)\n{\n\tax25_cb *ax25;\n\n\tif ((ax25 = kzalloc(sizeof(*ax25), GFP_ATOMIC)) == NULL)\n\t\treturn NULL;\n\n\trefcount_set(&ax25->refcount, 1);\n\n\tskb_queue_head_init(&ax25->write_queue);\n\tskb_queue_head_init(&ax25->frag_queue);\n\tskb_queue_head_init(&ax25->ack_queue);\n\tskb_queue_head_init(&ax25->reseq_queue);\n\n\tax25_setup_timers(ax25);\n\n\tax25_fillin_cb(ax25, NULL);\n\n\tax25->state = AX25_STATE_0;\n\n\treturn ax25;\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to an\n *\tAX25 socket object\n */\n\nstatic int ax25_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct net_device *dev;\n\tchar devname[IFNAMSIZ];\n\tunsigned int opt;\n\tint res = 0;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (opt < 1 || opt > 7) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (opt < 1 || opt > 63) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tax25->window = opt;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->rtt = (opt * HZ) >> 1;\n\t\tax25->t1  = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t2 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (opt < 1 || opt > 31) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->n2 = opt;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t3 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (opt > UINT_MAX / (60 * HZ)) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->idle = opt * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tif (opt > 2) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->backoff = opt;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tax25->pidincl = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tax25->iamdigi = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (opt < 16 || opt > 65535) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->paclen = opt;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tif (optlen > IFNAMSIZ - 1)\n\t\t\toptlen = IFNAMSIZ - 1;\n\n\t\tmemset(devname, 0, sizeof(devname));\n\n\t\tif (copy_from_sockptr(devname, optval, optlen)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t   (sock->state != SS_UNCONNECTED ||\n\t\t    sk->sk_state == TCP_LISTEN)) {\n\t\t\tres = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\trtnl_lock();\n\t\tdev = __dev_get_by_name(&init_net, devname);\n\t\tif (!dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tax25->ax25_dev = ax25_dev_ax25dev(dev);\n\t\tif (!ax25->ax25_dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\trtnl_unlock();\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\nstatic int ax25_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct ax25_dev *ax25_dev;\n\tchar devname[IFNAMSIZ];\n\tvoid *valptr;\n\tint val = 0;\n\tint maxlen, length;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(maxlen, optlen))\n\t\treturn -EFAULT;\n\n\tif (maxlen < 1)\n\t\treturn -EFAULT;\n\n\tvalptr = (void *) &val;\n\tlength = min_t(unsigned int, maxlen, sizeof(int));\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tval = ax25->window;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tval = ax25->t1 / HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tval = ax25->t2 / HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tval = ax25->n2;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tval = ax25->t3 / HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tval = ax25->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tval = ax25->backoff;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tval = (ax25->modulus == AX25_EMODULUS);\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tval = ax25->pidincl;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tval = ax25->iamdigi;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tval = ax25->paclen;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tax25_dev = ax25->ax25_dev;\n\n\t\tif (ax25_dev != NULL && ax25_dev->dev != NULL) {\n\t\t\tstrlcpy(devname, ax25_dev->dev->name, sizeof(devname));\n\t\t\tlength = strlen(devname) + 1;\n\t\t} else {\n\t\t\t*devname = '\\0';\n\t\t\tlength = 1;\n\t\t}\n\n\t\tvalptr = (void *) devname;\n\t\tbreak;\n\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (put_user(length, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, valptr, length) ? -EFAULT : 0;\n}\n\nstatic int ax25_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\tgoto out;\n\t}\n\tres = -EOPNOTSUPP;\n\nout:\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n/*\n * XXX: when creating ax25_sock we should update the .obj_size setting\n * below.\n */\nstatic struct proto ax25_proto = {\n\t.name\t  = \"AX25\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct ax25_sock),\n};\n\nstatic int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}\n\nstruct sock *ax25_make_new(struct sock *osk, struct ax25_dev *ax25_dev)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25, *oax25;\n\n\tsk = sk_alloc(sock_net(osk), PF_AX25, GFP_ATOMIC, osk->sk_prot, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tif ((ax25 = ax25_create_cb()) == NULL) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tswitch (osk->sk_type) {\n\tcase SOCK_DGRAM:\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\tax25_cb_put(ax25);\n\t\treturn NULL;\n\t}\n\n\tsock_init_data(NULL, sk);\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\toax25 = sk_to_ax25(osk);\n\n\tax25->modulus = oax25->modulus;\n\tax25->backoff = oax25->backoff;\n\tax25->pidincl = oax25->pidincl;\n\tax25->iamdigi = oax25->iamdigi;\n\tax25->rtt     = oax25->rtt;\n\tax25->t1      = oax25->t1;\n\tax25->t2      = oax25->t2;\n\tax25->t3      = oax25->t3;\n\tax25->n2      = oax25->n2;\n\tax25->idle    = oax25->idle;\n\tax25->paclen  = oax25->paclen;\n\tax25->window  = oax25->window;\n\n\tax25->ax25_dev    = ax25_dev;\n\tax25->source_addr = oax25->source_addr;\n\n\tif (oax25->digipeat != NULL) {\n\t\tax25->digipeat = kmemdup(oax25->digipeat, sizeof(ax25_digi),\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (ax25->digipeat == NULL) {\n\t\t\tsk_free(sk);\n\t\t\tax25_cb_put(ax25);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tax25_sk(sk)->cb = ax25;\n\tsk->sk_destruct = ax25_free_sock;\n\tax25->sk    = sk;\n\n\treturn sk;\n}\n\nstatic int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\n/*\n *\tWe support a funny extension here so you can (as root) give any callsign\n *\tdigipeated via a local address as source. This hack is obsolete now\n *\tthat we've implemented support for SO_BINDTODEVICE. It is however small\n *\tand trivially backward compatible.\n */\nstatic int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_dev *ax25_dev = NULL;\n\tax25_uid_assoc *user;\n\tax25_address call;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) &&\n\t    addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t/* support for old structure may go away some time\n\t\t * ax25_bind(): uses old (6 digipeater) socket structure.\n\t\t */\n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\tif (addr->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\tcall = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tcall = addr->fsa_ax25.sax25_call;\n\t}\n\n\tlock_sock(sk);\n\n\tax25 = sk_to_ax25(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tax25->source_addr = call;\n\n\t/*\n\t * User already set interface with SO_BINDTODEVICE\n\t */\n\tif (ax25->ax25_dev != NULL)\n\t\tgoto done;\n\n\tif (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&\n\t\t    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ax25_dev != NULL)\n\t\tax25_fillin_cb(ax25, ax25_dev);\n\ndone:\n\tax25_cb_add(ax25);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\n/*\n *\tFIXME: nonblock behaviour looks like it may have a bug.\n */\nstatic int __must_check ax25_connect(struct socket *sock,\n\tstruct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25 = sk_to_ax25(sk), *ax25t;\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_digi *digi = NULL;\n\tint ct = 0, err = 0;\n\n\t/*\n\t * some sanity checks. code further down depends on this\n\t */\n\n\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t/* support for this will go away in early 2.5.x\n\t\t * ax25_connect(): uses obsolete socket structure\n\t\t */\n\t\t;\n\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t/* support for old structure may go away some time\n\t\t * ax25_connect(): uses old (6 digipeater) socket structure.\n\t\t */\n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\n\tif (fsa->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* deal with restarts */\n\tif (sock->state == SS_CONNECTING) {\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_SENT: /* still trying */\n\t\t\terr = -EINPROGRESS;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_ESTABLISHED: /* connection established */\n\t\t\tsock->state = SS_CONNECTED;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_CLOSE: /* connection refused */\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\terr = -ECONNREFUSED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sk->sk_type == SOCK_SEQPACKET) {\n\t\terr = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tkfree(ax25->digipeat);\n\tax25->digipeat = NULL;\n\n\t/*\n\t *\tHandle digi-peaters to be used.\n\t */\n\tif (addr_len > sizeof(struct sockaddr_ax25) &&\n\t    fsa->fsa_ax25.sax25_ndigis != 0) {\n\t\t/* Valid number of digipeaters ? */\n\t\tif (fsa->fsa_ax25.sax25_ndigis < 1 ||\n\t\t    fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t    sizeof(ax25_address) * fsa->fsa_ax25.sax25_ndigis) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tif ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tdigi->ndigi      = fsa->fsa_ax25.sax25_ndigis;\n\t\tdigi->lastrepeat = -1;\n\n\t\twhile (ct < fsa->fsa_ax25.sax25_ndigis) {\n\t\t\tif ((fsa->fsa_digipeater[ct].ax25_call[6] &\n\t\t\t     AX25_HBIT) && ax25->iamdigi) {\n\t\t\t\tdigi->repeated[ct] = 1;\n\t\t\t\tdigi->lastrepeat   = ct;\n\t\t\t} else {\n\t\t\t\tdigi->repeated[ct] = 0;\n\t\t\t}\n\t\t\tdigi->calls[ct] = fsa->fsa_digipeater[ct];\n\t\t\tct++;\n\t\t}\n\t}\n\n\t/*\n\t *\tMust bind first - autobinding in this may or may not work. If\n\t *\tthe socket is already bound, check to see if the device has\n\t *\tbeen filled in, error if it hasn't.\n\t */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* check if we can remove this feature. It is broken. */\n\t\tprintk(KERN_WARNING \"ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\\n\",\n\t\t\tcurrent->comm);\n\t\tif ((err = ax25_rt_autobind(ax25, &fsa->fsa_ax25.sax25_call)) < 0) {\n\t\t\tkfree(digi);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\tax25_cb_add(ax25);\n\t} else {\n\t\tif (ax25->ax25_dev == NULL) {\n\t\t\tkfree(digi);\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t    (ax25t=ax25_find_cb(&ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi,\n\t\t\t ax25->ax25_dev->dev))) {\n\t\tkfree(digi);\n\t\terr = -EADDRINUSE;\t\t/* Already such a connection */\n\t\tax25_cb_put(ax25t);\n\t\tgoto out_release;\n\t}\n\n\tax25->dest_addr = fsa->fsa_ax25.sax25_call;\n\tax25->digipeat  = digi;\n\n\t/* First the easy one */\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\tsock->state = SS_CONNECTED;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\tgoto out_release;\n\t}\n\n\t/* Move to connecting socket, ax.25 lapb WAIT_UA.. */\n\tsock->state        = SS_CONNECTING;\n\tsk->sk_state          = TCP_SYN_SENT;\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\tif (ax25->ax25_dev->dama.slave)\n\t\t\tax25_ds_establish_data_link(ax25);\n\t\telse\n\t\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n#endif\n\t}\n\n\tax25->state = AX25_STATE_1;\n\n\tax25_start_heartbeat(ax25);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Not in ABM, not in WAIT_UA -> failed */\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\n\terr = 0;\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t       bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\treturn -EINVAL;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tThe read queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto out;\n\n\tnewsk\t\t = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\tnewsock->state = SS_CONNECTED;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\terr = sizeof (struct full_sockaddr_ax25);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tax25_digi dtmp, *dp;\n\tax25_cb *ax25;\n\tsize_t size;\n\tint lv, err, addr_len = msg->msg_namelen;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (ax25->ax25_dev == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (len > ax25->ax25_dev->dev->mtu) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tif (usax != NULL) {\n\t\tif (usax->sax25_family != AF_AX25) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t\t/* ax25_sendmsg(): uses obsolete socket structure */\n\t\t\t;\n\t\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t\t/* support for old structure may go away some time\n\t\t\t * ax25_sendmsg(): uses old (6 digipeater)\n\t\t\t * socket structure.\n\t\t\t */\n\t\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t\t    (addr_len > sizeof(struct full_sockaddr_ax25))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\tif (addr_len > sizeof(struct sockaddr_ax25) && usax->sax25_ndigis != 0) {\n\t\t\tint ct           = 0;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;\n\n\t\t\t/* Valid number of digipeaters ? */\n\t\t\tif (usax->sax25_ndigis < 1 ||\n\t\t\t    usax->sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t\t    sizeof(ax25_address) * usax->sax25_ndigis) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdtmp.ndigi      = usax->sax25_ndigis;\n\n\t\t\twhile (ct < usax->sax25_ndigis) {\n\t\t\t\tdtmp.repeated[ct] = 0;\n\t\t\t\tdtmp.calls[ct]    = fsa->fsa_digipeater[ct];\n\t\t\t\tct++;\n\t\t\t}\n\n\t\t\tdtmp.lastrepeat = 0;\n\t\t}\n\n\t\tsax = *usax;\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t    ax25cmp(&ax25->dest_addr, &sax.sax25_call)) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (usax->sax25_ndigis == 0)\n\t\t\tdp = NULL;\n\t\telse\n\t\t\tdp = &dtmp;\n\t} else {\n\t\t/*\n\t\t *\tFIXME: 1003.1g - if the socket is like this because\n\t\t *\tit has become closed (not started closed) and is VC\n\t\t *\twe ought to SIGPIPE, EPIPE\n\t\t */\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_AX25;\n\t\tsax.sax25_call   = ax25->dest_addr;\n\t\tdp = ax25->digipeat;\n\t}\n\n\t/* Build a packet */\n\t/* Assume the worst case */\n\tsize = len + ax25->ax25_dev->dev->hard_header_len;\n\n\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\n\t/* User data follows immediately after the AX.25 data */\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tskb_reset_network_header(skb);\n\n\t/* Add the PID if one is not supplied by the user in the skb */\n\tif (!ax25->pidincl)\n\t\t*(u8 *)skb_push(skb, 1) = sk->sk_protocol;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t/* Connected mode sockets go via the LAPB machine */\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\tkfree_skb(skb);\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Shove it onto the queue and kick */\n\t\tax25_output(ax25, ax25->paclen, skb);\n\n\t\terr = len;\n\t\tgoto out;\n\t}\n\n\tskb_push(skb, 1 + ax25_addr_size(dp));\n\n\t/* Building AX.25 Header */\n\n\t/* Build an AX.25 header */\n\tlv = ax25_addr_build(skb->data, &ax25->source_addr, &sax.sax25_call,\n\t\t\t     dp, AX25_COMMAND, AX25_MODULUS);\n\n\tskb_set_transport_header(skb, lv);\n\n\t*skb_transport_header(skb) = AX25_UI;\n\n\t/* Datagram frames go straight out of the door as UI */\n\tax25_queue_xmit(skb, ax25->ax25_dev->dev);\n\n\terr = len;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\n\tlock_sock(sk);\n\t/*\n\t * \tThis works for seqpacket too. The receiver has ordered the\n\t *\tqueue for us! We do one quick check first though\n\t */\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tif (!sk_to_ax25(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t/* Remove PID */\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\terr = copied;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_shutdown(struct socket *sk, int how)\n{\n\t/* FIXME - generate DM and RNR states */\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\tres = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\tres = put_user(amount, (int __user *) argp);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDUID:\t/* Add a uid to the uid/call map table */\n\tcase SIOCAX25DELUID:\t/* Delete a uid from the uid/call map table */\n\tcase SIOCAX25GETUID: {\n\t\tstruct sockaddr_ax25 sax25;\n\t\tif (copy_from_user(&sax25, argp, sizeof(sax25))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_uid_ioctl(cmd, &sax25);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25NOUID: {\t/* Set the default policy (default/bar) */\n\t\tlong amount;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(amount, (long __user *)argp)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (amount < 0 || amount > AX25_NOUID_BLOCK) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25_uid_policy = amount;\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCAX25OPTRT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_rt_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25CTLCON:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_ctl_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25GETINFO:\n\tcase SIOCAX25GETINFOOLD: {\n\t\tax25_cb *ax25 = sk_to_ax25(sk);\n\t\tstruct ax25_info_struct ax25_info;\n\n\t\tax25_info.t1        = ax25->t1   / HZ;\n\t\tax25_info.t2        = ax25->t2   / HZ;\n\t\tax25_info.t3        = ax25->t3   / HZ;\n\t\tax25_info.idle      = ax25->idle / (60 * HZ);\n\t\tax25_info.n2        = ax25->n2;\n\t\tax25_info.t1timer   = ax25_display_timer(&ax25->t1timer)   / HZ;\n\t\tax25_info.t2timer   = ax25_display_timer(&ax25->t2timer)   / HZ;\n\t\tax25_info.t3timer   = ax25_display_timer(&ax25->t3timer)   / HZ;\n\t\tax25_info.idletimer = ax25_display_timer(&ax25->idletimer) / (60 * HZ);\n\t\tax25_info.n2count   = ax25->n2count;\n\t\tax25_info.state     = ax25->state;\n\t\tax25_info.rcv_q     = sk_rmem_alloc_get(sk);\n\t\tax25_info.snd_q     = sk_wmem_alloc_get(sk);\n\t\tax25_info.vs        = ax25->vs;\n\t\tax25_info.vr        = ax25->vr;\n\t\tax25_info.va        = ax25->va;\n\t\tax25_info.vs_max    = ax25->vs; /* reserved */\n\t\tax25_info.paclen    = ax25->paclen;\n\t\tax25_info.window    = ax25->window;\n\n\t\t/* old structure? */\n\t\tif (cmd == SIOCAX25GETINFOOLD) {\n\t\t\tstatic int warned = 0;\n\t\t\tif (!warned) {\n\t\t\t\tprintk(KERN_INFO \"%s uses old SIOCAX25GETINFO\\n\",\n\t\t\t\t\tcurrent->comm);\n\t\t\t\twarned=1;\n\t\t\t}\n\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct_deprecated))) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct))) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDFWD:\n\tcase SIOCAX25DELFWD: {\n\t\tstruct ax25_fwd_struct ax25_fwd;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ax25_fwd, argp, sizeof(ax25_fwd))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_fwd_ioctl(cmd, &ax25_fwd);\n\t\tbreak;\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\tres = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *ax25_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(ax25_list_lock)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\treturn seq_hlist_start(&ax25_list, *pos);\n}\n\nstatic void *ax25_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &ax25_list, pos);\n}\n\nstatic void ax25_info_stop(struct seq_file *seq, void *v)\n\t__releases(ax25_list_lock)\n{\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\nstatic int ax25_info_show(struct seq_file *seq, void *v)\n{\n\tax25_cb *ax25 = hlist_entry(v, struct ax25_cb, ax25_node);\n\tchar buf[11];\n\tint k;\n\n\n\t/*\n\t * New format:\n\t * magic dev src_addr dest_addr,digi1,digi2,.. st vs vr va t1 t1 t2 t2 t3 t3 idle idle n2 n2 rtt window paclen Snd-Q Rcv-Q inode\n\t */\n\n\tseq_printf(seq, \"%p %s %s%s \",\n\t\t   ax25,\n\t\t   ax25->ax25_dev == NULL? \"???\" : ax25->ax25_dev->dev->name,\n\t\t   ax2asc(buf, &ax25->source_addr),\n\t\t   ax25->iamdigi? \"*\":\"\");\n\tseq_printf(seq, \"%s\", ax2asc(buf, &ax25->dest_addr));\n\n\tfor (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {\n\t\tseq_printf(seq, \",%s%s\",\n\t\t\t   ax2asc(buf, &ax25->digipeat->calls[k]),\n\t\t\t   ax25->digipeat->repeated[k]? \"*\":\"\");\n\t}\n\n\tseq_printf(seq, \" %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %d %d\",\n\t\t   ax25->state,\n\t\t   ax25->vs, ax25->vr, ax25->va,\n\t\t   ax25_display_timer(&ax25->t1timer) / HZ, ax25->t1 / HZ,\n\t\t   ax25_display_timer(&ax25->t2timer) / HZ, ax25->t2 / HZ,\n\t\t   ax25_display_timer(&ax25->t3timer) / HZ, ax25->t3 / HZ,\n\t\t   ax25_display_timer(&ax25->idletimer) / (60 * HZ),\n\t\t   ax25->idle / (60 * HZ),\n\t\t   ax25->n2count, ax25->n2,\n\t\t   ax25->rtt / HZ,\n\t\t   ax25->window,\n\t\t   ax25->paclen);\n\n\tif (ax25->sk != NULL) {\n\t\tseq_printf(seq, \" %d %d %lu\\n\",\n\t\t\t   sk_wmem_alloc_get(ax25->sk),\n\t\t\t   sk_rmem_alloc_get(ax25->sk),\n\t\t\t   sock_i_ino(ax25->sk));\n\t} else {\n\t\tseq_puts(seq, \" * * *\\n\");\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ax25_info_seqops = {\n\t.start = ax25_info_start,\n\t.next = ax25_info_next,\n\t.stop = ax25_info_stop,\n\t.show = ax25_info_show,\n};\n#endif\n\nstatic const struct net_proto_family ax25_family_ops = {\n\t.family =\tPF_AX25,\n\t.create =\tax25_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops ax25_proto_ops = {\n\t.family\t\t= PF_AX25,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= ax25_release,\n\t.bind\t\t= ax25_bind,\n\t.connect\t= ax25_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= ax25_accept,\n\t.getname\t= ax25_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= ax25_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.listen\t\t= ax25_listen,\n\t.shutdown\t= ax25_shutdown,\n\t.setsockopt\t= ax25_setsockopt,\n\t.getsockopt\t= ax25_getsockopt,\n\t.sendmsg\t= ax25_sendmsg,\n\t.recvmsg\t= ax25_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.sendpage\t= sock_no_sendpage,\n};\n\n/*\n *\tCalled by socket.c on kernel start up\n */\nstatic struct packet_type ax25_packet_type __read_mostly = {\n\t.type\t=\tcpu_to_be16(ETH_P_AX25),\n\t.func\t=\tax25_kiss_rcv,\n};\n\nstatic struct notifier_block ax25_dev_notifier = {\n\t.notifier_call = ax25_device_event,\n};\n\nstatic int __init ax25_init(void)\n{\n\tint rc = proto_register(&ax25_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ax25_family_ops);\n\tdev_add_pack(&ax25_packet_type);\n\tregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tproc_create_seq(\"ax25_route\", 0444, init_net.proc_net, &ax25_rt_seqops);\n\tproc_create_seq(\"ax25\", 0444, init_net.proc_net, &ax25_info_seqops);\n\tproc_create_seq(\"ax25_calls\", 0444, init_net.proc_net,\n\t\t\t&ax25_uid_seqops);\nout:\n\treturn rc;\n}\nmodule_init(ax25_init);\n\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio AX.25 link layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_AX25);\n\nstatic void __exit ax25_exit(void)\n{\n\tremove_proc_entry(\"ax25_route\", init_net.proc_net);\n\tremove_proc_entry(\"ax25\", init_net.proc_net);\n\tremove_proc_entry(\"ax25_calls\", init_net.proc_net);\n\n\tunregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tdev_remove_pack(&ax25_packet_type);\n\n\tsock_unregister(PF_AX25);\n\tproto_unregister(&ax25_proto);\n\n\tax25_rt_free();\n\tax25_uid_free();\n\tax25_dev_free();\n}\nmodule_exit(ax25_exit);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n * Copyright (C) Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Darryl Miles G7LED (dlm@g7led.demon.co.uk)\n * Copyright (C) Steven Whitehouse GW7RRM (stevew@acm.org)\n * Copyright (C) Joerg Reuter DL1BKE (jreuter@yaina.de)\n * Copyright (C) Hans-Joachim Hetscher DD8NE (dd8ne@bnv-bamberg.de)\n * Copyright (C) Hans Alblas PE1AYX (hans@esrac.ele.tue.nl)\n * Copyright (C) Frederic Rible F1OAT (frible@teaser.fr)\n */\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <net/net_namespace.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\n\n\nHLIST_HEAD(ax25_list);\nDEFINE_SPINLOCK(ax25_list_lock);\n\nstatic const struct proto_ops ax25_proto_ops;\n\nstatic void ax25_free_sock(struct sock *sk)\n{\n\tax25_cb_put(sk_to_ax25(sk));\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void ax25_cb_del(ax25_cb *ax25)\n{\n\tif (!hlist_unhashed(&ax25->ax25_node)) {\n\t\tspin_lock_bh(&ax25_list_lock);\n\t\thlist_del_init(&ax25->ax25_node);\n\t\tspin_unlock_bh(&ax25_list_lock);\n\t\tax25_cb_put(ax25);\n\t}\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int ax25_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\t/* Reject non AX.25 devices */\n\tif (dev->type != ARPHRD_AX25)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tax25_dev_device_up(dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tax25_kill_by_device(dev);\n\t\tax25_rt_device_down(dev);\n\t\tax25_dev_device_down(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nvoid ax25_cb_add(ax25_cb *ax25)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_cb_hold(ax25);\n\thlist_add_head(&ax25->ax25_node, &ax25_list);\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the SABM we have just\n *\treceived.\n */\nstruct sock *ax25_find_listener(ax25_address *addr, int digi,\n\tstruct net_device *dev, int type)\n{\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif ((s->iamdigi && !digi) || (!s->iamdigi && digi))\n\t\t\tcontinue;\n\t\tif (s->sk && !ax25cmp(&s->source_addr, addr) &&\n\t\t    s->sk->sk_type == type && s->sk->sk_state == TCP_LISTEN) {\n\t\t\t/* If device is null we match any device */\n\t\t\tif (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {\n\t\t\t\tsock_hold(s->sk);\n\t\t\t\tspin_unlock(&ax25_list_lock);\n\t\t\t\treturn s->sk;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\n\treturn NULL;\n}\n\n/*\n *\tFind an AX.25 socket given both ends.\n */\nstruct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&ax25_list_lock);\n\n\treturn sk;\n}\n\n/*\n *\tFind an AX.25 control block given both ends. It will only pick up\n *\tfloating AX.25 control blocks or non Raw socket bound control blocks.\n */\nax25_cb *ax25_find_cb(const ax25_address *src_addr, ax25_address *dest_addr,\n\tax25_digi *digi, struct net_device *dev)\n{\n\tax25_cb *s;\n\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && s->sk->sk_type != SOCK_SEQPACKET)\n\t\t\tcontinue;\n\t\tif (s->ax25_dev == NULL)\n\t\t\tcontinue;\n\t\tif (ax25cmp(&s->source_addr, src_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->ax25_dev->dev == dev) {\n\t\t\tif (digi != NULL && digi->ndigi != 0) {\n\t\t\t\tif (s->digipeat == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ax25digicmp(s->digipeat, digi) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (s->digipeat != NULL && s->digipeat->ndigi != 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tax25_cb_hold(s);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\n\t\t\treturn s;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(ax25_find_cb);\n\nvoid ax25_send_to_raw(ax25_address *addr, struct sk_buff *skb, int proto)\n{\n\tax25_cb *s;\n\tstruct sk_buff *copy;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 &&\n\t\t    s->sk->sk_type == SOCK_RAW &&\n\t\t    s->sk->sk_protocol == proto &&\n\t\t    s->ax25_dev->dev == skb->dev &&\n\t\t    atomic_read(&s->sk->sk_rmem_alloc) <= s->sk->sk_rcvbuf) {\n\t\t\tif ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (sock_queue_rcv_skb(s->sk, copy) != 0)\n\t\t\t\tkfree_skb(copy);\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid ax25_destroy_socket(ax25_cb *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void ax25_destroy_timer(struct timer_list *t)\n{\n\tax25_cb *ax25 = from_timer(ax25, t, dtimer);\n\tstruct sock *sk;\n\n\tsk=ax25->sk;\n\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tax25_destroy_socket(ax25);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork. Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid ax25_destroy_socket(ax25_cb *ax25)\n{\n\tstruct sk_buff *skb;\n\n\tax25_cb_del(ax25);\n\n\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25_clear_queues(ax25);\t/* Flush the queues */\n\n\tif (ax25->sk != NULL) {\n\t\twhile ((skb = skb_dequeue(&ax25->sk->sk_receive_queue)) != NULL) {\n\t\t\tif (skb->sk != ax25->sk) {\n\t\t\t\t/* A pending connection */\n\t\t\t\tax25_cb *sax25 = sk_to_ax25(skb->sk);\n\n\t\t\t\t/* Queue the unaccepted socket for death */\n\t\t\t\tsock_orphan(skb->sk);\n\n\t\t\t\t/* 9A4GL: hack to release unaccepted sockets */\n\t\t\t\tskb->sk->sk_state = TCP_LISTEN;\n\n\t\t\t\tax25_start_heartbeat(sax25);\n\t\t\t\tsax25->state = AX25_STATE_0;\n\t\t\t}\n\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tskb_queue_purge(&ax25->sk->sk_write_queue);\n\t}\n\n\tif (ax25->sk != NULL) {\n\t\tif (sk_has_allocations(ax25->sk)) {\n\t\t\t/* Defer: outstanding buffers */\n\t\t\ttimer_setup(&ax25->dtimer, ax25_destroy_timer, 0);\n\t\t\tax25->dtimer.expires  = jiffies + 2 * HZ;\n\t\t\tadd_timer(&ax25->dtimer);\n\t\t} else {\n\t\t\tstruct sock *sk=ax25->sk;\n\t\t\tax25->sk=NULL;\n\t\t\tsock_put(sk);\n\t\t}\n\t} else {\n\t\tax25_cb_put(ax25);\n\t}\n}\n\n/*\n * dl1bke 960311: set parameters for existing AX.25 connections,\n *\t\t  includes a KILL command to abort any connection.\n *\t\t  VERY useful for debugging ;-)\n */\nstatic int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)\n{\n\tstruct ax25_ctl_struct ax25_ctl;\n\tax25_digi digi;\n\tax25_dev *ax25_dev;\n\tax25_cb *ax25;\n\tunsigned int k;\n\tint ret = 0;\n\n\tif (copy_from_user(&ax25_ctl, arg, sizeof(ax25_ctl)))\n\t\treturn -EFAULT;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&ax25_ctl.port_addr)) == NULL)\n\t\treturn -ENODEV;\n\n\tif (ax25_ctl.digi_count > AX25_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif (ax25_ctl.arg > ULONG_MAX / HZ && ax25_ctl.cmd != AX25_KILL)\n\t\treturn -EINVAL;\n\n\tdigi.ndigi = ax25_ctl.digi_count;\n\tfor (k = 0; k < digi.ndigi; k++)\n\t\tdigi.calls[k] = ax25_ctl.digi_addr[k];\n\n\tif ((ax25 = ax25_find_cb(&ax25_ctl.source_addr, &ax25_ctl.dest_addr, &digi, ax25_dev->dev)) == NULL)\n\t\treturn -ENOTCONN;\n\n\tswitch (ax25_ctl.cmd) {\n\tcase AX25_KILL:\n\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\tif (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\n\t\t\tax25_dama_off(ax25);\n#endif\n\t\tax25_disconnect(ax25, ENETRESET);\n\t\tbreak;\n\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 7)\n\t\t\t\tgoto einval_put;\n\t\t} else {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 63)\n\t\t\t\tgoto einval_put;\n\t\t}\n\t\tax25->window = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->rtt = (ax25_ctl.arg * HZ) / 2;\n\t\tax25->t1  = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t2 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 31)\n\t\t\tgoto einval_put;\n\t\tax25->n2count = 0;\n\t\tax25->n2 = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t3 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (ax25_ctl.arg > ULONG_MAX / (60 * HZ))\n\t\t\tgoto einval_put;\n\n\t\tax25->idle = ax25_ctl.arg * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535)\n\t\t\tgoto einval_put;\n\t\tax25->paclen = ax25_ctl.arg;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto einval_put;\n\t  }\n\nout_put:\n\tax25_cb_put(ax25);\n\treturn ret;\n\neinval_put:\n\tret = -EINVAL;\n\tgoto out_put;\n}\n\nstatic void ax25_fillin_cb_from_dev(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->rtt     = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]) / 2;\n\tax25->t1      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]);\n\tax25->t2      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T2]);\n\tax25->t3      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T3]);\n\tax25->n2      = ax25_dev->values[AX25_VALUES_N2];\n\tax25->paclen  = ax25_dev->values[AX25_VALUES_PACLEN];\n\tax25->idle    = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_IDLE]);\n\tax25->backoff = ax25_dev->values[AX25_VALUES_BACKOFF];\n\n\tif (ax25_dev->values[AX25_VALUES_AXDEFMODE]) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_EWINDOW];\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_WINDOW];\n\t}\n}\n\n/*\n *\tFill in a created AX.25 created control block with the default\n *\tvalues for a particular device.\n */\nvoid ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\n\t/*\n\t * No device, use kernel / AX.25 spec default values\n\t */\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}\n\n/*\n * Create an empty AX.25 control block.\n */\nax25_cb *ax25_create_cb(void)\n{\n\tax25_cb *ax25;\n\n\tif ((ax25 = kzalloc(sizeof(*ax25), GFP_ATOMIC)) == NULL)\n\t\treturn NULL;\n\n\trefcount_set(&ax25->refcount, 1);\n\n\tskb_queue_head_init(&ax25->write_queue);\n\tskb_queue_head_init(&ax25->frag_queue);\n\tskb_queue_head_init(&ax25->ack_queue);\n\tskb_queue_head_init(&ax25->reseq_queue);\n\n\tax25_setup_timers(ax25);\n\n\tax25_fillin_cb(ax25, NULL);\n\n\tax25->state = AX25_STATE_0;\n\n\treturn ax25;\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to an\n *\tAX25 socket object\n */\n\nstatic int ax25_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct net_device *dev;\n\tchar devname[IFNAMSIZ];\n\tunsigned int opt;\n\tint res = 0;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (opt < 1 || opt > 7) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (opt < 1 || opt > 63) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tax25->window = opt;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->rtt = (opt * HZ) >> 1;\n\t\tax25->t1  = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t2 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (opt < 1 || opt > 31) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->n2 = opt;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t3 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (opt > UINT_MAX / (60 * HZ)) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->idle = opt * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tif (opt > 2) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->backoff = opt;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tax25->pidincl = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tax25->iamdigi = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (opt < 16 || opt > 65535) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->paclen = opt;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tif (optlen > IFNAMSIZ - 1)\n\t\t\toptlen = IFNAMSIZ - 1;\n\n\t\tmemset(devname, 0, sizeof(devname));\n\n\t\tif (copy_from_sockptr(devname, optval, optlen)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t   (sock->state != SS_UNCONNECTED ||\n\t\t    sk->sk_state == TCP_LISTEN)) {\n\t\t\tres = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\trtnl_lock();\n\t\tdev = __dev_get_by_name(&init_net, devname);\n\t\tif (!dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tax25->ax25_dev = ax25_dev_ax25dev(dev);\n\t\tif (!ax25->ax25_dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\trtnl_unlock();\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\nstatic int ax25_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct ax25_dev *ax25_dev;\n\tchar devname[IFNAMSIZ];\n\tvoid *valptr;\n\tint val = 0;\n\tint maxlen, length;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(maxlen, optlen))\n\t\treturn -EFAULT;\n\n\tif (maxlen < 1)\n\t\treturn -EFAULT;\n\n\tvalptr = (void *) &val;\n\tlength = min_t(unsigned int, maxlen, sizeof(int));\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tval = ax25->window;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tval = ax25->t1 / HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tval = ax25->t2 / HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tval = ax25->n2;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tval = ax25->t3 / HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tval = ax25->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tval = ax25->backoff;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tval = (ax25->modulus == AX25_EMODULUS);\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tval = ax25->pidincl;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tval = ax25->iamdigi;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tval = ax25->paclen;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tax25_dev = ax25->ax25_dev;\n\n\t\tif (ax25_dev != NULL && ax25_dev->dev != NULL) {\n\t\t\tstrlcpy(devname, ax25_dev->dev->name, sizeof(devname));\n\t\t\tlength = strlen(devname) + 1;\n\t\t} else {\n\t\t\t*devname = '\\0';\n\t\t\tlength = 1;\n\t\t}\n\n\t\tvalptr = (void *) devname;\n\t\tbreak;\n\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (put_user(length, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, valptr, length) ? -EFAULT : 0;\n}\n\nstatic int ax25_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\tgoto out;\n\t}\n\tres = -EOPNOTSUPP;\n\nout:\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n/*\n * XXX: when creating ax25_sock we should update the .obj_size setting\n * below.\n */\nstatic struct proto ax25_proto = {\n\t.name\t  = \"AX25\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct ax25_sock),\n};\n\nstatic int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}\n\nstruct sock *ax25_make_new(struct sock *osk, struct ax25_dev *ax25_dev)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25, *oax25;\n\n\tsk = sk_alloc(sock_net(osk), PF_AX25, GFP_ATOMIC, osk->sk_prot, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tif ((ax25 = ax25_create_cb()) == NULL) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tswitch (osk->sk_type) {\n\tcase SOCK_DGRAM:\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\tax25_cb_put(ax25);\n\t\treturn NULL;\n\t}\n\n\tsock_init_data(NULL, sk);\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\toax25 = sk_to_ax25(osk);\n\n\tax25->modulus = oax25->modulus;\n\tax25->backoff = oax25->backoff;\n\tax25->pidincl = oax25->pidincl;\n\tax25->iamdigi = oax25->iamdigi;\n\tax25->rtt     = oax25->rtt;\n\tax25->t1      = oax25->t1;\n\tax25->t2      = oax25->t2;\n\tax25->t3      = oax25->t3;\n\tax25->n2      = oax25->n2;\n\tax25->idle    = oax25->idle;\n\tax25->paclen  = oax25->paclen;\n\tax25->window  = oax25->window;\n\n\tax25->ax25_dev    = ax25_dev;\n\tax25->source_addr = oax25->source_addr;\n\n\tif (oax25->digipeat != NULL) {\n\t\tax25->digipeat = kmemdup(oax25->digipeat, sizeof(ax25_digi),\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (ax25->digipeat == NULL) {\n\t\t\tsk_free(sk);\n\t\t\tax25_cb_put(ax25);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tax25_sk(sk)->cb = ax25;\n\tsk->sk_destruct = ax25_free_sock;\n\tax25->sk    = sk;\n\n\treturn sk;\n}\n\nstatic int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\n/*\n *\tWe support a funny extension here so you can (as root) give any callsign\n *\tdigipeated via a local address as source. This hack is obsolete now\n *\tthat we've implemented support for SO_BINDTODEVICE. It is however small\n *\tand trivially backward compatible.\n */\nstatic int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_dev *ax25_dev = NULL;\n\tax25_uid_assoc *user;\n\tax25_address call;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) &&\n\t    addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t/* support for old structure may go away some time\n\t\t * ax25_bind(): uses old (6 digipeater) socket structure.\n\t\t */\n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\tif (addr->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\tcall = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tcall = addr->fsa_ax25.sax25_call;\n\t}\n\n\tlock_sock(sk);\n\n\tax25 = sk_to_ax25(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tax25->source_addr = call;\n\n\t/*\n\t * User already set interface with SO_BINDTODEVICE\n\t */\n\tif (ax25->ax25_dev != NULL)\n\t\tgoto done;\n\n\tif (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&\n\t\t    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ax25_dev != NULL)\n\t\tax25_fillin_cb(ax25, ax25_dev);\n\ndone:\n\tax25_cb_add(ax25);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\n/*\n *\tFIXME: nonblock behaviour looks like it may have a bug.\n */\nstatic int __must_check ax25_connect(struct socket *sock,\n\tstruct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25 = sk_to_ax25(sk), *ax25t;\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_digi *digi = NULL;\n\tint ct = 0, err = 0;\n\n\t/*\n\t * some sanity checks. code further down depends on this\n\t */\n\n\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t/* support for this will go away in early 2.5.x\n\t\t * ax25_connect(): uses obsolete socket structure\n\t\t */\n\t\t;\n\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t/* support for old structure may go away some time\n\t\t * ax25_connect(): uses old (6 digipeater) socket structure.\n\t\t */\n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\n\tif (fsa->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* deal with restarts */\n\tif (sock->state == SS_CONNECTING) {\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_SENT: /* still trying */\n\t\t\terr = -EINPROGRESS;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_ESTABLISHED: /* connection established */\n\t\t\tsock->state = SS_CONNECTED;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_CLOSE: /* connection refused */\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\terr = -ECONNREFUSED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sk->sk_type == SOCK_SEQPACKET) {\n\t\terr = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tkfree(ax25->digipeat);\n\tax25->digipeat = NULL;\n\n\t/*\n\t *\tHandle digi-peaters to be used.\n\t */\n\tif (addr_len > sizeof(struct sockaddr_ax25) &&\n\t    fsa->fsa_ax25.sax25_ndigis != 0) {\n\t\t/* Valid number of digipeaters ? */\n\t\tif (fsa->fsa_ax25.sax25_ndigis < 1 ||\n\t\t    fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t    sizeof(ax25_address) * fsa->fsa_ax25.sax25_ndigis) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tif ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tdigi->ndigi      = fsa->fsa_ax25.sax25_ndigis;\n\t\tdigi->lastrepeat = -1;\n\n\t\twhile (ct < fsa->fsa_ax25.sax25_ndigis) {\n\t\t\tif ((fsa->fsa_digipeater[ct].ax25_call[6] &\n\t\t\t     AX25_HBIT) && ax25->iamdigi) {\n\t\t\t\tdigi->repeated[ct] = 1;\n\t\t\t\tdigi->lastrepeat   = ct;\n\t\t\t} else {\n\t\t\t\tdigi->repeated[ct] = 0;\n\t\t\t}\n\t\t\tdigi->calls[ct] = fsa->fsa_digipeater[ct];\n\t\t\tct++;\n\t\t}\n\t}\n\n\t/*\n\t *\tMust bind first - autobinding in this may or may not work. If\n\t *\tthe socket is already bound, check to see if the device has\n\t *\tbeen filled in, error if it hasn't.\n\t */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* check if we can remove this feature. It is broken. */\n\t\tprintk(KERN_WARNING \"ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\\n\",\n\t\t\tcurrent->comm);\n\t\tif ((err = ax25_rt_autobind(ax25, &fsa->fsa_ax25.sax25_call)) < 0) {\n\t\t\tkfree(digi);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\tax25_cb_add(ax25);\n\t} else {\n\t\tif (ax25->ax25_dev == NULL) {\n\t\t\tkfree(digi);\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t    (ax25t=ax25_find_cb(&ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi,\n\t\t\t ax25->ax25_dev->dev))) {\n\t\tkfree(digi);\n\t\terr = -EADDRINUSE;\t\t/* Already such a connection */\n\t\tax25_cb_put(ax25t);\n\t\tgoto out_release;\n\t}\n\n\tax25->dest_addr = fsa->fsa_ax25.sax25_call;\n\tax25->digipeat  = digi;\n\n\t/* First the easy one */\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\tsock->state = SS_CONNECTED;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\tgoto out_release;\n\t}\n\n\t/* Move to connecting socket, ax.25 lapb WAIT_UA.. */\n\tsock->state        = SS_CONNECTING;\n\tsk->sk_state          = TCP_SYN_SENT;\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\tif (ax25->ax25_dev->dama.slave)\n\t\t\tax25_ds_establish_data_link(ax25);\n\t\telse\n\t\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n#endif\n\t}\n\n\tax25->state = AX25_STATE_1;\n\n\tax25_start_heartbeat(ax25);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Not in ABM, not in WAIT_UA -> failed */\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\n\terr = 0;\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t       bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\treturn -EINVAL;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tThe read queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto out;\n\n\tnewsk\t\t = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\tnewsock->state = SS_CONNECTED;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\terr = sizeof (struct full_sockaddr_ax25);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tax25_digi dtmp, *dp;\n\tax25_cb *ax25;\n\tsize_t size;\n\tint lv, err, addr_len = msg->msg_namelen;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (ax25->ax25_dev == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (len > ax25->ax25_dev->dev->mtu) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tif (usax != NULL) {\n\t\tif (usax->sax25_family != AF_AX25) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t\t/* ax25_sendmsg(): uses obsolete socket structure */\n\t\t\t;\n\t\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t\t/* support for old structure may go away some time\n\t\t\t * ax25_sendmsg(): uses old (6 digipeater)\n\t\t\t * socket structure.\n\t\t\t */\n\t\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t\t    (addr_len > sizeof(struct full_sockaddr_ax25))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\tif (addr_len > sizeof(struct sockaddr_ax25) && usax->sax25_ndigis != 0) {\n\t\t\tint ct           = 0;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;\n\n\t\t\t/* Valid number of digipeaters ? */\n\t\t\tif (usax->sax25_ndigis < 1 ||\n\t\t\t    usax->sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t\t    sizeof(ax25_address) * usax->sax25_ndigis) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdtmp.ndigi      = usax->sax25_ndigis;\n\n\t\t\twhile (ct < usax->sax25_ndigis) {\n\t\t\t\tdtmp.repeated[ct] = 0;\n\t\t\t\tdtmp.calls[ct]    = fsa->fsa_digipeater[ct];\n\t\t\t\tct++;\n\t\t\t}\n\n\t\t\tdtmp.lastrepeat = 0;\n\t\t}\n\n\t\tsax = *usax;\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t    ax25cmp(&ax25->dest_addr, &sax.sax25_call)) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (usax->sax25_ndigis == 0)\n\t\t\tdp = NULL;\n\t\telse\n\t\t\tdp = &dtmp;\n\t} else {\n\t\t/*\n\t\t *\tFIXME: 1003.1g - if the socket is like this because\n\t\t *\tit has become closed (not started closed) and is VC\n\t\t *\twe ought to SIGPIPE, EPIPE\n\t\t */\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_AX25;\n\t\tsax.sax25_call   = ax25->dest_addr;\n\t\tdp = ax25->digipeat;\n\t}\n\n\t/* Build a packet */\n\t/* Assume the worst case */\n\tsize = len + ax25->ax25_dev->dev->hard_header_len;\n\n\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\n\t/* User data follows immediately after the AX.25 data */\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tskb_reset_network_header(skb);\n\n\t/* Add the PID if one is not supplied by the user in the skb */\n\tif (!ax25->pidincl)\n\t\t*(u8 *)skb_push(skb, 1) = sk->sk_protocol;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t/* Connected mode sockets go via the LAPB machine */\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\tkfree_skb(skb);\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Shove it onto the queue and kick */\n\t\tax25_output(ax25, ax25->paclen, skb);\n\n\t\terr = len;\n\t\tgoto out;\n\t}\n\n\tskb_push(skb, 1 + ax25_addr_size(dp));\n\n\t/* Building AX.25 Header */\n\n\t/* Build an AX.25 header */\n\tlv = ax25_addr_build(skb->data, &ax25->source_addr, &sax.sax25_call,\n\t\t\t     dp, AX25_COMMAND, AX25_MODULUS);\n\n\tskb_set_transport_header(skb, lv);\n\n\t*skb_transport_header(skb) = AX25_UI;\n\n\t/* Datagram frames go straight out of the door as UI */\n\tax25_queue_xmit(skb, ax25->ax25_dev->dev);\n\n\terr = len;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\n\tlock_sock(sk);\n\t/*\n\t * \tThis works for seqpacket too. The receiver has ordered the\n\t *\tqueue for us! We do one quick check first though\n\t */\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tif (!sk_to_ax25(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t/* Remove PID */\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\terr = copied;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_shutdown(struct socket *sk, int how)\n{\n\t/* FIXME - generate DM and RNR states */\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\tres = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\tres = put_user(amount, (int __user *) argp);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDUID:\t/* Add a uid to the uid/call map table */\n\tcase SIOCAX25DELUID:\t/* Delete a uid from the uid/call map table */\n\tcase SIOCAX25GETUID: {\n\t\tstruct sockaddr_ax25 sax25;\n\t\tif (copy_from_user(&sax25, argp, sizeof(sax25))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_uid_ioctl(cmd, &sax25);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25NOUID: {\t/* Set the default policy (default/bar) */\n\t\tlong amount;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(amount, (long __user *)argp)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (amount < 0 || amount > AX25_NOUID_BLOCK) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25_uid_policy = amount;\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCAX25OPTRT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_rt_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25CTLCON:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_ctl_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25GETINFO:\n\tcase SIOCAX25GETINFOOLD: {\n\t\tax25_cb *ax25 = sk_to_ax25(sk);\n\t\tstruct ax25_info_struct ax25_info;\n\n\t\tax25_info.t1        = ax25->t1   / HZ;\n\t\tax25_info.t2        = ax25->t2   / HZ;\n\t\tax25_info.t3        = ax25->t3   / HZ;\n\t\tax25_info.idle      = ax25->idle / (60 * HZ);\n\t\tax25_info.n2        = ax25->n2;\n\t\tax25_info.t1timer   = ax25_display_timer(&ax25->t1timer)   / HZ;\n\t\tax25_info.t2timer   = ax25_display_timer(&ax25->t2timer)   / HZ;\n\t\tax25_info.t3timer   = ax25_display_timer(&ax25->t3timer)   / HZ;\n\t\tax25_info.idletimer = ax25_display_timer(&ax25->idletimer) / (60 * HZ);\n\t\tax25_info.n2count   = ax25->n2count;\n\t\tax25_info.state     = ax25->state;\n\t\tax25_info.rcv_q     = sk_rmem_alloc_get(sk);\n\t\tax25_info.snd_q     = sk_wmem_alloc_get(sk);\n\t\tax25_info.vs        = ax25->vs;\n\t\tax25_info.vr        = ax25->vr;\n\t\tax25_info.va        = ax25->va;\n\t\tax25_info.vs_max    = ax25->vs; /* reserved */\n\t\tax25_info.paclen    = ax25->paclen;\n\t\tax25_info.window    = ax25->window;\n\n\t\t/* old structure? */\n\t\tif (cmd == SIOCAX25GETINFOOLD) {\n\t\t\tstatic int warned = 0;\n\t\t\tif (!warned) {\n\t\t\t\tprintk(KERN_INFO \"%s uses old SIOCAX25GETINFO\\n\",\n\t\t\t\t\tcurrent->comm);\n\t\t\t\twarned=1;\n\t\t\t}\n\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct_deprecated))) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct))) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDFWD:\n\tcase SIOCAX25DELFWD: {\n\t\tstruct ax25_fwd_struct ax25_fwd;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ax25_fwd, argp, sizeof(ax25_fwd))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_fwd_ioctl(cmd, &ax25_fwd);\n\t\tbreak;\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\tres = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *ax25_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(ax25_list_lock)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\treturn seq_hlist_start(&ax25_list, *pos);\n}\n\nstatic void *ax25_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &ax25_list, pos);\n}\n\nstatic void ax25_info_stop(struct seq_file *seq, void *v)\n\t__releases(ax25_list_lock)\n{\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\nstatic int ax25_info_show(struct seq_file *seq, void *v)\n{\n\tax25_cb *ax25 = hlist_entry(v, struct ax25_cb, ax25_node);\n\tchar buf[11];\n\tint k;\n\n\n\t/*\n\t * New format:\n\t * magic dev src_addr dest_addr,digi1,digi2,.. st vs vr va t1 t1 t2 t2 t3 t3 idle idle n2 n2 rtt window paclen Snd-Q Rcv-Q inode\n\t */\n\n\tseq_printf(seq, \"%p %s %s%s \",\n\t\t   ax25,\n\t\t   ax25->ax25_dev == NULL? \"???\" : ax25->ax25_dev->dev->name,\n\t\t   ax2asc(buf, &ax25->source_addr),\n\t\t   ax25->iamdigi? \"*\":\"\");\n\tseq_printf(seq, \"%s\", ax2asc(buf, &ax25->dest_addr));\n\n\tfor (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {\n\t\tseq_printf(seq, \",%s%s\",\n\t\t\t   ax2asc(buf, &ax25->digipeat->calls[k]),\n\t\t\t   ax25->digipeat->repeated[k]? \"*\":\"\");\n\t}\n\n\tseq_printf(seq, \" %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %d %d\",\n\t\t   ax25->state,\n\t\t   ax25->vs, ax25->vr, ax25->va,\n\t\t   ax25_display_timer(&ax25->t1timer) / HZ, ax25->t1 / HZ,\n\t\t   ax25_display_timer(&ax25->t2timer) / HZ, ax25->t2 / HZ,\n\t\t   ax25_display_timer(&ax25->t3timer) / HZ, ax25->t3 / HZ,\n\t\t   ax25_display_timer(&ax25->idletimer) / (60 * HZ),\n\t\t   ax25->idle / (60 * HZ),\n\t\t   ax25->n2count, ax25->n2,\n\t\t   ax25->rtt / HZ,\n\t\t   ax25->window,\n\t\t   ax25->paclen);\n\n\tif (ax25->sk != NULL) {\n\t\tseq_printf(seq, \" %d %d %lu\\n\",\n\t\t\t   sk_wmem_alloc_get(ax25->sk),\n\t\t\t   sk_rmem_alloc_get(ax25->sk),\n\t\t\t   sock_i_ino(ax25->sk));\n\t} else {\n\t\tseq_puts(seq, \" * * *\\n\");\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ax25_info_seqops = {\n\t.start = ax25_info_start,\n\t.next = ax25_info_next,\n\t.stop = ax25_info_stop,\n\t.show = ax25_info_show,\n};\n#endif\n\nstatic const struct net_proto_family ax25_family_ops = {\n\t.family =\tPF_AX25,\n\t.create =\tax25_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops ax25_proto_ops = {\n\t.family\t\t= PF_AX25,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= ax25_release,\n\t.bind\t\t= ax25_bind,\n\t.connect\t= ax25_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= ax25_accept,\n\t.getname\t= ax25_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= ax25_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.listen\t\t= ax25_listen,\n\t.shutdown\t= ax25_shutdown,\n\t.setsockopt\t= ax25_setsockopt,\n\t.getsockopt\t= ax25_getsockopt,\n\t.sendmsg\t= ax25_sendmsg,\n\t.recvmsg\t= ax25_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.sendpage\t= sock_no_sendpage,\n};\n\n/*\n *\tCalled by socket.c on kernel start up\n */\nstatic struct packet_type ax25_packet_type __read_mostly = {\n\t.type\t=\tcpu_to_be16(ETH_P_AX25),\n\t.func\t=\tax25_kiss_rcv,\n};\n\nstatic struct notifier_block ax25_dev_notifier = {\n\t.notifier_call = ax25_device_event,\n};\n\nstatic int __init ax25_init(void)\n{\n\tint rc = proto_register(&ax25_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ax25_family_ops);\n\tdev_add_pack(&ax25_packet_type);\n\tregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tproc_create_seq(\"ax25_route\", 0444, init_net.proc_net, &ax25_rt_seqops);\n\tproc_create_seq(\"ax25\", 0444, init_net.proc_net, &ax25_info_seqops);\n\tproc_create_seq(\"ax25_calls\", 0444, init_net.proc_net,\n\t\t\t&ax25_uid_seqops);\nout:\n\treturn rc;\n}\nmodule_init(ax25_init);\n\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio AX.25 link layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_AX25);\n\nstatic void __exit ax25_exit(void)\n{\n\tremove_proc_entry(\"ax25_route\", init_net.proc_net);\n\tremove_proc_entry(\"ax25\", init_net.proc_net);\n\tremove_proc_entry(\"ax25_calls\", init_net.proc_net);\n\n\tunregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tdev_remove_pack(&ax25_packet_type);\n\n\tsock_unregister(PF_AX25);\n\tproto_unregister(&ax25_proto);\n\n\tax25_rt_free();\n\tax25_uid_free();\n\tax25_dev_free();\n}\nmodule_exit(ax25_exit);\n"], "filenames": ["net/ax25/af_ax25.c"], "buggy_code_start_loc": [79], "buggy_code_end_loc": [95], "fixing_code_start_loc": [80], "fixing_code_end_loc": [98], "type": "CWE-416", "message": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.", "other": {"cve": {"id": "CVE-2022-1199", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-29T15:15:10.527", "lastModified": "2023-02-02T17:12:32.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability."}, {"lang": "es", "value": "Se ha encontrado un fallo en el kernel de Linux. Este fallo permite a un atacante bloquear el kernel de Linux al simular la radioafici\u00f3n desde el espacio de usuario, resultando en una vulnerabilidad null-ptr-deref y una vulnerabilidad de uso de memoria previamente liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.17.14", "matchCriteriaId": "3D3A8707-E93D-4072-839F-EB77EEC3695E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:-:*:*:*:*:*:*", "matchCriteriaId": "0384FA0A-DE99-48D7-84E3-46ED0C3B5E03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc2:*:*:*:*:*:*", "matchCriteriaId": "7AB06DDF-3C2B-416D-B448-E990D8FF67A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc3:*:*:*:*:*:*", "matchCriteriaId": "EAE6C6C5-4D21-4C04-897C-70CBBB3D7B91"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-1199", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2070694", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221228-0006/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/04/02/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809"}}