{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'csv'\n\nmodule Jobs\n  class ExportUserArchive < ::Jobs::Base\n    sidekiq_options retry: false\n\n    attr_accessor :current_user\n    # note: contents provided entirely by user\n    attr_accessor :extra\n\n    COMPONENTS ||= %w(\n      user_archive\n      preferences\n      auth_tokens\n      auth_token_logs\n      badges\n      bookmarks\n      category_preferences\n      flags\n      likes\n      post_actions\n      queued_posts\n      visits\n    )\n\n    HEADER_ATTRS_FOR ||= HashWithIndifferentAccess.new(\n      user_archive: ['topic_title', 'categories', 'is_pm', 'post', 'like_count', 'reply_count', 'url', 'created_at'],\n      user_archive_profile: ['location', 'website', 'bio', 'views'],\n      auth_tokens: ['id', 'auth_token_hash', 'prev_auth_token_hash', 'auth_token_seen', 'client_ip', 'user_agent', 'seen_at', 'rotated_at', 'created_at', 'updated_at'],\n      auth_token_logs: ['id', 'action', 'user_auth_token_id', 'client_ip', 'auth_token_hash', 'created_at', 'path', 'user_agent'],\n      badges: ['badge_id', 'badge_name', 'granted_at', 'post_id', 'seq', 'granted_manually', 'notification_id', 'featured_rank'],\n      bookmarks: ['post_id', 'topic_id', 'post_number', 'link', 'name', 'created_at', 'updated_at', 'reminder_at', 'reminder_last_sent_at', 'reminder_set_at', 'auto_delete_preference'],\n      category_preferences: ['category_id', 'category_names', 'notification_level', 'dismiss_new_timestamp'],\n      flags: ['id', 'post_id', 'flag_type', 'created_at', 'updated_at', 'deleted_at', 'deleted_by', 'related_post_id', 'targets_topic', 'was_take_action'],\n      likes: ['id', 'post_id', 'topic_id', 'post_number', 'created_at', 'updated_at', 'deleted_at', 'deleted_by'],\n      post_actions: ['id', 'post_id', 'post_action_type', 'created_at', 'updated_at', 'deleted_at', 'deleted_by', 'related_post_id'],\n      queued_posts: ['id', 'verdict', 'category_id', 'topic_id', 'post_raw', 'other_json'],\n      visits: ['visited_at', 'posts_read', 'mobile', 'time_read'],\n    )\n\n    def execute(args)\n      @current_user = User.find_by(id: args[:user_id])\n      @extra = HashWithIndifferentAccess.new(args[:args]) if args[:args]\n      @timestamp ||= Time.now.strftime(\"%y%m%d-%H%M%S\")\n\n      components = []\n\n      COMPONENTS.each do |name|\n        h = { name: name, method: :\"#{name}_export\" }\n        h[:filetype] = :csv\n        filetype_method = :\"#{name}_filetype\"\n        if respond_to? filetype_method\n          h[:filetype] = public_send(filetype_method)\n        end\n        condition_method = :\"include_#{name}?\"\n        if respond_to? condition_method\n          h[:skip] = !public_send(condition_method)\n        end\n        h[:filename] = name\n        components.push(h)\n      end\n\n      export_title = 'user_archive'.titleize\n      filename = \"user_archive-#{@current_user.username}-#{@timestamp}\"\n      user_export = UserExport.create(file_name: filename, user_id: @current_user.id)\n\n      filename = \"#{filename}-#{user_export.id}\"\n      dirname = \"#{UserExport.base_directory}/#{filename}\"\n\n      # ensure directory exists\n      FileUtils.mkdir_p(dirname) unless Dir.exist?(dirname)\n\n      # Generate a compressed CSV file\n      zip_filename = nil\n      begin\n        components.each do |component|\n          next if component[:skip]\n          case component[:filetype]\n          when :csv\n            CSV.open(\"#{dirname}/#{component[:filename]}.csv\", \"w\") do |csv|\n              csv << get_header(component[:name])\n              public_send(component[:method]) { |d| csv << d }\n            end\n          when :json\n            File.open(\"#{dirname}/#{component[:filename]}.json\", \"w\") do |file|\n              file.write MultiJson.dump(public_send(component[:method]), indent: 4)\n            end\n          else\n            raise 'unknown export filetype'\n          end\n        end\n\n        zip_filename = Compression::Zip.new.compress(UserExport.base_directory, filename)\n      ensure\n        FileUtils.rm_rf(dirname)\n      end\n\n      # create upload\n      upload = nil\n\n      if File.exist?(zip_filename)\n        File.open(zip_filename) do |file|\n          upload = UploadCreator.new(\n            file,\n            File.basename(zip_filename),\n            type: 'csv_export',\n            for_export: 'true'\n          ).create_for(@current_user.id)\n\n          if upload.persisted?\n            user_export.update_columns(upload_id: upload.id)\n          else\n            Rails.logger.warn(\"Failed to upload the file #{zip_filename}: #{upload.errors.full_messages}\")\n          end\n        end\n\n        File.delete(zip_filename)\n      end\n    ensure\n      post = notify_user(upload, export_title)\n\n      if user_export.present? && post.present?\n        topic = post.topic\n        user_export.update_columns(topic_id: topic.id)\n        topic.update_status('closed', true, Discourse.system_user)\n      end\n    end\n\n    def user_archive_export\n      return enum_for(:user_archive_export) unless block_given?\n\n      Post.includes(topic: :category)\n        .where(user_id: @current_user.id)\n        .select(:topic_id, :post_number, :raw, :like_count, :reply_count, :created_at)\n        .order(:created_at)\n        .with_deleted\n        .each do |user_archive|\n        yield get_user_archive_fields(user_archive)\n      end\n    end\n\n    def user_archive_profile_export\n      return enum_for(:user_archive_profile_export) unless block_given?\n\n      UserProfile\n        .where(user_id: @current_user.id)\n        .select(:location, :website, :bio_raw, :views)\n        .each do |user_profile|\n        yield get_user_archive_profile_fields(user_profile)\n      end\n    end\n\n    def preferences_export\n      UserSerializer.new(@current_user, scope: guardian)\n    end\n\n    def preferences_filetype\n      :json\n    end\n\n    def auth_tokens_export\n      return enum_for(:auth_tokens) unless block_given?\n\n      UserAuthToken\n        .where(user_id: @current_user.id)\n        .each do |token|\n        yield [\n          token.id,\n          token.auth_token.to_s[0..4] + \"...\", # hashed and truncated\n          token.prev_auth_token[0..4] + \"...\",\n          token.auth_token_seen,\n          token.client_ip,\n          token.user_agent,\n          token.seen_at,\n          token.rotated_at,\n          token.created_at,\n          token.updated_at,\n        ]\n      end\n    end\n\n    def include_auth_token_logs?\n      # SiteSetting.verbose_auth_token_logging\n      UserAuthTokenLog.where(user_id: @current_user.id).exists?\n    end\n\n    def auth_token_logs_export\n      return enum_for(:auth_token_logs) unless block_given?\n\n      UserAuthTokenLog\n        .where(user_id: @current_user.id)\n        .each do |log|\n        yield [\n          log.id,\n          log.action,\n          log.user_auth_token_id,\n          log.client_ip,\n          log.auth_token.to_s[0..4] + \"...\", # hashed and truncated\n          log.created_at,\n          log.path,\n          log.user_agent,\n        ]\n      end\n    end\n\n    def badges_export\n      return enum_for(:badges_export) unless block_given?\n\n      UserBadge\n        .where(user_id: @current_user.id)\n        .joins(:badge)\n        .select(:badge_id, :granted_at, :post_id, :seq, :granted_by_id, :notification_id, :featured_rank)\n        .order(:granted_at)\n        .each do |ub|\n        yield [\n          ub.badge_id,\n          ub.badge.display_name,\n          ub.granted_at,\n          ub.post_id,\n          ub.seq,\n          # Hide the admin's identity, simply indicate human or system\n          User.human_user_id?(ub.granted_by_id),\n          ub.notification_id,\n          ub.featured_rank,\n        ]\n      end\n    end\n\n    def bookmarks_export\n      return enum_for(:bookmarks_export) unless block_given?\n\n      Bookmark\n        .where(user_id: @current_user.id)\n        .joins(:post)\n        .order(:id)\n        .each do |bkmk|\n        link = ''\n        if guardian.can_see_post?(bkmk.post)\n          link = bkmk.post.full_url\n        end\n        yield [\n          bkmk.post_id,\n          bkmk.topic_id,\n          bkmk.post&.post_number,\n          link,\n          bkmk.name,\n          bkmk.created_at,\n          bkmk.updated_at,\n          bkmk.reminder_at,\n          bkmk.reminder_last_sent_at,\n          bkmk.reminder_set_at,\n          Bookmark.auto_delete_preferences[bkmk.auto_delete_preference],\n        ]\n      end\n    end\n\n    def category_preferences_export\n      return enum_for(:category_preferences_export) unless block_given?\n\n      CategoryUser\n        .where(user_id: @current_user.id)\n        .select(:category_id, :notification_level, :last_seen_at)\n        .each do |cu|\n        yield [\n          cu.category_id,\n          piped_category_name(cu.category_id),\n          NotificationLevels.all[cu.notification_level],\n          cu.last_seen_at\n        ]\n      end\n    end\n\n    def flags_export\n      return enum_for(:flags_export) unless block_given?\n\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where(post_action_type_id: PostActionType.flag_types.values)\n        .order(:created_at)\n        .each do |pa|\n        yield [\n          pa.id,\n          pa.post_id,\n          PostActionType.flag_types[pa.post_action_type_id],\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n          pa.related_post_id,\n          pa.targets_topic,\n          # renamed to 'was_take_action' to avoid possibility of thinking this is a synonym of agreed_at\n          pa.staff_took_action,\n        ]\n      end\n    end\n\n    def likes_export\n      return enum_for(:likes_export) unless block_given?\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where(post_action_type_id: PostActionType.types[:like])\n        .order(:created_at)\n        .each do |pa|\n        post = Post.with_deleted.find_by(id: pa.post_id)\n        yield [\n          pa.id,\n          pa.post_id,\n          post&.topic_id,\n          post&.post_number,\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n        ]\n      end\n    end\n\n    def include_post_actions?\n      # Most forums should not have post_action records other than flags and likes, but they are possible in historical oddities.\n      PostAction\n        .where(user_id: @current_user.id)\n        .where.not(post_action_type_id: PostActionType.flag_types.values + [PostActionType.types[:like], PostActionType.types[:bookmark]])\n        .exists?\n    end\n\n    def post_actions_export\n      return enum_for(:likes_export) unless block_given?\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where.not(post_action_type_id: PostActionType.flag_types.values + [PostActionType.types[:like], PostActionType.types[:bookmark]])\n        .order(:created_at)\n        .each do |pa|\n        yield [\n          pa.id,\n          pa.post_id,\n          PostActionType.types[pa.post_action_type] || pa.post_action_type,\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n          pa.related_post_id,\n        ]\n      end\n    end\n\n    def queued_posts_export\n      return enum_for(:queued_posts_export) unless block_given?\n\n      # Most Reviewable fields staff-private, but post content needs to be exported.\n      ReviewableQueuedPost\n        .where(created_by: @current_user.id)\n        .order(:created_at)\n        .each do |rev|\n\n        yield [\n          rev.id,\n          Reviewable.statuses[rev.status],\n          rev.category_id,\n          rev.topic_id,\n          rev.payload['raw'],\n          MultiJson.dump(rev.payload.slice(*queued_posts_payload_permitted_keys)),\n        ]\n      end\n    end\n\n    def visits_export\n      return enum_for(:visits_export) unless block_given?\n\n      UserVisit\n        .where(user_id: @current_user.id)\n        .order(visited_at: :asc)\n        .each do |uv|\n        yield [\n          uv.visited_at,\n          uv.posts_read,\n          uv.mobile,\n          uv.time_read,\n        ]\n      end\n    end\n\n    def get_header(entity)\n      if entity == 'user_list'\n        header_array = HEADER_ATTRS_FOR['user_list'] + HEADER_ATTRS_FOR['user_stats'] + HEADER_ATTRS_FOR['user_profile']\n        header_array.concat(HEADER_ATTRS_FOR['user_sso']) if SiteSetting.enable_discourse_connect\n        user_custom_fields = UserField.all\n        if user_custom_fields.present?\n          user_custom_fields.each do |custom_field|\n            header_array.push(\"#{custom_field.name} (custom user field)\")\n          end\n        end\n        header_array.push(\"group_names\")\n      else\n        header_array = HEADER_ATTRS_FOR[entity]\n      end\n\n      header_array\n    end\n\n    private\n\n    def guardian\n      @guardian ||= Guardian.new(@current_user)\n    end\n\n    def piped_category_name(category_id)\n      return \"-\" unless category_id\n      category = Category.find_by(id: category_id)\n      return \"#{category_id}\" unless category\n      categories = [category.name]\n      while category.parent_category_id && category = category.parent_category\n        categories << category.name\n      end\n      categories.reverse.join(\"|\")\n    end\n\n    def self_or_other(user_id)\n      if user_id.nil?\n        nil\n      elsif user_id == @current_user.id\n        'self'\n      else\n        'other'\n      end\n    end\n\n    def get_user_archive_fields(user_archive)\n      user_archive_array = []\n      topic_data = user_archive.topic\n      user_archive = user_archive.as_json\n      topic_data = Topic.with_deleted.find_by(id: user_archive['topic_id']) if topic_data.nil?\n      return user_archive_array if topic_data.nil?\n\n      categories = piped_category_name(topic_data.category_id)\n      is_pm = topic_data.archetype == \"private_message\" ? I18n.t(\"csv_export.boolean_yes\") : I18n.t(\"csv_export.boolean_no\")\n      url = \"#{Discourse.base_url}/t/#{topic_data.slug}/#{topic_data.id}/#{user_archive['post_number']}\"\n\n      topic_hash = { \"post\" => user_archive['raw'], \"topic_title\" => topic_data.title, \"categories\" => categories, \"is_pm\" => is_pm, \"url\" => url }\n      user_archive.merge!(topic_hash)\n\n      HEADER_ATTRS_FOR['user_archive'].each do |attr|\n        user_archive_array.push(user_archive[attr])\n      end\n\n      user_archive_array\n    end\n\n    def get_user_archive_profile_fields(user_profile)\n      user_archive_profile = []\n\n      HEADER_ATTRS_FOR['user_archive_profile'].each do |attr|\n        data =\n          if attr == 'bio'\n            user_profile.attributes['bio_raw']\n          else\n            user_profile.attributes[attr]\n          end\n\n          user_archive_profile.push(data)\n      end\n\n      user_archive_profile\n    end\n\n    def queued_posts_payload_permitted_keys\n      # Generated with:\n      #\n      # SELECT distinct json_object_keys(payload) from reviewables\n      # where type = 'ReviewableQueuedPost' and (payload->'old_queued_post_id') IS NULL\n      #\n      # except raw, created_topic_id, created_post_id\n      %w{\n        composer_open_duration_msecs\n        is_poll\n        reply_to_post_number\n        tags\n        title\n        typing_duration_msecs\n      }\n    end\n\n    def notify_user(upload, export_title)\n      post = nil\n\n      if @current_user\n        post = if upload.persisted?\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :csv_export_succeeded,\n            download_link: UploadMarkdown.new(upload).attachment_markdown,\n            export_title: export_title\n          )\n        else\n          SystemMessage.create_from_system_user(@current_user, :csv_export_failed)\n        end\n      end\n\n      post\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'csv'\n\ndescribe Jobs::ExportUserArchive do\n  fab!(:user) { Fabricate(:user, username: \"john_doe\") }\n  fab!(:user2) { Fabricate(:user) }\n  let(:extra) { {} }\n  let(:job) {\n    j = Jobs::ExportUserArchive.new\n    j.current_user = user\n    j.extra = extra\n    j\n  }\n  let(:component) { raise 'component not set' }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:category) { Fabricate(:category_with_definition) }\n  fab!(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n  fab!(:topic) { Fabricate(:topic, category: category) }\n  let(:post) { Fabricate(:post, user: user, topic: topic) }\n\n  def make_component_csv\n    data_rows = []\n    csv_out = CSV.generate do |csv|\n      csv << job.get_header(component)\n      job.public_send(:\"#{component}_export\") do |row|\n        csv << row\n        data_rows << Jobs::ExportUserArchive::HEADER_ATTRS_FOR[component].zip(row.map(&:to_s)).to_h.with_indifferent_access\n      end\n    end\n    [data_rows, csv_out]\n  end\n\n  def make_component_json\n    JSON.parse(MultiJson.dump(job.public_send(:\"#{component}_export\")))\n  end\n\n  context '#execute' do\n    before do\n      _ = post\n      user.user_profile.website = 'https://doe.example.com/john'\n      user.user_profile.save\n      # force a UserAuthTokenLog entry\n      env = create_request_env.merge(\n        'HTTP_USER_AGENT' => 'MyWebBrowser',\n        'REQUEST_PATH' => '/some_path/456852',\n      )\n      cookie_jar = ActionDispatch::Request.new(env).cookie_jar\n      Discourse.current_user_provider.new(env).log_on_user(user, {}, cookie_jar)\n\n      # force a nonstandard post action\n      PostAction.new(user: user, post: post, post_action_type_id: 5).save\n    end\n\n    after do\n      user.uploads.each(&:destroy!)\n    end\n\n    it 'raises an error when the user is missing' do\n      expect { Jobs::ExportCsvFile.new.execute(user_id: user.id + (1 << 20)) }.to raise_error(Discourse::InvalidParameters)\n    end\n\n    it 'works' do\n      expect do\n        Jobs::ExportUserArchive.new.execute(\n          user_id: user.id,\n        )\n      end.to change { Upload.count }.by(1)\n\n      system_message = user.topics_allowed.last\n\n      expect(system_message.title).to eq(I18n.t(\n        \"system_messages.csv_export_succeeded.subject_template\",\n        export_title: \"User Archive\"\n      ))\n\n      upload = system_message.first_post.uploads.first\n\n      expect(system_message.first_post.raw).to eq(I18n.t(\n        \"system_messages.csv_export_succeeded.text_body_template\",\n        download_link: \"[#{upload.original_filename}|attachment](#{upload.short_url}) (#{upload.human_filesize})\"\n      ).chomp)\n\n      expect(system_message.id).to eq(UserExport.last.topic_id)\n      expect(system_message.closed).to eq(true)\n\n      files = []\n      Zip::File.open(Discourse.store.path_for(upload)) do |zip_file|\n        zip_file.each { |entry| files << entry.name }\n      end\n\n      expect(files.size).to eq(Jobs::ExportUserArchive::COMPONENTS.length)\n      expect(files.find { |f| f == 'user_archive.csv' }).to_not be_nil\n      expect(files.find { |f| f == 'category_preferences.csv' }).to_not be_nil\n    end\n\n    it 'sends a message if it fails' do\n      SiteSetting.max_export_file_size_kb = 1\n\n      expect do\n        Jobs::ExportUserArchive.new.execute(\n          user_id: user.id,\n        )\n      end.to change { Upload.count }.by(0)\n\n      system_message = user.topics_allowed.last\n      expect(system_message.title).to eq(I18n.t(\"system_messages.csv_export_failed.subject_template\"))\n    end\n  end\n\n  context 'user_archive posts' do\n    let(:component) { 'user_archive' }\n    let(:subsubcategory) { Fabricate(:category_with_definition, parent_category_id: subcategory.id) }\n    let(:subsubtopic) { Fabricate(:topic, category: subsubcategory) }\n    let(:subsubpost) { Fabricate(:post, user: user, topic: subsubtopic) }\n\n    let(:normal_post) { Fabricate(:post, user: user, topic: topic) }\n    let(:reply) { PostCreator.new(user2, raw: 'asdf1234qwert7896', topic_id: topic.id, reply_to_post_number: normal_post.post_number).create }\n\n    let(:message) { Fabricate(:private_message_topic) }\n    let(:message_post) { Fabricate(:post, user: user, topic: message) }\n\n    it 'properly exports posts' do\n      SiteSetting.max_category_nesting = 3\n      [reply, subsubpost, message_post]\n\n      PostActionCreator.like(user2, normal_post)\n\n      rows = []\n      job.user_archive_export do |row|\n        rows << Jobs::ExportUserArchive::HEADER_ATTRS_FOR['user_archive'].zip(row).to_h\n      end\n\n      expect(rows.length).to eq(3)\n\n      post1 = rows.find { |r| r['topic_title'] == topic.title }\n      post2 = rows.find { |r| r['topic_title'] == subsubtopic.title }\n      post3 = rows.find { |r| r['topic_title'] == message.title }\n\n      expect(post1[\"categories\"]).to eq(\"#{category.name}\")\n      expect(post2[\"categories\"]).to eq(\"#{category.name}|#{subcategory.name}|#{subsubcategory.name}\")\n      expect(post3[\"categories\"]).to eq(\"-\")\n\n      expect(post1[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_no\"))\n      expect(post2[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_no\"))\n      expect(post3[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_yes\"))\n\n      expect(post1[\"post\"]).to eq(normal_post.raw)\n      expect(post2[\"post\"]).to eq(subsubpost.raw)\n      expect(post3[\"post\"]).to eq(message_post.raw)\n\n      expect(post1['like_count']).to eq(1)\n      expect(post2['like_count']).to eq(0)\n\n      expect(post1['reply_count']).to eq(1)\n      expect(post2['reply_count']).to eq(0)\n    end\n\n    it 'can export a post from a deleted category' do\n      cat2 = Fabricate(:category)\n      topic2 = Fabricate(:topic, category: cat2, user: user)\n      _post2 = Fabricate(:post, topic: topic2, user: user)\n\n      cat2_id = cat2.id\n      cat2.destroy!\n\n      _, csv_out = make_component_csv\n      expect(csv_out).to match cat2_id.to_s\n    end\n  end\n\n  context 'preferences' do\n    let(:component) { 'preferences' }\n\n    before do\n      user.user_profile.website = 'https://doe.example.com/john'\n      user.user_profile.bio_raw = \"I am John Doe\\n\\nHere I am\"\n      user.user_profile.save\n      user.user_option.text_size = :smaller\n      user.user_option.automatically_unpin_topics = false\n      user.user_option.save\n    end\n\n    it 'properly includes the profile fields' do\n      _serializer = job.preferences_export\n      # puts MultiJson.dump(serializer, indent: 4)\n      output = make_component_json\n      payload = output['user']\n\n      expect(payload['website']).to match('doe.example.com')\n      expect(payload['bio_raw']).to match(\"Doe\\n\\nHere\")\n      expect(payload['user_option']['automatically_unpin_topics']).to eq(false)\n      expect(payload['user_option']['text_size']).to eq('smaller')\n    end\n  end\n\n  context 'auth tokens' do\n    let(:component) { 'auth_tokens' }\n\n    before do\n      env = create_request_env.merge(\n        'HTTP_USER_AGENT' => 'MyWebBrowser',\n        'REQUEST_PATH' => '/some_path/456852',\n      )\n      cookie_jar = ActionDispatch::Request.new(env).cookie_jar\n      Discourse.current_user_provider.new(env).log_on_user(user, {}, cookie_jar)\n    end\n\n    it 'properly includes session records' do\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(1)\n\n      expect(data[0]['user_agent']).to eq('MyWebBrowser')\n    end\n\n    context 'auth token logs' do\n      let(:component) { 'auth_token_logs' }\n      it 'includes details such as the path' do\n        data, _csv_out = make_component_csv\n        expect(data.length).to eq(1)\n\n        expect(data[0]['action']).to eq('generate')\n        expect(data[0]['path']).to eq('/some_path/456852')\n      end\n    end\n  end\n\n  context 'badges' do\n    let(:component) { 'badges' }\n\n    let(:badge1) { Fabricate(:badge) }\n    let(:badge2) { Fabricate(:badge, multiple_grant: true) }\n    let(:badge3) { Fabricate(:badge, multiple_grant: true) }\n    let(:day_ago) { 1.day.ago }\n\n    it 'properly includes badge records' do\n      grant_start = Time.now.utc\n      BadgeGranter.grant(badge1, user)\n      BadgeGranter.grant(badge2, user)\n      BadgeGranter.grant(badge2, user, granted_by: admin)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(6)\n\n      expect(data[0]['badge_id']).to eq(badge1.id.to_s)\n      expect(data[0]['badge_name']).to eq(badge1.display_name)\n      expect(data[0]['featured_rank']).to_not eq('')\n      expect(DateTime.parse(data[0]['granted_at'])).to be >= DateTime.parse(grant_start.to_s)\n      expect(data[2]['granted_manually']).to eq('true')\n      expect(Post.find(data[3]['post_id'])).to_not be_nil\n    end\n\n  end\n\n  context 'bookmarks' do\n    let(:component) { 'bookmarks' }\n\n    let(:name) { 'Collect my thoughts on this' }\n    let(:manager) { BookmarkManager.new(user) }\n    let(:topic1) { Fabricate(:topic) }\n    let(:post1) { Fabricate(:post, topic: topic1, post_number: 5) }\n    let(:post2) { Fabricate(:post) }\n    let(:post3) { Fabricate(:post) }\n    let(:message) { Fabricate(:private_message_topic) }\n    let(:post4) { Fabricate(:post, topic: message) }\n    let(:reminder_at) { 1.day.from_now }\n\n    it 'properly includes bookmark records' do\n      now = freeze_time '2017-03-01 12:00'\n\n      bkmk1 = manager.create(post_id: post1.id, name: name)\n      update1_at = now + 1.hours\n      bkmk1.update(name: 'great food recipe', updated_at: update1_at)\n\n      manager.create(post_id: post2.id, name: name, reminder_at: reminder_at, options: { auto_delete_preference: Bookmark.auto_delete_preferences[:when_reminder_sent] })\n      twelve_hr_ago = freeze_time now - 12.hours\n      pending_reminder = manager.create(post_id: post3.id, name: name, reminder_at: now - 8.hours)\n      freeze_time now\n\n      tau_record = message.topic_allowed_users.create!(user_id: user.id)\n      manager.create(post_id: post4.id, name: name)\n      tau_record.destroy!\n\n      BookmarkReminderNotificationHandler.send_notification(pending_reminder)\n\n      data, _csv_out = make_component_csv\n\n      expect(data.length).to eq(4)\n\n      expect(data[0]['post_id']).to eq(post1.id.to_s)\n      expect(data[0]['topic_id']).to eq(topic1.id.to_s)\n      expect(data[0]['post_number']).to eq('5')\n      expect(data[0]['link']).to eq(post1.full_url)\n      expect(DateTime.parse(data[0]['updated_at'])).to eq(DateTime.parse(update1_at.to_s))\n\n      expect(data[1]['name']).to eq(name)\n      expect(DateTime.parse(data[1]['reminder_at'])).to eq(DateTime.parse(reminder_at.to_s))\n      expect(data[1]['auto_delete_preference']).to eq('when_reminder_sent')\n\n      expect(DateTime.parse(data[2]['created_at'])).to eq(DateTime.parse(twelve_hr_ago.to_s))\n      expect(DateTime.parse(data[2]['reminder_last_sent_at'])).to eq(DateTime.parse(now.to_s))\n      expect(data[2]['reminder_set_at']).to eq('')\n\n      expect(data[3]['topic_id']).to eq(message.id.to_s)\n      expect(data[3]['link']).to eq('')\n    end\n\n  end\n\n  context 'category_preferences' do\n    let(:component) { 'category_preferences' }\n\n    let(:subsubcategory) { Fabricate(:category_with_definition, parent_category_id: subcategory.id) }\n    let(:announcements) { Fabricate(:category_with_definition) }\n    let(:deleted_category) { Fabricate(:category) }\n\n    let(:reset_at) { DateTime.parse('2017-03-01 12:00') }\n\n    before do\n      SiteSetting.max_category_nesting = 3\n\n      # TopicsController#reset-new?category_id=&include_subcategories=true\n      category_ids = [subcategory.id, subsubcategory.id]\n      category_ids.each do |category_id|\n        user\n          .category_users\n          .where(category_id: category_id)\n          .first_or_initialize\n          .update!(last_seen_at: reset_at, notification_level: NotificationLevels.all[:regular])\n      end\n\n      # Set Watching First Post on announcements, Tracking on subcategory, Muted on deleted, nothing on subsubcategory\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:watching_first_post], announcements.id)\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:tracking], subcategory.id)\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:muted], deleted_category.id)\n\n      deleted_category.destroy!\n    end\n\n    it 'correctly exports the CategoryUser table' do\n      data, _csv_out = make_component_csv\n\n      expect(data.find { |r| r['category_id'] == category.id }).to be_nil\n      expect(data.length).to eq(4)\n      data.sort! { |a, b| a['category_id'].to_i <=> b['category_id'].to_i }\n\n      expect(data[0][:category_id]).to eq(subcategory.id.to_s)\n      expect(data[0][:notification_level].to_s).to eq('tracking')\n      expect(DateTime.parse(data[0][:dismiss_new_timestamp])).to eq(reset_at)\n\n      expect(data[1][:category_id]).to eq(subsubcategory.id.to_s)\n      expect(data[1][:category_names]).to eq(\"#{category.name}|#{subcategory.name}|#{subsubcategory.name}\")\n      expect(data[1][:notification_level]).to eq('regular')\n      expect(DateTime.parse(data[1][:dismiss_new_timestamp])).to eq(reset_at)\n\n      expect(data[2][:category_id]).to eq(announcements.id.to_s)\n      expect(data[2][:category_names]).to eq(announcements.name)\n      expect(data[2][:notification_level]).to eq('watching_first_post')\n      expect(data[2][:dismiss_new_timestamp]).to eq('')\n\n      expect(data[3][:category_names]).to eq(data[3][:category_id])\n    end\n  end\n\n  context 'flags' do\n    let(:component) { 'flags' }\n    let(:other_post) { Fabricate(:post, user: admin) }\n    let(:post3) { Fabricate(:post) }\n    let(:post4) { Fabricate(:post) }\n\n    it 'correctly exports flags' do\n      result0 = PostActionCreator.notify_moderators(user, other_post, \"helping out the admins\")\n      PostActionCreator.spam(user, post3)\n      PostActionDestroyer.destroy(user, post3, :spam)\n      PostActionCreator.inappropriate(user, post3)\n\n      result3 = PostActionCreator.off_topic(user, post4)\n      result3.reviewable.perform(admin, :agree_and_keep)\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(4)\n      data.sort_by! { |row| row['post_id'].to_i }\n\n      expect(data[0]['post_id']).to eq(other_post.id.to_s)\n      expect(data[0]['flag_type']).to eq('notify_moderators')\n      expect(data[0]['related_post_id']).to eq(result0.post_action.related_post_id.to_s)\n\n      expect(data[1]['flag_type']).to eq('spam')\n      expect(data[2]['flag_type']).to eq('inappropriate')\n      expect(data[1]['deleted_at']).to_not be_empty\n      expect(data[1]['deleted_by']).to eq('self')\n      expect(data[2]['deleted_at']).to be_empty\n\n      expect(data[3]['post_id']).to eq(post4.id.to_s)\n      expect(data[3]['flag_type']).to eq('off_topic')\n      expect(data[3]['deleted_at']).to be_empty\n    end\n  end\n\n  context 'likes' do\n    let(:component) { 'likes' }\n    let(:other_post) { Fabricate(:post, user: admin) }\n    let(:post3) { Fabricate(:post) }\n\n    it 'correctly exports likes' do\n      PostActionCreator.like(user, other_post)\n      PostActionCreator.like(user, post3)\n      PostActionCreator.like(admin, post3)\n      PostActionDestroyer.destroy(user, post3, :like)\n      post3.destroy!\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(2)\n      data.sort_by! { |row| row['post_id'].to_i }\n\n      expect(data[0]['post_id']).to eq(other_post.id.to_s)\n      expect(data[1]['post_id']).to eq(post3.id.to_s)\n      expect(data[1]['deleted_at']).to_not be_empty\n      expect(data[1]['deleted_by']).to eq('self')\n    end\n  end\n\n  context 'queued posts' do\n    let(:component) { 'queued_posts' }\n    let(:reviewable_post) { Fabricate(:reviewable_queued_post, topic: topic, created_by: user) }\n    let(:reviewable_topic) { Fabricate(:reviewable_queued_post_topic, category: category, created_by: user) }\n\n    it 'correctly exports queued posts' do\n      SiteSetting.tagging_enabled = true\n\n      reviewable_post.perform(admin, :reject_post)\n      reviewable_topic.payload['tags'] = ['example_tag']\n      result = reviewable_topic.perform(admin, :approve_post)\n      expect(result.success?).to eq(true)\n\n      data, csv_out = make_component_csv\n      expect(data.length).to eq(2)\n      expect(csv_out).to_not match(admin.username)\n\n      approved = data.find { |el| el[\"verdict\"] === \"approved\" }\n      rejected = data.find { |el| el[\"verdict\"] === \"rejected\" }\n\n      expect(approved['other_json']).to match('example_tag')\n      expect(rejected['post_raw']).to eq('hello world post contents.')\n      expect(rejected['other_json']).to match('reply_to_post_number')\n    end\n  end\n\n  context 'visits' do\n    let(:component) { 'visits' }\n\n    it 'correctly exports the UserVisit table' do\n      freeze_time '2017-03-01 12:00'\n\n      UserVisit.create(user_id: user.id, visited_at: 1.minute.ago, posts_read: 1, mobile: false, time_read: 10)\n      UserVisit.create(user_id: user.id, visited_at: 2.days.ago, posts_read: 2, mobile: false, time_read: 20)\n      UserVisit.create(user_id: user.id, visited_at: 1.week.ago, posts_read: 3, mobile: true, time_read: 30)\n      UserVisit.create(user_id: user.id, visited_at: 1.year.ago, posts_read: 4, mobile: false, time_read: 40)\n      UserVisit.create(user_id: user2.id, visited_at: 1.minute.ago, posts_read: 1, mobile: false, time_read: 50)\n\n      data, _csv_out = make_component_csv\n\n      # user2's data is not mixed in\n      expect(data.length).to eq(4)\n      expect(data.find { |r| r['time_read'] == 50 }).to be_nil\n\n      expect(data[0]['visited_at']).to eq('2016-03-01')\n      expect(data[0]['posts_read']).to eq('4')\n      expect(data[0]['time_read']).to eq('40')\n      expect(data[1]['mobile']).to eq('true')\n      expect(data[3]['visited_at']).to eq('2017-03-01')\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'csv'\n\nmodule Jobs\n  class ExportUserArchive < ::Jobs::Base\n    sidekiq_options retry: false\n\n    attr_accessor :current_user\n    # note: contents provided entirely by user\n    attr_accessor :extra\n\n    COMPONENTS ||= %w(\n      user_archive\n      preferences\n      auth_tokens\n      auth_token_logs\n      badges\n      bookmarks\n      category_preferences\n      flags\n      likes\n      post_actions\n      queued_posts\n      visits\n    )\n\n    HEADER_ATTRS_FOR ||= HashWithIndifferentAccess.new(\n      user_archive: ['topic_title', 'categories', 'is_pm', 'post', 'like_count', 'reply_count', 'url', 'created_at'],\n      user_archive_profile: ['location', 'website', 'bio', 'views'],\n      auth_tokens: ['id', 'auth_token_hash', 'prev_auth_token_hash', 'auth_token_seen', 'client_ip', 'user_agent', 'seen_at', 'rotated_at', 'created_at', 'updated_at'],\n      auth_token_logs: ['id', 'action', 'user_auth_token_id', 'client_ip', 'auth_token_hash', 'created_at', 'path', 'user_agent'],\n      badges: ['badge_id', 'badge_name', 'granted_at', 'post_id', 'seq', 'granted_manually', 'notification_id', 'featured_rank'],\n      bookmarks: ['post_id', 'topic_id', 'post_number', 'link', 'name', 'created_at', 'updated_at', 'reminder_at', 'reminder_last_sent_at', 'reminder_set_at', 'auto_delete_preference'],\n      category_preferences: ['category_id', 'category_names', 'notification_level', 'dismiss_new_timestamp'],\n      flags: ['id', 'post_id', 'flag_type', 'created_at', 'updated_at', 'deleted_at', 'deleted_by', 'related_post_id', 'targets_topic', 'was_take_action'],\n      likes: ['id', 'post_id', 'topic_id', 'post_number', 'created_at', 'updated_at', 'deleted_at', 'deleted_by'],\n      post_actions: ['id', 'post_id', 'post_action_type', 'created_at', 'updated_at', 'deleted_at', 'deleted_by', 'related_post_id'],\n      queued_posts: ['id', 'verdict', 'category_id', 'topic_id', 'post_raw', 'other_json'],\n      visits: ['visited_at', 'posts_read', 'mobile', 'time_read'],\n    )\n\n    def execute(args)\n      @current_user = User.find_by(id: args[:user_id])\n      @extra = HashWithIndifferentAccess.new(args[:args]) if args[:args]\n      @timestamp ||= Time.now.strftime(\"%y%m%d-%H%M%S\")\n\n      components = []\n\n      COMPONENTS.each do |name|\n        h = { name: name, method: :\"#{name}_export\" }\n        h[:filetype] = :csv\n        filetype_method = :\"#{name}_filetype\"\n        if respond_to? filetype_method\n          h[:filetype] = public_send(filetype_method)\n        end\n        condition_method = :\"include_#{name}?\"\n        if respond_to? condition_method\n          h[:skip] = !public_send(condition_method)\n        end\n        h[:filename] = name\n        components.push(h)\n      end\n\n      export_title = 'user_archive'.titleize\n      filename = \"user_archive-#{@current_user.username}-#{@timestamp}\"\n      user_export = UserExport.create(file_name: filename, user_id: @current_user.id)\n\n      filename = \"#{filename}-#{user_export.id}\"\n      dirname = \"#{UserExport.base_directory}/#{filename}\"\n\n      # ensure directory exists\n      FileUtils.mkdir_p(dirname) unless Dir.exist?(dirname)\n\n      # Generate a compressed CSV file\n      zip_filename = nil\n      begin\n        components.each do |component|\n          next if component[:skip]\n          case component[:filetype]\n          when :csv\n            CSV.open(\"#{dirname}/#{component[:filename]}.csv\", \"w\") do |csv|\n              csv << get_header(component[:name])\n              public_send(component[:method]) { |d| csv << d }\n            end\n          when :json\n            File.open(\"#{dirname}/#{component[:filename]}.json\", \"w\") do |file|\n              file.write MultiJson.dump(public_send(component[:method]), indent: 4)\n            end\n          else\n            raise 'unknown export filetype'\n          end\n        end\n\n        zip_filename = Compression::Zip.new.compress(UserExport.base_directory, filename)\n      ensure\n        FileUtils.rm_rf(dirname)\n      end\n\n      # create upload\n      upload = nil\n\n      if File.exist?(zip_filename)\n        File.open(zip_filename) do |file|\n          upload = UploadCreator.new(\n            file,\n            File.basename(zip_filename),\n            type: 'csv_export',\n            for_export: 'true'\n          ).create_for(@current_user.id)\n\n          if upload.persisted?\n            user_export.update_columns(upload_id: upload.id)\n          else\n            Rails.logger.warn(\"Failed to upload the file #{zip_filename}: #{upload.errors.full_messages}\")\n          end\n        end\n\n        File.delete(zip_filename)\n      end\n    ensure\n      post = notify_user(upload, export_title)\n\n      if user_export.present? && post.present?\n        topic = post.topic\n        user_export.update_columns(topic_id: topic.id)\n        topic.update_status('closed', true, Discourse.system_user)\n      end\n    end\n\n    def user_archive_export\n      return enum_for(:user_archive_export) unless block_given?\n\n      Post.includes(topic: :category)\n        .where(user_id: @current_user.id)\n        .select(:topic_id, :post_number, :raw, :like_count, :reply_count, :created_at)\n        .order(:created_at)\n        .with_deleted\n        .each do |user_archive|\n        yield get_user_archive_fields(user_archive)\n      end\n    end\n\n    def user_archive_profile_export\n      return enum_for(:user_archive_profile_export) unless block_given?\n\n      UserProfile\n        .where(user_id: @current_user.id)\n        .select(:location, :website, :bio_raw, :views)\n        .each do |user_profile|\n        yield get_user_archive_profile_fields(user_profile)\n      end\n    end\n\n    def preferences_export\n      UserSerializer.new(@current_user, scope: guardian)\n    end\n\n    def preferences_filetype\n      :json\n    end\n\n    def auth_tokens_export\n      return enum_for(:auth_tokens) unless block_given?\n\n      UserAuthToken\n        .where(user_id: @current_user.id)\n        .each do |token|\n        yield [\n          token.id,\n          token.auth_token.to_s[0..4] + \"...\", # hashed and truncated\n          token.prev_auth_token[0..4] + \"...\",\n          token.auth_token_seen,\n          token.client_ip,\n          token.user_agent,\n          token.seen_at,\n          token.rotated_at,\n          token.created_at,\n          token.updated_at,\n        ]\n      end\n    end\n\n    def include_auth_token_logs?\n      # SiteSetting.verbose_auth_token_logging\n      UserAuthTokenLog.where(user_id: @current_user.id).exists?\n    end\n\n    def auth_token_logs_export\n      return enum_for(:auth_token_logs) unless block_given?\n\n      UserAuthTokenLog\n        .where(user_id: @current_user.id)\n        .each do |log|\n        yield [\n          log.id,\n          log.action,\n          log.user_auth_token_id,\n          log.client_ip,\n          log.auth_token.to_s[0..4] + \"...\", # hashed and truncated\n          log.created_at,\n          log.path,\n          log.user_agent,\n        ]\n      end\n    end\n\n    def badges_export\n      return enum_for(:badges_export) unless block_given?\n\n      UserBadge\n        .where(user_id: @current_user.id)\n        .joins(:badge)\n        .select(:badge_id, :granted_at, :post_id, :seq, :granted_by_id, :notification_id, :featured_rank)\n        .order(:granted_at)\n        .each do |ub|\n        yield [\n          ub.badge_id,\n          ub.badge.display_name,\n          ub.granted_at,\n          ub.post_id,\n          ub.seq,\n          # Hide the admin's identity, simply indicate human or system\n          User.human_user_id?(ub.granted_by_id),\n          ub.notification_id,\n          ub.featured_rank,\n        ]\n      end\n    end\n\n    def bookmarks_export\n      return enum_for(:bookmarks_export) unless block_given?\n\n      Bookmark\n        .where(user_id: @current_user.id)\n        .joins(:post)\n        .order(:id)\n        .each do |bkmk|\n        link = ''\n        if guardian.can_see_post?(bkmk.post)\n          link = bkmk.post.full_url\n        end\n        yield [\n          bkmk.post_id,\n          bkmk.topic_id,\n          bkmk.post&.post_number,\n          link,\n          bkmk.name,\n          bkmk.created_at,\n          bkmk.updated_at,\n          bkmk.reminder_at,\n          bkmk.reminder_last_sent_at,\n          bkmk.reminder_set_at,\n          Bookmark.auto_delete_preferences[bkmk.auto_delete_preference],\n        ]\n      end\n    end\n\n    def category_preferences_export\n      return enum_for(:category_preferences_export) unless block_given?\n\n      CategoryUser\n        .where(user_id: @current_user.id)\n        .includes(:category)\n        .merge(Category.secured(guardian))\n        .each do |cu|\n          yield [\n            cu.category_id,\n            piped_category_name(cu.category_id, cu.category),\n            NotificationLevels.all[cu.notification_level],\n            cu.last_seen_at\n          ]\n        end\n    end\n\n    def flags_export\n      return enum_for(:flags_export) unless block_given?\n\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where(post_action_type_id: PostActionType.flag_types.values)\n        .order(:created_at)\n        .each do |pa|\n        yield [\n          pa.id,\n          pa.post_id,\n          PostActionType.flag_types[pa.post_action_type_id],\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n          pa.related_post_id,\n          pa.targets_topic,\n          # renamed to 'was_take_action' to avoid possibility of thinking this is a synonym of agreed_at\n          pa.staff_took_action,\n        ]\n      end\n    end\n\n    def likes_export\n      return enum_for(:likes_export) unless block_given?\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where(post_action_type_id: PostActionType.types[:like])\n        .order(:created_at)\n        .each do |pa|\n        post = Post.with_deleted.find_by(id: pa.post_id)\n        yield [\n          pa.id,\n          pa.post_id,\n          post&.topic_id,\n          post&.post_number,\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n        ]\n      end\n    end\n\n    def include_post_actions?\n      # Most forums should not have post_action records other than flags and likes, but they are possible in historical oddities.\n      PostAction\n        .where(user_id: @current_user.id)\n        .where.not(post_action_type_id: PostActionType.flag_types.values + [PostActionType.types[:like], PostActionType.types[:bookmark]])\n        .exists?\n    end\n\n    def post_actions_export\n      return enum_for(:likes_export) unless block_given?\n      PostAction\n        .with_deleted\n        .where(user_id: @current_user.id)\n        .where.not(post_action_type_id: PostActionType.flag_types.values + [PostActionType.types[:like], PostActionType.types[:bookmark]])\n        .order(:created_at)\n        .each do |pa|\n        yield [\n          pa.id,\n          pa.post_id,\n          PostActionType.types[pa.post_action_type] || pa.post_action_type,\n          pa.created_at,\n          pa.updated_at,\n          pa.deleted_at,\n          self_or_other(pa.deleted_by_id),\n          pa.related_post_id,\n        ]\n      end\n    end\n\n    def queued_posts_export\n      return enum_for(:queued_posts_export) unless block_given?\n\n      # Most Reviewable fields staff-private, but post content needs to be exported.\n      ReviewableQueuedPost\n        .where(created_by: @current_user.id)\n        .order(:created_at)\n        .each do |rev|\n\n        yield [\n          rev.id,\n          Reviewable.statuses[rev.status],\n          rev.category_id,\n          rev.topic_id,\n          rev.payload['raw'],\n          MultiJson.dump(rev.payload.slice(*queued_posts_payload_permitted_keys)),\n        ]\n      end\n    end\n\n    def visits_export\n      return enum_for(:visits_export) unless block_given?\n\n      UserVisit\n        .where(user_id: @current_user.id)\n        .order(visited_at: :asc)\n        .each do |uv|\n        yield [\n          uv.visited_at,\n          uv.posts_read,\n          uv.mobile,\n          uv.time_read,\n        ]\n      end\n    end\n\n    def get_header(entity)\n      if entity == 'user_list'\n        header_array = HEADER_ATTRS_FOR['user_list'] + HEADER_ATTRS_FOR['user_stats'] + HEADER_ATTRS_FOR['user_profile']\n        header_array.concat(HEADER_ATTRS_FOR['user_sso']) if SiteSetting.enable_discourse_connect\n        user_custom_fields = UserField.all\n        if user_custom_fields.present?\n          user_custom_fields.each do |custom_field|\n            header_array.push(\"#{custom_field.name} (custom user field)\")\n          end\n        end\n        header_array.push(\"group_names\")\n      else\n        header_array = HEADER_ATTRS_FOR[entity]\n      end\n\n      header_array\n    end\n\n    private\n\n    def guardian\n      @guardian ||= Guardian.new(@current_user)\n    end\n\n    def piped_category_name(category_id, category)\n      return \"#{category_id}\" if category_id && !category\n      return \"-\" if !guardian.can_see_category?(category)\n      categories = [category.name]\n      while category.parent_category_id && category = category.parent_category\n        categories << category.name\n      end\n      categories.reverse.join(\"|\")\n    end\n\n    def self_or_other(user_id)\n      if user_id.nil?\n        nil\n      elsif user_id == @current_user.id\n        'self'\n      else\n        'other'\n      end\n    end\n\n    def get_user_archive_fields(user_archive)\n      user_archive_array = []\n      topic_data = user_archive.topic\n      user_archive = user_archive.as_json\n      topic_data = Topic.with_deleted.includes(:category).find_by(id: user_archive['topic_id']) if topic_data.nil?\n      return user_archive_array if topic_data.nil?\n\n      categories = piped_category_name(topic_data.category_id, topic_data.category)\n      is_pm = topic_data.archetype == \"private_message\" ? I18n.t(\"csv_export.boolean_yes\") : I18n.t(\"csv_export.boolean_no\")\n      url = \"#{Discourse.base_url}/t/#{topic_data.slug}/#{topic_data.id}/#{user_archive['post_number']}\"\n\n      topic_hash = { \"post\" => user_archive['raw'], \"topic_title\" => topic_data.title, \"categories\" => categories, \"is_pm\" => is_pm, \"url\" => url }\n      user_archive.merge!(topic_hash)\n\n      HEADER_ATTRS_FOR['user_archive'].each do |attr|\n        user_archive_array.push(user_archive[attr])\n      end\n\n      user_archive_array\n    end\n\n    def get_user_archive_profile_fields(user_profile)\n      user_archive_profile = []\n\n      HEADER_ATTRS_FOR['user_archive_profile'].each do |attr|\n        data =\n          if attr == 'bio'\n            user_profile.attributes['bio_raw']\n          else\n            user_profile.attributes[attr]\n          end\n\n          user_archive_profile.push(data)\n      end\n\n      user_archive_profile\n    end\n\n    def queued_posts_payload_permitted_keys\n      # Generated with:\n      #\n      # SELECT distinct json_object_keys(payload) from reviewables\n      # where type = 'ReviewableQueuedPost' and (payload->'old_queued_post_id') IS NULL\n      #\n      # except raw, created_topic_id, created_post_id\n      %w{\n        composer_open_duration_msecs\n        is_poll\n        reply_to_post_number\n        tags\n        title\n        typing_duration_msecs\n      }\n    end\n\n    def notify_user(upload, export_title)\n      post = nil\n\n      if @current_user\n        post = if upload.persisted?\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :csv_export_succeeded,\n            download_link: UploadMarkdown.new(upload).attachment_markdown,\n            export_title: export_title\n          )\n        else\n          SystemMessage.create_from_system_user(@current_user, :csv_export_failed)\n        end\n      end\n\n      post\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'csv'\n\ndescribe Jobs::ExportUserArchive do\n  fab!(:user) { Fabricate(:user, username: \"john_doe\") }\n  fab!(:user2) { Fabricate(:user) }\n  let(:extra) { {} }\n  let(:job) {\n    j = Jobs::ExportUserArchive.new\n    j.current_user = user\n    j.extra = extra\n    j\n  }\n  let(:component) { raise 'component not set' }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:category) { Fabricate(:category_with_definition, name: \"User Archive Category\") }\n  fab!(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n  fab!(:topic) { Fabricate(:topic, category: category) }\n  let(:post) { Fabricate(:post, user: user, topic: topic) }\n\n  def make_component_csv\n    data_rows = []\n    csv_out = CSV.generate do |csv|\n      csv << job.get_header(component)\n      job.public_send(:\"#{component}_export\") do |row|\n        csv << row\n        data_rows << Jobs::ExportUserArchive::HEADER_ATTRS_FOR[component].zip(row.map(&:to_s)).to_h.with_indifferent_access\n      end\n    end\n    [data_rows, csv_out]\n  end\n\n  def make_component_json\n    JSON.parse(MultiJson.dump(job.public_send(:\"#{component}_export\")))\n  end\n\n  context '#execute' do\n    before do\n      _ = post\n      user.user_profile.website = 'https://doe.example.com/john'\n      user.user_profile.save\n      # force a UserAuthTokenLog entry\n      env = create_request_env.merge(\n        'HTTP_USER_AGENT' => 'MyWebBrowser',\n        'REQUEST_PATH' => '/some_path/456852',\n      )\n      cookie_jar = ActionDispatch::Request.new(env).cookie_jar\n      Discourse.current_user_provider.new(env).log_on_user(user, {}, cookie_jar)\n\n      # force a nonstandard post action\n      PostAction.new(user: user, post: post, post_action_type_id: 5).save\n    end\n\n    after do\n      user.uploads.each(&:destroy!)\n    end\n\n    it 'raises an error when the user is missing' do\n      expect { Jobs::ExportCsvFile.new.execute(user_id: user.id + (1 << 20)) }.to raise_error(Discourse::InvalidParameters)\n    end\n\n    it 'works' do\n      expect do\n        Jobs::ExportUserArchive.new.execute(\n          user_id: user.id,\n        )\n      end.to change { Upload.count }.by(1)\n\n      system_message = user.topics_allowed.last\n\n      expect(system_message.title).to eq(I18n.t(\n        \"system_messages.csv_export_succeeded.subject_template\",\n        export_title: \"User Archive\"\n      ))\n\n      upload = system_message.first_post.uploads.first\n\n      expect(system_message.first_post.raw).to eq(I18n.t(\n        \"system_messages.csv_export_succeeded.text_body_template\",\n        download_link: \"[#{upload.original_filename}|attachment](#{upload.short_url}) (#{upload.human_filesize})\"\n      ).chomp)\n\n      expect(system_message.id).to eq(UserExport.last.topic_id)\n      expect(system_message.closed).to eq(true)\n\n      files = []\n      Zip::File.open(Discourse.store.path_for(upload)) do |zip_file|\n        zip_file.each { |entry| files << entry.name }\n      end\n\n      expect(files.size).to eq(Jobs::ExportUserArchive::COMPONENTS.length)\n      expect(files.find { |f| f == 'user_archive.csv' }).to_not be_nil\n      expect(files.find { |f| f == 'category_preferences.csv' }).to_not be_nil\n    end\n\n    it 'sends a message if it fails' do\n      SiteSetting.max_export_file_size_kb = 1\n\n      expect do\n        Jobs::ExportUserArchive.new.execute(\n          user_id: user.id,\n        )\n      end.to change { Upload.count }.by(0)\n\n      system_message = user.topics_allowed.last\n      expect(system_message.title).to eq(I18n.t(\"system_messages.csv_export_failed.subject_template\"))\n    end\n  end\n\n  context 'user_archive posts' do\n    let(:component) { 'user_archive' }\n    let(:subsubcategory) { Fabricate(:category_with_definition, parent_category_id: subcategory.id) }\n    let(:subsubtopic) { Fabricate(:topic, category: subsubcategory) }\n    let(:subsubpost) { Fabricate(:post, user: user, topic: subsubtopic) }\n\n    let(:normal_post) { Fabricate(:post, user: user, topic: topic) }\n    let(:reply) { PostCreator.new(user2, raw: 'asdf1234qwert7896', topic_id: topic.id, reply_to_post_number: normal_post.post_number).create }\n\n    let(:message) { Fabricate(:private_message_topic) }\n    let(:message_post) { Fabricate(:post, user: user, topic: message) }\n\n    it 'properly exports posts' do\n      SiteSetting.max_category_nesting = 3\n      [reply, subsubpost, message_post]\n\n      PostActionCreator.like(user2, normal_post)\n\n      rows = []\n      job.user_archive_export do |row|\n        rows << Jobs::ExportUserArchive::HEADER_ATTRS_FOR['user_archive'].zip(row).to_h\n      end\n\n      expect(rows.length).to eq(3)\n\n      post1 = rows.find { |r| r['topic_title'] == topic.title }\n      post2 = rows.find { |r| r['topic_title'] == subsubtopic.title }\n      post3 = rows.find { |r| r['topic_title'] == message.title }\n\n      expect(post1[\"categories\"]).to eq(\"#{category.name}\")\n      expect(post2[\"categories\"]).to eq(\"#{category.name}|#{subcategory.name}|#{subsubcategory.name}\")\n      expect(post3[\"categories\"]).to eq(\"-\")\n\n      expect(post1[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_no\"))\n      expect(post2[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_no\"))\n      expect(post3[\"is_pm\"]).to eq(I18n.t(\"csv_export.boolean_yes\"))\n\n      expect(post1[\"post\"]).to eq(normal_post.raw)\n      expect(post2[\"post\"]).to eq(subsubpost.raw)\n      expect(post3[\"post\"]).to eq(message_post.raw)\n\n      expect(post1['like_count']).to eq(1)\n      expect(post2['like_count']).to eq(0)\n\n      expect(post1['reply_count']).to eq(1)\n      expect(post2['reply_count']).to eq(0)\n    end\n\n    it 'can export a post from a deleted category' do\n      cat2 = Fabricate(:category)\n      topic2 = Fabricate(:topic, category: cat2, user: user)\n      _post2 = Fabricate(:post, topic: topic2, user: user)\n\n      cat2_id = cat2.id\n      cat2.destroy!\n\n      _, csv_out = make_component_csv\n      expect(csv_out).to match cat2_id.to_s\n    end\n\n    it \"can export a post from a secure category, obscuring the category name\" do\n      cat2 = Fabricate(:private_category, group: Fabricate(:group), name: \"Secret Cat\")\n      topic2 = Fabricate(:topic, category: cat2, user: user, title: \"This is a test secure topic\")\n      _post2 = Fabricate(:post, topic: topic2, user: user)\n      data, csv_out = make_component_csv\n      expect(csv_out).not_to match \"Secret Cat\"\n      expect(data.length).to eq(1)\n      expect(data[0][:topic_title]).to eq(\"This is a test secure topic\")\n      expect(data[0][:categories]).to eq(\"-\")\n    end\n  end\n\n  context 'preferences' do\n    let(:component) { 'preferences' }\n\n    before do\n      user.user_profile.website = 'https://doe.example.com/john'\n      user.user_profile.bio_raw = \"I am John Doe\\n\\nHere I am\"\n      user.user_profile.save\n      user.user_option.text_size = :smaller\n      user.user_option.automatically_unpin_topics = false\n      user.user_option.save\n    end\n\n    it 'properly includes the profile fields' do\n      _serializer = job.preferences_export\n      # puts MultiJson.dump(serializer, indent: 4)\n      output = make_component_json\n      payload = output['user']\n\n      expect(payload['website']).to match('doe.example.com')\n      expect(payload['bio_raw']).to match(\"Doe\\n\\nHere\")\n      expect(payload['user_option']['automatically_unpin_topics']).to eq(false)\n      expect(payload['user_option']['text_size']).to eq('smaller')\n    end\n  end\n\n  context 'auth tokens' do\n    let(:component) { 'auth_tokens' }\n\n    before do\n      env = create_request_env.merge(\n        'HTTP_USER_AGENT' => 'MyWebBrowser',\n        'REQUEST_PATH' => '/some_path/456852',\n      )\n      cookie_jar = ActionDispatch::Request.new(env).cookie_jar\n      Discourse.current_user_provider.new(env).log_on_user(user, {}, cookie_jar)\n    end\n\n    it 'properly includes session records' do\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(1)\n\n      expect(data[0]['user_agent']).to eq('MyWebBrowser')\n    end\n\n    context 'auth token logs' do\n      let(:component) { 'auth_token_logs' }\n      it 'includes details such as the path' do\n        data, _csv_out = make_component_csv\n        expect(data.length).to eq(1)\n\n        expect(data[0]['action']).to eq('generate')\n        expect(data[0]['path']).to eq('/some_path/456852')\n      end\n    end\n  end\n\n  context 'badges' do\n    let(:component) { 'badges' }\n\n    let(:badge1) { Fabricate(:badge) }\n    let(:badge2) { Fabricate(:badge, multiple_grant: true) }\n    let(:badge3) { Fabricate(:badge, multiple_grant: true) }\n    let(:day_ago) { 1.day.ago }\n\n    it 'properly includes badge records' do\n      grant_start = Time.now.utc\n      BadgeGranter.grant(badge1, user)\n      BadgeGranter.grant(badge2, user)\n      BadgeGranter.grant(badge2, user, granted_by: admin)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n      BadgeGranter.grant(badge3, user, post_id: Fabricate(:post).id)\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(6)\n\n      expect(data[0]['badge_id']).to eq(badge1.id.to_s)\n      expect(data[0]['badge_name']).to eq(badge1.display_name)\n      expect(data[0]['featured_rank']).to_not eq('')\n      expect(DateTime.parse(data[0]['granted_at'])).to be >= DateTime.parse(grant_start.to_s)\n      expect(data[2]['granted_manually']).to eq('true')\n      expect(Post.find(data[3]['post_id'])).to_not be_nil\n    end\n\n  end\n\n  context 'bookmarks' do\n    let(:component) { 'bookmarks' }\n\n    let(:name) { 'Collect my thoughts on this' }\n    let(:manager) { BookmarkManager.new(user) }\n    let(:topic1) { Fabricate(:topic) }\n    let(:post1) { Fabricate(:post, topic: topic1, post_number: 5) }\n    let(:post2) { Fabricate(:post) }\n    let(:post3) { Fabricate(:post) }\n    let(:message) { Fabricate(:private_message_topic) }\n    let(:post4) { Fabricate(:post, topic: message) }\n    let(:reminder_at) { 1.day.from_now }\n\n    it 'properly includes bookmark records' do\n      now = freeze_time '2017-03-01 12:00'\n\n      bkmk1 = manager.create(post_id: post1.id, name: name)\n      update1_at = now + 1.hours\n      bkmk1.update(name: 'great food recipe', updated_at: update1_at)\n\n      manager.create(post_id: post2.id, name: name, reminder_at: reminder_at, options: { auto_delete_preference: Bookmark.auto_delete_preferences[:when_reminder_sent] })\n      twelve_hr_ago = freeze_time now - 12.hours\n      pending_reminder = manager.create(post_id: post3.id, name: name, reminder_at: now - 8.hours)\n      freeze_time now\n\n      tau_record = message.topic_allowed_users.create!(user_id: user.id)\n      manager.create(post_id: post4.id, name: name)\n      tau_record.destroy!\n\n      BookmarkReminderNotificationHandler.send_notification(pending_reminder)\n\n      data, _csv_out = make_component_csv\n\n      expect(data.length).to eq(4)\n\n      expect(data[0]['post_id']).to eq(post1.id.to_s)\n      expect(data[0]['topic_id']).to eq(topic1.id.to_s)\n      expect(data[0]['post_number']).to eq('5')\n      expect(data[0]['link']).to eq(post1.full_url)\n      expect(DateTime.parse(data[0]['updated_at'])).to eq(DateTime.parse(update1_at.to_s))\n\n      expect(data[1]['name']).to eq(name)\n      expect(DateTime.parse(data[1]['reminder_at'])).to eq(DateTime.parse(reminder_at.to_s))\n      expect(data[1]['auto_delete_preference']).to eq('when_reminder_sent')\n\n      expect(DateTime.parse(data[2]['created_at'])).to eq(DateTime.parse(twelve_hr_ago.to_s))\n      expect(DateTime.parse(data[2]['reminder_last_sent_at'])).to eq(DateTime.parse(now.to_s))\n      expect(data[2]['reminder_set_at']).to eq('')\n\n      expect(data[3]['topic_id']).to eq(message.id.to_s)\n      expect(data[3]['link']).to eq('')\n    end\n\n  end\n\n  context 'category_preferences' do\n    let(:component) { 'category_preferences' }\n\n    let(:subsubcategory) { Fabricate(:category_with_definition, parent_category_id: subcategory.id, name: \"User Archive Subcategory\") }\n    let(:announcements) { Fabricate(:category_with_definition, name: \"Announcements\") }\n    let(:deleted_category) { Fabricate(:category, name: \"Deleted Category\") }\n    let(:secure_category_group) { Fabricate(:group) }\n    let(:secure_category) { Fabricate(:private_category, group: secure_category_group, name: \"Super Secret Category\") }\n\n    let(:reset_at) { DateTime.parse('2017-03-01 12:00') }\n\n    before do\n      SiteSetting.max_category_nesting = 3\n\n      # TopicsController#reset-new?category_id=&include_subcategories=true\n      category_ids = [subcategory.id, subsubcategory.id]\n      category_ids.each do |category_id|\n        user\n          .category_users\n          .where(category_id: category_id)\n          .first_or_initialize\n          .update!(last_seen_at: reset_at, notification_level: NotificationLevels.all[:regular])\n      end\n\n      # Set Watching First Post on announcements, Tracking on subcategory, Muted on deleted, nothing on subsubcategory\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:watching_first_post], announcements.id)\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:tracking], subcategory.id)\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:muted], deleted_category.id)\n\n      deleted_category.destroy!\n    end\n\n    it 'correctly exports the CategoryUser table, excluding deleted categories' do\n      data, _csv_out = make_component_csv\n\n      expect(data.find { |r| r['category_id'] == category.id.to_s }).to be_nil\n      expect(data.find { |r| r['category_id'] == deleted_category.id.to_s }).to be_nil\n      expect(data.length).to eq(3)\n      data.sort! { |a, b| a['category_id'].to_i <=> b['category_id'].to_i }\n\n      expect(data[0][:category_id]).to eq(subcategory.id.to_s)\n      expect(data[0][:notification_level].to_s).to eq('tracking')\n      expect(DateTime.parse(data[0][:dismiss_new_timestamp])).to eq(reset_at)\n\n      expect(data[1][:category_id]).to eq(subsubcategory.id.to_s)\n      expect(data[1][:category_names]).to eq(\"#{category.name}|#{subcategory.name}|#{subsubcategory.name}\")\n      expect(data[1][:notification_level]).to eq('regular')\n      expect(DateTime.parse(data[1][:dismiss_new_timestamp])).to eq(reset_at)\n\n      expect(data[2][:category_id]).to eq(announcements.id.to_s)\n      expect(data[2][:category_names]).to eq(announcements.name)\n      expect(data[2][:notification_level]).to eq('watching_first_post')\n      expect(data[2][:dismiss_new_timestamp]).to eq('')\n    end\n\n    it \"does not include any secure categories the user does not have access to, even if the user has a CategoryUser record\" do\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:muted], secure_category.id)\n      data, _csv_out = make_component_csv\n\n      expect(data.any? { |r| r['category_id'] == secure_category.id.to_s }).to eq(false)\n      expect(data.length).to eq(3)\n    end\n\n    it \"does include secure categories that the user has access to\" do\n      CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:muted], secure_category.id)\n      GroupUser.create!(user: user, group: secure_category_group)\n      data, _csv_out = make_component_csv\n\n      expect(data.any? { |r| r['category_id'] == secure_category.id.to_s }).to eq(true)\n      expect(data.length).to eq(4)\n    end\n  end\n\n  context 'flags' do\n    let(:component) { 'flags' }\n    let(:other_post) { Fabricate(:post, user: admin) }\n    let(:post3) { Fabricate(:post) }\n    let(:post4) { Fabricate(:post) }\n\n    it 'correctly exports flags' do\n      result0 = PostActionCreator.notify_moderators(user, other_post, \"helping out the admins\")\n      PostActionCreator.spam(user, post3)\n      PostActionDestroyer.destroy(user, post3, :spam)\n      PostActionCreator.inappropriate(user, post3)\n\n      result3 = PostActionCreator.off_topic(user, post4)\n      result3.reviewable.perform(admin, :agree_and_keep)\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(4)\n      data.sort_by! { |row| row['post_id'].to_i }\n\n      expect(data[0]['post_id']).to eq(other_post.id.to_s)\n      expect(data[0]['flag_type']).to eq('notify_moderators')\n      expect(data[0]['related_post_id']).to eq(result0.post_action.related_post_id.to_s)\n\n      expect(data[1]['flag_type']).to eq('spam')\n      expect(data[2]['flag_type']).to eq('inappropriate')\n      expect(data[1]['deleted_at']).to_not be_empty\n      expect(data[1]['deleted_by']).to eq('self')\n      expect(data[2]['deleted_at']).to be_empty\n\n      expect(data[3]['post_id']).to eq(post4.id.to_s)\n      expect(data[3]['flag_type']).to eq('off_topic')\n      expect(data[3]['deleted_at']).to be_empty\n    end\n  end\n\n  context 'likes' do\n    let(:component) { 'likes' }\n    let(:other_post) { Fabricate(:post, user: admin) }\n    let(:post3) { Fabricate(:post) }\n\n    it 'correctly exports likes' do\n      PostActionCreator.like(user, other_post)\n      PostActionCreator.like(user, post3)\n      PostActionCreator.like(admin, post3)\n      PostActionDestroyer.destroy(user, post3, :like)\n      post3.destroy!\n\n      data, _csv_out = make_component_csv\n      expect(data.length).to eq(2)\n      data.sort_by! { |row| row['post_id'].to_i }\n\n      expect(data[0]['post_id']).to eq(other_post.id.to_s)\n      expect(data[1]['post_id']).to eq(post3.id.to_s)\n      expect(data[1]['deleted_at']).to_not be_empty\n      expect(data[1]['deleted_by']).to eq('self')\n    end\n  end\n\n  context 'queued posts' do\n    let(:component) { 'queued_posts' }\n    let(:reviewable_post) { Fabricate(:reviewable_queued_post, topic: topic, created_by: user) }\n    let(:reviewable_topic) { Fabricate(:reviewable_queued_post_topic, category: category, created_by: user) }\n\n    it 'correctly exports queued posts' do\n      SiteSetting.tagging_enabled = true\n\n      reviewable_post.perform(admin, :reject_post)\n      reviewable_topic.payload['tags'] = ['example_tag']\n      result = reviewable_topic.perform(admin, :approve_post)\n      expect(result.success?).to eq(true)\n\n      data, csv_out = make_component_csv\n      expect(data.length).to eq(2)\n      expect(csv_out).to_not match(admin.username)\n\n      approved = data.find { |el| el[\"verdict\"] === \"approved\" }\n      rejected = data.find { |el| el[\"verdict\"] === \"rejected\" }\n\n      expect(approved['other_json']).to match('example_tag')\n      expect(rejected['post_raw']).to eq('hello world post contents.')\n      expect(rejected['other_json']).to match('reply_to_post_number')\n    end\n  end\n\n  context 'visits' do\n    let(:component) { 'visits' }\n\n    it 'correctly exports the UserVisit table' do\n      freeze_time '2017-03-01 12:00'\n\n      UserVisit.create(user_id: user.id, visited_at: 1.minute.ago, posts_read: 1, mobile: false, time_read: 10)\n      UserVisit.create(user_id: user.id, visited_at: 2.days.ago, posts_read: 2, mobile: false, time_read: 20)\n      UserVisit.create(user_id: user.id, visited_at: 1.week.ago, posts_read: 3, mobile: true, time_read: 30)\n      UserVisit.create(user_id: user.id, visited_at: 1.year.ago, posts_read: 4, mobile: false, time_read: 40)\n      UserVisit.create(user_id: user2.id, visited_at: 1.minute.ago, posts_read: 1, mobile: false, time_read: 50)\n\n      data, _csv_out = make_component_csv\n\n      # user2's data is not mixed in\n      expect(data.length).to eq(4)\n      expect(data.find { |r| r['time_read'] == 50 }).to be_nil\n\n      expect(data[0]['visited_at']).to eq('2016-03-01')\n      expect(data[0]['posts_read']).to eq('4')\n      expect(data[0]['time_read']).to eq('40')\n      expect(data[1]['mobile']).to eq('true')\n      expect(data[3]['visited_at']).to eq('2017-03-01')\n    end\n  end\nend\n"], "filenames": ["app/jobs/regular/export_user_archive.rb", "spec/jobs/export_user_archive_spec.rb"], "buggy_code_start_loc": [264, 18], "buggy_code_end_loc": [440, 366], "fixing_code_start_loc": [264, 18], "fixing_code_end_loc": [440, 395], "type": "CWE-200", "message": "Discourse is an open source discussion platform. Versions 2.8.2 and prior in the `stable` branch, 2.9.0.beta3 and prior in the `beta` branch, and 2.9.0.beta3 and prior in the `tests-passed` branch are vulnerable to a data leak. Users can request an export of their own activity. Sometimes, due to category settings, they may have category membership for a secure category. The name of this secure category is shown to the user in the export. The same thing occurs when the user's post has been moved to a secure category. A patch for this issue is available in the `main` branch of Discourse's GitHub repository and is anticipated to be part of future releases.", "other": {"cve": {"id": "CVE-2022-24782", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-24T21:15:13.933", "lastModified": "2022-04-07T12:58:21.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Versions 2.8.2 and prior in the `stable` branch, 2.9.0.beta3 and prior in the `beta` branch, and 2.9.0.beta3 and prior in the `tests-passed` branch are vulnerable to a data leak. Users can request an export of their own activity. Sometimes, due to category settings, they may have category membership for a secure category. The name of this secure category is shown to the user in the export. The same thing occurs when the user's post has been moved to a secure category. A patch for this issue is available in the `main` branch of Discourse's GitHub repository and is anticipated to be part of future releases."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. Las versiones 2.8.2 y anteriores en la rama \"stable\", versiones 2.9.0.beta3 y anteriores en la rama \"beta\", y versiones 2.9.0.beta3 y anteriores en la rama \"tests-passed\" son vulnerables a un filtrado de informaci\u00f3n. Los usuarios pueden solicitar una exportaci\u00f3n de su propia actividad. A veces, debido a la configuraci\u00f3n de la categor\u00eda, pueden tener una pertenencia a una categor\u00eda segura. El nombre de esta categor\u00eda segura es mostrada al usuario en la exportaci\u00f3n. Lo mismo ocurre cuando el post del usuario ha sido movido a una categor\u00eda segura. Un parche para este problema est\u00e1 disponible en la rama \"main\" del repositorio GitHub de Discourse y esta anticipado que forme parte de futuras versiones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.2", "matchCriteriaId": "92530146-660F-4474-A2C9-E12020382560"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/9d5737fd28374cc876c070f6c3a931a8071ec356", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/16273", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-c3cq-w899-f343", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/9d5737fd28374cc876c070f6c3a931a8071ec356"}}