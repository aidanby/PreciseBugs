{"buggy_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, mrmacete, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n#include <r_hash.h>\n\n// TODO: deprecate bprintf and use Eprintf (bin->self)\n#define bprintf if (bin->verbose) eprintf\n#define Eprintf if (mo->verbose) eprintf\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\ntypedef struct {\n\tut8 * imports;\n\tRSkipList *relocs;\n} RWalkBindChainsContext;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 read_uleb128(ut8 **p, ut8 *end) {\n\tconst char *error = NULL;\n\tut64 v;\n\t*p = (ut8 *)r_uleb128 (*p, end - *p, &v, &error);\n\tif (error) {\n\t\teprintf (\"%s\", error);\n\t\tR_FREE (error);\n\t\treturn UT64_MAX;\n\t}\n\treturn v;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) *bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t) *bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 offset_to_vaddr(struct MACH0_(obj_t) *bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RBinFile *bf, ut64 offset) {\n\tr_return_val_if_fail (bf && bf->rbin, offset);\n\tRIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin? offset_to_vaddr (bin, offset): offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) *bin) {\n\t/*\n\t * These definitions are used by r2 -nn\n\t * must be kept in sync with libr/bin/d/macho\n\t */\n\tsdb_set (bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\" \"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\" \"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\" \"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\" \"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\" \"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\" \"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\" \"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\", 0);\n\tsdb_set (bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) *bin) {\n\tut8 magicbytes[4] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0 + bin->header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0 + bin->header_at, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats (bin);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\tchar section_flagname[128];\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tr_sys_perror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tchar *segment_flagname = NULL;\n#if R_BIN_MACH064\n\tsegment_flagname = r_str_newf (\"mach0_segment64_%u.offset\", (ut32)j);\n#else\n\tsegment_flagname = r_str_newf (\"mach0_segment_%u.offset\", (ut32)j);\n#endif\n\tsdb_num_set (bin->kv, segment_flagname, off, 0);\n\tfree (segment_flagname);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tr_sys_perror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.offset\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\t\n\t\t\tsdb_num_set (bin->kv, section_flagname, offset, 0);\n#if R_BIN_MACH064\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section64\", 0);\n#else\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section\", 0);\n#endif\n\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) error_message = x; goto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) *mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof (struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = r_buf_read_at (mo->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tEprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (symt, be);\n\tst.cmdsize = r_read_ble32 (symt + 4, be);\n\tst.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;\n\tst.nsyms = r_read_ble32 (symt + 12, be);\n\tst.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;\n\tst.strsize = r_read_ble32 (symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError (\"fail\");\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, mo->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tError (\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError (\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (mo->b, st.stroff, (ut8*)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError (\"Error: read (symstr)\");\n\t\t}\n\t\tut64 max_nsymtab = (r_buf_size (mo->b) - st.symoff) / sizeof (struct MACH0_(nlist));\n\t\tif (mo->nsymtab > max_nsymtab || !(mo->symtab = calloc (mo->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof (struct MACH0_(nlist)));\n\t\t\tlen = r_buf_read_at (mo->b, at, nlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tError (\"read (nlist)\");\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = r_read_ble32 (nlst, be);\n\t\t\tmo->symtab[i].n_type = r_read_ble8 (nlst + 4);\n\t\t\tmo->symtab[i].n_sect = r_read_ble8 (nlst + 5);\n\t\t\tmo->symtab[i].n_desc = r_read_ble16 (nlst + 6, be);\n#if R_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = r_read_ble64 (&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = r_read_ble32 (&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tR_FREE (mo->symstr);\n\tR_FREE (mo->symtab);\n\tEprintf (\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof (struct dylib_table_of_contents)))) {\n\t\t\tr_sys_perror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tut64 max_nmodtab = (bin->size - bin->dysymtab.modtaboff) / sizeof (struct MACH0_(dylib_module));\n\tif (bin->nmodtab > 0 && bin->nmodtab <= max_nmodtab) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof (struct MACH0_(dylib_module))))) {\n\t\t\tr_sys_perror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof (ut32)))) {\n\t\t\tr_sys_perror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn r_str_ndup ((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(RBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic;\t\t/* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length;\t/* total length of CodeDirectory blob */\n\t\tuint32_t version;\t/* compatibility version */\n\t\tuint32_t flags;\t\t/* setup and mode flags */\n\t\tuint32_t hashOffset;\t/* offset of hash slot element at index zero */\n\t\tuint32_t identOffset;\t/* offset of identifier string */\n\t\tuint32_t nSpecialSlots;\t/* number of special hash slots */\n\t\tuint32_t nCodeSlots;\t/* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit;\t/* limit to main image signature range */\n\t\tuint8_t hashSize;\t/* size of each hash in bytes */\n\t\tuint8_t hashType;\t/* type of hash (cdHashType* constants) */\n\t\tuint8_t platform;\t/* unused (must be zero) */\n\t\tuint8_t\tpageSize;\t/* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2;\t/* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc (1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf (\"Offset: 0x%08\"PFMT64x\"\\n\", off);\n\tr_buf_read_at (b, off, p, datasize);\n\tCS_CodeDirectory cscd = {0};\n\t#define READFIELD(x) cscd.x = r_read_ble32 (p + r_offsetof (CS_CodeDirectory, x), 1)\n\t#define READFIELD8(x) cscd.x = p[r_offsetof (CS_CodeDirectory, x)]\n\tREADFIELD (length);\n\tREADFIELD (version);\n\tREADFIELD (flags);\n\tREADFIELD (hashOffset);\n\tREADFIELD (identOffset);\n\tREADFIELD (nSpecialSlots);\n\tREADFIELD (nCodeSlots);\n\tREADFIELD (hashSize);\n\tREADFIELD (teamIDOffset);\n\tREADFIELD8 (hashType);\n\tREADFIELD (pageSize);\n\tREADFIELD (codeLimit);\n\teprintf (\"Version: %x\\n\", cscd.version);\n\teprintf (\"Flags: %x\\n\", cscd.flags);\n\teprintf (\"Length: %d\\n\", cscd.length);\n\teprintf (\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf (\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf (\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf (\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf (\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString (p, cscd.identOffset, psize);\n\teprintf (\"Identity: %s\\n\", identity);\n\tchar *teamId = readString (p, cscd.teamIDOffset, psize);\n\teprintf (\"TeamID: %s\\n\", teamId);\n\teprintf (\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree (identity);\n\tfree (teamId);\n\n\tint hashSize = 20; // SHA1 is default\n\tint algoType = R_HASH_SHA1;\n\tconst char *hashName = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\thashSize = 20;\n\t\thashName = \"sha1\";\n\t\talgoType = R_HASH_SHA1;\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\thashSize = 32;\n\t\talgoType = R_HASH_SHA256;\n\t\thashName = \"sha256\";\n\t\tbreak;\n\t}\n\t// computed cdhash\n\tRHash *ctx = r_hash_new (true, algoType);\n\tint fofsz = cscd.length;\n\tif (fofsz > 0 && fofsz < (r_buf_size (b) - off)) {\n\t\tut8 *fofbuf = calloc (fofsz, 1);\n\t\tif (fofbuf) {\n\t\t\tint i;\n\t\t\tif (r_buf_read_at (b, off, fofbuf, fofsz) != fofsz) {\n\t\t\t\teprintf (\"Invalid cdhash offset/length values\\n\");\n\t\t\t}\n\t\t\tr_hash_do_begin (ctx, algoType);\n\t\t\tif (algoType == R_HASH_SHA1) {\n\t\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t\t} else {\n\t\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t\t}\n\t\t\tr_hash_do_end (ctx, algoType);\n\t\t\teprintf (\"ph %s @ 0x%\"PFMT64x\"!%d\\n\", hashName, off, fofsz);\n\t\t\teprintf (\"ComputedCDHash: \");\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t\teprintf (\"\\n\");\n\t\t\tfree (fofbuf);\n\t\t}\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf (\"Hashed region: 0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * hashSize;\n\t\teprintf (\"0x%08\"PFMT64x\"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < hashSize; k++) {\n\t\t\teprintf (\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = R_MIN (sizeof (fofbuf), cscd.codeLimit - fof);\n\t\tr_buf_read_at (b, fof, fofbuf, sizeof (fofbuf));\n\t\tr_hash_do_begin (ctx, algoType);\n\t\tif (algoType == R_HASH_SHA1) {\n\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t} else {\n\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t}\n\t\tr_hash_do_end (ctx, algoType);\n\t\tif (memcmp (hash + idx, ctx->digest, hashSize)) {\n\t\t\teprintf (\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"  OK\");\n\t\t}\n\t\teprintf (\"\\n\");\n\t}\n\tr_hash_free (ctx);\n\tfree (p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {0};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {0};\n\tstruct super_blob_t super = {{0}};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_buf_read_ble32_at (bin->b, data, mach0_endian);\n\tsuper.blob.length = r_buf_read_ble32_at (bin->b, data + 4, mach0_endian);\n\tsuper.count = r_buf_read_ble32_at (bin->b, data + 8, mach0_endian);\n\tchar *verbose = r_sys_getenv (\"RABIN2_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree (verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, mach0_endian);\n\t\tidx.offset = r_read_ble32 (&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = {0};\n\t\t\t\tentitlements.magic = r_buf_read_ble32_at (bin->b, off, mach0_endian);\n\t\t\t\tentitlements.length = r_buf_read_ble32_at (bin->b, off + 4, mach0_endian);\n\t\t\t\tlen = entitlements.length - sizeof (struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < r_buf_size (bin->b)) {\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + sizeof (struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory (bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = {0};\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset, header, sizeof (header));\n\t\t\t\tut32 length = R_MIN (UT16_MAX, r_read_ble32 (header + 4, 1));\n\t\t\t\tut8 *p = calloc (length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32*)p;\n\t\t\t\t\teprintf (\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf (\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf (\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t\t{\n\t\t\t\tut8 p[256];\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 16, p, sizeof (p));\n\t\t\t\tp[sizeof (p) - 1] = 0;\n\t\t\t\tut32 slot_size = r_read_ble32 (p + 8, 1);\n\t\t\t\tif (slot_size < sizeof (p)) {\n\t\t\t\t\tut32 ident_size = r_read_ble32 (p + 8, 1);\n\t\t\t\t\tif (!ident_size || ident_size > sizeof (p) - 28) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar *ident = r_str_ndup ((const char *)p + 28, ident_size);\n\t\t\t\t\tif (ident) {\n\t\t\t\t\t\tsdb_set (bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\t\tfree (ident);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"Invalid code slot size\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) *bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = r_read_ble32 (tmp, bin->big_endian);\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size ||\n\t\toff + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command) + sizeof (flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tcount = r_read_ble32 (tmp, bin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc (1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset (bin->libs[lib], 0, R_BIN_MACH0_STRING_LENGTH);\n\tlen = r_buf_read_at (bin->b, off + dl.dylib.name,\n\t\t(ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH - 1);\n\tbin->libs[lib][R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic size_t get_word_size(struct MACH0_(obj_t) *bin) {\n\tconst size_t word_size = MACH0_(get_bits)(bin) / 8;\n\treturn R_MAX (word_size, 4);\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) *bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\tchar cmd_flagname[128];\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size) {\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylinker\", 0);\n\t\t\t\tR_FREE (bin->intrp);\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8*)malloc (datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\tr_buf_read_at (bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = r_read_ble32 (db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = r_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = r_read_ble16 (db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = offset_to_vaddr(bin, dw);\n\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf (\"Cd 4 %d @ 0x%\"PFMT64x\"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\t\tut8 buf[8];\n\t\t\t\tif (r_buf_read_at (bin->b, off + 8, buf, sizeof (buf)) == sizeof (buf)) {\n\t\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t\t}\n\t\t\t\t\thas_chained_fixups = parse_chained_fixups (bin, dataoff, datasize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n#if 0\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"reconstructing chained fixups\\n\");\n\t\t}\n#endif\n\t\treconstruct_chained_fixup (bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) *mo) {\n\tif (!init_hdr (mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items (mo)) {\n\t\tEprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {\n\tr_return_if_fail (options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n}\n\nstatic void *duplicate_ptr(void *p) {\n\treturn p;\n}\n\nstatic void free_only_key(HtPPKv *kv) {\n\tfree (kv->key);\n}\n\nstatic size_t ptr_size(void *c) {\n\t// :D\n\treturn 8;\n}\n\n// XXX should be deprecated its never called\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (options) {\n\t\tbin->verbose = options->verbose;\n\t\tbin->header_at = options->header_at;\n\t\tbin->symbols_off = options->symbols_off;\n\t}\n\tbin->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8 *)r_file_slurp (file, &binsz);\n\tbin->size = binsz;\n\tif (!buf) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->imports_by_name = ht_pp_new ((HtPPDupValue)duplicate_ptr, free_only_key, (HtPPCalcSizeV)ptr_size);\n\treturn bin;\n}\n\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options) {\n\tr_return_val_if_fail (buf, NULL);\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = r_buf_ref (buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\t\tbin->size = r_buf_size (bin->b);\n\t\tif (options) {\n\t\t\tbin->verbose = options->verbose;\n\t\t\tbin->header_at = options->header_at;\n\t\t\tbin->symbols_off = options->symbols_off;\n\t\t}\n\t\tif (!init (bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool __isDataSection(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRList *MACH0_(get_segments)(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)r_bin_section_free);\n\tsize_t i, j;\n\n\t/* for core files */\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSection *s = r_bin_section_new (NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t//TODO s->flags = seg->flags;\n\t\t\ts->name = r_str_ndup (seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\tr_str_filter (s->name, -1);\n\t\t\ts->perm = prot2perm (seg->initprot);\n\t\t\ts->add = true;\n\t\t\tr_list_append (list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = R_MIN (bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRBinSection *s = R_NEW0 (RBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t//s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = r_str_ndup (bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = r_str_newf (\"%u.%s\", (ut32)i, bin->segs[segment_index].segname);\n\t\t\ts->name = r_str_newf (\"%s.%s\", segment_name, section_name);\n\t\t\ts->is_data = __isDataSection (s);\n\t\t\tif (strstr (section_name, \"interpos\") || strstr (section_name, \"__mod_\")) {\n#if R_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = r_str_newf (\"Cd %d[%\"PFMT64d\"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\tr_list_append (list, s);\n\t\t\tfree (segment_name);\n\t\t\tfree (section_name);\n\t\t}\n\t}\n\treturn list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, 16);\n\t\t\tsectname[16] = 0;\n\t\t\tr_str_filter (sectname, -1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc (bin->nsects + 1, sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, 17);\n\t\tr_str_filter (sectname, -1);\n\t\tr_str_ncpy (raw_segname, bin->sects[i].segname, 16);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) *bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf (\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf (\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup (symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = r_str_newf (\"%\"PFMT64x\".%s\", addr, name);\n\tht_pp_find (hash, key, &found);\n\tif (found) {\n\t\tfree (key);\n\t\treturn true;\n\t}\n\tht_pp_insert (hash, key, \"1\");\n\tfree (key);\n\treturn false;\n}\n\nstatic char *get_name(struct MACH0_(obj_t) *mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char*)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = r_str_ndup (symstr, len);\n\t\tif (filter) {\n\t\t\tr_str_filter (res, -1);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) *bin, RExportsIterator iterator, void *ctx) {\n\tRList *states = NULL;\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn 0;\n\t}\n\tut8 *trie = calloc (size + 1, 1);\n\tif (!trie) {\n\t\treturn 0;\n\t}\n\tut8 *end = trie + size;\n\tif (r_buf_read_at (bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = r_list_newf ((RListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = R_NEW0 (RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\tr_list_push (states, root);\n\n\tdo {\n\t\tRTrieState * state = r_list_get_top (states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128 (&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128 (&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128 (&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128 (&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen ((char*) p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar * name = NULL;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\tr_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = r_str_append (name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar * stub_name = r_str_newf (\"stub.%s\", name);\n\t\t\t\t\titerator (bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator (bin, name, flags, resolver, ctx);\n\t\t\t\t\tR_FREE (stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator (bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tR_FREE (name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128 (&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\tfree (r_list_pop (states));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState * next = R_NEW0 (RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *) p;\n\t\tp += strlen (next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128 (&p, end);\n\t\tif (tr == UT64_MAX || tr >= size) {\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\tif (next->node >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRListIter *it;\n\t\t\tRTrieState *s;\n\t\t\tr_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tR_FREE (next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\tr_list_push (states, next);\n\t} while (r_list_length (states));\n\nbeach:\n\tr_list_free (states);\n\tR_FREE (trie);\n\treturn count;\n}\n\nstatic void fill_exports_list(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRList *list = (RList*) ctx;\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn;\n\t}\n\tsym->vaddr = offset_to_vaddr (bin, offset);\n\tsym->paddr = offset;\n\tsym->type = \"EXT\";\n\tsym->name = strdup (name);\n\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\tr_list_append (list, sym);\n}\n\n// TODO: Return RList<RBinSymbol> // 2x speedup\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin) {\n\tstatic RList * cache = NULL; // XXX DONT COMMIT WITH THIS\n\tstruct symbol_t *symbols;\n\tsize_t j, s, symbols_size, symbols_count;\n\tut32 to, from;\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (cache) {\n\t\treturn cache;\n\t}\n\tRList *list = r_list_newf ((RListFree)r_bin_symbol_free);\n\tcache = list;\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\twalk_exports (bin, fill_exports_list, list);\n\tif (r_list_length (list)) {\n\t\tRListIter *it;\n\t\tRBinSymbol *s;\n\t\tr_list_foreach (list, it, s) {\n\t\t\tinSymtab (hash, s->name, s->vaddr);\n\t\t}\n\t}\n\n\tif (!bin->symtab || !bin->symstr) {\n\t\tht_pp_free (hash);\n\t\treturn list;\n\t}\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1 || !(symbols = calloc (1, symbols_size))) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t}\n\tj = 0; // symbol_idx\n\tbin->main_addr = 0;\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = bin->symtab[i].n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, sym->vaddr);\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tsym->bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tint stridx = bin->symtab[i].n_strx;\n\t\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tif (!inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\tr_list_append (list, sym);\n\t\t\t} else {\n\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tstruct symbol_t symbol;\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub (bin, &symbol, i)) {\n\t\t\tj++;\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = symbol.addr;\n\t\t\tsym->paddr = symbol.offset;\n\t\t\tsym->name = symbol.name;\n\t\t\tif (!sym->name) {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tsym->is_imported = symbol.is_imported;\n\t\t\tr_list_append (list, sym);\n\t\t}\n\t}\n\n\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1) maybe wrong\n\t\t\tRBinSymbol *sym = R_NEW0(RBinSymbol);\n\t\t\t/* is symbol */\n\t\t\tsym->vaddr = st->n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsym->is_imported = symbols[j].is_imported;\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tr_list_append (list, sym);\n\t\t\tj++;\n\t\t}\n\t}\n\tht_pp_free (hash);\n\t// bin->symbols = symbols;\n    free (symbols);\n\treturn list;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx*) ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = offset_to_vaddr (bin, offset);\n\t\tif (inSymtab (sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup (name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin) {\n\tstruct symbol_t *symbols;\n\tint j, s, stridx, symbols_size, symbols_count;\n\tut32 to, from, i;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tr_return_val_if_fail (bin, NULL);\n\tint n_exports = walk_exports (bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\t\tbin->dysymtab.nundefsym );\n\t\tsymbols_count += bin->nsymtab;\n\t\tif (symbols_count < 0 || ((st64)symbols_count * 2) > ST32_MAX) {\n\t\t\teprintf (\"Symbols count overflow\\n\");\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = get_name (bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree (symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub (bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = r_str_newf (\"entry%d\", i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tR_FREE (symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t} else {\n\t\tsymbols_size = (symbols_count + 1) * sizeof (struct symbol_t);\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports (bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free (hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t) *bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym;\n\tsize_t wordsize;\n\tut32 stype;\n\twordsize = get_word_size (bin);\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case ((T) / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\tCASE(8);\n\tCASE(16);\n\tCASE(32);\n\tCASE(64);\n\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {\n\t\t\t\tint indidx = bin->sects[i].reserved1 + j;\n\t\t\t\tif (indidx < 0 || indidx >= bin->nindirectsyms) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (idx == bin->indirectsyms[indidx]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc (bin->dysymtab.nundefsym + 1, sizeof (struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = get_name (bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\tr_str_ncpy (imports[j].name, imp_name, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\tfree (imp_name);\n\t\t} else {\n\t\t\t//imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstatic int reloc_comparator(struct reloc_t *a, struct reloc_t *b) {\n\treturn a->addr - b->addr;\n}\n\nstatic void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; // enum RelocationInfoType\n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}\n\nstatic bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {\n\tr_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);\n\tRWalkBindChainsContext *ctx = context;\n\tut8 *imports = ctx->imports;\n\tstruct MACH0_(obj_t) *bin = event_details->bin;\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 fixups_size = bin->fixups_size;\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;\n\tut64 addend = 0;\n\tif (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {\n\t\taddend = ((RFixupBindEventDetails *) event_details)->addend;\n\t}\n\n\tif (import_index < imports_count) {\n\t\tut64 name_offset;\n\t\tswitch (imports_format) {\n\t\t\tcase DYLD_CHAINED_IMPORT: {\n\t\t\t\tstruct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND: {\n\t\t\t\tstruct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND64: {\n\t\t\t\tstruct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported imports format\\n\");\n\t\t\t\treturn false;\n\t\t}\n\n\t\tut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;\n\n\t\tif (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {\n\t\t\tchar *name = r_buf_get_string (bin->b, symbols_offset + name_offset);\n\t\t\tif (name) {\n\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\tif (!reloc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treloc->addr = offset_to_vaddr (bin, event_details->offset);\n\t\t\t\treloc->offset = event_details->offset;\n\t\t\t\treloc->ord = import_index;\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\treloc->size = 8;\n\t\t\t\treloc->addend = addend;\n\t\t\t\tr_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);\n\t\t\t\tr_skiplist_insert_autofree (ctx->relocs, reloc);\n\t\t\t\tfree (name);\n\t\t\t} else if (bin->verbose) {\n\t\t\t\teprintf (\"Malformed chained bind: failed to read name\\n\");\n\t\t\t}\n\t\t} else if (bin->verbose) {\n\t\t\teprintf (\"Malformed chained bind: name_offset out of bounds\\n\");\n\t\t}\n\t} else if (bin->verbose) {\n\t\teprintf (\"Malformed chained bind: import out of length\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {\n\tr_return_if_fail (bin && bin->fixups_offset);\n\n\tut8 *imports = NULL;\n\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 imports_offset = bin->fixups_header.imports_offset;\n\tif (!imports_count || !imports_offset) {\n\t\treturn;\n\t}\n\tif (bin->fixups_header.symbols_format != 0) {\n\t\teprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");\n\t\treturn;\n\t}\n\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut64 imports_size;\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\timports_size = sizeof (struct dyld_chained_import) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unsupported chained imports format: %d\\n\", imports_format);\n\t\t\tgoto beach;\n\t}\n\n\timports = malloc (imports_size);\n\tif (!imports) {\n\t\tgoto beach;\n\t}\n\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"i\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"ii\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"il\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tRWalkBindChainsContext ctx;\n\tctx.imports = imports;\n\tctx.relocs = relocs;\n\n\tMACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);\n\nbeach:\n\tfree (imports);\n}\n\nstatic bool is_valid_ordinal_table_size(ut64 size) {\n\treturn size > 0 && size <= UT16_MAX;\n}\n\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin) {\n\tRSkipList *relocs = NULL;\n\tRPVector *threaded_binds = NULL;\n\tsize_t wordsize = get_word_size (bin);\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes, rel_type = 0;\n\t\tsize_t bind_size, lazy_size, weak_size;\n\n#define CASE(T) case ((T) / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\t\tweak_size = bin->dyld_info->weak_bind_size;\n\n\t\tif (!bind_size && !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off + bind_size + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->weak_bind_off + weak_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tut64 amount = bind_size + lazy_size + weak_size;\n\t\tif (amount == 0 || amount > UT32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->segs) {\n\t\t\treturn NULL;\n\t\t}\n\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, amount + 1);\n\t\tif (!opcodes) {\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->weak_bind_off, opcodes + bind_size + lazy_size, weak_size);\n\t\tif (len < amount) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tR_FREE (opcodes);\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize_t partition_sizes[] = {bind_size, lazy_size, weak_size};\n\t\tsize_t pidx;\n\t\tint opcodes_offset = 0;\n\t\tfor (pidx = 0; pidx < R_ARRAY_SIZE (partition_sizes); pidx++) {\n\t\t\tsize_t partition_size = partition_sizes[pidx];\n\n\t\t\tut8 type = 0;\n\t\t\tint lib_ord = 0, seg_idx = -1, sym_ord = -1;\n\t\t\tchar *sym_name = NULL;\n\t\t\tsize_t j, count, skip;\n\t\t\tst64 addend = 0;\n\t\t\tut64 addr = bin->segs[0].vmaddr;\n\t\t\tut64 segment_size = bin->segs[0].filesize;\n\t\t\tif (bin->segs[0].filesize != bin->segs[0].vmsize) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t}\n\t\t\tif (segment_size > bin->size) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t\tsegment_size = bin->size;\n\t\t\t}\n\t\t\tut64 segment_end_addr = addr + segment_size;\n\n\t\t\tut8 *p = opcodes + opcodes_offset;\n\t\t\tut8 *end = p + partition_size;\n\t\t\tbool done = false;\n\t\t\twhile (!done && p < end) {\n\t\t\t\tut8 imm = *p & BIND_IMMEDIATE_MASK;\n\t\t\t\tut8 op = *p & BIND_OPCODE_MASK;\n\t\t\t\tp++;\n\t\t\t\tswitch (op) {\n\t\t\t\tcase BIND_OPCODE_DONE: {\n\t\t\t\t\tbool in_lazy_binds = pidx == 1;\n\t\t\t\t\tif (!in_lazy_binds) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_THREADED: {\n\t\t\t\t\tswitch (imm) {\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\t\t\tut64 table_size = read_uleb128 (&p, end);\n\t\t\t\t\t\tif (!is_valid_ordinal_table_size (table_size)) {\n\t\t\t\t\t\t\tbprintf (\"Error: BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size is wrong\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthreaded_binds = r_pvector_new_with_len ((RPVectorFree) &free, table_size);\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tsym_ord = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY:\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tint cur_seg_idx = (seg_idx != -1)? seg_idx: 0;\n\t\t\t\t\t\t\tsize_t n_threaded_binds = r_pvector_len (threaded_binds);\n\t\t\t\t\t\t\twhile (addr < segment_end_addr) {\n\t\t\t\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\t\t\t\tut64 paddr = addr - bin->segs[cur_seg_idx].vmaddr + bin->segs[cur_seg_idx].fileoff;\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, paddr, tmp, 8) != 8) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = false;\n\t\t\t\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\t\t\t\tbool is_auth = (raw_ptr & (1ULL << 63)) != 0;\n\t\t\t\t\t\t\t\tbool is_bind = (raw_ptr & (1ULL << 62)) != 0;\n\t\t\t\t\t\t\t\tint ordinal = -1;\n\t\t\t\t\t\t\t\tint addend = -1;\n\t\t\t\t\t\t\t\tut64 delta;\n\t\t\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ordinal != -1) {\n\t\t\t\t\t\t\t\t\tif (ordinal >= n_threaded_binds) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Malformed bind chain\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *ref = r_pvector_at (threaded_binds, ordinal);\n\t\t\t\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Inconsistent bind opcodes\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\t\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t*reloc = *ref;\n\t\t\t\t\t\t\t\t\treloc->addr = addr;\n\t\t\t\t\t\t\t\t\treloc->offset = paddr;\n\t\t\t\t\t\t\t\t\tif (addend != -1) {\n\t\t\t\t\t\t\t\t\t\treloc->addend = addend;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_skiplist_insert (relocs, reloc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddr += delta * wordsize;\n\t\t\t\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\t\tlib_ord = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\t\tlib_ord = read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\t\tsym_name = (char*)p;\n\t\t\t\t\twhile (*p++ && p < end) {\n\t\t\t\t\t\t/* empty loop */\n\t\t\t\t\t}\n\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsym_ord = -1;\n\t\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < UT16_MAX) {\n\t\t\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\t\t\tsize_t stridx = 0;\n\t\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\t\t\tif (iundefsym >= 0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\t\t\tint sidx = iundefsym + j;\n\t\t\t\t\t\t\t\tif (sidx < 0 || sidx >= bin->nsymtab) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\t\t\tif (stridx >= bin->symstrlen) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found && !strcmp ((const char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\t\taddend = r_sleb128 ((const ut8 **)&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tseg_idx = imm;\n\t\t\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\t\tfree (opcodes);\n\t\t\t\t\t\tr_skiplist_free (relocs);\n\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\treturn NULL; // early exit to avoid future mayhem\n\t\t\t\t\t}\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + read_uleb128 (&p, end);\n\t\t\t\t\tsegment_end_addr = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddr += read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n#define DO_BIND() do {\\\n\tif (sym_ord < 0 && !sym_name) break;\\\n\tif (!threaded_binds) {\\\n\t\tif (seg_idx < 0 ) break;\\\n\t\tif (!addr) break;\\\n\t}\\\n\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\\\n\treloc->addr = addr;\\\n\tif (seg_idx >= 0) {\\\n\t\treloc->offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\n\t\tif (type == BIND_TYPE_TEXT_PCREL32)\\\n\t\t\treloc->addend = addend - (bin->baddr + addr);\\\n\t\telse\\\n\t\t\treloc->addend = addend;\\\n\t} else {\\\n\t\treloc->addend = addend;\\\n\t}\\\n\t/* library ordinal ??? */ \\\n\treloc->ord = lib_ord;\\\n\treloc->ord = sym_ord;\\\n\treloc->type = rel_type;\\\n\tif (sym_name)\\\n\t\tr_str_ncpy (reloc->name, sym_name, 256);\\\n\tif (threaded_binds)\\\n\t\tr_pvector_set (threaded_binds, sym_ord, reloc);\\\n\telse\\\n\t\tr_skiplist_insert (relocs, reloc);\\\n} while (0)\n\t\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\t\tif (!threaded_binds && addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode 0x%\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\tif (!threaded_binds) {\n\t\t\t\t\t\taddr += wordsize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsym_ord++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += read_uleb128 (&p, end) + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128 (&p, end);\n\t\t\t\t\tskip = read_uleb128 (&p, end);\n\t\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDO_BIND ();\n\t\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#undef DO_BIND\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\t\t\tR_FREE (opcodes);\n\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\treturn relocs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topcodes_offset += partition_size;\n\t\t}\n\n\t\tR_FREE (opcodes);\n\t\tr_pvector_free (threaded_binds);\n\t\tthreaded_binds = NULL;\n\t}\n\n\tif (bin->symtab && bin->symstr && bin->sects && bin->indirectsyms) {\n\t\tint j;\n\t\tint amount = bin->dysymtab.nundefsym;\n\t\tif (amount < 0) {\n\t\t\tamount = 0;\n\t\t}\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < amount; j++) {\n\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\tif (!reloc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_ptr (bin, reloc, bin->dysymtab.iundefsym + j)) {\n\t\t\t\treloc->ord = j;\n\t\t\t\tr_skiplist_insert_autofree (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tR_FREE (reloc);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bin->symtab && bin->dysymtab.extreloff && bin->dysymtab.nextrel) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tparse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);\n\t}\n\n\tif (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\twalk_bind_chains (bin, relocs);\n\t}\nbeach:\n\tr_pvector_free (threaded_binds);\n\treturn relocs;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tut64 ea = entry_to_vaddr (bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = R_NEW0 (struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = addr_to_offset (bin, entry->addr);\n\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf (\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\tchar lib_flagname[128];\t\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tchar lib_flagname[128];\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof (struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t\tr_str_ncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cputype_from_hdr) (&bin->hdr): \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_VAX780:\treturn \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785:\treturn \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750:\treturn \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730:\treturn \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII:\treturn \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200:\treturn \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500:\treturn \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600:\treturn \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650:\treturn \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800:\treturn \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII:\treturn \"uvaxIII\";\n\t\tdefault:\t\t\treturn \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030:\treturn \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040:\treturn \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn \"mc68030 only\";\n\t\tdefault:\t\t\treturn \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: \t\t\treturn \"386\";\n\t\tcase CPU_SUBTYPE_486: \t\t\treturn \"486\";\n\t\tcase CPU_SUBTYPE_486SX: \t\treturn \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: \t\treturn \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn \"Xeon MP\";\n\t\tdefault:\t\t\t\treturn \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn \"x86 arch 1\";\n\t\tdefault:\t\t\treturn \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC88100:\treturn \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110:\treturn \"mc88110\";\n\t\tdefault:\t\t\treturn \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC98601:\treturn \"mc98601\";\n\t\tdefault:\t\t\treturn \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn \"hppa7100LC\";\n\t\tdefault:\t\t\treturn \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8:\treturn \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E:\treturn \"arm64e\";\n\t\tdefault:\t\t\treturn \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf (\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn \"all\";\n\t\tdefault:\t\t\treturn \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn \"r3000\";\n\t\tdefault:\t\t\treturn \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_I860_860:\treturn \"860\";\n\t\tdefault:\t\t\treturn \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn \"970\";\n\t\tdefault:\t\t\treturn \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tr_return_val_if_fail (hdr, NULL);\n\treturn strdup (cpusubtype_tostring (hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cpusubtype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET:    mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_filetype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n#if FEATURE_SYMLIST\n\t\t (void)MACH0_(get_symbols_list) (bin);\n#else\n\t\t (void)MACH0_(get_symbols) (bin);\n#endif\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree (MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset (bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va (bf, 0);\n\tcb_printf (\"pf.mach0_header @ 0x%08\"PFMT64x\"\\n\", pvaddr);\n\tcb_printf (\"0x%08\"PFMT64x\"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof (word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\t\tif (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { \\\n\t\t\teprintf (\"Invalid address in buffer.\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\taddr += 4; \\\n\t\tpvaddr += 4;\\\n\t\tword = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds && addr < length; n++) {\n\t\tREADWORD ();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf (\"pf.%s @ 0x%08\"PFMT64x\"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string (lcType));\n\t\tREADWORD ();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  platform    %s\\n\",\n\t\t\t\tpvaddr, build_version_platform_to_string (r_buf_read_le32_at (buf, addr)));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  minos       %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 4, r_buf_read_le16_at (buf, addr + 6), r_buf_read8_at (buf, addr + 5),\n\t\t\t\tr_buf_read8_at (buf, addr + 4));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  sdk         %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, addr + 12);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  ntools      %d\\n\",\n\t\t\t\tpvaddr + 12, ntools);\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf (\"pf.mach0_build_version_tool @ 0x%08\"PFMT64x\"\\n\", pvaddr + off);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  tool        %s\\n\",\n\t\t\t\t\tpvaddr + off, build_version_tool_to_string (r_buf_read_le32_at (buf, addr + off)));\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  version     %d.%d.%d\\n\",\n\t\t\t\t\tpvaddr + off, r_buf_read_le16_at (buf, addr + off + 2), r_buf_read8_at (buf, addr + off + 1),\n\t\t\t\t\tr_buf_read8_at (buf, addr + off));\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\t\tut8 data[64] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, data, sizeof (data));\n#if R_BIN_MACH064\n\t\t\t\tut64 ep = r_read_ble64 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\t\tut64 ss = r_read_ble64 (&data[8], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr +  8, ss);\n#else\n\t\t\t\tut32 ep = r_read_ble32 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\t\tut32 ss = r_read_ble32 (&data[4], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr +  4, ss);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = r_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *id = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (id));\n\t\t\tif (id) {\n\t\t\t\tfree (id);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID:\n\t\t\t{\n\t\t\t\tut8 i, uuid[16];\n\t\t\t\tr_buf_read_at (buf, addr, uuid, sizeof (uuid));\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  uuid        \", pvaddr);\n\t\t\t\tfor (i = 0; i < sizeof (uuid); i++) {\n\t\t\t\t\tcb_printf (\"%02x\", uuid[i]);\n\t\t\t\t}\n\t\t\t\tcb_printf (\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64:\n\t\t\t{\n\t\t\t\tut8 name[17] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, name, sizeof (name) - 1);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  name        %s\\n\", pvaddr, name);\n\t\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr - 8 + (is64 ? 64 : 48));\n\t\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\t\tif (is64) {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section64 @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 80;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 68;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *load_dylib = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (load_dylib));\n\t\t\tif (load_dylib) {\n\t\t\t\tfree (load_dylib);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = r_buf_get_string (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, r_str_get (rpath));\n\t\t\tif (rpath) {\n\t\t\t\tfree (rpath);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word = r_buf_read_le32_at (buf, addr);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptoff   0x%08x\\n\", pvaddr, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptsize  %d\\n\", pvaddr + 4, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\tr_buf_read_at (buf, addr, (ut8 *)words, sizeof (words));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf (\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree (mh);\n}\n\nRList *MACH0_(mach_fields)(RBinFile *bf) {\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr) (buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\tfree (mh);\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = pa2va (bf, 0);\n\tut64 paddr = 0;\n\n\tr_list_append (ret, r_bin_field_new (addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tchar load_command_flagname[128];\n\tfor (n = 0; n < mh->ncmds && paddr < length; n++) {\n\t\tut32 lcType = r_buf_read_ble32_at (buf, paddr, isBe);\n\t\tut32 word = r_buf_read_ble32_at (buf, paddr + 4, isBe);\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tsnprintf (load_command_flagname, sizeof (load_command_flagname), \"load_command_%d_%s\", n, cmd_to_string (lcType));\n\t\t\tr_list_append (ret, r_bin_field_new (addr, addr, 1, load_command_flagname, pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, paddr + 20);\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\tchar tool_flagname[32];\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\tsnprintf (tool_flagname, sizeof (tool_flagname), \"tool_%d\", j++);\n\t\t\t\tr_list_append (ret, r_bin_field_new (addr + off, addr + off, 1, tool_flagname, \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr + (is64 ? 64 : 48));\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tchar section_flagname[128];\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64? \"mach0_section64\": \"mach0_section\";\n\t\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"section_%u\", (ut32)j++);\n\t\t\t\tRBinField *f = r_bin_field_new (addr + off, addr + off, 1, section_flagname, sname, sname, true);\n\t\t\t\tr_list_append (ret, f);\n\t\t\t\toff += is64? 80: 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree (mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_ARM64E) {\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "#include <r_bin.h>\n#include <r_types.h>\n#include \"mach0_specs.h\"\n\n#ifndef _INCLUDE_R_BIN_MACH0_H_\n#define _INCLUDE_R_BIN_MACH0_H_\n\n// 20% faster loading times for macho if enabled\n#define FEATURE_SYMLIST 0\n\n#define R_BIN_MACH0_STRING_LENGTH 256\n\n\n#define CSMAGIC_CODEDIRECTORY      0xfade0c02\n#define CSMAGIC_EMBEDDED_SIGNATURE 0xfade0cc0\n#define CSMAGIC_DETACHED_SIGNATURE 0xfade0cc1 /* multi-arch collection of embedded signatures */\n#define CSMAGIC_ENTITLEMENTS       0xfade7171\n#define CSMAGIC_REQUIREMENT        0xfade0c00 /* single Requirement blob */\n#define CSMAGIC_REQUIREMENTS       0xfade0c01 /* Requirements vector (internal requirements) */\n\n#define CS_PAGE_SIZE 4096\n\n#define CS_HASHTYPE_SHA1 1\n#define CS_HASHTYPE_SHA256 2\n#define CS_HASHTYPE_SHA256_TRUNCATED 3\n\n#define CS_HASH_SIZE_SHA1 20\n#define CS_HASH_SIZE_SHA256 32\n#define CS_HASH_SIZE_SHA256_TRUNCATED 20\n\n#define CSSLOT_CODEDIRECTORY 0\n#define CSSLOT_INFOSLOT 1\n#define CSSLOT_REQUIREMENTS  2\n#define CSSLOT_RESOURCEDIR 3\n#define CSSLOT_APPLICATION 4\n#define CSSLOT_ENTITLEMENTS  5\n#define CSSLOT_CMS_SIGNATURE 0x10000\n\ntypedef enum {\n\tR_FIXUP_EVENT_NONE = 0,\n\tR_FIXUP_EVENT_REBASE = 1,\n\tR_FIXUP_EVENT_REBASE_AUTH = 2,\n\tR_FIXUP_EVENT_BIND = 4,\n\tR_FIXUP_EVENT_BIND_AUTH = 8,\n} RFixupEvent;\n\n#define R_FIXUP_EVENT_MASK_BIND_ALL (R_FIXUP_EVENT_BIND | R_FIXUP_EVENT_BIND_AUTH)\n#define R_FIXUP_EVENT_MASK_REBASE_ALL (R_FIXUP_EVENT_REBASE | R_FIXUP_EVENT_REBASE_AUTH)\n#define R_FIXUP_EVENT_MASK_ALL (R_FIXUP_EVENT_MASK_BIND_ALL | R_FIXUP_EVENT_MASK_REBASE_ALL)\n\nstruct section_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 size;\n\tut64 vsize;\n\tut32 align;\n\tut32 flags;\n\tint perm;\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint last;\n};\n\nstruct symbol_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 size;\n\tint bits;\n\tint type;\n\tbool is_imported;\n\tchar *name;\n\tbool last;\n};\n\nstruct import_t {\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint ord;\n\tint last;\n};\n\nstruct reloc_t {\n\tut64 offset;\n\tut64 addr;\n\tst64 addend;\n\tut8 type;\n\tint ord;\n\tint last;\n\tchar name[256];\n\tbool external;\n\tbool pc_relative;\n\tut8 size;\n};\n\nstruct addr_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 haddr;\n\tint last;\n};\n\nstruct lib_t {\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint last;\n};\n\nstruct blob_index_t {\n\tut32 type;\n\tut32 offset;\n};\n\nstruct blob_t {\n\tut32 magic;\n\tut32 length;\n};\n\nstruct super_blob_t {\n\tstruct blob_t blob;\n\tut32 count;\n\tstruct blob_index_t index[];\n};\n\nstruct MACH0_(opts_t) {\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n};\n\nstruct MACH0_(obj_t) {\n\tstruct MACH0_(mach_header) hdr;\n\tstruct MACH0_(segment_command) *segs;\n\tchar *intrp;\n\tchar *compiler;\n\tint nsegs;\n\tstruct r_dyld_chained_starts_in_segment **chained_starts;\n\tstruct dyld_chained_fixups_header fixups_header;\n\tut64 fixups_offset;\n\tut64 fixups_size;\n\tstruct MACH0_(section) *sects;\n\tint nsects;\n\tstruct MACH0_(nlist) *symtab;\n\tut8 *symstr;\n\tut8 *func_start; //buffer that hold the data from LC_FUNCTION_STARTS\n\tint symstrlen;\n\tint nsymtab;\n\tut32 *indirectsyms;\n\tint nindirectsyms;\n\n\tRBinImport **imports_by_ord;\n\tsize_t imports_by_ord_size;\n\tHtPP *imports_by_name;\n\n\tstruct dysymtab_command dysymtab;\n\tstruct load_command main_cmd;\n\tstruct dyld_info_command *dyld_info;\n\tstruct dylib_table_of_contents *toc;\n\tint ntoc;\n\tstruct MACH0_(dylib_module) *modtab;\n\tint nmodtab;\n\tstruct thread_command thread;\n\tut8 *signature;\n\tunion {\n\t\tstruct x86_thread_state32 x86_32;\n\t\tstruct x86_thread_state64 x86_64;\n\t\tstruct ppc_thread_state32 ppc_32;\n\t\tstruct ppc_thread_state64 ppc_64;\n\t\tstruct arm_thread_state32 arm_32;\n\t\tstruct arm_thread_state64 arm_64;\n\t} thread_state;\n\tchar (*libs)[R_BIN_MACH0_STRING_LENGTH];\n\tint nlibs;\n\tint size;\n\tut64 baddr;\n\tut64 entry;\n\tbool big_endian;\n\tconst char *file;\n\tRBuffer *b;\n\tint os;\n\tSdb *kv;\n\tint has_crypto;\n\tint has_canary;\n\tint has_retguard;\n\tint has_sanitizers;\n\tint has_blocks_ext;\n\tint dbg_info;\n\tconst char *lang;\n\tint uuidn;\n\tint func_size;\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n\tvoid *user;\n\tut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);\n\tstruct symbol_t *symbols;\n\tut64 main_addr;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebasing_buffer;\n};\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n} RFixupEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ordinal;\n\tut64 addend;\n} RFixupBindEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut32 ordinal;\n\tut8 key;\n\tut8 addr_div;\n\tut16 diversity;\n} RFixupBindAuthEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ptr_value;\n} RFixupRebaseEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ptr_value;\n\tut8 key;\n\tut8 addr_div;\n\tut16 diversity;\n} RFixupRebaseAuthEventDetails;\n\ntypedef bool (*RFixupCallback)(void * context, RFixupEventDetails * event_details);\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf);\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options);\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options);\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *bin);\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin);\n//RList *MACH0_(get_segments)(struct MACH0_(obj_t) *bin);\nRList *MACH0_(get_segments)(RBinFile *bf); // struct MACH0_(obj_t) *bin);\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin);\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin);\nvoid MACH0_(pull_symbols)(struct MACH0_(obj_t) *mo, RBinSymbolCallback cb, void *user);\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin);\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin);\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin);\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin);\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin);\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin);\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin);\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin);\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr);\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr);\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr);\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr);\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf);\nvoid MACH0_(mach_headerfields)(RBinFile *bf);\nRList *MACH0_(mach_fields)(RBinFile *bf);\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *obj, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void *context);\n#endif\n", "/* radare - LGPL - Copyright 2009-2021 - pancake */\n\n#include <r_core.h>\n#include \"ht_pp.h\"\n\n/*!\n * Number of sub-commands to show as options when displaying the help of a\n * command. When a command has more options than MAX_CHILDREN_SHOW, `?` is shown\n * instead.\n *\n * Example with MAX_CHILDREN_SHOW=3:\n * w -> wa\n *   -> wb\n *   -> wc\n *\n * When doing `?`, you would see:\n * w[abc]\n *\n * If there is also:\n *   -> wd\n * you would see:\n * w[?]\n */\n#define MAX_CHILDREN_SHOW 7\n\nstatic const RCmdDescHelp not_defined_help = {\n\t.usage = \"Usage not defined\",\n\t.summary = \"Help summary not defined\",\n\t.description = \"Help description not defined.\",\n};\n\nstatic const RCmdDescHelp root_help = {\n\t.usage = \"[.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...\",\n\t.description = \"\",\n};\n\nstatic int value = 0;\n\n#define NCMDS (sizeof (cmd->cmds)/sizeof(*cmd->cmds))\nR_LIB_VERSION (r_cmd);\n\nstatic bool cmd_desc_set_parent(RCmdDesc *cd, RCmdDesc *parent) {\n\tr_return_val_if_fail (cd && !cd->parent, false);\n\tif (parent) {\n\t\tcd->parent = parent;\n\t\tr_pvector_push (&parent->children, cd);\n\t\tparent->n_children++;\n\t}\n\treturn true;\n}\n\nstatic void cmd_desc_unset_parent(RCmdDesc *cd) {\n\tr_return_if_fail (cd && cd->parent);\n\tRCmdDesc *parent = cd->parent;\n\tr_pvector_remove_data (&parent->children, cd);\n\tparent->n_children--;\n\tcd->parent = NULL;\n}\n\nstatic bool cmd_desc_remove_from_ht_cmds(RCmd *cmd, RCmdDesc *cd) {\n\tvoid **it_cd;\n\tbool res = ht_pp_delete (cmd->ht_cmds, cd->name);\n\tr_return_val_if_fail (res, false);\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child_cd = *it_cd;\n\t\tcmd_desc_remove_from_ht_cmds (cmd, child_cd);\n\t}\n\treturn res;\n}\n\nstatic void cmd_desc_free(RCmdDesc *cd) {\n\tif (!cd) {\n\t\treturn;\n\t}\n\n\tr_pvector_clear (&cd->children);\n\tfree (cd->name);\n\tfree (cd);\n}\n\nstatic RCmdDesc *create_cmd_desc(RCmd *cmd, RCmdDesc *parent, RCmdDescType type, const char *name, const RCmdDescHelp *help, bool ht_insert) {\n\tRCmdDesc *res = R_NEW0 (RCmdDesc);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->type = type;\n\tres->name = strdup (name);\n\tif (!res->name) {\n\t\tgoto err;\n\t}\n\tres->n_children = 0;\n\tres->help = help? help: &not_defined_help;\n\tr_pvector_init (&res->children, (RPVectorFree)cmd_desc_free);\n\tif (ht_insert && !ht_pp_insert (cmd->ht_cmds, name, res)) {\n\t\tgoto err;\n\t}\n\tcmd_desc_set_parent (res, parent);\n\treturn res;\nerr:\n\tcmd_desc_free (res);\n\treturn NULL;\n}\n\nstatic void alias_freefn(HtPPKv *kv) {\n\tchar *k = kv->key;\n\tRCmdAliasVal *v = kv->value;\n\n\tfree (v->data);\n\tfree (k);\n\tfree (v);\n}\n\nstatic void *alias_dupkey(const void *k) {\n\treturn strdup ((const char *)k);\n}\n\nstatic void *alias_dupvalue(const void *v_void) {\n\tRCmdAliasVal *v = (RCmdAliasVal *)v_void;\n\tRCmdAliasVal *vcopy = R_NEW (RCmdAliasVal);\n\tif (!vcopy) {\n\t\treturn NULL;\n\t}\n\tut8 *data = malloc (v->sz);\n\tif (!data) {\n\t\tfree (vcopy);\n\t\treturn NULL;\n\t}\n\tvcopy->is_data = v->is_data;\n\tvcopy->is_str = v->is_str;\n\tvcopy->sz = v->sz;\n\tvcopy->data = data;\n\tmemcpy (vcopy->data, v->data, v->sz);\n\n\treturn vcopy;\n}\n\nstatic ut32 alias_calcsizeK(const void *k) {\n\treturn strlen ((const char *)k);\n}\n\nstatic ut32 alias_calcsizeV(const void *v) {\n\treturn ((RCmdAliasVal *)v)->sz;\n}\n\nstatic int alias_cmp(const void *k1, const void *k2) {\n\treturn strcmp ((const char *)k1, (const char *)k2);\n}\n\nstatic ut32 alias_hashfn(const void *k_in) {\n\t/* djb2 algorithm by Dan Bernstein */\n\tut32 hash = 5381;\n\tut8 c;\n\tconst char *k = k_in;\n\n\twhile (*k) {\n\t\tc = *k++;\n\t\t/* hash * 33 + c */\n\t\thash += (hash << 5) + c;\n\t}\n\n\treturn hash;\n}\n\nR_API void r_cmd_alias_init(RCmd *cmd) {\n\tHtPPOptions opt = {0};\n\topt.cmp = alias_cmp;\n\topt.hashfn = alias_hashfn;\n\topt.dupkey = alias_dupkey;\n\topt.dupvalue = alias_dupvalue;\n\topt.calcsizeK = alias_calcsizeK;\n\topt.calcsizeV = alias_calcsizeV;\n\topt.freefn = alias_freefn;\n\n\tcmd->aliases = ht_pp_new_opt (&opt);\n}\n\nR_API RCmd *r_cmd_new(void) {\n\tint i;\n\tRCmd *cmd = R_NEW0 (RCmd);\n\tif (!cmd) {\n\t\treturn cmd;\n\t}\n\tcmd->lcmds = r_list_new ();\n\tfor (i = 0; i < NCMDS; i++) {\n\t\tcmd->cmds[i] = NULL;\n\t}\n\tcmd->nullcallback = cmd->data = NULL;\n\tcmd->ht_cmds = ht_pp_new0 ();\n\tcmd->root_cmd_desc = create_cmd_desc (cmd, NULL, R_CMD_DESC_TYPE_ARGV, \"\", &root_help, true);\n\tr_core_plugin_init (cmd);\n\tr_cmd_macro_init (&cmd->macro);\n\tr_cmd_alias_init (cmd);\n\treturn cmd;\n}\n\nR_API RCmd *r_cmd_free(RCmd *cmd) {\n\tint i;\n\tif (!cmd) {\n\t\treturn NULL;\n\t}\n\tht_up_free (cmd->ts_symbols_ht);\n\tr_cmd_alias_free (cmd);\n\tr_cmd_macro_fini (&cmd->macro);\n\tht_pp_free (cmd->ht_cmds);\n\t// dinitialize plugin commands\n\tr_core_plugin_fini (cmd);\n\tr_list_free (cmd->plist);\n\tr_list_free (cmd->lcmds);\n\tfor (i = 0; i < NCMDS; i++) {\n\t\tif (cmd->cmds[i]) {\n\t\t\tR_FREE (cmd->cmds[i]);\n\t\t}\n\t}\n\tcmd_desc_free (cmd->root_cmd_desc);\n\tfree (cmd);\n\treturn NULL;\n}\n\nR_API RCmdDesc *r_cmd_get_root(RCmd *cmd) {\n\treturn cmd->root_cmd_desc;\n}\n\nR_API RCmdDesc *r_cmd_get_desc(RCmd *cmd, const char *cmd_identifier) {\n\tr_return_val_if_fail (cmd && cmd_identifier, NULL);\n\tchar *cmdid = strdup (cmd_identifier);\n\tchar *end_cmdid = cmdid + strlen (cmdid);\n\tRCmdDesc *res = NULL;\n\tbool is_exact_match = true;\n\t// match longer commands first\n\twhile (*cmdid) {\n\t\tRCmdDesc *cd = ht_pp_find (cmd->ht_cmds, cmdid, NULL);\n\t\tif (cd) {\n\t\t\tswitch (cd->type) {\n\t\t\tcase R_CMD_DESC_TYPE_ARGV:\n\t\t\t\tif (!is_exact_match) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\tcase R_CMD_DESC_TYPE_GROUP:\n\t\t\t\t// fallthrough\n\t\t\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\t\t\tres = cd;\n\t\t\t\tgoto out;\n\t\t\tcase R_CMD_DESC_TYPE_INNER:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tis_exact_match = false;\n\t\t*(--end_cmdid) = '\\0';\n\t}\nout:\n\tfree (cmdid);\n\treturn res;\n}\n\nstatic bool get_keys(void *keylist_in, const void *k, const void *v) {\n\tRList *keylist = (RList *) keylist_in;\n\treturn r_list_append (keylist, (char *) k);\n}\n\nR_API RList *r_cmd_alias_keys(RCmd *cmd) {\n\tRList *keylist = r_list_new ();\n\tif (!keylist) {\n\t\treturn NULL;\n\t}\n\n\tht_pp_foreach (cmd->aliases, get_keys, keylist);\n\n\treturn keylist;\n}\n\nR_API void r_cmd_alias_free(RCmd *cmd) {\n\tht_pp_free (cmd->aliases);\n\tcmd->aliases = NULL;\n}\n\nR_API bool r_cmd_alias_del(RCmd *cmd, const char *k) {\n\treturn ht_pp_delete(cmd->aliases, k);\n}\n\nR_API int r_cmd_alias_set_cmd(RCmd *cmd, const char *k, const char *v) {\n\tRCmdAliasVal val;\n\tval.data = (ut8 *)v;\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\tval.sz = strlen (v) + 1;\n\tval.is_str = true;\n\tval.is_data = false;\n\n\treturn ht_pp_update (cmd->aliases, k, &val);\n}\n\nR_API int r_cmd_alias_set_str(RCmd *cmd, const char *k, const char *v) {\n\tRCmdAliasVal val;\n\tval.data = (ut8 *)strdup (v);\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\tval.is_str = true;\n\tval.is_data = true;\n\n\t/* No trailing newline */\n\tint len = strlen (v);\n\twhile (len-- > 0) {\n\t\tif (v[len] == '\\r' || v[len] == '\\n') {\n\t\t\tval.data[len] = '\\0';\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// len is strlen()-1 now\n\tval.sz = len + 2;\n\n\tint ret = ht_pp_update (cmd->aliases, k, &val);\n\tfree (val.data);\n\treturn ret;\n}\n\nR_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {\n\tint i;\n\n\tif (sz < 1) {\n\t\treturn 1;\n\t}\n\n\tRCmdAliasVal val;\n\tval.data = malloc (sz);\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\n\tmemcpy (val.data, v, sz);\n\tval.sz = sz;\n\n\t/* If it's a string already, we speed things up later by checking now */\n\tconst ut8 *firstnull = NULL;\n\tbool is_binary = false;\n\tfor (i = 0; i < sz; i++) {\n\t\t/* \\0 before expected -> not string */\n\t\tif (v[i] == '\\0') {\n\t\t\tfirstnull = &v[i];\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Non-ascii character -> not string */\n\t\tif (!IS_PRINTABLE(v[i]) && !IS_WHITECHAR(v[i])) {\n\t\t\tis_binary = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (firstnull == &v[sz-1] && !is_binary) {\n\t\t/* Data is already a string */\n\t\tval.is_str = true;\n\t} else if (!firstnull && !is_binary) {\n\t\t/* Data is an unterminated string */\n\t\tval.sz++;\n\t\tut8 *data = realloc (val.data, val.sz);\n\t\tif (!data) {\n\t\t\treturn 1;\n\t\t}\n\t\tval.data = data;\n\t\tval.data[val.sz - 1] = '\\0';\n\t\tval.is_str = true;\n\t} else {\n\t\t/* Data has nulls or non-ascii, not a string */\n\t\tval.is_str = false;\n\t}\n\n\tval.is_data = true;\n\n\tif (val.is_str) {\n\t\t/* No trailing newline */\n\t\tint len = val.sz - 1;\n\t\twhile (len-- > 0) {\n\t\t\tif (v[len] == '\\r' || v[len] == '\\n') {\n\t\t\t\tval.data[len] = '\\0';\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// len is strlen()-1 now\n\t\tval.sz = len + 2;\n\t}\n\n\tint ret = ht_pp_update (cmd->aliases, k, &val);\n\tfree (val.data);\n\treturn ret;\n}\n\nR_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}\n\nstatic ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {\n\tut8* out;\n\tint out_sz;\n\n\t/* If appending to a string, always overwrite the trailing \\0 */\n\tint bytes_from_first = first->is_str\n\t\t? first->sz - 1\n\t\t: first->sz;\n\n\tout_sz = bytes_from_first + second_sz;\n\tout = malloc (out_sz);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\n\t/* Copy full buffer if raw bytes. Stop before \\0 if string. */\n\tmemcpy (out, first->data, bytes_from_first);\n\t/* Always copy all bytes from second, including trailing \\0 */\n\tmemcpy (out+bytes_from_first, second, second_sz);\n\n\tif (out_sz) {\n\t\t*out_szp = out_sz;\n\t}\n\treturn out;\n}\n\nR_API int r_cmd_alias_append_str(RCmd *cmd, const char *k, const char *a) {\n\tRCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);\n\tif (v_old) {\n\t\tif (!v_old->is_data) {\n\t\t\treturn 1;\n\t\t}\n\t\tint new_len = 0;\n\t\tut8* new = alias_append_internal (&new_len, v_old, (ut8 *)a, strlen (a) + 1);\n\t\tif (!new) {\n\t\t\treturn 1;\n\t\t}\n\t\tr_cmd_alias_set_raw (cmd, k, new, new_len);\n\t\tfree (new);\n\t} else {\n\t\tr_cmd_alias_set_str (cmd, k, a);\n\t}\n\treturn 0;\n}\n\nR_API int r_cmd_alias_append_raw(RCmd *cmd, const char *k, const ut8 *a, int sz) {\n\tRCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);\n\tif (v_old) {\n\t\tif (!v_old->is_data) {\n\t\t\treturn 1;\n\t\t}\n\t\tint new_len = 0;\n\t\tut8 *new = alias_append_internal (&new_len, v_old, a, sz);\n\t\tif (!new) {\n\t\t\treturn 1;\n\t\t}\n\t\tr_cmd_alias_set_raw (cmd, k, new, new_len);\n\t\tfree (new);\n\t} else {\n\t\tr_cmd_alias_set_raw (cmd, k, a, sz);\n\t}\n\treturn 0;\n}\n\n/* Returns a new copy of v->data. If !v->is_str, hex escaped */\nR_API char *r_cmd_alias_val_strdup(RCmdAliasVal *v) {\n\tif (v->is_str) {\n\t\treturn strdup ((char *)v->data);\n\t}\n\treturn r_str_escape_raw (v->data, v->sz);\n}\n\n/* Returns a new copy of v->data. If !v->is_str, b64 encoded. */\nR_API char *r_cmd_alias_val_strdup_b64(RCmdAliasVal *v) {\n\tif (v->is_str) {\n\t\treturn strdup ((char *)v->data);\n\t}\n\n\treturn r_base64_encode_dyn ((char *)v->data, v->sz);\n}\n\nR_API void r_cmd_set_data(RCmd *cmd, void *data) {\n\tcmd->data = data;\n}\n\nR_API bool r_cmd_add(RCmd *c, const char *cmd, RCmdCb cb) {\n\tint idx = (ut8)cmd[0];\n\tRCmdItem *item = c->cmds[idx];\n\tif (!item) {\n\t\titem = R_NEW0 (RCmdItem);\n\t\tc->cmds[idx] = item;\n\t}\n\tstrncpy (item->cmd, cmd, sizeof (item->cmd)-1);\n\titem->callback = cb;\n\treturn true;\n}\n\nR_API void r_cmd_del(RCmd *cmd, const char *command) {\n\tint idx = (ut8)command[0];\n\tR_FREE (cmd->cmds[idx]);\n}\n\nR_API int r_cmd_call(RCmd *cmd, const char *input) {\n\tstruct r_cmd_item_t *c;\n\tint ret = -1;\n\tRListIter *iter;\n\tRCorePlugin *cp;\n\tr_return_val_if_fail (cmd && input, -1);\n\tif (!*input) {\n\t\tif (cmd->nullcallback) {\n\t\t\tret = cmd->nullcallback (cmd->data);\n\t\t}\n\t} else {\n\t\tchar *nstr = NULL;\n\t\tRCmdAliasVal *v = r_cmd_alias_get (cmd, input);\n\t\tif (v && v->is_data) {\n\t\t\tchar *v_str = r_cmd_alias_val_strdup (v);\n\t\t\tr_cons_strcat (v_str);\n\t\t\tfree (v_str);\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (cmd->plist, iter, cp) {\n\t\t\tif (cp->call && cp->call (cmd->data, input)) {\n\t\t\t\tfree (nstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (!*input) {\n\t\t\tfree (nstr);\n\t\t\treturn -1;\n\t\t}\n\t\tc = cmd->cmds[((ut8)input[0]) & 0xff];\n\t\tif (c && c->callback) {\n\t\t\tconst char *inp = (*input)? input + 1: \"\";\n\t\t\tret = c->callback (cmd->data, inp);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tfree (nstr);\n\t}\n\treturn ret;\n}\n\nstatic RCmdStatus int2cmdstatus(int v) {\n\tif (v == -2) {\n\t\treturn R_CMD_STATUS_EXIT;\n\t} else if (v < 0) {\n\t\treturn R_CMD_STATUS_ERROR;\n\t} else {\n\t\treturn R_CMD_STATUS_OK;\n\t}\n}\n\nR_API RCmdStatus r_cmd_call_parsed_args(RCmd *cmd, RCmdParsedArgs *args) {\n\tRCmdStatus res = R_CMD_STATUS_INVALID;\n\n\t// As old RCorePlugin do not register new commands in RCmd, we have no\n\t// way of knowing if one of those is able to handle the input, so we\n\t// have to pass the input to all of them before looking into the\n\t// RCmdDesc tree\n\tRListIter *iter;\n\tRCorePlugin *cp;\n\tchar *exec_string = r_cmd_parsed_args_execstr (args);\n\tr_list_foreach (cmd->plist, iter, cp) {\n\t\tif (cp->call && cp->call (cmd->data, exec_string)) {\n\t\t\tres = R_CMD_STATUS_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tR_FREE (exec_string);\n\tif (res == R_CMD_STATUS_OK) {\n\t\treturn res;\n\t}\n\n\tRCmdDesc *cd = r_cmd_get_desc (cmd, r_cmd_parsed_args_cmd (args));\n\tif (!cd) {\n\t\treturn R_CMD_STATUS_INVALID;\n\t}\n\n\tres = R_CMD_STATUS_INVALID;\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\tif (!cd->d.group_data.exec_cd) {\n\t\t\tbreak;\n\t\t}\n\t\tcd = cd->d.group_data.exec_cd;\n\t\t// fallthrough\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\tif (cd->d.argv_data.cb) {\n\t\t\tres = cd->d.argv_data.cb (cmd->data, args->argc, (const char **)args->argv);\n\t\t}\n\t\tbreak;\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\texec_string = r_cmd_parsed_args_execstr (args);\n\t\tres = int2cmdstatus (cd->d.oldinput_data.cb (cmd->data, exec_string + strlen (cd->name)));\n\t\tR_FREE (exec_string);\n\t\tbreak;\n\tdefault:\n\t\tres = R_CMD_STATUS_INVALID;\n\t\tR_LOG_ERROR (\"RCmdDesc type not handled\\n\");\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nstatic void fill_children_chars(RStrBuf *sb, RCmdDesc *cd) {\n\tif (cd->help->options) {\n\t\tr_strbuf_append (sb, cd->help->options);\n\t\treturn;\n\t}\n\n\tRStrBuf csb;\n\tr_strbuf_init (&csb);\n\n\tvoid **it;\n\tr_cmd_desc_children_foreach (cd, it) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it;\n\t\tif (r_str_startswith (child->name, cd->name) && strlen (child->name) == strlen (cd->name) + 1) {\n\t\t\tr_strbuf_appendf (&csb, \"%c\", child->name[strlen (cd->name)]);\n\t\t}\n\t}\n\n\tif (r_strbuf_is_empty (&csb) || r_strbuf_length (&csb) >= MAX_CHILDREN_SHOW) {\n\t\tr_strbuf_fini (&csb);\n\t\tr_strbuf_set (&csb, \"?\");\n\t}\n\n\tif (!cd->n_children || r_cmd_desc_has_handler (cd)) {\n\t\tr_strbuf_prepend (&csb, \"[\");\n\t\tr_strbuf_append (&csb, \"]\");\n\t} else {\n\t\tr_strbuf_prepend (&csb, \"<\");\n\t\tr_strbuf_append (&csb, \">\");\n\t}\n\tchar *tmp = r_strbuf_drain_nofree (&csb);\n\tr_strbuf_append (sb, tmp);\n\tfree (tmp);\n}\n\nstatic bool show_children_shortcut(RCmdDesc *cd) {\n\treturn cd->n_children || cd->help->options || cd->type == R_CMD_DESC_TYPE_OLDINPUT;\n}\n\nstatic void fill_usage_strbuf(RStrBuf *sb, RCmdDesc *cd, bool use_color) {\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_label_color = use_color? cons->context->pal.label: \"\",\n\t\t   *pal_args_color = use_color? cons->context->pal.args: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tr_strbuf_appendf (sb, \"%sUsage: %s\", pal_label_color, pal_reset);\n\tif (cd->help->usage) {\n\t\tr_strbuf_appendf (sb, \"%s%s%s\", cd->help->usage, pal_args_color, pal_reset);\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s%s\", pal_input_color, cd->name);\n\t\tif (show_children_shortcut (cd)) {\n\t\t\tr_strbuf_append (sb, pal_reset);\n\t\t\tfill_children_chars (sb, cd);\n\t\t}\n\t\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\t\tr_strbuf_appendf (sb, \"%s%s%s\", pal_args_color, cd->help->args_str, pal_reset);\n\t\t}\n\t}\n\tif (cd->help->summary) {\n\t\tr_strbuf_appendf (sb, \"   %s# %s%s\", pal_help_color, cd->help->summary, pal_reset);\n\t}\n\tr_strbuf_append (sb, \"\\n\");\n}\n\nstatic size_t calc_padding_len(RCmdDesc *cd) {\n\tsize_t name_len = strlen (cd->name);\n\tsize_t args_len = 0;\n\tsize_t children_length = 0;\n\tif (show_children_shortcut (cd)) {\n\t\tRStrBuf sb;\n\t\tr_strbuf_init (&sb);\n\t\tfill_children_chars (&sb, cd);\n\t\tchildren_length += r_strbuf_length (&sb);\n\t\tr_strbuf_fini (&sb);\n\t}\n\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\targs_len = strlen (cd->help->args_str);\n\t}\n\treturn name_len + args_len + children_length;\n}\n\nstatic size_t update_max_len(RCmdDesc *cd, size_t max_len) {\n\tsize_t val = calc_padding_len (cd);\n\treturn val > max_len? val: max_len;\n}\n\nstatic void print_child_help(RStrBuf *sb, RCmdDesc *cd, size_t max_len, bool use_color) {\n\tsize_t str_len = calc_padding_len (cd);\n\tint padding = str_len < max_len? max_len - str_len: 0;\n\tconst char *cd_summary = r_str_get (cd->help->summary);\n\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_args_color = use_color? cons->context->pal.args: \"\",\n\t\t   *pal_opt_color = use_color? cons->context->pal.reset: \"\",\n\t\t   *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tr_strbuf_appendf (sb, \"| %s%s\", pal_input_color, cd->name);\n\tif (show_children_shortcut (cd)) {\n\t\tr_strbuf_append (sb, pal_opt_color);\n\t\tfill_children_chars (sb, cd);\n\t}\n\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\tr_strbuf_appendf (sb, \"%s%s\", pal_args_color, cd->help->args_str);\n\t}\n\tr_strbuf_appendf (sb, \" %*s%s# %s%s\\n\", padding, \"\", pal_help_color, cd_summary, pal_reset);\n}\n\nstatic char *argv_group_get_help(RCmd *cmd, RCmdDesc *cd, bool use_color) {\n\tRStrBuf *sb = r_strbuf_new (NULL);\n\tfill_usage_strbuf (sb, cd, use_color);\n\n\tvoid **it_cd;\n\tsize_t max_len = 0;\n\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it_cd;\n\t\tmax_len = update_max_len (child, max_len);\n\t}\n\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it_cd;\n\t\tprint_child_help (sb, child, max_len, use_color);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nstatic char *argv_get_help(RCmd *cmd, RCmdDesc *cd, RCmdParsedArgs *a, size_t detail, bool use_color) {\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_label_color = use_color? cons->context->pal.label: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tRStrBuf *sb = r_strbuf_new (NULL);\n\n\tfill_usage_strbuf (sb, cd, use_color);\n\n\tswitch (detail) {\n\tcase 1:\n\t\treturn r_strbuf_drain (sb);\n\tcase 2:\n\t\tif (cd->help->description) {\n\t\t\tr_strbuf_appendf (sb, \"\\n%s\\n\", cd->help->description);\n\t\t}\n\t\tif (cd->help->examples) {\n\t\t\tr_strbuf_appendf (sb, \"\\n%sExamples:%s\\n\", pal_label_color, pal_reset);\n\t\t\tconst RCmdDescExample *it = cd->help->examples;\n\t\t\twhile (it->example) {\n\t\t\t\tr_strbuf_appendf (sb, \"| %s%s%s %s# %s%s\\n\", pal_input_color,\n\t\t\t\t\tit->example, pal_reset, pal_help_color, it->comment, pal_reset);\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\treturn r_strbuf_drain (sb);\n\tdefault:\n\t\tr_strbuf_free (sb);\n\t\treturn NULL;\n\t}\n}\n\nstatic char *oldinput_get_help(RCmd *cmd, RCmdDesc *cd, RCmdParsedArgs *a) {\n\tconst char *s = NULL;\n\tr_cons_push ();\n\tRCmdStatus status = r_cmd_call_parsed_args (cmd, a);\n\tif (status == R_CMD_STATUS_OK) {\n\t\tr_cons_filter ();\n\t\ts = r_cons_get_buffer ();\n\t}\n\tchar *res = strdup (r_str_get (s));\n\tr_cons_pop ();\n\treturn res;\n}\n\nR_API char *r_cmd_get_help(RCmd *cmd, RCmdParsedArgs *args, bool use_color) {\n\tchar *cmdid = strdup (r_cmd_parsed_args_cmd (args));\n\tchar *cmdid_p = cmdid + strlen (cmdid) - 1;\n\tsize_t detail = 0;\n\twhile (cmdid_p >= cmdid && *cmdid_p == '?') {\n\t\t*cmdid_p = '\\0';\n\t\tcmdid_p--;\n\t\tdetail++;\n\t}\n\n\tif (detail == 0) {\n\t\t// there should be at least one `?`\n\t\tfree (cmdid);\n\t\treturn NULL;\n\t}\n\n\tRCmdDesc *cd = cmdid_p >= cmdid? r_cmd_get_desc (cmd, cmdid): r_cmd_get_root (cmd);\n\tfree (cmdid);\n\tif (!cd || !cd->help) {\n\t\treturn NULL;\n\t}\n\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\tif (detail > 1 && cd->d.group_data.exec_cd) {\n\t\t\tcd = cd->d.group_data.exec_cd;\n\t\t}\n\t\t// fallthrough\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\tif (detail == 1 && !r_pvector_empty (&cd->children)) {\n\t\t\tif (args->argc > 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn argv_group_get_help (cmd, cd, use_color);\n\t\t}\n\t\treturn argv_get_help (cmd, cd, args, detail, use_color);\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\treturn oldinput_get_help (cmd, cd, args);\n\tcase R_CMD_DESC_TYPE_INNER:\n\t\tr_warn_if_reached ();\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n/** macro.c **/\n\nR_API RCmdMacroItem *r_cmd_macro_item_new(void) {\n\treturn R_NEW0 (RCmdMacroItem);\n}\n\nR_API void r_cmd_macro_item_free(RCmdMacroItem *item) {\n\tif (item) {\n\t\tfree (item->name);\n\t\tfree (item->args);\n\t\tfree (item->code);\n\t\tfree (item);\n\t}\n}\n\nR_API void r_cmd_macro_init(RCmdMacro *mac) {\n\tmac->counter = 0;\n\tmac->_brk_value = 0;\n\tmac->brk_value = &mac->_brk_value;\n\tmac->cb_printf = (void *)printf;\n\tmac->num = NULL;\n\tmac->user = NULL;\n\tmac->cmd = NULL;\n\tmac->macros = r_list_newf ((RListFree)r_cmd_macro_item_free);\n}\n\nR_API void r_cmd_macro_fini(RCmdMacro *mac) {\n\tr_list_free (mac->macros);\n\tmac->macros = NULL;\n}\n\n// XXX add support single line function definitions\n// XXX add support for single name multiple nargs macros\nR_API bool r_cmd_macro_add(RCmdMacro *mac, const char *oname) {\n\tstruct r_cmd_macro_item_t *macro;\n\tchar *name, *args = NULL;\n\t//char buf[R_CMD_MAXLEN];\n\tRCmdMacroItem *m;\n\tbool macro_update = false;\n\tRListIter *iter;\n\tchar *pbody;\n\t// char *bufp;\n\tchar *ptr;\n\tint lidx;\n\n\tif (!*oname) {\n\t\tr_cmd_macro_list (mac);\n\t\treturn false;\n\t}\n\n\tname = strdup (oname);\n\tif (!name) {\n\t\treturn false;\n\t}\n\n\tpbody = strchr (name, ';');\n\tif (!pbody) {\n\t\teprintf (\"Invalid macro body\\n\");\n\t\tfree (name);\n\t\treturn false;\n\t}\n\t*pbody = '\\0';\n\tpbody++;\n\n\tif (*name && name[1] && name[strlen (name)-1]==')') {\n\t\teprintf (\"r_cmd_macro_add: missing macro body?\\n\");\n\t\tfree (name);\n\t\treturn false;\n\t}\n\n\tmacro = NULL;\n\tptr = strchr (name, ' ');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\targs = ptr +1;\n\t}\n\tmacro_update = false;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (name, m->name)) {\n\t\t\tmacro = m;\n\t\t\t// keep macro->name\n\t\t\tfree (macro->code);\n\t\t\tfree (macro->args);\n\t\t\tmacro_update = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ptr) {\n\t\t*ptr = ' ';\n\t}\n\tif (!macro) {\n\t\tmacro = r_cmd_macro_item_new ();\n\t\tif (!macro) {\n\t\t\tfree (name);\n\t\t\treturn false;\n\t\t}\n\t\tmacro->name = strdup (name);\n\t}\n\n\tmacro->codelen = (pbody[0])? strlen (pbody)+2 : 4096;\n\tmacro->code = (char *)malloc (macro->codelen);\n\t*macro->code = '\\0';\n\tmacro->nargs = 0;\n\tif (!args) {\n\t\targs = \"\";\n\t}\n\tmacro->args = strdup (args);\n\tptr = strchr (macro->name, ' ');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tmacro->nargs = r_str_word_set0 (ptr+1);\n\t}\n\n\tfor (lidx = 0; pbody[lidx]; lidx++) {\n\t\tif (pbody[lidx] == ';') {\n\t\t\tpbody[lidx] = '\\n';\n\t\t} else if (pbody[lidx] == ')' && pbody[lidx - 1] == '\\n') {\n\t\t\tpbody[lidx] = '\\0';\n\t\t}\n\t}\n\tstrncpy (macro->code, pbody, macro->codelen);\n\tmacro->code[macro->codelen-1] = 0;\n\tif (macro_update == false) {\n\t\tr_list_append (mac->macros, macro);\n\t}\n\tfree (name);\n\treturn true;\n}\n\nR_API bool r_cmd_macro_rm(RCmdMacro *mac, const char *_name) {\n\tr_return_val_if_fail (mac && _name, false);\n\tRListIter *iter;\n\tRCmdMacroItem *m;\n\tchar *name = strdup (_name);\n\tif (!name) {\n\t\treturn false;\n\t}\n\tchar *ptr = strchr (name, ')');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t}\n\tbool ret = false;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (m->name, name)) {\n\t\t\tr_list_delete (mac->macros, iter);\n\t\t\teprintf (\"Macro '%s' removed.\\n\", name);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (name);\n\treturn ret;\n}\n\n// TODO: use mac->cb_printf which is r_cons_printf at the end\nR_API void r_cmd_macro_list(RCmdMacro *mac) {\n\tRCmdMacroItem *m;\n\tint j, idx = 0;\n\tRListIter *iter;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tmac->cb_printf (\"%d (%s %s; \", idx, m->name, m->args);\n\t\tfor (j=0; m->code[j]; j++) {\n\t\t\tif (m->code[j] == '\\n') {\n\t\t\t\tmac->cb_printf (\"; \");\n\t\t\t} else {\n\t\t\t\tmac->cb_printf (\"%c\", m->code[j]);\n\t\t\t}\n\t\t}\n\t\tmac->cb_printf (\")\\n\");\n\t\tidx++;\n\t}\n}\n\n// TODO: use mac->cb_printf which is r_cons_printf at the end\nR_API void r_cmd_macro_meta(RCmdMacro *mac) {\n\tRCmdMacroItem *m;\n\tint j;\n\tRListIter *iter;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tmac->cb_printf (\"(%s %s, \", m->name, m->args);\n\t\tfor (j=0; m->code[j]; j++) {\n\t\t\tif (m->code[j] == '\\n') {\n\t\t\t\tmac->cb_printf (\"; \");\n\t\t\t} else {\n\t\t\t\tmac->cb_printf (\"%c\", m->code[j]);\n\t\t\t}\n\t\t}\n\t\tmac->cb_printf (\")\\n\");\n\t}\n}\n\n#if 0\n(define name value\n  f $0 @ $1)\n\n(define loop cmd\n  loop:\n  ? $0 == 0\n  ?? .loop:\n  )\n\n.(define patata 3)\n#endif\n\nR_API int r_cmd_macro_cmd_args(RCmdMacro *mac, const char *ptr, const char *args, int nargs) {\n\tint i, j;\n\tchar *pcmd, cmd[R_CMD_MAXLEN];\n\tconst char *arg = args;\n\n\tfor (*cmd=i=j=0; j<R_CMD_MAXLEN && ptr[j]; i++,j++) {\n\t\tif (ptr[j]=='$') {\n\t\t\tif (ptr[j+1]>='0' && ptr[j+1]<='9') {\n\t\t\t\tint wordlen;\n\t\t\t\tint w = ptr[j+1]-'0';\n\t\t\t\tconst char *word = r_str_word_get0 (arg, w);\n\t\t\t\tif (word && *word) {\n\t\t\t\t\twordlen = strlen (word);\n\t\t\t\t\tif ((i + wordlen + 1) >= sizeof (cmd)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy (cmd+i, word, wordlen+1);\n\t\t\t\t\ti += wordlen-1;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Undefined argument %d\\n\", w);\n\t\t\t\t}\n\t\t\t} else if (ptr[j+1]=='@') {\n\t\t\t\tchar off[32];\n\t\t\t\tint offlen;\n\t\t\t\tofflen = snprintf (off, sizeof (off), \"%d\",\n\t\t\t\t\tmac->counter);\n\t\t\t\tif ((i + offlen + 1) >= sizeof (cmd)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemcpy (cmd+i, off, offlen+1);\n\t\t\t\ti += offlen-1;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tcmd[i] = ptr[j];\n\t\t\t\tcmd[i + 1] = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tcmd[i] = ptr[j];\n\t\t\tcmd[i + 1] = '\\0';\n\t\t}\n\t}\n\tfor (pcmd = cmd; *pcmd && (*pcmd == ' ' || *pcmd == '\\t'); pcmd++) {\n\t\t;\n\t}\n\t//eprintf (\"-pre %d\\n\", (int)mac->num->value);\n\tint xx = (*pcmd==')')? 0: mac->cmd (mac->user, pcmd);\n\t//eprintf (\"-pos %p %d\\n\", mac->num, (int)mac->num->value);\n\treturn xx;\n}\n\nR_API char *r_cmd_macro_label_process(RCmdMacro *mac, RCmdMacroLabel *labels, int *labels_n, char *ptr) {\n\tint i;\n\tfor (; *ptr == ' '; ptr++) {\n\t\t;\n\t}\n\tif (ptr[strlen (ptr) - 1]==':' && !strchr (ptr, ' ')) {\n\t\t/* label detected */\n\t\tif (ptr[0] == '.') {\n\t\t//\teprintf(\"---> GOTO '%s'\\n\", ptr+1);\n\t\t\t/* goto */\n\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t\t//\teprintf(\"---| chk '%s'\\n\", labels[i].name);\n\t\t\t\tif (!strcmp (ptr + 1, labels[i].name)) {\n\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NULL;\n\t\t} else\n\t\t/* conditional goto */\n\t\tif (ptr[0]=='?' && ptr[1]=='!' && ptr[2] != '?') {\n\t\t\tif (mac->num && mac->num->value != 0) {\n\t\t\t\tchar *label = ptr + 3;\n\t\t\t\tfor (; *label == ' ' || *label == '.'; label++) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\t// eprintf(\"===> GOTO %s\\n\", label);\n\t\t\t\t/* goto label ptr+3 */\n\t\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t\t\t\tif (!strcmp (label, labels[i].name)) {\n\t\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else\n\t\t/* conditional goto */\n\t\tif (ptr[0] == '?' && ptr[1] == '?' && ptr[2] != '?') {\n\t\t\tif (mac->num->value == 0) {\n\t\t\t\tchar *label = ptr + 3;\n\t\t\t\tfor (; label[0] == ' ' || label[0] == '.'; label++) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\t//\t\teprintf(\"===> GOTO %s\\n\", label);\n\t\t\t\t/* goto label ptr+3 */\n\t\t\t\tfor (i=0; i<*labels_n; i++) {\n\t\t\t\t\tif (!strcmp (label, labels[i].name)) {\n\t\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t//\teprintf(\"---| chk '%s'\\n\", labels[i].name);\n\t\t\t\tif (!strcmp (ptr + 1, labels[i].name)) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Add label */\n\t\t//\teprintf(\"===> ADD LABEL(%s)\\n\", ptr);\n\t\t\tif (i == 0) {\n\t\t\t\tstrncpy (labels[*labels_n].name, ptr, 64);\n\t\t\t\tlabels[*labels_n].ptr = ptr+strlen (ptr)+1;\n\t\t\t\t*labels_n = *labels_n + 1;\n\t\t\t}\n\t\t}\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n/* TODO: add support for spaced arguments */\nR_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {\n\tchar *args;\n\tint nargs = 0;\n\tchar *str, *ptr, *ptr2;\n\tRListIter *iter;\n\tstatic int macro_level = 0;\n\tRCmdMacroItem *m;\n\t/* labels */\n\tint labels_n = 0;\n\tstruct r_cmd_macro_label_t labels[MACRO_LABELS];\n\n\tstr = strdup (name);\n\tif (!str) {\n\t\tr_sys_perror (\"strdup\");\n\t\treturn false;\n\t}\n\tptr = strchr (str, ')');\n\tif (!ptr) {\n\t\teprintf (\"Missing end ')' parenthesis.\\n\");\n\t\tfree (str);\n\t\treturn false;\n\t} else {\n\t\t*ptr = '\\0';\n\t}\n\n\targs = strchr (str, ' ');\n\tif (args) {\n\t\t*args = '\\0';\n\t\targs++;\n\t\tnargs = r_str_word_set0 (args);\n\t}\n\n\tmacro_level++;\n\tif (macro_level > MACRO_LIMIT) {\n\t\teprintf (\"Maximum macro recursivity reached.\\n\");\n\t\tmacro_level--;\n\t\tfree (str);\n\t\treturn 0;\n\t}\n\tptr = strchr (str, ';');\n\tif (ptr) {\n\t\t*ptr = 0;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (str, m->name)) {\n\t\t\tchar *ptr = m->code;\n\t\t\tchar *end = strchr (ptr, '\\n');\n\t\t\tif (m->nargs != 0 && nargs != m->nargs) {\n\t\t\t\teprintf (\"Macro '%s' expects %d args, not %d\\n\", m->name, m->nargs, nargs);\n\t\t\t\tmacro_level --;\n\t\t\t\tfree (str);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmac->brk = 0;\n\t\t\tdo {\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\teprintf (\"Interrupted at (%s)\\n\", ptr);\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\t*end = '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tfree (str);\n\t\t\t\t\tr_cons_break_pop ();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_cons_flush ();\n\t\t\t\t/* Label handling */\n\t\t\t\tptr2 = r_cmd_macro_label_process (mac, &(labels[0]), &labels_n, ptr);\n\t\t\t\tif (!ptr2) {\n\t\t\t\t\teprintf (\"Oops. invalid label name\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ptr != ptr2) {\n\t\t\t\t\tptr = ptr2;\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\t*end = '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tend = strchr (ptr, '\\n');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Command execution */\n\t\t\t\tif (*ptr) {\n\t\t\t\t\tmac->num->value = value;\n\t\t\t\t\tint r = r_cmd_macro_cmd_args (mac, ptr, args, nargs);\n\t\t\t\t\t// TODO: handle quit? r == 0??\n\t\t\t\t\t// quit, exits the macro. like a break\n\t\t\t\t\tvalue = mac->num->value;\n\t\t\t\t\tif (r < 0) {\n\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\tr_cons_break_pop ();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\n';\n\t\t\t\t\tptr = end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmacro_level --;\n\t\t\t\t\tfree (str);\n\t\t\t\t\tgoto out_clean;\n\t\t\t\t}\n\n\t\t\t\t/* Fetch next command */\n\t\t\t\tend = strchr (ptr, '\\n');\n\t\t\t} while (!mac->brk);\n\t\t\tif (mac->brk) {\n\t\t\t\tmacro_level--;\n\t\t\t\tfree (str);\n\t\t\t\tgoto out_clean;\n\t\t\t}\n\t\t}\n\t}\n\teprintf (\"No macro named '%s'\\n\", str);\n\tmacro_level--;\n\tfree (str);\nout_clean:\n\tr_cons_break_pop ();\n\treturn true;\n}\n\nR_API int r_cmd_macro_break(RCmdMacro *mac, const char *value) {\n\tmac->brk = 1;\n\tmac->brk_value = NULL;\n\tmac->_brk_value = (ut64)r_num_math (mac->num, value);\n\tif (value && *value) {\n\t\tmac->brk_value = &mac->_brk_value;\n\t}\n\treturn 0;\n}\n\n/* RCmdParsedArgs */\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_new(const char *cmd, int n_args, char **args) {\n\tr_return_val_if_fail (cmd && n_args >= 0, NULL);\n\tRCmdParsedArgs *res = R_NEW0 (RCmdParsedArgs);\n\tres->has_space_after_cmd = true;\n\tres->argc = n_args + 1;\n\tres->argv = R_NEWS0 (char *, res->argc);\n\tres->argv[0] = strdup (cmd);\n\tint i;\n\tfor (i = 1; i < res->argc; i++) {\n\t\tres->argv[i] = strdup (args[i - 1]);\n\t}\n\treturn res;\n}\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_newcmd(const char *cmd) {\n\treturn r_cmd_parsed_args_new (cmd, 0, NULL);\n}\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_newargs(int n_args, char **args) {\n\treturn r_cmd_parsed_args_new (\"\", n_args, args);\n}\n\nR_API void r_cmd_parsed_args_free(RCmdParsedArgs *a) {\n\tif (!a) {\n\t\treturn;\n\t}\n\n\tint i;\n\tfor (i = 0; i < a->argc; i++) {\n\t\tfree (a->argv[i]);\n\t}\n\tfree (a->argv);\n\tfree (a);\n}\n\nstatic void free_array(char **arr, int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tfree (arr[i]);\n\t}\n\tfree (arr);\n}\n\nR_API bool r_cmd_parsed_args_setargs(RCmdParsedArgs *a, int n_args, char **args) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], false);\n\tchar **tmp = R_NEWS0 (char *, n_args + 1);\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\ttmp[0] = strdup (a->argv[0]);\n\tint i;\n\tfor (i = 1; i < n_args + 1; i++) {\n\t\ttmp[i] = strdup (args[i - 1]);\n\t\tif (!tmp[i]) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree_array (a->argv, a->argc);\n\ta->argv = tmp;\n\ta->argc = n_args + 1;\n\treturn true;\nerr:\n\tfree_array (tmp, n_args + 1);\n\treturn false;\n}\n\nR_API bool r_cmd_parsed_args_setcmd(RCmdParsedArgs *a, const char *cmd) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], false);\n\tchar *tmp = strdup (cmd);\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\tfree (a->argv[0]);\n\ta->argv[0] = tmp;\n\treturn true;\n}\n\nstatic void parsed_args_iterateargs(RCmdParsedArgs *a, RStrBuf *sb) {\n\tint i;\n\tfor (i = 1; i < a->argc; i++) {\n\t\tif (i > 1) {\n\t\t\tr_strbuf_append (sb, \" \");\n\t\t}\n\t\tr_strbuf_append (sb, a->argv[i]);\n\t}\n}\n\nR_API char *r_cmd_parsed_args_argstr(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tparsed_args_iterateargs (a, sb);\n\treturn r_strbuf_drain (sb);\n}\n\nR_API char *r_cmd_parsed_args_execstr(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\tRStrBuf *sb = r_strbuf_new (a->argv[0]);\n\tif (a->argc > 1 && a->has_space_after_cmd) {\n\t\tr_strbuf_append (sb, \" \");\n\t}\n\tparsed_args_iterateargs (a, sb);\n\treturn r_strbuf_drain (sb);\n}\n\nR_API const char *r_cmd_parsed_args_cmd(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\treturn a->argv[0];\n}\n\n/* RCmdDescriptor */\n\nstatic RCmdDesc *argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help, bool ht_insert) {\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_ARGV, name, help, ht_insert);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tres->d.argv_data.cb = cb;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn argv_new (cmd, parent, name, cb, help, true);\n}\n\nR_API RCmdDesc *r_cmd_desc_inner_new(RCmd *cmd, RCmdDesc *parent, const char *name, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_INNER, name, help, false);\n}\n\nR_API RCmdDesc *r_cmd_desc_group_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help, const RCmdDescHelp *group_help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_GROUP, name, group_help, true);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tRCmdDesc *exec_cd = NULL;\n\tif (cb && help) {\n\t\texec_cd = argv_new (cmd, res, name, cb, help, false);\n\t\tif (!exec_cd) {\n\t\t\tr_cmd_desc_remove (cmd, res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tres->d.group_data.exec_cd = exec_cd;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_oldinput_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name && cb, NULL);\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_OLDINPUT, name, help, true);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->d.oldinput_data.cb = cb;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_parent(RCmdDesc *cd) {\n\tr_return_val_if_fail (cd, NULL);\n\treturn cd->parent;\n}\n\nR_API bool r_cmd_desc_has_handler(RCmdDesc *cd) {\n\tr_return_val_if_fail (cd, false);\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\treturn cd->d.argv_data.cb;\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\treturn cd->d.oldinput_data.cb;\n\tcase R_CMD_DESC_TYPE_INNER:\n\t\treturn false;\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\treturn cd->d.group_data.exec_cd && r_cmd_desc_has_handler (cd->d.group_data.exec_cd);\n\t}\n\treturn false;\n}\n\nR_API bool r_cmd_desc_remove(RCmd *cmd, RCmdDesc *cd) {\n\tr_return_val_if_fail (cmd && cd, false);\n\tif (cd->parent) {\n\t\tcmd_desc_unset_parent (cd);\n\t}\n\tcmd_desc_remove_from_ht_cmds (cmd, cd);\n\tcmd_desc_free (cd);\n\treturn true;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, mrmacete, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n#include <r_hash.h>\n\n// TODO: deprecate bprintf and use Eprintf (bin->self)\n#define bprintf if (bin->verbose) eprintf\n#define Eprintf if (mo->verbose) eprintf\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\ntypedef struct {\n\tut8 * imports;\n\tRSkipList *relocs;\n} RWalkBindChainsContext;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 read_uleb128(ut8 **p, ut8 *end) {\n\tconst char *error = NULL;\n\tut64 v;\n\t*p = (ut8 *)r_uleb128 (*p, end - *p, &v, &error);\n\tif (error) {\n\t\teprintf (\"%s\", error);\n\t\tR_FREE (error);\n\t\treturn UT64_MAX;\n\t}\n\treturn v;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) *bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t) *bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 offset_to_vaddr(struct MACH0_(obj_t) *bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RBinFile *bf, ut64 offset) {\n\tr_return_val_if_fail (bf && bf->rbin, offset);\n\tRIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin? offset_to_vaddr (bin, offset): offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) *bin) {\n\t/*\n\t * These definitions are used by r2 -nn\n\t * must be kept in sync with libr/bin/d/macho\n\t */\n\tsdb_set (bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\" \"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\" \"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\" \"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\" \"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\" \"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\" \"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\" \"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\", 0);\n\tsdb_set (bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) *bin) {\n\tut8 magicbytes[4] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0 + bin->header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0 + bin->header_at, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats (bin);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\tchar section_flagname[128];\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tr_sys_perror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tchar *segment_flagname = NULL;\n#if R_BIN_MACH064\n\tsegment_flagname = r_str_newf (\"mach0_segment64_%u.offset\", (ut32)j);\n#else\n\tsegment_flagname = r_str_newf (\"mach0_segment_%u.offset\", (ut32)j);\n#endif\n\tsdb_num_set (bin->kv, segment_flagname, off, 0);\n\tfree (segment_flagname);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tr_sys_perror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.offset\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\t\n\t\t\tsdb_num_set (bin->kv, section_flagname, offset, 0);\n#if R_BIN_MACH064\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section64\", 0);\n#else\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\t\t\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section\", 0);\n#endif\n\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) error_message = x; goto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) *mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof (struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = r_buf_read_at (mo->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tEprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (symt, be);\n\tst.cmdsize = r_read_ble32 (symt + 4, be);\n\tst.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;\n\tst.nsyms = r_read_ble32 (symt + 12, be);\n\tst.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;\n\tst.strsize = r_read_ble32 (symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError (\"fail\");\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, mo->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tError (\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError (\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (mo->b, st.stroff, (ut8*)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError (\"Error: read (symstr)\");\n\t\t}\n\t\tut64 max_nsymtab = (r_buf_size (mo->b) - st.symoff) / sizeof (struct MACH0_(nlist));\n\t\tif (mo->nsymtab > max_nsymtab || !(mo->symtab = calloc (mo->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof (struct MACH0_(nlist)));\n\t\t\tlen = r_buf_read_at (mo->b, at, nlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tError (\"read (nlist)\");\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = r_read_ble32 (nlst, be);\n\t\t\tmo->symtab[i].n_type = r_read_ble8 (nlst + 4);\n\t\t\tmo->symtab[i].n_sect = r_read_ble8 (nlst + 5);\n\t\t\tmo->symtab[i].n_desc = r_read_ble16 (nlst + 6, be);\n#if R_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = r_read_ble64 (&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = r_read_ble32 (&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tR_FREE (mo->symstr);\n\tR_FREE (mo->symtab);\n\tEprintf (\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof (struct dylib_table_of_contents)))) {\n\t\t\tr_sys_perror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tut64 max_nmodtab = (bin->size - bin->dysymtab.modtaboff) / sizeof (struct MACH0_(dylib_module));\n\tif (bin->nmodtab > 0 && bin->nmodtab <= max_nmodtab) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof (struct MACH0_(dylib_module))))) {\n\t\t\tr_sys_perror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof (ut32)))) {\n\t\t\tr_sys_perror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn r_str_ndup ((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(RBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic;\t\t/* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length;\t/* total length of CodeDirectory blob */\n\t\tuint32_t version;\t/* compatibility version */\n\t\tuint32_t flags;\t\t/* setup and mode flags */\n\t\tuint32_t hashOffset;\t/* offset of hash slot element at index zero */\n\t\tuint32_t identOffset;\t/* offset of identifier string */\n\t\tuint32_t nSpecialSlots;\t/* number of special hash slots */\n\t\tuint32_t nCodeSlots;\t/* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit;\t/* limit to main image signature range */\n\t\tuint8_t hashSize;\t/* size of each hash in bytes */\n\t\tuint8_t hashType;\t/* type of hash (cdHashType* constants) */\n\t\tuint8_t platform;\t/* unused (must be zero) */\n\t\tuint8_t\tpageSize;\t/* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2;\t/* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc (1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf (\"Offset: 0x%08\"PFMT64x\"\\n\", off);\n\tr_buf_read_at (b, off, p, datasize);\n\tCS_CodeDirectory cscd = {0};\n\t#define READFIELD(x) cscd.x = r_read_ble32 (p + r_offsetof (CS_CodeDirectory, x), 1)\n\t#define READFIELD8(x) cscd.x = p[r_offsetof (CS_CodeDirectory, x)]\n\tREADFIELD (length);\n\tREADFIELD (version);\n\tREADFIELD (flags);\n\tREADFIELD (hashOffset);\n\tREADFIELD (identOffset);\n\tREADFIELD (nSpecialSlots);\n\tREADFIELD (nCodeSlots);\n\tREADFIELD (hashSize);\n\tREADFIELD (teamIDOffset);\n\tREADFIELD8 (hashType);\n\tREADFIELD (pageSize);\n\tREADFIELD (codeLimit);\n\teprintf (\"Version: %x\\n\", cscd.version);\n\teprintf (\"Flags: %x\\n\", cscd.flags);\n\teprintf (\"Length: %d\\n\", cscd.length);\n\teprintf (\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf (\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf (\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf (\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf (\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString (p, cscd.identOffset, psize);\n\teprintf (\"Identity: %s\\n\", identity);\n\tchar *teamId = readString (p, cscd.teamIDOffset, psize);\n\teprintf (\"TeamID: %s\\n\", teamId);\n\teprintf (\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree (identity);\n\tfree (teamId);\n\n\tint hashSize = 20; // SHA1 is default\n\tint algoType = R_HASH_SHA1;\n\tconst char *hashName = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\thashSize = 20;\n\t\thashName = \"sha1\";\n\t\talgoType = R_HASH_SHA1;\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\thashSize = 32;\n\t\talgoType = R_HASH_SHA256;\n\t\thashName = \"sha256\";\n\t\tbreak;\n\t}\n\t// computed cdhash\n\tRHash *ctx = r_hash_new (true, algoType);\n\tint fofsz = cscd.length;\n\tif (fofsz > 0 && fofsz < (r_buf_size (b) - off)) {\n\t\tut8 *fofbuf = calloc (fofsz, 1);\n\t\tif (fofbuf) {\n\t\t\tint i;\n\t\t\tif (r_buf_read_at (b, off, fofbuf, fofsz) != fofsz) {\n\t\t\t\teprintf (\"Invalid cdhash offset/length values\\n\");\n\t\t\t}\n\t\t\tr_hash_do_begin (ctx, algoType);\n\t\t\tif (algoType == R_HASH_SHA1) {\n\t\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t\t} else {\n\t\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t\t}\n\t\t\tr_hash_do_end (ctx, algoType);\n\t\t\teprintf (\"ph %s @ 0x%\"PFMT64x\"!%d\\n\", hashName, off, fofsz);\n\t\t\teprintf (\"ComputedCDHash: \");\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t\teprintf (\"\\n\");\n\t\t\tfree (fofbuf);\n\t\t}\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf (\"Hashed region: 0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * hashSize;\n\t\teprintf (\"0x%08\"PFMT64x\"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < hashSize; k++) {\n\t\t\teprintf (\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = R_MIN (sizeof (fofbuf), cscd.codeLimit - fof);\n\t\tr_buf_read_at (b, fof, fofbuf, sizeof (fofbuf));\n\t\tr_hash_do_begin (ctx, algoType);\n\t\tif (algoType == R_HASH_SHA1) {\n\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t} else {\n\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t}\n\t\tr_hash_do_end (ctx, algoType);\n\t\tif (memcmp (hash + idx, ctx->digest, hashSize)) {\n\t\t\teprintf (\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"  OK\");\n\t\t}\n\t\teprintf (\"\\n\");\n\t}\n\tr_hash_free (ctx);\n\tfree (p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {0};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {0};\n\tstruct super_blob_t super = {{0}};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_buf_read_ble32_at (bin->b, data, mach0_endian);\n\tsuper.blob.length = r_buf_read_ble32_at (bin->b, data + 4, mach0_endian);\n\tsuper.count = r_buf_read_ble32_at (bin->b, data + 8, mach0_endian);\n\tchar *verbose = r_sys_getenv (\"RABIN2_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree (verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, mach0_endian);\n\t\tidx.offset = r_read_ble32 (&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = {0};\n\t\t\t\tentitlements.magic = r_buf_read_ble32_at (bin->b, off, mach0_endian);\n\t\t\t\tentitlements.length = r_buf_read_ble32_at (bin->b, off + 4, mach0_endian);\n\t\t\t\tlen = entitlements.length - sizeof (struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < r_buf_size (bin->b)) {\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + sizeof (struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory (bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = {0};\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset, header, sizeof (header));\n\t\t\t\tut32 length = R_MIN (UT16_MAX, r_read_ble32 (header + 4, 1));\n\t\t\t\tut8 *p = calloc (length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32*)p;\n\t\t\t\t\teprintf (\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf (\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf (\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t\t{\n\t\t\t\tut8 p[256];\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 16, p, sizeof (p));\n\t\t\t\tp[sizeof (p) - 1] = 0;\n\t\t\t\tut32 slot_size = r_read_ble32 (p + 8, 1);\n\t\t\t\tif (slot_size < sizeof (p)) {\n\t\t\t\t\tut32 ident_size = r_read_ble32 (p + 8, 1);\n\t\t\t\t\tif (!ident_size || ident_size > sizeof (p) - 28) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar *ident = r_str_ndup ((const char *)p + 28, ident_size);\n\t\t\t\t\tif (ident) {\n\t\t\t\t\t\tsdb_set (bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\t\tfree (ident);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"Invalid code slot size\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) *bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = r_read_ble32 (tmp, bin->big_endian);\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size ||\n\t\toff + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command) + sizeof (flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tcount = r_read_ble32 (tmp, bin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc (1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset (bin->libs[lib], 0, R_BIN_MACH0_STRING_LENGTH);\n\tlen = r_buf_read_at (bin->b, off + dl.dylib.name,\n\t\t(ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH - 1);\n\tbin->libs[lib][R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic size_t get_word_size(struct MACH0_(obj_t) *bin) {\n\tconst size_t word_size = MACH0_(get_bits)(bin) / 8;\n\treturn R_MAX (word_size, 4);\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\tbin->segs_count = bin->nsegs;\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) *bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\tchar cmd_flagname[128];\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size) {\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylinker\", 0);\n\t\t\t\tR_FREE (bin->intrp);\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8*)malloc (datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\tr_buf_read_at (bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = r_read_ble32 (db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = r_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = r_read_ble16 (db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = offset_to_vaddr(bin, dw);\n\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf (\"Cd 4 %d @ 0x%\"PFMT64x\"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\t\tut8 buf[8];\n\t\t\t\tif (r_buf_read_at (bin->b, off + 8, buf, sizeof (buf)) == sizeof (buf)) {\n\t\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t\t}\n\t\t\t\t\thas_chained_fixups = parse_chained_fixups (bin, dataoff, datasize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n#if 0\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"reconstructing chained fixups\\n\");\n\t\t}\n#endif\n\t\treconstruct_chained_fixup (bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) *mo) {\n\tif (!init_hdr (mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items (mo)) {\n\t\tEprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {\n\tr_return_if_fail (options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n}\n\nstatic void *duplicate_ptr(void *p) {\n\treturn p;\n}\n\nstatic void free_only_key(HtPPKv *kv) {\n\tfree (kv->key);\n}\n\nstatic size_t ptr_size(void *c) {\n\t// :D\n\treturn 8;\n}\n\n// XXX should be deprecated its never called\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (options) {\n\t\tbin->verbose = options->verbose;\n\t\tbin->header_at = options->header_at;\n\t\tbin->symbols_off = options->symbols_off;\n\t}\n\tbin->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8 *)r_file_slurp (file, &binsz);\n\tbin->size = binsz;\n\tif (!buf) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->imports_by_name = ht_pp_new ((HtPPDupValue)duplicate_ptr, free_only_key, (HtPPCalcSizeV)ptr_size);\n\treturn bin;\n}\n\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options) {\n\tr_return_val_if_fail (buf, NULL);\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = r_buf_ref (buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\t\tbin->size = r_buf_size (bin->b);\n\t\tif (options) {\n\t\t\tbin->verbose = options->verbose;\n\t\t\tbin->header_at = options->header_at;\n\t\t\tbin->symbols_off = options->symbols_off;\n\t\t}\n\t\tif (!init (bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool __isDataSection(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRList *MACH0_(get_segments)(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)r_bin_section_free);\n\tsize_t i, j;\n\n\t/* for core files */\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSection *s = r_bin_section_new (NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t//TODO s->flags = seg->flags;\n\t\t\ts->name = r_str_ndup (seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\tr_str_filter (s->name, -1);\n\t\t\ts->perm = prot2perm (seg->initprot);\n\t\t\ts->add = true;\n\t\t\tr_list_append (list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = R_MIN (bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRBinSection *s = R_NEW0 (RBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t//s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = r_str_ndup (bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = r_str_newf (\"%u.%s\", (ut32)i, bin->segs[segment_index].segname);\n\t\t\ts->name = r_str_newf (\"%s.%s\", segment_name, section_name);\n\t\t\ts->is_data = __isDataSection (s);\n\t\t\tif (strstr (section_name, \"interpos\") || strstr (section_name, \"__mod_\")) {\n#if R_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = r_str_newf (\"Cd %d[%\"PFMT64d\"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\tr_list_append (list, s);\n\t\t\tfree (segment_name);\n\t\t\tfree (section_name);\n\t\t}\n\t}\n\treturn list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, 16);\n\t\t\tsectname[16] = 0;\n\t\t\tr_str_filter (sectname, -1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc (bin->nsects + 1, sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, 17);\n\t\tr_str_filter (sectname, -1);\n\t\tr_str_ncpy (raw_segname, bin->sects[i].segname, 16);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) *bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf (\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf (\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup (symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = r_str_newf (\"%\"PFMT64x\".%s\", addr, name);\n\tht_pp_find (hash, key, &found);\n\tif (found) {\n\t\tfree (key);\n\t\treturn true;\n\t}\n\tht_pp_insert (hash, key, \"1\");\n\tfree (key);\n\treturn false;\n}\n\nstatic char *get_name(struct MACH0_(obj_t) *mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char*)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = r_str_ndup (symstr, len);\n\t\tif (filter) {\n\t\t\tr_str_filter (res, -1);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) *bin, RExportsIterator iterator, void *ctx) {\n\tRList *states = NULL;\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn 0;\n\t}\n\tut8 *trie = calloc (size + 1, 1);\n\tif (!trie) {\n\t\treturn 0;\n\t}\n\tut8 *end = trie + size;\n\tif (r_buf_read_at (bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = r_list_newf ((RListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = R_NEW0 (RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\tr_list_push (states, root);\n\n\tdo {\n\t\tRTrieState * state = r_list_get_top (states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128 (&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128 (&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128 (&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128 (&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen ((char*) p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar * name = NULL;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\tr_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = r_str_append (name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar * stub_name = r_str_newf (\"stub.%s\", name);\n\t\t\t\t\titerator (bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator (bin, name, flags, resolver, ctx);\n\t\t\t\t\tR_FREE (stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator (bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tR_FREE (name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128 (&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\tfree (r_list_pop (states));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState * next = R_NEW0 (RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *) p;\n\t\tp += strlen (next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128 (&p, end);\n\t\tif (tr == UT64_MAX || tr >= size) {\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\tif (next->node >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRListIter *it;\n\t\t\tRTrieState *s;\n\t\t\tr_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tR_FREE (next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\tr_list_push (states, next);\n\t} while (r_list_length (states));\n\nbeach:\n\tr_list_free (states);\n\tR_FREE (trie);\n\treturn count;\n}\n\nstatic void fill_exports_list(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRList *list = (RList*) ctx;\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn;\n\t}\n\tsym->vaddr = offset_to_vaddr (bin, offset);\n\tsym->paddr = offset;\n\tsym->type = \"EXT\";\n\tsym->name = strdup (name);\n\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\tr_list_append (list, sym);\n}\n\n// TODO: Return RList<RBinSymbol> // 2x speedup\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin) {\n\tstatic RList * cache = NULL; // XXX DONT COMMIT WITH THIS\n\tstruct symbol_t *symbols;\n\tsize_t j, s, symbols_size, symbols_count;\n\tut32 to, from;\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (cache) {\n\t\treturn cache;\n\t}\n\tRList *list = r_list_newf ((RListFree)r_bin_symbol_free);\n\tcache = list;\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\twalk_exports (bin, fill_exports_list, list);\n\tif (r_list_length (list)) {\n\t\tRListIter *it;\n\t\tRBinSymbol *s;\n\t\tr_list_foreach (list, it, s) {\n\t\t\tinSymtab (hash, s->name, s->vaddr);\n\t\t}\n\t}\n\n\tif (!bin->symtab || !bin->symstr) {\n\t\tht_pp_free (hash);\n\t\treturn list;\n\t}\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1 || !(symbols = calloc (1, symbols_size))) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t}\n\tj = 0; // symbol_idx\n\tbin->main_addr = 0;\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = bin->symtab[i].n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, sym->vaddr);\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tsym->bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tint stridx = bin->symtab[i].n_strx;\n\t\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tif (!inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\tr_list_append (list, sym);\n\t\t\t} else {\n\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tstruct symbol_t symbol;\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub (bin, &symbol, i)) {\n\t\t\tj++;\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = symbol.addr;\n\t\t\tsym->paddr = symbol.offset;\n\t\t\tsym->name = symbol.name;\n\t\t\tif (!sym->name) {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tsym->is_imported = symbol.is_imported;\n\t\t\tr_list_append (list, sym);\n\t\t}\n\t}\n\n\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1) maybe wrong\n\t\t\tRBinSymbol *sym = R_NEW0(RBinSymbol);\n\t\t\t/* is symbol */\n\t\t\tsym->vaddr = st->n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsym->is_imported = symbols[j].is_imported;\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tr_list_append (list, sym);\n\t\t\tj++;\n\t\t}\n\t}\n\tht_pp_free (hash);\n\t// bin->symbols = symbols;\n    free (symbols);\n\treturn list;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx*) ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = offset_to_vaddr (bin, offset);\n\t\tif (inSymtab (sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup (name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin) {\n\tstruct symbol_t *symbols;\n\tint j, s, stridx, symbols_size, symbols_count;\n\tut32 to, from, i;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tr_return_val_if_fail (bin, NULL);\n\tint n_exports = walk_exports (bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\t\tbin->dysymtab.nundefsym );\n\t\tsymbols_count += bin->nsymtab;\n\t\tif (symbols_count < 0 || ((st64)symbols_count * 2) > ST32_MAX) {\n\t\t\teprintf (\"Symbols count overflow\\n\");\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = get_name (bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree (symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub (bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = r_str_newf (\"entry%d\", i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tR_FREE (symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t} else {\n\t\tsymbols_size = (symbols_count + 1) * sizeof (struct symbol_t);\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports (bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free (hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t) *bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym;\n\tsize_t wordsize;\n\tut32 stype;\n\twordsize = get_word_size (bin);\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case ((T) / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\tCASE(8);\n\tCASE(16);\n\tCASE(32);\n\tCASE(64);\n\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {\n\t\t\t\tint indidx = bin->sects[i].reserved1 + j;\n\t\t\t\tif (indidx < 0 || indidx >= bin->nindirectsyms) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (idx == bin->indirectsyms[indidx]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc (bin->dysymtab.nundefsym + 1, sizeof (struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = get_name (bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\tr_str_ncpy (imports[j].name, imp_name, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\tfree (imp_name);\n\t\t} else {\n\t\t\t//imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstatic int reloc_comparator(struct reloc_t *a, struct reloc_t *b) {\n\treturn a->addr - b->addr;\n}\n\nstatic void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; // enum RelocationInfoType\n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}\n\nstatic bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {\n\tr_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);\n\tRWalkBindChainsContext *ctx = context;\n\tut8 *imports = ctx->imports;\n\tstruct MACH0_(obj_t) *bin = event_details->bin;\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 fixups_size = bin->fixups_size;\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;\n\tut64 addend = 0;\n\tif (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {\n\t\taddend = ((RFixupBindEventDetails *) event_details)->addend;\n\t}\n\n\tif (import_index < imports_count) {\n\t\tut64 name_offset;\n\t\tswitch (imports_format) {\n\t\t\tcase DYLD_CHAINED_IMPORT: {\n\t\t\t\tstruct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND: {\n\t\t\t\tstruct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND64: {\n\t\t\t\tstruct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported imports format\\n\");\n\t\t\t\treturn false;\n\t\t}\n\n\t\tut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;\n\n\t\tif (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {\n\t\t\tchar *name = r_buf_get_string (bin->b, symbols_offset + name_offset);\n\t\t\tif (name) {\n\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\tif (!reloc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treloc->addr = offset_to_vaddr (bin, event_details->offset);\n\t\t\t\treloc->offset = event_details->offset;\n\t\t\t\treloc->ord = import_index;\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\treloc->size = 8;\n\t\t\t\treloc->addend = addend;\n\t\t\t\tr_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);\n\t\t\t\tr_skiplist_insert_autofree (ctx->relocs, reloc);\n\t\t\t\tfree (name);\n\t\t\t} else if (bin->verbose) {\n\t\t\t\teprintf (\"Malformed chained bind: failed to read name\\n\");\n\t\t\t}\n\t\t} else if (bin->verbose) {\n\t\t\teprintf (\"Malformed chained bind: name_offset out of bounds\\n\");\n\t\t}\n\t} else if (bin->verbose) {\n\t\teprintf (\"Malformed chained bind: import out of length\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {\n\tr_return_if_fail (bin && bin->fixups_offset);\n\n\tut8 *imports = NULL;\n\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 imports_offset = bin->fixups_header.imports_offset;\n\tif (!imports_count || !imports_offset) {\n\t\treturn;\n\t}\n\tif (bin->fixups_header.symbols_format != 0) {\n\t\teprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");\n\t\treturn;\n\t}\n\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut64 imports_size;\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\timports_size = sizeof (struct dyld_chained_import) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unsupported chained imports format: %d\\n\", imports_format);\n\t\t\tgoto beach;\n\t}\n\n\timports = malloc (imports_size);\n\tif (!imports) {\n\t\tgoto beach;\n\t}\n\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"i\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"ii\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"il\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tRWalkBindChainsContext ctx;\n\tctx.imports = imports;\n\tctx.relocs = relocs;\n\n\tMACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);\n\nbeach:\n\tfree (imports);\n}\n\nstatic bool is_valid_ordinal_table_size(ut64 size) {\n\treturn size > 0 && size <= UT16_MAX;\n}\n\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin) {\n\tRSkipList *relocs = NULL;\n\tRPVector *threaded_binds = NULL;\n\tsize_t wordsize = get_word_size (bin);\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes, rel_type = 0;\n\t\tsize_t bind_size, lazy_size, weak_size;\n\n#define CASE(T) case ((T) / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\t\tweak_size = bin->dyld_info->weak_bind_size;\n\n\t\tif (!bind_size && !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off + bind_size + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->weak_bind_off + weak_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tut64 amount = bind_size + lazy_size + weak_size;\n\t\tif (amount == 0 || amount > UT32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->segs) {\n\t\t\treturn NULL;\n\t\t}\n\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, amount + 1);\n\t\tif (!opcodes) {\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->weak_bind_off, opcodes + bind_size + lazy_size, weak_size);\n\t\tif (len < amount) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tR_FREE (opcodes);\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize_t partition_sizes[] = {bind_size, lazy_size, weak_size};\n\t\tsize_t pidx;\n\t\tint opcodes_offset = 0;\n\t\tfor (pidx = 0; pidx < R_ARRAY_SIZE (partition_sizes); pidx++) {\n\t\t\tsize_t partition_size = partition_sizes[pidx];\n\n\t\t\tut8 type = 0;\n\t\t\tint lib_ord = 0, seg_idx = -1, sym_ord = -1;\n\t\t\tchar *sym_name = NULL;\n\t\t\tsize_t j, count, skip;\n\t\t\tst64 addend = 0;\n\t\t\tut64 addr = bin->segs[0].vmaddr;\n\t\t\tut64 segment_size = bin->segs[0].filesize;\n\t\t\tif (bin->segs[0].filesize != bin->segs[0].vmsize) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t}\n\t\t\tif (segment_size > bin->size) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t\tsegment_size = bin->size;\n\t\t\t}\n\t\t\tut64 segment_end_addr = addr + segment_size;\n\n\t\t\tut8 *p = opcodes + opcodes_offset;\n\t\t\tut8 *end = p + partition_size;\n\t\t\tbool done = false;\n\t\t\twhile (!done && p < end) {\n\t\t\t\tut8 imm = *p & BIND_IMMEDIATE_MASK;\n\t\t\t\tut8 op = *p & BIND_OPCODE_MASK;\n\t\t\t\tp++;\n\t\t\t\tswitch (op) {\n\t\t\t\tcase BIND_OPCODE_DONE: {\n\t\t\t\t\tbool in_lazy_binds = pidx == 1;\n\t\t\t\t\tif (!in_lazy_binds) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_THREADED: {\n\t\t\t\t\tswitch (imm) {\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\t\t\tut64 table_size = read_uleb128 (&p, end);\n\t\t\t\t\t\tif (!is_valid_ordinal_table_size (table_size)) {\n\t\t\t\t\t\t\tbprintf (\"Error: BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size is wrong\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthreaded_binds = r_pvector_new_with_len ((RPVectorFree) &free, table_size);\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tsym_ord = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY:\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tint cur_seg_idx = (seg_idx != -1)? seg_idx: 0;\n\t\t\t\t\t\t\tsize_t n_threaded_binds = r_pvector_len (threaded_binds);\n\t\t\t\t\t\t\twhile (addr < segment_end_addr) {\n\t\t\t\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\t\t\t\tut64 paddr = addr - bin->segs[cur_seg_idx].vmaddr + bin->segs[cur_seg_idx].fileoff;\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, paddr, tmp, 8) != 8) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = false;\n\t\t\t\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\t\t\t\tbool is_auth = (raw_ptr & (1ULL << 63)) != 0;\n\t\t\t\t\t\t\t\tbool is_bind = (raw_ptr & (1ULL << 62)) != 0;\n\t\t\t\t\t\t\t\tint ordinal = -1;\n\t\t\t\t\t\t\t\tint addend = -1;\n\t\t\t\t\t\t\t\tut64 delta;\n\t\t\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ordinal != -1) {\n\t\t\t\t\t\t\t\t\tif (ordinal >= n_threaded_binds) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Malformed bind chain\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *ref = r_pvector_at (threaded_binds, ordinal);\n\t\t\t\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Inconsistent bind opcodes\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\t\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t*reloc = *ref;\n\t\t\t\t\t\t\t\t\treloc->addr = addr;\n\t\t\t\t\t\t\t\t\treloc->offset = paddr;\n\t\t\t\t\t\t\t\t\tif (addend != -1) {\n\t\t\t\t\t\t\t\t\t\treloc->addend = addend;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_skiplist_insert (relocs, reloc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddr += delta * wordsize;\n\t\t\t\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\t\tlib_ord = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\t\tlib_ord = read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\t\tsym_name = (char*)p;\n\t\t\t\t\twhile (*p++ && p < end) {\n\t\t\t\t\t\t/* empty loop */\n\t\t\t\t\t}\n\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsym_ord = -1;\n\t\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < UT16_MAX) {\n\t\t\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\t\t\tsize_t stridx = 0;\n\t\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\t\t\tif (iundefsym >= 0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\t\t\tint sidx = iundefsym + j;\n\t\t\t\t\t\t\t\tif (sidx < 0 || sidx >= bin->nsymtab) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\t\t\tif (stridx >= bin->symstrlen) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found && !strcmp ((const char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\t\taddend = r_sleb128 ((const ut8 **)&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tseg_idx = imm;\n\t\t\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\t\tfree (opcodes);\n\t\t\t\t\t\tr_skiplist_free (relocs);\n\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\treturn NULL; // early exit to avoid future mayhem\n\t\t\t\t\t}\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + read_uleb128 (&p, end);\n\t\t\t\t\tsegment_end_addr = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddr += read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n#define DO_BIND() do {\\\n\tif (sym_ord < 0 && !sym_name) break;\\\n\tif (!threaded_binds) {\\\n\t\tif (seg_idx < 0 ) break;\\\n\t\tif (!addr) break;\\\n\t}\\\n\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\\\n\treloc->addr = addr;\\\n\tif (seg_idx >= 0) {\\\n\t\treloc->offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\n\t\tif (type == BIND_TYPE_TEXT_PCREL32)\\\n\t\t\treloc->addend = addend - (bin->baddr + addr);\\\n\t\telse\\\n\t\t\treloc->addend = addend;\\\n\t} else {\\\n\t\treloc->addend = addend;\\\n\t}\\\n\t/* library ordinal ??? */ \\\n\treloc->ord = lib_ord;\\\n\treloc->ord = sym_ord;\\\n\treloc->type = rel_type;\\\n\tif (sym_name)\\\n\t\tr_str_ncpy (reloc->name, sym_name, 256);\\\n\tif (threaded_binds)\\\n\t\tr_pvector_set (threaded_binds, sym_ord, reloc);\\\n\telse\\\n\t\tr_skiplist_insert (relocs, reloc);\\\n} while (0)\n\t\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\t\tif (!threaded_binds && addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode 0x%\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\tif (!threaded_binds) {\n\t\t\t\t\t\taddr += wordsize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsym_ord++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += read_uleb128 (&p, end) + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128 (&p, end);\n\t\t\t\t\tskip = read_uleb128 (&p, end);\n\t\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDO_BIND ();\n\t\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#undef DO_BIND\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\t\t\tR_FREE (opcodes);\n\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\treturn relocs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topcodes_offset += partition_size;\n\t\t}\n\n\t\tR_FREE (opcodes);\n\t\tr_pvector_free (threaded_binds);\n\t\tthreaded_binds = NULL;\n\t}\n\n\tif (bin->symtab && bin->symstr && bin->sects && bin->indirectsyms) {\n\t\tint j;\n\t\tint amount = bin->dysymtab.nundefsym;\n\t\tif (amount < 0) {\n\t\t\tamount = 0;\n\t\t}\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < amount; j++) {\n\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\tif (!reloc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_ptr (bin, reloc, bin->dysymtab.iundefsym + j)) {\n\t\t\t\treloc->ord = j;\n\t\t\t\tr_skiplist_insert_autofree (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tR_FREE (reloc);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bin->symtab && bin->dysymtab.extreloff && bin->dysymtab.nextrel) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tparse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);\n\t}\n\n\tif (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\twalk_bind_chains (bin, relocs);\n\t}\nbeach:\n\tr_pvector_free (threaded_binds);\n\treturn relocs;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tut64 ea = entry_to_vaddr (bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = R_NEW0 (struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = addr_to_offset (bin, entry->addr);\n\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf (\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\tchar lib_flagname[128];\t\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tchar lib_flagname[128];\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof (struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t\tr_str_ncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cputype_from_hdr) (&bin->hdr): \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_VAX780:\treturn \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785:\treturn \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750:\treturn \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730:\treturn \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII:\treturn \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200:\treturn \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500:\treturn \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600:\treturn \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650:\treturn \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800:\treturn \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII:\treturn \"uvaxIII\";\n\t\tdefault:\t\t\treturn \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030:\treturn \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040:\treturn \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn \"mc68030 only\";\n\t\tdefault:\t\t\treturn \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: \t\t\treturn \"386\";\n\t\tcase CPU_SUBTYPE_486: \t\t\treturn \"486\";\n\t\tcase CPU_SUBTYPE_486SX: \t\treturn \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: \t\treturn \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn \"Xeon MP\";\n\t\tdefault:\t\t\t\treturn \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn \"x86 arch 1\";\n\t\tdefault:\t\t\treturn \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC88100:\treturn \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110:\treturn \"mc88110\";\n\t\tdefault:\t\t\treturn \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC98601:\treturn \"mc98601\";\n\t\tdefault:\t\t\treturn \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn \"hppa7100LC\";\n\t\tdefault:\t\t\treturn \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8:\treturn \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E:\treturn \"arm64e\";\n\t\tdefault:\t\t\treturn \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf (\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn \"all\";\n\t\tdefault:\t\t\treturn \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn \"r3000\";\n\t\tdefault:\t\t\treturn \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_I860_860:\treturn \"860\";\n\t\tdefault:\t\t\treturn \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn \"970\";\n\t\tdefault:\t\t\treturn \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tr_return_val_if_fail (hdr, NULL);\n\treturn strdup (cpusubtype_tostring (hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cpusubtype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET:    mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_filetype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n#if FEATURE_SYMLIST\n\t\t (void)MACH0_(get_symbols_list) (bin);\n#else\n\t\t (void)MACH0_(get_symbols) (bin);\n#endif\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree (MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset (bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va (bf, 0);\n\tcb_printf (\"pf.mach0_header @ 0x%08\"PFMT64x\"\\n\", pvaddr);\n\tcb_printf (\"0x%08\"PFMT64x\"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof (word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\t\tif (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { \\\n\t\t\teprintf (\"Invalid address in buffer.\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\taddr += 4; \\\n\t\tpvaddr += 4;\\\n\t\tword = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds && addr < length; n++) {\n\t\tREADWORD ();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf (\"pf.%s @ 0x%08\"PFMT64x\"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string (lcType));\n\t\tREADWORD ();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  platform    %s\\n\",\n\t\t\t\tpvaddr, build_version_platform_to_string (r_buf_read_le32_at (buf, addr)));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  minos       %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 4, r_buf_read_le16_at (buf, addr + 6), r_buf_read8_at (buf, addr + 5),\n\t\t\t\tr_buf_read8_at (buf, addr + 4));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  sdk         %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, addr + 12);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  ntools      %d\\n\",\n\t\t\t\tpvaddr + 12, ntools);\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf (\"pf.mach0_build_version_tool @ 0x%08\"PFMT64x\"\\n\", pvaddr + off);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  tool        %s\\n\",\n\t\t\t\t\tpvaddr + off, build_version_tool_to_string (r_buf_read_le32_at (buf, addr + off)));\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  version     %d.%d.%d\\n\",\n\t\t\t\t\tpvaddr + off, r_buf_read_le16_at (buf, addr + off + 2), r_buf_read8_at (buf, addr + off + 1),\n\t\t\t\t\tr_buf_read8_at (buf, addr + off));\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\t\tut8 data[64] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, data, sizeof (data));\n#if R_BIN_MACH064\n\t\t\t\tut64 ep = r_read_ble64 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\t\tut64 ss = r_read_ble64 (&data[8], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr +  8, ss);\n#else\n\t\t\t\tut32 ep = r_read_ble32 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\t\tut32 ss = r_read_ble32 (&data[4], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr +  4, ss);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = r_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *id = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (id));\n\t\t\tif (id) {\n\t\t\t\tfree (id);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID:\n\t\t\t{\n\t\t\t\tut8 i, uuid[16];\n\t\t\t\tr_buf_read_at (buf, addr, uuid, sizeof (uuid));\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  uuid        \", pvaddr);\n\t\t\t\tfor (i = 0; i < sizeof (uuid); i++) {\n\t\t\t\t\tcb_printf (\"%02x\", uuid[i]);\n\t\t\t\t}\n\t\t\t\tcb_printf (\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64:\n\t\t\t{\n\t\t\t\tut8 name[17] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, name, sizeof (name) - 1);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  name        %s\\n\", pvaddr, name);\n\t\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr - 8 + (is64 ? 64 : 48));\n\t\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\t\tif (is64) {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section64 @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 80;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 68;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *load_dylib = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (load_dylib));\n\t\t\tif (load_dylib) {\n\t\t\t\tfree (load_dylib);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = r_buf_get_string (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, r_str_get (rpath));\n\t\t\tif (rpath) {\n\t\t\t\tfree (rpath);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word = r_buf_read_le32_at (buf, addr);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptoff   0x%08x\\n\", pvaddr, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptsize  %d\\n\", pvaddr + 4, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\tr_buf_read_at (buf, addr, (ut8 *)words, sizeof (words));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf (\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree (mh);\n}\n\nRList *MACH0_(mach_fields)(RBinFile *bf) {\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr) (buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\tfree (mh);\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = pa2va (bf, 0);\n\tut64 paddr = 0;\n\n\tr_list_append (ret, r_bin_field_new (addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tchar load_command_flagname[128];\n\tfor (n = 0; n < mh->ncmds && paddr < length; n++) {\n\t\tut32 lcType = r_buf_read_ble32_at (buf, paddr, isBe);\n\t\tut32 word = r_buf_read_ble32_at (buf, paddr + 4, isBe);\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tsnprintf (load_command_flagname, sizeof (load_command_flagname), \"load_command_%d_%s\", n, cmd_to_string (lcType));\n\t\t\tr_list_append (ret, r_bin_field_new (addr, addr, 1, load_command_flagname, pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, paddr + 20);\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\tchar tool_flagname[32];\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\tsnprintf (tool_flagname, sizeof (tool_flagname), \"tool_%d\", j++);\n\t\t\t\tr_list_append (ret, r_bin_field_new (addr + off, addr + off, 1, tool_flagname, \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr + (is64 ? 64 : 48));\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tchar section_flagname[128];\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64? \"mach0_section64\": \"mach0_section\";\n\t\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"section_%u\", (ut32)j++);\n\t\t\t\tRBinField *f = r_bin_field_new (addr + off, addr + off, 1, section_flagname, sname, sname, true);\n\t\t\t\tr_list_append (ret, f);\n\t\t\t\toff += is64? 80: 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree (mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_ARM64E) {\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "#include <r_bin.h>\n#include <r_types.h>\n#include \"mach0_specs.h\"\n\n#ifndef _INCLUDE_R_BIN_MACH0_H_\n#define _INCLUDE_R_BIN_MACH0_H_\n\n// 20% faster loading times for macho if enabled\n#define FEATURE_SYMLIST 0\n\n#define R_BIN_MACH0_STRING_LENGTH 256\n\n\n#define CSMAGIC_CODEDIRECTORY      0xfade0c02\n#define CSMAGIC_EMBEDDED_SIGNATURE 0xfade0cc0\n#define CSMAGIC_DETACHED_SIGNATURE 0xfade0cc1 /* multi-arch collection of embedded signatures */\n#define CSMAGIC_ENTITLEMENTS       0xfade7171\n#define CSMAGIC_REQUIREMENT        0xfade0c00 /* single Requirement blob */\n#define CSMAGIC_REQUIREMENTS       0xfade0c01 /* Requirements vector (internal requirements) */\n\n#define CS_PAGE_SIZE 4096\n\n#define CS_HASHTYPE_SHA1 1\n#define CS_HASHTYPE_SHA256 2\n#define CS_HASHTYPE_SHA256_TRUNCATED 3\n\n#define CS_HASH_SIZE_SHA1 20\n#define CS_HASH_SIZE_SHA256 32\n#define CS_HASH_SIZE_SHA256_TRUNCATED 20\n\n#define CSSLOT_CODEDIRECTORY 0\n#define CSSLOT_INFOSLOT 1\n#define CSSLOT_REQUIREMENTS  2\n#define CSSLOT_RESOURCEDIR 3\n#define CSSLOT_APPLICATION 4\n#define CSSLOT_ENTITLEMENTS  5\n#define CSSLOT_CMS_SIGNATURE 0x10000\n\ntypedef enum {\n\tR_FIXUP_EVENT_NONE = 0,\n\tR_FIXUP_EVENT_REBASE = 1,\n\tR_FIXUP_EVENT_REBASE_AUTH = 2,\n\tR_FIXUP_EVENT_BIND = 4,\n\tR_FIXUP_EVENT_BIND_AUTH = 8,\n} RFixupEvent;\n\n#define R_FIXUP_EVENT_MASK_BIND_ALL (R_FIXUP_EVENT_BIND | R_FIXUP_EVENT_BIND_AUTH)\n#define R_FIXUP_EVENT_MASK_REBASE_ALL (R_FIXUP_EVENT_REBASE | R_FIXUP_EVENT_REBASE_AUTH)\n#define R_FIXUP_EVENT_MASK_ALL (R_FIXUP_EVENT_MASK_BIND_ALL | R_FIXUP_EVENT_MASK_REBASE_ALL)\n\nstruct section_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 size;\n\tut64 vsize;\n\tut32 align;\n\tut32 flags;\n\tint perm;\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint last;\n};\n\nstruct symbol_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 size;\n\tint bits;\n\tint type;\n\tbool is_imported;\n\tchar *name;\n\tbool last;\n};\n\nstruct import_t {\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint ord;\n\tint last;\n};\n\nstruct reloc_t {\n\tut64 offset;\n\tut64 addr;\n\tst64 addend;\n\tut8 type;\n\tint ord;\n\tint last;\n\tchar name[256];\n\tbool external;\n\tbool pc_relative;\n\tut8 size;\n};\n\nstruct addr_t {\n\tut64 offset;\n\tut64 addr;\n\tut64 haddr;\n\tint last;\n};\n\nstruct lib_t {\n\tchar name[R_BIN_MACH0_STRING_LENGTH];\n\tint last;\n};\n\nstruct blob_index_t {\n\tut32 type;\n\tut32 offset;\n};\n\nstruct blob_t {\n\tut32 magic;\n\tut32 length;\n};\n\nstruct super_blob_t {\n\tstruct blob_t blob;\n\tut32 count;\n\tstruct blob_index_t index[];\n};\n\nstruct MACH0_(opts_t) {\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n};\n\nstruct MACH0_(obj_t) {\n\tstruct MACH0_(mach_header) hdr;\n\tstruct MACH0_(segment_command) *segs;\n\tchar *intrp;\n\tchar *compiler;\n\tint nsegs;\n\tint segs_count;\n\tstruct r_dyld_chained_starts_in_segment **chained_starts;\n\tstruct dyld_chained_fixups_header fixups_header;\n\tut64 fixups_offset;\n\tut64 fixups_size;\n\tstruct MACH0_(section) *sects;\n\tint nsects;\n\tstruct MACH0_(nlist) *symtab;\n\tut8 *symstr;\n\tut8 *func_start; //buffer that hold the data from LC_FUNCTION_STARTS\n\tint symstrlen;\n\tint nsymtab;\n\tut32 *indirectsyms;\n\tint nindirectsyms;\n\n\tRBinImport **imports_by_ord;\n\tsize_t imports_by_ord_size;\n\tHtPP *imports_by_name;\n\n\tstruct dysymtab_command dysymtab;\n\tstruct load_command main_cmd;\n\tstruct dyld_info_command *dyld_info;\n\tstruct dylib_table_of_contents *toc;\n\tint ntoc;\n\tstruct MACH0_(dylib_module) *modtab;\n\tint nmodtab;\n\tstruct thread_command thread;\n\tut8 *signature;\n\tunion {\n\t\tstruct x86_thread_state32 x86_32;\n\t\tstruct x86_thread_state64 x86_64;\n\t\tstruct ppc_thread_state32 ppc_32;\n\t\tstruct ppc_thread_state64 ppc_64;\n\t\tstruct arm_thread_state32 arm_32;\n\t\tstruct arm_thread_state64 arm_64;\n\t} thread_state;\n\tchar (*libs)[R_BIN_MACH0_STRING_LENGTH];\n\tint nlibs;\n\tint size;\n\tut64 baddr;\n\tut64 entry;\n\tbool big_endian;\n\tconst char *file;\n\tRBuffer *b;\n\tint os;\n\tSdb *kv;\n\tint has_crypto;\n\tint has_canary;\n\tint has_retguard;\n\tint has_sanitizers;\n\tint has_blocks_ext;\n\tint dbg_info;\n\tconst char *lang;\n\tint uuidn;\n\tint func_size;\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n\tvoid *user;\n\tut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);\n\tstruct symbol_t *symbols;\n\tut64 main_addr;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebasing_buffer;\n};\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n} RFixupEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ordinal;\n\tut64 addend;\n} RFixupBindEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut32 ordinal;\n\tut8 key;\n\tut8 addr_div;\n\tut16 diversity;\n} RFixupBindAuthEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ptr_value;\n} RFixupRebaseEventDetails;\n\ntypedef struct {\n\tRFixupEvent type;\n\tstruct MACH0_(obj_t) *bin;\n\tut64 offset;\n\tut64 raw_ptr;\n\tut64 ptr_value;\n\tut8 key;\n\tut8 addr_div;\n\tut16 diversity;\n} RFixupRebaseAuthEventDetails;\n\ntypedef bool (*RFixupCallback)(void * context, RFixupEventDetails * event_details);\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf);\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options);\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options);\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *bin);\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin);\n//RList *MACH0_(get_segments)(struct MACH0_(obj_t) *bin);\nRList *MACH0_(get_segments)(RBinFile *bf); // struct MACH0_(obj_t) *bin);\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin);\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin);\nvoid MACH0_(pull_symbols)(struct MACH0_(obj_t) *mo, RBinSymbolCallback cb, void *user);\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin);\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin);\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin);\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin);\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin);\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin);\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin);\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin);\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr);\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin);\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr);\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin);\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr);\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr);\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf);\nvoid MACH0_(mach_headerfields)(RBinFile *bf);\nRList *MACH0_(mach_fields)(RBinFile *bf);\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *obj, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void *context);\n#endif\n", "/* radare - LGPL - Copyright 2009-2021 - pancake */\n\n#include <r_core.h>\n#include \"ht_pp.h\"\n\n/*!\n * Number of sub-commands to show as options when displaying the help of a\n * command. When a command has more options than MAX_CHILDREN_SHOW, `?` is shown\n * instead.\n *\n * Example with MAX_CHILDREN_SHOW=3:\n * w -> wa\n *   -> wb\n *   -> wc\n *\n * When doing `?`, you would see:\n * w[abc]\n *\n * If there is also:\n *   -> wd\n * you would see:\n * w[?]\n */\n#define MAX_CHILDREN_SHOW 7\n\nstatic const RCmdDescHelp not_defined_help = {\n\t.usage = \"Usage not defined\",\n\t.summary = \"Help summary not defined\",\n\t.description = \"Help description not defined.\",\n};\n\nstatic const RCmdDescHelp root_help = {\n\t.usage = \"[.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...\",\n\t.description = \"\",\n};\n\nstatic int value = 0;\n\n#define NCMDS (sizeof (cmd->cmds)/sizeof(*cmd->cmds))\nR_LIB_VERSION (r_cmd);\n\nstatic bool cmd_desc_set_parent(RCmdDesc *cd, RCmdDesc *parent) {\n\tr_return_val_if_fail (cd && !cd->parent, false);\n\tif (parent) {\n\t\tcd->parent = parent;\n\t\tr_pvector_push (&parent->children, cd);\n\t\tparent->n_children++;\n\t}\n\treturn true;\n}\n\nstatic void cmd_desc_unset_parent(RCmdDesc *cd) {\n\tr_return_if_fail (cd && cd->parent);\n\tRCmdDesc *parent = cd->parent;\n\tr_pvector_remove_data (&parent->children, cd);\n\tparent->n_children--;\n\tcd->parent = NULL;\n}\n\nstatic bool cmd_desc_remove_from_ht_cmds(RCmd *cmd, RCmdDesc *cd) {\n\tvoid **it_cd;\n\tbool res = ht_pp_delete (cmd->ht_cmds, cd->name);\n\tr_return_val_if_fail (res, false);\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child_cd = *it_cd;\n\t\tcmd_desc_remove_from_ht_cmds (cmd, child_cd);\n\t}\n\treturn res;\n}\n\nstatic void cmd_desc_free(RCmdDesc *cd) {\n\tif (!cd) {\n\t\treturn;\n\t}\n\n\tr_pvector_clear (&cd->children);\n\tfree (cd->name);\n\tfree (cd);\n}\n\nstatic RCmdDesc *create_cmd_desc(RCmd *cmd, RCmdDesc *parent, RCmdDescType type, const char *name, const RCmdDescHelp *help, bool ht_insert) {\n\tRCmdDesc *res = R_NEW0 (RCmdDesc);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->type = type;\n\tres->name = strdup (name);\n\tif (!res->name) {\n\t\tgoto err;\n\t}\n\tres->n_children = 0;\n\tres->help = help? help: &not_defined_help;\n\tr_pvector_init (&res->children, (RPVectorFree)cmd_desc_free);\n\tif (ht_insert && !ht_pp_insert (cmd->ht_cmds, name, res)) {\n\t\tgoto err;\n\t}\n\tcmd_desc_set_parent (res, parent);\n\treturn res;\nerr:\n\tcmd_desc_free (res);\n\treturn NULL;\n}\n\nstatic void alias_freefn(HtPPKv *kv) {\n\tchar *k = kv->key;\n\tRCmdAliasVal *v = kv->value;\n\n\tfree (v->data);\n\tfree (k);\n\tfree (v);\n}\n\nstatic void *alias_dupkey(const void *k) {\n\treturn strdup ((const char *)k);\n}\n\nstatic void *alias_dupvalue(const void *v_void) {\n\tRCmdAliasVal *v = (RCmdAliasVal *)v_void;\n\tRCmdAliasVal *vcopy = R_NEW (RCmdAliasVal);\n\tif (!vcopy) {\n\t\treturn NULL;\n\t}\n\tut8 *data = malloc (v->sz);\n\tif (!data) {\n\t\tfree (vcopy);\n\t\treturn NULL;\n\t}\n\tvcopy->is_data = v->is_data;\n\tvcopy->is_str = v->is_str;\n\tvcopy->sz = v->sz;\n\tvcopy->data = data;\n\tmemcpy (vcopy->data, v->data, v->sz);\n\n\treturn vcopy;\n}\n\nstatic ut32 alias_calcsizeK(const void *k) {\n\treturn strlen ((const char *)k);\n}\n\nstatic ut32 alias_calcsizeV(const void *v) {\n\treturn ((RCmdAliasVal *)v)->sz;\n}\n\nstatic int alias_cmp(const void *k1, const void *k2) {\n\treturn strcmp ((const char *)k1, (const char *)k2);\n}\n\nstatic ut32 alias_hashfn(const void *k_in) {\n\t/* djb2 algorithm by Dan Bernstein */\n\tut32 hash = 5381;\n\tut8 c;\n\tconst char *k = k_in;\n\n\twhile (*k) {\n\t\tc = *k++;\n\t\t/* hash * 33 + c */\n\t\thash += (hash << 5) + c;\n\t}\n\n\treturn hash;\n}\n\nR_API void r_cmd_alias_init(RCmd *cmd) {\n\tHtPPOptions opt = {0};\n\topt.cmp = alias_cmp;\n\topt.hashfn = alias_hashfn;\n\topt.dupkey = alias_dupkey;\n\topt.dupvalue = alias_dupvalue;\n\topt.calcsizeK = alias_calcsizeK;\n\topt.calcsizeV = alias_calcsizeV;\n\topt.freefn = alias_freefn;\n\n\tcmd->aliases = ht_pp_new_opt (&opt);\n}\n\nR_API RCmd *r_cmd_new(void) {\n\tint i;\n\tRCmd *cmd = R_NEW0 (RCmd);\n\tif (!cmd) {\n\t\treturn cmd;\n\t}\n\tcmd->lcmds = r_list_new ();\n\tfor (i = 0; i < NCMDS; i++) {\n\t\tcmd->cmds[i] = NULL;\n\t}\n\tcmd->nullcallback = cmd->data = NULL;\n\tcmd->ht_cmds = ht_pp_new0 ();\n\tcmd->root_cmd_desc = create_cmd_desc (cmd, NULL, R_CMD_DESC_TYPE_ARGV, \"\", &root_help, true);\n\tr_core_plugin_init (cmd);\n\tr_cmd_macro_init (&cmd->macro);\n\tr_cmd_alias_init (cmd);\n\treturn cmd;\n}\n\nR_API RCmd *r_cmd_free(RCmd *cmd) {\n\tint i;\n\tif (!cmd) {\n\t\treturn NULL;\n\t}\n\tht_up_free (cmd->ts_symbols_ht);\n\tr_cmd_alias_free (cmd);\n\tr_cmd_macro_fini (&cmd->macro);\n\tht_pp_free (cmd->ht_cmds);\n\t// dinitialize plugin commands\n\tr_core_plugin_fini (cmd);\n\tr_list_free (cmd->plist);\n\tr_list_free (cmd->lcmds);\n\tfor (i = 0; i < NCMDS; i++) {\n\t\tif (cmd->cmds[i]) {\n\t\t\tR_FREE (cmd->cmds[i]);\n\t\t}\n\t}\n\tcmd_desc_free (cmd->root_cmd_desc);\n\tfree (cmd);\n\treturn NULL;\n}\n\nR_API RCmdDesc *r_cmd_get_root(RCmd *cmd) {\n\treturn cmd->root_cmd_desc;\n}\n\nR_API RCmdDesc *r_cmd_get_desc(RCmd *cmd, const char *cmd_identifier) {\n\tr_return_val_if_fail (cmd && cmd_identifier, NULL);\n\tchar *cmdid = strdup (cmd_identifier);\n\tchar *end_cmdid = cmdid + strlen (cmdid);\n\tRCmdDesc *res = NULL;\n\tbool is_exact_match = true;\n\t// match longer commands first\n\twhile (*cmdid) {\n\t\tRCmdDesc *cd = ht_pp_find (cmd->ht_cmds, cmdid, NULL);\n\t\tif (cd) {\n\t\t\tswitch (cd->type) {\n\t\t\tcase R_CMD_DESC_TYPE_ARGV:\n\t\t\t\tif (!is_exact_match) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\tcase R_CMD_DESC_TYPE_GROUP:\n\t\t\t\t// fallthrough\n\t\t\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\t\t\tres = cd;\n\t\t\t\tgoto out;\n\t\t\tcase R_CMD_DESC_TYPE_INNER:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tis_exact_match = false;\n\t\t*(--end_cmdid) = '\\0';\n\t}\nout:\n\tfree (cmdid);\n\treturn res;\n}\n\nstatic bool get_keys(void *keylist_in, const void *k, const void *v) {\n\tRList *keylist = (RList *) keylist_in;\n\treturn r_list_append (keylist, (char *) k);\n}\n\nR_API RList *r_cmd_alias_keys(RCmd *cmd) {\n\tRList *keylist = r_list_new ();\n\tif (!keylist) {\n\t\treturn NULL;\n\t}\n\n\tht_pp_foreach (cmd->aliases, get_keys, keylist);\n\n\treturn keylist;\n}\n\nR_API void r_cmd_alias_free(RCmd *cmd) {\n\tht_pp_free (cmd->aliases);\n\tcmd->aliases = NULL;\n}\n\nR_API bool r_cmd_alias_del(RCmd *cmd, const char *k) {\n\treturn ht_pp_delete(cmd->aliases, k);\n}\n\nR_API int r_cmd_alias_set_cmd(RCmd *cmd, const char *k, const char *v) {\n\tRCmdAliasVal val;\n\tval.data = (ut8 *)v;\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\tval.sz = strlen (v) + 1;\n\tval.is_str = true;\n\tval.is_data = false;\n\n\treturn ht_pp_update (cmd->aliases, k, &val);\n}\n\nR_API int r_cmd_alias_set_str(RCmd *cmd, const char *k, const char *v) {\n\tRCmdAliasVal val;\n\tval.data = (ut8 *)strdup (v);\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\tval.is_str = true;\n\tval.is_data = true;\n\n\t/* No trailing newline */\n\tint len = strlen (v);\n\twhile (len-- > 0) {\n\t\tif (v[len] == '\\r' || v[len] == '\\n') {\n\t\t\tval.data[len] = '\\0';\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// len is strlen()-1 now\n\tval.sz = len + 2;\n\n\tint ret = ht_pp_update (cmd->aliases, k, &val);\n\tfree (val.data);\n\treturn ret;\n}\n\nR_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {\n\tint i;\n\n\tif (sz < 1) {\n\t\treturn 1;\n\t}\n\n\tRCmdAliasVal val;\n\tval.data = malloc (sz);\n\tif (!val.data) {\n\t\treturn 1;\n\t}\n\n\tmemcpy (val.data, v, sz);\n\tval.sz = sz;\n\n\t/* If it's a string already, we speed things up later by checking now */\n\tconst ut8 *firstnull = NULL;\n\tbool is_binary = false;\n\tfor (i = 0; i < sz; i++) {\n\t\t/* \\0 before expected -> not string */\n\t\tif (v[i] == '\\0') {\n\t\t\tfirstnull = &v[i];\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Non-ascii character -> not string */\n\t\tif (!IS_PRINTABLE(v[i]) && !IS_WHITECHAR(v[i])) {\n\t\t\tis_binary = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (firstnull == &v[sz-1] && !is_binary) {\n\t\t/* Data is already a string */\n\t\tval.is_str = true;\n\t} else if (!firstnull && !is_binary) {\n\t\t/* Data is an unterminated string */\n\t\tval.sz++;\n\t\tut8 *data = realloc (val.data, val.sz);\n\t\tif (!data) {\n\t\t\treturn 1;\n\t\t}\n\t\tval.data = data;\n\t\tval.data[val.sz - 1] = '\\0';\n\t\tval.is_str = true;\n\t} else {\n\t\t/* Data has nulls or non-ascii, not a string */\n\t\tval.is_str = false;\n\t}\n\n\tval.is_data = true;\n\n\tif (val.is_str) {\n\t\t/* No trailing newline */\n\t\tint len = val.sz - 1;\n\t\twhile (len-- > 0) {\n\t\t\tif (v[len] == '\\r' || v[len] == '\\n') {\n\t\t\t\tval.data[len] = '\\0';\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// len is strlen()-1 now\n\t\tval.sz = len + 2;\n\t}\n\n\tint ret = ht_pp_update (cmd->aliases, k, &val);\n\tfree (val.data);\n\treturn ret;\n}\n\nR_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find (cmd->aliases, k, NULL);\n}\n\nstatic ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {\n\tut8* out;\n\tint out_sz;\n\n\t/* If appending to a string, always overwrite the trailing \\0 */\n\tint bytes_from_first = first->is_str\n\t\t? first->sz - 1\n\t\t: first->sz;\n\n\tout_sz = bytes_from_first + second_sz;\n\tout = malloc (out_sz);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\n\t/* Copy full buffer if raw bytes. Stop before \\0 if string. */\n\tmemcpy (out, first->data, bytes_from_first);\n\t/* Always copy all bytes from second, including trailing \\0 */\n\tmemcpy (out+bytes_from_first, second, second_sz);\n\n\tif (out_sz) {\n\t\t*out_szp = out_sz;\n\t}\n\treturn out;\n}\n\nR_API int r_cmd_alias_append_str(RCmd *cmd, const char *k, const char *a) {\n\tRCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);\n\tif (v_old) {\n\t\tif (!v_old->is_data) {\n\t\t\treturn 1;\n\t\t}\n\t\tint new_len = 0;\n\t\tut8* new = alias_append_internal (&new_len, v_old, (ut8 *)a, strlen (a) + 1);\n\t\tif (!new) {\n\t\t\treturn 1;\n\t\t}\n\t\tr_cmd_alias_set_raw (cmd, k, new, new_len);\n\t\tfree (new);\n\t} else {\n\t\tr_cmd_alias_set_str (cmd, k, a);\n\t}\n\treturn 0;\n}\n\nR_API int r_cmd_alias_append_raw(RCmd *cmd, const char *k, const ut8 *a, int sz) {\n\tRCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);\n\tif (v_old) {\n\t\tif (!v_old->is_data) {\n\t\t\treturn 1;\n\t\t}\n\t\tint new_len = 0;\n\t\tut8 *new = alias_append_internal (&new_len, v_old, a, sz);\n\t\tif (!new) {\n\t\t\treturn 1;\n\t\t}\n\t\tr_cmd_alias_set_raw (cmd, k, new, new_len);\n\t\tfree (new);\n\t} else {\n\t\tr_cmd_alias_set_raw (cmd, k, a, sz);\n\t}\n\treturn 0;\n}\n\n/* Returns a new copy of v->data. If !v->is_str, hex escaped */\nR_API char *r_cmd_alias_val_strdup(RCmdAliasVal *v) {\n\tif (v->is_str) {\n\t\treturn strdup ((char *)v->data);\n\t}\n\treturn r_str_escape_raw (v->data, v->sz);\n}\n\n/* Returns a new copy of v->data. If !v->is_str, b64 encoded. */\nR_API char *r_cmd_alias_val_strdup_b64(RCmdAliasVal *v) {\n\tif (v->is_str) {\n\t\treturn strdup ((char *)v->data);\n\t}\n\n\treturn r_base64_encode_dyn ((char *)v->data, v->sz);\n}\n\nR_API void r_cmd_set_data(RCmd *cmd, void *data) {\n\tcmd->data = data;\n}\n\nR_API bool r_cmd_add(RCmd *c, const char *cmd, RCmdCb cb) {\n\tint idx = (ut8)cmd[0];\n\tRCmdItem *item = c->cmds[idx];\n\tif (!item) {\n\t\titem = R_NEW0 (RCmdItem);\n\t\tc->cmds[idx] = item;\n\t}\n\tstrncpy (item->cmd, cmd, sizeof (item->cmd)-1);\n\titem->callback = cb;\n\treturn true;\n}\n\nR_API void r_cmd_del(RCmd *cmd, const char *command) {\n\tint idx = (ut8)command[0];\n\tR_FREE (cmd->cmds[idx]);\n}\n\nR_API int r_cmd_call(RCmd *cmd, const char *input) {\n\tstruct r_cmd_item_t *c;\n\tint ret = -1;\n\tRListIter *iter;\n\tRCorePlugin *cp;\n\tr_return_val_if_fail (cmd && input, -1);\n\tif (!*input) {\n\t\tif (cmd->nullcallback) {\n\t\t\tret = cmd->nullcallback (cmd->data);\n\t\t}\n\t} else {\n\t\tchar *nstr = NULL;\n\t\tRCmdAliasVal *v = r_cmd_alias_get (cmd, input);\n\t\tif (v && v->is_data) {\n\t\t\tchar *v_str = r_cmd_alias_val_strdup (v);\n\t\t\tr_cons_strcat (v_str);\n\t\t\tfree (v_str);\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (cmd->plist, iter, cp) {\n\t\t\tif (cp->call && cp->call (cmd->data, input)) {\n\t\t\t\tfree (nstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (!*input) {\n\t\t\tfree (nstr);\n\t\t\treturn -1;\n\t\t}\n\t\tc = cmd->cmds[((ut8)input[0]) & 0xff];\n\t\tif (c && c->callback) {\n\t\t\tconst char *inp = (*input)? input + 1: \"\";\n\t\t\tret = c->callback (cmd->data, inp);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tfree (nstr);\n\t}\n\treturn ret;\n}\n\nstatic RCmdStatus int2cmdstatus(int v) {\n\tif (v == -2) {\n\t\treturn R_CMD_STATUS_EXIT;\n\t} else if (v < 0) {\n\t\treturn R_CMD_STATUS_ERROR;\n\t} else {\n\t\treturn R_CMD_STATUS_OK;\n\t}\n}\n\nR_API RCmdStatus r_cmd_call_parsed_args(RCmd *cmd, RCmdParsedArgs *args) {\n\tRCmdStatus res = R_CMD_STATUS_INVALID;\n\n\t// As old RCorePlugin do not register new commands in RCmd, we have no\n\t// way of knowing if one of those is able to handle the input, so we\n\t// have to pass the input to all of them before looking into the\n\t// RCmdDesc tree\n\tRListIter *iter;\n\tRCorePlugin *cp;\n\tchar *exec_string = r_cmd_parsed_args_execstr (args);\n\tr_list_foreach (cmd->plist, iter, cp) {\n\t\tif (cp->call && cp->call (cmd->data, exec_string)) {\n\t\t\tres = R_CMD_STATUS_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tR_FREE (exec_string);\n\tif (res == R_CMD_STATUS_OK) {\n\t\treturn res;\n\t}\n\n\tRCmdDesc *cd = r_cmd_get_desc (cmd, r_cmd_parsed_args_cmd (args));\n\tif (!cd) {\n\t\treturn R_CMD_STATUS_INVALID;\n\t}\n\n\tres = R_CMD_STATUS_INVALID;\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\tif (!cd->d.group_data.exec_cd) {\n\t\t\tbreak;\n\t\t}\n\t\tcd = cd->d.group_data.exec_cd;\n\t\t// fallthrough\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\tif (cd->d.argv_data.cb) {\n\t\t\tres = cd->d.argv_data.cb (cmd->data, args->argc, (const char **)args->argv);\n\t\t}\n\t\tbreak;\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\texec_string = r_cmd_parsed_args_execstr (args);\n\t\tres = int2cmdstatus (cd->d.oldinput_data.cb (cmd->data, exec_string + strlen (cd->name)));\n\t\tR_FREE (exec_string);\n\t\tbreak;\n\tdefault:\n\t\tres = R_CMD_STATUS_INVALID;\n\t\tR_LOG_ERROR (\"RCmdDesc type not handled\\n\");\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nstatic void fill_children_chars(RStrBuf *sb, RCmdDesc *cd) {\n\tif (cd->help->options) {\n\t\tr_strbuf_append (sb, cd->help->options);\n\t\treturn;\n\t}\n\n\tRStrBuf csb;\n\tr_strbuf_init (&csb);\n\n\tvoid **it;\n\tr_cmd_desc_children_foreach (cd, it) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it;\n\t\tif (r_str_startswith (child->name, cd->name) && strlen (child->name) == strlen (cd->name) + 1) {\n\t\t\tr_strbuf_appendf (&csb, \"%c\", child->name[strlen (cd->name)]);\n\t\t}\n\t}\n\n\tif (r_strbuf_is_empty (&csb) || r_strbuf_length (&csb) >= MAX_CHILDREN_SHOW) {\n\t\tr_strbuf_fini (&csb);\n\t\tr_strbuf_set (&csb, \"?\");\n\t}\n\n\tif (!cd->n_children || r_cmd_desc_has_handler (cd)) {\n\t\tr_strbuf_prepend (&csb, \"[\");\n\t\tr_strbuf_append (&csb, \"]\");\n\t} else {\n\t\tr_strbuf_prepend (&csb, \"<\");\n\t\tr_strbuf_append (&csb, \">\");\n\t}\n\tchar *tmp = r_strbuf_drain_nofree (&csb);\n\tr_strbuf_append (sb, tmp);\n\tfree (tmp);\n}\n\nstatic bool show_children_shortcut(RCmdDesc *cd) {\n\treturn cd->n_children || cd->help->options || cd->type == R_CMD_DESC_TYPE_OLDINPUT;\n}\n\nstatic void fill_usage_strbuf(RStrBuf *sb, RCmdDesc *cd, bool use_color) {\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_label_color = use_color? cons->context->pal.label: \"\",\n\t\t   *pal_args_color = use_color? cons->context->pal.args: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tr_strbuf_appendf (sb, \"%sUsage: %s\", pal_label_color, pal_reset);\n\tif (cd->help->usage) {\n\t\tr_strbuf_appendf (sb, \"%s%s%s\", cd->help->usage, pal_args_color, pal_reset);\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s%s\", pal_input_color, cd->name);\n\t\tif (show_children_shortcut (cd)) {\n\t\t\tr_strbuf_append (sb, pal_reset);\n\t\t\tfill_children_chars (sb, cd);\n\t\t}\n\t\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\t\tr_strbuf_appendf (sb, \"%s%s%s\", pal_args_color, cd->help->args_str, pal_reset);\n\t\t}\n\t}\n\tif (cd->help->summary) {\n\t\tr_strbuf_appendf (sb, \"   %s# %s%s\", pal_help_color, cd->help->summary, pal_reset);\n\t}\n\tr_strbuf_append (sb, \"\\n\");\n}\n\nstatic size_t calc_padding_len(RCmdDesc *cd) {\n\tsize_t name_len = strlen (cd->name);\n\tsize_t args_len = 0;\n\tsize_t children_length = 0;\n\tif (show_children_shortcut (cd)) {\n\t\tRStrBuf sb;\n\t\tr_strbuf_init (&sb);\n\t\tfill_children_chars (&sb, cd);\n\t\tchildren_length += r_strbuf_length (&sb);\n\t\tr_strbuf_fini (&sb);\n\t}\n\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\targs_len = strlen (cd->help->args_str);\n\t}\n\treturn name_len + args_len + children_length;\n}\n\nstatic size_t update_max_len(RCmdDesc *cd, size_t max_len) {\n\tsize_t val = calc_padding_len (cd);\n\treturn val > max_len? val: max_len;\n}\n\nstatic void print_child_help(RStrBuf *sb, RCmdDesc *cd, size_t max_len, bool use_color) {\n\tsize_t str_len = calc_padding_len (cd);\n\tint padding = str_len < max_len? max_len - str_len: 0;\n\tconst char *cd_summary = r_str_get (cd->help->summary);\n\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_args_color = use_color? cons->context->pal.args: \"\",\n\t\t   *pal_opt_color = use_color? cons->context->pal.reset: \"\",\n\t\t   *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tr_strbuf_appendf (sb, \"| %s%s\", pal_input_color, cd->name);\n\tif (show_children_shortcut (cd)) {\n\t\tr_strbuf_append (sb, pal_opt_color);\n\t\tfill_children_chars (sb, cd);\n\t}\n\tif (R_STR_ISNOTEMPTY (cd->help->args_str)) {\n\t\tr_strbuf_appendf (sb, \"%s%s\", pal_args_color, cd->help->args_str);\n\t}\n\tr_strbuf_appendf (sb, \" %*s%s# %s%s\\n\", padding, \"\", pal_help_color, cd_summary, pal_reset);\n}\n\nstatic char *argv_group_get_help(RCmd *cmd, RCmdDesc *cd, bool use_color) {\n\tRStrBuf *sb = r_strbuf_new (NULL);\n\tfill_usage_strbuf (sb, cd, use_color);\n\n\tvoid **it_cd;\n\tsize_t max_len = 0;\n\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it_cd;\n\t\tmax_len = update_max_len (child, max_len);\n\t}\n\n\tr_cmd_desc_children_foreach (cd, it_cd) {\n\t\tRCmdDesc *child = *(RCmdDesc **)it_cd;\n\t\tprint_child_help (sb, child, max_len, use_color);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nstatic char *argv_get_help(RCmd *cmd, RCmdDesc *cd, RCmdParsedArgs *a, size_t detail, bool use_color) {\n\tRCons *cons = r_cons_singleton ();\n\tconst char *pal_help_color = use_color? cons->context->pal.help: \"\",\n\t\t   *pal_input_color = use_color? cons->context->pal.input: \"\",\n\t\t   *pal_label_color = use_color? cons->context->pal.label: \"\",\n\t\t   *pal_reset = use_color? cons->context->pal.reset: \"\";\n\n\tRStrBuf *sb = r_strbuf_new (NULL);\n\n\tfill_usage_strbuf (sb, cd, use_color);\n\n\tswitch (detail) {\n\tcase 1:\n\t\treturn r_strbuf_drain (sb);\n\tcase 2:\n\t\tif (cd->help->description) {\n\t\t\tr_strbuf_appendf (sb, \"\\n%s\\n\", cd->help->description);\n\t\t}\n\t\tif (cd->help->examples) {\n\t\t\tr_strbuf_appendf (sb, \"\\n%sExamples:%s\\n\", pal_label_color, pal_reset);\n\t\t\tconst RCmdDescExample *it = cd->help->examples;\n\t\t\twhile (it->example) {\n\t\t\t\tr_strbuf_appendf (sb, \"| %s%s%s %s# %s%s\\n\", pal_input_color,\n\t\t\t\t\tit->example, pal_reset, pal_help_color, it->comment, pal_reset);\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\treturn r_strbuf_drain (sb);\n\tdefault:\n\t\tr_strbuf_free (sb);\n\t\treturn NULL;\n\t}\n}\n\nstatic char *oldinput_get_help(RCmd *cmd, RCmdDesc *cd, RCmdParsedArgs *a) {\n\tconst char *s = NULL;\n\tr_cons_push ();\n\tRCmdStatus status = r_cmd_call_parsed_args (cmd, a);\n\tif (status == R_CMD_STATUS_OK) {\n\t\tr_cons_filter ();\n\t\ts = r_cons_get_buffer ();\n\t}\n\tchar *res = strdup (r_str_get (s));\n\tr_cons_pop ();\n\treturn res;\n}\n\nR_API char *r_cmd_get_help(RCmd *cmd, RCmdParsedArgs *args, bool use_color) {\n\tchar *cmdid = strdup (r_cmd_parsed_args_cmd (args));\n\tchar *cmdid_p = cmdid + strlen (cmdid) - 1;\n\tsize_t detail = 0;\n\twhile (cmdid_p >= cmdid && *cmdid_p == '?') {\n\t\t*cmdid_p = '\\0';\n\t\tcmdid_p--;\n\t\tdetail++;\n\t}\n\n\tif (detail == 0) {\n\t\t// there should be at least one `?`\n\t\tfree (cmdid);\n\t\treturn NULL;\n\t}\n\n\tRCmdDesc *cd = cmdid_p >= cmdid? r_cmd_get_desc (cmd, cmdid): r_cmd_get_root (cmd);\n\tfree (cmdid);\n\tif (!cd || !cd->help) {\n\t\treturn NULL;\n\t}\n\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\tif (detail > 1 && cd->d.group_data.exec_cd) {\n\t\t\tcd = cd->d.group_data.exec_cd;\n\t\t}\n\t\t// fallthrough\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\tif (detail == 1 && !r_pvector_empty (&cd->children)) {\n\t\t\tif (args->argc > 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn argv_group_get_help (cmd, cd, use_color);\n\t\t}\n\t\treturn argv_get_help (cmd, cd, args, detail, use_color);\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\treturn oldinput_get_help (cmd, cd, args);\n\tcase R_CMD_DESC_TYPE_INNER:\n\t\tr_warn_if_reached ();\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n/** macro.c **/\n\nR_API RCmdMacroItem *r_cmd_macro_item_new(void) {\n\treturn R_NEW0 (RCmdMacroItem);\n}\n\nR_API void r_cmd_macro_item_free(RCmdMacroItem *item) {\n\tif (item) {\n\t\tfree (item->name);\n\t\tfree (item->args);\n\t\tfree (item->code);\n\t\tfree (item);\n\t}\n}\n\nR_API void r_cmd_macro_init(RCmdMacro *mac) {\n\tmac->counter = 0;\n\tmac->_brk_value = 0;\n\tmac->brk_value = &mac->_brk_value;\n\tmac->cb_printf = (void *)printf;\n\tmac->num = NULL;\n\tmac->user = NULL;\n\tmac->cmd = NULL;\n\tmac->macros = r_list_newf ((RListFree)r_cmd_macro_item_free);\n}\n\nR_API void r_cmd_macro_fini(RCmdMacro *mac) {\n\tr_list_free (mac->macros);\n\tmac->macros = NULL;\n}\n\n// XXX add support single line function definitions\n// XXX add support for single name multiple nargs macros\nR_API bool r_cmd_macro_add(RCmdMacro *mac, const char *oname) {\n\tstruct r_cmd_macro_item_t *macro;\n\tchar *name, *args = NULL;\n\t//char buf[R_CMD_MAXLEN];\n\tRCmdMacroItem *m;\n\tbool macro_update = false;\n\tRListIter *iter;\n\tchar *pbody;\n\t// char *bufp;\n\tchar *ptr;\n\tint lidx;\n\n\tif (!*oname) {\n\t\tr_cmd_macro_list (mac);\n\t\treturn false;\n\t}\n\n\tname = strdup (oname);\n\tif (!name) {\n\t\treturn false;\n\t}\n\n\tpbody = strchr (name, ';');\n\tif (!pbody) {\n\t\teprintf (\"Invalid macro body\\n\");\n\t\tfree (name);\n\t\treturn false;\n\t}\n\t*pbody = '\\0';\n\tpbody++;\n\n\tif (*name && name[1] && name[strlen (name)-1]==')') {\n\t\teprintf (\"r_cmd_macro_add: missing macro body?\\n\");\n\t\tfree (name);\n\t\treturn false;\n\t}\n\n\tmacro = NULL;\n\tptr = strchr (name, ' ');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\targs = ptr +1;\n\t}\n\tmacro_update = false;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (name, m->name)) {\n\t\t\tmacro = m;\n\t\t\t// keep macro->name\n\t\t\tfree (macro->code);\n\t\t\tfree (macro->args);\n\t\t\tmacro_update = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ptr) {\n\t\t*ptr = ' ';\n\t}\n\tif (!macro) {\n\t\tmacro = r_cmd_macro_item_new ();\n\t\tif (!macro) {\n\t\t\tfree (name);\n\t\t\treturn false;\n\t\t}\n\t\tmacro->name = strdup (name);\n\t}\n\n\tmacro->codelen = (pbody[0])? strlen (pbody)+2 : 4096;\n\tmacro->code = (char *)malloc (macro->codelen);\n\t*macro->code = '\\0';\n\tmacro->nargs = 0;\n\tif (!args) {\n\t\targs = \"\";\n\t}\n\tmacro->args = strdup (args);\n\tptr = strchr (macro->name, ' ');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tmacro->nargs = r_str_word_set0 (ptr+1);\n\t}\n\n\tfor (lidx = 0; pbody[lidx]; lidx++) {\n\t\tif (pbody[lidx] == ';') {\n\t\t\tpbody[lidx] = '\\n';\n\t\t} else if (pbody[lidx] == ')' && pbody[lidx - 1] == '\\n') {\n\t\t\tpbody[lidx] = '\\0';\n\t\t}\n\t}\n\tstrncpy (macro->code, pbody, macro->codelen);\n\tmacro->code[macro->codelen-1] = 0;\n\tif (macro_update == false) {\n\t\tr_list_append (mac->macros, macro);\n\t}\n\tfree (name);\n\treturn true;\n}\n\nR_API bool r_cmd_macro_rm(RCmdMacro *mac, const char *_name) {\n\tr_return_val_if_fail (mac && _name, false);\n\tRListIter *iter;\n\tRCmdMacroItem *m;\n\tchar *name = strdup (_name);\n\tif (!name) {\n\t\treturn false;\n\t}\n\tchar *ptr = strchr (name, ')');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t}\n\tbool ret = false;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (m->name, name)) {\n\t\t\tr_list_delete (mac->macros, iter);\n\t\t\teprintf (\"Macro '%s' removed.\\n\", name);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (name);\n\treturn ret;\n}\n\n// TODO: use mac->cb_printf which is r_cons_printf at the end\nR_API void r_cmd_macro_list(RCmdMacro *mac) {\n\tRCmdMacroItem *m;\n\tint j, idx = 0;\n\tRListIter *iter;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tmac->cb_printf (\"%d (%s %s; \", idx, m->name, m->args);\n\t\tfor (j=0; m->code[j]; j++) {\n\t\t\tif (m->code[j] == '\\n') {\n\t\t\t\tmac->cb_printf (\"; \");\n\t\t\t} else {\n\t\t\t\tmac->cb_printf (\"%c\", m->code[j]);\n\t\t\t}\n\t\t}\n\t\tmac->cb_printf (\")\\n\");\n\t\tidx++;\n\t}\n}\n\n// TODO: use mac->cb_printf which is r_cons_printf at the end\nR_API void r_cmd_macro_meta(RCmdMacro *mac) {\n\tRCmdMacroItem *m;\n\tint j;\n\tRListIter *iter;\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tmac->cb_printf (\"(%s %s, \", m->name, m->args);\n\t\tfor (j=0; m->code[j]; j++) {\n\t\t\tif (m->code[j] == '\\n') {\n\t\t\t\tmac->cb_printf (\"; \");\n\t\t\t} else {\n\t\t\t\tmac->cb_printf (\"%c\", m->code[j]);\n\t\t\t}\n\t\t}\n\t\tmac->cb_printf (\")\\n\");\n\t}\n}\n\n#if 0\n(define name value\n  f $0 @ $1)\n\n(define loop cmd\n  loop:\n  ? $0 == 0\n  ?? .loop:\n  )\n\n.(define patata 3)\n#endif\n\nR_API int r_cmd_macro_cmd_args(RCmdMacro *mac, const char *ptr, const char *args, int nargs) {\n\tint i, j;\n\tchar *pcmd, cmd[R_CMD_MAXLEN];\n\tconst char *arg = args;\n\n\tfor (*cmd=i=j=0; j<R_CMD_MAXLEN && ptr[j]; i++,j++) {\n\t\tif (ptr[j]=='$') {\n\t\t\tif (ptr[j+1]>='0' && ptr[j+1]<='9') {\n\t\t\t\tint wordlen;\n\t\t\t\tint w = ptr[j+1]-'0';\n\t\t\t\tconst char *word = r_str_word_get0 (arg, w);\n\t\t\t\tif (word && *word) {\n\t\t\t\t\twordlen = strlen (word);\n\t\t\t\t\tif ((i + wordlen + 1) >= sizeof (cmd)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy (cmd+i, word, wordlen+1);\n\t\t\t\t\ti += wordlen-1;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Undefined argument %d\\n\", w);\n\t\t\t\t}\n\t\t\t} else if (ptr[j+1]=='@') {\n\t\t\t\tchar off[32];\n\t\t\t\tint offlen;\n\t\t\t\tofflen = snprintf (off, sizeof (off), \"%d\",\n\t\t\t\t\tmac->counter);\n\t\t\t\tif ((i + offlen + 1) >= sizeof (cmd)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemcpy (cmd+i, off, offlen+1);\n\t\t\t\ti += offlen-1;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tcmd[i] = ptr[j];\n\t\t\t\tcmd[i + 1] = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tcmd[i] = ptr[j];\n\t\t\tcmd[i + 1] = '\\0';\n\t\t}\n\t}\n\tfor (pcmd = cmd; *pcmd && (*pcmd == ' ' || *pcmd == '\\t'); pcmd++) {\n\t\t;\n\t}\n\t//eprintf (\"-pre %d\\n\", (int)mac->num->value);\n\tint xx = (*pcmd==')')? 0: mac->cmd (mac->user, pcmd);\n\t//eprintf (\"-pos %p %d\\n\", mac->num, (int)mac->num->value);\n\treturn xx;\n}\n\nR_API char *r_cmd_macro_label_process(RCmdMacro *mac, RCmdMacroLabel *labels, int *labels_n, char *ptr) {\n\tint i;\n\tfor (; *ptr == ' '; ptr++) {\n\t\t;\n\t}\n\tif (ptr[strlen (ptr) - 1]==':' && !strchr (ptr, ' ')) {\n\t\t/* label detected */\n\t\tif (ptr[0] == '.') {\n\t\t//\teprintf(\"---> GOTO '%s'\\n\", ptr+1);\n\t\t\t/* goto */\n\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t\t//\teprintf(\"---| chk '%s'\\n\", labels[i].name);\n\t\t\t\tif (!strcmp (ptr + 1, labels[i].name)) {\n\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NULL;\n\t\t} else\n\t\t/* conditional goto */\n\t\tif (ptr[0]=='?' && ptr[1]=='!' && ptr[2] != '?') {\n\t\t\tif (mac->num && mac->num->value != 0) {\n\t\t\t\tchar *label = ptr + 3;\n\t\t\t\tfor (; *label == ' ' || *label == '.'; label++) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\t// eprintf(\"===> GOTO %s\\n\", label);\n\t\t\t\t/* goto label ptr+3 */\n\t\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t\t\t\tif (!strcmp (label, labels[i].name)) {\n\t\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else\n\t\t/* conditional goto */\n\t\tif (ptr[0] == '?' && ptr[1] == '?' && ptr[2] != '?') {\n\t\t\tif (mac->num->value == 0) {\n\t\t\t\tchar *label = ptr + 3;\n\t\t\t\tfor (; label[0] == ' ' || label[0] == '.'; label++) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\t//\t\teprintf(\"===> GOTO %s\\n\", label);\n\t\t\t\t/* goto label ptr+3 */\n\t\t\t\tfor (i=0; i<*labels_n; i++) {\n\t\t\t\t\tif (!strcmp (label, labels[i].name)) {\n\t\t\t\t\t\treturn labels[i].ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < *labels_n; i++) {\n\t\t//\teprintf(\"---| chk '%s'\\n\", labels[i].name);\n\t\t\t\tif (!strcmp (ptr + 1, labels[i].name)) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Add label */\n\t\t//\teprintf(\"===> ADD LABEL(%s)\\n\", ptr);\n\t\t\tif (i == 0) {\n\t\t\t\tstrncpy (labels[*labels_n].name, ptr, 64);\n\t\t\t\tlabels[*labels_n].ptr = ptr+strlen (ptr)+1;\n\t\t\t\t*labels_n = *labels_n + 1;\n\t\t\t}\n\t\t}\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n/* TODO: add support for spaced arguments */\nR_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {\n\tchar *args;\n\tint nargs = 0;\n\tchar *str, *ptr, *ptr2;\n\tRListIter *iter;\n\tstatic int macro_level = 0;\n\tRCmdMacroItem *m;\n\t/* labels */\n\tint labels_n = 0;\n\tstruct r_cmd_macro_label_t labels[MACRO_LABELS];\n\n\tstr = strdup (name);\n\tif (!str) {\n\t\tr_sys_perror (\"strdup\");\n\t\treturn false;\n\t}\n\tptr = strchr (str, ')');\n\tif (!ptr) {\n\t\teprintf (\"Missing end ')' parenthesis.\\n\");\n\t\tfree (str);\n\t\treturn false;\n\t} else {\n\t\t*ptr = '\\0';\n\t}\n\n\targs = strchr (str, ' ');\n\tif (args) {\n\t\t*args = '\\0';\n\t\targs++;\n\t\tnargs = r_str_word_set0 (args);\n\t}\n\n\tmacro_level++;\n\tif (macro_level > MACRO_LIMIT) {\n\t\teprintf (\"Maximum macro recursivity reached.\\n\");\n\t\tmacro_level--;\n\t\tfree (str);\n\t\treturn 0;\n\t}\n\tptr = strchr (str, ';');\n\tif (ptr) {\n\t\t*ptr = 0;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\tr_list_foreach (mac->macros, iter, m) {\n\t\tif (!strcmp (str, m->name)) {\n\t\t\tchar *ptr = m->code;\n\t\t\tchar *end = strchr (ptr, '\\n');\n\t\t\tif (m->nargs != 0 && nargs != m->nargs) {\n\t\t\t\teprintf (\"Macro '%s' expects %d args, not %d\\n\", m->name, m->nargs, nargs);\n\t\t\t\tmacro_level --;\n\t\t\t\tfree (str);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmac->brk = 0;\n\t\t\tdo {\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\teprintf (\"Interrupted at (%s)\\n\", ptr);\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\t*end = '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tfree (str);\n\t\t\t\t\tr_cons_break_pop ();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_cons_flush ();\n\t\t\t\t/* Label handling */\n\t\t\t\tptr2 = r_cmd_macro_label_process (mac, &(labels[0]), &labels_n, ptr);\n\t\t\t\tif (!ptr2) {\n\t\t\t\t\teprintf (\"Oops. invalid label name\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ptr != ptr2) {\n\t\t\t\t\tptr = ptr2;\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\t*end = '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tend = strchr (ptr, '\\n');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Command execution */\n\t\t\t\tif (*ptr) {\n\t\t\t\t\tmac->num->value = value;\n\t\t\t\t\tint r = r_cmd_macro_cmd_args (mac, ptr, args, nargs);\n\t\t\t\t\t// TODO: handle quit? r == 0??\n\t\t\t\t\t// quit, exits the macro. like a break\n\t\t\t\t\tvalue = mac->num->value;\n\t\t\t\t\tif (r < 0) {\n\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\tr_cons_break_pop ();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\n';\n\t\t\t\t\tptr = end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmacro_level --;\n\t\t\t\t\tfree (str);\n\t\t\t\t\tgoto out_clean;\n\t\t\t\t}\n\n\t\t\t\t/* Fetch next command */\n\t\t\t\tend = strchr (ptr, '\\n');\n\t\t\t} while (!mac->brk);\n\t\t\tif (mac->brk) {\n\t\t\t\tmacro_level--;\n\t\t\t\tfree (str);\n\t\t\t\tgoto out_clean;\n\t\t\t}\n\t\t}\n\t}\n\teprintf (\"No macro named '%s'\\n\", str);\n\tmacro_level--;\n\tfree (str);\nout_clean:\n\tr_cons_break_pop ();\n\treturn true;\n}\n\nR_API int r_cmd_macro_break(RCmdMacro *mac, const char *value) {\n\tmac->brk = 1;\n\tmac->brk_value = NULL;\n\tmac->_brk_value = (ut64)r_num_math (mac->num, value);\n\tif (value && *value) {\n\t\tmac->brk_value = &mac->_brk_value;\n\t}\n\treturn 0;\n}\n\n/* RCmdParsedArgs */\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_new(const char *cmd, int n_args, char **args) {\n\tr_return_val_if_fail (cmd && n_args >= 0, NULL);\n\tRCmdParsedArgs *res = R_NEW0 (RCmdParsedArgs);\n\tres->has_space_after_cmd = true;\n\tres->argc = n_args + 1;\n\tres->argv = R_NEWS0 (char *, res->argc);\n\tres->argv[0] = strdup (cmd);\n\tint i;\n\tfor (i = 1; i < res->argc; i++) {\n\t\tres->argv[i] = strdup (args[i - 1]);\n\t}\n\treturn res;\n}\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_newcmd(const char *cmd) {\n\treturn r_cmd_parsed_args_new (cmd, 0, NULL);\n}\n\nR_API RCmdParsedArgs *r_cmd_parsed_args_newargs(int n_args, char **args) {\n\treturn r_cmd_parsed_args_new (\"\", n_args, args);\n}\n\nR_API void r_cmd_parsed_args_free(RCmdParsedArgs *a) {\n\tif (!a) {\n\t\treturn;\n\t}\n\n\tint i;\n\tfor (i = 0; i < a->argc; i++) {\n\t\tfree (a->argv[i]);\n\t}\n\tfree (a->argv);\n\tfree (a);\n}\n\nstatic void free_array(char **arr, int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tfree (arr[i]);\n\t}\n\tfree (arr);\n}\n\nR_API bool r_cmd_parsed_args_setargs(RCmdParsedArgs *a, int n_args, char **args) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], false);\n\tchar **tmp = R_NEWS0 (char *, n_args + 1);\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\ttmp[0] = strdup (a->argv[0]);\n\tint i;\n\tfor (i = 1; i < n_args + 1; i++) {\n\t\ttmp[i] = strdup (args[i - 1]);\n\t\tif (!tmp[i]) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree_array (a->argv, a->argc);\n\ta->argv = tmp;\n\ta->argc = n_args + 1;\n\treturn true;\nerr:\n\tfree_array (tmp, n_args + 1);\n\treturn false;\n}\n\nR_API bool r_cmd_parsed_args_setcmd(RCmdParsedArgs *a, const char *cmd) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], false);\n\tchar *tmp = strdup (cmd);\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\tfree (a->argv[0]);\n\ta->argv[0] = tmp;\n\treturn true;\n}\n\nstatic void parsed_args_iterateargs(RCmdParsedArgs *a, RStrBuf *sb) {\n\tint i;\n\tfor (i = 1; i < a->argc; i++) {\n\t\tif (i > 1) {\n\t\t\tr_strbuf_append (sb, \" \");\n\t\t}\n\t\tr_strbuf_append (sb, a->argv[i]);\n\t}\n}\n\nR_API char *r_cmd_parsed_args_argstr(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tparsed_args_iterateargs (a, sb);\n\treturn r_strbuf_drain (sb);\n}\n\nR_API char *r_cmd_parsed_args_execstr(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\tRStrBuf *sb = r_strbuf_new (a->argv[0]);\n\tif (a->argc > 1 && a->has_space_after_cmd) {\n\t\tr_strbuf_append (sb, \" \");\n\t}\n\tparsed_args_iterateargs (a, sb);\n\treturn r_strbuf_drain (sb);\n}\n\nR_API const char *r_cmd_parsed_args_cmd(RCmdParsedArgs *a) {\n\tr_return_val_if_fail (a && a->argv && a->argv[0], NULL);\n\treturn a->argv[0];\n}\n\n/* RCmdDescriptor */\n\nstatic RCmdDesc *argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help, bool ht_insert) {\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_ARGV, name, help, ht_insert);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tres->d.argv_data.cb = cb;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn argv_new (cmd, parent, name, cb, help, true);\n}\n\nR_API RCmdDesc *r_cmd_desc_inner_new(RCmd *cmd, RCmdDesc *parent, const char *name, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_INNER, name, help, false);\n}\n\nR_API RCmdDesc *r_cmd_desc_group_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help, const RCmdDescHelp *group_help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_GROUP, name, group_help, true);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tRCmdDesc *exec_cd = NULL;\n\tif (cb && help) {\n\t\texec_cd = argv_new (cmd, res, name, cb, help, false);\n\t\tif (!exec_cd) {\n\t\t\tr_cmd_desc_remove (cmd, res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tres->d.group_data.exec_cd = exec_cd;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_oldinput_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name && cb, NULL);\n\tRCmdDesc *res = create_cmd_desc (cmd, parent, R_CMD_DESC_TYPE_OLDINPUT, name, help, true);\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->d.oldinput_data.cb = cb;\n\treturn res;\n}\n\nR_API RCmdDesc *r_cmd_desc_parent(RCmdDesc *cd) {\n\tr_return_val_if_fail (cd, NULL);\n\treturn cd->parent;\n}\n\nR_API bool r_cmd_desc_has_handler(RCmdDesc *cd) {\n\tr_return_val_if_fail (cd, false);\n\tswitch (cd->type) {\n\tcase R_CMD_DESC_TYPE_ARGV:\n\t\treturn cd->d.argv_data.cb;\n\tcase R_CMD_DESC_TYPE_OLDINPUT:\n\t\treturn cd->d.oldinput_data.cb;\n\tcase R_CMD_DESC_TYPE_INNER:\n\t\treturn false;\n\tcase R_CMD_DESC_TYPE_GROUP:\n\t\treturn cd->d.group_data.exec_cd && r_cmd_desc_has_handler (cd->d.group_data.exec_cd);\n\t}\n\treturn false;\n}\n\nR_API bool r_cmd_desc_remove(RCmd *cmd, RCmdDesc *cd) {\n\tr_return_val_if_fail (cmd && cd, false);\n\tif (cd->parent) {\n\t\tcmd_desc_unset_parent (cd);\n\t}\n\tcmd_desc_remove_from_ht_cmds (cmd, cd);\n\tcmd_desc_free (cd);\n\treturn true;\n}\n"], "filenames": ["libr/bin/format/mach0/mach0.c", "libr/bin/format/mach0/mach0.h", "libr/core/cmd_api.c"], "buggy_code_start_loc": [1513, 132, 394], "buggy_code_end_loc": [4562, 132, 395], "fixing_code_start_loc": [1513, 133, 394], "fixing_code_end_loc": [4564, 134, 395], "type": "CWE-125", "message": "Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.", "other": {"cve": {"id": "CVE-2022-1052", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-24T13:15:07.837", "lastModified": "2022-03-31T18:56:17.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6."}, {"lang": "es", "value": "Un Desbordamiento del B\u00fafer de la Pila en iterate_chained_fixups en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.6.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.6", "matchCriteriaId": "F3E05FE2-B40C-4EAB-B211-1CCEC2B73F98"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3b3b7f77-ab8d-4de3-999b-eeec0a3eebe7", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4"}}