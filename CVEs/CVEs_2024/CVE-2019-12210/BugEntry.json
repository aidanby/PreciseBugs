{"buggy_code": ["/*\n *  Copyright (C) 2014-2018 Yubico AB - See COPYING\n */\n\n/* Define which PAM interfaces we provide */\n#define PAM_SM_AUTH\n\n/* Include PAM headers */\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"util.h\"\n\n/* If secure_getenv is not defined, define it here */\n#ifndef HAVE_SECURE_GETENV\nchar *secure_getenv(const char *);\nchar *secure_getenv(const char *name) {\n  (void)name;\n  return NULL;\n}\n#endif\n\nstatic void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {\n  int i;\n  memset(cfg, 0, sizeof(cfg_t));\n  cfg->debug_file = stderr;\n\n  for (i = 0; i < argc; i++) {\n    if (strncmp(argv[i], \"max_devices=\", 12) == 0)\n      sscanf(argv[i], \"max_devices=%u\", &cfg->max_devs);\n    if (strcmp(argv[i], \"manual\") == 0)\n      cfg->manual = 1;\n    if (strcmp(argv[i], \"debug\") == 0)\n      cfg->debug = 1;\n    if (strcmp(argv[i], \"nouserok\") == 0)\n      cfg->nouserok = 1;\n    if (strcmp(argv[i], \"openasuser\") == 0)\n      cfg->openasuser = 1;\n    if (strcmp(argv[i], \"alwaysok\") == 0)\n      cfg->alwaysok = 1;\n    if (strcmp(argv[i], \"interactive\") == 0)\n      cfg->interactive = 1;\n    if (strcmp(argv[i], \"cue\") == 0)\n      cfg->cue = 1;\n    if (strcmp(argv[i], \"nodetect\") == 0)\n      cfg->nodetect = 1;\n    if (strncmp(argv[i], \"authfile=\", 9) == 0)\n      cfg->auth_file = argv[i] + 9;\n    if (strncmp(argv[i], \"authpending_file=\", 17) == 0)\n      cfg->authpending_file = argv[i] + 17;\n    if (strncmp(argv[i], \"origin=\", 7) == 0)\n      cfg->origin = argv[i] + 7;\n    if (strncmp(argv[i], \"appid=\", 6) == 0)\n      cfg->appid = argv[i] + 6;\n    if (strncmp(argv[i], \"prompt=\", 7) == 0)\n      cfg->prompt = argv[i] + 7;\n    if (strncmp (argv[i], \"debug_file=\", 11) == 0) {\n      const char *filename = argv[i] + 11;\n      if(strncmp (filename, \"stdout\", 6) == 0) {\n        cfg->debug_file = stdout;\n      }\n      else if(strncmp (filename, \"stderr\", 6) == 0) {\n        cfg->debug_file = stderr;\n      }\n      else if( strncmp (filename, \"syslog\", 6) == 0) {\n        cfg->debug_file = (FILE *)-1;\n      }\n      else {\n        struct stat st;\n        FILE *file;\n        if(lstat(filename, &st) == 0) {\n          if(S_ISREG(st.st_mode)) {\n            file = fopen(filename, \"a\");\n            if(file != NULL) {\n              cfg->debug_file = file;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (cfg->debug) {\n    D(cfg->debug_file, \"called.\");\n    D(cfg->debug_file, \"flags %d argc %d\", flags, argc);\n    for (i = 0; i < argc; i++) {\n      D(cfg->debug_file, \"argv[%d]=%s\", i, argv[i]);\n    }\n    D(cfg->debug_file, \"max_devices=%d\", cfg->max_devs);\n    D(cfg->debug_file, \"debug=%d\", cfg->debug);\n    D(cfg->debug_file, \"interactive=%d\", cfg->interactive);\n    D(cfg->debug_file, \"cue=%d\", cfg->cue);\n    D(cfg->debug_file, \"nodetect=%d\", cfg->nodetect);\n    D(cfg->debug_file, \"manual=%d\", cfg->manual);\n    D(cfg->debug_file, \"nouserok=%d\", cfg->nouserok);\n    D(cfg->debug_file, \"openasuser=%d\", cfg->openasuser);\n    D(cfg->debug_file, \"alwaysok=%d\", cfg->alwaysok);\n    D(cfg->debug_file, \"authfile=%s\", cfg->auth_file ? cfg->auth_file : \"(null)\");\n    D(cfg->debug_file, \"authpending_file=%s\", cfg->authpending_file ? cfg->authpending_file : \"(null)\");\n    D(cfg->debug_file, \"origin=%s\", cfg->origin ? cfg->origin : \"(null)\");\n    D(cfg->debug_file, \"appid=%s\", cfg->appid ? cfg->appid : \"(null)\");\n    D(cfg->debug_file, \"prompt=%s\", cfg->prompt ? cfg->prompt : \"(null)\");\n  }\n}\n\n#ifdef DBG\n#undef DBG\n#endif\n#define DBG(...)                                                                 \\\n  if (cfg->debug) {                                                            \\\n    D(cfg->debug_file, __VA_ARGS__);                                                           \\\n  }\n\n/* PAM entry point for authentication verification */\nint pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n  int retval = PAM_IGNORE;\n  device_t *devices = NULL;\n  unsigned n_devices = 0;\n  int openasuser;\n  int should_free_origin = 0;\n  int should_free_appid = 0;\n  int should_free_auth_file = 0;\n  int should_free_authpending_file = 0;\n\n  parse_cfg(flags, argc, argv, cfg);\n\n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n    } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n    }\n\n    DBG(\"Using default authentication file %s\", buf);\n\n    cfg->auth_file = buf; /* cfg takes ownership */\n    should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n    DBG(\"Using authentication file %s\", cfg->auth_file);\n  }\n\n  openasuser = geteuid() == 0 && cfg->openasuser;\n  if (openasuser) {\n    if (seteuid(pw_s.pw_uid)) {\n      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n  }\n  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                     cfg->debug, cfg->debug_file,\n                                     devices, &n_devices);\n  if (openasuser) {\n    if (seteuid(0)) {\n      DBG(\"Unable to switch back to uid 0\");\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched back to uid 0\");\n  }\n\n  if (retval != 1) {\n    // for nouserok; make sure errors in get_devices_from_authfile don't\n    // result in valid devices\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  // Determine the full path for authpending_file in order to emit touch request notifications\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    // Open (or create) the authpending_file to indicate that we start waiting for a touch\n    authpending_file_descriptor = open(cfg->authpending_file, O_RDONLY | O_CREAT, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  // Close the authpending_file to indicate that we stop waiting for a touch\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  return retval;\n}\n\nPAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc,\n                              const char **argv) {\n  (void)pamh;\n  (void)flags;\n  (void)argc;\n  (void)argv;\n\n  return PAM_SUCCESS;\n}\n", "/*\n * Copyright (C) 2014-2018 Yubico AB - See COPYING\n */\n\n#include \"util.h\"\n\n#include <u2f-server.h>\n#include <u2f-host.h>\n\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <errno.h>\n#include <unistd.h>\n\n#include <string.h>\n\nint get_devices_from_authfile(const char *authfile, const char *username,\n                              unsigned max_devs, int verbose, FILE *debug_file,\n                              device_t *devices, unsigned *n_devs) {\n\n  char *buf = NULL;\n  char *s_user, *s_token;\n  int retval = 0;\n  int fd = -1;\n  struct stat st;\n  struct passwd *pw = NULL, pw_s;\n  char buffer[BUFSIZE];\n  int gpu_ret;\n  FILE *opwfile = NULL;\n  unsigned i, j;\n\n  /* Ensure we never return uninitialized count. */\n  *n_devs = 0;\n\n  fd = open(authfile, O_RDONLY, 0);\n  if (fd < 0) {\n    if (verbose)\n      D(debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n    goto err;\n  }\n\n  if (fstat(fd, &st) < 0) {\n    if (verbose)\n      D(debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n    goto err;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n    if (verbose)\n      D(debug_file, \"%s is not a regular file\", authfile);\n    goto err;\n  }\n\n  if (st.st_size == 0) {\n    if (verbose)\n      D(debug_file, \"File %s is empty\", authfile);\n    goto err;\n  }\n\n  gpu_ret = getpwuid_r(st.st_uid, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpu_ret != 0 || pw == NULL) {\n    D(debug_file, \"Unable to retrieve credentials for uid %u, (%s)\", st.st_uid,\n       strerror(errno));\n    goto err;\n  }\n\n  if (strcmp(pw->pw_name, username) != 0 && strcmp(pw->pw_name, \"root\") != 0) {\n    if (strcmp(username, \"root\") != 0) {\n      D(debug_file, \"The owner of the authentication file is neither %s nor root\",\n         username);\n    } else {\n      D(debug_file, \"The owner of the authentication file is not root\");\n    }\n    goto err;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n    if (verbose)\n      D(debug_file, \"fdopen: %s\", strerror(errno));\n    goto err;\n  }\n\n  buf = malloc(sizeof(char) * (DEVSIZE * max_devs));\n  if (!buf) {\n    if (verbose)\n      D(debug_file, \"Unable to allocate memory\");\n    goto err;\n  }\n\n  retval = -2;\n  while (fgets(buf, (int)(DEVSIZE * (max_devs - 1)), opwfile)) {\n    char *saveptr = NULL;\n    if (buf[strlen(buf) - 1] == '\\n')\n      buf[strlen(buf) - 1] = '\\0';\n\n    if (verbose)\n      D(debug_file, \"Authorization line: %s\", buf);\n\n    s_user = strtok_r(buf, \":\", &saveptr);\n    if (s_user && strcmp(username, s_user) == 0) {\n      if (verbose)\n        D(debug_file, \"Matched user: %s\", s_user);\n\n      retval = -1; // We found at least one line for the user\n\n      // only keep last line for this user\n      for (i = 0; i < *n_devs; i++) {\n        free(devices[i].keyHandle);\n        free(devices[i].publicKey);\n        devices[i].keyHandle = NULL;\n        devices[i].publicKey = NULL;\n      }\n      *n_devs = 0;\n\n      i = 0;\n      while ((s_token = strtok_r(NULL, \",\", &saveptr))) {\n        devices[i].keyHandle = NULL;\n        devices[i].publicKey = NULL;\n\n        if ((*n_devs)++ > MAX_DEVS - 1) {\n          *n_devs = MAX_DEVS;\n          if (verbose)\n            D(debug_file, \"Found more than %d devices, ignoring the remaining ones\",\n               MAX_DEVS);\n          break;\n        }\n\n        if (verbose)\n          D(debug_file, \"KeyHandle for device number %d: %s\", i + 1, s_token);\n\n        devices[i].keyHandle = strdup(s_token);\n\n        if (!devices[i].keyHandle) {\n          if (verbose)\n            D(debug_file, \"Unable to allocate memory for keyHandle number %d\", i);\n          goto err;\n        }\n\n        s_token = strtok_r(NULL, \":\", &saveptr);\n\n        if (!s_token) {\n          if (verbose)\n            D(debug_file, \"Unable to retrieve publicKey number %d\", i + 1);\n          goto err;\n        }\n\n        if (verbose)\n          D(debug_file, \"publicKey for device number %d: %s\", i + 1, s_token);\n\n        if (strlen(s_token) % 2 != 0) {\n          if (verbose)\n            D(debug_file, \"Length of key number %d not even\", i + 1);\n          goto err;\n        }\n\n        devices[i].key_len = strlen(s_token) / 2;\n\n        if (verbose)\n          D(debug_file, \"Length of key number %d is %zu\", i + 1, devices[i].key_len);\n\n        devices[i].publicKey =\n          malloc((sizeof(unsigned char) * devices[i].key_len));\n\n        if (!devices[i].publicKey) {\n          if (verbose)\n            D(debug_file, \"Unable to allocate memory for publicKey number %d\", i);\n          goto err;\n        }\n\n        for (j = 0; j < devices[i].key_len; j++) {\n          unsigned int x;\n          if (sscanf(&s_token[2 * j], \"%2x\", &x) != 1) {\n            if (verbose)\n              D(debug_file, \"Invalid hex number in key\");\n            goto err;\n          }\n          devices[i].publicKey[j] = (unsigned char)x;\n        }\n\n        i++;\n      }\n    }\n  }\n\n  if (verbose)\n    D(debug_file, \"Found %d device(s) for user %s\", *n_devs, username);\n\n  retval = 1;\n  goto out;\n\nerr:\n  for (i = 0; i < *n_devs; i++) {\n    free(devices[i].keyHandle);\n    free(devices[i].publicKey);\n    devices[i].keyHandle = NULL;\n    devices[i].publicKey = NULL;\n  }\n\n  *n_devs = 0;\n\nout:\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (opwfile)\n    fclose(opwfile);\n  else if (fd >= 0)\n    close(fd);\n  return retval;\n}\n\nvoid free_devices(device_t *devices, const unsigned n_devs) {\n  unsigned i;\n\n  if (!devices)\n    return;\n\n  for (i = 0; i < n_devs; i++) {\n    free(devices[i].keyHandle);\n    devices[i].keyHandle = NULL;\n\n    free(devices[i].publicKey);\n    devices[i].publicKey = NULL;\n  }\n\n  free(devices);\n  devices = NULL;\n}\n\nint do_authentication(const cfg_t *cfg, const device_t *devices,\n                      const unsigned n_devs, pam_handle_t *pamh) {\n  u2fs_ctx_t *ctx;\n  u2fs_auth_res_t *auth_result;\n  u2fs_rc s_rc;\n  u2fh_rc h_rc;\n  u2fh_devs *devs = NULL;\n  char *response = NULL;\n  char *buf;\n  int retval = -2;\n  int cued = 0;\n  unsigned i = 0;\n  unsigned max_index = 0;\n  unsigned max_index_prev = 0;\n\n  h_rc = u2fh_global_init(cfg->debug ? U2FH_DEBUG : 0);\n  if (h_rc != U2FH_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-host: %s\", u2fh_strerror(h_rc));\n    return retval;\n  }\n  h_rc = u2fh_devs_init(&devs);\n  if (h_rc != U2FH_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-host device handles: %s\",\n       u2fh_strerror(h_rc));\n    return retval;\n  }\n\n  if ((h_rc = u2fh_devs_discover(devs, &max_index)) != U2FH_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to discover device(s), %s\", u2fh_strerror(h_rc));\n    return retval;\n  }\n  max_index_prev = max_index;\n\n  if (cfg->debug)\n    D(cfg->debug_file, \"Device max index is %u\", max_index);\n\n  s_rc = u2fs_global_init(cfg->debug ? U2FS_DEBUG : 0);\n  if (s_rc != U2FS_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-server: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n  s_rc = u2fs_init(&ctx);\n  if (s_rc != U2FS_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-server context: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if ((s_rc = u2fs_set_origin(ctx, cfg->origin)) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to set origin: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if ((s_rc = u2fs_set_appid(ctx, cfg->appid)) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to set appid: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if (cfg->nodetect && cfg->debug)\n    D(cfg->debug_file, \"nodetect option specified, suitable key detection will be skipped\");\n\n  i = 0;\n  while (i < n_devs) {\n\n    retval = -2;\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Attempting authentication with device number %d\", i + 1);\n\n    if ((s_rc = u2fs_set_keyHandle(ctx, devices[i].keyHandle)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set keyHandle: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_publicKey(ctx, devices[i].publicKey)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set publicKey %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_authentication_challenge(ctx, &buf)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to produce authentication challenge: %s\",\n           u2fs_strerror(s_rc));\n      free(buf);\n      buf = NULL;\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Challenge: %s\", buf);\n\n    if (cfg->nodetect || (h_rc = u2fh_authenticate(devs, buf, cfg->origin, &response, 0)) == U2FH_OK ) {\n\n      if (cfg->manual == 0 && cfg->cue && !cued) {\n        cued = 1;\n        converse(pamh, PAM_TEXT_INFO, DEFAULT_CUE);\n      }\n\n      retval = -1;\n\n      if ((h_rc = u2fh_authenticate(devs, buf, cfg->origin, &response, U2FH_REQUEST_USER_PRESENCE)) ==\n          U2FH_OK) {\n        if (cfg->debug)\n          D(cfg->debug_file, \"Response: %s\", response);\n\n        s_rc = u2fs_authentication_verify(ctx, response, &auth_result);\n        u2fs_free_auth_res(auth_result);\n        free(response);\n        response = NULL;\n        if (s_rc == U2FS_OK) {\n          retval = 1;\n\n          free(buf);\n          buf = NULL;\n          break;\n        }\n      } else {\n        if (cfg->debug)\n          D(cfg->debug_file, \"Unable to communicate to the device, %s\", u2fh_strerror(h_rc));\n      }\n    } else {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Device for this keyhandle is not present.\");\n    }\n    free(buf);\n    buf = NULL;\n\n    i++;\n\n    if (u2fh_devs_discover(devs, &max_index) != U2FH_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to discover devices\");\n      return retval;\n    }\n\n    if (max_index > max_index_prev) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Devices max_index has changed: %u (was %u). Starting over\",\n           max_index, max_index_prev);\n      max_index_prev = max_index;\n      i = 0;\n    }\n  }\n\n  u2fh_devs_done(devs);\n  u2fh_global_done();\n\n  u2fs_done(ctx);\n  u2fs_global_done();\n\n  return retval;\n}\n\n#define MAX_PROMPT_LEN (1024)\n\nint do_manual_authentication(const cfg_t *cfg, const device_t *devices,\n                             const unsigned n_devs, pam_handle_t *pamh) {\n  u2fs_ctx_t *ctx_arr[n_devs];\n  u2fs_auth_res_t *auth_result;\n  u2fs_rc s_rc;\n  char *response = NULL;\n  char prompt[MAX_PROMPT_LEN];\n  char *buf;\n  int retval = -2;\n  unsigned i = 0;\n\n  if (u2fs_global_init(0) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to initialize libu2f-server\");\n    return retval;\n  }\n\n  for (i = 0; i < n_devs; ++i) {\n\n    if (u2fs_init(ctx_arr + i) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to initialize libu2f-server\");\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_origin(ctx_arr[i], cfg->origin)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set origin: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_appid(ctx_arr[i], cfg->appid)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set appid: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Attempting authentication with device number %d\", i + 1);\n\n    if ((s_rc = u2fs_set_keyHandle(ctx_arr[i], devices[i].keyHandle)) !=\n        U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set keyHandle: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_publicKey(ctx_arr[i], devices[i].publicKey)) !=\n        U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set publicKey %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_authentication_challenge(ctx_arr[i], &buf)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to produce authentication challenge: %s\",\n           u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Challenge: %s\", buf);\n\n    if (i == 0) {\n      snprintf(prompt, sizeof(prompt),\n                      \"Now please copy-paste the below challenge(s) to \"\n                      \"'u2f-host -aauthenticate -o %s'\",\n              cfg->origin);\n      converse(pamh, PAM_TEXT_INFO, prompt);\n    }\n    converse(pamh, PAM_TEXT_INFO, buf);\n    free(buf);\n    buf = NULL;\n  }\n\n  converse(pamh, PAM_TEXT_INFO,\n           \"Now, please enter the response(s) below, one per line.\");\n\n  retval = -1;\n\n  for (i = 0; i < n_devs; ++i) {\n    snprintf(prompt, sizeof(prompt), \"[%d]: \", i);\n    response = converse(pamh, PAM_PROMPT_ECHO_ON, prompt);\n    converse(pamh, PAM_TEXT_INFO, response);\n\n    s_rc = u2fs_authentication_verify(ctx_arr[i], response, &auth_result);\n    u2fs_free_auth_res(auth_result);\n    if (s_rc == U2FS_OK) {\n      retval = 1;\n    }\n    free(response);\n    if (retval == 1) {\n        break;\n    }\n  }\n\n  for (i = 0; i < n_devs; ++i)\n    u2fs_done(ctx_arr[i]);\n  u2fs_global_done();\n\n  return retval;\n}\n\nstatic int _converse(pam_handle_t *pamh, int nargs,\n                     const struct pam_message **message,\n                     struct pam_response **response) {\n  struct pam_conv *conv;\n  int retval;\n\n  retval = pam_get_item(pamh, PAM_CONV, (void *)&conv);\n\n  if (retval != PAM_SUCCESS) {\n    return retval;\n  }\n\n  return conv->conv(nargs, message, response, conv->appdata_ptr);\n}\n\nchar *converse(pam_handle_t *pamh, int echocode, const char *prompt) {\n  const struct pam_message msg = {.msg_style = echocode, .msg = (char *)prompt};\n  const struct pam_message *msgs = &msg;\n  struct pam_response *resp = NULL;\n  int retval = _converse(pamh, 1, &msgs, &resp);\n  char *ret = NULL;\n\n  if (retval != PAM_SUCCESS || resp == NULL || resp->resp == NULL ||\n      *resp->resp == '\\000') {\n\n    if (retval == PAM_SUCCESS && resp && resp->resp) {\n      ret = resp->resp;\n    }\n  } else {\n    ret = resp->resp;\n  }\n\n  // Deallocate temporary storage.\n  if (resp) {\n    if (!ret) {\n      free(resp->resp);\n    }\n    free(resp);\n  }\n\n  return ret;\n}\n\n#if defined(PAM_DEBUG)\nvoid _debug(FILE *debug_file, const char *file, int line, const char *func, const char *fmt, ...) {\n  va_list ap;\n#ifdef __linux__\n  unsigned int size;\n  char buffer[BUFSIZE];\n  char *out;\n\n  size = (unsigned int)snprintf(NULL, 0, DEBUG_STR, file, line, func);\n  va_start(ap, fmt);\n  size += (unsigned int)vsnprintf(NULL, 0, fmt, ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  if (size < (BUFSIZE - 1)) {\n    out = buffer;\n  }\n  else {\n    out = malloc(size);\n  }\n\n  if (out) {\n    size = (unsigned int)sprintf(out, DEBUG_STR, file, line, func);\n    vsprintf(&out[size], fmt, ap);\n    va_end(ap);\n  }\n  else {\n    out = buffer;\n    sprintf(out, \"debug(pam_u2f): malloc failed when trying to log\\n\");\n  }\n\n  if (debug_file == (FILE *)-1) {\n    syslog(LOG_AUTHPRIV | LOG_DEBUG, \"%s\", out);\n  }\n  else {\n    fprintf(debug_file, \"%s\\n\", out);\n  }\n\n  if (out != buffer) {\n    free(out);\n  }\n#else /* Windows, MAC */\n  va_start(ap, fmt);\n  fprintf(debug_file, DEBUG_STR, file, line, func );\n  vfprintf(debug_file, fmt, ap);\n  fprintf(debug_file, \"\\n\");\n  va_end(ap);\n#endif /* __linux__ */\n}\n#endif /* PAM_DEBUG */\n", "/*\n * Copyright (C) 2014-2018 Yubico AB - See COPYING\n */\n\n#ifndef UTIL_H\n#define UTIL_H\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n#define BUFSIZE 1024\n#define MAX_DEVS 24\n#define PK_LEN 130 // Public key\n#define KH_LEN 86  // Key handle\n#define RD_LEN 40  // Rounding\n#define DEVSIZE (((PK_LEN) + (KH_LEN) + (RD_LEN)))\n#define DEFAULT_AUTHFILE_DIR_VAR \"XDG_CONFIG_HOME\"\n#define DEFAULT_AUTHFILE \"/Yubico/u2f_keys\"\n#define DEFAULT_AUTHPENDING_FILE_PATH \"/var/run/user/%d/pam-u2f-authpending\"\n#define DEFAULT_PROMPT \"Insert your U2F device, then press ENTER.\"\n#define DEFAULT_CUE \"Please touch the device.\"\n#define DEFAULT_ORIGIN_PREFIX \"pam://\"\n#define DEBUG_STR \"debug(pam_u2f): %s:%d (%s): \"\n\n#if defined(DEBUG_PAM)\n#define D(file, ...)  _debug(file, __FILE__, __LINE__, __func__, __VA_ARGS__)\n#else\n#define D(file, ...)\n#endif /* DEBUG_PAM */\n\ntypedef struct {\n  unsigned max_devs;\n  const char *client_key;\n  int manual;\n  int debug;\n  int nouserok;\n  int openasuser;\n  int alwaysok;\n  int interactive;\n  int cue;\n  int nodetect;\n  const char *auth_file;\n  const char *authpending_file;\n  const char *origin;\n  const char *appid;\n  const char *prompt;\n  FILE *debug_file;\n} cfg_t;\n\ntypedef struct {\n  unsigned char *publicKey;\n  char *keyHandle;\n  size_t key_len;\n} device_t;\n\nint get_devices_from_authfile(const char *authfile, const char *username,\n                              unsigned max_devs, int verbose, FILE *debug_file,\n                              device_t *devices, unsigned *n_devs);\nvoid free_devices(device_t *devices, const unsigned n_devs);\n\nint do_authentication(const cfg_t *cfg, const device_t *devices,\n                      const unsigned n_devs, pam_handle_t *pamh);\nint do_manual_authentication(const cfg_t *cfg, const device_t *devices,\n                             const unsigned n_devs, pam_handle_t *pamh);\nchar *converse(pam_handle_t *pamh, int echocode, const char *prompt);\nvoid _debug(FILE *, const char *, int, const char *, const char *, ...);\n#endif /* UTIL_H */\n"], "fixing_code": ["/*\n *  Copyright (C) 2014-2019 Yubico AB - See COPYING\n */\n\n/* Define which PAM interfaces we provide */\n#define PAM_SM_AUTH\n\n/* Include PAM headers */\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"util.h\"\n\n/* If secure_getenv is not defined, define it here */\n#ifndef HAVE_SECURE_GETENV\nchar *secure_getenv(const char *);\nchar *secure_getenv(const char *name) {\n  (void)name;\n  return NULL;\n}\n#endif\n\nstatic void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {\n  struct stat st;\n  FILE *file = NULL;\n  int fd = -1;\n  int i;\n\n  memset(cfg, 0, sizeof(cfg_t));\n  cfg->debug_file = stderr;\n\n  for (i = 0; i < argc; i++) {\n    if (strncmp(argv[i], \"max_devices=\", 12) == 0)\n      sscanf(argv[i], \"max_devices=%u\", &cfg->max_devs);\n    if (strcmp(argv[i], \"manual\") == 0)\n      cfg->manual = 1;\n    if (strcmp(argv[i], \"debug\") == 0)\n      cfg->debug = 1;\n    if (strcmp(argv[i], \"nouserok\") == 0)\n      cfg->nouserok = 1;\n    if (strcmp(argv[i], \"openasuser\") == 0)\n      cfg->openasuser = 1;\n    if (strcmp(argv[i], \"alwaysok\") == 0)\n      cfg->alwaysok = 1;\n    if (strcmp(argv[i], \"interactive\") == 0)\n      cfg->interactive = 1;\n    if (strcmp(argv[i], \"cue\") == 0)\n      cfg->cue = 1;\n    if (strcmp(argv[i], \"nodetect\") == 0)\n      cfg->nodetect = 1;\n    if (strncmp(argv[i], \"authfile=\", 9) == 0)\n      cfg->auth_file = argv[i] + 9;\n    if (strncmp(argv[i], \"authpending_file=\", 17) == 0)\n      cfg->authpending_file = argv[i] + 17;\n    if (strncmp(argv[i], \"origin=\", 7) == 0)\n      cfg->origin = argv[i] + 7;\n    if (strncmp(argv[i], \"appid=\", 6) == 0)\n      cfg->appid = argv[i] + 6;\n    if (strncmp(argv[i], \"prompt=\", 7) == 0)\n      cfg->prompt = argv[i] + 7;\n    if (strncmp (argv[i], \"debug_file=\", 11) == 0) {\n      const char *filename = argv[i] + 11;\n      if(strncmp (filename, \"stdout\", 6) == 0) {\n        cfg->debug_file = stdout;\n      }\n      else if(strncmp (filename, \"stderr\", 6) == 0) {\n        cfg->debug_file = stderr;\n      }\n      else if( strncmp (filename, \"syslog\", 6) == 0) {\n        cfg->debug_file = (FILE *)-1;\n      }\n      else {\n        fd = open(filename, O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY);\n        if (fd >= 0 && (fstat(fd, &st) == 0) && S_ISREG(st.st_mode)) {\n          file = fdopen(fd, \"a\");\n          if(file != NULL) {\n            cfg->debug_file = file;\n            cfg->is_custom_debug_file = 1;\n            file = NULL;\n            fd = -1;\n          }\n        }\n      }\n    }\n  }\n\n  if (cfg->debug) {\n    D(cfg->debug_file, \"called.\");\n    D(cfg->debug_file, \"flags %d argc %d\", flags, argc);\n    for (i = 0; i < argc; i++) {\n      D(cfg->debug_file, \"argv[%d]=%s\", i, argv[i]);\n    }\n    D(cfg->debug_file, \"max_devices=%d\", cfg->max_devs);\n    D(cfg->debug_file, \"debug=%d\", cfg->debug);\n    D(cfg->debug_file, \"interactive=%d\", cfg->interactive);\n    D(cfg->debug_file, \"cue=%d\", cfg->cue);\n    D(cfg->debug_file, \"nodetect=%d\", cfg->nodetect);\n    D(cfg->debug_file, \"manual=%d\", cfg->manual);\n    D(cfg->debug_file, \"nouserok=%d\", cfg->nouserok);\n    D(cfg->debug_file, \"openasuser=%d\", cfg->openasuser);\n    D(cfg->debug_file, \"alwaysok=%d\", cfg->alwaysok);\n    D(cfg->debug_file, \"authfile=%s\", cfg->auth_file ? cfg->auth_file : \"(null)\");\n    D(cfg->debug_file, \"authpending_file=%s\", cfg->authpending_file ? cfg->authpending_file : \"(null)\");\n    D(cfg->debug_file, \"origin=%s\", cfg->origin ? cfg->origin : \"(null)\");\n    D(cfg->debug_file, \"appid=%s\", cfg->appid ? cfg->appid : \"(null)\");\n    D(cfg->debug_file, \"prompt=%s\", cfg->prompt ? cfg->prompt : \"(null)\");\n  }\n\n  if (fd != -1)\n    close(fd);\n\n  if (file != NULL)\n    fclose(file);\n}\n\n#ifdef DBG\n#undef DBG\n#endif\n#define DBG(...)                                                                 \\\n  if (cfg->debug) {                                                            \\\n    D(cfg->debug_file, __VA_ARGS__);                                                           \\\n  }\n\n/* PAM entry point for authentication verification */\nint pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n  int retval = PAM_IGNORE;\n  device_t *devices = NULL;\n  unsigned n_devices = 0;\n  int openasuser;\n  int should_free_origin = 0;\n  int should_free_appid = 0;\n  int should_free_auth_file = 0;\n  int should_free_authpending_file = 0;\n\n  parse_cfg(flags, argc, argv, cfg);\n\n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n    } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n    }\n\n    DBG(\"Using default authentication file %s\", buf);\n\n    cfg->auth_file = buf; /* cfg takes ownership */\n    should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n    DBG(\"Using authentication file %s\", cfg->auth_file);\n  }\n\n  openasuser = geteuid() == 0 && cfg->openasuser;\n  if (openasuser) {\n    if (seteuid(pw_s.pw_uid)) {\n      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n  }\n  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                     cfg->debug, cfg->debug_file,\n                                     devices, &n_devices);\n  if (openasuser) {\n    if (seteuid(0)) {\n      DBG(\"Unable to switch back to uid 0\");\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched back to uid 0\");\n  }\n\n  if (retval != 1) {\n    // for nouserok; make sure errors in get_devices_from_authfile don't\n    // result in valid devices\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  // Determine the full path for authpending_file in order to emit touch request notifications\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    // Open (or create) the authpending_file to indicate that we start waiting for a touch\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  // Close the authpending_file to indicate that we stop waiting for a touch\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}\n\nPAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc,\n                              const char **argv) {\n  (void)pamh;\n  (void)flags;\n  (void)argc;\n  (void)argv;\n\n  return PAM_SUCCESS;\n}\n", "/*\n * Copyright (C) 2014-2019 Yubico AB - See COPYING\n */\n\n#include \"util.h\"\n\n#include <u2f-server.h>\n#include <u2f-host.h>\n\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <errno.h>\n#include <unistd.h>\n\n#include <string.h>\n\nint get_devices_from_authfile(const char *authfile, const char *username,\n                              unsigned max_devs, int verbose, FILE *debug_file,\n                              device_t *devices, unsigned *n_devs) {\n\n  char *buf = NULL;\n  char *s_user, *s_token;\n  int retval = 0;\n  int fd = -1;\n  struct stat st;\n  struct passwd *pw = NULL, pw_s;\n  char buffer[BUFSIZE];\n  int gpu_ret;\n  FILE *opwfile = NULL;\n  unsigned i, j;\n\n  /* Ensure we never return uninitialized count. */\n  *n_devs = 0;\n\n  fd = open(authfile, O_RDONLY | O_CLOEXEC | O_NOCTTY);\n  if (fd < 0) {\n    if (verbose)\n      D(debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n    goto err;\n  }\n\n  if (fstat(fd, &st) < 0) {\n    if (verbose)\n      D(debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n    goto err;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n    if (verbose)\n      D(debug_file, \"%s is not a regular file\", authfile);\n    goto err;\n  }\n\n  if (st.st_size == 0) {\n    if (verbose)\n      D(debug_file, \"File %s is empty\", authfile);\n    goto err;\n  }\n\n  gpu_ret = getpwuid_r(st.st_uid, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpu_ret != 0 || pw == NULL) {\n    D(debug_file, \"Unable to retrieve credentials for uid %u, (%s)\", st.st_uid,\n       strerror(errno));\n    goto err;\n  }\n\n  if (strcmp(pw->pw_name, username) != 0 && strcmp(pw->pw_name, \"root\") != 0) {\n    if (strcmp(username, \"root\") != 0) {\n      D(debug_file, \"The owner of the authentication file is neither %s nor root\",\n         username);\n    } else {\n      D(debug_file, \"The owner of the authentication file is not root\");\n    }\n    goto err;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n    if (verbose)\n      D(debug_file, \"fdopen: %s\", strerror(errno));\n    goto err;\n  } else {\n    fd = -1; /* fd belongs to opwfile */\n  }\n\n  buf = malloc(sizeof(char) * (DEVSIZE * max_devs));\n  if (!buf) {\n    if (verbose)\n      D(debug_file, \"Unable to allocate memory\");\n    goto err;\n  }\n\n  retval = -2;\n  while (fgets(buf, (int)(DEVSIZE * (max_devs - 1)), opwfile)) {\n    char *saveptr = NULL;\n    if (buf[strlen(buf) - 1] == '\\n')\n      buf[strlen(buf) - 1] = '\\0';\n\n    if (verbose)\n      D(debug_file, \"Authorization line: %s\", buf);\n\n    s_user = strtok_r(buf, \":\", &saveptr);\n    if (s_user && strcmp(username, s_user) == 0) {\n      if (verbose)\n        D(debug_file, \"Matched user: %s\", s_user);\n\n      retval = -1; // We found at least one line for the user\n\n      // only keep last line for this user\n      for (i = 0; i < *n_devs; i++) {\n        free(devices[i].keyHandle);\n        free(devices[i].publicKey);\n        devices[i].keyHandle = NULL;\n        devices[i].publicKey = NULL;\n      }\n      *n_devs = 0;\n\n      i = 0;\n      while ((s_token = strtok_r(NULL, \",\", &saveptr))) {\n        devices[i].keyHandle = NULL;\n        devices[i].publicKey = NULL;\n\n        if ((*n_devs)++ > MAX_DEVS - 1) {\n          *n_devs = MAX_DEVS;\n          if (verbose)\n            D(debug_file, \"Found more than %d devices, ignoring the remaining ones\",\n               MAX_DEVS);\n          break;\n        }\n\n        if (verbose)\n          D(debug_file, \"KeyHandle for device number %d: %s\", i + 1, s_token);\n\n        devices[i].keyHandle = strdup(s_token);\n\n        if (!devices[i].keyHandle) {\n          if (verbose)\n            D(debug_file, \"Unable to allocate memory for keyHandle number %d\", i);\n          goto err;\n        }\n\n        s_token = strtok_r(NULL, \":\", &saveptr);\n\n        if (!s_token) {\n          if (verbose)\n            D(debug_file, \"Unable to retrieve publicKey number %d\", i + 1);\n          goto err;\n        }\n\n        if (verbose)\n          D(debug_file, \"publicKey for device number %d: %s\", i + 1, s_token);\n\n        if (strlen(s_token) % 2 != 0) {\n          if (verbose)\n            D(debug_file, \"Length of key number %d not even\", i + 1);\n          goto err;\n        }\n\n        devices[i].key_len = strlen(s_token) / 2;\n\n        if (verbose)\n          D(debug_file, \"Length of key number %d is %zu\", i + 1, devices[i].key_len);\n\n        devices[i].publicKey =\n          malloc((sizeof(unsigned char) * devices[i].key_len));\n\n        if (!devices[i].publicKey) {\n          if (verbose)\n            D(debug_file, \"Unable to allocate memory for publicKey number %d\", i);\n          goto err;\n        }\n\n        for (j = 0; j < devices[i].key_len; j++) {\n          unsigned int x;\n          if (sscanf(&s_token[2 * j], \"%2x\", &x) != 1) {\n            if (verbose)\n              D(debug_file, \"Invalid hex number in key\");\n            goto err;\n          }\n          devices[i].publicKey[j] = (unsigned char)x;\n        }\n\n        i++;\n      }\n    }\n  }\n\n  if (verbose)\n    D(debug_file, \"Found %d device(s) for user %s\", *n_devs, username);\n\n  retval = 1;\n  goto out;\n\nerr:\n  for (i = 0; i < *n_devs; i++) {\n    free(devices[i].keyHandle);\n    free(devices[i].publicKey);\n    devices[i].keyHandle = NULL;\n    devices[i].publicKey = NULL;\n  }\n\n  *n_devs = 0;\n\nout:\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (opwfile)\n    fclose(opwfile);\n\n  if (fd != -1)\n    close(fd);\n\n  return retval;\n}\n\nvoid free_devices(device_t *devices, const unsigned n_devs) {\n  unsigned i;\n\n  if (!devices)\n    return;\n\n  for (i = 0; i < n_devs; i++) {\n    free(devices[i].keyHandle);\n    devices[i].keyHandle = NULL;\n\n    free(devices[i].publicKey);\n    devices[i].publicKey = NULL;\n  }\n\n  free(devices);\n  devices = NULL;\n}\n\nint do_authentication(const cfg_t *cfg, const device_t *devices,\n                      const unsigned n_devs, pam_handle_t *pamh) {\n  u2fs_ctx_t *ctx;\n  u2fs_auth_res_t *auth_result;\n  u2fs_rc s_rc;\n  u2fh_rc h_rc;\n  u2fh_devs *devs = NULL;\n  char *response = NULL;\n  char *buf;\n  int retval = -2;\n  int cued = 0;\n  unsigned i = 0;\n  unsigned max_index = 0;\n  unsigned max_index_prev = 0;\n\n  h_rc = u2fh_global_init(cfg->debug ? U2FH_DEBUG : 0);\n  if (h_rc != U2FH_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-host: %s\", u2fh_strerror(h_rc));\n    return retval;\n  }\n  h_rc = u2fh_devs_init(&devs);\n  if (h_rc != U2FH_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-host device handles: %s\",\n       u2fh_strerror(h_rc));\n    return retval;\n  }\n\n  if ((h_rc = u2fh_devs_discover(devs, &max_index)) != U2FH_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to discover device(s), %s\", u2fh_strerror(h_rc));\n    return retval;\n  }\n  max_index_prev = max_index;\n\n  if (cfg->debug)\n    D(cfg->debug_file, \"Device max index is %u\", max_index);\n\n  s_rc = u2fs_global_init(cfg->debug ? U2FS_DEBUG : 0);\n  if (s_rc != U2FS_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-server: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n  s_rc = u2fs_init(&ctx);\n  if (s_rc != U2FS_OK) {\n    D(cfg->debug_file, \"Unable to initialize libu2f-server context: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if ((s_rc = u2fs_set_origin(ctx, cfg->origin)) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to set origin: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if ((s_rc = u2fs_set_appid(ctx, cfg->appid)) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to set appid: %s\", u2fs_strerror(s_rc));\n    return retval;\n  }\n\n  if (cfg->nodetect && cfg->debug)\n    D(cfg->debug_file, \"nodetect option specified, suitable key detection will be skipped\");\n\n  i = 0;\n  while (i < n_devs) {\n\n    retval = -2;\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Attempting authentication with device number %d\", i + 1);\n\n    if ((s_rc = u2fs_set_keyHandle(ctx, devices[i].keyHandle)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set keyHandle: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_publicKey(ctx, devices[i].publicKey)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set publicKey %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_authentication_challenge(ctx, &buf)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to produce authentication challenge: %s\",\n           u2fs_strerror(s_rc));\n      free(buf);\n      buf = NULL;\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Challenge: %s\", buf);\n\n    if (cfg->nodetect || (h_rc = u2fh_authenticate(devs, buf, cfg->origin, &response, 0)) == U2FH_OK ) {\n\n      if (cfg->manual == 0 && cfg->cue && !cued) {\n        cued = 1;\n        converse(pamh, PAM_TEXT_INFO, DEFAULT_CUE);\n      }\n\n      retval = -1;\n\n      if ((h_rc = u2fh_authenticate(devs, buf, cfg->origin, &response, U2FH_REQUEST_USER_PRESENCE)) ==\n          U2FH_OK) {\n        if (cfg->debug)\n          D(cfg->debug_file, \"Response: %s\", response);\n\n        s_rc = u2fs_authentication_verify(ctx, response, &auth_result);\n        u2fs_free_auth_res(auth_result);\n        free(response);\n        response = NULL;\n        if (s_rc == U2FS_OK) {\n          retval = 1;\n\n          free(buf);\n          buf = NULL;\n          break;\n        }\n      } else {\n        if (cfg->debug)\n          D(cfg->debug_file, \"Unable to communicate to the device, %s\", u2fh_strerror(h_rc));\n      }\n    } else {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Device for this keyhandle is not present.\");\n    }\n    free(buf);\n    buf = NULL;\n\n    i++;\n\n    if (u2fh_devs_discover(devs, &max_index) != U2FH_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to discover devices\");\n      return retval;\n    }\n\n    if (max_index > max_index_prev) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Devices max_index has changed: %u (was %u). Starting over\",\n           max_index, max_index_prev);\n      max_index_prev = max_index;\n      i = 0;\n    }\n  }\n\n  u2fh_devs_done(devs);\n  u2fh_global_done();\n\n  u2fs_done(ctx);\n  u2fs_global_done();\n\n  return retval;\n}\n\n#define MAX_PROMPT_LEN (1024)\n\nint do_manual_authentication(const cfg_t *cfg, const device_t *devices,\n                             const unsigned n_devs, pam_handle_t *pamh) {\n  u2fs_ctx_t *ctx_arr[n_devs];\n  u2fs_auth_res_t *auth_result;\n  u2fs_rc s_rc;\n  char *response = NULL;\n  char prompt[MAX_PROMPT_LEN];\n  char *buf;\n  int retval = -2;\n  unsigned i = 0;\n\n  if (u2fs_global_init(0) != U2FS_OK) {\n    if (cfg->debug)\n      D(cfg->debug_file, \"Unable to initialize libu2f-server\");\n    return retval;\n  }\n\n  for (i = 0; i < n_devs; ++i) {\n\n    if (u2fs_init(ctx_arr + i) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to initialize libu2f-server\");\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_origin(ctx_arr[i], cfg->origin)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set origin: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_appid(ctx_arr[i], cfg->appid)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set appid: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Attempting authentication with device number %d\", i + 1);\n\n    if ((s_rc = u2fs_set_keyHandle(ctx_arr[i], devices[i].keyHandle)) !=\n        U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set keyHandle: %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_set_publicKey(ctx_arr[i], devices[i].publicKey)) !=\n        U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to set publicKey %s\", u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if ((s_rc = u2fs_authentication_challenge(ctx_arr[i], &buf)) != U2FS_OK) {\n      if (cfg->debug)\n        D(cfg->debug_file, \"Unable to produce authentication challenge: %s\",\n           u2fs_strerror(s_rc));\n      return retval;\n    }\n\n    if (cfg->debug)\n      D(cfg->debug_file, \"Challenge: %s\", buf);\n\n    if (i == 0) {\n      snprintf(prompt, sizeof(prompt),\n                      \"Now please copy-paste the below challenge(s) to \"\n                      \"'u2f-host -aauthenticate -o %s'\",\n              cfg->origin);\n      converse(pamh, PAM_TEXT_INFO, prompt);\n    }\n    converse(pamh, PAM_TEXT_INFO, buf);\n    free(buf);\n    buf = NULL;\n  }\n\n  converse(pamh, PAM_TEXT_INFO,\n           \"Now, please enter the response(s) below, one per line.\");\n\n  retval = -1;\n\n  for (i = 0; i < n_devs; ++i) {\n    snprintf(prompt, sizeof(prompt), \"[%d]: \", i);\n    response = converse(pamh, PAM_PROMPT_ECHO_ON, prompt);\n    converse(pamh, PAM_TEXT_INFO, response);\n\n    s_rc = u2fs_authentication_verify(ctx_arr[i], response, &auth_result);\n    u2fs_free_auth_res(auth_result);\n    if (s_rc == U2FS_OK) {\n      retval = 1;\n    }\n    free(response);\n    if (retval == 1) {\n        break;\n    }\n  }\n\n  for (i = 0; i < n_devs; ++i)\n    u2fs_done(ctx_arr[i]);\n  u2fs_global_done();\n\n  return retval;\n}\n\nstatic int _converse(pam_handle_t *pamh, int nargs,\n                     const struct pam_message **message,\n                     struct pam_response **response) {\n  struct pam_conv *conv;\n  int retval;\n\n  retval = pam_get_item(pamh, PAM_CONV, (void *)&conv);\n\n  if (retval != PAM_SUCCESS) {\n    return retval;\n  }\n\n  return conv->conv(nargs, message, response, conv->appdata_ptr);\n}\n\nchar *converse(pam_handle_t *pamh, int echocode, const char *prompt) {\n  const struct pam_message msg = {.msg_style = echocode, .msg = (char *)prompt};\n  const struct pam_message *msgs = &msg;\n  struct pam_response *resp = NULL;\n  int retval = _converse(pamh, 1, &msgs, &resp);\n  char *ret = NULL;\n\n  if (retval != PAM_SUCCESS || resp == NULL || resp->resp == NULL ||\n      *resp->resp == '\\000') {\n\n    if (retval == PAM_SUCCESS && resp && resp->resp) {\n      ret = resp->resp;\n    }\n  } else {\n    ret = resp->resp;\n  }\n\n  // Deallocate temporary storage.\n  if (resp) {\n    if (!ret) {\n      free(resp->resp);\n    }\n    free(resp);\n  }\n\n  return ret;\n}\n\n#if defined(PAM_DEBUG)\nvoid _debug(FILE *debug_file, const char *file, int line, const char *func, const char *fmt, ...) {\n  va_list ap;\n#ifdef __linux__\n  unsigned int size;\n  char buffer[BUFSIZE];\n  char *out;\n\n  size = (unsigned int)snprintf(NULL, 0, DEBUG_STR, file, line, func);\n  va_start(ap, fmt);\n  size += (unsigned int)vsnprintf(NULL, 0, fmt, ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  if (size < (BUFSIZE - 1)) {\n    out = buffer;\n  }\n  else {\n    out = malloc(size);\n  }\n\n  if (out) {\n    size = (unsigned int)sprintf(out, DEBUG_STR, file, line, func);\n    vsprintf(&out[size], fmt, ap);\n    va_end(ap);\n  }\n  else {\n    out = buffer;\n    sprintf(out, \"debug(pam_u2f): malloc failed when trying to log\\n\");\n  }\n\n  if (debug_file == (FILE *)-1) {\n    syslog(LOG_AUTHPRIV | LOG_DEBUG, \"%s\", out);\n  }\n  else {\n    fprintf(debug_file, \"%s\\n\", out);\n  }\n\n  if (out != buffer) {\n    free(out);\n  }\n#else /* Windows, MAC */\n  va_start(ap, fmt);\n  fprintf(debug_file, DEBUG_STR, file, line, func );\n  vfprintf(debug_file, fmt, ap);\n  fprintf(debug_file, \"\\n\");\n  va_end(ap);\n#endif /* __linux__ */\n}\n#endif /* PAM_DEBUG */\n", "/*\n * Copyright (C) 2014-2019 Yubico AB - See COPYING\n */\n\n#ifndef UTIL_H\n#define UTIL_H\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n#define BUFSIZE 1024\n#define MAX_DEVS 24\n#define PK_LEN 130 // Public key\n#define KH_LEN 86  // Key handle\n#define RD_LEN 40  // Rounding\n#define DEVSIZE (((PK_LEN) + (KH_LEN) + (RD_LEN)))\n#define DEFAULT_AUTHFILE_DIR_VAR \"XDG_CONFIG_HOME\"\n#define DEFAULT_AUTHFILE \"/Yubico/u2f_keys\"\n#define DEFAULT_AUTHPENDING_FILE_PATH \"/var/run/user/%d/pam-u2f-authpending\"\n#define DEFAULT_PROMPT \"Insert your U2F device, then press ENTER.\"\n#define DEFAULT_CUE \"Please touch the device.\"\n#define DEFAULT_ORIGIN_PREFIX \"pam://\"\n#define DEBUG_STR \"debug(pam_u2f): %s:%d (%s): \"\n\n#if defined(DEBUG_PAM)\n#define D(file, ...)  _debug(file, __FILE__, __LINE__, __func__, __VA_ARGS__)\n#else\n#define D(file, ...)\n#endif /* DEBUG_PAM */\n\ntypedef struct {\n  unsigned max_devs;\n  const char *client_key;\n  int manual;\n  int debug;\n  int nouserok;\n  int openasuser;\n  int alwaysok;\n  int interactive;\n  int cue;\n  int nodetect;\n  const char *auth_file;\n  const char *authpending_file;\n  const char *origin;\n  const char *appid;\n  const char *prompt;\n  FILE *debug_file;\n  int is_custom_debug_file;\n} cfg_t;\n\ntypedef struct {\n  unsigned char *publicKey;\n  char *keyHandle;\n  size_t key_len;\n} device_t;\n\nint get_devices_from_authfile(const char *authfile, const char *username,\n                              unsigned max_devs, int verbose, FILE *debug_file,\n                              device_t *devices, unsigned *n_devs);\nvoid free_devices(device_t *devices, const unsigned n_devs);\n\nint do_authentication(const cfg_t *cfg, const device_t *devices,\n                      const unsigned n_devs, pam_handle_t *pamh);\nint do_manual_authentication(const cfg_t *cfg, const device_t *devices,\n                             const unsigned n_devs, pam_handle_t *pamh);\nchar *converse(pam_handle_t *pamh, int echocode, const char *prompt);\nvoid _debug(FILE *, const char *, int, const char *, const char *, ...);\n#endif /* UTIL_H */\n"], "filenames": ["pam-u2f.c", "util.c", "util.h"], "buggy_code_start_loc": [2, 2, 2], "buggy_code_end_loc": [386, 215, 47], "fixing_code_start_loc": [2, 2, 2], "fixing_code_end_loc": [402, 220, 49], "type": "NVD-CWE-noinfo", "message": "In Yubico pam-u2f 1.0.7, when configured with debug and a custom debug log file is set using debug_file, that file descriptor is not closed when a new process is spawned. This leads to the file descriptor being inherited into the child process; the child process can then read from and write to it. This can leak sensitive information and also, if written to, be used to fill the disk or plant misinformation.", "other": {"cve": {"id": "CVE-2019-12210", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-04T21:29:00.827", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Yubico pam-u2f 1.0.7, when configured with debug and a custom debug log file is set using debug_file, that file descriptor is not closed when a new process is spawned. This leads to the file descriptor being inherited into the child process; the child process can then read from and write to it. This can leak sensitive information and also, if written to, be used to fill the disk or plant misinformation."}, {"lang": "es", "value": "En Yubico pam-u2f 1.0.7, cuando se configura con depuraci\u00f3n y se configura un archivo de registro de depuraci\u00f3n personalizado utilizando debug_file, ese descriptor de archivo no se cierra cuando un nuevo proceso es generado. Esto lleva a que el descriptor de archivo se herede en el proceso hijo; El proceso hijo puede leer y escribir en \u00e9l. Esto puede filtrar informaci\u00f3n confidencial y tambi\u00e9n, si se escribe, se puede utilizar para rellenar el disco o la informaci\u00f3n err\u00f3nea de la planta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yubico:pam-u2f:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "F42F8364-4F0B-4890-AB66-4C3A47C09AFB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00012.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00018.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2019/06/05/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Exploit", "Third Party Advisory"]}, {"url": "https://developers.yubico.com/pam-u2f/Release_Notes.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62"}}