{"buggy_code": ["#include \"Limelight-internal.h\"\n\n#define ENET_INTERNAL_TIMEOUT_MS 100\n\n// This function wraps enet_host_service() and hides the fact that it must be called\n// multiple times for retransmissions to work correctly. It is meant to be a drop-in\n// replacement for enet_host_service(). It also handles cancellation of the connection\n// attempt during the wait.\nstatic int serviceEnetHostInternal(ENetHost* client, ENetEvent* event, enet_uint32 timeoutMs, bool ignoreInterrupts) {\n    int ret;\n\n    // We need to call enet_host_service() multiple times to make sure retransmissions happen\n    for (;;) {\n        int selectedTimeout = timeoutMs < ENET_INTERNAL_TIMEOUT_MS ? timeoutMs : ENET_INTERNAL_TIMEOUT_MS;\n\n        // We want to report an interrupt event if we are able to read data\n        if (!ignoreInterrupts && ConnectionInterrupted) {\n            Limelog(\"ENet wait interrupted\\n\");\n            ret = -1;\n            break;\n        }\n\n        ret = enet_host_service(client, event, selectedTimeout);\n        if (ret != 0 || timeoutMs == 0) {\n            break;\n        }\n\n        timeoutMs -= selectedTimeout;\n    }\n\n    return ret;\n}\n\nint serviceEnetHost(ENetHost* client, ENetEvent* event, enet_uint32 timeoutMs) {\n    return serviceEnetHostInternal(client, event, timeoutMs, false);\n}\n\n// This function performs a graceful disconnect, including lingering until outbound\n// traffic is acked (up until the linger timeout elapses).\nint gracefullyDisconnectEnetPeer(ENetHost* host, ENetPeer* peer, enet_uint32 lingerTimeoutMs) {\n    // Check if this peer is currently alive. We won't get another ENET_EVENT_TYPE_DISCONNECT\n    // event from ENet if the peer is dead. In that case, we'll do an abortive disconnect.\n    if (peer->state == ENET_PEER_STATE_CONNECTED) {\n        ENetEvent event;\n        int err;\n\n        // Begin the disconnection process. We'll get ENET_EVENT_TYPE_DISCONNECT once\n        // the peer acks all outstanding reliable sends.\n        enet_peer_disconnect_later(peer, 0);\n\n        // We must use the internal function which lets us ignore pending interrupts.\n        while ((err = serviceEnetHostInternal(host, &event, lingerTimeoutMs, true)) > 0) {\n            switch (event.type) {\n            case ENET_EVENT_TYPE_RECEIVE:\n                enet_packet_destroy(event.packet);\n                break;\n            case ENET_EVENT_TYPE_DISCONNECT:\n                Limelog(\"ENet peer acknowledged disconnection\\n\");\n                return 0;\n            default:\n                LC_ASSERT(false);\n                break;\n            }\n        }\n\n        if (err == 0) {\n            Limelog(\"Timed out waiting for ENet peer to acknowledge disconnection\\n\");\n        }\n        else {\n            Limelog(\"Failed to receive ENet peer disconnection acknowledgement\\n\");\n        }\n\n        return -1;\n    }\n    else {\n        Limelog(\"ENet peer is already disconnected\\n\");\n        enet_peer_disconnect_now(peer, 0);\n        return 0;\n    }\n}\n\nint extractVersionQuadFromString(const char* string, int* quad) {\n    char versionString[128];\n    char* nextDot;\n    char* nextNumber;\n    int i;\n    \n    strcpy(versionString, string);\n    nextNumber = versionString;\n    \n    for (i = 0; i < 4; i++) {\n        if (i == 3) {\n            nextDot = strchr(nextNumber, '\\0');\n        }\n        else {\n            nextDot = strchr(nextNumber, '.');\n        }\n        if (nextDot == NULL) {\n            return -1;\n        }\n        \n        // Cut the string off at the next dot\n        *nextDot = '\\0';\n        \n        quad[i] = atoi(nextNumber);\n        \n        // Move on to the next segment\n        nextNumber = nextDot + 1;\n    }\n    \n    return 0;\n}\n\nvoid* extendBuffer(void* ptr, size_t newSize) {\n    void* newBuf = realloc(ptr, newSize);\n    if (newBuf == NULL && ptr != NULL) {\n        free(ptr);\n    }\n    return newBuf;\n}\n\nbool isReferenceFrameInvalidationSupportedByDecoder(void) {\n    LC_ASSERT(NegotiatedVideoFormat != 0);\n\n    return ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_H264) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_AVC)) ||\n           ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_H265) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_HEVC)) ||\n           ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_AV1) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_AV1));\n}\n\nbool isReferenceFrameInvalidationEnabled(void) {\n    // RFI must be supported by the server and the client decoder to be used\n    return ReferenceFrameInvalidationSupported && isReferenceFrameInvalidationSupportedByDecoder();\n}\n\nvoid LiInitializeStreamConfiguration(PSTREAM_CONFIGURATION streamConfig) {\n    memset(streamConfig, 0, sizeof(*streamConfig));\n}\n\nvoid LiInitializeVideoCallbacks(PDECODER_RENDERER_CALLBACKS drCallbacks) {\n    memset(drCallbacks, 0, sizeof(*drCallbacks));\n}\n\nvoid LiInitializeAudioCallbacks(PAUDIO_RENDERER_CALLBACKS arCallbacks) {\n    memset(arCallbacks, 0, sizeof(*arCallbacks));\n}\n\nvoid LiInitializeConnectionCallbacks(PCONNECTION_LISTENER_CALLBACKS clCallbacks) {\n    memset(clCallbacks, 0, sizeof(*clCallbacks));\n}\n\nvoid LiInitializeServerInformation(PSERVER_INFORMATION serverInfo) {\n    memset(serverInfo, 0, sizeof(*serverInfo));\n}\n\nuint64_t LiGetMillis(void) {\n    return PltGetMillis();\n}\n\nuint32_t LiGetHostFeatureFlags(void) {\n    return SunshineFeatureFlags;\n}\n"], "fixing_code": ["#include \"Limelight-internal.h\"\n\n#define ENET_INTERNAL_TIMEOUT_MS 100\n\n// This function wraps enet_host_service() and hides the fact that it must be called\n// multiple times for retransmissions to work correctly. It is meant to be a drop-in\n// replacement for enet_host_service(). It also handles cancellation of the connection\n// attempt during the wait.\nstatic int serviceEnetHostInternal(ENetHost* client, ENetEvent* event, enet_uint32 timeoutMs, bool ignoreInterrupts) {\n    int ret;\n\n    // We need to call enet_host_service() multiple times to make sure retransmissions happen\n    for (;;) {\n        int selectedTimeout = timeoutMs < ENET_INTERNAL_TIMEOUT_MS ? timeoutMs : ENET_INTERNAL_TIMEOUT_MS;\n\n        // We want to report an interrupt event if we are able to read data\n        if (!ignoreInterrupts && ConnectionInterrupted) {\n            Limelog(\"ENet wait interrupted\\n\");\n            ret = -1;\n            break;\n        }\n\n        ret = enet_host_service(client, event, selectedTimeout);\n        if (ret != 0 || timeoutMs == 0) {\n            break;\n        }\n\n        timeoutMs -= selectedTimeout;\n    }\n\n    return ret;\n}\n\nint serviceEnetHost(ENetHost* client, ENetEvent* event, enet_uint32 timeoutMs) {\n    return serviceEnetHostInternal(client, event, timeoutMs, false);\n}\n\n// This function performs a graceful disconnect, including lingering until outbound\n// traffic is acked (up until the linger timeout elapses).\nint gracefullyDisconnectEnetPeer(ENetHost* host, ENetPeer* peer, enet_uint32 lingerTimeoutMs) {\n    // Check if this peer is currently alive. We won't get another ENET_EVENT_TYPE_DISCONNECT\n    // event from ENet if the peer is dead. In that case, we'll do an abortive disconnect.\n    if (peer->state == ENET_PEER_STATE_CONNECTED) {\n        ENetEvent event;\n        int err;\n\n        // Begin the disconnection process. We'll get ENET_EVENT_TYPE_DISCONNECT once\n        // the peer acks all outstanding reliable sends.\n        enet_peer_disconnect_later(peer, 0);\n\n        // We must use the internal function which lets us ignore pending interrupts.\n        while ((err = serviceEnetHostInternal(host, &event, lingerTimeoutMs, true)) > 0) {\n            switch (event.type) {\n            case ENET_EVENT_TYPE_RECEIVE:\n                enet_packet_destroy(event.packet);\n                break;\n            case ENET_EVENT_TYPE_DISCONNECT:\n                Limelog(\"ENet peer acknowledged disconnection\\n\");\n                return 0;\n            default:\n                LC_ASSERT(false);\n                break;\n            }\n        }\n\n        if (err == 0) {\n            Limelog(\"Timed out waiting for ENet peer to acknowledge disconnection\\n\");\n        }\n        else {\n            Limelog(\"Failed to receive ENet peer disconnection acknowledgement\\n\");\n        }\n\n        return -1;\n    }\n    else {\n        Limelog(\"ENet peer is already disconnected\\n\");\n        enet_peer_disconnect_now(peer, 0);\n        return 0;\n    }\n}\n\nint extractVersionQuadFromString(const char* string, int* quad) {\n    const char* nextNumber = string;\n    for (int i = 0; i < 4; i++) {\n        // Parse the next component\n        quad[i] = (int)strtol(nextNumber, (char**)&nextNumber, 10);\n\n        // Skip the dot if we still have version components left.\n        //\n        // We continue looping even when we're at the end of the\n        // input string to ensure all subsequent version components\n        // are zeroed.\n        if (*nextNumber != 0) {\n            nextNumber++;\n        }\n    }\n    \n    return 0;\n}\n\nvoid* extendBuffer(void* ptr, size_t newSize) {\n    void* newBuf = realloc(ptr, newSize);\n    if (newBuf == NULL && ptr != NULL) {\n        free(ptr);\n    }\n    return newBuf;\n}\n\nbool isReferenceFrameInvalidationSupportedByDecoder(void) {\n    LC_ASSERT(NegotiatedVideoFormat != 0);\n\n    return ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_H264) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_AVC)) ||\n           ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_H265) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_HEVC)) ||\n           ((NegotiatedVideoFormat & VIDEO_FORMAT_MASK_AV1) && (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION_AV1));\n}\n\nbool isReferenceFrameInvalidationEnabled(void) {\n    // RFI must be supported by the server and the client decoder to be used\n    return ReferenceFrameInvalidationSupported && isReferenceFrameInvalidationSupportedByDecoder();\n}\n\nvoid LiInitializeStreamConfiguration(PSTREAM_CONFIGURATION streamConfig) {\n    memset(streamConfig, 0, sizeof(*streamConfig));\n}\n\nvoid LiInitializeVideoCallbacks(PDECODER_RENDERER_CALLBACKS drCallbacks) {\n    memset(drCallbacks, 0, sizeof(*drCallbacks));\n}\n\nvoid LiInitializeAudioCallbacks(PAUDIO_RENDERER_CALLBACKS arCallbacks) {\n    memset(arCallbacks, 0, sizeof(*arCallbacks));\n}\n\nvoid LiInitializeConnectionCallbacks(PCONNECTION_LISTENER_CALLBACKS clCallbacks) {\n    memset(clCallbacks, 0, sizeof(*clCallbacks));\n}\n\nvoid LiInitializeServerInformation(PSERVER_INFORMATION serverInfo) {\n    memset(serverInfo, 0, sizeof(*serverInfo));\n}\n\nuint64_t LiGetMillis(void) {\n    return PltGetMillis();\n}\n\nuint32_t LiGetHostFeatureFlags(void) {\n    return SunshineFeatureFlags;\n}\n"], "filenames": ["src/Misc.c"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [109], "fixing_code_start_loc": [83], "fixing_code_end_loc": [95], "type": "CWE-120", "message": "Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954.", "other": {"cve": {"id": "CVE-2023-42801", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T17:15:07.657", "lastModified": "2023-12-27T19:29:03.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954."}, {"lang": "es", "value": "Moonlight-common-c contiene el c\u00f3digo principal del cliente GameStream compartido entre los clientes Moonlight. Moonlight-common-c es vulnerable al desbordamiento del b\u00fafer a partir de el commit f57bd745b4cbed577ea654fad4701bea4d38b44c. Un servidor de transmisi\u00f3n de juegos malicioso podr\u00eda aprovechar una vulnerabilidad de desbordamiento del b\u00fafer para bloquear un cliente Moonlight. Lograr RCE es posible, pero poco probable, debido a los canarios de pila que utilizan las cadenas de herramientas de compilaci\u00f3n modernas. Los binarios publicados para los clientes oficiales Qt, Android, iOS/tvOS y Embedded est\u00e1n creados con canarios de pila, pero es posible que algunos clientes no oficiales no utilicen canarios de pila. Esta vulnerabilidad se produce despu\u00e9s del proceso de emparejamiento, por lo que requiere que se enga\u00f1e al cliente para que se empareje con un host malicioso. No es posible realizar utilizando un intermediario debido a la fijaci\u00f3n de clave p\u00fablica que tiene lugar durante el proceso de emparejamiento. El error se solucion\u00f3 en el commit b2497a3918a6d79808d9fd0c04734786e70d5954."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight-common-c:*:*:*:*:*:*:*:*", "versionStartIncluding": "2016-10-05", "versionEndExcluding": "2023-10-06", "matchCriteriaId": "6A541BFA-AFA9-45F9-A3FF-6D0171AF3FF6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "9.0.0", "matchCriteriaId": "6C281DF9-B533-472E-B04D-0DC6090FF717"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:tvos:*:*", "versionEndExcluding": "9.0.0", "matchCriteriaId": "E65147FA-6910-4C37-A39B-79612CC3F09F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:android:*:*", "versionEndExcluding": "12.0", "matchCriteriaId": "D1AF2F8B-7A5A-416B-83EC-69209CBFDBC8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:chrome:*:*", "versionEndExcluding": "0.10.23", "matchCriteriaId": "20DF991A-ECF9-4526-922E-1041CFE0F3B6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_embedded:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.1", "matchCriteriaId": "DCD1F5DB-8365-4127-9712-FBAC26FB454B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_xbox:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.14.5", "matchCriteriaId": "DFB74756-2331-4872-9368-858709CDF84B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_tv:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "49048515-E23B-4829-AA68-4E3E395869CD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_switch:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.13.4", "matchCriteriaId": "3B470F75-3A7D-4FCC-8F73-5AD66492B238"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_vita:*:*:*:*:*:*:*:*", "matchCriteriaId": "F0FF6130-773C-460D-8D61-024A749879BF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_qt\\/pc:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.0.0", "matchCriteriaId": "81950A53-E571-4C59-A394-07CAC855E7CD"}]}]}], "references": [{"url": "https://github.com/moonlight-stream/moonlight-common-c/blob/c1744de06938b5a5c8897a705be1bc6508dc7580/src/Misc.c#L82-L88", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://github.com/moonlight-stream/moonlight-common-c/commit/b2497a3918a6d79808d9fd0c04734786e70d5954", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moonlight-stream/moonlight-common-c/commit/f57bd745b4cbed577ea654fad4701bea4d38b44c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moonlight-stream/moonlight-common-c/security/advisories/GHSA-f3h8-j898-5h5v", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moonlight-stream/moonlight-common-c/commit/b2497a3918a6d79808d9fd0c04734786e70d5954"}}