{"buggy_code": ["/*\n *  arch/arm/kernel/sys_oabi-compat.c\n *\n *  Compatibility wrappers for syscalls that are used from\n *  old ABI user space binaries with an EABI kernel.\n *\n *  Author:\tNicolas Pitre\n *  Created:\tOct 7, 2005\n *  Copyright:\tMontaVista Software, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n/*\n * The legacy ABI and the new ARM EABI have different rules making some\n * syscalls incompatible especially with structure arguments.\n * Most notably, Eabi says 64-bit members should be 64-bit aligned instead of\n * simply word aligned.  EABI also pads structures to the size of the largest\n * member it contains instead of the invariant 32-bit.\n *\n * The following syscalls are affected:\n *\n * sys_stat64:\n * sys_lstat64:\n * sys_fstat64:\n * sys_fstatat64:\n *\n *   struct stat64 has different sizes and some members are shifted\n *   Compatibility wrappers are needed for them and provided below.\n *\n * sys_fcntl64:\n *\n *   struct flock64 has different sizes and some members are shifted\n *   A compatibility wrapper is needed and provided below.\n *\n * sys_statfs64:\n * sys_fstatfs64:\n *\n *   struct statfs64 has extra padding with EABI growing its size from\n *   84 to 88.  This struct is now __attribute__((packed,aligned(4)))\n *   with a small assembly wrapper to force the sz argument to 84 if it is 88\n *   to avoid copying the extra padding over user space unexpecting it.\n *\n * sys_newuname:\n *\n *   struct new_utsname has no padding with EABI.  No problem there.\n *\n * sys_epoll_ctl:\n * sys_epoll_wait:\n *\n *   struct epoll_event has its second member shifted also affecting the\n *   structure size. Compatibility wrappers are needed and provided below.\n *\n * sys_ipc:\n * sys_semop:\n * sys_semtimedop:\n *\n *   struct sembuf loses its padding with EABI.  Since arrays of them are\n *   used they have to be copyed to remove the padding. Compatibility wrappers\n *   provided below.\n *\n * sys_bind:\n * sys_connect:\n * sys_sendmsg:\n * sys_sendto:\n * sys_socketcall:\n *\n *   struct sockaddr_un loses its padding with EABI.  Since the size of the\n *   structure is used as a validation test in unix_mkname(), we need to\n *   change the length argument to 110 whenever it is 112.  Compatibility\n *   wrappers provided below.\n */\n\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fcntl.h>\n#include <linux/eventpoll.h>\n#include <linux/sem.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/ipc.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstruct oldabi_stat64 {\n\tunsigned long long st_dev;\n\tunsigned int\t__pad1;\n\tunsigned long\t__st_ino;\n\tunsigned int\tst_mode;\n\tunsigned int\tst_nlink;\n\n\tunsigned long\tst_uid;\n\tunsigned long\tst_gid;\n\n\tunsigned long long st_rdev;\n\tunsigned int\t__pad2;\n\n\tlong long\tst_size;\n\tunsigned long\tst_blksize;\n\tunsigned long long st_blocks;\n\n\tunsigned long\tst_atime;\n\tunsigned long\tst_atime_nsec;\n\n\tunsigned long\tst_mtime;\n\tunsigned long\tst_mtime_nsec;\n\n\tunsigned long\tst_ctime;\n\tunsigned long\tst_ctime_nsec;\n\n\tunsigned long long st_ino;\n} __attribute__ ((packed,aligned(4)));\n\nstatic long cp_oldabi_stat64(struct kstat *stat,\n\t\t\t     struct oldabi_stat64 __user *statbuf)\n{\n\tstruct oldabi_stat64 tmp;\n\n\ttmp.st_dev = huge_encode_dev(stat->dev);\n\ttmp.__pad1 = 0;\n\ttmp.__st_ino = stat->ino;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\ttmp.st_uid = from_kuid_munged(current_user_ns(), stat->uid);\n\ttmp.st_gid = from_kgid_munged(current_user_ns(), stat->gid);\n\ttmp.st_rdev = huge_encode_dev(stat->rdev);\n\ttmp.st_size = stat->size;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.__pad2 = 0;\n\ttmp.st_blksize = stat->blksize;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_ino = stat->ino;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nasmlinkage long sys_oabi_stat64(const char __user * filename,\n\t\t\t\tstruct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_lstat64(const char __user * filename,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstat64(unsigned long fd,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstatat64(int dfd,\n\t\t\t\t   const char __user *filename,\n\t\t\t\t   struct oldabi_stat64  __user *statbuf,\n\t\t\t\t   int flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_oldabi_stat64(&stat, statbuf);\n}\n\nstruct oabi_flock64 {\n\tshort\tl_type;\n\tshort\tl_whence;\n\tloff_t\tl_start;\n\tloff_t\tl_len;\n\tpid_t\tl_pid;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n\tunsigned long local_arg = arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\n\treturn ret;\n}\n\nstruct oabi_epoll_event {\n\t__u32 events;\n\t__u64 data;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_epoll_ctl(int epfd, int op, int fd,\n\t\t\t\t   struct oabi_epoll_event __user *event)\n{\n\tstruct oabi_epoll_event user;\n\tstruct epoll_event kernel;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (op == EPOLL_CTL_DEL)\n\t\treturn sys_epoll_ctl(epfd, op, fd, NULL);\n\tif (copy_from_user(&user, event, sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.events = user.events;\n\tkernel.data   = user.data;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_ctl(epfd, op, fd, &kernel);\n\tset_fs(fs);\n\treturn ret;\n}\n\nasmlinkage long sys_oabi_epoll_wait(int epfd,\n\t\t\t\t    struct oabi_epoll_event __user *events,\n\t\t\t\t    int maxevents, int timeout)\n{\n\tstruct epoll_event *kbuf;\n\tmm_segment_t fs;\n\tlong ret, err, i;\n\n\tif (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))\n\t\treturn -EINVAL;\n\tkbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\n\tset_fs(fs);\n\terr = 0;\n\tfor (i = 0; i < ret; i++) {\n\t\t__put_user_error(kbuf[i].events, &events->events, err);\n\t\t__put_user_error(kbuf[i].data,   &events->data,   err);\n\t\tevents++;\n\t}\n\tkfree(kbuf);\n\treturn err ? -EFAULT : ret;\n}\n\nstruct oabi_sembuf {\n\tunsigned short\tsem_num;\n\tshort\t\tsem_op;\n\tshort\t\tsem_flg;\n\tunsigned short\t__pad;\n};\n\nasmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}\n\nasmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\n\t\t\t       unsigned nsops)\n{\n\treturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\n}\n\nasmlinkage int sys_oabi_ipc(uint call, int first, int second, int third,\n\t\t\t    void __user *ptr, long fifth)\n{\n\tswitch (call & 0xffff) {\n\tcase SEMOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second, NULL);\n\tcase SEMTIMEDOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second,\n\t\t\t\t\t    (const struct timespec __user *)fifth);\n\tdefault:\n\t\treturn sys_ipc(call, first, second, third, ptr, fifth);\n\t}\n}\n\nasmlinkage long sys_oabi_bind(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_bind(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_connect(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_connect(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendto(int fd, void __user *buff,\n\t\t\t\tsize_t len, unsigned flags,\n\t\t\t\tstruct sockaddr __user *addr,\n\t\t\t\tint addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_sendto(fd, buff, len, flags, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags)\n{\n\tstruct sockaddr __user *addr;\n\tint msg_namelen;\n\tsa_family_t sa_family;\n\tif (msg &&\n\t    get_user(msg_namelen, &msg->msg_namelen) == 0 &&\n\t    msg_namelen == 112 &&\n\t    get_user(addr, &msg->msg_name) == 0 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * HACK ALERT: there is a limit to how much backward bending\n\t\t * we should do for what is actually a transitional\n\t\t * compatibility layer.  This already has known flaws with\n\t\t * a few ioctls that we don't intend to fix.  Therefore\n\t\t * consider this blatent hack as another one... and take care\n\t\t * to run for cover.  In most cases it will \"just work fine\".\n\t\t * If it doesn't, well, tough.\n\t\t */\n\t\tput_user(110, &msg->msg_namelen);\n\t}\n\treturn sys_sendmsg(fd, msg, flags);\n}\n\nasmlinkage long sys_oabi_socketcall(int call, unsigned long __user *args)\n{\n\tunsigned long r = -EFAULT, a[6];\n\n\tswitch (call) {\n\tcase SYS_BIND:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_bind(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_connect(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\tif (copy_from_user(a, args, 6 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendto(a[0], (void __user *)a[1], a[2], a[3],\n\t\t\t\t\t    (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendmsg(a[0], (struct user_msghdr __user *)a[1], a[2]);\n\t\tbreak;\n\tdefault:\n\t\tr = sys_socketcall(call, args);\n\t}\n\n\treturn r;\n}\n"], "fixing_code": ["/*\n *  arch/arm/kernel/sys_oabi-compat.c\n *\n *  Compatibility wrappers for syscalls that are used from\n *  old ABI user space binaries with an EABI kernel.\n *\n *  Author:\tNicolas Pitre\n *  Created:\tOct 7, 2005\n *  Copyright:\tMontaVista Software, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n/*\n * The legacy ABI and the new ARM EABI have different rules making some\n * syscalls incompatible especially with structure arguments.\n * Most notably, Eabi says 64-bit members should be 64-bit aligned instead of\n * simply word aligned.  EABI also pads structures to the size of the largest\n * member it contains instead of the invariant 32-bit.\n *\n * The following syscalls are affected:\n *\n * sys_stat64:\n * sys_lstat64:\n * sys_fstat64:\n * sys_fstatat64:\n *\n *   struct stat64 has different sizes and some members are shifted\n *   Compatibility wrappers are needed for them and provided below.\n *\n * sys_fcntl64:\n *\n *   struct flock64 has different sizes and some members are shifted\n *   A compatibility wrapper is needed and provided below.\n *\n * sys_statfs64:\n * sys_fstatfs64:\n *\n *   struct statfs64 has extra padding with EABI growing its size from\n *   84 to 88.  This struct is now __attribute__((packed,aligned(4)))\n *   with a small assembly wrapper to force the sz argument to 84 if it is 88\n *   to avoid copying the extra padding over user space unexpecting it.\n *\n * sys_newuname:\n *\n *   struct new_utsname has no padding with EABI.  No problem there.\n *\n * sys_epoll_ctl:\n * sys_epoll_wait:\n *\n *   struct epoll_event has its second member shifted also affecting the\n *   structure size. Compatibility wrappers are needed and provided below.\n *\n * sys_ipc:\n * sys_semop:\n * sys_semtimedop:\n *\n *   struct sembuf loses its padding with EABI.  Since arrays of them are\n *   used they have to be copyed to remove the padding. Compatibility wrappers\n *   provided below.\n *\n * sys_bind:\n * sys_connect:\n * sys_sendmsg:\n * sys_sendto:\n * sys_socketcall:\n *\n *   struct sockaddr_un loses its padding with EABI.  Since the size of the\n *   structure is used as a validation test in unix_mkname(), we need to\n *   change the length argument to 110 whenever it is 112.  Compatibility\n *   wrappers provided below.\n */\n\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fcntl.h>\n#include <linux/eventpoll.h>\n#include <linux/sem.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/ipc.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstruct oldabi_stat64 {\n\tunsigned long long st_dev;\n\tunsigned int\t__pad1;\n\tunsigned long\t__st_ino;\n\tunsigned int\tst_mode;\n\tunsigned int\tst_nlink;\n\n\tunsigned long\tst_uid;\n\tunsigned long\tst_gid;\n\n\tunsigned long long st_rdev;\n\tunsigned int\t__pad2;\n\n\tlong long\tst_size;\n\tunsigned long\tst_blksize;\n\tunsigned long long st_blocks;\n\n\tunsigned long\tst_atime;\n\tunsigned long\tst_atime_nsec;\n\n\tunsigned long\tst_mtime;\n\tunsigned long\tst_mtime_nsec;\n\n\tunsigned long\tst_ctime;\n\tunsigned long\tst_ctime_nsec;\n\n\tunsigned long long st_ino;\n} __attribute__ ((packed,aligned(4)));\n\nstatic long cp_oldabi_stat64(struct kstat *stat,\n\t\t\t     struct oldabi_stat64 __user *statbuf)\n{\n\tstruct oldabi_stat64 tmp;\n\n\ttmp.st_dev = huge_encode_dev(stat->dev);\n\ttmp.__pad1 = 0;\n\ttmp.__st_ino = stat->ino;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\ttmp.st_uid = from_kuid_munged(current_user_ns(), stat->uid);\n\ttmp.st_gid = from_kgid_munged(current_user_ns(), stat->gid);\n\ttmp.st_rdev = huge_encode_dev(stat->rdev);\n\ttmp.st_size = stat->size;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.__pad2 = 0;\n\ttmp.st_blksize = stat->blksize;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_ino = stat->ino;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nasmlinkage long sys_oabi_stat64(const char __user * filename,\n\t\t\t\tstruct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_lstat64(const char __user * filename,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstat64(unsigned long fd,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstatat64(int dfd,\n\t\t\t\t   const char __user *filename,\n\t\t\t\t   struct oldabi_stat64  __user *statbuf,\n\t\t\t\t   int flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_oldabi_stat64(&stat, statbuf);\n}\n\nstruct oabi_flock64 {\n\tshort\tl_type;\n\tshort\tl_whence;\n\tloff_t\tl_start;\n\tloff_t\tl_len;\n\tpid_t\tl_pid;\n} __attribute__ ((packed,aligned(4)));\n\nstatic long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}\n\nasmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\treturn do_locks(fd, cmd, arg);\n\n\tdefault:\n\t\treturn sys_fcntl64(fd, cmd, arg);\n\t}\n}\n\nstruct oabi_epoll_event {\n\t__u32 events;\n\t__u64 data;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_epoll_ctl(int epfd, int op, int fd,\n\t\t\t\t   struct oabi_epoll_event __user *event)\n{\n\tstruct oabi_epoll_event user;\n\tstruct epoll_event kernel;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (op == EPOLL_CTL_DEL)\n\t\treturn sys_epoll_ctl(epfd, op, fd, NULL);\n\tif (copy_from_user(&user, event, sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.events = user.events;\n\tkernel.data   = user.data;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_ctl(epfd, op, fd, &kernel);\n\tset_fs(fs);\n\treturn ret;\n}\n\nasmlinkage long sys_oabi_epoll_wait(int epfd,\n\t\t\t\t    struct oabi_epoll_event __user *events,\n\t\t\t\t    int maxevents, int timeout)\n{\n\tstruct epoll_event *kbuf;\n\tmm_segment_t fs;\n\tlong ret, err, i;\n\n\tif (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))\n\t\treturn -EINVAL;\n\tkbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\n\tset_fs(fs);\n\terr = 0;\n\tfor (i = 0; i < ret; i++) {\n\t\t__put_user_error(kbuf[i].events, &events->events, err);\n\t\t__put_user_error(kbuf[i].data,   &events->data,   err);\n\t\tevents++;\n\t}\n\tkfree(kbuf);\n\treturn err ? -EFAULT : ret;\n}\n\nstruct oabi_sembuf {\n\tunsigned short\tsem_num;\n\tshort\t\tsem_op;\n\tshort\t\tsem_flg;\n\tunsigned short\t__pad;\n};\n\nasmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}\n\nasmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\n\t\t\t       unsigned nsops)\n{\n\treturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\n}\n\nasmlinkage int sys_oabi_ipc(uint call, int first, int second, int third,\n\t\t\t    void __user *ptr, long fifth)\n{\n\tswitch (call & 0xffff) {\n\tcase SEMOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second, NULL);\n\tcase SEMTIMEDOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second,\n\t\t\t\t\t    (const struct timespec __user *)fifth);\n\tdefault:\n\t\treturn sys_ipc(call, first, second, third, ptr, fifth);\n\t}\n}\n\nasmlinkage long sys_oabi_bind(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_bind(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_connect(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_connect(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendto(int fd, void __user *buff,\n\t\t\t\tsize_t len, unsigned flags,\n\t\t\t\tstruct sockaddr __user *addr,\n\t\t\t\tint addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_sendto(fd, buff, len, flags, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags)\n{\n\tstruct sockaddr __user *addr;\n\tint msg_namelen;\n\tsa_family_t sa_family;\n\tif (msg &&\n\t    get_user(msg_namelen, &msg->msg_namelen) == 0 &&\n\t    msg_namelen == 112 &&\n\t    get_user(addr, &msg->msg_name) == 0 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * HACK ALERT: there is a limit to how much backward bending\n\t\t * we should do for what is actually a transitional\n\t\t * compatibility layer.  This already has known flaws with\n\t\t * a few ioctls that we don't intend to fix.  Therefore\n\t\t * consider this blatent hack as another one... and take care\n\t\t * to run for cover.  In most cases it will \"just work fine\".\n\t\t * If it doesn't, well, tough.\n\t\t */\n\t\tput_user(110, &msg->msg_namelen);\n\t}\n\treturn sys_sendmsg(fd, msg, flags);\n}\n\nasmlinkage long sys_oabi_socketcall(int call, unsigned long __user *args)\n{\n\tunsigned long r = -EFAULT, a[6];\n\n\tswitch (call) {\n\tcase SYS_BIND:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_bind(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_connect(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\tif (copy_from_user(a, args, 6 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendto(a[0], (void __user *)a[1], a[2], a[3],\n\t\t\t\t\t    (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendmsg(a[0], (struct user_msghdr __user *)a[1], a[2]);\n\t\tbreak;\n\tdefault:\n\t\tr = sys_socketcall(call, args);\n\t}\n\n\treturn r;\n}\n"], "filenames": ["arch/arm/kernel/sys_oabi-compat.c"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [245], "fixing_code_start_loc": [196], "fixing_code_end_loc": [246], "type": "CWE-264", "message": "arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call.", "other": {"cve": {"id": "CVE-2015-8966", "sourceIdentifier": "security@android.com", "published": "2016-12-08T21:59:00.160", "lastModified": "2016-12-10T02:59:01.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call."}, {"lang": "es", "value": "arch/arm/kernel/sys_oabi-compat.c en el kernel de Linux en versiones anteriores a 4.4 permite a usuarios locales obtener privilegios a trav\u00e9s de un comando (1) F_OFD_GETLK, (2) F_OFD_SETLK o (3) F_OFD_SETLKW manipulado en una llamada de sistema fcntl64."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.6", "matchCriteriaId": "2B389602-4271-4CF2-BA64-4B0DAD8AB4A9"}]}]}], "references": [{"url": "http://source.android.com/security/bulletin/2016-12-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94673", "source": "security@android.com"}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=76cc404bfdc0d419c720de4daaf2584542734f42", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42"}}