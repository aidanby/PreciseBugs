{"buggy_code": ["/*\n * JPEG 2000 encoder and decoder common functions\n * Copyright (c) 2007 Kamil Nowosad\n * Copyright (c) 2013 Nicolas Bertrand <nicoinattendu@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * JPEG 2000 image encoder and decoder common functions\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/mem.h\"\n#include \"avcodec.h\"\n#include \"jpeg2000.h\"\n\n#define SHL(a, n) ((n) >= 0 ? (a) << (n) : (a) >> -(n))\n\n/* tag tree routines */\n\n/* allocate the memory for tag tree */\nstatic int32_t tag_tree_size(uint16_t w, uint16_t h)\n{\n    uint32_t res = 0;\n    while (w > 1 || h > 1) {\n        res += w * h;\n        av_assert0(res + 1 < INT32_MAX);\n        w = (w + 1) >> 1;\n        h = (h + 1) >> 1;\n    }\n    return (int32_t)(res + 1);\n}\n\nstatic Jpeg2000TgtNode *ff_jpeg2000_tag_tree_init(int w, int h)\n{\n    int pw = w, ph = h;\n    Jpeg2000TgtNode *res, *t, *t2;\n    int32_t tt_size;\n\n    tt_size = tag_tree_size(w, h);\n\n    t = res = av_mallocz_array(tt_size, sizeof(*t));\n    if (!res)\n        return NULL;\n\n    while (w > 1 || h > 1) {\n        int i, j;\n        pw = w;\n        ph = h;\n\n        w  = (w + 1) >> 1;\n        h  = (h + 1) >> 1;\n        t2 = t + pw * ph;\n\n        for (i = 0; i < ph; i++)\n            for (j = 0; j < pw; j++)\n                t[i * pw + j].parent = &t2[(i >> 1) * w + (j >> 1)];\n\n        t = t2;\n    }\n    t[0].parent = NULL;\n    return res;\n}\n\nstatic void tag_tree_zero(Jpeg2000TgtNode *t, int w, int h)\n{\n    int i, siz = tag_tree_size(w, h);\n\n    for (i = 0; i < siz; i++) {\n        t[i].val = 0;\n        t[i].vis = 0;\n    }\n}\n\nuint8_t ff_jpeg2000_sigctxno_lut[256][4];\n\nstatic int getsigctxno(int flag, int bandno)\n{\n    int h, v, d;\n\n    h = ((flag & JPEG2000_T1_SIG_E)  ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_W)  ? 1 : 0);\n    v = ((flag & JPEG2000_T1_SIG_N)  ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_S)  ? 1 : 0);\n    d = ((flag & JPEG2000_T1_SIG_NE) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_NW) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_SE) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_SW) ? 1 : 0);\n\n    if (bandno < 3) {\n        if (bandno == 1)\n            FFSWAP(int, h, v);\n        if (h == 2) return 8;\n        if (h == 1) {\n            if (v >= 1) return 7;\n            if (d >= 1) return 6;\n            return 5;\n        }\n        if (v == 2) return 4;\n        if (v == 1) return 3;\n        if (d >= 2) return 2;\n        if (d == 1) return 1;\n    } else {\n        if (d >= 3) return 8;\n        if (d == 2) {\n            if (h+v >= 1) return 7;\n            return 6;\n        }\n        if (d == 1) {\n            if (h+v >= 2) return 5;\n            if (h+v == 1) return 4;\n            return 3;\n        }\n        if (h+v >= 2) return 2;\n        if (h+v == 1) return 1;\n    }\n    return 0;\n}\n\nuint8_t ff_jpeg2000_sgnctxno_lut[16][16], ff_jpeg2000_xorbit_lut[16][16];\n\nstatic const int contribtab[3][3] = { {  0, -1,  1 }, { -1, -1,  0 }, {  1,  0,  1 } };\nstatic const int  ctxlbltab[3][3] = { { 13, 12, 11 }, { 10,  9, 10 }, { 11, 12, 13 } };\nstatic const int  xorbittab[3][3] = { {  1,  1,  1 }, {  1,  0,  0 }, {  0,  0,  0 } };\n\nstatic int getsgnctxno(int flag, uint8_t *xorbit)\n{\n    int vcontrib, hcontrib;\n\n    hcontrib = contribtab[flag & JPEG2000_T1_SIG_E ? flag & JPEG2000_T1_SGN_E ? 1 : 2 : 0]\n                         [flag & JPEG2000_T1_SIG_W ? flag & JPEG2000_T1_SGN_W ? 1 : 2 : 0] + 1;\n    vcontrib = contribtab[flag & JPEG2000_T1_SIG_S ? flag & JPEG2000_T1_SGN_S ? 1 : 2 : 0]\n                         [flag & JPEG2000_T1_SIG_N ? flag & JPEG2000_T1_SGN_N ? 1 : 2 : 0] + 1;\n    *xorbit = xorbittab[hcontrib][vcontrib];\n\n    return ctxlbltab[hcontrib][vcontrib];\n}\n\nvoid ff_jpeg2000_init_tier1_luts(void)\n{\n    int i, j;\n    for (i = 0; i < 256; i++)\n        for (j = 0; j < 4; j++)\n            ff_jpeg2000_sigctxno_lut[i][j] = getsigctxno(i, j);\n    for (i = 0; i < 16; i++)\n        for (j = 0; j < 16; j++)\n            ff_jpeg2000_sgnctxno_lut[i][j] =\n                getsgnctxno(i + (j << 8), &ff_jpeg2000_xorbit_lut[i][j]);\n}\n\nvoid ff_jpeg2000_set_significance(Jpeg2000T1Context *t1, int x, int y,\n                                  int negative)\n{\n    x++;\n    y++;\n    t1->flags[y][x] |= JPEG2000_T1_SIG;\n    if (negative) {\n        t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W | JPEG2000_T1_SGN_W;\n        t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E | JPEG2000_T1_SGN_E;\n        t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N | JPEG2000_T1_SGN_N;\n        t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S | JPEG2000_T1_SGN_S;\n    } else {\n        t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W;\n        t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E;\n        t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N;\n        t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S;\n    }\n    t1->flags[y + 1][x + 1] |= JPEG2000_T1_SIG_NW;\n    t1->flags[y + 1][x - 1] |= JPEG2000_T1_SIG_NE;\n    t1->flags[y - 1][x + 1] |= JPEG2000_T1_SIG_SW;\n    t1->flags[y - 1][x - 1] |= JPEG2000_T1_SIG_SE;\n}\n\nstatic const uint8_t lut_gain[2][4] = { { 0, 0, 0, 0 }, { 0, 1, 1, 2 } };\n\nint ff_jpeg2000_init_component(Jpeg2000Component *comp,\n                               Jpeg2000CodingStyle *codsty,\n                               Jpeg2000QuantStyle *qntsty,\n                               int cbps, int dx, int dy,\n                               AVCodecContext *avctx)\n{\n    uint8_t log2_band_prec_width, log2_band_prec_height;\n    int reslevelno, bandno, gbandno = 0, ret, i, j;\n    uint32_t csize;\n\n    if (codsty->nreslevels2decode <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"nreslevels2decode %d invalid or uninitialized\\n\", codsty->nreslevels2decode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,\n                                   codsty->nreslevels2decode - 1,\n                                   codsty->transform))\n        return ret;\n    // component size comp->coord is uint16_t so ir cannot overflow\n    csize = (comp->coord[0][1] - comp->coord[0][0]) *\n            (comp->coord[1][1] - comp->coord[1][0]);\n\n    if (codsty->transform == FF_DWT97) {\n        comp->i_data = NULL;\n        comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));\n        if (!comp->f_data)\n            return AVERROR(ENOMEM);\n    } else {\n        comp->f_data = NULL;\n        comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));\n        if (!comp->i_data)\n            return AVERROR(ENOMEM);\n    }\n    comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));\n    if (!comp->reslevel)\n        return AVERROR(ENOMEM);\n    /* LOOP on resolution levels */\n    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n        int declvl = codsty->nreslevels - reslevelno;    // N_L -r see  ISO/IEC 15444-1:2002 B.5\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        /* Compute borders for each resolution level.\n         * Computation of trx_0, trx_1, try_0 and try_1.\n         * see ISO/IEC 15444-1:2002 eq. B.5 and B-14 */\n        for (i = 0; i < 2; i++)\n            for (j = 0; j < 2; j++)\n                reslevel->coord[i][j] =\n                    ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);\n        // update precincts size: 2^n value\n        reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];\n        reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];\n\n        /* Number of bands for each resolution level */\n        if (reslevelno == 0)\n            reslevel->nbands = 1;\n        else\n            reslevel->nbands = 3;\n\n        /* Number of precincts wich span the tile for resolution level reslevelno\n         * see B.6 in ISO/IEC 15444-1:2002 eq. B-16\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -| - (trx_0 / 2 ^ log2_prec_width)\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| - (try_0 / 2 ^ log2_prec_width)\n         * for Dcinema profiles in JPEG 2000\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -|\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| */\n        if (reslevel->coord[0][1] == reslevel->coord[0][0])\n            reslevel->num_precincts_x = 0;\n        else\n            reslevel->num_precincts_x =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],\n                                        reslevel->log2_prec_width) -\n                (reslevel->coord[0][0] >> reslevel->log2_prec_width);\n\n        if (reslevel->coord[1][1] == reslevel->coord[1][0])\n            reslevel->num_precincts_y = 0;\n        else\n            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n            switch (qntsty->quantsty) {\n                uint8_t gain;\n                int numbps;\n            case JPEG2000_QSTY_NONE:\n                /* TODO: to verify. No quantization in this case */\n                band->f_stepsize = 1;\n                break;\n            case JPEG2000_QSTY_SI:\n                /*TODO: Compute formula to implement. */\n                numbps = cbps +\n                         lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];\n                band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],\n                                       2 + numbps - qntsty->expn[gbandno]);\n                break;\n            case JPEG2000_QSTY_SE:\n                /* Exponent quantization step.\n                 * Formula:\n                 * delta_b = 2 ^ (R_b - expn_b) * (1 + (mant_b / 2 ^ 11))\n                 * R_b = R_I + log2 (gain_b )\n                 * see ISO/IEC 15444-1:2002 E.1.1 eqn. E-3 and E-4 */\n                /* TODO/WARN: value of log2 (gain_b ) not taken into account\n                 * but it works (compared to OpenJPEG). Why?\n                 * Further investigation needed. */\n                gain            = cbps;\n                band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);\n                band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;\n                break;\n            default:\n                band->f_stepsize = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Unknown quantization format\\n\");\n                break;\n            }\n            /* FIXME: In openjepg code stespize = stepsize * 0.5. Why?\n             * If not set output of entropic decoder is not correct. */\n            if (!av_codec_is_encoder(avctx->codec))\n                band->f_stepsize *= 0.5;\n\n            band->i_stepsize = band->f_stepsize * (1 << 15);\n\n            /* computation of tbx_0, tbx_1, tby_0, tby_1\n             * see ISO/IEC 15444-1:2002 B.5 eq. B-15 and tbl B.1\n             * codeblock width and height is computed for\n             * DCI JPEG 2000 codeblock_width = codeblock_width = 32 = 2 ^ 5 */\n            if (reslevelno == 0) {\n                /* for reslevelno = 0, only one band, x0_b = y0_b = 0 */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],\n                                                    declvl - 1);\n                log2_band_prec_width  = reslevel->log2_prec_width;\n                log2_band_prec_height = reslevel->log2_prec_height;\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height);\n            } else {\n                /* 3 bands x0_b = 1 y0_b = 0; x0_b = 0 y0_b = 1; x0_b = y0_b = 1 */\n                /* x0_b and y0_b are computed with ((bandno + 1 >> i) & 1) */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        /* Formula example for tbx_0 = ceildiv((tcx_0 - 2 ^ (declvl - 1) * x0_b) / declvl) */\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -\n                                                    (((bandno + 1 >> i) & 1) << declvl - 1),\n                                                    declvl);\n                /* TODO: Manage case of 3 band offsets here or\n                 * in coding/decoding function? */\n\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width - 1);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height - 1);\n\n                log2_band_prec_width  = reslevel->log2_prec_width  - 1;\n                log2_band_prec_height = reslevel->log2_prec_height - 1;\n            }\n\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_malloc_array(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;\n\n            for (precno = 0; precno < nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n\n                /* TODO: Explain formula for JPEG200 DCINEMA. */\n                /* TODO: Verify with previous count of codeblocks per band */\n\n                /* Compute P_x0 */\n                prec->coord[0][0] = (precno % reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);\n\n                /* Compute P_y0 */\n                prec->coord[1][0] = (precno / reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);\n\n                /* Compute P_x1 */\n                prec->coord[0][1] = prec->coord[0][0] +\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);\n\n                /* Compute P_y1 */\n                prec->coord[1][1] = prec->coord[1][0] +\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);\n\n                prec->nb_codeblocks_width =\n                    ff_jpeg2000_ceildivpow2(prec->coord[0][1] -\n                                            prec->coord[0][0],\n                                            band->log2_cblk_width);\n                prec->nb_codeblocks_height =\n                    ff_jpeg2000_ceildivpow2(prec->coord[1][1] -\n                                            prec->coord[1][0],\n                                            band->log2_cblk_height);\n\n                /* Tag trees initialization */\n                prec->cblkincl =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->cblkincl)\n                    return AVERROR(ENOMEM);\n\n                prec->zerobits =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->zerobits)\n                    return AVERROR(ENOMEM);\n\n                prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *\n                                              (uint64_t)prec->nb_codeblocks_height,\n                                              sizeof(*prec->cblk));\n                if (!prec->cblk)\n                    return AVERROR(ENOMEM);\n                for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                    uint16_t Cx0, Cy0;\n\n                    /* Compute coordinates of codeblocks */\n                    /* Compute Cx0*/\n                    Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;\n                    Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);\n                    cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);\n\n                    /* Compute Cy0*/\n                    Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;\n                    Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);\n                    cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);\n\n                    /* Compute Cx1 */\n                    cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),\n                                              prec->coord[0][1]);\n\n                    /* Compute Cy1 */\n                    cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),\n                                              prec->coord[1][1]);\n                    /* Update code-blocks coordinates according sub-band position */\n                    if ((bandno + !!reslevelno) & 1) {\n                        cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                        cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                    }\n                    if ((bandno + !!reslevelno) & 2) {\n                        cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                        cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                    }\n\n                    cblk->zero      = 0;\n                    cblk->lblock    = 3;\n                    cblk->length    = 0;\n                    cblk->lengthinc = 0;\n                    cblk->npasses   = 0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nvoid ff_jpeg2000_reinit(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, cblkno, precno;\n    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n        Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n            Jpeg2000Band *band = rlevel->band + bandno;\n            for(precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                tag_tree_zero(prec->zerobits, prec->nb_codeblocks_width, prec->nb_codeblocks_height);\n                tag_tree_zero(prec->cblkincl, prec->nb_codeblocks_width, prec->nb_codeblocks_height);\n                for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                    cblk->length = 0;\n                    cblk->lblock = 3;\n                }\n            }\n        }\n    }\n}\n\nvoid ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}\n"], "fixing_code": ["/*\n * JPEG 2000 encoder and decoder common functions\n * Copyright (c) 2007 Kamil Nowosad\n * Copyright (c) 2013 Nicolas Bertrand <nicoinattendu@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * JPEG 2000 image encoder and decoder common functions\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/mem.h\"\n#include \"avcodec.h\"\n#include \"jpeg2000.h\"\n\n#define SHL(a, n) ((n) >= 0 ? (a) << (n) : (a) >> -(n))\n\n/* tag tree routines */\n\n/* allocate the memory for tag tree */\nstatic int32_t tag_tree_size(uint16_t w, uint16_t h)\n{\n    uint32_t res = 0;\n    while (w > 1 || h > 1) {\n        res += w * h;\n        av_assert0(res + 1 < INT32_MAX);\n        w = (w + 1) >> 1;\n        h = (h + 1) >> 1;\n    }\n    return (int32_t)(res + 1);\n}\n\nstatic Jpeg2000TgtNode *ff_jpeg2000_tag_tree_init(int w, int h)\n{\n    int pw = w, ph = h;\n    Jpeg2000TgtNode *res, *t, *t2;\n    int32_t tt_size;\n\n    tt_size = tag_tree_size(w, h);\n\n    t = res = av_mallocz_array(tt_size, sizeof(*t));\n    if (!res)\n        return NULL;\n\n    while (w > 1 || h > 1) {\n        int i, j;\n        pw = w;\n        ph = h;\n\n        w  = (w + 1) >> 1;\n        h  = (h + 1) >> 1;\n        t2 = t + pw * ph;\n\n        for (i = 0; i < ph; i++)\n            for (j = 0; j < pw; j++)\n                t[i * pw + j].parent = &t2[(i >> 1) * w + (j >> 1)];\n\n        t = t2;\n    }\n    t[0].parent = NULL;\n    return res;\n}\n\nstatic void tag_tree_zero(Jpeg2000TgtNode *t, int w, int h)\n{\n    int i, siz = tag_tree_size(w, h);\n\n    for (i = 0; i < siz; i++) {\n        t[i].val = 0;\n        t[i].vis = 0;\n    }\n}\n\nuint8_t ff_jpeg2000_sigctxno_lut[256][4];\n\nstatic int getsigctxno(int flag, int bandno)\n{\n    int h, v, d;\n\n    h = ((flag & JPEG2000_T1_SIG_E)  ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_W)  ? 1 : 0);\n    v = ((flag & JPEG2000_T1_SIG_N)  ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_S)  ? 1 : 0);\n    d = ((flag & JPEG2000_T1_SIG_NE) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_NW) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_SE) ? 1 : 0) +\n        ((flag & JPEG2000_T1_SIG_SW) ? 1 : 0);\n\n    if (bandno < 3) {\n        if (bandno == 1)\n            FFSWAP(int, h, v);\n        if (h == 2) return 8;\n        if (h == 1) {\n            if (v >= 1) return 7;\n            if (d >= 1) return 6;\n            return 5;\n        }\n        if (v == 2) return 4;\n        if (v == 1) return 3;\n        if (d >= 2) return 2;\n        if (d == 1) return 1;\n    } else {\n        if (d >= 3) return 8;\n        if (d == 2) {\n            if (h+v >= 1) return 7;\n            return 6;\n        }\n        if (d == 1) {\n            if (h+v >= 2) return 5;\n            if (h+v == 1) return 4;\n            return 3;\n        }\n        if (h+v >= 2) return 2;\n        if (h+v == 1) return 1;\n    }\n    return 0;\n}\n\nuint8_t ff_jpeg2000_sgnctxno_lut[16][16], ff_jpeg2000_xorbit_lut[16][16];\n\nstatic const int contribtab[3][3] = { {  0, -1,  1 }, { -1, -1,  0 }, {  1,  0,  1 } };\nstatic const int  ctxlbltab[3][3] = { { 13, 12, 11 }, { 10,  9, 10 }, { 11, 12, 13 } };\nstatic const int  xorbittab[3][3] = { {  1,  1,  1 }, {  1,  0,  0 }, {  0,  0,  0 } };\n\nstatic int getsgnctxno(int flag, uint8_t *xorbit)\n{\n    int vcontrib, hcontrib;\n\n    hcontrib = contribtab[flag & JPEG2000_T1_SIG_E ? flag & JPEG2000_T1_SGN_E ? 1 : 2 : 0]\n                         [flag & JPEG2000_T1_SIG_W ? flag & JPEG2000_T1_SGN_W ? 1 : 2 : 0] + 1;\n    vcontrib = contribtab[flag & JPEG2000_T1_SIG_S ? flag & JPEG2000_T1_SGN_S ? 1 : 2 : 0]\n                         [flag & JPEG2000_T1_SIG_N ? flag & JPEG2000_T1_SGN_N ? 1 : 2 : 0] + 1;\n    *xorbit = xorbittab[hcontrib][vcontrib];\n\n    return ctxlbltab[hcontrib][vcontrib];\n}\n\nvoid ff_jpeg2000_init_tier1_luts(void)\n{\n    int i, j;\n    for (i = 0; i < 256; i++)\n        for (j = 0; j < 4; j++)\n            ff_jpeg2000_sigctxno_lut[i][j] = getsigctxno(i, j);\n    for (i = 0; i < 16; i++)\n        for (j = 0; j < 16; j++)\n            ff_jpeg2000_sgnctxno_lut[i][j] =\n                getsgnctxno(i + (j << 8), &ff_jpeg2000_xorbit_lut[i][j]);\n}\n\nvoid ff_jpeg2000_set_significance(Jpeg2000T1Context *t1, int x, int y,\n                                  int negative)\n{\n    x++;\n    y++;\n    t1->flags[y][x] |= JPEG2000_T1_SIG;\n    if (negative) {\n        t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W | JPEG2000_T1_SGN_W;\n        t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E | JPEG2000_T1_SGN_E;\n        t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N | JPEG2000_T1_SGN_N;\n        t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S | JPEG2000_T1_SGN_S;\n    } else {\n        t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W;\n        t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E;\n        t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N;\n        t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S;\n    }\n    t1->flags[y + 1][x + 1] |= JPEG2000_T1_SIG_NW;\n    t1->flags[y + 1][x - 1] |= JPEG2000_T1_SIG_NE;\n    t1->flags[y - 1][x + 1] |= JPEG2000_T1_SIG_SW;\n    t1->flags[y - 1][x - 1] |= JPEG2000_T1_SIG_SE;\n}\n\nstatic const uint8_t lut_gain[2][4] = { { 0, 0, 0, 0 }, { 0, 1, 1, 2 } };\n\nint ff_jpeg2000_init_component(Jpeg2000Component *comp,\n                               Jpeg2000CodingStyle *codsty,\n                               Jpeg2000QuantStyle *qntsty,\n                               int cbps, int dx, int dy,\n                               AVCodecContext *avctx)\n{\n    uint8_t log2_band_prec_width, log2_band_prec_height;\n    int reslevelno, bandno, gbandno = 0, ret, i, j;\n    uint32_t csize;\n\n    if (codsty->nreslevels2decode <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"nreslevels2decode %d invalid or uninitialized\\n\", codsty->nreslevels2decode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,\n                                   codsty->nreslevels2decode - 1,\n                                   codsty->transform))\n        return ret;\n    // component size comp->coord is uint16_t so ir cannot overflow\n    csize = (comp->coord[0][1] - comp->coord[0][0]) *\n            (comp->coord[1][1] - comp->coord[1][0]);\n\n    if (codsty->transform == FF_DWT97) {\n        comp->i_data = NULL;\n        comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));\n        if (!comp->f_data)\n            return AVERROR(ENOMEM);\n    } else {\n        comp->f_data = NULL;\n        comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));\n        if (!comp->i_data)\n            return AVERROR(ENOMEM);\n    }\n    comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));\n    if (!comp->reslevel)\n        return AVERROR(ENOMEM);\n    /* LOOP on resolution levels */\n    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n        int declvl = codsty->nreslevels - reslevelno;    // N_L -r see  ISO/IEC 15444-1:2002 B.5\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        /* Compute borders for each resolution level.\n         * Computation of trx_0, trx_1, try_0 and try_1.\n         * see ISO/IEC 15444-1:2002 eq. B.5 and B-14 */\n        for (i = 0; i < 2; i++)\n            for (j = 0; j < 2; j++)\n                reslevel->coord[i][j] =\n                    ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);\n        // update precincts size: 2^n value\n        reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];\n        reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];\n\n        /* Number of bands for each resolution level */\n        if (reslevelno == 0)\n            reslevel->nbands = 1;\n        else\n            reslevel->nbands = 3;\n\n        /* Number of precincts wich span the tile for resolution level reslevelno\n         * see B.6 in ISO/IEC 15444-1:2002 eq. B-16\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -| - (trx_0 / 2 ^ log2_prec_width)\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| - (try_0 / 2 ^ log2_prec_width)\n         * for Dcinema profiles in JPEG 2000\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -|\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| */\n        if (reslevel->coord[0][1] == reslevel->coord[0][0])\n            reslevel->num_precincts_x = 0;\n        else\n            reslevel->num_precincts_x =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],\n                                        reslevel->log2_prec_width) -\n                (reslevel->coord[0][0] >> reslevel->log2_prec_width);\n\n        if (reslevel->coord[1][1] == reslevel->coord[1][0])\n            reslevel->num_precincts_y = 0;\n        else\n            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n            switch (qntsty->quantsty) {\n                uint8_t gain;\n                int numbps;\n            case JPEG2000_QSTY_NONE:\n                /* TODO: to verify. No quantization in this case */\n                band->f_stepsize = 1;\n                break;\n            case JPEG2000_QSTY_SI:\n                /*TODO: Compute formula to implement. */\n                numbps = cbps +\n                         lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];\n                band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],\n                                       2 + numbps - qntsty->expn[gbandno]);\n                break;\n            case JPEG2000_QSTY_SE:\n                /* Exponent quantization step.\n                 * Formula:\n                 * delta_b = 2 ^ (R_b - expn_b) * (1 + (mant_b / 2 ^ 11))\n                 * R_b = R_I + log2 (gain_b )\n                 * see ISO/IEC 15444-1:2002 E.1.1 eqn. E-3 and E-4 */\n                /* TODO/WARN: value of log2 (gain_b ) not taken into account\n                 * but it works (compared to OpenJPEG). Why?\n                 * Further investigation needed. */\n                gain            = cbps;\n                band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);\n                band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;\n                break;\n            default:\n                band->f_stepsize = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Unknown quantization format\\n\");\n                break;\n            }\n            /* FIXME: In openjepg code stespize = stepsize * 0.5. Why?\n             * If not set output of entropic decoder is not correct. */\n            if (!av_codec_is_encoder(avctx->codec))\n                band->f_stepsize *= 0.5;\n\n            band->i_stepsize = band->f_stepsize * (1 << 15);\n\n            /* computation of tbx_0, tbx_1, tby_0, tby_1\n             * see ISO/IEC 15444-1:2002 B.5 eq. B-15 and tbl B.1\n             * codeblock width and height is computed for\n             * DCI JPEG 2000 codeblock_width = codeblock_width = 32 = 2 ^ 5 */\n            if (reslevelno == 0) {\n                /* for reslevelno = 0, only one band, x0_b = y0_b = 0 */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],\n                                                    declvl - 1);\n                log2_band_prec_width  = reslevel->log2_prec_width;\n                log2_band_prec_height = reslevel->log2_prec_height;\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height);\n            } else {\n                /* 3 bands x0_b = 1 y0_b = 0; x0_b = 0 y0_b = 1; x0_b = y0_b = 1 */\n                /* x0_b and y0_b are computed with ((bandno + 1 >> i) & 1) */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        /* Formula example for tbx_0 = ceildiv((tcx_0 - 2 ^ (declvl - 1) * x0_b) / declvl) */\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -\n                                                    (((bandno + 1 >> i) & 1) << declvl - 1),\n                                                    declvl);\n                /* TODO: Manage case of 3 band offsets here or\n                 * in coding/decoding function? */\n\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width - 1);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height - 1);\n\n                log2_band_prec_width  = reslevel->log2_prec_width  - 1;\n                log2_band_prec_height = reslevel->log2_prec_height - 1;\n            }\n\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_calloc(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;\n\n            for (precno = 0; precno < nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n\n                /* TODO: Explain formula for JPEG200 DCINEMA. */\n                /* TODO: Verify with previous count of codeblocks per band */\n\n                /* Compute P_x0 */\n                prec->coord[0][0] = (precno % reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);\n\n                /* Compute P_y0 */\n                prec->coord[1][0] = (precno / reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);\n\n                /* Compute P_x1 */\n                prec->coord[0][1] = prec->coord[0][0] +\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);\n\n                /* Compute P_y1 */\n                prec->coord[1][1] = prec->coord[1][0] +\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);\n\n                prec->nb_codeblocks_width =\n                    ff_jpeg2000_ceildivpow2(prec->coord[0][1] -\n                                            prec->coord[0][0],\n                                            band->log2_cblk_width);\n                prec->nb_codeblocks_height =\n                    ff_jpeg2000_ceildivpow2(prec->coord[1][1] -\n                                            prec->coord[1][0],\n                                            band->log2_cblk_height);\n\n                /* Tag trees initialization */\n                prec->cblkincl =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->cblkincl)\n                    return AVERROR(ENOMEM);\n\n                prec->zerobits =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->zerobits)\n                    return AVERROR(ENOMEM);\n\n                prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *\n                                              (uint64_t)prec->nb_codeblocks_height,\n                                              sizeof(*prec->cblk));\n                if (!prec->cblk)\n                    return AVERROR(ENOMEM);\n                for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                    uint16_t Cx0, Cy0;\n\n                    /* Compute coordinates of codeblocks */\n                    /* Compute Cx0*/\n                    Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;\n                    Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);\n                    cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);\n\n                    /* Compute Cy0*/\n                    Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;\n                    Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);\n                    cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);\n\n                    /* Compute Cx1 */\n                    cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),\n                                              prec->coord[0][1]);\n\n                    /* Compute Cy1 */\n                    cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),\n                                              prec->coord[1][1]);\n                    /* Update code-blocks coordinates according sub-band position */\n                    if ((bandno + !!reslevelno) & 1) {\n                        cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                        cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                    }\n                    if ((bandno + !!reslevelno) & 2) {\n                        cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                        cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                    }\n\n                    cblk->zero      = 0;\n                    cblk->lblock    = 3;\n                    cblk->length    = 0;\n                    cblk->lengthinc = 0;\n                    cblk->npasses   = 0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nvoid ff_jpeg2000_reinit(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, cblkno, precno;\n    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n        Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n            Jpeg2000Band *band = rlevel->band + bandno;\n            for(precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                tag_tree_zero(prec->zerobits, prec->nb_codeblocks_width, prec->nb_codeblocks_height);\n                tag_tree_zero(prec->cblkincl, prec->nb_codeblocks_width, prec->nb_codeblocks_height);\n                for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                    cblk->length = 0;\n                    cblk->lblock = 3;\n                }\n            }\n        }\n    }\n}\n\nvoid ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                if (band->prec) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n                    av_freep(&prec->zerobits);\n                    av_freep(&prec->cblkincl);\n                    av_freep(&prec->cblk);\n                }\n            }\n\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}\n"], "filenames": ["libavcodec/jpeg2000.c"], "buggy_code_start_loc": [275], "buggy_code_end_loc": [516], "fixing_code_start_loc": [275], "fixing_code_end_loc": [518], "type": "NVD-CWE-Other", "message": "libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.", "other": {"cve": {"id": "CVE-2013-7017", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:49.473", "lastModified": "2016-12-03T03:00:42.330", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\n\n\"CWE-476: NULL Pointer Dereference\"", "descriptions": [{"lang": "en", "value": "libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data."}, {"lang": "es", "value": "libavcodec/jpeg2000.c en FFmpeg anterior a la versi\u00f3n 2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero inv\u00e1lido) o posiblemente tener otro impacto sin especificar a trav\u00e9s de datos JPEG2000 manipulados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555"}}