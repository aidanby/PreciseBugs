{"buggy_code": ["/*\n * LEGO USB Tower driver\n *\n * Copyright (C) 2003 David Glance <davidgsf@sourceforge.net>\n *               2001-2004 Juergen Stuber <starblue@users.sourceforge.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License as\n *\tpublished by the Free Software Foundation; either version 2 of\n *\tthe License, or (at your option) any later version.\n *\n * derived from USB Skeleton driver - 0.5\n * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)\n *\n * History:\n *\n * 2001-10-13 - 0.1 js\n *   - first version\n * 2001-11-03 - 0.2 js\n *   - simplified buffering, one-shot URBs for writing\n * 2001-11-10 - 0.3 js\n *   - removed IOCTL (setting power/mode is more complicated, postponed)\n * 2001-11-28 - 0.4 js\n *   - added vendor commands for mode of operation and power level in open\n * 2001-12-04 - 0.5 js\n *   - set IR mode by default (by oversight 0.4 set VLL mode)\n * 2002-01-11 - 0.5? pcchan\n *   - make read buffer reusable and work around bytes_to_write issue between\n *     uhci and legusbtower\n * 2002-09-23 - 0.52 david (david@csse.uwa.edu.au)\n *   - imported into lejos project\n *   - changed wake_up to wake_up_interruptible\n *   - changed to use lego0 rather than tower0\n *   - changed dbg() to use __func__ rather than deprecated __func__\n * 2003-01-12 - 0.53 david (david@csse.uwa.edu.au)\n *   - changed read and write to write everything or\n *     timeout (from a patch by Chris Riesen and Brett Thaeler driver)\n *   - added ioctl functionality to set timeouts\n * 2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au)\n *   - initial import into LegoUSB project\n *   - merge of existing LegoUSB.c driver\n * 2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au)\n *   - port to 2.6 style driver\n * 2004-02-29 - 0.6 Juergen Stuber <starblue@users.sourceforge.net>\n *   - fix locking\n *   - unlink read URBs which are no longer needed\n *   - allow increased buffer size, eliminates need for timeout on write\n *   - have read URB running continuously\n *   - added poll\n *   - forbid seeking\n *   - added nonblocking I/O\n *   - changed back __func__ to __func__\n *   - read and log tower firmware version\n *   - reset tower on probe, avoids failure of first write\n * 2004-03-09 - 0.7 Juergen Stuber <starblue@users.sourceforge.net>\n *   - timeout read now only after inactivity, shorten default accordingly\n * 2004-03-11 - 0.8 Juergen Stuber <starblue@users.sourceforge.net>\n *   - log major, minor instead of possibly confusing device filename\n *   - whitespace cleanup\n * 2004-03-12 - 0.9 Juergen Stuber <starblue@users.sourceforge.net>\n *   - normalize whitespace in debug messages\n *   - take care about endianness in control message responses\n * 2004-03-13 - 0.91 Juergen Stuber <starblue@users.sourceforge.net>\n *   - make default intervals longer to accommodate current EHCI driver\n * 2004-03-19 - 0.92 Juergen Stuber <starblue@users.sourceforge.net>\n *   - replaced atomic_t by memory barriers\n * 2004-04-21 - 0.93 Juergen Stuber <starblue@users.sourceforge.net>\n *   - wait for completion of write urb in release (needed for remotecontrol)\n *   - corrected poll for write direction (missing negation)\n * 2004-04-22 - 0.94 Juergen Stuber <starblue@users.sourceforge.net>\n *   - make device locking interruptible\n * 2004-04-30 - 0.95 Juergen Stuber <starblue@users.sourceforge.net>\n *   - check for valid udev on resubmitting and unlinking urbs\n * 2004-08-03 - 0.96 Juergen Stuber <starblue@users.sourceforge.net>\n *   - move reset into open to clean out spurious data\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <asm/uaccess.h>\n#include <linux/usb.h>\n#include <linux/poll.h>\n\n\n/* Version Information */\n#define DRIVER_VERSION \"v0.96\"\n#define DRIVER_AUTHOR \"Juergen Stuber <starblue@sourceforge.net>\"\n#define DRIVER_DESC \"LEGO USB Tower Driver\"\n\n\n/* The defaults are chosen to work with the latest versions of leJOS and NQC.\n */\n\n/* Some legacy software likes to receive packets in one piece.\n * In this case read_buffer_size should exceed the maximal packet length\n * (417 for datalog uploads), and packet_timeout should be set.\n */\nstatic int read_buffer_size = 480;\nmodule_param(read_buffer_size, int, 0);\nMODULE_PARM_DESC(read_buffer_size, \"Read buffer size\");\n\n/* Some legacy software likes to send packets in one piece.\n * In this case write_buffer_size should exceed the maximal packet length\n * (417 for firmware and program downloads).\n * A problem with long writes is that the following read may time out\n * if the software is not prepared to wait long enough.\n */\nstatic int write_buffer_size = 480;\nmodule_param(write_buffer_size, int, 0);\nMODULE_PARM_DESC(write_buffer_size, \"Write buffer size\");\n\n/* Some legacy software expects reads to contain whole LASM packets.\n * To achieve this, characters which arrive before a packet timeout\n * occurs will be returned in a single read operation.\n * A problem with long reads is that the software may time out\n * if it is not prepared to wait long enough.\n * The packet timeout should be greater than the time between the\n * reception of subsequent characters, which should arrive about\n * every 5ms for the standard 2400 baud.\n * Set it to 0 to disable.\n */\nstatic int packet_timeout = 50;\nmodule_param(packet_timeout, int, 0);\nMODULE_PARM_DESC(packet_timeout, \"Packet timeout in ms\");\n\n/* Some legacy software expects blocking reads to time out.\n * Timeout occurs after the specified time of read and write inactivity.\n * Set it to 0 to disable.\n */\nstatic int read_timeout = 200;\nmodule_param(read_timeout, int, 0);\nMODULE_PARM_DESC(read_timeout, \"Read timeout in ms\");\n\n/* As of kernel version 2.6.4 ehci-hcd uses an\n * \"only one interrupt transfer per frame\" shortcut\n * to simplify the scheduling of periodic transfers.\n * This conflicts with our standard 1ms intervals for in and out URBs.\n * We use default intervals of 2ms for in and 8ms for out transfers,\n * which is fast enough for 2400 baud and allows a small additional load.\n * Increase the interval to allow more devices that do interrupt transfers,\n * or set to 0 to use the standard interval from the endpoint descriptors.\n */\nstatic int interrupt_in_interval = 2;\nmodule_param(interrupt_in_interval, int, 0);\nMODULE_PARM_DESC(interrupt_in_interval, \"Interrupt in interval in ms\");\n\nstatic int interrupt_out_interval = 8;\nmodule_param(interrupt_out_interval, int, 0);\nMODULE_PARM_DESC(interrupt_out_interval, \"Interrupt out interval in ms\");\n\n/* Define these values to match your device */\n#define LEGO_USB_TOWER_VENDOR_ID\t0x0694\n#define LEGO_USB_TOWER_PRODUCT_ID\t0x0001\n\n/* Vendor requests */\n#define LEGO_USB_TOWER_REQUEST_RESET\t\t0x04\n#define LEGO_USB_TOWER_REQUEST_GET_VERSION\t0xFD\n\nstruct tower_reset_reply {\n\t__le16 size;\t\t/* little-endian */\n\t__u8 err_code;\n\t__u8 spare;\n} __attribute__ ((packed));\n\nstruct tower_get_version_reply {\n\t__le16 size;\t\t/* little-endian */\n\t__u8 err_code;\n\t__u8 spare;\n\t__u8 major;\n\t__u8 minor;\n\t__le16 build_no;\t\t/* little-endian */\n} __attribute__ ((packed));\n\n\n/* table of devices that work with this driver */\nstatic const struct usb_device_id tower_table[] = {\n\t{ USB_DEVICE(LEGO_USB_TOWER_VENDOR_ID, LEGO_USB_TOWER_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE (usb, tower_table);\nstatic DEFINE_MUTEX(open_disc_mutex);\n\n#define LEGO_USB_TOWER_MINOR_BASE\t160\n\n\n/* Structure to hold all of our device specific stuff */\nstruct lego_usb_tower {\n\tstruct mutex\t\tlock;\t\t/* locks this structure */\n\tstruct usb_device*\tudev;\t\t/* save off the usb device pointer */\n\tunsigned char\t\tminor;\t\t/* the starting minor number for this device */\n\n\tint\t\t\topen_count;\t/* number of times this port has been opened */\n\n\tchar*\t\t\tread_buffer;\n\tsize_t\t\t\tread_buffer_length; /* this much came in */\n\tsize_t\t\t\tread_packet_length; /* this much will be returned on read */\n\tspinlock_t\t\tread_buffer_lock;\n\tint\t\t\tpacket_timeout_jiffies;\n\tunsigned long\t\tread_last_arrival;\n\n\twait_queue_head_t\tread_wait;\n\twait_queue_head_t\twrite_wait;\n\n\tchar*\t\t\tinterrupt_in_buffer;\n\tstruct usb_endpoint_descriptor* interrupt_in_endpoint;\n\tstruct urb*\t\tinterrupt_in_urb;\n\tint\t\t\tinterrupt_in_interval;\n\tint\t\t\tinterrupt_in_running;\n\tint\t\t\tinterrupt_in_done;\n\n\tchar*\t\t\tinterrupt_out_buffer;\n\tstruct usb_endpoint_descriptor* interrupt_out_endpoint;\n\tstruct urb*\t\tinterrupt_out_urb;\n\tint\t\t\tinterrupt_out_interval;\n\tint\t\t\tinterrupt_out_busy;\n\n};\n\n\n/* local function prototypes */\nstatic ssize_t tower_read\t(struct file *file, char __user *buffer, size_t count, loff_t *ppos);\nstatic ssize_t tower_write\t(struct file *file, const char __user *buffer, size_t count, loff_t *ppos);\nstatic inline void tower_delete (struct lego_usb_tower *dev);\nstatic int tower_open\t\t(struct inode *inode, struct file *file);\nstatic int tower_release\t(struct inode *inode, struct file *file);\nstatic unsigned int tower_poll\t(struct file *file, poll_table *wait);\nstatic loff_t tower_llseek\t(struct file *file, loff_t off, int whence);\n\nstatic void tower_abort_transfers (struct lego_usb_tower *dev);\nstatic void tower_check_for_read_packet (struct lego_usb_tower *dev);\nstatic void tower_interrupt_in_callback (struct urb *urb);\nstatic void tower_interrupt_out_callback (struct urb *urb);\n\nstatic int  tower_probe\t(struct usb_interface *interface, const struct usb_device_id *id);\nstatic void tower_disconnect\t(struct usb_interface *interface);\n\n\n/* file operations needed when we register this driver */\nstatic const struct file_operations tower_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read  =\ttower_read,\n\t.write =\ttower_write,\n\t.open =\t\ttower_open,\n\t.release =\ttower_release,\n\t.poll =\t\ttower_poll,\n\t.llseek =\ttower_llseek,\n};\n\nstatic char *legousbtower_devnode(struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\n/*\n * usb class driver info in order to get a minor number from the usb core,\n * and to have the device registered with the driver core\n */\nstatic struct usb_class_driver tower_class = {\n\t.name =\t\t\"legousbtower%d\",\n\t.devnode = \tlegousbtower_devnode,\n\t.fops =\t\t&tower_fops,\n\t.minor_base =\tLEGO_USB_TOWER_MINOR_BASE,\n};\n\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver tower_driver = {\n\t.name =\t\t\"legousbtower\",\n\t.probe =\ttower_probe,\n\t.disconnect =\ttower_disconnect,\n\t.id_table =\ttower_table,\n};\n\n\n/**\n *\tlego_usb_tower_debug_data\n */\nstatic inline void lego_usb_tower_debug_data(struct device *dev,\n\t\t\t\t\t     const char *function, int size,\n\t\t\t\t\t     const unsigned char *data)\n{\n\tdev_dbg(dev, \"%s - length = %d, data = %*ph\\n\",\n\t\tfunction, size, size, data);\n}\n\n\n/**\n *\ttower_delete\n */\nstatic inline void tower_delete (struct lego_usb_tower *dev)\n{\n\ttower_abort_transfers (dev);\n\n\t/* free data structures */\n\tusb_free_urb(dev->interrupt_in_urb);\n\tusb_free_urb(dev->interrupt_out_urb);\n\tkfree (dev->read_buffer);\n\tkfree (dev->interrupt_in_buffer);\n\tkfree (dev->interrupt_out_buffer);\n\tkfree (dev);\n}\n\n\n/**\n *\ttower_open\n */\nstatic int tower_open (struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev = NULL;\n\tint subminor;\n\tint retval = 0;\n\tstruct usb_interface *interface;\n\tstruct tower_reset_reply reset_reply;\n\tint result;\n\n\tnonseekable_open(inode, file);\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface (&tower_driver, subminor);\n\n\tif (!interface) {\n\t\tpr_err(\"error, can't find device for minor %d\\n\", subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&open_disc_mutex);\n\tdev = usb_get_intfdata(interface);\n\n\tif (!dev) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* lock this device */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t        retval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\n\t/* allow opening only once */\n\tif (dev->open_count) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t\tretval = -EBUSY;\n\t\tgoto unlock_exit;\n\t}\n\tdev->open_count = 1;\n\tmutex_unlock(&open_disc_mutex);\n\n\t/* reset the tower */\n\tresult = usb_control_msg (dev->udev,\n\t\t\t\t  usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_RESET,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &reset_reply,\n\t\t\t\t  sizeof(reset_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"LEGO USB Tower reset control request failed\\n\");\n\t\tretval = result;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* initialize in direction */\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tusb_fill_int_urb (dev->interrupt_in_urb,\n\t\t\t  dev->udev,\n\t\t\t  usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t  dev->interrupt_in_buffer,\n\t\t\t  usb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t  tower_interrupt_in_callback,\n\t\t\t  dev,\n\t\t\t  dev->interrupt_in_interval);\n\n\tdev->interrupt_in_running = 1;\n\tdev->interrupt_in_done = 0;\n\tmb();\n\n\tretval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_in_urb %d\\n\", retval);\n\t\tdev->interrupt_in_running = 0;\n\t\tdev->open_count = 0;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* save device in the file's private structure */\n\tfile->private_data = dev;\n\nunlock_exit:\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n/**\n *\ttower_release\n */\nstatic int tower_release (struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\tif (dev == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit_nolock;\n\t}\n\n\tmutex_lock(&open_disc_mutex);\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t        retval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\tif (dev->open_count != 1) {\n\t\tdev_dbg(&dev->udev->dev, \"%s: device not opened exactly once\\n\",\n\t\t\t__func__);\n\t\tretval = -ENODEV;\n\t\tgoto unlock_exit;\n\t}\n\tif (dev->udev == NULL) {\n\t\t/* the device was unplugged before the file was released */\n\n\t\t/* unlock here as tower_delete frees dev */\n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete (dev);\n\t\tgoto exit;\n\t}\n\n\t/* wait until write transfer is finished */\n\tif (dev->interrupt_out_busy) {\n\t\twait_event_interruptible_timeout (dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);\n\t}\n\ttower_abort_transfers (dev);\n\tdev->open_count = 0;\n\nunlock_exit:\n\tmutex_unlock(&dev->lock);\n\nexit:\n\tmutex_unlock(&open_disc_mutex);\nexit_nolock:\n\treturn retval;\n}\n\n\n/**\n *\ttower_abort_transfers\n *      aborts transfers and frees associated data structures\n */\nstatic void tower_abort_transfers (struct lego_usb_tower *dev)\n{\n\tif (dev == NULL)\n\t\treturn;\n\n\t/* shutdown transfer */\n\tif (dev->interrupt_in_running) {\n\t\tdev->interrupt_in_running = 0;\n\t\tmb();\n\t\tif (dev->udev)\n\t\t\tusb_kill_urb (dev->interrupt_in_urb);\n\t}\n\tif (dev->interrupt_out_busy && dev->udev)\n\t\tusb_kill_urb(dev->interrupt_out_urb);\n}\n\n\n/**\n *\ttower_check_for_read_packet\n *\n *      To get correct semantics for signals and non-blocking I/O\n *      with packetizing we pretend not to see any data in the read buffer\n *      until it has been there unchanged for at least\n *      dev->packet_timeout_jiffies, or until the buffer is full.\n */\nstatic void tower_check_for_read_packet (struct lego_usb_tower *dev)\n{\n\tspin_lock_irq (&dev->read_buffer_lock);\n\tif (!packet_timeout\n\t    || time_after(jiffies, dev->read_last_arrival + dev->packet_timeout_jiffies)\n\t    || dev->read_buffer_length == read_buffer_size) {\n\t\tdev->read_packet_length = dev->read_buffer_length;\n\t}\n\tdev->interrupt_in_done = 0;\n\tspin_unlock_irq (&dev->read_buffer_lock);\n}\n\n\n/**\n *\ttower_poll\n */\nstatic unsigned int tower_poll (struct file *file, poll_table *wait)\n{\n\tstruct lego_usb_tower *dev;\n\tunsigned int mask = 0;\n\n\tdev = file->private_data;\n\n\tif (!dev->udev)\n\t\treturn POLLERR | POLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\ttower_check_for_read_packet(dev);\n\tif (dev->read_packet_length > 0) {\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tif (!dev->interrupt_out_busy) {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\n\treturn mask;\n}\n\n\n/**\n *\ttower_llseek\n */\nstatic loff_t tower_llseek (struct file *file, loff_t off, int whence)\n{\n\treturn -ESPIPE;\t\t/* unseekable */\n}\n\n\n/**\n *\ttower_read\n */\nstatic ssize_t tower_read (struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_read;\n\tint i;\n\tint retval = 0;\n\tunsigned long timeout = 0;\n\n\tdev = file->private_data;\n\n\t/* lock this object */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t/* verify that the device wasn't unplugged */\n\tif (dev->udev == NULL) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t/* verify that we actually have some data to read */\n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"read request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\tif (read_timeout) {\n\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\t}\n\n\t/* wait for data */\n\ttower_check_for_read_packet (dev);\n\twhile (dev->read_packet_length == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible_timeout(dev->read_wait, dev->interrupt_in_done, dev->packet_timeout_jiffies);\n\t\tif (retval < 0) {\n\t\t\tgoto unlock_exit;\n\t\t}\n\n\t\t/* reset read timeout during read or write activity */\n\t\tif (read_timeout\n\t\t    && (dev->read_buffer_length || dev->interrupt_out_busy)) {\n\t\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\t\t}\n\t\t/* check for read timeout */\n\t\tif (read_timeout && time_after (jiffies, timeout)) {\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\ttower_check_for_read_packet (dev);\n\t}\n\n\t/* copy the data from read_buffer into userspace */\n\tbytes_to_read = min(count, dev->read_packet_length);\n\n\tif (copy_to_user (buffer, dev->read_buffer, bytes_to_read)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\tspin_lock_irq (&dev->read_buffer_lock);\n\tdev->read_buffer_length -= bytes_to_read;\n\tdev->read_packet_length -= bytes_to_read;\n\tfor (i=0; i<dev->read_buffer_length; i++) {\n\t\tdev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];\n\t}\n\tspin_unlock_irq (&dev->read_buffer_lock);\n\n\tretval = bytes_to_read;\n\nunlock_exit:\n\t/* unlock the device */\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n/**\n *\ttower_write\n */\nstatic ssize_t tower_write (struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_write;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\t/* lock this object */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t/* verify that the device wasn't unplugged */\n\tif (dev->udev == NULL) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t/* verify that we actually have some data to write */\n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"write request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\t/* wait until previous transfer is finished */\n\twhile (dev->interrupt_out_busy) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible (dev->write_wait, !dev->interrupt_out_busy);\n\t\tif (retval) {\n\t\t\tgoto unlock_exit;\n\t\t}\n\t}\n\n\t/* write the data into interrupt_out_buffer from userspace */\n\tbytes_to_write = min_t(int, count, write_buffer_size);\n\tdev_dbg(&dev->udev->dev, \"%s: count = %Zd, bytes_to_write = %Zd\\n\",\n\t\t__func__, count, bytes_to_write);\n\n\tif (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* send off the urb */\n\tusb_fill_int_urb(dev->interrupt_out_urb,\n\t\t\t dev->udev,\n\t\t\t usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_out_buffer,\n\t\t\t bytes_to_write,\n\t\t\t tower_interrupt_out_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_out_interval);\n\n\tdev->interrupt_out_busy = 1;\n\twmb();\n\n\tretval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev->interrupt_out_busy = 0;\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_out_urb %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\tretval = bytes_to_write;\n\nunlock_exit:\n\t/* unlock the device */\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n/**\n *\ttower_interrupt_in_callback\n */\nstatic void tower_interrupt_in_callback (struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\tint retval;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\tif (status) {\n\t\tif (status == -ENOENT ||\n\t\t    status == -ECONNRESET ||\n\t\t    status == -ESHUTDOWN) {\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s: nonzero status received: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tgoto resubmit; /* maybe we can recover */\n\t\t}\n\t}\n\n\tif (urb->actual_length > 0) {\n\t\tspin_lock (&dev->read_buffer_lock);\n\t\tif (dev->read_buffer_length + urb->actual_length < read_buffer_size) {\n\t\t\tmemcpy (dev->read_buffer + dev->read_buffer_length,\n\t\t\t\tdev->interrupt_in_buffer,\n\t\t\t\turb->actual_length);\n\t\t\tdev->read_buffer_length += urb->actual_length;\n\t\t\tdev->read_last_arrival = jiffies;\n\t\t\tdev_dbg(&dev->udev->dev, \"%s: received %d bytes\\n\",\n\t\t\t\t__func__, urb->actual_length);\n\t\t} else {\n\t\t\tpr_warn(\"read_buffer overflow, %d bytes dropped\\n\",\n\t\t\t\turb->actual_length);\n\t\t}\n\t\tspin_unlock (&dev->read_buffer_lock);\n\t}\n\nresubmit:\n\t/* resubmit if we're still running */\n\tif (dev->interrupt_in_running && dev->udev) {\n\t\tretval = usb_submit_urb (dev->interrupt_in_urb, GFP_ATOMIC);\n\t\tif (retval)\n\t\t\tdev_err(&dev->udev->dev,\n\t\t\t\t\"%s: usb_submit_urb failed (%d)\\n\",\n\t\t\t\t__func__, retval);\n\t}\n\nexit:\n\tdev->interrupt_in_done = 1;\n\twake_up_interruptible (&dev->read_wait);\n}\n\n\n/**\n *\ttower_interrupt_out_callback\n */\nstatic void tower_interrupt_out_callback (struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\t/* sync/async unlink faults aren't errors */\n\tif (status && !(status == -ENOENT ||\n\t\t\tstatus == -ECONNRESET ||\n\t\t\tstatus == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"%s: nonzero write bulk status received: %d\\n\", __func__,\n\t\t\tstatus);\n\t}\n\n\tdev->interrupt_out_busy = 0;\n\twake_up_interruptible(&dev->write_wait);\n}\n\n\n/**\n *\ttower_probe\n *\n *\tCalled by the usb core when a new device is connected that it thinks\n *\tthis driver might be interested in.\n */\nstatic int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor* endpoint;\n\tstruct tower_get_version_reply get_version_reply;\n\tint i;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t/* allocate memory for our device state and initialize it */\n\n\tdev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (usb_endpoint_dir_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt in endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt out endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n\tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n\n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata (interface, dev);\n\n\tretval = usb_register_dev (interface, &tower_class);\n\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata (interface, NULL);\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n\n\t/* get the firmware version and log it */\n\tresult = usb_control_msg (udev,\n\t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &get_version_reply,\n\t\t\t\t  sizeof(get_version_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\t\t \"build %d\\n\", get_version_reply.major,\n\t\t get_version_reply.minor,\n\t\t le16_to_cpu(get_version_reply.build_no));\n\n\nexit:\n\treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n\n\n/**\n *\ttower_disconnect\n *\n *\tCalled by the usb core when the device is removed from the system.\n */\nstatic void tower_disconnect (struct usb_interface *interface)\n{\n\tstruct lego_usb_tower *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata (interface);\n\tmutex_lock(&open_disc_mutex);\n\tusb_set_intfdata (interface, NULL);\n\n\tminor = dev->minor;\n\n\t/* give back our minor */\n\tusb_deregister_dev (interface, &tower_class);\n\n\tmutex_lock(&dev->lock);\n\tmutex_unlock(&open_disc_mutex);\n\n\t/* if the device is not opened, then we clean up right now */\n\tif (!dev->open_count) {\n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete (dev);\n\t} else {\n\t\tdev->udev = NULL;\n\t\t/* wake up pollers */\n\t\twake_up_interruptible_all(&dev->read_wait);\n\t\twake_up_interruptible_all(&dev->write_wait);\n\t\tmutex_unlock(&dev->lock);\n\t}\n\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now disconnected\\n\",\n\t\t (minor - LEGO_USB_TOWER_MINOR_BASE));\n}\n\nmodule_usb_driver(tower_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n#ifdef MODULE_LICENSE\nMODULE_LICENSE(\"GPL\");\n#endif\n"], "fixing_code": ["/*\n * LEGO USB Tower driver\n *\n * Copyright (C) 2003 David Glance <davidgsf@sourceforge.net>\n *               2001-2004 Juergen Stuber <starblue@users.sourceforge.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License as\n *\tpublished by the Free Software Foundation; either version 2 of\n *\tthe License, or (at your option) any later version.\n *\n * derived from USB Skeleton driver - 0.5\n * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)\n *\n * History:\n *\n * 2001-10-13 - 0.1 js\n *   - first version\n * 2001-11-03 - 0.2 js\n *   - simplified buffering, one-shot URBs for writing\n * 2001-11-10 - 0.3 js\n *   - removed IOCTL (setting power/mode is more complicated, postponed)\n * 2001-11-28 - 0.4 js\n *   - added vendor commands for mode of operation and power level in open\n * 2001-12-04 - 0.5 js\n *   - set IR mode by default (by oversight 0.4 set VLL mode)\n * 2002-01-11 - 0.5? pcchan\n *   - make read buffer reusable and work around bytes_to_write issue between\n *     uhci and legusbtower\n * 2002-09-23 - 0.52 david (david@csse.uwa.edu.au)\n *   - imported into lejos project\n *   - changed wake_up to wake_up_interruptible\n *   - changed to use lego0 rather than tower0\n *   - changed dbg() to use __func__ rather than deprecated __func__\n * 2003-01-12 - 0.53 david (david@csse.uwa.edu.au)\n *   - changed read and write to write everything or\n *     timeout (from a patch by Chris Riesen and Brett Thaeler driver)\n *   - added ioctl functionality to set timeouts\n * 2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au)\n *   - initial import into LegoUSB project\n *   - merge of existing LegoUSB.c driver\n * 2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au)\n *   - port to 2.6 style driver\n * 2004-02-29 - 0.6 Juergen Stuber <starblue@users.sourceforge.net>\n *   - fix locking\n *   - unlink read URBs which are no longer needed\n *   - allow increased buffer size, eliminates need for timeout on write\n *   - have read URB running continuously\n *   - added poll\n *   - forbid seeking\n *   - added nonblocking I/O\n *   - changed back __func__ to __func__\n *   - read and log tower firmware version\n *   - reset tower on probe, avoids failure of first write\n * 2004-03-09 - 0.7 Juergen Stuber <starblue@users.sourceforge.net>\n *   - timeout read now only after inactivity, shorten default accordingly\n * 2004-03-11 - 0.8 Juergen Stuber <starblue@users.sourceforge.net>\n *   - log major, minor instead of possibly confusing device filename\n *   - whitespace cleanup\n * 2004-03-12 - 0.9 Juergen Stuber <starblue@users.sourceforge.net>\n *   - normalize whitespace in debug messages\n *   - take care about endianness in control message responses\n * 2004-03-13 - 0.91 Juergen Stuber <starblue@users.sourceforge.net>\n *   - make default intervals longer to accommodate current EHCI driver\n * 2004-03-19 - 0.92 Juergen Stuber <starblue@users.sourceforge.net>\n *   - replaced atomic_t by memory barriers\n * 2004-04-21 - 0.93 Juergen Stuber <starblue@users.sourceforge.net>\n *   - wait for completion of write urb in release (needed for remotecontrol)\n *   - corrected poll for write direction (missing negation)\n * 2004-04-22 - 0.94 Juergen Stuber <starblue@users.sourceforge.net>\n *   - make device locking interruptible\n * 2004-04-30 - 0.95 Juergen Stuber <starblue@users.sourceforge.net>\n *   - check for valid udev on resubmitting and unlinking urbs\n * 2004-08-03 - 0.96 Juergen Stuber <starblue@users.sourceforge.net>\n *   - move reset into open to clean out spurious data\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <asm/uaccess.h>\n#include <linux/usb.h>\n#include <linux/poll.h>\n\n\n/* Version Information */\n#define DRIVER_VERSION \"v0.96\"\n#define DRIVER_AUTHOR \"Juergen Stuber <starblue@sourceforge.net>\"\n#define DRIVER_DESC \"LEGO USB Tower Driver\"\n\n\n/* The defaults are chosen to work with the latest versions of leJOS and NQC.\n */\n\n/* Some legacy software likes to receive packets in one piece.\n * In this case read_buffer_size should exceed the maximal packet length\n * (417 for datalog uploads), and packet_timeout should be set.\n */\nstatic int read_buffer_size = 480;\nmodule_param(read_buffer_size, int, 0);\nMODULE_PARM_DESC(read_buffer_size, \"Read buffer size\");\n\n/* Some legacy software likes to send packets in one piece.\n * In this case write_buffer_size should exceed the maximal packet length\n * (417 for firmware and program downloads).\n * A problem with long writes is that the following read may time out\n * if the software is not prepared to wait long enough.\n */\nstatic int write_buffer_size = 480;\nmodule_param(write_buffer_size, int, 0);\nMODULE_PARM_DESC(write_buffer_size, \"Write buffer size\");\n\n/* Some legacy software expects reads to contain whole LASM packets.\n * To achieve this, characters which arrive before a packet timeout\n * occurs will be returned in a single read operation.\n * A problem with long reads is that the software may time out\n * if it is not prepared to wait long enough.\n * The packet timeout should be greater than the time between the\n * reception of subsequent characters, which should arrive about\n * every 5ms for the standard 2400 baud.\n * Set it to 0 to disable.\n */\nstatic int packet_timeout = 50;\nmodule_param(packet_timeout, int, 0);\nMODULE_PARM_DESC(packet_timeout, \"Packet timeout in ms\");\n\n/* Some legacy software expects blocking reads to time out.\n * Timeout occurs after the specified time of read and write inactivity.\n * Set it to 0 to disable.\n */\nstatic int read_timeout = 200;\nmodule_param(read_timeout, int, 0);\nMODULE_PARM_DESC(read_timeout, \"Read timeout in ms\");\n\n/* As of kernel version 2.6.4 ehci-hcd uses an\n * \"only one interrupt transfer per frame\" shortcut\n * to simplify the scheduling of periodic transfers.\n * This conflicts with our standard 1ms intervals for in and out URBs.\n * We use default intervals of 2ms for in and 8ms for out transfers,\n * which is fast enough for 2400 baud and allows a small additional load.\n * Increase the interval to allow more devices that do interrupt transfers,\n * or set to 0 to use the standard interval from the endpoint descriptors.\n */\nstatic int interrupt_in_interval = 2;\nmodule_param(interrupt_in_interval, int, 0);\nMODULE_PARM_DESC(interrupt_in_interval, \"Interrupt in interval in ms\");\n\nstatic int interrupt_out_interval = 8;\nmodule_param(interrupt_out_interval, int, 0);\nMODULE_PARM_DESC(interrupt_out_interval, \"Interrupt out interval in ms\");\n\n/* Define these values to match your device */\n#define LEGO_USB_TOWER_VENDOR_ID\t0x0694\n#define LEGO_USB_TOWER_PRODUCT_ID\t0x0001\n\n/* Vendor requests */\n#define LEGO_USB_TOWER_REQUEST_RESET\t\t0x04\n#define LEGO_USB_TOWER_REQUEST_GET_VERSION\t0xFD\n\nstruct tower_reset_reply {\n\t__le16 size;\t\t/* little-endian */\n\t__u8 err_code;\n\t__u8 spare;\n} __attribute__ ((packed));\n\nstruct tower_get_version_reply {\n\t__le16 size;\t\t/* little-endian */\n\t__u8 err_code;\n\t__u8 spare;\n\t__u8 major;\n\t__u8 minor;\n\t__le16 build_no;\t\t/* little-endian */\n} __attribute__ ((packed));\n\n\n/* table of devices that work with this driver */\nstatic const struct usb_device_id tower_table[] = {\n\t{ USB_DEVICE(LEGO_USB_TOWER_VENDOR_ID, LEGO_USB_TOWER_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE (usb, tower_table);\nstatic DEFINE_MUTEX(open_disc_mutex);\n\n#define LEGO_USB_TOWER_MINOR_BASE\t160\n\n\n/* Structure to hold all of our device specific stuff */\nstruct lego_usb_tower {\n\tstruct mutex\t\tlock;\t\t/* locks this structure */\n\tstruct usb_device*\tudev;\t\t/* save off the usb device pointer */\n\tunsigned char\t\tminor;\t\t/* the starting minor number for this device */\n\n\tint\t\t\topen_count;\t/* number of times this port has been opened */\n\n\tchar*\t\t\tread_buffer;\n\tsize_t\t\t\tread_buffer_length; /* this much came in */\n\tsize_t\t\t\tread_packet_length; /* this much will be returned on read */\n\tspinlock_t\t\tread_buffer_lock;\n\tint\t\t\tpacket_timeout_jiffies;\n\tunsigned long\t\tread_last_arrival;\n\n\twait_queue_head_t\tread_wait;\n\twait_queue_head_t\twrite_wait;\n\n\tchar*\t\t\tinterrupt_in_buffer;\n\tstruct usb_endpoint_descriptor* interrupt_in_endpoint;\n\tstruct urb*\t\tinterrupt_in_urb;\n\tint\t\t\tinterrupt_in_interval;\n\tint\t\t\tinterrupt_in_running;\n\tint\t\t\tinterrupt_in_done;\n\n\tchar*\t\t\tinterrupt_out_buffer;\n\tstruct usb_endpoint_descriptor* interrupt_out_endpoint;\n\tstruct urb*\t\tinterrupt_out_urb;\n\tint\t\t\tinterrupt_out_interval;\n\tint\t\t\tinterrupt_out_busy;\n\n};\n\n\n/* local function prototypes */\nstatic ssize_t tower_read\t(struct file *file, char __user *buffer, size_t count, loff_t *ppos);\nstatic ssize_t tower_write\t(struct file *file, const char __user *buffer, size_t count, loff_t *ppos);\nstatic inline void tower_delete (struct lego_usb_tower *dev);\nstatic int tower_open\t\t(struct inode *inode, struct file *file);\nstatic int tower_release\t(struct inode *inode, struct file *file);\nstatic unsigned int tower_poll\t(struct file *file, poll_table *wait);\nstatic loff_t tower_llseek\t(struct file *file, loff_t off, int whence);\n\nstatic void tower_abort_transfers (struct lego_usb_tower *dev);\nstatic void tower_check_for_read_packet (struct lego_usb_tower *dev);\nstatic void tower_interrupt_in_callback (struct urb *urb);\nstatic void tower_interrupt_out_callback (struct urb *urb);\n\nstatic int  tower_probe\t(struct usb_interface *interface, const struct usb_device_id *id);\nstatic void tower_disconnect\t(struct usb_interface *interface);\n\n\n/* file operations needed when we register this driver */\nstatic const struct file_operations tower_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read  =\ttower_read,\n\t.write =\ttower_write,\n\t.open =\t\ttower_open,\n\t.release =\ttower_release,\n\t.poll =\t\ttower_poll,\n\t.llseek =\ttower_llseek,\n};\n\nstatic char *legousbtower_devnode(struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\n/*\n * usb class driver info in order to get a minor number from the usb core,\n * and to have the device registered with the driver core\n */\nstatic struct usb_class_driver tower_class = {\n\t.name =\t\t\"legousbtower%d\",\n\t.devnode = \tlegousbtower_devnode,\n\t.fops =\t\t&tower_fops,\n\t.minor_base =\tLEGO_USB_TOWER_MINOR_BASE,\n};\n\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver tower_driver = {\n\t.name =\t\t\"legousbtower\",\n\t.probe =\ttower_probe,\n\t.disconnect =\ttower_disconnect,\n\t.id_table =\ttower_table,\n};\n\n\n/**\n *\tlego_usb_tower_debug_data\n */\nstatic inline void lego_usb_tower_debug_data(struct device *dev,\n\t\t\t\t\t     const char *function, int size,\n\t\t\t\t\t     const unsigned char *data)\n{\n\tdev_dbg(dev, \"%s - length = %d, data = %*ph\\n\",\n\t\tfunction, size, size, data);\n}\n\n\n/**\n *\ttower_delete\n */\nstatic inline void tower_delete (struct lego_usb_tower *dev)\n{\n\ttower_abort_transfers (dev);\n\n\t/* free data structures */\n\tusb_free_urb(dev->interrupt_in_urb);\n\tusb_free_urb(dev->interrupt_out_urb);\n\tkfree (dev->read_buffer);\n\tkfree (dev->interrupt_in_buffer);\n\tkfree (dev->interrupt_out_buffer);\n\tkfree (dev);\n}\n\n\n/**\n *\ttower_open\n */\nstatic int tower_open (struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev = NULL;\n\tint subminor;\n\tint retval = 0;\n\tstruct usb_interface *interface;\n\tstruct tower_reset_reply reset_reply;\n\tint result;\n\n\tnonseekable_open(inode, file);\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface (&tower_driver, subminor);\n\n\tif (!interface) {\n\t\tpr_err(\"error, can't find device for minor %d\\n\", subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&open_disc_mutex);\n\tdev = usb_get_intfdata(interface);\n\n\tif (!dev) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* lock this device */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t        retval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\n\t/* allow opening only once */\n\tif (dev->open_count) {\n\t\tmutex_unlock(&open_disc_mutex);\n\t\tretval = -EBUSY;\n\t\tgoto unlock_exit;\n\t}\n\tdev->open_count = 1;\n\tmutex_unlock(&open_disc_mutex);\n\n\t/* reset the tower */\n\tresult = usb_control_msg (dev->udev,\n\t\t\t\t  usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_RESET,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &reset_reply,\n\t\t\t\t  sizeof(reset_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"LEGO USB Tower reset control request failed\\n\");\n\t\tretval = result;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* initialize in direction */\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tusb_fill_int_urb (dev->interrupt_in_urb,\n\t\t\t  dev->udev,\n\t\t\t  usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t  dev->interrupt_in_buffer,\n\t\t\t  usb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t  tower_interrupt_in_callback,\n\t\t\t  dev,\n\t\t\t  dev->interrupt_in_interval);\n\n\tdev->interrupt_in_running = 1;\n\tdev->interrupt_in_done = 0;\n\tmb();\n\n\tretval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_in_urb %d\\n\", retval);\n\t\tdev->interrupt_in_running = 0;\n\t\tdev->open_count = 0;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* save device in the file's private structure */\n\tfile->private_data = dev;\n\nunlock_exit:\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n/**\n *\ttower_release\n */\nstatic int tower_release (struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\tif (dev == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit_nolock;\n\t}\n\n\tmutex_lock(&open_disc_mutex);\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t        retval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\tif (dev->open_count != 1) {\n\t\tdev_dbg(&dev->udev->dev, \"%s: device not opened exactly once\\n\",\n\t\t\t__func__);\n\t\tretval = -ENODEV;\n\t\tgoto unlock_exit;\n\t}\n\tif (dev->udev == NULL) {\n\t\t/* the device was unplugged before the file was released */\n\n\t\t/* unlock here as tower_delete frees dev */\n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete (dev);\n\t\tgoto exit;\n\t}\n\n\t/* wait until write transfer is finished */\n\tif (dev->interrupt_out_busy) {\n\t\twait_event_interruptible_timeout (dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);\n\t}\n\ttower_abort_transfers (dev);\n\tdev->open_count = 0;\n\nunlock_exit:\n\tmutex_unlock(&dev->lock);\n\nexit:\n\tmutex_unlock(&open_disc_mutex);\nexit_nolock:\n\treturn retval;\n}\n\n\n/**\n *\ttower_abort_transfers\n *      aborts transfers and frees associated data structures\n */\nstatic void tower_abort_transfers (struct lego_usb_tower *dev)\n{\n\tif (dev == NULL)\n\t\treturn;\n\n\t/* shutdown transfer */\n\tif (dev->interrupt_in_running) {\n\t\tdev->interrupt_in_running = 0;\n\t\tmb();\n\t\tif (dev->udev)\n\t\t\tusb_kill_urb (dev->interrupt_in_urb);\n\t}\n\tif (dev->interrupt_out_busy && dev->udev)\n\t\tusb_kill_urb(dev->interrupt_out_urb);\n}\n\n\n/**\n *\ttower_check_for_read_packet\n *\n *      To get correct semantics for signals and non-blocking I/O\n *      with packetizing we pretend not to see any data in the read buffer\n *      until it has been there unchanged for at least\n *      dev->packet_timeout_jiffies, or until the buffer is full.\n */\nstatic void tower_check_for_read_packet (struct lego_usb_tower *dev)\n{\n\tspin_lock_irq (&dev->read_buffer_lock);\n\tif (!packet_timeout\n\t    || time_after(jiffies, dev->read_last_arrival + dev->packet_timeout_jiffies)\n\t    || dev->read_buffer_length == read_buffer_size) {\n\t\tdev->read_packet_length = dev->read_buffer_length;\n\t}\n\tdev->interrupt_in_done = 0;\n\tspin_unlock_irq (&dev->read_buffer_lock);\n}\n\n\n/**\n *\ttower_poll\n */\nstatic unsigned int tower_poll (struct file *file, poll_table *wait)\n{\n\tstruct lego_usb_tower *dev;\n\tunsigned int mask = 0;\n\n\tdev = file->private_data;\n\n\tif (!dev->udev)\n\t\treturn POLLERR | POLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\ttower_check_for_read_packet(dev);\n\tif (dev->read_packet_length > 0) {\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tif (!dev->interrupt_out_busy) {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\n\treturn mask;\n}\n\n\n/**\n *\ttower_llseek\n */\nstatic loff_t tower_llseek (struct file *file, loff_t off, int whence)\n{\n\treturn -ESPIPE;\t\t/* unseekable */\n}\n\n\n/**\n *\ttower_read\n */\nstatic ssize_t tower_read (struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_read;\n\tint i;\n\tint retval = 0;\n\tunsigned long timeout = 0;\n\n\tdev = file->private_data;\n\n\t/* lock this object */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t/* verify that the device wasn't unplugged */\n\tif (dev->udev == NULL) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t/* verify that we actually have some data to read */\n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"read request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\tif (read_timeout) {\n\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\t}\n\n\t/* wait for data */\n\ttower_check_for_read_packet (dev);\n\twhile (dev->read_packet_length == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible_timeout(dev->read_wait, dev->interrupt_in_done, dev->packet_timeout_jiffies);\n\t\tif (retval < 0) {\n\t\t\tgoto unlock_exit;\n\t\t}\n\n\t\t/* reset read timeout during read or write activity */\n\t\tif (read_timeout\n\t\t    && (dev->read_buffer_length || dev->interrupt_out_busy)) {\n\t\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\t\t}\n\t\t/* check for read timeout */\n\t\tif (read_timeout && time_after (jiffies, timeout)) {\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\ttower_check_for_read_packet (dev);\n\t}\n\n\t/* copy the data from read_buffer into userspace */\n\tbytes_to_read = min(count, dev->read_packet_length);\n\n\tif (copy_to_user (buffer, dev->read_buffer, bytes_to_read)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\tspin_lock_irq (&dev->read_buffer_lock);\n\tdev->read_buffer_length -= bytes_to_read;\n\tdev->read_packet_length -= bytes_to_read;\n\tfor (i=0; i<dev->read_buffer_length; i++) {\n\t\tdev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];\n\t}\n\tspin_unlock_irq (&dev->read_buffer_lock);\n\n\tretval = bytes_to_read;\n\nunlock_exit:\n\t/* unlock the device */\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n/**\n *\ttower_write\n */\nstatic ssize_t tower_write (struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_write;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\t/* lock this object */\n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t/* verify that the device wasn't unplugged */\n\tif (dev->udev == NULL) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t/* verify that we actually have some data to write */\n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"write request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\t/* wait until previous transfer is finished */\n\twhile (dev->interrupt_out_busy) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible (dev->write_wait, !dev->interrupt_out_busy);\n\t\tif (retval) {\n\t\t\tgoto unlock_exit;\n\t\t}\n\t}\n\n\t/* write the data into interrupt_out_buffer from userspace */\n\tbytes_to_write = min_t(int, count, write_buffer_size);\n\tdev_dbg(&dev->udev->dev, \"%s: count = %Zd, bytes_to_write = %Zd\\n\",\n\t\t__func__, count, bytes_to_write);\n\n\tif (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* send off the urb */\n\tusb_fill_int_urb(dev->interrupt_out_urb,\n\t\t\t dev->udev,\n\t\t\t usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_out_buffer,\n\t\t\t bytes_to_write,\n\t\t\t tower_interrupt_out_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_out_interval);\n\n\tdev->interrupt_out_busy = 1;\n\twmb();\n\n\tretval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev->interrupt_out_busy = 0;\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_out_urb %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\tretval = bytes_to_write;\n\nunlock_exit:\n\t/* unlock the device */\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n/**\n *\ttower_interrupt_in_callback\n */\nstatic void tower_interrupt_in_callback (struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\tint retval;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\tif (status) {\n\t\tif (status == -ENOENT ||\n\t\t    status == -ECONNRESET ||\n\t\t    status == -ESHUTDOWN) {\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s: nonzero status received: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tgoto resubmit; /* maybe we can recover */\n\t\t}\n\t}\n\n\tif (urb->actual_length > 0) {\n\t\tspin_lock (&dev->read_buffer_lock);\n\t\tif (dev->read_buffer_length + urb->actual_length < read_buffer_size) {\n\t\t\tmemcpy (dev->read_buffer + dev->read_buffer_length,\n\t\t\t\tdev->interrupt_in_buffer,\n\t\t\t\turb->actual_length);\n\t\t\tdev->read_buffer_length += urb->actual_length;\n\t\t\tdev->read_last_arrival = jiffies;\n\t\t\tdev_dbg(&dev->udev->dev, \"%s: received %d bytes\\n\",\n\t\t\t\t__func__, urb->actual_length);\n\t\t} else {\n\t\t\tpr_warn(\"read_buffer overflow, %d bytes dropped\\n\",\n\t\t\t\turb->actual_length);\n\t\t}\n\t\tspin_unlock (&dev->read_buffer_lock);\n\t}\n\nresubmit:\n\t/* resubmit if we're still running */\n\tif (dev->interrupt_in_running && dev->udev) {\n\t\tretval = usb_submit_urb (dev->interrupt_in_urb, GFP_ATOMIC);\n\t\tif (retval)\n\t\t\tdev_err(&dev->udev->dev,\n\t\t\t\t\"%s: usb_submit_urb failed (%d)\\n\",\n\t\t\t\t__func__, retval);\n\t}\n\nexit:\n\tdev->interrupt_in_done = 1;\n\twake_up_interruptible (&dev->read_wait);\n}\n\n\n/**\n *\ttower_interrupt_out_callback\n */\nstatic void tower_interrupt_out_callback (struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\t/* sync/async unlink faults aren't errors */\n\tif (status && !(status == -ENOENT ||\n\t\t\tstatus == -ECONNRESET ||\n\t\t\tstatus == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"%s: nonzero write bulk status received: %d\\n\", __func__,\n\t\t\tstatus);\n\t}\n\n\tdev->interrupt_out_busy = 0;\n\twake_up_interruptible(&dev->write_wait);\n}\n\n\n/**\n *\ttower_probe\n *\n *\tCalled by the usb core when a new device is connected that it thinks\n *\tthis driver might be interested in.\n */\nstatic int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor* endpoint;\n\tstruct tower_get_version_reply get_version_reply;\n\tint i;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t/* allocate memory for our device state and initialize it */\n\n\tdev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (usb_endpoint_dir_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt in endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt out endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n\tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n\n\t/* get the firmware version and log it */\n\tresult = usb_control_msg (udev,\n\t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &get_version_reply,\n\t\t\t\t  sizeof(get_version_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\t\t \"build %d\\n\", get_version_reply.major,\n\t\t get_version_reply.minor,\n\t\t le16_to_cpu(get_version_reply.build_no));\n\n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata (interface, dev);\n\n\tretval = usb_register_dev (interface, &tower_class);\n\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata (interface, NULL);\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n\nexit:\n\treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n\n\n/**\n *\ttower_disconnect\n *\n *\tCalled by the usb core when the device is removed from the system.\n */\nstatic void tower_disconnect (struct usb_interface *interface)\n{\n\tstruct lego_usb_tower *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata (interface);\n\tmutex_lock(&open_disc_mutex);\n\tusb_set_intfdata (interface, NULL);\n\n\tminor = dev->minor;\n\n\t/* give back our minor */\n\tusb_deregister_dev (interface, &tower_class);\n\n\tmutex_lock(&dev->lock);\n\tmutex_unlock(&open_disc_mutex);\n\n\t/* if the device is not opened, then we clean up right now */\n\tif (!dev->open_count) {\n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete (dev);\n\t} else {\n\t\tdev->udev = NULL;\n\t\t/* wake up pollers */\n\t\twake_up_interruptible_all(&dev->read_wait);\n\t\twake_up_interruptible_all(&dev->write_wait);\n\t\tmutex_unlock(&dev->lock);\n\t}\n\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now disconnected\\n\",\n\t\t (minor - LEGO_USB_TOWER_MINOR_BASE));\n}\n\nmodule_usb_driver(tower_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n#ifdef MODULE_LICENSE\nMODULE_LICENSE(\"GPL\");\n#endif\n"], "filenames": ["drivers/usb/misc/legousbtower.c"], "buggy_code_start_loc": [889], "buggy_code_end_loc": [926], "fixing_code_start_loc": [888], "fixing_code_end_loc": [926], "type": "CWE-476", "message": "The tower_probe function in drivers/usb/misc/legousbtower.c in the Linux kernel before 4.8.1 allows local users (who are physically proximate for inserting a crafted USB device) to gain privileges by leveraging a write-what-where condition that occurs after a race condition and a NULL pointer dereference.", "other": {"cve": {"id": "CVE-2017-15102", "sourceIdentifier": "secalert@redhat.com", "published": "2017-11-15T21:29:00.250", "lastModified": "2019-05-08T18:14:44.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The tower_probe function in drivers/usb/misc/legousbtower.c in the Linux kernel before 4.8.1 allows local users (who are physically proximate for inserting a crafted USB device) to gain privileges by leveraging a write-what-where condition that occurs after a race condition and a NULL pointer dereference."}, {"lang": "es", "value": "La funci\u00f3n tower_probe en drivers/usb/misc/legousbtower.c en el kernel de Linux en versiones anteriores a la 4.8.1 permite que usuarios locales (que est\u00e9n tan cerca f\u00edsicamente como para insertar un dispositivo USB manipulado) obtengan privilegios aprovechando una condici\u00f3n de write-what-where que ocurre tras una condici\u00f3n de carrera y una desreferencia de puntero NULL"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.4, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8.1", "matchCriteriaId": "52C1E6B2-1581-4CD7-B5FB-8DF3438E93C8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2fae9e5a7babada041e2e161699ade2447a01989", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://seclists.org/oss-sec/2017/q4/238", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/101790", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1505905", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3583-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3583-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989"}}