{"buggy_code": ["/*\n * card-setcos.c: Support for PKI cards by Setec\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005  Antti Tapaninen <aet@cc.hut.fi>\n * Copyright (C) 2005  Zetes\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\n#define _FINEID_BROKEN_SELECT_FLAG 1\n\nstatic const struct sc_atr_table setcos_atrs[] = {\n\t/* some Nokia branded SC */\n\t{ \"3B:1F:11:00:67:80:42:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_GENERIC, 0, NULL },\n\t/* RSA SecurID 3100 */\n\t{ \"3B:9F:94:40:1E:00:67:16:43:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_PKI, 0, NULL },\n\n\t/* FINEID 1016 (SetCOS 4.3.1B3/PKCS#15, VRK) */\n\t{ \"3b:9f:94:40:1e:00:67:00:43:46:49:53:45:10:52:66:ff:81:90:00\", \"ff:ff:ff:ff:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID, SC_CARD_FLAG_RNG, NULL },\n\t/* FINEID 2032 (EIDApplet/7816-15, VRK test) */\n\t{ \"3b:6b:00:ff:80:62:00:a2:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2132 (EIDApplet/7816-15, 3rdparty test) */\n\t{ \"3b:64:00:ff:80:62:00:a2\", \"ff:ff:00:ff:ff:ff:00:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2064 (EIDApplet/7816-15, VRK) */\n\t{ \"3b:7b:00:00:00:80:62:00:51:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:ff:f0:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2164 (EIDApplet/7816-15, 3rdparty) */\n\t{ \"3b:64:00:00:80:62:00:51\", \"ff:ff:ff:ff:ff:ff:f0:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2264 (EIDApplet/7816-15, OPK/EMV/AVANT) */\n\t{ \"3b:6e:00:00:00:62:00:00:57:41:56:41:4e:54:10:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:7b:94:00:00:80:62:11:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID cards 1.3.2011 with Samsung chips (round connector) that supports 2048 bit keys. */\n\t{ \"3b:7b:94:00:00:80:62:12:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2_2048, 0, NULL },\n\t/* FINEID card for organisations, chip unknown. */\n\t{ \"3b:7b:18:00:00:80:62:01:54:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, _FINEID_BROKEN_SELECT_FLAG, NULL },\n\t/* Swedish NIDEL card */\n\t{ \"3b:9f:94:80:1f:c3:00:68:10:44:05:01:46:49:53:45:31:c8:07:90:00:18\", NULL, NULL, SC_CARD_TYPE_SETCOS_NIDEL, 0, NULL },\n\t/* Setcos 4.4.1 */\n\t{ \"3b:9f:94:80:1f:c3:00:68:11:44:05:01:46:49:53:45:31:c8:00:00:00:00\", \"ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:00:00:00:00\", NULL, SC_CARD_TYPE_SETCOS_44, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\n#define SETCOS_IS_EID_APPLET(card) ((card)->type == SC_CARD_TYPE_SETCOS_EID_V2_0 || (card)->type == SC_CARD_TYPE_SETCOS_EID_V2_1)\n\n/* Setcos 4.4 Life Cycle Status Integer  */\n#define SETEC_LCSI_CREATE      0x01\n#define SETEC_LCSI_INIT        0x03\n#define SETEC_LCSI_ACTIVATED   0x07\n#define SETEC_LCSI_DEACTIVATE  0x06\n#define SETEC_LCSI_TEMINATE    0x0F /* MF only  */\n\nstatic struct sc_card_operations setcos_ops;\nstatic struct sc_card_driver setcos_drv = {\n\t\"Setec cards\",\n\t\"setcos\",\n\t&setcos_ops,\n\tNULL, 0, NULL\n};\n\nstatic int match_hist_bytes(sc_card_t *card, const char *str, size_t len)\n{\n\tconst char *src = (const char *) card->reader->atr_info.hist_bytes;\n\tsize_t srclen = card->reader->atr_info.hist_bytes_len;\n\tsize_t offset = 0;\n\n\tif (len == 0)\n\t\tlen = strlen(str);\n\tif (srclen < len)\n\t\treturn 0;\n\twhile (srclen - offset > len) {\n\t\tif (memcmp(src + offset, str, len) == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\toffset++;\n\t}\n\treturn 0;\n}\n\nstatic int setcos_match_card(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tu8 buf[6];\n\tint i;\n\n\ti = _sc_match_atr(card, setcos_atrs, &card->type);\n\tif (i < 0) {\n\t\t/* Unknown card, but has the FinEID application for sure */\n\t\tif (match_hist_bytes(card, \"FinEID\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_FINEID_V2_2048;\n\t\t\treturn 1;\n\t\t}\n\t\tif (match_hist_bytes(card, \"FISE\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t\t\treturn 1;\n\t\t}\n\t\t/* Check if it's a EID2.x applet by reading the version info */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xCA, 0xDF, 0x30);\n\t\tapdu.cla = 0x00;\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = 5;\n\t\tapdu.le = 5;\n\t\ti = sc_transmit_apdu(card, &apdu);\n\t\tif (i == 0 && apdu.sw1 == 0x90 && apdu.sw2 == 0x00 && apdu.resplen == 5) {\n\t\t\tif (memcmp(buf, \"v2.0\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_0;\n\t\t\telse if (memcmp(buf, \"v2.1\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_1;\n\t\t\telse {\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tsc_log(card->ctx,  \"SetCOS EID applet %s is not supported\", (char *) buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tcard->flags = setcos_atrs[i].flags;\n\treturn 1;\n}\n\nstatic int select_pkcs15_app(sc_card_t * card)\n{\n\tsc_path_t app;\n\tint r;\n\n\t/* Regular PKCS#15 AID */\n\tsc_format_path(\"A000000063504B43532D3135\", &app);\n\tapp.type = SC_PATH_TYPE_DF_NAME;\n\tr = sc_select_file(card, &app, NULL);\n\treturn r;\n}\n\nstatic int setcos_init(sc_card_t *card)\n{\n\tcard->name = \"SetCOS\";\n\n\t/* Handle unknown or forced cards */\n\tif (card->type < 0) {\n\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t}\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcard->cla = 0x00;\n\t\tselect_pkcs15_app(card);\n\t\tif (card->flags & SC_CARD_FLAG_RNG)\n\t\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\tcard->cla = 0x00;\n\t\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t\tbreak;\n\tdefault:\n\t\t/* XXX: Get SetCOS version */\n\t\tcard->cla = 0x80;\t/* SetCOS 4.3.x */\n\t\t/* State that we have an RNG */\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\t}\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_PKI:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\t{\n\t\t\tunsigned long flags;\n\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t{\n\t\t\tunsigned long flags;\n\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\t\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\n\t\t\t_sc_card_add_rsa_alg(card, 512, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 768, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic int setcos_construct_fci_44(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n\tconst u8 *pin_key_info;\n\tint len;\n\n\t/* Command */\n\t*p++ = 0x6F;\n\tp++;\n\n\t/* Size (set to 0 for keys/PINs on a Java card) */\n\tif (SETCOS_IS_EID_APPLET(card) &&\n\t    (file->type == SC_FILE_TYPE_INTERNAL_EF || \n\t     (file->type == SC_FILE_TYPE_WORKING_EF && file->ef_structure == 0x22)))\n\t     \tbuf[0] = buf[1] = 0x00;\n\telse {\n\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\tbuf[1] = file->size & 0xFF;\n\t}\n\tsc_asn1_put_tag(0x81, buf, 2, p, *outlen - (p - out), &p);\n\n\t/* Type */\n\tif (file->type_attr_len) {\n\t\tmemcpy(buf, file->type_attr, file->type_attr_len);\n\t\tsc_asn1_put_tag(0x82, buf, file->type_attr_len, p, *outlen - (p - out), &p);\n\t} else {\n\t\tu8\tbLen = 1;\n\n\t\tbuf[0] = file->shareable ? 0x40 : 0;\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\t\t\t\t/* RSA keyfile */\n\t\t\tbuf[0] = 0x11;\t\t\t\t\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\t\t\tif (file->ef_structure == 0x22) {\t\t/* pin-file */\n\t\t\t\tbuf[0] = 0x0A;\t\t\t\t/* EF linear fixed EF for ISF keys */\n\t\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\t\tbLen = 1;\n\t\t\t\telse {\n\t\t\t\t\t/* Setcos V4.4 */\n\t\t\t\t\tbLen = 5;\n\t\t\t\t\tbuf[1] = 0x41;\t\t\t\t/* fixed */\n\t\t\t\t\tbuf[2] = file->record_length >> 8;\t/* 2 byte record length  */\n\t\t\t\t\tbuf[3] = file->record_length & 0xFF;\n\t\t\t\t\tbuf[4] = file->size / file->record_length; /* record count */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf[0] |= file->ef_structure & 7;\t/* set file-type, only for EF, not for DF objects  */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\t\n\t\t\tbuf[0] = 0x38;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tsc_asn1_put_tag(0x82, buf, bLen, p, *outlen - (p - out), &p);\n\t}\n\n\t/* File ID */\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, *outlen - (p - out), &p);\n\n\t/* DF name */\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (file->name[0] != 0)\n\t\t\tsc_asn1_put_tag(0x84, (u8 *) file->name, file->namelen, p, *outlen - (p - out), &p);\n\t\telse { /* Name required -> take the FID if not specified */\n\t\t\tbuf[0] = (file->id >> 8) & 0xFF;\n\t\t\tbuf[1] = file->id & 0xFF;\n\t\t\tsc_asn1_put_tag(0x84, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\n\t/* Security Attributes */\n\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\tsc_asn1_put_tag(0x86, buf, file->sec_attr_len, p, *outlen - (p - out), &p);\n\n\t/* Life cycle status */\n\tif (file->prop_attr_len) {\n\t\tmemcpy(buf, file->prop_attr, file->prop_attr_len);\n\t\tsc_asn1_put_tag(0x8A, buf, file->prop_attr_len, p, *outlen - (p - out), &p);\n\t}\n\n\t/* PIN definitions */\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (card->type == SC_CARD_TYPE_SETCOS_EID_V2_1) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\";\n\t\t\tlen = 6;\n\t\t}\n\t\telse if (card->type == SC_CARD_TYPE_SETCOS_EID_V2_0) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\"; /* Max 2 PINs supported */\n\t\t\tlen = 4;\n\t\t}\n\t\telse {\n\t\t\t/* Pin/key info: define 4 pins, no keys */\n\t\t\tif(file->path.len == 2)\n\t\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\\xC2\\x00\";\t/* root-MF: use local pin-file */\n\t\t\telse\n\t\t\t\tpin_key_info = (const u8 *)\"\\xC1\\x04\\x01\\x02\\x03\\x04\\xC2\\x00\";\t/* sub-DF: use parent pin-file in root-MF */\n\t\t\tlen = 8;\n\t\t}\n\t\tsc_asn1_put_tag(0xA5, pin_key_info, len, p, *outlen - (p - out), &p);\n\t}\n\n\t/* Length */\n\tout[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\nstatic int setcos_construct_fci(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || \n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_construct_fci_44(card, file, out, outlen);\n\telse\n\t\treturn iso_ops->construct_fci(card, file, out, outlen);\n}\n\nstatic u8 acl_to_byte(const sc_acl_entry_t *e)\n{\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\treturn 0x00;\n\tcase SC_AC_CHV:\n\t\tswitch (e->key_ref) {\n\t\tcase 1:\n\t\t\treturn 0x01;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treturn 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0x00;\n\t\t}\n\t\tbreak;\n\tcase SC_AC_TERM:\n\t\treturn 0x04;\n\tcase SC_AC_NEVER:\n\t\treturn 0x0F;\n\t}\n\treturn 0x00;\n}\n\nstatic unsigned int acl_to_byte_44(const struct sc_acl_entry *e, u8* p_bNumber)\n{\n\t/* Handle special fixed values */\n\tif (e == (sc_acl_entry_t *) 1)           /* SC_AC_NEVER */\n\t\treturn SC_AC_NEVER;\n\telse if ((e == (sc_acl_entry_t *) 2) ||  /* SC_AC_NONE */\n\t         (e == (sc_acl_entry_t *) 3) ||  /* SC_AC_UNKNOWN */\n\t         (e == (sc_acl_entry_t *) 0))\n\t\treturn SC_AC_NONE;\n\n\t/* Handle standard values */\n\t*p_bNumber = e->key_ref;\n\treturn(e->method);\n}\n\n/* If pin is present in the pins list, return it's index.\n * If it's not yet present, add it to the list and return the index. */\nstatic int setcos_pin_index_44(int *pins, int len, int pin)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (pins[i] == pin)\n\t\t\treturn i;\n\t\tif (pins[i] == -1) {\n\t\t\tpins[i] = pin;\n\t\t\treturn i;\n\t\t}\n\t}\n\tassert(i != len); /* Too much PINs, shouldn't happen */\n\treturn 0;\n}\n\n/* The ACs are always for the SETEC_LCSI_ACTIVATED state, even if\n * we have to create the file in the SC_FILE_STATUS_INITIALISATION state. */\nstatic int setcos_create_file_44(sc_card_t *card, sc_file_t *file)\n{\n\tconst u8 bFileStatus = file->status == SC_FILE_STATUS_CREATION ?\n\t\tSETEC_LCSI_CREATE : SETEC_LCSI_ACTIVATED;\n\tu8 bCommands_always = 0;\n\tint pins[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\tu8 bCommands_pin[sizeof(pins)/sizeof(pins[0])]; /* both 7 entries big */\n\tu8 bCommands_key = 0;\n\tu8 bNumber = 0;\n\tu8 bKeyNumber = 0;\n\tunsigned int bMethod = 0;\n\n\t/* -1 means RFU */\n\tconst int df_idx[8] = {  /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {  /* note: SC_AC_OP_SELECT to be ignored, actually RFU */\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = {  /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\t/* Set file creation status  */\n\tsc_file_set_prop_attr(file, &bFileStatus, 1);\n\n\t/* Build ACI from local structure = get AC for each operation group */\n\tif (file->sec_attr_len == 0) {\n\t\tconst int* p_idx;\n\t\tint\t       i;\n\t\tint\t       len = 0;\n\t\tu8         bBuf[64];\n\n\t\t/* Get specific operation groups for specified file-type */\n\t\tswitch (file->type){\n\t\tcase SC_FILE_TYPE_DF:           /* DF */\n\t\t\tp_idx = df_idx;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:  /* EF for RSA keys */\n\t\t\tp_idx = efi_idx;\n\t\t\tbreak;\n\t\tdefault:                        /* SC_FILE_TYPE_WORKING_EF */\n\t\t\tp_idx = ef_idx;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get enabled commands + required Keys/Pins  */\n\t\tmemset(bCommands_pin, 0, sizeof(bCommands_pin));\n\t\tfor (i = 7; i >= 0; i--) {  /* for each AC Setcos operation */\n\t\t\tbCommands_always <<= 1;\n\t\t\tbCommands_key <<= 1;\n\n\t\t\tif (p_idx[i] == -1)  /* -1 means that bit is RFU -> set to 0 */\n\t\t\t\tcontinue;\n\n\t\t\tbMethod = acl_to_byte_44(file->acl[ p_idx[i] ], &bNumber);\n\t\t\t/* Convert to OpenSc-index, convert to pin/key number */\n\t\t\tswitch(bMethod){\n\t\t\tcase SC_AC_NONE:\t\t\t/* always allowed */\n\t\t\t\tbCommands_always |= 1;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_CHV:\t\t\t\t/* pin */\n\t\t\t\tif ((bNumber & 0x7F) == 0 || (bNumber & 0x7F) > 7) {\n\t\t\t\t\tsc_log(card->ctx,  \"SetCOS 4.4 PIN refs can only be 1..7\\n\");\n\t\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t\t}\n\t\t\t\tbCommands_pin[setcos_pin_index_44(pins, sizeof(pins), (int) bNumber)] |= 1 << i;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_TERM:\t\t\t/* key */\n\t\t\t\tbKeyNumber = bNumber;\t/* There should be only 1 key */\n\t\t\t\tbCommands_key |= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Add the commands that are always allowed */\n\t\tif (bCommands_always) {\n\t\t\tbBuf[len++] = 1;\n\t\t\tbBuf[len++] = bCommands_always;\n\t\t}\n\t\t/* Add commands that require pins */\n\t\tfor (i = 0; i < (int)sizeof(bCommands_pin) && pins[i] != -1; i++) {\n\t\t\tbBuf[len++] = 2;\n\t\t\tbBuf[len++] = bCommands_pin[i];\n\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\tbBuf[len++] = pins[i];  /* pin ref */\n\t\t\telse\n\t\t\t\tbBuf[len++] = pins[i] & 0x07;  /* pin ref */\n\t\t}\n\t\t/* Add commands that require the key */\n\t\tif (bCommands_key) {\n\t\t\tbBuf[len++] = 2 | 0x20;\t\t\t/* indicate keyNumber present */\n\t\t\tbBuf[len++] = bCommands_key;\n\t\t\tbBuf[len++] = bKeyNumber;\n\t\t}\n\t\t/* RSA signing/decryption requires AC adaptive coding,  can't be put\n\t\t   in AC simple coding. Only implemented for pins, not for a key. */\n\t\tif ( (file->type == SC_FILE_TYPE_INTERNAL_EF) &&\n\t\t     (acl_to_byte_44(file->acl[SC_AC_OP_CRYPTO], &bNumber) == SC_AC_CHV) ) {\n\t\t\tbBuf[len++] = 0x83;\n\t\t\tbBuf[len++] = 0x01;\n\t\t\tbBuf[len++] = 0x2A;  /* INS byte for the sign/decrypt APDU */\n\t\t\tbBuf[len++] = bNumber & 0x07;  /* pin ref */\n\t\t}\n\n\t\tsc_file_set_sec_attr(file, bBuf, len);\n\t}\n\n\treturn iso_ops->create_file(card, file);\n}\n\nstatic int setcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_create_file_44(card, file);\n\n\tif (file->prop_attr_len == 0)\n\t\tsc_file_set_prop_attr(file, (const u8 *) \"\\x03\\x00\\x00\", 3);\n\tif (file->sec_attr_len == 0) {\n\t\tint idx[6], i;\n\t\tu8 buf[6];\n\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tconst int df_idx[6] = {\n\t\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = df_idx[i];\n\t\t} else {\n\t\t\tconst int ef_idx[6] = {\n\t\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = ef_idx[i];\n\t\t}\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\t\t\tentry = sc_file_get_acl_entry(file, idx[i]);\n\t\t\tbuf[i] = acl_to_byte(entry);\n\t\t}\n\n\t\tsc_file_set_sec_attr(file, buf, 6);\n\t}\n\n\treturn iso_ops->create_file(card, file);\n}\n\nstatic int setcos_set_security_env2(sc_card_t *card,\n\t\t\t\t    const sc_security_env_t *env, int se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r, locked = 0;\n\n\tassert(card != NULL && env != NULL);\n\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC) {\n\t\t\tsc_log(card->ctx,  \"symmetric keyref not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tif (se_num > 0) {\n\t\t\tsc_log(card->ctx,  \"restore security environment not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation) {\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\t/* Should be 0x81 */\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\t/* Should be 0x41 */\n\t\tapdu.p1 = ((card->type == SC_CARD_TYPE_SETCOS_FINEID_V2) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_44) ||\n\t\t\t   (card->type == SC_CARD_TYPE_SETCOS_NIDEL) || \n\t\t\t   SETCOS_IS_EID_APPLET(card)) ? 0x41 : 0x81;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT) {\n\t\t*p++ = 0x81;\n\t\t*p++ = env->file_ref.len;\n\t\tmemcpy(p, env->file_ref.value, env->file_ref.len);\n\t\tp += env->file_ref.len;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT &&\n\t    !(card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t      card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t\t\t*p++ = 0x83;\n\t\telse\n\t\t\t*p++ = 0x84;\n\t\t*p++ = env->key_ref_len;\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\n\t\tp += env->key_ref_len;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (se_num > 0) {\n\t\tr = sc_lock(card);\n\t\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\t\tlocked = 1;\n\t}\n\tif (apdu.datalen != 0) {\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (se_num <= 0)\n\t\treturn 0;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0xF2, se_num);\n\tr = sc_transmit_apdu(card, &apdu);\n\tsc_unlock(card);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\nerr:\n\tif (locked)\n\t\tsc_unlock(card);\n\treturn r;\n}\n\nstatic int setcos_set_security_env(sc_card_t *card,\n\t\t\t\t   const sc_security_env_t *env, int se_num)\n{\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT) {\n\t\tsc_security_env_t tmp;\n\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\t\tif (tmp.algorithm != SC_ALGORITHM_RSA) {\n\t\t\tsc_log(card->ctx,  \"Only RSA algorithm supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tswitch (card->type) {\n\t\tcase SC_CARD_TYPE_SETCOS_PKI:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcase SC_CARD_TYPE_SETCOS_44:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx,  \"Card does not support RSA.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\ttmp.algorithm_ref = 0x00;\n\t\t/* potential FIXME: return an error, if an unsupported\n\t\t * pad or hash was requested, although this shouldn't happen.\n\t\t */\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\ttmp.algorithm_ref = 0x02;\n\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\ttmp.algorithm_ref |= 0x10;\n\t\treturn setcos_set_security_env2(card, &tmp, se_num);\n\t}\n\treturn setcos_set_security_env2(card, env, se_num);\n}\n\nstatic void add_acl_entry(sc_file_t *file, int op, u8 byte)\n{\n\tunsigned int method, key_ref = SC_AC_KEY_REF_NONE;\n\n\tswitch (byte >> 4) {\n\tcase 0:\n\t\tmethod = SC_AC_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = 1;\n\t\tbreak;\n\tcase 2:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = 2;\n\t\tbreak;\n\tcase 4:\n\t\tmethod = SC_AC_TERM;\n\t\tbreak;\n\tcase 15:\n\t\tmethod = SC_AC_NEVER;\n\t\tbreak;\n\tdefault:\n\t\tmethod = SC_AC_UNKNOWN;\n\t\tbreak;\n\t}\n\tsc_file_add_acl_entry(file, op, method, key_ref);\n}\n\nstatic void parse_sec_attr(sc_file_t *file, const u8 * buf, size_t len)\n{\n\tint i;\n\tint idx[6];\n\n\tif (len < 6)\n\t\treturn;\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tconst int df_idx[6] = {\n\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\tSC_AC_OP_INVALIDATE\n\t\t};\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tidx[i] = df_idx[i];\n\t} else {\n\t\tconst int ef_idx[6] = {\n\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\tSC_AC_OP_INVALIDATE\n\t\t};\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tidx[i] = ef_idx[i];\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\tadd_acl_entry(file, idx[i], buf[i]);\n}\n\nstatic void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\t/* OpenSc Operation values for each command operation-type */\n\tconst int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\n\t/* Check all sub-AC definitions within the total AC */\n\twhile (len > 1) {\t\t\t\t/* minimum length = 2 */\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\n\t\tiMethod = SC_AC_NONE;\t\t/* default no authentication required */\n\n\t\tif (buf[iOffset] & 0X80) { /* AC in adaptive coding */\n\t\t\t/* Evaluates only the command-byte, not the optional P1/P2/Option bytes */\n\t\t\tsize_t\tiParmLen = 1;\t\t\t/* command-byte is always present */\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */\n\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\n\t\t\t/* Get KeyNumber if available */\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\t\t\t}\n\n\t\t\t/* Get PinNumber if available */\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */\n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Convert SETCOS command to OpenSC command group */\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t/* crypto operation */\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t/* key-generation operation */\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { /* AC in simple coding */\n\t\t\t   /* Initial AC is treated as an operational AC */\n\n\t\t\t/* Get specific Cmd groups for specified file-type */\n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            /* DF */\n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\n\t\t\t\tiPinCount--;\t\t\t\t/* one byte used for keyReference  */\n\t\t\t}\n\n\t\t\t/* Pin present ? */\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t/* pin ref */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Add AC for each command-operationType into OpenSc structure */\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Current field treated, get next AC sub-field */\n\t\tiOffset += iACLen +1;\t\t/* AC + PTL-byte */\n\t\tlen     -= iACLen +1;\n\t}\n}\n\nstatic int setcos_select_file(sc_card_t *card,\n\t\t\t      const sc_path_t *in_path, sc_file_t **file)\n{\n\tint r;\n\n\tr = iso_ops->select_file(card, in_path, file);\n\t/* Certain FINeID cards for organisations return 6A88 instead of 6A82 for missing files */\n\tif (card->flags & _FINEID_BROKEN_SELECT_FLAG && r == SC_ERROR_DATA_OBJECT_NOT_FOUND)\n\t\treturn SC_ERROR_FILE_NOT_FOUND;\n\tif (r)\n\t\treturn r;\n\tif (file != NULL) {\n\t\tif (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t\t    SETCOS_IS_EID_APPLET(card))\n\t\t\tparse_sec_attr_44(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\t\telse\n\t\t\tparse_sec_attr(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\t}\n\treturn 0;\n}\n\nstatic int setcos_list_files(sc_card_t *card, u8 * buf, size_t buflen)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, 0, 0);\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || \n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card))\n\t\tapdu.cla = 0x80;\n\tapdu.resp = buf;\n\tapdu.resplen = buflen;\n\tapdu.le = buflen > 256 ? 256 : buflen;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 && apdu.sw1 == 0x6A && apdu.sw2 == 0x82)\n\t\treturn 0; /* no files found */\n\tif (apdu.resplen == 0)\n\t\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\treturn apdu.resplen;\n}\n\nstatic int setcos_process_fci(sc_card_t *card, sc_file_t *file,\n\t\t       const u8 *buf, size_t buflen)\n{\n\tint r = iso_ops->process_fci(card, file, buf, buflen);\n\n\t/* SetCOS 4.4: RSA key file is an internal EF but it's\n\t * file descriptor doesn't seem to follow ISO7816. */\n\tif (r >= 0 && (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t               SETCOS_IS_EID_APPLET(card))) {\n\t\tconst u8 *tag;\n\t\tsize_t taglen = 1;\n\t\ttag = (u8 *) sc_asn1_find_tag(card->ctx, buf, buflen, 0x82, &taglen);\n\t\tif (tag != NULL && taglen == 1 && *tag == 0x11)\n\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t}\n\n\treturn r;\n}\n\n/* Write internal data, e.g. add default pin-records to pin-file */\nstatic int setcos_putdata(struct sc_card *card, struct sc_cardctl_setcos_data_obj* data_obj)\n{\n\tint\t\t\t\tr;\n\tstruct sc_apdu\t\t\tapdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_3_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xDA;\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = data_obj->DataLen;\n\tapdu.datalen = data_obj->DataLen;\n\tapdu.data    = data_obj->Data;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"PUT_DATA returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Read internal data, e.g. get RSA public key */\nstatic int setcos_getdata(struct sc_card *card, struct sc_cardctl_setcos_data_obj* data_obj)\n{\n\tint\t\t\t\tr;\n\tstruct sc_apdu\t\t\tapdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_2_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xCA;\t\t\t/* GET DATA */\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = 0;\n\tapdu.datalen = 0;\n\tapdu.data    = data_obj->Data;\n\n\tapdu.le      = 256;\n\tapdu.resp    = data_obj->Data;\n\tapdu.resplen = data_obj->DataLen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"GET_DATA returned error\");\n\n\tif (apdu.resplen > data_obj->DataLen)\n\t\tr = SC_ERROR_WRONG_LENGTH;\n\telse\n\t\tdata_obj->DataLen = apdu.resplen;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Generate or store a key */\nstatic int setcos_generate_store_key(sc_card_t *card,\n\tstruct sc_cardctl_setcos_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr, len;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Setup key-generation parameters */\n\tlen = 0;\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t\tsbuf[len++] = 0x92;\t/* algo ID: RSA CRT */\n\telse\n\t\tsbuf[len++] = 0x9A;\t/* algo ID: EXTERNALLY GENERATED RSA CRT */\n\tsbuf[len++] = 0x00;\t\n\tsbuf[len++] = data->mod_len / 256;\t/* 2 bytes for modulus bitlength */\n\tsbuf[len++] = data->mod_len % 256;\n\n\tsbuf[len++] = data->pubexp_len / 256;   /* 2 bytes for pubexp bitlength */\n\tsbuf[len++] = data->pubexp_len % 256;\n\tmemcpy(sbuf + len, data->pubexp, (data->pubexp_len + 7) / 8);\n\tlen += (data->pubexp_len + 7) / 8;\n\n\tif (data->op_type == OP_TYPE_STORE) {\n\t\tsbuf[len++] = data->primep_len / 256;\n\t\tsbuf[len++] = data->primep_len % 256;\n\t\tmemcpy(sbuf + len, data->primep, (data->primep_len + 7) / 8);\n\t\tlen += (data->primep_len + 7) / 8;\n\t\tsbuf[len++] = data->primeq_len / 256;\n\t\tsbuf[len++] = data->primeq_len % 256;\n\t\tmemcpy(sbuf + len, data->primeq, (data->primeq_len + 7) / 8);\n\t\tlen += (data->primeq_len + 7) / 8;\t\t\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\tapdu.cla = 0x00;\n\tapdu.data = sbuf;\n\tapdu.datalen = len;\n\tapdu.lc\t= len;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"STORE/GENERATE_KEY returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int setcos_activate_file(sc_card_t *card)\n{\n\tint r;\n\tu8 sbuf[2];\n\tsc_apdu_t apdu;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x44, 0x00, 0x00);\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ACTIVATE_FILE returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int setcos_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tif (card->type != SC_CARD_TYPE_SETCOS_44 && !SETCOS_IS_EID_APPLET(card))\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tswitch(cmd) {\n\tcase SC_CARDCTL_SETCOS_PUTDATA:\n\t\treturn setcos_putdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GETDATA:\n\t\treturn setcos_getdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GENERATE_STORE_KEY:\n\t\treturn setcos_generate_store_key(card,\n\t\t\t\t(struct sc_cardctl_setcos_gen_store_key_info *) ptr);\n\tcase SC_CARDCTL_SETCOS_ACTIVATE_FILE:\n\t\treturn setcos_activate_file(card);\n\t}\n\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\nstatic struct sc_card_driver *sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tsetcos_ops = *iso_drv->ops;\n\tsetcos_ops.match_card = setcos_match_card;\n\tsetcos_ops.init = setcos_init;\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\tsetcos_ops.create_file = setcos_create_file;\n\tsetcos_ops.set_security_env = setcos_set_security_env;\n\tsetcos_ops.select_file = setcos_select_file;\n\tsetcos_ops.list_files = setcos_list_files;\n\tsetcos_ops.process_fci = setcos_process_fci;\n\tsetcos_ops.construct_fci = setcos_construct_fci;\n\tsetcos_ops.card_ctl = setcos_card_ctl;\n\n\treturn &setcos_drv;\n}\n\nstruct sc_card_driver *sc_get_setcos_driver(void)\n{\n\treturn sc_get_driver();\n}\n"], "fixing_code": ["/*\n * card-setcos.c: Support for PKI cards by Setec\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005  Antti Tapaninen <aet@cc.hut.fi>\n * Copyright (C) 2005  Zetes\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\n#define _FINEID_BROKEN_SELECT_FLAG 1\n\nstatic const struct sc_atr_table setcos_atrs[] = {\n\t/* some Nokia branded SC */\n\t{ \"3B:1F:11:00:67:80:42:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_GENERIC, 0, NULL },\n\t/* RSA SecurID 3100 */\n\t{ \"3B:9F:94:40:1E:00:67:16:43:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_PKI, 0, NULL },\n\n\t/* FINEID 1016 (SetCOS 4.3.1B3/PKCS#15, VRK) */\n\t{ \"3b:9f:94:40:1e:00:67:00:43:46:49:53:45:10:52:66:ff:81:90:00\", \"ff:ff:ff:ff:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID, SC_CARD_FLAG_RNG, NULL },\n\t/* FINEID 2032 (EIDApplet/7816-15, VRK test) */\n\t{ \"3b:6b:00:ff:80:62:00:a2:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2132 (EIDApplet/7816-15, 3rdparty test) */\n\t{ \"3b:64:00:ff:80:62:00:a2\", \"ff:ff:00:ff:ff:ff:00:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2064 (EIDApplet/7816-15, VRK) */\n\t{ \"3b:7b:00:00:00:80:62:00:51:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:ff:f0:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2164 (EIDApplet/7816-15, 3rdparty) */\n\t{ \"3b:64:00:00:80:62:00:51\", \"ff:ff:ff:ff:ff:ff:f0:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID 2264 (EIDApplet/7816-15, OPK/EMV/AVANT) */\n\t{ \"3b:6e:00:00:00:62:00:00:57:41:56:41:4e:54:10:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:7b:94:00:00:80:62:11:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t/* FINEID cards 1.3.2011 with Samsung chips (round connector) that supports 2048 bit keys. */\n\t{ \"3b:7b:94:00:00:80:62:12:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2_2048, 0, NULL },\n\t/* FINEID card for organisations, chip unknown. */\n\t{ \"3b:7b:18:00:00:80:62:01:54:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, _FINEID_BROKEN_SELECT_FLAG, NULL },\n\t/* Swedish NIDEL card */\n\t{ \"3b:9f:94:80:1f:c3:00:68:10:44:05:01:46:49:53:45:31:c8:07:90:00:18\", NULL, NULL, SC_CARD_TYPE_SETCOS_NIDEL, 0, NULL },\n\t/* Setcos 4.4.1 */\n\t{ \"3b:9f:94:80:1f:c3:00:68:11:44:05:01:46:49:53:45:31:c8:00:00:00:00\", \"ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:00:00:00:00\", NULL, SC_CARD_TYPE_SETCOS_44, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\n#define SETCOS_IS_EID_APPLET(card) ((card)->type == SC_CARD_TYPE_SETCOS_EID_V2_0 || (card)->type == SC_CARD_TYPE_SETCOS_EID_V2_1)\n\n/* Setcos 4.4 Life Cycle Status Integer  */\n#define SETEC_LCSI_CREATE      0x01\n#define SETEC_LCSI_INIT        0x03\n#define SETEC_LCSI_ACTIVATED   0x07\n#define SETEC_LCSI_DEACTIVATE  0x06\n#define SETEC_LCSI_TEMINATE    0x0F /* MF only  */\n\nstatic struct sc_card_operations setcos_ops;\nstatic struct sc_card_driver setcos_drv = {\n\t\"Setec cards\",\n\t\"setcos\",\n\t&setcos_ops,\n\tNULL, 0, NULL\n};\n\nstatic int match_hist_bytes(sc_card_t *card, const char *str, size_t len)\n{\n\tconst char *src = (const char *) card->reader->atr_info.hist_bytes;\n\tsize_t srclen = card->reader->atr_info.hist_bytes_len;\n\tsize_t offset = 0;\n\n\tif (len == 0)\n\t\tlen = strlen(str);\n\tif (srclen < len)\n\t\treturn 0;\n\twhile (srclen - offset > len) {\n\t\tif (memcmp(src + offset, str, len) == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\toffset++;\n\t}\n\treturn 0;\n}\n\nstatic int setcos_match_card(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tu8 buf[6];\n\tint i;\n\n\ti = _sc_match_atr(card, setcos_atrs, &card->type);\n\tif (i < 0) {\n\t\t/* Unknown card, but has the FinEID application for sure */\n\t\tif (match_hist_bytes(card, \"FinEID\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_FINEID_V2_2048;\n\t\t\treturn 1;\n\t\t}\n\t\tif (match_hist_bytes(card, \"FISE\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t\t\treturn 1;\n\t\t}\n\t\t/* Check if it's a EID2.x applet by reading the version info */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xCA, 0xDF, 0x30);\n\t\tapdu.cla = 0x00;\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = 5;\n\t\tapdu.le = 5;\n\t\ti = sc_transmit_apdu(card, &apdu);\n\t\tif (i == 0 && apdu.sw1 == 0x90 && apdu.sw2 == 0x00 && apdu.resplen == 5) {\n\t\t\tif (memcmp(buf, \"v2.0\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_0;\n\t\t\telse if (memcmp(buf, \"v2.1\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_1;\n\t\t\telse {\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tsc_log(card->ctx,  \"SetCOS EID applet %s is not supported\", (char *) buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tcard->flags = setcos_atrs[i].flags;\n\treturn 1;\n}\n\nstatic int select_pkcs15_app(sc_card_t * card)\n{\n\tsc_path_t app;\n\tint r;\n\n\t/* Regular PKCS#15 AID */\n\tsc_format_path(\"A000000063504B43532D3135\", &app);\n\tapp.type = SC_PATH_TYPE_DF_NAME;\n\tr = sc_select_file(card, &app, NULL);\n\treturn r;\n}\n\nstatic int setcos_init(sc_card_t *card)\n{\n\tcard->name = \"SetCOS\";\n\n\t/* Handle unknown or forced cards */\n\tif (card->type < 0) {\n\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t}\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcard->cla = 0x00;\n\t\tselect_pkcs15_app(card);\n\t\tif (card->flags & SC_CARD_FLAG_RNG)\n\t\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\tcard->cla = 0x00;\n\t\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t\tbreak;\n\tdefault:\n\t\t/* XXX: Get SetCOS version */\n\t\tcard->cla = 0x80;\t/* SetCOS 4.3.x */\n\t\t/* State that we have an RNG */\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\t}\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_PKI:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\t{\n\t\t\tunsigned long flags;\n\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t{\n\t\t\tunsigned long flags;\n\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\t\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\n\t\t\t_sc_card_add_rsa_alg(card, 512, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 768, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic int setcos_construct_fci_44(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n\tconst u8 *pin_key_info;\n\tint len;\n\n\t/* Command */\n\t*p++ = 0x6F;\n\tp++;\n\n\t/* Size (set to 0 for keys/PINs on a Java card) */\n\tif (SETCOS_IS_EID_APPLET(card) &&\n\t    (file->type == SC_FILE_TYPE_INTERNAL_EF || \n\t     (file->type == SC_FILE_TYPE_WORKING_EF && file->ef_structure == 0x22)))\n\t     \tbuf[0] = buf[1] = 0x00;\n\telse {\n\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\tbuf[1] = file->size & 0xFF;\n\t}\n\tsc_asn1_put_tag(0x81, buf, 2, p, *outlen - (p - out), &p);\n\n\t/* Type */\n\tif (file->type_attr_len) {\n\t\tmemcpy(buf, file->type_attr, file->type_attr_len);\n\t\tsc_asn1_put_tag(0x82, buf, file->type_attr_len, p, *outlen - (p - out), &p);\n\t} else {\n\t\tu8\tbLen = 1;\n\n\t\tbuf[0] = file->shareable ? 0x40 : 0;\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\t\t\t\t/* RSA keyfile */\n\t\t\tbuf[0] = 0x11;\t\t\t\t\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\t\t\tif (file->ef_structure == 0x22) {\t\t/* pin-file */\n\t\t\t\tbuf[0] = 0x0A;\t\t\t\t/* EF linear fixed EF for ISF keys */\n\t\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\t\tbLen = 1;\n\t\t\t\telse {\n\t\t\t\t\t/* Setcos V4.4 */\n\t\t\t\t\tbLen = 5;\n\t\t\t\t\tbuf[1] = 0x41;\t\t\t\t/* fixed */\n\t\t\t\t\tbuf[2] = file->record_length >> 8;\t/* 2 byte record length  */\n\t\t\t\t\tbuf[3] = file->record_length & 0xFF;\n\t\t\t\t\tbuf[4] = file->size / file->record_length; /* record count */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf[0] |= file->ef_structure & 7;\t/* set file-type, only for EF, not for DF objects  */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\t\n\t\t\tbuf[0] = 0x38;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tsc_asn1_put_tag(0x82, buf, bLen, p, *outlen - (p - out), &p);\n\t}\n\n\t/* File ID */\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, *outlen - (p - out), &p);\n\n\t/* DF name */\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (file->name[0] != 0)\n\t\t\tsc_asn1_put_tag(0x84, (u8 *) file->name, file->namelen, p, *outlen - (p - out), &p);\n\t\telse { /* Name required -> take the FID if not specified */\n\t\t\tbuf[0] = (file->id >> 8) & 0xFF;\n\t\t\tbuf[1] = file->id & 0xFF;\n\t\t\tsc_asn1_put_tag(0x84, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\n\t/* Security Attributes */\n\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\tsc_asn1_put_tag(0x86, buf, file->sec_attr_len, p, *outlen - (p - out), &p);\n\n\t/* Life cycle status */\n\tif (file->prop_attr_len) {\n\t\tmemcpy(buf, file->prop_attr, file->prop_attr_len);\n\t\tsc_asn1_put_tag(0x8A, buf, file->prop_attr_len, p, *outlen - (p - out), &p);\n\t}\n\n\t/* PIN definitions */\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (card->type == SC_CARD_TYPE_SETCOS_EID_V2_1) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\";\n\t\t\tlen = 6;\n\t\t}\n\t\telse if (card->type == SC_CARD_TYPE_SETCOS_EID_V2_0) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\"; /* Max 2 PINs supported */\n\t\t\tlen = 4;\n\t\t}\n\t\telse {\n\t\t\t/* Pin/key info: define 4 pins, no keys */\n\t\t\tif(file->path.len == 2)\n\t\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\\xC2\\x00\";\t/* root-MF: use local pin-file */\n\t\t\telse\n\t\t\t\tpin_key_info = (const u8 *)\"\\xC1\\x04\\x01\\x02\\x03\\x04\\xC2\\x00\";\t/* sub-DF: use parent pin-file in root-MF */\n\t\t\tlen = 8;\n\t\t}\n\t\tsc_asn1_put_tag(0xA5, pin_key_info, len, p, *outlen - (p - out), &p);\n\t}\n\n\t/* Length */\n\tout[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\nstatic int setcos_construct_fci(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || \n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_construct_fci_44(card, file, out, outlen);\n\telse\n\t\treturn iso_ops->construct_fci(card, file, out, outlen);\n}\n\nstatic u8 acl_to_byte(const sc_acl_entry_t *e)\n{\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\treturn 0x00;\n\tcase SC_AC_CHV:\n\t\tswitch (e->key_ref) {\n\t\tcase 1:\n\t\t\treturn 0x01;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treturn 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0x00;\n\t\t}\n\t\tbreak;\n\tcase SC_AC_TERM:\n\t\treturn 0x04;\n\tcase SC_AC_NEVER:\n\t\treturn 0x0F;\n\t}\n\treturn 0x00;\n}\n\nstatic unsigned int acl_to_byte_44(const struct sc_acl_entry *e, u8* p_bNumber)\n{\n\t/* Handle special fixed values */\n\tif (e == (sc_acl_entry_t *) 1)           /* SC_AC_NEVER */\n\t\treturn SC_AC_NEVER;\n\telse if ((e == (sc_acl_entry_t *) 2) ||  /* SC_AC_NONE */\n\t         (e == (sc_acl_entry_t *) 3) ||  /* SC_AC_UNKNOWN */\n\t         (e == (sc_acl_entry_t *) 0))\n\t\treturn SC_AC_NONE;\n\n\t/* Handle standard values */\n\t*p_bNumber = e->key_ref;\n\treturn(e->method);\n}\n\n/* If pin is present in the pins list, return it's index.\n * If it's not yet present, add it to the list and return the index. */\nstatic int setcos_pin_index_44(int *pins, int len, int pin)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (pins[i] == pin)\n\t\t\treturn i;\n\t\tif (pins[i] == -1) {\n\t\t\tpins[i] = pin;\n\t\t\treturn i;\n\t\t}\n\t}\n\tassert(i != len); /* Too much PINs, shouldn't happen */\n\treturn 0;\n}\n\n/* The ACs are always for the SETEC_LCSI_ACTIVATED state, even if\n * we have to create the file in the SC_FILE_STATUS_INITIALISATION state. */\nstatic int setcos_create_file_44(sc_card_t *card, sc_file_t *file)\n{\n\tconst u8 bFileStatus = file->status == SC_FILE_STATUS_CREATION ?\n\t\tSETEC_LCSI_CREATE : SETEC_LCSI_ACTIVATED;\n\tu8 bCommands_always = 0;\n\tint pins[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\tu8 bCommands_pin[sizeof(pins)/sizeof(pins[0])]; /* both 7 entries big */\n\tu8 bCommands_key = 0;\n\tu8 bNumber = 0;\n\tu8 bKeyNumber = 0;\n\tunsigned int bMethod = 0;\n\n\t/* -1 means RFU */\n\tconst int df_idx[8] = {  /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {  /* note: SC_AC_OP_SELECT to be ignored, actually RFU */\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = {  /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\t/* Set file creation status  */\n\tsc_file_set_prop_attr(file, &bFileStatus, 1);\n\n\t/* Build ACI from local structure = get AC for each operation group */\n\tif (file->sec_attr_len == 0) {\n\t\tconst int* p_idx;\n\t\tint\t       i;\n\t\tint\t       len = 0;\n\t\tu8         bBuf[64];\n\n\t\t/* Get specific operation groups for specified file-type */\n\t\tswitch (file->type){\n\t\tcase SC_FILE_TYPE_DF:           /* DF */\n\t\t\tp_idx = df_idx;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:  /* EF for RSA keys */\n\t\t\tp_idx = efi_idx;\n\t\t\tbreak;\n\t\tdefault:                        /* SC_FILE_TYPE_WORKING_EF */\n\t\t\tp_idx = ef_idx;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get enabled commands + required Keys/Pins  */\n\t\tmemset(bCommands_pin, 0, sizeof(bCommands_pin));\n\t\tfor (i = 7; i >= 0; i--) {  /* for each AC Setcos operation */\n\t\t\tbCommands_always <<= 1;\n\t\t\tbCommands_key <<= 1;\n\n\t\t\tif (p_idx[i] == -1)  /* -1 means that bit is RFU -> set to 0 */\n\t\t\t\tcontinue;\n\n\t\t\tbMethod = acl_to_byte_44(file->acl[ p_idx[i] ], &bNumber);\n\t\t\t/* Convert to OpenSc-index, convert to pin/key number */\n\t\t\tswitch(bMethod){\n\t\t\tcase SC_AC_NONE:\t\t\t/* always allowed */\n\t\t\t\tbCommands_always |= 1;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_CHV:\t\t\t\t/* pin */\n\t\t\t\tif ((bNumber & 0x7F) == 0 || (bNumber & 0x7F) > 7) {\n\t\t\t\t\tsc_log(card->ctx,  \"SetCOS 4.4 PIN refs can only be 1..7\\n\");\n\t\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t\t}\n\t\t\t\tbCommands_pin[setcos_pin_index_44(pins, sizeof(pins), (int) bNumber)] |= 1 << i;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_TERM:\t\t\t/* key */\n\t\t\t\tbKeyNumber = bNumber;\t/* There should be only 1 key */\n\t\t\t\tbCommands_key |= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Add the commands that are always allowed */\n\t\tif (bCommands_always) {\n\t\t\tbBuf[len++] = 1;\n\t\t\tbBuf[len++] = bCommands_always;\n\t\t}\n\t\t/* Add commands that require pins */\n\t\tfor (i = 0; i < (int)sizeof(bCommands_pin) && pins[i] != -1; i++) {\n\t\t\tbBuf[len++] = 2;\n\t\t\tbBuf[len++] = bCommands_pin[i];\n\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\tbBuf[len++] = pins[i];  /* pin ref */\n\t\t\telse\n\t\t\t\tbBuf[len++] = pins[i] & 0x07;  /* pin ref */\n\t\t}\n\t\t/* Add commands that require the key */\n\t\tif (bCommands_key) {\n\t\t\tbBuf[len++] = 2 | 0x20;\t\t\t/* indicate keyNumber present */\n\t\t\tbBuf[len++] = bCommands_key;\n\t\t\tbBuf[len++] = bKeyNumber;\n\t\t}\n\t\t/* RSA signing/decryption requires AC adaptive coding,  can't be put\n\t\t   in AC simple coding. Only implemented for pins, not for a key. */\n\t\tif ( (file->type == SC_FILE_TYPE_INTERNAL_EF) &&\n\t\t     (acl_to_byte_44(file->acl[SC_AC_OP_CRYPTO], &bNumber) == SC_AC_CHV) ) {\n\t\t\tbBuf[len++] = 0x83;\n\t\t\tbBuf[len++] = 0x01;\n\t\t\tbBuf[len++] = 0x2A;  /* INS byte for the sign/decrypt APDU */\n\t\t\tbBuf[len++] = bNumber & 0x07;  /* pin ref */\n\t\t}\n\n\t\tsc_file_set_sec_attr(file, bBuf, len);\n\t}\n\n\treturn iso_ops->create_file(card, file);\n}\n\nstatic int setcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_create_file_44(card, file);\n\n\tif (file->prop_attr_len == 0)\n\t\tsc_file_set_prop_attr(file, (const u8 *) \"\\x03\\x00\\x00\", 3);\n\tif (file->sec_attr_len == 0) {\n\t\tint idx[6], i;\n\t\tu8 buf[6];\n\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tconst int df_idx[6] = {\n\t\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = df_idx[i];\n\t\t} else {\n\t\t\tconst int ef_idx[6] = {\n\t\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = ef_idx[i];\n\t\t}\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\t\t\tentry = sc_file_get_acl_entry(file, idx[i]);\n\t\t\tbuf[i] = acl_to_byte(entry);\n\t\t}\n\n\t\tsc_file_set_sec_attr(file, buf, 6);\n\t}\n\n\treturn iso_ops->create_file(card, file);\n}\n\nstatic int setcos_set_security_env2(sc_card_t *card,\n\t\t\t\t    const sc_security_env_t *env, int se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r, locked = 0;\n\n\tassert(card != NULL && env != NULL);\n\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC) {\n\t\t\tsc_log(card->ctx,  \"symmetric keyref not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tif (se_num > 0) {\n\t\t\tsc_log(card->ctx,  \"restore security environment not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation) {\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\t/* Should be 0x81 */\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\t/* Should be 0x41 */\n\t\tapdu.p1 = ((card->type == SC_CARD_TYPE_SETCOS_FINEID_V2) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_44) ||\n\t\t\t   (card->type == SC_CARD_TYPE_SETCOS_NIDEL) || \n\t\t\t   SETCOS_IS_EID_APPLET(card)) ? 0x41 : 0x81;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT) {\n\t\t*p++ = 0x81;\n\t\t*p++ = env->file_ref.len;\n\t\tmemcpy(p, env->file_ref.value, env->file_ref.len);\n\t\tp += env->file_ref.len;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT &&\n\t    !(card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t      card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t\t\t*p++ = 0x83;\n\t\telse\n\t\t\t*p++ = 0x84;\n\t\t*p++ = env->key_ref_len;\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\n\t\tp += env->key_ref_len;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (se_num > 0) {\n\t\tr = sc_lock(card);\n\t\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\t\tlocked = 1;\n\t}\n\tif (apdu.datalen != 0) {\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (se_num <= 0)\n\t\treturn 0;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0xF2, se_num);\n\tr = sc_transmit_apdu(card, &apdu);\n\tsc_unlock(card);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\nerr:\n\tif (locked)\n\t\tsc_unlock(card);\n\treturn r;\n}\n\nstatic int setcos_set_security_env(sc_card_t *card,\n\t\t\t\t   const sc_security_env_t *env, int se_num)\n{\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT) {\n\t\tsc_security_env_t tmp;\n\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\t\tif (tmp.algorithm != SC_ALGORITHM_RSA) {\n\t\t\tsc_log(card->ctx,  \"Only RSA algorithm supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tswitch (card->type) {\n\t\tcase SC_CARD_TYPE_SETCOS_PKI:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcase SC_CARD_TYPE_SETCOS_44:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx,  \"Card does not support RSA.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\ttmp.algorithm_ref = 0x00;\n\t\t/* potential FIXME: return an error, if an unsupported\n\t\t * pad or hash was requested, although this shouldn't happen.\n\t\t */\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\ttmp.algorithm_ref = 0x02;\n\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\ttmp.algorithm_ref |= 0x10;\n\t\treturn setcos_set_security_env2(card, &tmp, se_num);\n\t}\n\treturn setcos_set_security_env2(card, env, se_num);\n}\n\nstatic void add_acl_entry(sc_file_t *file, int op, u8 byte)\n{\n\tunsigned int method, key_ref = SC_AC_KEY_REF_NONE;\n\n\tswitch (byte >> 4) {\n\tcase 0:\n\t\tmethod = SC_AC_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = 1;\n\t\tbreak;\n\tcase 2:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = 2;\n\t\tbreak;\n\tcase 4:\n\t\tmethod = SC_AC_TERM;\n\t\tbreak;\n\tcase 15:\n\t\tmethod = SC_AC_NEVER;\n\t\tbreak;\n\tdefault:\n\t\tmethod = SC_AC_UNKNOWN;\n\t\tbreak;\n\t}\n\tsc_file_add_acl_entry(file, op, method, key_ref);\n}\n\nstatic void parse_sec_attr(sc_file_t *file, const u8 * buf, size_t len)\n{\n\tint i;\n\tint idx[6];\n\n\tif (len < 6)\n\t\treturn;\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tconst int df_idx[6] = {\n\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\tSC_AC_OP_INVALIDATE\n\t\t};\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tidx[i] = df_idx[i];\n\t} else {\n\t\tconst int ef_idx[6] = {\n\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\tSC_AC_OP_INVALIDATE\n\t\t};\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tidx[i] = ef_idx[i];\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\tadd_acl_entry(file, idx[i], buf[i]);\n}\n\nstatic void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\t/* OpenSc Operation values for each command operation-type */\n\tconst int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\n\t/* Check all sub-AC definitions within the total AC */\n\twhile (len > 1) {\t\t\t\t/* minimum length = 2 */\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\n\t\tiMethod = SC_AC_NONE;\t\t/* default no authentication required */\n\n\t\tif (buf[iOffset] & 0X80) { /* AC in adaptive coding */\n\t\t\t/* Evaluates only the command-byte, not the optional P1/P2/Option bytes */\n\t\t\tsize_t\tiParmLen = 1;\t\t\t/* command-byte is always present */\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */\n\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\n\t\t\t/* Get KeyNumber if available */\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\t\t\t}\n\n\t\t\t/* Get PinNumber if available */\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */\n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Convert SETCOS command to OpenSC command group */\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t/* crypto operation */\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t/* key-generation operation */\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { /* AC in simple coding */\n\t\t\t   /* Initial AC is treated as an operational AC */\n\n\t\t\t/* Get specific Cmd groups for specified file-type */\n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            /* DF */\n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\n\t\t\t\tiPinCount--;\t\t\t\t/* one byte used for keyReference  */\n\t\t\t}\n\n\t\t\t/* Pin present ? */\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t/* pin ref */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Add AC for each command-operationType into OpenSc structure */\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Current field treated, get next AC sub-field */\n\t\tiOffset += iACLen +1;\t\t/* AC + PTL-byte */\n\t\tlen     -= iACLen +1;\n\t}\n}\n\nstatic int setcos_select_file(sc_card_t *card,\n\t\t\t      const sc_path_t *in_path, sc_file_t **file)\n{\n\tint r;\n\n\tr = iso_ops->select_file(card, in_path, file);\n\t/* Certain FINeID cards for organisations return 6A88 instead of 6A82 for missing files */\n\tif (card->flags & _FINEID_BROKEN_SELECT_FLAG && r == SC_ERROR_DATA_OBJECT_NOT_FOUND)\n\t\treturn SC_ERROR_FILE_NOT_FOUND;\n\tif (r)\n\t\treturn r;\n\tif (file != NULL) {\n\t\tif (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t\t    SETCOS_IS_EID_APPLET(card))\n\t\t\tparse_sec_attr_44(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\t\telse\n\t\t\tparse_sec_attr(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\t}\n\treturn 0;\n}\n\nstatic int setcos_list_files(sc_card_t *card, u8 * buf, size_t buflen)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, 0, 0);\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || \n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card))\n\t\tapdu.cla = 0x80;\n\tapdu.resp = buf;\n\tapdu.resplen = buflen;\n\tapdu.le = buflen > 256 ? 256 : buflen;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 && apdu.sw1 == 0x6A && apdu.sw2 == 0x82)\n\t\treturn 0; /* no files found */\n\tif (apdu.resplen == 0)\n\t\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\treturn apdu.resplen;\n}\n\nstatic int setcos_process_fci(sc_card_t *card, sc_file_t *file,\n\t\t       const u8 *buf, size_t buflen)\n{\n\tint r = iso_ops->process_fci(card, file, buf, buflen);\n\n\t/* SetCOS 4.4: RSA key file is an internal EF but it's\n\t * file descriptor doesn't seem to follow ISO7816. */\n\tif (r >= 0 && (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t               SETCOS_IS_EID_APPLET(card))) {\n\t\tconst u8 *tag;\n\t\tsize_t taglen = 1;\n\t\ttag = (u8 *) sc_asn1_find_tag(card->ctx, buf, buflen, 0x82, &taglen);\n\t\tif (tag != NULL && taglen == 1 && *tag == 0x11)\n\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t}\n\n\treturn r;\n}\n\n/* Write internal data, e.g. add default pin-records to pin-file */\nstatic int setcos_putdata(struct sc_card *card, struct sc_cardctl_setcos_data_obj* data_obj)\n{\n\tint\t\t\t\tr;\n\tstruct sc_apdu\t\t\tapdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_3_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xDA;\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = data_obj->DataLen;\n\tapdu.datalen = data_obj->DataLen;\n\tapdu.data    = data_obj->Data;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"PUT_DATA returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Read internal data, e.g. get RSA public key */\nstatic int setcos_getdata(struct sc_card *card, struct sc_cardctl_setcos_data_obj* data_obj)\n{\n\tint\t\t\t\tr;\n\tstruct sc_apdu\t\t\tapdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_2_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xCA;\t\t\t/* GET DATA */\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = 0;\n\tapdu.datalen = 0;\n\tapdu.data    = data_obj->Data;\n\n\tapdu.le      = 256;\n\tapdu.resp    = data_obj->Data;\n\tapdu.resplen = data_obj->DataLen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"GET_DATA returned error\");\n\n\tif (apdu.resplen > data_obj->DataLen)\n\t\tr = SC_ERROR_WRONG_LENGTH;\n\telse\n\t\tdata_obj->DataLen = apdu.resplen;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Generate or store a key */\nstatic int setcos_generate_store_key(sc_card_t *card,\n\tstruct sc_cardctl_setcos_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr, len;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Setup key-generation parameters */\n\tlen = 0;\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t\tsbuf[len++] = 0x92;\t/* algo ID: RSA CRT */\n\telse\n\t\tsbuf[len++] = 0x9A;\t/* algo ID: EXTERNALLY GENERATED RSA CRT */\n\tsbuf[len++] = 0x00;\t\n\tsbuf[len++] = data->mod_len / 256;\t/* 2 bytes for modulus bitlength */\n\tsbuf[len++] = data->mod_len % 256;\n\n\tsbuf[len++] = data->pubexp_len / 256;   /* 2 bytes for pubexp bitlength */\n\tsbuf[len++] = data->pubexp_len % 256;\n\tmemcpy(sbuf + len, data->pubexp, (data->pubexp_len + 7) / 8);\n\tlen += (data->pubexp_len + 7) / 8;\n\n\tif (data->op_type == OP_TYPE_STORE) {\n\t\tsbuf[len++] = data->primep_len / 256;\n\t\tsbuf[len++] = data->primep_len % 256;\n\t\tmemcpy(sbuf + len, data->primep, (data->primep_len + 7) / 8);\n\t\tlen += (data->primep_len + 7) / 8;\n\t\tsbuf[len++] = data->primeq_len / 256;\n\t\tsbuf[len++] = data->primeq_len % 256;\n\t\tmemcpy(sbuf + len, data->primeq, (data->primeq_len + 7) / 8);\n\t\tlen += (data->primeq_len + 7) / 8;\t\t\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\tapdu.cla = 0x00;\n\tapdu.data = sbuf;\n\tapdu.datalen = len;\n\tapdu.lc\t= len;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"STORE/GENERATE_KEY returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int setcos_activate_file(sc_card_t *card)\n{\n\tint r;\n\tu8 sbuf[2];\n\tsc_apdu_t apdu;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x44, 0x00, 0x00);\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ACTIVATE_FILE returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int setcos_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tif (card->type != SC_CARD_TYPE_SETCOS_44 && !SETCOS_IS_EID_APPLET(card))\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tswitch(cmd) {\n\tcase SC_CARDCTL_SETCOS_PUTDATA:\n\t\treturn setcos_putdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GETDATA:\n\t\treturn setcos_getdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GENERATE_STORE_KEY:\n\t\treturn setcos_generate_store_key(card,\n\t\t\t\t(struct sc_cardctl_setcos_gen_store_key_info *) ptr);\n\tcase SC_CARDCTL_SETCOS_ACTIVATE_FILE:\n\t\treturn setcos_activate_file(card);\n\t}\n\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\nstatic struct sc_card_driver *sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tsetcos_ops = *iso_drv->ops;\n\tsetcos_ops.match_card = setcos_match_card;\n\tsetcos_ops.init = setcos_init;\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\tsetcos_ops.create_file = setcos_create_file;\n\tsetcos_ops.set_security_env = setcos_set_security_env;\n\tsetcos_ops.select_file = setcos_select_file;\n\tsetcos_ops.list_files = setcos_list_files;\n\tsetcos_ops.process_fci = setcos_process_fci;\n\tsetcos_ops.construct_fci = setcos_construct_fci;\n\tsetcos_ops.card_ctl = setcos_card_ctl;\n\n\treturn &setcos_drv;\n}\n\nstruct sc_card_driver *sc_get_setcos_driver(void)\n{\n\treturn sc_get_driver();\n}\n"], "filenames": ["src/libopensc/card-setcos.c"], "buggy_code_start_loc": [871], "buggy_code_end_loc": [872], "fixing_code_start_loc": [871], "fixing_code_end_loc": [872], "type": "CWE-125", "message": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-setcos.c has an incorrect read operation during parsing of a SETCOS file attribute.", "other": {"cve": {"id": "CVE-2019-19479", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-01T23:15:10.653", "lastModified": "2021-11-30T21:59:31.693", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-setcos.c has an incorrect read operation during parsing of a SETCOS file attribute."}, {"lang": "es", "value": "Se detect\u00f3 un problema en OpenSC versiones hasta 0.19.0 y versiones 0.20.x hasta 0.20.0-rc3. El archivo libopensc/card-setcos.c presenta una operaci\u00f3n de lectura incorrecta durante el an\u00e1lisis de un atributo de archivo SETCOS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.19.0", "matchCriteriaId": "1BBAA136-529C-41AB-8A74-D4BABD9B00ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "B40AD56D-CA2A-41D0-A0B5-C5ACF6F21858"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "9C6258EA-E2DE-4AB0-BCF8-E4F550E80A4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "69C9C1EF-1A86-44CD-A147-5DEA86441FC2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/12/29/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=18693", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/12/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDSQLMZZYBHO5X3BK7D6E7E6NZIMZDI5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2"}}