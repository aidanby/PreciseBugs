{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                 M   M   AAA    GGGG  IIIII   CCCC  K   K                    %\n%                 MM MM  A   A  G        I    C      K  K                     %\n%                 M M M  AAAAA  G GGG    I    C      KKK                      %\n%                 M   M  A   A  G   G    I    C      K  K                     %\n%                 M   M  A   A   GGGG  IIIII   CCCC  K   K                    %\n%                                                                             %\n%                            CCCC  L      IIIII                               %\n%                           C      L        I                                 %\n%                           C      L        I                                 %\n%                           C      L        I                                 %\n%                            CCCC  LLLLL  IIIII                               %\n%                                                                             %\n%       Perform \"Magick\" on Images via the Command Line Interface             %\n%                                                                             %\n%                             Dragon Computing                                %\n%                             Anthony Thyssen                                 %\n%                               January 2012                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Read CLI arguments, script files, and pipelines, to provide options that\n%  manipulate images from many different formats.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/magick-cli.h\"\n#include \"MagickWand/script-token.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/* verbose debugging,\n      0 - no debug lines\n      3 - show option details  (better to use -debug Command now)\n      5 - image counts (after option runs)\n*/\n#define MagickCommandDebug 0\n\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P r o c e s s S c r i p t O p t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProcessScriptOptions() reads options and processes options as they are\n%  found in the given file, or pipeline.  The filename to open and read\n%  options is given as the 'index' argument of the argument array given.\n%\n%  Other arguments following index may be read by special script options\n%  as settings (strings), images, or as operations to be processed in various\n%  ways.   How they are treated is up to the script being processed.\n%\n%  Note that a script not 'return' to the command line processing, nor can\n%  they call (and return from) other scripts. At least not at this time.\n%\n%  There are no 'ProcessOptionFlags' control flags at this time.\n%\n%  The format of the ProcessScriptOptions method is:\n%\n%    void ProcessScriptOptions(MagickCLI *cli_wand,const char *filename,\n%       int argc,char **argv,int index)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use.\n%\n%    o filename: the filename of script to process\n%\n%    o argc: the number of elements in the argument vector. (optional)\n%\n%    o argv: A text array containing the command line arguments. (optional)\n%\n%    o index: offset of next argment in argv (script arguments) (optional)\n%\n*/\nWandExport void ProcessScriptOptions(MagickCLI *cli_wand,const char *filename,\n  int argc,char **argv,int index)\n{\n  ScriptTokenInfo\n    *token_info;\n\n  CommandOptionFlags\n    option_type;\n\n  int\n    count;\n\n  char\n    *option,\n    *arg1,\n    *arg2;\n\n  assert(filename != (char *) NULL ); /* at least one argument - script name */\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(CommandEvent,GetMagickModule(),\n         \"Processing script \\\"%s\\\"\", filename);\n\n  /* open file script or stream, and set up tokenizer */\n  token_info = AcquireScriptTokenInfo(filename);\n  if (token_info == (ScriptTokenInfo *) NULL) {\n    CLIWandExceptionFile(OptionFatalError,\"UnableToOpenScript\",filename);\n    return;\n  }\n\n  /* define the error location string for use in exceptions\n     order of localtion format escapes: filename, line, column */\n  cli_wand->location=\"in \\\"%s\\\" at line %u,column %u\";\n  if ( LocaleCompare(\"-\", filename) == 0 )\n    cli_wand->filename=\"stdin\";\n  else\n    cli_wand->filename=filename;\n\n  /* Process Options from Script */\n  option = arg1 = arg2 = (char*) NULL;\nDisableMSCWarning(4127)\n  while (1) {\nRestoreMSCWarning\n\n    { MagickBooleanType status = GetScriptToken(token_info);\n      cli_wand->line=token_info->token_line;\n      cli_wand->column=token_info->token_column;\n      if (status == MagickFalse)\n        break; /* error or end of options */\n    }\n\n    do { /* use break to loop to exception handler and loop */\n\n      /* save option details */\n      CloneString(&option,token_info->token);\n\n      /* get option, its argument count, and option type */\n      cli_wand->command = GetCommandOptionInfo(option);\n      count=cli_wand->command->type;\n      option_type=(CommandOptionFlags) cli_wand->command->flags;\n#if 0\n      (void) FormatLocaleFile(stderr, \"Script: %u,%u: \\\"%s\\\" matched \\\"%s\\\"\\n\",\n          cli_wand->line, cli_wand->line, option, cli_wand->command->mnemonic );\n#endif\n\n      /* handle a undefined option - image read - always for \"magick-script\" */\n      if ( option_type == UndefinedOptionFlag ||\n           (option_type & NonMagickOptionFlag) != 0 ) {\n#if MagickCommandDebug >= 3\n        (void) FormatLocaleFile(stderr, \"Script %u,%u Non-Option: \\\"%s\\\"\\n\",\n                    cli_wand->line, cli_wand->line, option);\n#endif\n        if (IsCommandOption(option) == MagickFalse) {\n          /* non-option -- treat as a image read */\n          cli_wand->command=(const OptionInfo *) NULL;\n          CLIOption(cli_wand,\"-read\",option);\n          break; /* next option */\n        }\n        CLIWandException(OptionFatalError,\"UnrecognizedOption\",option);\n        break; /* next option */\n      }\n\n      if ( count >= 1 ) {\n        if (GetScriptToken(token_info) == MagickFalse)\n          CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        CloneString(&arg1,token_info->token);\n      }\n      else\n        CloneString(&arg1,(char *) NULL);\n\n      if ( count >= 2 ) {\n        if (GetScriptToken(token_info) == MagickFalse)\n          CLIWandExceptionBreak(OptionFatalError,\"MissingArgument\",option);\n        CloneString(&arg2,token_info->token);\n      }\n      else\n        CloneString(&arg2,(char *) NULL);\n\n      /*\n        Process Options\n      */\n#if MagickCommandDebug >= 3\n      (void) FormatLocaleFile(stderr,\n        \"Script %u,%u Option: \\\"%s\\\"  Count: %d  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            cli_wand->line,cli_wand->line,option,count,option_type,arg1,arg2);\n#endif\n      /* Hard Deprecated Options, no code to execute - error */\n      if ( (option_type & DeprecateOptionFlag) != 0 ) {\n        CLIWandException(OptionError,\"DeprecatedOptionNoCode\",option);\n        break; /* next option */\n      }\n\n      /* MagickCommandGenesis() options have no place in a magick script */\n      if ( (option_type & GenesisOptionFlag) != 0 ) {\n        CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n        break; /* next option */\n      }\n\n      /* handle any special 'script' options */\n      if ( (option_type & SpecialOptionFlag) != 0 ) {\n        if ( LocaleCompare(option,\"-exit\") == 0 ) {\n          goto loop_exit; /* break out of loop - return from script */\n        }\n        if ( LocaleCompare(option,\"-script\") == 0 ) {\n          /* FUTURE: call new script from this script - error for now */\n          CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n          break; /* next option */\n        }\n        /* FUTURE: handle special script-argument options here */\n        /* handle any other special operators now */\n        CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n        break; /* next option */\n      }\n\n      /* Process non-specific Option */\n      CLIOption(cli_wand, option, arg1, arg2);\n      (void) fflush(stdout);\n      (void) fflush(stderr);\n\nDisableMSCWarning(4127)\n    } while (0); /* break block to next option */\nRestoreMSCWarning\n\n#if MagickCommandDebug >= 5\n    fprintf(stderr, \"Script Image Count = %ld\\n\",\n         GetImageListLength(cli_wand->wand.images) );\n#endif\n    if (CLICatchException(cli_wand, MagickFalse) != MagickFalse)\n      break;  /* exit loop */\n  }\n\n  /*\n     Loop exit - check for some tokenization error\n  */\nloop_exit:\n#if MagickCommandDebug >= 3\n  (void) FormatLocaleFile(stderr, \"Script End: %d\\n\", token_info->status);\n#endif\n  switch( token_info->status ) {\n    case TokenStatusOK:\n    case TokenStatusEOF:\n      if (cli_wand->image_list_stack != (Stack *) NULL)\n        CLIWandException(OptionError,\"UnbalancedParenthesis\", \"(eof)\");\n      else if (cli_wand->image_info_stack != (Stack *) NULL)\n        CLIWandException(OptionError,\"UnbalancedBraces\", \"(eof)\");\n      break;\n    case TokenStatusBadQuotes:\n      /* Ensure last token has a sane length for error report */\n      if( strlen(token_info->token) > INITAL_TOKEN_LENGTH-1 ) {\n        token_info->token[INITAL_TOKEN_LENGTH-4] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-3] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-2] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-1] = '\\0';\n      }\n      CLIWandException(OptionFatalError,\"ScriptUnbalancedQuotes\",\n           token_info->token);\n      break;\n    case TokenStatusMemoryFailed:\n      CLIWandException(OptionFatalError,\"ScriptTokenMemoryFailed\",\"\");\n      break;\n    case TokenStatusBinary:\n      CLIWandException(OptionFatalError,\"ScriptIsBinary\",\"\");\n      break;\n  }\n  (void) fflush(stdout);\n  (void) fflush(stderr);\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(CommandEvent,GetMagickModule(),\n         \"Script End \\\"%s\\\"\", filename);\n\n  /* Clean up */\n  token_info = DestroyScriptTokenInfo(token_info);\n\n  CloneString(&option,(char *) NULL);\n  CloneString(&arg1,(char *) NULL);\n  CloneString(&arg2,(char *) NULL);\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r o c e s s C o m m a n d O p t i o n s                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProcessCommandOptions() reads and processes arguments in the given\n%  command line argument array. The 'index' defines where in the array we\n%  should begin processing\n%\n%  The 'process_flags' can be used to control and limit option processing.\n%  For example, to only process one option, or how unknown and special options\n%  are to be handled, and if the last argument in array is to be regarded as a\n%  final image write argument (filename or special coder).\n%\n%  The format of the ProcessCommandOptions method is:\n%\n%    int ProcessCommandOptions(MagickCLI *cli_wand,int argc,char **argv,\n%      int index)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o process_flags: What type of arguments will be processed, ignored\n%                     or return errors.\n%\n%    o index: index in the argv array to start processing from\n%\n% The function returns the index ot the next option to be processed. This\n% is really only releven if process_flags contains a ProcessOneOptionOnly\n% flag.\n%\n*/\nWandExport int ProcessCommandOptions(MagickCLI *cli_wand,int argc,char **argv,\n  int index)\n{\n  const char\n    *option,\n    *arg1,\n    *arg2;\n\n  int\n    i,\n    end,\n    count;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(argc>=index); /* you may have no arguments left! */\n  assert(argv != (char **) NULL);\n  assert(argv[index] != (char *) NULL);\n  assert(argv[argc-1] != (char *) NULL);\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n\n  /* define the error location string for use in exceptions\n     order of localtion format escapes: filename, line, column */\n  cli_wand->location=\"at %s arg %u\";\n  cli_wand->filename=\"CLI\";\n  cli_wand->line=index;  /* note first argument we will process */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Starting (\\\"%s\\\")\", argv[index]);\n\n  end = argc;\n  if ( (cli_wand->process_flags & ProcessImplictWrite) != 0 )\n    end--; /* the last arument is an implied write, do not process directly */\n\n  for (i=index; i < end; i += count +1) {\n    /* Finished processing one option? */\n    if ( (cli_wand->process_flags & ProcessOneOptionOnly) != 0 && i != index )\n      return(i);\n\n    do { /* use break to loop to exception handler and loop */\n\n      option=argv[i];\n      cli_wand->line=i;  /* note the argument for this option */\n\n      /* get option, its argument count, and option type */\n      cli_wand->command = GetCommandOptionInfo(argv[i]);\n      count=cli_wand->command->type;\n      option_type=(CommandOptionFlags) cli_wand->command->flags;\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLI %d: \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            i, argv[i], cli_wand->command->mnemonic );\n#endif\n\n      if ( option_type == UndefinedOptionFlag ||\n           (option_type & NonMagickOptionFlag) != 0 ) {\n#if MagickCommandDebug >= 3\n        (void) FormatLocaleFile(stderr, \"CLI arg %d Non-Option: \\\"%s\\\"\\n\",\n             i, option);\n#endif\n        if (IsCommandOption(option) == MagickFalse) {\n          if ( (cli_wand->process_flags & ProcessImplictRead) != 0 ) {\n            /* non-option -- treat as a image read */\n            cli_wand->command=(const OptionInfo *) NULL;\n            CLIOption(cli_wand,\"-read\",option);\n            break; /* next option */\n          }\n        }\n        CLIWandException(OptionFatalError,\"UnrecognizedOption\",option);\n        break; /* next option */\n      }\n\n      if ( ((option_type & SpecialOptionFlag) != 0 ) &&\n           ((cli_wand->process_flags & ProcessScriptOption) != 0) &&\n           (LocaleCompare(option,\"-script\") == 0) ) {\n        /* Call Script from CLI, with a filename as a zeroth argument.\n           NOTE: -script may need to use the 'implict write filename' argument\n           so it must be handled specially to prevent a 'missing argument' error.\n        */\n        if ( (i+count) >= argc )\n          CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        ProcessScriptOptions(cli_wand,argv[i+1],argc,argv,i+count);\n        return(argc);  /* Script does not return to CLI -- Yet */\n                       /* FUTURE: when it does, their may be no write arg! */\n      }\n\n      if ((i+count) >= end ) {\n        CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n          return(end);\n        break; /* next option - not that their is any! */\n      }\n\n      arg1 = ( count >= 1 ) ? argv[i+1] : (char *) NULL;\n      arg2 = ( count >= 2 ) ? argv[i+2] : (char *) NULL;\n\n      /*\n        Process Known Options\n      */\n#if MagickCommandDebug >= 3\n      (void) FormatLocaleFile(stderr,\n        \"CLI arg %u Option: \\\"%s\\\"  Count: %d  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            i,option,count,option_type,arg1,arg2);\n#endif\n      /* ignore 'genesis options' in command line args */\n      if ( (option_type & GenesisOptionFlag) != 0 )\n        break; /* next option */\n\n      /* Handle any special options for CLI (-script handled above) */\n      if ( (option_type & SpecialOptionFlag) != 0 ) {\n        if ( (cli_wand->process_flags & ProcessExitOption) != 0\n             && LocaleCompare(option,\"-exit\") == 0 )\n          return(i+count);\n        break; /* next option */\n      }\n\n      /* Process standard image option */\n      CLIOption(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n    } while (0); /* break block to next option */\nRestoreMSCWarning\n\n#if MagickCommandDebug >= 5\n    (void) FormatLocaleFile(stderr, \"CLI-post Image Count = %ld\\n\",\n         (long) GetImageListLength(cli_wand->wand.images) );\n#endif\n    if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n      return(i+count);\n  }\n  assert(i==end);\n\n  if ( (cli_wand->process_flags & ProcessImplictWrite) == 0 )\n    return(end); /* no implied write -- just return to caller */\n\n  assert(end==argc-1); /* end should not include last argument */\n\n  /*\n     Implicit Write of images to final CLI argument\n  */\n  option=argv[i];\n  cli_wand->line=i;\n\n  /* check that stacks are empty - or cause exception */\n  if (cli_wand->image_list_stack != (Stack *) NULL)\n    CLIWandException(OptionError,\"UnbalancedParenthesis\", \"(end of cli)\");\n  else if (cli_wand->image_info_stack != (Stack *) NULL)\n    CLIWandException(OptionError,\"UnbalancedBraces\", \"(end of cli)\");\n  if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n    return(argc);\n\n#if MagickCommandDebug >= 3\n  (void) FormatLocaleFile(stderr,\"CLI arg %d Write File: \\\"%s\\\"\\n\",i,option);\n#endif\n\n  /* Valid 'do no write' replacement option (instead of \"null:\") */\n  if (LocaleCompare(option,\"-exit\") == 0 )\n    return(argc);  /* just exit, no image write */\n\n  /* If filename looks like an option,\n     Or the common 'end of line' error of a single space.\n     -- produce an error */\n  if (IsCommandOption(option) != MagickFalse ||\n      (option[0] == ' ' && option[1] == '\\0') ) {\n    CLIWandException(OptionError,\"MissingOutputFilename\",option);\n    return(argc);\n  }\n\n  cli_wand->command=(const OptionInfo *) NULL;\n  CLIOption(cli_wand,\"-write\",option);\n  return(argc);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a g i c k I m a g e C o m m a n d                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickImageCommand() Handle special use CLI arguments and prepare a\n%  CLI MagickCLI to process the command line or directly specified script.\n%\n%  This is essentualy interface function between the MagickCore library\n%  initialization function MagickCommandGenesis(), and the option MagickCLI\n%  processing functions  ProcessCommandOptions()  or  ProcessScriptOptions()\n%\n%  The format of the MagickImageCommand method is:\n%\n%      MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,\n%        char **argv,char **metadata,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the starting image_info structure\n%      (for compatibilty with MagickCommandGenisis())\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o metadata: any metadata (for VBS) is returned here.\n%      (for compatibilty with MagickCommandGenisis())\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void MagickUsage(MagickBooleanType verbose)\n{\n  const char\n    *name;\n\n  size_t\n    len;\n\n  name=GetClientName();\n  len=strlen(name);\n\n  if (len>=7 && LocaleCompare(\"convert\",name+len-7) == 0) {\n    /* convert usage */\n    (void) FormatLocaleFile(stdout,\n       \"Usage: %s [ {option} | {image} ... ] {output_image}\\n\",name);\n    (void) FormatLocaleFile(stdout,\n       \"       %s -help | -version | -usage | -list {option}\\n\\n\",name);\n    return;\n  }\n  else if (len>=6 && LocaleCompare(\"script\",name+len-6) == 0) {\n    /* magick-script usage */\n    (void) FormatLocaleFile(stdout,\n      \"Usage: %s {filename} [ {script_args} ... ]\\n\",name);\n  }\n  else {\n    /* magick usage */\n    (void) FormatLocaleFile(stdout,\n       \"Usage: %s [ {option} | {image} ... ] {output_image}\\n\",name);\n    (void) FormatLocaleFile(stdout,\n       \"       %s [ {option} | {image} ... ] -script {filename} [ {script_args} ...]\\n\",\n       name);\n  }\n  (void) FormatLocaleFile(stdout,\n    \"       %s -help | -version | -usage | -list {option}\\n\\n\",name);\n\n  if (verbose == MagickFalse)\n    return;\n\n  (void) FormatLocaleFile(stdout,\"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n    \"All options are performed in a strict 'as you see them' order\\n\",\n    \"You must read-in images before you can operate on them.\\n\",\n    \"\\n\",\n    \"Magick Script files can use any of the following forms...\\n\",\n    \"     #!/path/to/magick -script\\n\",\n    \"or\\n\",\n    \"     #!/bin/sh\\n\",\n    \"     :; exec magick -script \\\"$0\\\" \\\"$@\\\"; exit 10\\n\",\n    \"     # Magick script from here...\\n\",\n    \"or\\n\",\n    \"     #!/usr/bin/env  magick-script\\n\",\n    \"The latter two forms do not require the path to the command hard coded.\\n\",\n    \"Note: \\\"magick-script\\\" needs to be linked to the \\\"magick\\\" command.\\n\",\n    \"\\n\",\n    \"For more information on usage, options, examples, and techniques\\n\",\n    \"see the ImageMagick website at    \", MagickAuthoritativeURL);\n\n  return;\n}\n\n/*\n   Concatanate given file arguments to the given output argument.\n   Used for a special -concatenate option used for specific 'delegates'.\n   The option is not formally documented.\n\n      magick -concatenate files... output\n\n   This is much like the UNIX \"cat\" command, but for both UNIX and Windows,\n   however the last argument provides the output filename.\n*/\nstatic MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}\n\nWandExport MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,\n  char **argv,char **metadata,ExceptionInfo *exception)\n{\n  MagickCLI\n    *cli_wand;\n\n  size_t\n    len;\n\n  assert(image_info != (ImageInfo *) NULL);\n\n  /* For specific OS command line requirements */\n  ReadCommandlLine(argc,&argv);\n\n  /* Initialize special \"CLI Wand\" to hold images and settings (empty) */\n  cli_wand=AcquireMagickCLI(image_info,exception);\n  cli_wand->location=\"Initializing\";\n  cli_wand->filename=argv[0];\n  cli_wand->line=1;\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n\n  GetPathComponent(argv[0],TailPath,cli_wand->wand.name);\n  SetClientName(cli_wand->wand.name);\n  ConcatenateMagickString(cli_wand->wand.name,\"-CLI\",MagickPathExtent);\n\n  len=strlen(argv[0]);  /* precaution */\n\n  /* \"convert\" command - give a \"deprecated\" warning\" */\n  if (len>=7 && LocaleCompare(\"convert\",argv[0]+len-7) == 0) {\n    cli_wand->process_flags = ConvertCommandOptionFlags;\n    (void) FormatLocaleFile(stderr,\"WARNING: %s\\n\",\n         \"The convert command is deprecated in IMv7, use \\\"magick\\\"\\n\");\n  }\n\n  /* Special Case:  If command name ends with \"script\" implied \"-script\" */\n  if (len>=6 && LocaleCompare(\"script\",argv[0]+len-6) == 0) {\n    if (argc >= 2 && (  (*(argv[1]) != '-') || (strlen(argv[1]) == 1) )) {\n      GetPathComponent(argv[1],TailPath,cli_wand->wand.name);\n      ProcessScriptOptions(cli_wand,argv[1],argc,argv,2);\n      goto Magick_Command_Cleanup;\n    }\n  }\n\n  /* Special Case: Version Information and Abort */\n  if (argc == 2) {\n    if ((LocaleCompare(\"-version\",argv[1]) == 0)   || /* GNU standard option */\n        (LocaleCompare(\"--version\",argv[1]) == 0) ) { /* just version */\n      CLIOption(cli_wand, \"-version\");\n      goto Magick_Command_Exit;\n    }\n    if ((LocaleCompare(\"-help\",argv[1]) == 0)   || /* GNU standard option */\n        (LocaleCompare(\"--help\",argv[1]) == 0) ) { /* just a brief summary */\n      if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n      MagickUsage(MagickFalse);\n      goto Magick_Command_Exit;\n    }\n    if (LocaleCompare(\"-usage\",argv[1]) == 0) {   /* both version & usage */\n      if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n      CLIOption(cli_wand, \"-version\" );\n      MagickUsage(MagickTrue);\n      goto Magick_Command_Exit;\n    }\n  }\n\n  /* not enough arguments -- including -help */\n  if (argc < 3) {\n    (void) FormatLocaleFile(stderr,\n       \"Error: Invalid argument or not enough arguments\\n\\n\");\n    MagickUsage(MagickFalse);\n    goto Magick_Command_Exit;\n  }\n\n  /* Special \"concatenate option (hidden) for delegate usage */\n  if (LocaleCompare(\"-concatenate\",argv[1]) == 0) {\n    if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n    ConcatenateImages(argc,argv,exception);\n    goto Magick_Command_Exit;\n  }\n\n  /* List Information and Abort */\n  if (argc == 3 && LocaleCompare(\"-list\",argv[1]) == 0) {\n    CLIOption(cli_wand, argv[1], argv[2]);\n    goto Magick_Command_Exit;\n  }\n\n  /* ------------- */\n  /* The Main Call */\n\n  if (LocaleCompare(\"-script\",argv[1]) == 0) {\n    /* Start processing directly from script, no pre-script options\n       Replace wand command name with script name\n       First argument in the argv array is the script name to read.\n    */\n    GetPathComponent(argv[2],TailPath,cli_wand->wand.name);\n    ProcessScriptOptions(cli_wand,argv[2],argc,argv,3);\n  }\n  else {\n    /* Normal Command Line, assumes output file as last option */\n    ProcessCommandOptions(cli_wand,argc,argv,1);\n  }\n  /* ------------- */\n\nMagick_Command_Cleanup:\n  cli_wand->location=\"Cleanup\";\n  cli_wand->filename=argv[0];\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n  /* recover original image_info and clean up stacks\n     FUTURE: \"-reset stacks\" option  */\n  while ((cli_wand->image_list_stack != (Stack *) NULL) &&\n         (cli_wand->image_list_stack->next != (Stack *) NULL))\n    CLIOption(cli_wand,\")\");\n  while ((cli_wand->image_info_stack != (Stack *) NULL) &&\n         (cli_wand->image_info_stack->next != (Stack *) NULL))\n    CLIOption(cli_wand,\"}\");\n\n  /* assert we have recovered the original structures */\n  assert(cli_wand->wand.image_info == image_info);\n  assert(cli_wand->wand.exception == exception);\n\n  /* Handle metadata for ImageMagickObject COM object for Windows VBS */\n  if (metadata != (char **) NULL) {\n    const char\n      *format;\n\n    char\n      *text;\n\n    format=\"%w,%h,%m\";   // Get this from image_info Option splaytree\n\n    text=InterpretImageProperties(image_info,cli_wand->wand.images,format,\n      exception);\n    if (text == (char *) NULL)\n      ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n        \"MemoryAllocationFailed\",\"`%s'\", GetExceptionMessage(errno));\n    else {\n      (void) ConcatenateString(&(*metadata),text);\n      text=DestroyString(text);\n    }\n  }\n\nMagick_Command_Exit:\n  cli_wand->location=\"Exiting\";\n  cli_wand->filename=argv[0];\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n  /* Destroy the special CLI Wand */\n  cli_wand->wand.image_info = (ImageInfo *) NULL; /* not these */\n  cli_wand->wand.exception = (ExceptionInfo *) NULL;\n  cli_wand=DestroyMagickCLI(cli_wand);\n\n  return(exception->severity < ErrorException ? MagickTrue : MagickFalse);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                 M   M   AAA    GGGG  IIIII   CCCC  K   K                    %\n%                 MM MM  A   A  G        I    C      K  K                     %\n%                 M M M  AAAAA  G GGG    I    C      KKK                      %\n%                 M   M  A   A  G   G    I    C      K  K                     %\n%                 M   M  A   A   GGGG  IIIII   CCCC  K   K                    %\n%                                                                             %\n%                            CCCC  L      IIIII                               %\n%                           C      L        I                                 %\n%                           C      L        I                                 %\n%                           C      L        I                                 %\n%                            CCCC  LLLLL  IIIII                               %\n%                                                                             %\n%       Perform \"Magick\" on Images via the Command Line Interface             %\n%                                                                             %\n%                             Dragon Computing                                %\n%                             Anthony Thyssen                                 %\n%                               January 2012                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Read CLI arguments, script files, and pipelines, to provide options that\n%  manipulate images from many different formats.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/magick-cli.h\"\n#include \"MagickWand/script-token.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/* verbose debugging,\n      0 - no debug lines\n      3 - show option details  (better to use -debug Command now)\n      5 - image counts (after option runs)\n*/\n#define MagickCommandDebug 0\n\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P r o c e s s S c r i p t O p t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProcessScriptOptions() reads options and processes options as they are\n%  found in the given file, or pipeline.  The filename to open and read\n%  options is given as the 'index' argument of the argument array given.\n%\n%  Other arguments following index may be read by special script options\n%  as settings (strings), images, or as operations to be processed in various\n%  ways.   How they are treated is up to the script being processed.\n%\n%  Note that a script not 'return' to the command line processing, nor can\n%  they call (and return from) other scripts. At least not at this time.\n%\n%  There are no 'ProcessOptionFlags' control flags at this time.\n%\n%  The format of the ProcessScriptOptions method is:\n%\n%    void ProcessScriptOptions(MagickCLI *cli_wand,const char *filename,\n%       int argc,char **argv,int index)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use.\n%\n%    o filename: the filename of script to process\n%\n%    o argc: the number of elements in the argument vector. (optional)\n%\n%    o argv: A text array containing the command line arguments. (optional)\n%\n%    o index: offset of next argment in argv (script arguments) (optional)\n%\n*/\nWandExport void ProcessScriptOptions(MagickCLI *cli_wand,const char *filename,\n  int argc,char **argv,int index)\n{\n  ScriptTokenInfo\n    *token_info;\n\n  CommandOptionFlags\n    option_type;\n\n  int\n    count;\n\n  char\n    *option,\n    *arg1,\n    *arg2;\n\n  assert(filename != (char *) NULL ); /* at least one argument - script name */\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(CommandEvent,GetMagickModule(),\n         \"Processing script \\\"%s\\\"\", filename);\n\n  /* open file script or stream, and set up tokenizer */\n  token_info = AcquireScriptTokenInfo(filename);\n  if (token_info == (ScriptTokenInfo *) NULL) {\n    CLIWandExceptionFile(OptionFatalError,\"UnableToOpenScript\",filename);\n    return;\n  }\n\n  /* define the error location string for use in exceptions\n     order of localtion format escapes: filename, line, column */\n  cli_wand->location=\"in \\\"%s\\\" at line %u,column %u\";\n  if ( LocaleCompare(\"-\", filename) == 0 )\n    cli_wand->filename=\"stdin\";\n  else\n    cli_wand->filename=filename;\n\n  /* Process Options from Script */\n  option = arg1 = arg2 = (char*) NULL;\nDisableMSCWarning(4127)\n  while (1) {\nRestoreMSCWarning\n\n    { MagickBooleanType status = GetScriptToken(token_info);\n      cli_wand->line=token_info->token_line;\n      cli_wand->column=token_info->token_column;\n      if (status == MagickFalse)\n        break; /* error or end of options */\n    }\n\n    do { /* use break to loop to exception handler and loop */\n\n      /* save option details */\n      CloneString(&option,token_info->token);\n\n      /* get option, its argument count, and option type */\n      cli_wand->command = GetCommandOptionInfo(option);\n      count=cli_wand->command->type;\n      option_type=(CommandOptionFlags) cli_wand->command->flags;\n#if 0\n      (void) FormatLocaleFile(stderr, \"Script: %u,%u: \\\"%s\\\" matched \\\"%s\\\"\\n\",\n          cli_wand->line, cli_wand->line, option, cli_wand->command->mnemonic );\n#endif\n\n      /* handle a undefined option - image read - always for \"magick-script\" */\n      if ( option_type == UndefinedOptionFlag ||\n           (option_type & NonMagickOptionFlag) != 0 ) {\n#if MagickCommandDebug >= 3\n        (void) FormatLocaleFile(stderr, \"Script %u,%u Non-Option: \\\"%s\\\"\\n\",\n                    cli_wand->line, cli_wand->line, option);\n#endif\n        if (IsCommandOption(option) == MagickFalse) {\n          /* non-option -- treat as a image read */\n          cli_wand->command=(const OptionInfo *) NULL;\n          CLIOption(cli_wand,\"-read\",option);\n          break; /* next option */\n        }\n        CLIWandException(OptionFatalError,\"UnrecognizedOption\",option);\n        break; /* next option */\n      }\n\n      if ( count >= 1 ) {\n        if (GetScriptToken(token_info) == MagickFalse)\n          CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        CloneString(&arg1,token_info->token);\n      }\n      else\n        CloneString(&arg1,(char *) NULL);\n\n      if ( count >= 2 ) {\n        if (GetScriptToken(token_info) == MagickFalse)\n          CLIWandExceptionBreak(OptionFatalError,\"MissingArgument\",option);\n        CloneString(&arg2,token_info->token);\n      }\n      else\n        CloneString(&arg2,(char *) NULL);\n\n      /*\n        Process Options\n      */\n#if MagickCommandDebug >= 3\n      (void) FormatLocaleFile(stderr,\n        \"Script %u,%u Option: \\\"%s\\\"  Count: %d  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            cli_wand->line,cli_wand->line,option,count,option_type,arg1,arg2);\n#endif\n      /* Hard Deprecated Options, no code to execute - error */\n      if ( (option_type & DeprecateOptionFlag) != 0 ) {\n        CLIWandException(OptionError,\"DeprecatedOptionNoCode\",option);\n        break; /* next option */\n      }\n\n      /* MagickCommandGenesis() options have no place in a magick script */\n      if ( (option_type & GenesisOptionFlag) != 0 ) {\n        CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n        break; /* next option */\n      }\n\n      /* handle any special 'script' options */\n      if ( (option_type & SpecialOptionFlag) != 0 ) {\n        if ( LocaleCompare(option,\"-exit\") == 0 ) {\n          goto loop_exit; /* break out of loop - return from script */\n        }\n        if ( LocaleCompare(option,\"-script\") == 0 ) {\n          /* FUTURE: call new script from this script - error for now */\n          CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n          break; /* next option */\n        }\n        /* FUTURE: handle special script-argument options here */\n        /* handle any other special operators now */\n        CLIWandException(OptionError,\"InvalidUseOfOption\",option);\n        break; /* next option */\n      }\n\n      /* Process non-specific Option */\n      CLIOption(cli_wand, option, arg1, arg2);\n      (void) fflush(stdout);\n      (void) fflush(stderr);\n\nDisableMSCWarning(4127)\n    } while (0); /* break block to next option */\nRestoreMSCWarning\n\n#if MagickCommandDebug >= 5\n    fprintf(stderr, \"Script Image Count = %ld\\n\",\n         GetImageListLength(cli_wand->wand.images) );\n#endif\n    if (CLICatchException(cli_wand, MagickFalse) != MagickFalse)\n      break;  /* exit loop */\n  }\n\n  /*\n     Loop exit - check for some tokenization error\n  */\nloop_exit:\n#if MagickCommandDebug >= 3\n  (void) FormatLocaleFile(stderr, \"Script End: %d\\n\", token_info->status);\n#endif\n  switch( token_info->status ) {\n    case TokenStatusOK:\n    case TokenStatusEOF:\n      if (cli_wand->image_list_stack != (Stack *) NULL)\n        CLIWandException(OptionError,\"UnbalancedParenthesis\", \"(eof)\");\n      else if (cli_wand->image_info_stack != (Stack *) NULL)\n        CLIWandException(OptionError,\"UnbalancedBraces\", \"(eof)\");\n      break;\n    case TokenStatusBadQuotes:\n      /* Ensure last token has a sane length for error report */\n      if( strlen(token_info->token) > INITAL_TOKEN_LENGTH-1 ) {\n        token_info->token[INITAL_TOKEN_LENGTH-4] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-3] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-2] = '.';\n        token_info->token[INITAL_TOKEN_LENGTH-1] = '\\0';\n      }\n      CLIWandException(OptionFatalError,\"ScriptUnbalancedQuotes\",\n           token_info->token);\n      break;\n    case TokenStatusMemoryFailed:\n      CLIWandException(OptionFatalError,\"ScriptTokenMemoryFailed\",\"\");\n      break;\n    case TokenStatusBinary:\n      CLIWandException(OptionFatalError,\"ScriptIsBinary\",\"\");\n      break;\n  }\n  (void) fflush(stdout);\n  (void) fflush(stderr);\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(CommandEvent,GetMagickModule(),\n         \"Script End \\\"%s\\\"\", filename);\n\n  /* Clean up */\n  token_info = DestroyScriptTokenInfo(token_info);\n\n  CloneString(&option,(char *) NULL);\n  CloneString(&arg1,(char *) NULL);\n  CloneString(&arg2,(char *) NULL);\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  P r o c e s s C o m m a n d O p t i o n s                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProcessCommandOptions() reads and processes arguments in the given\n%  command line argument array. The 'index' defines where in the array we\n%  should begin processing\n%\n%  The 'process_flags' can be used to control and limit option processing.\n%  For example, to only process one option, or how unknown and special options\n%  are to be handled, and if the last argument in array is to be regarded as a\n%  final image write argument (filename or special coder).\n%\n%  The format of the ProcessCommandOptions method is:\n%\n%    int ProcessCommandOptions(MagickCLI *cli_wand,int argc,char **argv,\n%      int index)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o process_flags: What type of arguments will be processed, ignored\n%                     or return errors.\n%\n%    o index: index in the argv array to start processing from\n%\n% The function returns the index ot the next option to be processed. This\n% is really only releven if process_flags contains a ProcessOneOptionOnly\n% flag.\n%\n*/\nWandExport int ProcessCommandOptions(MagickCLI *cli_wand,int argc,char **argv,\n  int index)\n{\n  const char\n    *option,\n    *arg1,\n    *arg2;\n\n  int\n    i,\n    end,\n    count;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(argc>=index); /* you may have no arguments left! */\n  assert(argv != (char **) NULL);\n  assert(argv[index] != (char *) NULL);\n  assert(argv[argc-1] != (char *) NULL);\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n\n  /* define the error location string for use in exceptions\n     order of localtion format escapes: filename, line, column */\n  cli_wand->location=\"at %s arg %u\";\n  cli_wand->filename=\"CLI\";\n  cli_wand->line=index;  /* note first argument we will process */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Starting (\\\"%s\\\")\", argv[index]);\n\n  end = argc;\n  if ( (cli_wand->process_flags & ProcessImplictWrite) != 0 )\n    end--; /* the last arument is an implied write, do not process directly */\n\n  for (i=index; i < end; i += count +1) {\n    /* Finished processing one option? */\n    if ( (cli_wand->process_flags & ProcessOneOptionOnly) != 0 && i != index )\n      return(i);\n\n    do { /* use break to loop to exception handler and loop */\n\n      option=argv[i];\n      cli_wand->line=i;  /* note the argument for this option */\n\n      /* get option, its argument count, and option type */\n      cli_wand->command = GetCommandOptionInfo(argv[i]);\n      count=cli_wand->command->type;\n      option_type=(CommandOptionFlags) cli_wand->command->flags;\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLI %d: \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            i, argv[i], cli_wand->command->mnemonic );\n#endif\n\n      if ( option_type == UndefinedOptionFlag ||\n           (option_type & NonMagickOptionFlag) != 0 ) {\n#if MagickCommandDebug >= 3\n        (void) FormatLocaleFile(stderr, \"CLI arg %d Non-Option: \\\"%s\\\"\\n\",\n             i, option);\n#endif\n        if (IsCommandOption(option) == MagickFalse) {\n          if ( (cli_wand->process_flags & ProcessImplictRead) != 0 ) {\n            /* non-option -- treat as a image read */\n            cli_wand->command=(const OptionInfo *) NULL;\n            CLIOption(cli_wand,\"-read\",option);\n            break; /* next option */\n          }\n        }\n        CLIWandException(OptionFatalError,\"UnrecognizedOption\",option);\n        break; /* next option */\n      }\n\n      if ( ((option_type & SpecialOptionFlag) != 0 ) &&\n           ((cli_wand->process_flags & ProcessScriptOption) != 0) &&\n           (LocaleCompare(option,\"-script\") == 0) ) {\n        /* Call Script from CLI, with a filename as a zeroth argument.\n           NOTE: -script may need to use the 'implict write filename' argument\n           so it must be handled specially to prevent a 'missing argument' error.\n        */\n        if ( (i+count) >= argc )\n          CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        ProcessScriptOptions(cli_wand,argv[i+1],argc,argv,i+count);\n        return(argc);  /* Script does not return to CLI -- Yet */\n                       /* FUTURE: when it does, their may be no write arg! */\n      }\n\n      if ((i+count) >= end ) {\n        CLIWandException(OptionFatalError,\"MissingArgument\",option);\n        if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n          return(end);\n        break; /* next option - not that their is any! */\n      }\n\n      arg1 = ( count >= 1 ) ? argv[i+1] : (char *) NULL;\n      arg2 = ( count >= 2 ) ? argv[i+2] : (char *) NULL;\n\n      /*\n        Process Known Options\n      */\n#if MagickCommandDebug >= 3\n      (void) FormatLocaleFile(stderr,\n        \"CLI arg %u Option: \\\"%s\\\"  Count: %d  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            i,option,count,option_type,arg1,arg2);\n#endif\n      /* ignore 'genesis options' in command line args */\n      if ( (option_type & GenesisOptionFlag) != 0 )\n        break; /* next option */\n\n      /* Handle any special options for CLI (-script handled above) */\n      if ( (option_type & SpecialOptionFlag) != 0 ) {\n        if ( (cli_wand->process_flags & ProcessExitOption) != 0\n             && LocaleCompare(option,\"-exit\") == 0 )\n          return(i+count);\n        break; /* next option */\n      }\n\n      /* Process standard image option */\n      CLIOption(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n    } while (0); /* break block to next option */\nRestoreMSCWarning\n\n#if MagickCommandDebug >= 5\n    (void) FormatLocaleFile(stderr, \"CLI-post Image Count = %ld\\n\",\n         (long) GetImageListLength(cli_wand->wand.images) );\n#endif\n    if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n      return(i+count);\n  }\n  assert(i==end);\n\n  if ( (cli_wand->process_flags & ProcessImplictWrite) == 0 )\n    return(end); /* no implied write -- just return to caller */\n\n  assert(end==argc-1); /* end should not include last argument */\n\n  /*\n     Implicit Write of images to final CLI argument\n  */\n  option=argv[i];\n  cli_wand->line=i;\n\n  /* check that stacks are empty - or cause exception */\n  if (cli_wand->image_list_stack != (Stack *) NULL)\n    CLIWandException(OptionError,\"UnbalancedParenthesis\", \"(end of cli)\");\n  else if (cli_wand->image_info_stack != (Stack *) NULL)\n    CLIWandException(OptionError,\"UnbalancedBraces\", \"(end of cli)\");\n  if ( CLICatchException(cli_wand, MagickFalse) != MagickFalse )\n    return(argc);\n\n#if MagickCommandDebug >= 3\n  (void) FormatLocaleFile(stderr,\"CLI arg %d Write File: \\\"%s\\\"\\n\",i,option);\n#endif\n\n  /* Valid 'do no write' replacement option (instead of \"null:\") */\n  if (LocaleCompare(option,\"-exit\") == 0 )\n    return(argc);  /* just exit, no image write */\n\n  /* If filename looks like an option,\n     Or the common 'end of line' error of a single space.\n     -- produce an error */\n  if (IsCommandOption(option) != MagickFalse ||\n      (option[0] == ' ' && option[1] == '\\0') ) {\n    CLIWandException(OptionError,\"MissingOutputFilename\",option);\n    return(argc);\n  }\n\n  cli_wand->command=(const OptionInfo *) NULL;\n  CLIOption(cli_wand,\"-write\",option);\n  return(argc);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a g i c k I m a g e C o m m a n d                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickImageCommand() Handle special use CLI arguments and prepare a\n%  CLI MagickCLI to process the command line or directly specified script.\n%\n%  This is essentualy interface function between the MagickCore library\n%  initialization function MagickCommandGenesis(), and the option MagickCLI\n%  processing functions  ProcessCommandOptions()  or  ProcessScriptOptions()\n%\n%  The format of the MagickImageCommand method is:\n%\n%      MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,\n%        char **argv,char **metadata,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the starting image_info structure\n%      (for compatibilty with MagickCommandGenisis())\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o metadata: any metadata (for VBS) is returned here.\n%      (for compatibilty with MagickCommandGenisis())\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void MagickUsage(MagickBooleanType verbose)\n{\n  const char\n    *name;\n\n  size_t\n    len;\n\n  name=GetClientName();\n  len=strlen(name);\n\n  if (len>=7 && LocaleCompare(\"convert\",name+len-7) == 0) {\n    /* convert usage */\n    (void) FormatLocaleFile(stdout,\n       \"Usage: %s [ {option} | {image} ... ] {output_image}\\n\",name);\n    (void) FormatLocaleFile(stdout,\n       \"       %s -help | -version | -usage | -list {option}\\n\\n\",name);\n    return;\n  }\n  else if (len>=6 && LocaleCompare(\"script\",name+len-6) == 0) {\n    /* magick-script usage */\n    (void) FormatLocaleFile(stdout,\n      \"Usage: %s {filename} [ {script_args} ... ]\\n\",name);\n  }\n  else {\n    /* magick usage */\n    (void) FormatLocaleFile(stdout,\n       \"Usage: %s [ {option} | {image} ... ] {output_image}\\n\",name);\n    (void) FormatLocaleFile(stdout,\n       \"       %s [ {option} | {image} ... ] -script {filename} [ {script_args} ...]\\n\",\n       name);\n  }\n  (void) FormatLocaleFile(stdout,\n    \"       %s -help | -version | -usage | -list {option}\\n\\n\",name);\n\n  if (verbose == MagickFalse)\n    return;\n\n  (void) FormatLocaleFile(stdout,\"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n    \"All options are performed in a strict 'as you see them' order\\n\",\n    \"You must read-in images before you can operate on them.\\n\",\n    \"\\n\",\n    \"Magick Script files can use any of the following forms...\\n\",\n    \"     #!/path/to/magick -script\\n\",\n    \"or\\n\",\n    \"     #!/bin/sh\\n\",\n    \"     :; exec magick -script \\\"$0\\\" \\\"$@\\\"; exit 10\\n\",\n    \"     # Magick script from here...\\n\",\n    \"or\\n\",\n    \"     #!/usr/bin/env  magick-script\\n\",\n    \"The latter two forms do not require the path to the command hard coded.\\n\",\n    \"Note: \\\"magick-script\\\" needs to be linked to the \\\"magick\\\" command.\\n\",\n    \"\\n\",\n    \"For more information on usage, options, examples, and techniques\\n\",\n    \"see the ImageMagick website at    \", MagickAuthoritativeURL);\n\n  return;\n}\n\n/*\n   Concatanate given file arguments to the given output argument.\n   Used for a special -concatenate option used for specific 'delegates'.\n   The option is not formally documented.\n\n      magick -concatenate files... output\n\n   This is much like the UNIX \"cat\" command, but for both UNIX and Windows,\n   however the last argument provides the output filename.\n*/\nstatic MagickBooleanType ConcatenateImages(int argc,char **argv,\n  ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n\n  MagickBooleanType\n    status;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        argv[argc-1]);\n      return(MagickFalse);\n    }\n  status=MagickTrue;\n  for (i=2; i < (ssize_t) (argc-1); i++)\n  {\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL)\n      {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      if (fputc((char) c,output) != c)\n        status=MagickFalse;\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(status);\n}\n\nWandExport MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,\n  char **argv,char **metadata,ExceptionInfo *exception)\n{\n  MagickCLI\n    *cli_wand;\n\n  size_t\n    len;\n\n  assert(image_info != (ImageInfo *) NULL);\n\n  /* For specific OS command line requirements */\n  ReadCommandlLine(argc,&argv);\n\n  /* Initialize special \"CLI Wand\" to hold images and settings (empty) */\n  cli_wand=AcquireMagickCLI(image_info,exception);\n  cli_wand->location=\"Initializing\";\n  cli_wand->filename=argv[0];\n  cli_wand->line=1;\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n\n  GetPathComponent(argv[0],TailPath,cli_wand->wand.name);\n  SetClientName(cli_wand->wand.name);\n  ConcatenateMagickString(cli_wand->wand.name,\"-CLI\",MagickPathExtent);\n\n  len=strlen(argv[0]);  /* precaution */\n\n  /* \"convert\" command - give a \"deprecated\" warning\" */\n  if (len>=7 && LocaleCompare(\"convert\",argv[0]+len-7) == 0) {\n    cli_wand->process_flags = ConvertCommandOptionFlags;\n    (void) FormatLocaleFile(stderr,\"WARNING: %s\\n\",\n         \"The convert command is deprecated in IMv7, use \\\"magick\\\"\\n\");\n  }\n\n  /* Special Case:  If command name ends with \"script\" implied \"-script\" */\n  if (len>=6 && LocaleCompare(\"script\",argv[0]+len-6) == 0) {\n    if (argc >= 2 && (  (*(argv[1]) != '-') || (strlen(argv[1]) == 1) )) {\n      GetPathComponent(argv[1],TailPath,cli_wand->wand.name);\n      ProcessScriptOptions(cli_wand,argv[1],argc,argv,2);\n      goto Magick_Command_Cleanup;\n    }\n  }\n\n  /* Special Case: Version Information and Abort */\n  if (argc == 2) {\n    if ((LocaleCompare(\"-version\",argv[1]) == 0)   || /* GNU standard option */\n        (LocaleCompare(\"--version\",argv[1]) == 0) ) { /* just version */\n      CLIOption(cli_wand, \"-version\");\n      goto Magick_Command_Exit;\n    }\n    if ((LocaleCompare(\"-help\",argv[1]) == 0)   || /* GNU standard option */\n        (LocaleCompare(\"--help\",argv[1]) == 0) ) { /* just a brief summary */\n      if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n      MagickUsage(MagickFalse);\n      goto Magick_Command_Exit;\n    }\n    if (LocaleCompare(\"-usage\",argv[1]) == 0) {   /* both version & usage */\n      if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n      CLIOption(cli_wand, \"-version\" );\n      MagickUsage(MagickTrue);\n      goto Magick_Command_Exit;\n    }\n  }\n\n  /* not enough arguments -- including -help */\n  if (argc < 3) {\n    (void) FormatLocaleFile(stderr,\n       \"Error: Invalid argument or not enough arguments\\n\\n\");\n    MagickUsage(MagickFalse);\n    goto Magick_Command_Exit;\n  }\n\n  /* Special \"concatenate option (hidden) for delegate usage */\n  if (LocaleCompare(\"-concatenate\",argv[1]) == 0) {\n    if (cli_wand->wand.debug != MagickFalse)\n        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n            \"- Special Option \\\"%s\\\"\", argv[1]);\n    ConcatenateImages(argc,argv,exception);\n    goto Magick_Command_Exit;\n  }\n\n  /* List Information and Abort */\n  if (argc == 3 && LocaleCompare(\"-list\",argv[1]) == 0) {\n    CLIOption(cli_wand, argv[1], argv[2]);\n    goto Magick_Command_Exit;\n  }\n\n  /* ------------- */\n  /* The Main Call */\n\n  if (LocaleCompare(\"-script\",argv[1]) == 0) {\n    /* Start processing directly from script, no pre-script options\n       Replace wand command name with script name\n       First argument in the argv array is the script name to read.\n    */\n    GetPathComponent(argv[2],TailPath,cli_wand->wand.name);\n    ProcessScriptOptions(cli_wand,argv[2],argc,argv,3);\n  }\n  else {\n    /* Normal Command Line, assumes output file as last option */\n    ProcessCommandOptions(cli_wand,argc,argv,1);\n  }\n  /* ------------- */\n\nMagick_Command_Cleanup:\n  cli_wand->location=\"Cleanup\";\n  cli_wand->filename=argv[0];\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n  /* recover original image_info and clean up stacks\n     FUTURE: \"-reset stacks\" option  */\n  while ((cli_wand->image_list_stack != (Stack *) NULL) &&\n         (cli_wand->image_list_stack->next != (Stack *) NULL))\n    CLIOption(cli_wand,\")\");\n  while ((cli_wand->image_info_stack != (Stack *) NULL) &&\n         (cli_wand->image_info_stack->next != (Stack *) NULL))\n    CLIOption(cli_wand,\"}\");\n\n  /* assert we have recovered the original structures */\n  assert(cli_wand->wand.image_info == image_info);\n  assert(cli_wand->wand.exception == exception);\n\n  /* Handle metadata for ImageMagickObject COM object for Windows VBS */\n  if (metadata != (char **) NULL) {\n    const char\n      *format;\n\n    char\n      *text;\n\n    format=\"%w,%h,%m\";   // Get this from image_info Option splaytree\n\n    text=InterpretImageProperties(image_info,cli_wand->wand.images,format,\n      exception);\n    if (text == (char *) NULL)\n      ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n        \"MemoryAllocationFailed\",\"`%s'\", GetExceptionMessage(errno));\n    else {\n      (void) ConcatenateString(&(*metadata),text);\n      text=DestroyString(text);\n    }\n  }\n\nMagick_Command_Exit:\n  cli_wand->location=\"Exiting\";\n  cli_wand->filename=argv[0];\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"\\\"%s\\\"\",argv[0]);\n\n  /* Destroy the special CLI Wand */\n  cli_wand->wand.image_info = (ImageInfo *) NULL; /* not these */\n  cli_wand->wand.exception = (ExceptionInfo *) NULL;\n  cli_wand=DestroyMagickCLI(cli_wand);\n\n  return(exception->severity < ErrorException ? MagickTrue : MagickFalse);\n}\n"], "filenames": ["MagickWand/magick-cli.c"], "buggy_code_start_loc": [644], "buggy_code_end_loc": [681], "fixing_code_start_loc": [644], "fixing_code_end_loc": [686], "type": "CWE-252", "message": "The ConcatenateImages function in MagickWand/magick-cli.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "other": {"cve": {"id": "CVE-2016-10060", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-02T21:59:00.193", "lastModified": "2021-04-28T19:20:52.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ConcatenateImages function in MagickWand/magick-cli.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (application crash) via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n ConcatenateImages en MagickWand/magick-cli.c en ImageMagick en versiones anteriores a 7.0.1-10 no comprueba el valor de retorno de la funci\u00f3n fputc, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.4-1", "matchCriteriaId": "9C58A952-0904-4F37-9531-56050AED9B6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.1-10", "matchCriteriaId": "3FBA4C0C-4880-4275-82D5-404EAAE91101"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95208", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410470", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/196", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7"}}