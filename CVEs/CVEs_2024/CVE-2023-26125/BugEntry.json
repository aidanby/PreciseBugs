{"buggy_code": ["// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n\t\"github.com/gin-gonic/gin/render\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\nconst defaultMultipartMemory = 32 << 20 // 32 MB\n\nvar (\n\tdefault404Body = []byte(\"404 page not found\")\n\tdefault405Body = []byte(\"405 method not allowed\")\n)\n\nvar defaultPlatform string\n\nvar defaultTrustedCIDRs = []*net.IPNet{\n\t{ // 0.0.0.0/0 (IPv4)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0},\n\t},\n\t{ // ::/0 (IPv6)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t},\n}\n\n// HandlerFunc defines the handler used by gin middleware as return value.\ntype HandlerFunc func(*Context)\n\n// HandlersChain defines a HandlerFunc slice.\ntype HandlersChain []HandlerFunc\n\n// Last returns the last handler in the chain. i.e. the last handler is the main one.\nfunc (c HandlersChain) Last() HandlerFunc {\n\tif length := len(c); length > 0 {\n\t\treturn c[length-1]\n\t}\n\treturn nil\n}\n\n// RouteInfo represents a request route's specification which contains method and path and its handler.\ntype RouteInfo struct {\n\tMethod      string\n\tPath        string\n\tHandler     string\n\tHandlerFunc HandlerFunc\n}\n\n// RoutesInfo defines a RouteInfo slice.\ntype RoutesInfo []RouteInfo\n\n// Trusted platforms\nconst (\n\t// PlatformGoogleAppEngine when running on Google App Engine. Trust X-Appengine-Remote-Addr\n\t// for determining the client's IP\n\tPlatformGoogleAppEngine = \"X-Appengine-Remote-Addr\"\n\t// PlatformCloudflare when using Cloudflare's CDN. Trust CF-Connecting-IP for determining\n\t// the client's IP\n\tPlatformCloudflare = \"CF-Connecting-IP\"\n)\n\n// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.\n// Create an instance of Engine, by using New() or Default()\ntype Engine struct {\n\tRouterGroup\n\n\t// RedirectTrailingSlash enables automatic redirection if the current route can't be matched but a\n\t// handler for the path with (without) the trailing slash exists.\n\t// For example if /foo/ is requested but a route only exists for /foo, the\n\t// client is redirected to /foo with http status code 301 for GET requests\n\t// and 307 for all other request methods.\n\tRedirectTrailingSlash bool\n\n\t// RedirectFixedPath if enabled, the router tries to fix the current request path, if no\n\t// handle is registered for it.\n\t// First superfluous path elements like ../ or // are removed.\n\t// Afterwards the router does a case-insensitive lookup of the cleaned path.\n\t// If a handle can be found for this route, the router makes a redirection\n\t// to the corrected path with status code 301 for GET requests and 307 for\n\t// all other request methods.\n\t// For example /FOO and /..//Foo could be redirected to /foo.\n\t// RedirectTrailingSlash is independent of this option.\n\tRedirectFixedPath bool\n\n\t// HandleMethodNotAllowed if enabled, the router checks if another method is allowed for the\n\t// current route, if the current request can not be routed.\n\t// If this is the case, the request is answered with 'Method Not Allowed'\n\t// and HTTP status code 405.\n\t// If no other Method is allowed, the request is delegated to the NotFound\n\t// handler.\n\tHandleMethodNotAllowed bool\n\n\t// ForwardedByClientIP if enabled, client IP will be parsed from the request's headers that\n\t// match those stored at `(*gin.Engine).RemoteIPHeaders`. If no IP was\n\t// fetched, it falls back to the IP obtained from\n\t// `(*gin.Context).Request.RemoteAddr`.\n\tForwardedByClientIP bool\n\n\t// AppEngine was deprecated.\n\t// Deprecated: USE `TrustedPlatform` WITH VALUE `gin.PlatformGoogleAppEngine` INSTEAD\n\t// #726 #755 If enabled, it will trust some headers starting with\n\t// 'X-AppEngine...' for better integration with that PaaS.\n\tAppEngine bool\n\n\t// UseRawPath if enabled, the url.RawPath will be used to find parameters.\n\tUseRawPath bool\n\n\t// UnescapePathValues if true, the path value will be unescaped.\n\t// If UseRawPath is false (by default), the UnescapePathValues effectively is true,\n\t// as url.Path gonna be used, which is already unescaped.\n\tUnescapePathValues bool\n\n\t// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.\n\t// See the PR #1817 and issue #1644\n\tRemoveExtraSlash bool\n\n\t// RemoteIPHeaders list of headers used to obtain the client IP when\n\t// `(*gin.Engine).ForwardedByClientIP` is `true` and\n\t// `(*gin.Context).Request.RemoteAddr` is matched by at least one of the\n\t// network origins of list defined by `(*gin.Engine).SetTrustedProxies()`.\n\tRemoteIPHeaders []string\n\n\t// TrustedPlatform if set to a constant of value gin.Platform*, trusts the headers set by\n\t// that platform, for example to determine the client IP\n\tTrustedPlatform string\n\n\t// MaxMultipartMemory value of 'maxMemory' param that is given to http.Request's ParseMultipartForm\n\t// method call.\n\tMaxMultipartMemory int64\n\n\t// UseH2C enable h2c support.\n\tUseH2C bool\n\n\t// ContextWithFallback enable fallback Context.Deadline(), Context.Done(), Context.Err() and Context.Value() when Context.Request.Context() is not nil.\n\tContextWithFallback bool\n\n\tdelims           render.Delims\n\tsecureJSONPrefix string\n\tHTMLRender       render.HTMLRender\n\tFuncMap          template.FuncMap\n\tallNoRoute       HandlersChain\n\tallNoMethod      HandlersChain\n\tnoRoute          HandlersChain\n\tnoMethod         HandlersChain\n\tpool             sync.Pool\n\ttrees            methodTrees\n\tmaxParams        uint16\n\tmaxSections      uint16\n\ttrustedProxies   []string\n\ttrustedCIDRs     []*net.IPNet\n}\n\nvar _ IRouter = (*Engine)(nil)\n\n// New returns a new blank Engine instance without any middleware attached.\n// By default, the configuration is:\n// - RedirectTrailingSlash:  true\n// - RedirectFixedPath:      false\n// - HandleMethodNotAllowed: false\n// - ForwardedByClientIP:    true\n// - UseRawPath:             false\n// - UnescapePathValues:     true\nfunc New() *Engine {\n\tdebugPrintWARNINGNew()\n\tengine := &Engine{\n\t\tRouterGroup: RouterGroup{\n\t\t\tHandlers: nil,\n\t\t\tbasePath: \"/\",\n\t\t\troot:     true,\n\t\t},\n\t\tFuncMap:                template.FuncMap{},\n\t\tRedirectTrailingSlash:  true,\n\t\tRedirectFixedPath:      false,\n\t\tHandleMethodNotAllowed: false,\n\t\tForwardedByClientIP:    true,\n\t\tRemoteIPHeaders:        []string{\"X-Forwarded-For\", \"X-Real-IP\"},\n\t\tTrustedPlatform:        defaultPlatform,\n\t\tUseRawPath:             false,\n\t\tRemoveExtraSlash:       false,\n\t\tUnescapePathValues:     true,\n\t\tMaxMultipartMemory:     defaultMultipartMemory,\n\t\ttrees:                  make(methodTrees, 0, 9),\n\t\tdelims:                 render.Delims{Left: \"{{\", Right: \"}}\"},\n\t\tsecureJSONPrefix:       \"while(1);\",\n\t\ttrustedProxies:         []string{\"0.0.0.0/0\", \"::/0\"},\n\t\ttrustedCIDRs:           defaultTrustedCIDRs,\n\t}\n\tengine.RouterGroup.engine = engine\n\tengine.pool.New = func() any {\n\t\treturn engine.allocateContext(engine.maxParams)\n\t}\n\treturn engine\n}\n\n// Default returns an Engine instance with the Logger and Recovery middleware already attached.\nfunc Default() *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n\tengine.Use(Logger(), Recovery())\n\treturn engine\n}\n\nfunc (engine *Engine) Handler() http.Handler {\n\tif !engine.UseH2C {\n\t\treturn engine\n\t}\n\n\th2s := &http2.Server{}\n\treturn h2c.NewHandler(engine, h2s)\n}\n\nfunc (engine *Engine) allocateContext(maxParams uint16) *Context {\n\tv := make(Params, 0, maxParams)\n\tskippedNodes := make([]skippedNode, 0, engine.maxSections)\n\treturn &Context{engine: engine, params: &v, skippedNodes: &skippedNodes}\n}\n\n// Delims sets template left and right delims and returns an Engine instance.\nfunc (engine *Engine) Delims(left, right string) *Engine {\n\tengine.delims = render.Delims{Left: left, Right: right}\n\treturn engine\n}\n\n// SecureJsonPrefix sets the secureJSONPrefix used in Context.SecureJSON.\nfunc (engine *Engine) SecureJsonPrefix(prefix string) *Engine {\n\tengine.secureJSONPrefix = prefix\n\treturn engine\n}\n\n// LoadHTMLGlob loads HTML files identified by glob pattern\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLGlob(pattern string) {\n\tleft := engine.delims.Left\n\tright := engine.delims.Right\n\ttempl := template.Must(template.New(\"\").Delims(left, right).Funcs(engine.FuncMap).ParseGlob(pattern))\n\n\tif IsDebugging() {\n\t\tdebugPrintLoadTemplate(templ)\n\t\tengine.HTMLRender = render.HTMLDebug{Glob: pattern, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\tengine.SetHTMLTemplate(templ)\n}\n\n// LoadHTMLFiles loads a slice of HTML files\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLFiles(files ...string) {\n\tif IsDebugging() {\n\t\tengine.HTMLRender = render.HTMLDebug{Files: files, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\ttempl := template.Must(template.New(\"\").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFiles(files...))\n\tengine.SetHTMLTemplate(templ)\n}\n\n// SetHTMLTemplate associate a template with HTML renderer.\nfunc (engine *Engine) SetHTMLTemplate(templ *template.Template) {\n\tif len(engine.trees) > 0 {\n\t\tdebugPrintWARNINGSetHTMLTemplate()\n\t}\n\n\tengine.HTMLRender = render.HTMLProduction{Template: templ.Funcs(engine.FuncMap)}\n}\n\n// SetFuncMap sets the FuncMap used for template.FuncMap.\nfunc (engine *Engine) SetFuncMap(funcMap template.FuncMap) {\n\tengine.FuncMap = funcMap\n}\n\n// NoRoute adds handlers for NoRoute. It returns a 404 code by default.\nfunc (engine *Engine) NoRoute(handlers ...HandlerFunc) {\n\tengine.noRoute = handlers\n\tengine.rebuild404Handlers()\n}\n\n// NoMethod sets the handlers called when Engine.HandleMethodNotAllowed = true.\nfunc (engine *Engine) NoMethod(handlers ...HandlerFunc) {\n\tengine.noMethod = handlers\n\tengine.rebuild405Handlers()\n}\n\n// Use attaches a global middleware to the router. i.e. the middleware attached through Use() will be\n// included in the handlers chain for every single request. Even 404, 405, static files...\n// For example, this is the right place for a logger or error management middleware.\nfunc (engine *Engine) Use(middleware ...HandlerFunc) IRoutes {\n\tengine.RouterGroup.Use(middleware...)\n\tengine.rebuild404Handlers()\n\tengine.rebuild405Handlers()\n\treturn engine\n}\n\nfunc (engine *Engine) rebuild404Handlers() {\n\tengine.allNoRoute = engine.combineHandlers(engine.noRoute)\n}\n\nfunc (engine *Engine) rebuild405Handlers() {\n\tengine.allNoMethod = engine.combineHandlers(engine.noMethod)\n}\n\nfunc (engine *Engine) addRoute(method, path string, handlers HandlersChain) {\n\tassert1(path[0] == '/', \"path must begin with '/'\")\n\tassert1(method != \"\", \"HTTP method can not be empty\")\n\tassert1(len(handlers) > 0, \"there must be at least one handler\")\n\n\tdebugPrintRoute(method, path, handlers)\n\n\troot := engine.trees.get(method)\n\tif root == nil {\n\t\troot = new(node)\n\t\troot.fullPath = \"/\"\n\t\tengine.trees = append(engine.trees, methodTree{method: method, root: root})\n\t}\n\troot.addRoute(path, handlers)\n\n\t// Update maxParams\n\tif paramsCount := countParams(path); paramsCount > engine.maxParams {\n\t\tengine.maxParams = paramsCount\n\t}\n\n\tif sectionsCount := countSections(path); sectionsCount > engine.maxSections {\n\t\tengine.maxSections = sectionsCount\n\t}\n}\n\n// Routes returns a slice of registered routes, including some useful information, such as:\n// the http method, path and the handler name.\nfunc (engine *Engine) Routes() (routes RoutesInfo) {\n\tfor _, tree := range engine.trees {\n\t\troutes = iterate(\"\", tree.method, routes, tree.root)\n\t}\n\treturn routes\n}\n\nfunc iterate(path, method string, routes RoutesInfo, root *node) RoutesInfo {\n\tpath += root.path\n\tif len(root.handlers) > 0 {\n\t\thandlerFunc := root.handlers.Last()\n\t\troutes = append(routes, RouteInfo{\n\t\t\tMethod:      method,\n\t\t\tPath:        path,\n\t\t\tHandler:     nameOfFunction(handlerFunc),\n\t\t\tHandlerFunc: handlerFunc,\n\t\t})\n\t}\n\tfor _, child := range root.children {\n\t\troutes = iterate(path, method, routes, child)\n\t}\n\treturn routes\n}\n\n// Run attaches the router to a http.Server and starts listening and serving HTTP requests.\n// It is a shortcut for http.ListenAndServe(addr, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) Run(addr ...string) (err error) {\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\taddress := resolveAddress(addr)\n\tdebugPrint(\"Listening and serving HTTP on %s\\n\", address)\n\terr = http.ListenAndServe(address, engine.Handler())\n\treturn\n}\n\nfunc (engine *Engine) prepareTrustedCIDRs() ([]*net.IPNet, error) {\n\tif engine.trustedProxies == nil {\n\t\treturn nil, nil\n\t}\n\n\tcidr := make([]*net.IPNet, 0, len(engine.trustedProxies))\n\tfor _, trustedProxy := range engine.trustedProxies {\n\t\tif !strings.Contains(trustedProxy, \"/\") {\n\t\t\tip := parseIP(trustedProxy)\n\t\t\tif ip == nil {\n\t\t\t\treturn cidr, &net.ParseError{Type: \"IP address\", Text: trustedProxy}\n\t\t\t}\n\n\t\t\tswitch len(ip) {\n\t\t\tcase net.IPv4len:\n\t\t\t\ttrustedProxy += \"/32\"\n\t\t\tcase net.IPv6len:\n\t\t\t\ttrustedProxy += \"/128\"\n\t\t\t}\n\t\t}\n\t\t_, cidrNet, err := net.ParseCIDR(trustedProxy)\n\t\tif err != nil {\n\t\t\treturn cidr, err\n\t\t}\n\t\tcidr = append(cidr, cidrNet)\n\t}\n\treturn cidr, nil\n}\n\n// SetTrustedProxies set a list of network origins (IPv4 addresses,\n// IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs) from which to trust\n// request's headers that contain alternative client IP when\n// `(*gin.Engine).ForwardedByClientIP` is `true`. `TrustedProxies`\n// feature is enabled by default, and it also trusts all proxies\n// by default. If you want to disable this feature, use\n// Engine.SetTrustedProxies(nil), then Context.ClientIP() will\n// return the remote address directly.\nfunc (engine *Engine) SetTrustedProxies(trustedProxies []string) error {\n\tengine.trustedProxies = trustedProxies\n\treturn engine.parseTrustedProxies()\n}\n\n// isUnsafeTrustedProxies checks if Engine.trustedCIDRs contains all IPs, it's not safe if it has (returns true)\nfunc (engine *Engine) isUnsafeTrustedProxies() bool {\n\treturn engine.isTrustedProxy(net.ParseIP(\"0.0.0.0\")) || engine.isTrustedProxy(net.ParseIP(\"::\"))\n}\n\n// parseTrustedProxies parse Engine.trustedProxies to Engine.trustedCIDRs\nfunc (engine *Engine) parseTrustedProxies() error {\n\ttrustedCIDRs, err := engine.prepareTrustedCIDRs()\n\tengine.trustedCIDRs = trustedCIDRs\n\treturn err\n}\n\n// isTrustedProxy will check whether the IP address is included in the trusted list according to Engine.trustedCIDRs\nfunc (engine *Engine) isTrustedProxy(ip net.IP) bool {\n\tif engine.trustedCIDRs == nil {\n\t\treturn false\n\t}\n\tfor _, cidr := range engine.trustedCIDRs {\n\t\tif cidr.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// validateHeader will parse X-Forwarded-For header and return the trusted client IP address\nfunc (engine *Engine) validateHeader(header string) (clientIP string, valid bool) {\n\tif header == \"\" {\n\t\treturn \"\", false\n\t}\n\titems := strings.Split(header, \",\")\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tipStr := strings.TrimSpace(items[i])\n\t\tip := net.ParseIP(ipStr)\n\t\tif ip == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// X-Forwarded-For is appended by proxy\n\t\t// Check IPs in reverse order and stop when find untrusted proxy\n\t\tif (i == 0) || (!engine.isTrustedProxy(ip)) {\n\t\t\treturn ipStr, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// parseIP parse a string representation of an IP and returns a net.IP with the\n// minimum byte representation or nil if input is invalid.\nfunc parseIP(ip string) net.IP {\n\tparsedIP := net.ParseIP(ip)\n\n\tif ipv4 := parsedIP.To4(); ipv4 != nil {\n\t\t// return ip in a 4-byte representation\n\t\treturn ipv4\n\t}\n\n\t// return ip in a 16-byte representation or nil\n\treturn parsedIP\n}\n\n// RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests.\n// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunTLS(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving HTTPS on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\terr = http.ListenAndServeTLS(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified unix socket (i.e. a file).\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunUnix(file string) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on unix:/%s\", file)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\tlistener, err := net.Listen(\"unix\", file)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tdefer os.Remove(file)\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified file descriptor.\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunFd(fd int) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on fd@%d\", fd)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd@%d\", fd))\n\tlistener, err := net.FileListener(f)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\terr = engine.RunListener(listener)\n\treturn\n}\n\n// RunListener attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified net.Listener\nfunc (engine *Engine) RunListener(listener net.Listener) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on listener what's bind with address@%s\", listener.Addr())\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// ServeHTTP conforms to the http.Handler interface.\nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tc := engine.pool.Get().(*Context)\n\tc.writermem.reset(w)\n\tc.Request = req\n\tc.reset()\n\n\tengine.handleHTTPRequest(c)\n\n\tengine.pool.Put(c)\n}\n\n// HandleContext re-enters a context that has been rewritten.\n// This can be done by setting c.Request.URL.Path to your new target.\n// Disclaimer: You can loop yourself to deal with this, use wisely.\nfunc (engine *Engine) HandleContext(c *Context) {\n\toldIndexValue := c.index\n\tc.reset()\n\tengine.handleHTTPRequest(c)\n\n\tc.index = oldIndexValue\n}\n\nfunc (engine *Engine) handleHTTPRequest(c *Context) {\n\thttpMethod := c.Request.Method\n\trPath := c.Request.URL.Path\n\tunescape := false\n\tif engine.UseRawPath && len(c.Request.URL.RawPath) > 0 {\n\t\trPath = c.Request.URL.RawPath\n\t\tunescape = engine.UnescapePathValues\n\t}\n\n\tif engine.RemoveExtraSlash {\n\t\trPath = cleanPath(rPath)\n\t}\n\n\t// Find root of the tree for the given HTTP method\n\tt := engine.trees\n\tfor i, tl := 0, len(t); i < tl; i++ {\n\t\tif t[i].method != httpMethod {\n\t\t\tcontinue\n\t\t}\n\t\troot := t[i].root\n\t\t// Find route in tree\n\t\tvalue := root.getValue(rPath, c.params, c.skippedNodes, unescape)\n\t\tif value.params != nil {\n\t\t\tc.Params = *value.params\n\t\t}\n\t\tif value.handlers != nil {\n\t\t\tc.handlers = value.handlers\n\t\t\tc.fullPath = value.fullPath\n\t\t\tc.Next()\n\t\t\tc.writermem.WriteHeaderNow()\n\t\t\treturn\n\t\t}\n\t\tif httpMethod != http.MethodConnect && rPath != \"/\" {\n\t\t\tif value.tsr && engine.RedirectTrailingSlash {\n\t\t\t\tredirectTrailingSlash(c)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif engine.RedirectFixedPath && redirectFixedPath(c, root, engine.RedirectFixedPath) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\tif engine.HandleMethodNotAllowed {\n\t\tfor _, tree := range engine.trees {\n\t\t\tif tree.method == httpMethod {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif value := tree.root.getValue(rPath, nil, c.skippedNodes, unescape); value.handlers != nil {\n\t\t\t\tc.handlers = engine.allNoMethod\n\t\t\t\tserveError(c, http.StatusMethodNotAllowed, default405Body)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tc.handlers = engine.allNoRoute\n\tserveError(c, http.StatusNotFound, default404Body)\n}\n\nvar mimePlain = []string{MIMEPlain}\n\nfunc serveError(c *Context, code int, defaultMessage []byte) {\n\tc.writermem.status = code\n\tc.Next()\n\tif c.writermem.Written() {\n\t\treturn\n\t}\n\tif c.writermem.Status() == code {\n\t\tc.writermem.Header()[\"Content-Type\"] = mimePlain\n\t\t_, err := c.Writer.Write(defaultMessage)\n\t\tif err != nil {\n\t\t\tdebugPrint(\"cannot write message to writer during serve error: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\tc.writermem.WriteHeaderNow()\n}\n\nfunc redirectTrailingSlash(c *Context) {\n\treq := c.Request\n\tp := req.URL.Path\n\tif prefix := path.Clean(c.Request.Header.Get(\"X-Forwarded-Prefix\")); prefix != \".\" {\n\t\tprefix = url.QueryEscape(prefix)\n\t\tprefix = strings.ReplaceAll(prefix, \"%2F\", \"/\")\n\n\t\tp = prefix + \"/\" + req.URL.Path\n\t}\n\treq.URL.Path = p + \"/\"\n\tif length := len(p); length > 1 && p[length-1] == '/' {\n\t\treq.URL.Path = p[:length-1]\n\t}\n\tredirectRequest(c)\n}\n\nfunc redirectFixedPath(c *Context, root *node, trailingSlash bool) bool {\n\treq := c.Request\n\trPath := req.URL.Path\n\n\tif fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok {\n\t\treq.URL.Path = bytesconv.BytesToString(fixedPath)\n\t\tredirectRequest(c)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc redirectRequest(c *Context) {\n\treq := c.Request\n\trPath := req.URL.Path\n\trURL := req.URL.String()\n\n\tcode := http.StatusMovedPermanently // Permanent redirect, request with GET method\n\tif req.Method != http.MethodGet {\n\t\tcode = http.StatusTemporaryRedirect\n\t}\n\tdebugPrint(\"redirecting request %d: %s --> %s\", code, rPath, rURL)\n\thttp.Redirect(c.Writer, req, rURL, code)\n\tc.writermem.WriteHeaderNow()\n}\n", "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype header struct {\n\tKey   string\n\tValue string\n}\n\n// PerformRequest for testing gin router.\nfunc PerformRequest(r http.Handler, method, path string, headers ...header) *httptest.ResponseRecorder {\n\treq := httptest.NewRequest(method, path, nil)\n\tfor _, h := range headers {\n\t\treq.Header.Add(h.Key, h.Value)\n\t}\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\treturn w\n}\n\nfunc testRouteOK(method string, t *testing.T) {\n\tpassed := false\n\tpassedAny := false\n\tr := New()\n\tr.Any(\"/test2\", func(c *Context) {\n\t\tpassedAny = true\n\t})\n\tr.Handle(method, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(r, method, \"/test\")\n\tassert.True(t, passed)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tPerformRequest(r, method, \"/test2\")\n\tassert.True(t, passedAny)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.Handle(method, \"/test_2\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK2(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\tvar methodRoute string\n\tif method == http.MethodPost {\n\t\tmethodRoute = http.MethodGet\n\t} else {\n\t\tmethodRoute = http.MethodPost\n\t}\n\trouter.Handle(methodRoute, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouterMethod(t *testing.T) {\n\trouter := New()\n\trouter.PUT(\"/hey2\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup2\")\n\t})\n\n\trouter.PUT(\"/hey\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"called\")\n\t})\n\n\trouter.PUT(\"/hey3\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup3\")\n\t})\n\n\tw := PerformRequest(router, http.MethodPut, \"/hey\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"called\", w.Body.String())\n}\n\nfunc TestRouterGroupRouteOK(t *testing.T) {\n\ttestRouteOK(http.MethodGet, t)\n\ttestRouteOK(http.MethodPost, t)\n\ttestRouteOK(http.MethodPut, t)\n\ttestRouteOK(http.MethodPatch, t)\n\ttestRouteOK(http.MethodHead, t)\n\ttestRouteOK(http.MethodOptions, t)\n\ttestRouteOK(http.MethodDelete, t)\n\ttestRouteOK(http.MethodConnect, t)\n\ttestRouteOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK(t *testing.T) {\n\ttestRouteNotOK(http.MethodGet, t)\n\ttestRouteNotOK(http.MethodPost, t)\n\ttestRouteNotOK(http.MethodPut, t)\n\ttestRouteNotOK(http.MethodPatch, t)\n\ttestRouteNotOK(http.MethodHead, t)\n\ttestRouteNotOK(http.MethodOptions, t)\n\ttestRouteNotOK(http.MethodDelete, t)\n\ttestRouteNotOK(http.MethodConnect, t)\n\ttestRouteNotOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK2(t *testing.T) {\n\ttestRouteNotOK2(http.MethodGet, t)\n\ttestRouteNotOK2(http.MethodPost, t)\n\ttestRouteNotOK2(http.MethodPut, t)\n\ttestRouteNotOK2(http.MethodPatch, t)\n\ttestRouteNotOK2(http.MethodHead, t)\n\ttestRouteNotOK2(http.MethodOptions, t)\n\ttestRouteNotOK2(http.MethodDelete, t)\n\ttestRouteNotOK2(http.MethodConnect, t)\n\ttestRouteNotOK2(http.MethodTrace, t)\n}\n\nfunc TestRouteRedirectTrailingSlash(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = false\n\trouter.RedirectTrailingSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/path2/\", func(c *Context) {})\n\trouter.POST(\"/path3\", func(c *Context) {})\n\trouter.PUT(\"/path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, \"/path3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, \"/path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api\"})\n\tassert.Equal(t, \"/api/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api/\"})\n\tassert.Equal(t, 200, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../bug#?\"})\n\tassert.Equal(t, \"../../../bug%2523%253F/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"https://gin-gonic.com/#\"})\n\tassert.Equal(t, \"https%3A/gin-gonic.com/%23/https%253A/gin-gonic.com/%2523/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"#bug\"})\n\tassert.Equal(t, \"%23bug/%2523bug/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\trouter.RedirectTrailingSlash = false\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouteRedirectFixedPath(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.RedirectTrailingSlash = false\n\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/Path2\", func(c *Context) {})\n\trouter.POST(\"/PATH3\", func(c *Context) {})\n\trouter.POST(\"/Path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/PATH\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/Path2\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, \"/PATH3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path4\")\n\tassert.Equal(t, \"/Path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL.\nfunc TestRouteParamsByName(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/test/john/smith/is/super/great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL even with extra slashes.\nfunc TestRouteParamsByNameWithExtraSlash(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"//test//john//smith//is//super//great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFile(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\tassert.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFile(\"/result\", f.Name())\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFileFS(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\tassert.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFileFS(\"/result_fs\", filename, Dir(dir, false))\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result_fs\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result_fs\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticListingDir(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", Dir(\"./\", true))\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"gin.go\")\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestHandleHeadToDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticNoListing(t *testing.T) {\n\trouter := New()\n\trouter.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.NotContains(t, w.Body.String(), \"gin.go\")\n}\n\nfunc TestRouterMiddlewareAndStatic(t *testing.T) {\n\trouter := New()\n\tstatic := router.Group(\"/\", func(c *Context) {\n\t\tc.Writer.Header().Add(\"Last-Modified\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"Expires\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"X-GIN\", \"Gin Framework\")\n\t})\n\tstatic.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/gin.go\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"package gin\")\n\t// Content-Type='text/plain; charset=utf-8' when go version <= 1.16,\n\t// else, Content-Type='text/x-go; charset=utf-8'\n\tassert.NotEqual(t, \"\", w.Header().Get(\"Content-Type\"))\n\tassert.NotEqual(t, w.Header().Get(\"Last-Modified\"), \"Mon, 02 Jan 2006 15:04:05 MST\")\n\tassert.Equal(t, \"Mon, 02 Jan 2006 15:04:05 MST\", w.Header().Get(\"Expires\"))\n\tassert.Equal(t, \"Gin Framework\", w.Header().Get(\"x-GIN\"))\n}\n\nfunc TestRouteNotAllowedEnabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"responseText\", w.Body.String())\n\tassert.Equal(t, http.StatusTeapot, w.Code)\n}\n\nfunc TestRouteNotAllowedEnabled2(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\t// add one methodTree to trees\n\trouter.addRoute(http.MethodPost, \"/\", HandlersChain{func(_ *Context) {}})\n\trouter.GET(\"/path2\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodPost, \"/path2\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouteNotAllowedDisabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = false\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"404 page not found\", w.Body.String())\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouterNotFoundWithRemoveExtraSlash(t *testing.T) {\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/../path\", http.StatusOK, \"\"},    // CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"}, // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, \"GET\", tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, fmt.Sprint(w.Header().Get(\"Location\")))\n\t\t}\n\t}\n}\n\nfunc TestRouterNotFound(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/dir/\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/path/\", http.StatusMovedPermanently, \"/path\"},   // TSR -/\n\t\t{\"/dir\", http.StatusMovedPermanently, \"/dir/\"},     // TSR +/\n\t\t{\"/PATH\", http.StatusMovedPermanently, \"/path\"},    // Fixed Case\n\t\t{\"/DIR/\", http.StatusMovedPermanently, \"/dir/\"},    // Fixed Case\n\t\t{\"/PATH/\", http.StatusMovedPermanently, \"/path\"},   // Fixed Case -/\n\t\t{\"/DIR\", http.StatusMovedPermanently, \"/dir/\"},     // Fixed Case +/\n\t\t{\"/../path\", http.StatusMovedPermanently, \"/path\"}, // Without CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"},                 // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, http.MethodGet, tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, fmt.Sprint(w.Header().Get(\"Location\")))\n\t\t}\n\t}\n\n\t// Test custom not found handler\n\tvar notFound bool\n\trouter.NoRoute(func(c *Context) {\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\tnotFound = true\n\t})\n\tw := PerformRequest(router, http.MethodGet, \"/nope\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.True(t, notFound)\n\n\t// Test other method than GET (want 307 instead of 301)\n\trouter.PATCH(\"/path\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodPatch, \"/path/\")\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\tassert.Equal(t, \"map[Location:[/path]]\", fmt.Sprint(w.Header()))\n\n\t// Test special case where no node for the prefix \"/\" exists\n\trouter = New()\n\trouter.GET(\"/a\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodGet, \"/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\t// Reproduction test for the bug of issue #2843\n\trouter = New()\n\trouter.NoRoute(func(c *Context) {\n\t\tif c.Request.RequestURI == \"/login\" {\n\t\t\tc.String(200, \"login\")\n\t\t}\n\t})\n\trouter.GET(\"/logout\", func(c *Context) {\n\t\tc.String(200, \"logout\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/login\")\n\tassert.Equal(t, \"login\", w.Body.String())\n\tw = PerformRequest(router, http.MethodGet, \"/logout\")\n\tassert.Equal(t, \"logout\", w.Body.String())\n}\n\nfunc TestRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\trouter.NoRoute(func(c *Context) {\n\t\tc.String(404, \"non existent\")\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n}\n\nfunc TestRouterStaticFSFileNotFound(t *testing.T) {\n\trouter := New()\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\".\")))\n\n\tassert.NotPanics(t, func() {\n\t\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\t})\n}\n\n// Reproduction test for the bug of issue #1805\nfunc TestMiddlewareCalledOnceByRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\n\t// Middleware must be called just only once by per request.\n\tmiddlewareCalledNum := 0\n\trouter.Use(func(c *Context) {\n\t\tmiddlewareCalledNum++\n\t})\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\n\t// First access\n\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, 1, middlewareCalledNum)\n\n\t// Second access\n\tPerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, 2, middlewareCalledNum)\n}\n\nfunc TestRouteRawPath(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some/Other/Project\", name)\n\t\tassert.Equal(t, \"222\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/222\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteRawPathNoUnescape(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\troute.UnescapePathValues = false\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some%2FOther%2FProject\", name)\n\t\tassert.Equal(t, \"333\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/333\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteServeErrorWithWriteHeader(t *testing.T) {\n\troute := New()\n\troute.Use(func(c *Context) {\n\t\tc.Status(421)\n\t\tc.Next()\n\t})\n\n\tw := PerformRequest(route, http.MethodGet, \"/NotFound\")\n\tassert.Equal(t, 421, w.Code)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestRouteContextHoldsFullPath(t *testing.T) {\n\trouter := New()\n\n\t// Test routes\n\troutes := []string{\n\t\t\"/simple\",\n\t\t\"/project/:name\",\n\t\t\"/\",\n\t\t\"/news/home\",\n\t\t\"/news\",\n\t\t\"/simple-two/one\",\n\t\t\"/simple-two/one-two\",\n\t\t\"/project/:name/build/*params\",\n\t\t\"/project/:name/bui\",\n\t\t\"/user/:id/status\",\n\t\t\"/user/:id\",\n\t\t\"/user/:id/profile\",\n\t}\n\n\tfor _, route := range routes {\n\t\tactualRoute := route\n\t\trouter.GET(route, func(c *Context) {\n\t\t\t// For each defined route context should contain its full path\n\t\t\tassert.Equal(t, actualRoute, c.FullPath())\n\t\t\tc.AbortWithStatus(http.StatusOK)\n\t\t})\n\t}\n\n\tfor _, route := range routes {\n\t\tw := PerformRequest(router, http.MethodGet, route)\n\t\tassert.Equal(t, http.StatusOK, w.Code)\n\t}\n\n\t// Test not found\n\trouter.Use(func(c *Context) {\n\t\t// For not found routes full path is empty\n\t\tassert.Equal(t, \"\", c.FullPath())\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/not-found\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestEngineHandleMethodNotAllowedCornerCase(t *testing.T) {\n\tr := New()\n\tr.HandleMethodNotAllowed = true\n\n\tbase := r.Group(\"base\")\n\tbase.GET(\"/metrics\", handlerTest1)\n\n\tv1 := base.Group(\"v1\")\n\n\tv1.GET(\"/:id/devices\", handlerTest1)\n\tv1.GET(\"/user/:id/groups\", handlerTest1)\n\n\tv1.GET(\"/orgs/:id\", handlerTest1)\n\tv1.DELETE(\"/orgs/:id\", handlerTest1)\n\n\tw := PerformRequest(r, \"GET\", \"/base/v1/user/groups\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n"], "fixing_code": ["// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n\t\"github.com/gin-gonic/gin/render\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\nconst defaultMultipartMemory = 32 << 20 // 32 MB\n\nvar (\n\tdefault404Body = []byte(\"404 page not found\")\n\tdefault405Body = []byte(\"405 method not allowed\")\n)\n\nvar defaultPlatform string\n\nvar defaultTrustedCIDRs = []*net.IPNet{\n\t{ // 0.0.0.0/0 (IPv4)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0},\n\t},\n\t{ // ::/0 (IPv6)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t},\n}\n\n// HandlerFunc defines the handler used by gin middleware as return value.\ntype HandlerFunc func(*Context)\n\n// HandlersChain defines a HandlerFunc slice.\ntype HandlersChain []HandlerFunc\n\n// Last returns the last handler in the chain. i.e. the last handler is the main one.\nfunc (c HandlersChain) Last() HandlerFunc {\n\tif length := len(c); length > 0 {\n\t\treturn c[length-1]\n\t}\n\treturn nil\n}\n\n// RouteInfo represents a request route's specification which contains method and path and its handler.\ntype RouteInfo struct {\n\tMethod      string\n\tPath        string\n\tHandler     string\n\tHandlerFunc HandlerFunc\n}\n\n// RoutesInfo defines a RouteInfo slice.\ntype RoutesInfo []RouteInfo\n\n// Trusted platforms\nconst (\n\t// PlatformGoogleAppEngine when running on Google App Engine. Trust X-Appengine-Remote-Addr\n\t// for determining the client's IP\n\tPlatformGoogleAppEngine = \"X-Appengine-Remote-Addr\"\n\t// PlatformCloudflare when using Cloudflare's CDN. Trust CF-Connecting-IP for determining\n\t// the client's IP\n\tPlatformCloudflare = \"CF-Connecting-IP\"\n)\n\n// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.\n// Create an instance of Engine, by using New() or Default()\ntype Engine struct {\n\tRouterGroup\n\n\t// RedirectTrailingSlash enables automatic redirection if the current route can't be matched but a\n\t// handler for the path with (without) the trailing slash exists.\n\t// For example if /foo/ is requested but a route only exists for /foo, the\n\t// client is redirected to /foo with http status code 301 for GET requests\n\t// and 307 for all other request methods.\n\tRedirectTrailingSlash bool\n\n\t// RedirectFixedPath if enabled, the router tries to fix the current request path, if no\n\t// handle is registered for it.\n\t// First superfluous path elements like ../ or // are removed.\n\t// Afterwards the router does a case-insensitive lookup of the cleaned path.\n\t// If a handle can be found for this route, the router makes a redirection\n\t// to the corrected path with status code 301 for GET requests and 307 for\n\t// all other request methods.\n\t// For example /FOO and /..//Foo could be redirected to /foo.\n\t// RedirectTrailingSlash is independent of this option.\n\tRedirectFixedPath bool\n\n\t// HandleMethodNotAllowed if enabled, the router checks if another method is allowed for the\n\t// current route, if the current request can not be routed.\n\t// If this is the case, the request is answered with 'Method Not Allowed'\n\t// and HTTP status code 405.\n\t// If no other Method is allowed, the request is delegated to the NotFound\n\t// handler.\n\tHandleMethodNotAllowed bool\n\n\t// ForwardedByClientIP if enabled, client IP will be parsed from the request's headers that\n\t// match those stored at `(*gin.Engine).RemoteIPHeaders`. If no IP was\n\t// fetched, it falls back to the IP obtained from\n\t// `(*gin.Context).Request.RemoteAddr`.\n\tForwardedByClientIP bool\n\n\t// AppEngine was deprecated.\n\t// Deprecated: USE `TrustedPlatform` WITH VALUE `gin.PlatformGoogleAppEngine` INSTEAD\n\t// #726 #755 If enabled, it will trust some headers starting with\n\t// 'X-AppEngine...' for better integration with that PaaS.\n\tAppEngine bool\n\n\t// UseRawPath if enabled, the url.RawPath will be used to find parameters.\n\tUseRawPath bool\n\n\t// UnescapePathValues if true, the path value will be unescaped.\n\t// If UseRawPath is false (by default), the UnescapePathValues effectively is true,\n\t// as url.Path gonna be used, which is already unescaped.\n\tUnescapePathValues bool\n\n\t// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.\n\t// See the PR #1817 and issue #1644\n\tRemoveExtraSlash bool\n\n\t// RemoteIPHeaders list of headers used to obtain the client IP when\n\t// `(*gin.Engine).ForwardedByClientIP` is `true` and\n\t// `(*gin.Context).Request.RemoteAddr` is matched by at least one of the\n\t// network origins of list defined by `(*gin.Engine).SetTrustedProxies()`.\n\tRemoteIPHeaders []string\n\n\t// TrustedPlatform if set to a constant of value gin.Platform*, trusts the headers set by\n\t// that platform, for example to determine the client IP\n\tTrustedPlatform string\n\n\t// MaxMultipartMemory value of 'maxMemory' param that is given to http.Request's ParseMultipartForm\n\t// method call.\n\tMaxMultipartMemory int64\n\n\t// UseH2C enable h2c support.\n\tUseH2C bool\n\n\t// ContextWithFallback enable fallback Context.Deadline(), Context.Done(), Context.Err() and Context.Value() when Context.Request.Context() is not nil.\n\tContextWithFallback bool\n\n\tdelims           render.Delims\n\tsecureJSONPrefix string\n\tHTMLRender       render.HTMLRender\n\tFuncMap          template.FuncMap\n\tallNoRoute       HandlersChain\n\tallNoMethod      HandlersChain\n\tnoRoute          HandlersChain\n\tnoMethod         HandlersChain\n\tpool             sync.Pool\n\ttrees            methodTrees\n\tmaxParams        uint16\n\tmaxSections      uint16\n\ttrustedProxies   []string\n\ttrustedCIDRs     []*net.IPNet\n}\n\nvar _ IRouter = (*Engine)(nil)\n\n// New returns a new blank Engine instance without any middleware attached.\n// By default, the configuration is:\n// - RedirectTrailingSlash:  true\n// - RedirectFixedPath:      false\n// - HandleMethodNotAllowed: false\n// - ForwardedByClientIP:    true\n// - UseRawPath:             false\n// - UnescapePathValues:     true\nfunc New() *Engine {\n\tdebugPrintWARNINGNew()\n\tengine := &Engine{\n\t\tRouterGroup: RouterGroup{\n\t\t\tHandlers: nil,\n\t\t\tbasePath: \"/\",\n\t\t\troot:     true,\n\t\t},\n\t\tFuncMap:                template.FuncMap{},\n\t\tRedirectTrailingSlash:  true,\n\t\tRedirectFixedPath:      false,\n\t\tHandleMethodNotAllowed: false,\n\t\tForwardedByClientIP:    true,\n\t\tRemoteIPHeaders:        []string{\"X-Forwarded-For\", \"X-Real-IP\"},\n\t\tTrustedPlatform:        defaultPlatform,\n\t\tUseRawPath:             false,\n\t\tRemoveExtraSlash:       false,\n\t\tUnescapePathValues:     true,\n\t\tMaxMultipartMemory:     defaultMultipartMemory,\n\t\ttrees:                  make(methodTrees, 0, 9),\n\t\tdelims:                 render.Delims{Left: \"{{\", Right: \"}}\"},\n\t\tsecureJSONPrefix:       \"while(1);\",\n\t\ttrustedProxies:         []string{\"0.0.0.0/0\", \"::/0\"},\n\t\ttrustedCIDRs:           defaultTrustedCIDRs,\n\t}\n\tengine.RouterGroup.engine = engine\n\tengine.pool.New = func() any {\n\t\treturn engine.allocateContext(engine.maxParams)\n\t}\n\treturn engine\n}\n\n// Default returns an Engine instance with the Logger and Recovery middleware already attached.\nfunc Default() *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n\tengine.Use(Logger(), Recovery())\n\treturn engine\n}\n\nfunc (engine *Engine) Handler() http.Handler {\n\tif !engine.UseH2C {\n\t\treturn engine\n\t}\n\n\th2s := &http2.Server{}\n\treturn h2c.NewHandler(engine, h2s)\n}\n\nfunc (engine *Engine) allocateContext(maxParams uint16) *Context {\n\tv := make(Params, 0, maxParams)\n\tskippedNodes := make([]skippedNode, 0, engine.maxSections)\n\treturn &Context{engine: engine, params: &v, skippedNodes: &skippedNodes}\n}\n\n// Delims sets template left and right delims and returns an Engine instance.\nfunc (engine *Engine) Delims(left, right string) *Engine {\n\tengine.delims = render.Delims{Left: left, Right: right}\n\treturn engine\n}\n\n// SecureJsonPrefix sets the secureJSONPrefix used in Context.SecureJSON.\nfunc (engine *Engine) SecureJsonPrefix(prefix string) *Engine {\n\tengine.secureJSONPrefix = prefix\n\treturn engine\n}\n\n// LoadHTMLGlob loads HTML files identified by glob pattern\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLGlob(pattern string) {\n\tleft := engine.delims.Left\n\tright := engine.delims.Right\n\ttempl := template.Must(template.New(\"\").Delims(left, right).Funcs(engine.FuncMap).ParseGlob(pattern))\n\n\tif IsDebugging() {\n\t\tdebugPrintLoadTemplate(templ)\n\t\tengine.HTMLRender = render.HTMLDebug{Glob: pattern, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\tengine.SetHTMLTemplate(templ)\n}\n\n// LoadHTMLFiles loads a slice of HTML files\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLFiles(files ...string) {\n\tif IsDebugging() {\n\t\tengine.HTMLRender = render.HTMLDebug{Files: files, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\ttempl := template.Must(template.New(\"\").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFiles(files...))\n\tengine.SetHTMLTemplate(templ)\n}\n\n// SetHTMLTemplate associate a template with HTML renderer.\nfunc (engine *Engine) SetHTMLTemplate(templ *template.Template) {\n\tif len(engine.trees) > 0 {\n\t\tdebugPrintWARNINGSetHTMLTemplate()\n\t}\n\n\tengine.HTMLRender = render.HTMLProduction{Template: templ.Funcs(engine.FuncMap)}\n}\n\n// SetFuncMap sets the FuncMap used for template.FuncMap.\nfunc (engine *Engine) SetFuncMap(funcMap template.FuncMap) {\n\tengine.FuncMap = funcMap\n}\n\n// NoRoute adds handlers for NoRoute. It returns a 404 code by default.\nfunc (engine *Engine) NoRoute(handlers ...HandlerFunc) {\n\tengine.noRoute = handlers\n\tengine.rebuild404Handlers()\n}\n\n// NoMethod sets the handlers called when Engine.HandleMethodNotAllowed = true.\nfunc (engine *Engine) NoMethod(handlers ...HandlerFunc) {\n\tengine.noMethod = handlers\n\tengine.rebuild405Handlers()\n}\n\n// Use attaches a global middleware to the router. i.e. the middleware attached through Use() will be\n// included in the handlers chain for every single request. Even 404, 405, static files...\n// For example, this is the right place for a logger or error management middleware.\nfunc (engine *Engine) Use(middleware ...HandlerFunc) IRoutes {\n\tengine.RouterGroup.Use(middleware...)\n\tengine.rebuild404Handlers()\n\tengine.rebuild405Handlers()\n\treturn engine\n}\n\nfunc (engine *Engine) rebuild404Handlers() {\n\tengine.allNoRoute = engine.combineHandlers(engine.noRoute)\n}\n\nfunc (engine *Engine) rebuild405Handlers() {\n\tengine.allNoMethod = engine.combineHandlers(engine.noMethod)\n}\n\nfunc (engine *Engine) addRoute(method, path string, handlers HandlersChain) {\n\tassert1(path[0] == '/', \"path must begin with '/'\")\n\tassert1(method != \"\", \"HTTP method can not be empty\")\n\tassert1(len(handlers) > 0, \"there must be at least one handler\")\n\n\tdebugPrintRoute(method, path, handlers)\n\n\troot := engine.trees.get(method)\n\tif root == nil {\n\t\troot = new(node)\n\t\troot.fullPath = \"/\"\n\t\tengine.trees = append(engine.trees, methodTree{method: method, root: root})\n\t}\n\troot.addRoute(path, handlers)\n\n\t// Update maxParams\n\tif paramsCount := countParams(path); paramsCount > engine.maxParams {\n\t\tengine.maxParams = paramsCount\n\t}\n\n\tif sectionsCount := countSections(path); sectionsCount > engine.maxSections {\n\t\tengine.maxSections = sectionsCount\n\t}\n}\n\n// Routes returns a slice of registered routes, including some useful information, such as:\n// the http method, path and the handler name.\nfunc (engine *Engine) Routes() (routes RoutesInfo) {\n\tfor _, tree := range engine.trees {\n\t\troutes = iterate(\"\", tree.method, routes, tree.root)\n\t}\n\treturn routes\n}\n\nfunc iterate(path, method string, routes RoutesInfo, root *node) RoutesInfo {\n\tpath += root.path\n\tif len(root.handlers) > 0 {\n\t\thandlerFunc := root.handlers.Last()\n\t\troutes = append(routes, RouteInfo{\n\t\t\tMethod:      method,\n\t\t\tPath:        path,\n\t\t\tHandler:     nameOfFunction(handlerFunc),\n\t\t\tHandlerFunc: handlerFunc,\n\t\t})\n\t}\n\tfor _, child := range root.children {\n\t\troutes = iterate(path, method, routes, child)\n\t}\n\treturn routes\n}\n\n// Run attaches the router to a http.Server and starts listening and serving HTTP requests.\n// It is a shortcut for http.ListenAndServe(addr, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) Run(addr ...string) (err error) {\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\taddress := resolveAddress(addr)\n\tdebugPrint(\"Listening and serving HTTP on %s\\n\", address)\n\terr = http.ListenAndServe(address, engine.Handler())\n\treturn\n}\n\nfunc (engine *Engine) prepareTrustedCIDRs() ([]*net.IPNet, error) {\n\tif engine.trustedProxies == nil {\n\t\treturn nil, nil\n\t}\n\n\tcidr := make([]*net.IPNet, 0, len(engine.trustedProxies))\n\tfor _, trustedProxy := range engine.trustedProxies {\n\t\tif !strings.Contains(trustedProxy, \"/\") {\n\t\t\tip := parseIP(trustedProxy)\n\t\t\tif ip == nil {\n\t\t\t\treturn cidr, &net.ParseError{Type: \"IP address\", Text: trustedProxy}\n\t\t\t}\n\n\t\t\tswitch len(ip) {\n\t\t\tcase net.IPv4len:\n\t\t\t\ttrustedProxy += \"/32\"\n\t\t\tcase net.IPv6len:\n\t\t\t\ttrustedProxy += \"/128\"\n\t\t\t}\n\t\t}\n\t\t_, cidrNet, err := net.ParseCIDR(trustedProxy)\n\t\tif err != nil {\n\t\t\treturn cidr, err\n\t\t}\n\t\tcidr = append(cidr, cidrNet)\n\t}\n\treturn cidr, nil\n}\n\n// SetTrustedProxies set a list of network origins (IPv4 addresses,\n// IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs) from which to trust\n// request's headers that contain alternative client IP when\n// `(*gin.Engine).ForwardedByClientIP` is `true`. `TrustedProxies`\n// feature is enabled by default, and it also trusts all proxies\n// by default. If you want to disable this feature, use\n// Engine.SetTrustedProxies(nil), then Context.ClientIP() will\n// return the remote address directly.\nfunc (engine *Engine) SetTrustedProxies(trustedProxies []string) error {\n\tengine.trustedProxies = trustedProxies\n\treturn engine.parseTrustedProxies()\n}\n\n// isUnsafeTrustedProxies checks if Engine.trustedCIDRs contains all IPs, it's not safe if it has (returns true)\nfunc (engine *Engine) isUnsafeTrustedProxies() bool {\n\treturn engine.isTrustedProxy(net.ParseIP(\"0.0.0.0\")) || engine.isTrustedProxy(net.ParseIP(\"::\"))\n}\n\n// parseTrustedProxies parse Engine.trustedProxies to Engine.trustedCIDRs\nfunc (engine *Engine) parseTrustedProxies() error {\n\ttrustedCIDRs, err := engine.prepareTrustedCIDRs()\n\tengine.trustedCIDRs = trustedCIDRs\n\treturn err\n}\n\n// isTrustedProxy will check whether the IP address is included in the trusted list according to Engine.trustedCIDRs\nfunc (engine *Engine) isTrustedProxy(ip net.IP) bool {\n\tif engine.trustedCIDRs == nil {\n\t\treturn false\n\t}\n\tfor _, cidr := range engine.trustedCIDRs {\n\t\tif cidr.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// validateHeader will parse X-Forwarded-For header and return the trusted client IP address\nfunc (engine *Engine) validateHeader(header string) (clientIP string, valid bool) {\n\tif header == \"\" {\n\t\treturn \"\", false\n\t}\n\titems := strings.Split(header, \",\")\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tipStr := strings.TrimSpace(items[i])\n\t\tip := net.ParseIP(ipStr)\n\t\tif ip == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// X-Forwarded-For is appended by proxy\n\t\t// Check IPs in reverse order and stop when find untrusted proxy\n\t\tif (i == 0) || (!engine.isTrustedProxy(ip)) {\n\t\t\treturn ipStr, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// parseIP parse a string representation of an IP and returns a net.IP with the\n// minimum byte representation or nil if input is invalid.\nfunc parseIP(ip string) net.IP {\n\tparsedIP := net.ParseIP(ip)\n\n\tif ipv4 := parsedIP.To4(); ipv4 != nil {\n\t\t// return ip in a 4-byte representation\n\t\treturn ipv4\n\t}\n\n\t// return ip in a 16-byte representation or nil\n\treturn parsedIP\n}\n\n// RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests.\n// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunTLS(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving HTTPS on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\terr = http.ListenAndServeTLS(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified unix socket (i.e. a file).\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunUnix(file string) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on unix:/%s\", file)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\tlistener, err := net.Listen(\"unix\", file)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tdefer os.Remove(file)\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified file descriptor.\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunFd(fd int) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on fd@%d\", fd)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd@%d\", fd))\n\tlistener, err := net.FileListener(f)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\terr = engine.RunListener(listener)\n\treturn\n}\n\n// RunListener attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified net.Listener\nfunc (engine *Engine) RunListener(listener net.Listener) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on listener what's bind with address@%s\", listener.Addr())\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\")\n\t}\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// ServeHTTP conforms to the http.Handler interface.\nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tc := engine.pool.Get().(*Context)\n\tc.writermem.reset(w)\n\tc.Request = req\n\tc.reset()\n\n\tengine.handleHTTPRequest(c)\n\n\tengine.pool.Put(c)\n}\n\n// HandleContext re-enters a context that has been rewritten.\n// This can be done by setting c.Request.URL.Path to your new target.\n// Disclaimer: You can loop yourself to deal with this, use wisely.\nfunc (engine *Engine) HandleContext(c *Context) {\n\toldIndexValue := c.index\n\tc.reset()\n\tengine.handleHTTPRequest(c)\n\n\tc.index = oldIndexValue\n}\n\nfunc (engine *Engine) handleHTTPRequest(c *Context) {\n\thttpMethod := c.Request.Method\n\trPath := c.Request.URL.Path\n\tunescape := false\n\tif engine.UseRawPath && len(c.Request.URL.RawPath) > 0 {\n\t\trPath = c.Request.URL.RawPath\n\t\tunescape = engine.UnescapePathValues\n\t}\n\n\tif engine.RemoveExtraSlash {\n\t\trPath = cleanPath(rPath)\n\t}\n\n\t// Find root of the tree for the given HTTP method\n\tt := engine.trees\n\tfor i, tl := 0, len(t); i < tl; i++ {\n\t\tif t[i].method != httpMethod {\n\t\t\tcontinue\n\t\t}\n\t\troot := t[i].root\n\t\t// Find route in tree\n\t\tvalue := root.getValue(rPath, c.params, c.skippedNodes, unescape)\n\t\tif value.params != nil {\n\t\t\tc.Params = *value.params\n\t\t}\n\t\tif value.handlers != nil {\n\t\t\tc.handlers = value.handlers\n\t\t\tc.fullPath = value.fullPath\n\t\t\tc.Next()\n\t\t\tc.writermem.WriteHeaderNow()\n\t\t\treturn\n\t\t}\n\t\tif httpMethod != http.MethodConnect && rPath != \"/\" {\n\t\t\tif value.tsr && engine.RedirectTrailingSlash {\n\t\t\t\tredirectTrailingSlash(c)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif engine.RedirectFixedPath && redirectFixedPath(c, root, engine.RedirectFixedPath) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\tif engine.HandleMethodNotAllowed {\n\t\tfor _, tree := range engine.trees {\n\t\t\tif tree.method == httpMethod {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif value := tree.root.getValue(rPath, nil, c.skippedNodes, unescape); value.handlers != nil {\n\t\t\t\tc.handlers = engine.allNoMethod\n\t\t\t\tserveError(c, http.StatusMethodNotAllowed, default405Body)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tc.handlers = engine.allNoRoute\n\tserveError(c, http.StatusNotFound, default404Body)\n}\n\nvar mimePlain = []string{MIMEPlain}\n\nfunc serveError(c *Context, code int, defaultMessage []byte) {\n\tc.writermem.status = code\n\tc.Next()\n\tif c.writermem.Written() {\n\t\treturn\n\t}\n\tif c.writermem.Status() == code {\n\t\tc.writermem.Header()[\"Content-Type\"] = mimePlain\n\t\t_, err := c.Writer.Write(defaultMessage)\n\t\tif err != nil {\n\t\t\tdebugPrint(\"cannot write message to writer during serve error: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\tc.writermem.WriteHeaderNow()\n}\n\nfunc redirectTrailingSlash(c *Context) {\n\treq := c.Request\n\tp := req.URL.Path\n\tif prefix := path.Clean(c.Request.Header.Get(\"X-Forwarded-Prefix\")); prefix != \".\" {\n\t\treg := regexp.MustCompile(\"[^a-zA-Z0-9/-]+\")\n\t\tprefix = reg.ReplaceAllString(prefix, \"\")\n\n\t\tp = prefix + \"/\" + req.URL.Path\n\t}\n\treq.URL.Path = p + \"/\"\n\tif length := len(p); length > 1 && p[length-1] == '/' {\n\t\treq.URL.Path = p[:length-1]\n\t}\n\tredirectRequest(c)\n}\n\nfunc redirectFixedPath(c *Context, root *node, trailingSlash bool) bool {\n\treq := c.Request\n\trPath := req.URL.Path\n\n\tif fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok {\n\t\treq.URL.Path = bytesconv.BytesToString(fixedPath)\n\t\tredirectRequest(c)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc redirectRequest(c *Context) {\n\treq := c.Request\n\trPath := req.URL.Path\n\trURL := req.URL.String()\n\n\tcode := http.StatusMovedPermanently // Permanent redirect, request with GET method\n\tif req.Method != http.MethodGet {\n\t\tcode = http.StatusTemporaryRedirect\n\t}\n\tdebugPrint(\"redirecting request %d: %s --> %s\", code, rPath, rURL)\n\thttp.Redirect(c.Writer, req, rURL, code)\n\tc.writermem.WriteHeaderNow()\n}\n", "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype header struct {\n\tKey   string\n\tValue string\n}\n\n// PerformRequest for testing gin router.\nfunc PerformRequest(r http.Handler, method, path string, headers ...header) *httptest.ResponseRecorder {\n\treq := httptest.NewRequest(method, path, nil)\n\tfor _, h := range headers {\n\t\treq.Header.Add(h.Key, h.Value)\n\t}\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\treturn w\n}\n\nfunc testRouteOK(method string, t *testing.T) {\n\tpassed := false\n\tpassedAny := false\n\tr := New()\n\tr.Any(\"/test2\", func(c *Context) {\n\t\tpassedAny = true\n\t})\n\tr.Handle(method, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(r, method, \"/test\")\n\tassert.True(t, passed)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tPerformRequest(r, method, \"/test2\")\n\tassert.True(t, passedAny)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.Handle(method, \"/test_2\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK2(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\tvar methodRoute string\n\tif method == http.MethodPost {\n\t\tmethodRoute = http.MethodGet\n\t} else {\n\t\tmethodRoute = http.MethodPost\n\t}\n\trouter.Handle(methodRoute, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouterMethod(t *testing.T) {\n\trouter := New()\n\trouter.PUT(\"/hey2\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup2\")\n\t})\n\n\trouter.PUT(\"/hey\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"called\")\n\t})\n\n\trouter.PUT(\"/hey3\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup3\")\n\t})\n\n\tw := PerformRequest(router, http.MethodPut, \"/hey\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"called\", w.Body.String())\n}\n\nfunc TestRouterGroupRouteOK(t *testing.T) {\n\ttestRouteOK(http.MethodGet, t)\n\ttestRouteOK(http.MethodPost, t)\n\ttestRouteOK(http.MethodPut, t)\n\ttestRouteOK(http.MethodPatch, t)\n\ttestRouteOK(http.MethodHead, t)\n\ttestRouteOK(http.MethodOptions, t)\n\ttestRouteOK(http.MethodDelete, t)\n\ttestRouteOK(http.MethodConnect, t)\n\ttestRouteOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK(t *testing.T) {\n\ttestRouteNotOK(http.MethodGet, t)\n\ttestRouteNotOK(http.MethodPost, t)\n\ttestRouteNotOK(http.MethodPut, t)\n\ttestRouteNotOK(http.MethodPatch, t)\n\ttestRouteNotOK(http.MethodHead, t)\n\ttestRouteNotOK(http.MethodOptions, t)\n\ttestRouteNotOK(http.MethodDelete, t)\n\ttestRouteNotOK(http.MethodConnect, t)\n\ttestRouteNotOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK2(t *testing.T) {\n\ttestRouteNotOK2(http.MethodGet, t)\n\ttestRouteNotOK2(http.MethodPost, t)\n\ttestRouteNotOK2(http.MethodPut, t)\n\ttestRouteNotOK2(http.MethodPatch, t)\n\ttestRouteNotOK2(http.MethodHead, t)\n\ttestRouteNotOK2(http.MethodOptions, t)\n\ttestRouteNotOK2(http.MethodDelete, t)\n\ttestRouteNotOK2(http.MethodConnect, t)\n\ttestRouteNotOK2(http.MethodTrace, t)\n}\n\nfunc TestRouteRedirectTrailingSlash(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = false\n\trouter.RedirectTrailingSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/path2/\", func(c *Context) {})\n\trouter.POST(\"/path3\", func(c *Context) {})\n\trouter.PUT(\"/path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, \"/path3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, \"/path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api\"})\n\tassert.Equal(t, \"/api/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api/\"})\n\tassert.Equal(t, 200, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../bug#?\"})\n\tassert.Equal(t, \"//bug//path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"https://gin-gonic.com/#\"})\n\tassert.Equal(t, \"https/gin-goniccom/https/gin-goniccom/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"#bug\"})\n\tassert.Equal(t, \"bug/bug/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/nor-mal/#?a=1\"})\n\tassert.Equal(t, \"/nor-mal/a1/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, 301, w.Code)\n\n\trouter.RedirectTrailingSlash = false\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouteRedirectFixedPath(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.RedirectTrailingSlash = false\n\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/Path2\", func(c *Context) {})\n\trouter.POST(\"/PATH3\", func(c *Context) {})\n\trouter.POST(\"/Path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/PATH\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/Path2\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, \"/PATH3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path4\")\n\tassert.Equal(t, \"/Path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL.\nfunc TestRouteParamsByName(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/test/john/smith/is/super/great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL even with extra slashes.\nfunc TestRouteParamsByNameWithExtraSlash(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"//test//john//smith//is//super//great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFile(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\tassert.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFile(\"/result\", f.Name())\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFileFS(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\tassert.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFileFS(\"/result_fs\", filename, Dir(dir, false))\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result_fs\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result_fs\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticListingDir(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", Dir(\"./\", true))\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"gin.go\")\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestHandleHeadToDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticNoListing(t *testing.T) {\n\trouter := New()\n\trouter.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.NotContains(t, w.Body.String(), \"gin.go\")\n}\n\nfunc TestRouterMiddlewareAndStatic(t *testing.T) {\n\trouter := New()\n\tstatic := router.Group(\"/\", func(c *Context) {\n\t\tc.Writer.Header().Add(\"Last-Modified\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"Expires\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"X-GIN\", \"Gin Framework\")\n\t})\n\tstatic.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/gin.go\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"package gin\")\n\t// Content-Type='text/plain; charset=utf-8' when go version <= 1.16,\n\t// else, Content-Type='text/x-go; charset=utf-8'\n\tassert.NotEqual(t, \"\", w.Header().Get(\"Content-Type\"))\n\tassert.NotEqual(t, w.Header().Get(\"Last-Modified\"), \"Mon, 02 Jan 2006 15:04:05 MST\")\n\tassert.Equal(t, \"Mon, 02 Jan 2006 15:04:05 MST\", w.Header().Get(\"Expires\"))\n\tassert.Equal(t, \"Gin Framework\", w.Header().Get(\"x-GIN\"))\n}\n\nfunc TestRouteNotAllowedEnabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"responseText\", w.Body.String())\n\tassert.Equal(t, http.StatusTeapot, w.Code)\n}\n\nfunc TestRouteNotAllowedEnabled2(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\t// add one methodTree to trees\n\trouter.addRoute(http.MethodPost, \"/\", HandlersChain{func(_ *Context) {}})\n\trouter.GET(\"/path2\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodPost, \"/path2\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouteNotAllowedDisabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = false\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"404 page not found\", w.Body.String())\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouterNotFoundWithRemoveExtraSlash(t *testing.T) {\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/../path\", http.StatusOK, \"\"},    // CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"}, // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, \"GET\", tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, fmt.Sprint(w.Header().Get(\"Location\")))\n\t\t}\n\t}\n}\n\nfunc TestRouterNotFound(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/dir/\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/path/\", http.StatusMovedPermanently, \"/path\"},   // TSR -/\n\t\t{\"/dir\", http.StatusMovedPermanently, \"/dir/\"},     // TSR +/\n\t\t{\"/PATH\", http.StatusMovedPermanently, \"/path\"},    // Fixed Case\n\t\t{\"/DIR/\", http.StatusMovedPermanently, \"/dir/\"},    // Fixed Case\n\t\t{\"/PATH/\", http.StatusMovedPermanently, \"/path\"},   // Fixed Case -/\n\t\t{\"/DIR\", http.StatusMovedPermanently, \"/dir/\"},     // Fixed Case +/\n\t\t{\"/../path\", http.StatusMovedPermanently, \"/path\"}, // Without CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"},                 // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, http.MethodGet, tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, fmt.Sprint(w.Header().Get(\"Location\")))\n\t\t}\n\t}\n\n\t// Test custom not found handler\n\tvar notFound bool\n\trouter.NoRoute(func(c *Context) {\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\tnotFound = true\n\t})\n\tw := PerformRequest(router, http.MethodGet, \"/nope\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.True(t, notFound)\n\n\t// Test other method than GET (want 307 instead of 301)\n\trouter.PATCH(\"/path\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodPatch, \"/path/\")\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\tassert.Equal(t, \"map[Location:[/path]]\", fmt.Sprint(w.Header()))\n\n\t// Test special case where no node for the prefix \"/\" exists\n\trouter = New()\n\trouter.GET(\"/a\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodGet, \"/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\t// Reproduction test for the bug of issue #2843\n\trouter = New()\n\trouter.NoRoute(func(c *Context) {\n\t\tif c.Request.RequestURI == \"/login\" {\n\t\t\tc.String(200, \"login\")\n\t\t}\n\t})\n\trouter.GET(\"/logout\", func(c *Context) {\n\t\tc.String(200, \"logout\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/login\")\n\tassert.Equal(t, \"login\", w.Body.String())\n\tw = PerformRequest(router, http.MethodGet, \"/logout\")\n\tassert.Equal(t, \"logout\", w.Body.String())\n}\n\nfunc TestRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\trouter.NoRoute(func(c *Context) {\n\t\tc.String(404, \"non existent\")\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n}\n\nfunc TestRouterStaticFSFileNotFound(t *testing.T) {\n\trouter := New()\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\".\")))\n\n\tassert.NotPanics(t, func() {\n\t\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\t})\n}\n\n// Reproduction test for the bug of issue #1805\nfunc TestMiddlewareCalledOnceByRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\n\t// Middleware must be called just only once by per request.\n\tmiddlewareCalledNum := 0\n\trouter.Use(func(c *Context) {\n\t\tmiddlewareCalledNum++\n\t})\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\n\t// First access\n\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, 1, middlewareCalledNum)\n\n\t// Second access\n\tPerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, 2, middlewareCalledNum)\n}\n\nfunc TestRouteRawPath(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some/Other/Project\", name)\n\t\tassert.Equal(t, \"222\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/222\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteRawPathNoUnescape(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\troute.UnescapePathValues = false\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some%2FOther%2FProject\", name)\n\t\tassert.Equal(t, \"333\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/333\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteServeErrorWithWriteHeader(t *testing.T) {\n\troute := New()\n\troute.Use(func(c *Context) {\n\t\tc.Status(421)\n\t\tc.Next()\n\t})\n\n\tw := PerformRequest(route, http.MethodGet, \"/NotFound\")\n\tassert.Equal(t, 421, w.Code)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestRouteContextHoldsFullPath(t *testing.T) {\n\trouter := New()\n\n\t// Test routes\n\troutes := []string{\n\t\t\"/simple\",\n\t\t\"/project/:name\",\n\t\t\"/\",\n\t\t\"/news/home\",\n\t\t\"/news\",\n\t\t\"/simple-two/one\",\n\t\t\"/simple-two/one-two\",\n\t\t\"/project/:name/build/*params\",\n\t\t\"/project/:name/bui\",\n\t\t\"/user/:id/status\",\n\t\t\"/user/:id\",\n\t\t\"/user/:id/profile\",\n\t}\n\n\tfor _, route := range routes {\n\t\tactualRoute := route\n\t\trouter.GET(route, func(c *Context) {\n\t\t\t// For each defined route context should contain its full path\n\t\t\tassert.Equal(t, actualRoute, c.FullPath())\n\t\t\tc.AbortWithStatus(http.StatusOK)\n\t\t})\n\t}\n\n\tfor _, route := range routes {\n\t\tw := PerformRequest(router, http.MethodGet, route)\n\t\tassert.Equal(t, http.StatusOK, w.Code)\n\t}\n\n\t// Test not found\n\trouter.Use(func(c *Context) {\n\t\t// For not found routes full path is empty\n\t\tassert.Equal(t, \"\", c.FullPath())\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/not-found\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestEngineHandleMethodNotAllowedCornerCase(t *testing.T) {\n\tr := New()\n\tr.HandleMethodNotAllowed = true\n\n\tbase := r.Group(\"base\")\n\tbase.GET(\"/metrics\", handlerTest1)\n\n\tv1 := base.Group(\"v1\")\n\n\tv1.GET(\"/:id/devices\", handlerTest1)\n\tv1.GET(\"/user/:id/groups\", handlerTest1)\n\n\tv1.GET(\"/orgs/:id\", handlerTest1)\n\tv1.DELETE(\"/orgs/:id\", handlerTest1)\n\n\tw := PerformRequest(r, \"GET\", \"/base/v1/user/groups\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n"], "filenames": ["gin.go", "routes_test.go"], "buggy_code_start_loc": [12, 189], "buggy_code_end_loc": [674, 198], "fixing_code_start_loc": [11, 189], "fixing_code_end_loc": [674, 202], "type": "CWE-20", "message": "Versions of the package github.com/gin-gonic/gin before 1.9.0 are vulnerable to Improper Input Validation by allowing an attacker to use a specially crafted request via the X-Forwarded-Prefix header, potentially leading to cache poisoning.\r\r**Note:** Although this issue does not pose a significant threat on its own it can serve as an input vector for other more impactful vulnerabilities. However, successful exploitation may depend on the server configuration and whether the header is used in the application logic.", "other": {"cve": {"id": "CVE-2023-26125", "sourceIdentifier": "report@snyk.io", "published": "2023-05-04T05:15:09.163", "lastModified": "2023-06-09T18:32:18.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package github.com/gin-gonic/gin before 1.9.0 are vulnerable to Improper Input Validation by allowing an attacker to use a specially crafted request via the X-Forwarded-Prefix header, potentially leading to cache poisoning.\r\r**Note:** Although this issue does not pose a significant threat on its own it can serve as an input vector for other more impactful vulnerabilities. However, successful exploitation may depend on the server configuration and whether the header is used in the application logic."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gin-gonic:gin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.0", "matchCriteriaId": "AEC0CA9C-5051-4183-B191-C1EF30CAAC32"}]}]}], "references": [{"url": "https://github.com/gin-gonic/gin/pull/3500", "source": "report@snyk.io", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/gin-gonic/gin/pull/3503", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/gin-gonic/gin/releases/tag/v1.9.0", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://github.com/t0rchwo0d/gin/commit/fd9f98e70fb4107ee68c783482d231d35e60507b", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMGINGONICGIN-3324285", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/t0rchwo0d/gin/commit/fd9f98e70fb4107ee68c783482d231d35e60507b"}}