{"buggy_code": ["#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#include <memory>\n\n#include \"rutil/Logger.hxx\"\n#include \"resip/stack/ConnectionBase.hxx\"\n#include \"resip/stack/WsConnectionBase.hxx\"\n#include \"resip/stack/SipMessage.hxx\"\n#include \"resip/stack/WsDecorator.hxx\"\n#include \"resip/stack/Cookie.hxx\"\n#include \"resip/stack/WsBaseTransport.hxx\"\n#include \"resip/stack/WsCookieContext.hxx\"\n#include \"resip/stack/WsCookieContextFactory.hxx\"\n#include \"resip/stack/Symbols.hxx\"\n#include \"rutil/WinLeakCheck.hxx\"\n#include \"rutil/SharedPtr.hxx\"\n#include \"rutil/Sha1.hxx\"\n\n#ifdef USE_SSL\n#include \"resip/stack/ssl/Security.hxx\"\n#include \"resip/stack/ssl/TlsConnection.hxx\"\n#include \"rutil/ssl/SHA1Stream.hxx\"\n#endif\n\n#include \"rutil/MD5Stream.hxx\"\n\n#ifdef USE_SIGCOMP\n#include <osc/Stack.h>\n#include <osc/TcpStream.h>\n#include <osc/SigcompMessage.h>\n#include <osc/StateChanges.h>\n#endif\n\nusing namespace resip;\n\n#define RESIPROCATE_SUBSYSTEM Subsystem::TRANSPORT\n\nchar \nConnectionBase::connectionStates[ConnectionBase::MAX][32] = { \"NewMessage\", \"ReadingHeaders\", \"PartialBody\" };\n\n#ifndef RESIP_SIP_MSG_MAX_BYTES\n#define RESIP_SIP_MSG_MAX_BYTES  10485760\n#endif\n\nsize_t\nConnectionBase::messageSizeMax = RESIP_SIP_MSG_MAX_BYTES;\n\nConnectionBase::ConnectionBase(Transport* transport, const Tuple& who, Compression &compression)\n   : mSendPos(0),\n     mTransport(transport),\n     mWho(who),\n     mFailureReason(TransportFailure::None),\n     mFailureSubCode(0),\n     mCompression(compression),\n// NO: #ifdef USE_SIGCOMP // class def doesn't decl members conditionally\n     mSigcompStack(0),\n     mSigcompFramer(0),\n// NO: #endif\n     mSendingTransmissionFormat(Unknown),\n     mReceivingTransmissionFormat(Unknown),\n     mMessage(0),\n     mBuffer(0),\n     mBufferPos(0),\n     mBufferSize(0),\n     mWsFrameExtractor(messageSizeMax),\n     mLastUsed(Timer::getTimeMs()),\n     mConnState(NewMessage)\n{\n   DebugLog (<< \"ConnectionBase::ConnectionBase, who: \" << mWho << \" \" << this);\n#ifdef USE_SIGCOMP\n   if (mCompression.isEnabled())\n   {\n      DebugLog (<< \"Compression enabled for connection: \" << this);\n      mSigcompStack = new osc::Stack(mCompression.getStateHandler());\n      mCompression.addCompressorsToStack(mSigcompStack);\n   }\n   else\n   {\n      DebugLog (<< \"Compression disabled for connection: \" << this);\n   }\n#else\n   DebugLog (<< \"No compression library available: \" << this);\n#endif\n\n   if(mTransport) \n   {\n      mWho.mTransportKey = mTransport->getKey();\n   }\n}\n\nConnectionBase::~ConnectionBase()\n{\n   if(mTransport)\n   {\n      mTransport->flowTerminated(mWho);\n   }\n\n   while (!mOutstandingSends.empty())\n   {\n      SendData* sendData = mOutstandingSends.front();\n      mTransport->fail(sendData->transactionId,\n         mFailureReason ? mFailureReason : TransportFailure::ConnectionUnknown,\n         mFailureSubCode);\n      delete sendData;\n      mOutstandingSends.pop_front();\n   }\n   delete [] mBuffer;\n   delete mMessage;\n#ifdef USE_SIGCOMP\n   delete mSigcompStack;\n#endif\n\n   DebugLog (<< \"ConnectionBase::~ConnectionBase \" << this);\n}\n\nvoid\nConnectionBase::setFailureReason(TransportFailure::FailureReason failReason, int subCode)\n{\n   if ( failReason > mFailureReason )\n   {\n      mFailureReason = failReason;\n      mFailureSubCode = subCode;\n   }\n}\n\nFlowKey\nConnectionBase::getFlowKey() const\n{\n   return mWho.mFlowKey;\n}\n\nbool\nConnectionBase::preparseNewBytes(int bytesRead)\n{\n   DebugLog(<< \"In State: \" << connectionStates[mConnState]);\n   \n  start:   // If there is an overhang come back here, effectively recursing\n   \n   switch(mConnState)\n   {\n      case NewMessage:\n      {\n         if (strncmp(mBuffer + mBufferPos, Symbols::CRLFCRLF, 4) == 0)\n         {\n            DebugLog(<< \"Got incoming double-CRLF keepalive (aka ping).\");\n            mBufferPos += 4;\n            bytesRead -= 4;\n            onDoubleCRLF();\n            if (bytesRead)\n            {\n               goto start;\n            }\n            else\n            {\n               delete [] mBuffer;\n               mBuffer = 0;\n               return true;\n            }\n         }\n         else if (strncmp(mBuffer + mBufferPos, Symbols::CRLF, 2) == 0)\n         {\n            //DebugLog(<< \"Got incoming CRLF keepalive response (aka pong).\");\n            mBufferPos += 2;\n            bytesRead -= 2;\n            onSingleCRLF();\n            if (bytesRead)\n            {\n               goto start;\n            }\n            else\n            {\n               delete [] mBuffer;\n               mBuffer = 0;\n               return true;\n            }\n         }\n\n         resip_assert(mTransport);\n         mMessage = new SipMessage(&mTransport->getTuple());\n         \n         DebugLog(<< \"ConnectionBase::process setting source \" << mWho);\n         mMessage->setSource(mWho);\n         mMessage->setTlsDomain(mTransport->tlsDomain());\n\n#ifdef USE_SSL\n         // Set TlsPeerName if message is from TlsConnection\n         TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n         if(tlsConnection)\n         {\n            std::list<Data> peerNameList;\n            tlsConnection->getPeerNames(peerNameList);\n            mMessage->setTlsPeerNames(peerNameList);\n         }\n#endif\n         mMsgHeaderScanner.prepareForMessage(mMessage);\n         // Fall through to the next case.\n      }\n      case ReadingHeaders:\n      {\n         unsigned int chunkLength = (unsigned int)mBufferPos + bytesRead;\n         char *unprocessedCharPtr;\n         MsgHeaderScanner::ScanChunkResult scanChunkResult =\n            mMsgHeaderScanner.scanChunk(mBuffer,\n                                        chunkLength,\n                                        &unprocessedCharPtr);\n         if (scanChunkResult == MsgHeaderScanner::scrError)\n         {\n            //.jacob. Not a terribly informative warning.\n            WarningLog(<< \"Discarding preparse!\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         if (mMsgHeaderScanner.getHeaderCount() > 1024)\n         {\n            WarningLog(<< \"Discarding preparse; too many headers\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         unsigned int numUnprocessedChars = \n            (unsigned int)((mBuffer + chunkLength) - unprocessedCharPtr);\n\n         if(numUnprocessedChars > ConnectionBase::ChunkSize &&\n            scanChunkResult == MsgHeaderScanner::scrNextChunk)\n         {\n            WarningLog(<< \"Discarding preparse; header-field-value (or \"\n                        \"header name) too long\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         if(numUnprocessedChars==chunkLength)\n         {\n            // .bwc. MsgHeaderScanner wasn't able to parse anything useful;\n            // don't bother mMessage yet, but make more room in mBuffer.\n            size_t size = numUnprocessedChars*3/2;\n            if (size < ConnectionBase::ChunkSize)\n            {\n               size = ConnectionBase::ChunkSize;\n            }\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=MsgHeaderScanner::allocateBuffer((int)size);\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n               return false;\n            }\n            memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n            delete [] mBuffer;\n            mBuffer = newBuffer;\n            mBufferPos = numUnprocessedChars;\n            mBufferSize = size;\n            mConnState = ReadingHeaders;\n            return true;\n         }\n\n         mMessage->addBuffer(mBuffer);\n         mBuffer=0;\n\n         if (scanChunkResult == MsgHeaderScanner::scrNextChunk)\n         {\n            // Message header is incomplete...\n            if (numUnprocessedChars == 0)\n            {\n               // ...but the chunk is completely processed.\n               //.jacob. I've discarded the \"assigned\" concept.\n               //DebugLog(<< \"Data assigned, not fragmented, not complete\");\n               try\n               {\n                  mBuffer = MsgHeaderScanner::allocateBuffer(ChunkSize);\n               }\n               catch(std::bad_alloc&)\n               {\n                  ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n                  return false;\n               }\n               mBufferPos = 0;\n               mBufferSize = ChunkSize;\n            }\n            else\n            {\n               // ...but some of the chunk must be shifted into the next one.\n               size_t size = numUnprocessedChars*3/2;\n               if (size < ConnectionBase::ChunkSize)\n               {\n                  size = ConnectionBase::ChunkSize;\n               }\n               char* newBuffer = 0;\n               try\n               {\n                  newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n               }\n               catch(std::bad_alloc&)\n               {\n                  ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n                  return false;\n               }\n               memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n               mBuffer = newBuffer;\n               mBufferPos = numUnprocessedChars;\n               mBufferSize = size;\n            }\n            mConnState = ReadingHeaders;\n         }\n         else\n         {\n            size_t contentLength = 0;\n            \n            try\n            {\n               // The message header is complete.\n               contentLength=mMessage->const_header(h_ContentLength).value();\n            }\n            catch(resip::BaseException& e)  // Could be SipMessage::Exception or ParseException\n            {\n               WarningLog(<<\"Malformed Content-Length in connection-based transport\"\n                           \". Not much we can do to fix this.  \" << e);\n               // .bwc. Bad Content-Length. We are hosed.\n               delete mMessage;\n               mMessage = 0;\n               mBuffer = 0;\n               // .bwc. mMessage just took ownership of mBuffer, so we don't\n               // delete it here. We do zero it though, for completeness.\n               //.jacob. Shouldn't the state also be set here?\n               return false;\n            }\n            \n            if(contentLength > messageSizeMax || contentLength < 0)\n            {\n               WarningLog(<<\"Content-Length in connection-based \"\n                           \"transport exceeds maximum \" << messageSizeMax);\n               delete mMessage;\n               mMessage = 0;\n               mBuffer = 0;\n               // .bwc. mMessage just took ownership of mBuffer, so we don't\n               // delete it here. We do zero it though, for completeness.\n               //.jacob. Shouldn't the state also be set here?\n               return false;\n            }\n\n            if (numUnprocessedChars < contentLength)\n            {\n               // The message body is incomplete.\n               DebugLog(<< \"partial body received\");\n               size_t newSize=resipMin(resipMax((size_t)numUnprocessedChars*3/2,\n                                             (size_t)ConnectionBase::ChunkSize),\n                                    contentLength);\n               char* newBuffer = MsgHeaderScanner::allocateBuffer((int)newSize);\n               memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n               mBufferPos = numUnprocessedChars;\n               mBufferSize = newSize;\n               mBuffer = newBuffer;\n               \n               mConnState = PartialBody;\n            }\n            else\n            {\n               // Do this stuff BEFORE we kick the message out the door.\n               // Remember, deleting or passing mMessage on invalidates our\n               // buffer!\n               int overHang = numUnprocessedChars - (int)contentLength;\n\n               mConnState = NewMessage;\n               mBuffer = 0;\n               if (overHang > 0) \n               {\n                  // The next message has been partially read.\n                  size_t size = overHang*3/2;\n                  if (size < ConnectionBase::ChunkSize)\n                  {\n                     size = ConnectionBase::ChunkSize;\n                  }\n                  char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                  memcpy(newBuffer,\n                         unprocessedCharPtr + contentLength,\n                         overHang);\n                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               // The message body is complete.\n               mMessage->setBody(unprocessedCharPtr, (UInt32)contentLength);\n               CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n               if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                     || (b==CongestionManager::REJECTING_NEW_WORK\n                        && mMessage->isRequest()))\n               {\n                  UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n                  // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n                  // requests but not responses ( ?bwc? is this right for ACK?). \n                  // If we are REJECTING_NON_ESSENTIAL, \n                  // we reject all incoming work, since losing something from the \n                  // wire will not cause instability or leaks (see \n                  // CongestionManager.hxx)\n                  \n                  // .bwc. This handles all appropriate checking for whether\n                  // this is a response or an ACK.\n                  std::auto_ptr<SendData> tryLater(transport()->make503(*mMessage, expectedWait/1000));\n                  if(tryLater.get())\n                  {\n                     transport()->send(tryLater);\n                  }\n                  delete mMessage; // dropping message due to congestion\n                  mMessage = 0;\n               }\n               else if (!transport()->basicCheck(*mMessage))\n               {\n                  delete mMessage;\n                  mMessage = 0;\n               }\n               else\n               {\n                  Transport::stampReceived(mMessage);\n                  DebugLog(<< \"##Connection: \" << *this << \" received: \" << *mMessage);\n                  resip_assert( mTransport );\n                  mTransport->pushRxMsgUp(mMessage);\n                  mMessage = 0;\n               }\n\n               if (overHang > 0) \n               {\n                  goto start;\n               }\n            }\n         }\n         break;\n      }\n      case PartialBody:\n      {\n         size_t contentLength = 0;\n\n         try\n         {\n             contentLength = mMessage->const_header(h_ContentLength).value();\n         }\n         catch(resip::BaseException& e)  // Could be SipMessage::Exception or ParseException\n         {\n            WarningLog(<<\"Malformed Content-Length in connection-based transport\"\n                        \". Not much we can do to fix this. \" << e);\n            // .bwc. Bad Content-Length. We are hosed.\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            //.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos == contentLength)\n         {\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mBuffer=0;\n            // .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            // if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n                     && mMessage->isRequest()))\n            {\n               UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n               // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n               // requests but not responses ( ?bwc? is this right for ACK?). \n               // If we are REJECTING_NON_ESSENTIAL, \n               // we reject all incoming work, since losing something from the \n               // wire will not cause instability or leaks (see \n               // CongestionManager.hxx)\n               \n               // .bwc. This handles all appropriate checking for whether\n               // this is a response or an ACK.\n               std::auto_ptr<SendData> tryLater = transport()->make503(*mMessage, expectedWait/1000);\n               if(tryLater.get())\n               {\n                  transport()->send(tryLater);\n               }\n               delete mMessage; // dropping message due to congestion\n               mMessage = 0;\n            }\n            else if (!transport()->basicCheck(*mMessage))\n            {\n               delete mMessage;\n               mMessage = 0;\n            }\n            else\n            {\n               DebugLog(<< \"##ConnectionBase: \" << *this << \" received: \" << *mMessage);\n\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            mConnState = NewMessage;\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            // .bwc. We've filled our buffer; go ahead and make more room.\n            size_t newSize = resipMin(mBufferSize*3/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer while receiving body!\");\n               return false;\n            }\n            memcpy(newBuffer, mBuffer, mBufferSize);\n            mBufferSize=newSize;\n            delete [] mBuffer;\n            mBuffer = newBuffer;\n         }\n         break;\n      }\n      default:\n         resip_assert(0);\n   }\n   return true;\n}\n\nvoid\nConnectionBase::wsParseCookies(CookieList& cookieList, const SipMessage* message)\n{\n   Data name;\n   Data value;\n   StringCategories::const_iterator it = message->header(h_Cookies).begin();\n   for (; it != message->header(h_Cookies).end(); ++it)\n   {\n      ParseBuffer pb((*it).value());\n      while(!pb.eof())\n      {\n         const char* anchor =  pb.skipWhitespace();\n\n         pb.skipToChar(Symbols::EQUALS[0]);\n         pb.data(name, anchor);\n\n         anchor = pb.skipChar(Symbols::EQUALS[0]);\n         if(*(pb.position()) == Symbols::DOUBLE_QUOTE[0])\n         {\n            anchor = pb.skipChar(Symbols::DOUBLE_QUOTE[0]);\n            pb.skipToChar(Symbols::DOUBLE_QUOTE[0]);\n            pb.data(value, anchor);\n            pb.skipChar(Symbols::DOUBLE_QUOTE[0]);\n         }\n         else\n         {\n            pb.skipToOneOf(Symbols::SEMI_COLON, ParseBuffer::Whitespace);\n            pb.data(value, anchor);\n         }\n\n         Cookie cookie(name, value);\n         cookieList.push_back(cookie);\n         DebugLog(<< \"Cookie: \" << cookie);\n\n         if(!pb.eof() && *(pb.position()) == Symbols::SEMI_COLON[0])\n         {\n            pb.skipChar(Symbols::SEMI_COLON[0]);\n         }\n\n         pb.skipWhitespace();\n      }\n   }\n}\n\n/*\n * Returns true if handshake complete, false if more bytes needed\n * Sets dropConnection = true if an error occurs\n */\nbool\nConnectionBase::wsProcessHandshake(int bytesRead, bool &dropConnection)\n{\n   mConnState = WebSocket;\n   dropConnection = false;\n\n   if(mBufferPos + bytesRead > messageSizeMax)\n   {\n      WarningLog(<<\"Too many bytes received during WS handshake, dropping connection.  Max message size = \" << messageSizeMax);\n      dropConnection = true;\n      return false;\n   }\n\n   resip_assert(mTransport);\n   mMessage = new SipMessage(&mTransport->getTuple());\n   resip_assert(mMessage);\n\n   mMessage->setSource(mWho);   \n   mMessage->setTlsDomain(mTransport->tlsDomain());\n\n   if (!scanMsgHeader(bytesRead)) \n   {\n      return false;\n   }\n\n   try\n   {\n      WsConnectionBase* wsConnectionBase = dynamic_cast<WsConnectionBase*>(this);\n      CookieList cookieList;\n      if(wsConnectionBase)\n      {\n         SharedPtr<WsCookieContext> wsCookieContext((WsCookieContext*)0);\n         if (mMessage->exists(h_Cookies))\n         {\n            WsBaseTransport* wst = dynamic_cast<WsBaseTransport*>(mTransport);\n            resip_assert(wst);\n            try\n            {\n               wsParseCookies(cookieList, mMessage);\n               wsConnectionBase->setCookies(cookieList);\n               // Use of resip WsCookieContext capabilities is not mandatory,\n               // only try to use it if cookieContextFactory is available\n               if(wst->cookieContextFactory().get())\n               {\n                  Uri& requestUri = mMessage->header(h_RequestLine).uri();\n                  wsCookieContext = wst->cookieContextFactory()->makeCookieContext(cookieList, requestUri);\n                  wsConnectionBase->setWsCookieContext(wsCookieContext);\n               }\n            }\n            catch(ParseException& ex)\n            {\n               WarningLog(<<\"Failed to parse cookies into WsCookieContext: \" << ex);\n            }\n         }\n         SharedPtr<WsConnectionValidator> wsConnectionValidator = wsConnectionBase->connectionValidator();\n         if(wsConnectionValidator &&\n            (!wsCookieContext.get() || !wsConnectionValidator->validateConnection(*wsCookieContext)))\n         {\n            ErrLog(<<\"WebSocket cookie validation failed, dropping connection\");\n            // FIXME: should send back a HTTP error code:\n            //   400 if the cookie was not in the right syntax\n            //   403 if the cookie was well formed but rejected\n            //       due to expiry or a bad HMAC\n            delete mMessage;\n            mMessage = 0;\n            mBufferPos = 0;\n            dropConnection = true;\n            return false;\n         }\n      }\n\n      std::auto_ptr<Data> wsResponsePtr = makeWsHandshakeResponse();\n\n      if (wsResponsePtr.get())\n      {\n         DebugLog (<< \"WebSocket upgrade accepted, cookie count = \" << cookieList.size());\n\n         mOutstandingSends.push_back(new SendData(\n                  who(),\n                  *wsResponsePtr.get(),\n                  Data::Empty,\n                  Data::Empty,\n                  true));\n      }\n      else\n      {\n         ErrLog(<<\"Failed to parse WebSocket initialization request\");\n         delete mMessage;\n         mMessage = 0;\n         mBufferPos = 0;\n         dropConnection = true;\n         return false;\n      }\n   }\n   catch(resip::ParseException& e)\n   {\n      ErrLog(<<\"Cannot auth request is missing \" << e);\n      delete mMessage;\n      mMessage = 0;\n      mBufferPos = 0;\n      dropConnection = true;\n      return false;\n   }\n\n   delete mMessage;\n   mMessage=0;\n   mBufferPos = 0;\n\n   return true;\n}\n\nbool\nConnectionBase::scanMsgHeader(int bytesRead)\n{\n   mMsgHeaderScanner.prepareForMessage(mMessage);\n   char *unprocessedCharPtr;\n   MsgHeaderScanner::ScanChunkResult scanResult = mMsgHeaderScanner.scanChunk(mBuffer, mBufferPos + bytesRead, &unprocessedCharPtr);\n   if (scanResult != MsgHeaderScanner::scrEnd)\n   {\n      if(scanResult != MsgHeaderScanner::scrNextChunk)\n      {\n         StackLog(<<\"Failed to parse message, more bytes needed\");\n         StackLog(<< Data(mBuffer, bytesRead));\n      }\n      delete mMessage;\n      mMessage=0;\n      mBufferPos += bytesRead;\n      return false;\n   }\n   return true;\n}\n\nstd::auto_ptr<Data>\nConnectionBase::makeWsHandshakeResponse()\n{\n   std::auto_ptr<Data> responsePtr(0);\n   if(isUsingSecWebSocketKey())\n   {\n      responsePtr.reset(new Data(\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"Connection: Upgrade\\r\\n\"\n         \"Sec-WebSocket-Protocol: sip\\r\\n\"));\n\n      // Assuming that OpenSSL implementation of SHA1 is more effient than our internal one\n#ifdef USE_SSL\n      SHA1Stream wsSha1Stream;\n      wsSha1Stream << (mMessage->const_header(h_SecWebSocketKey).value() + Symbols::WebsocketMagicGUID);\n      Data wsAcceptKey = wsSha1Stream.getBin(160).base64encode();\n#else\n      SHA1 sha1;\n      sha1.update(mMessage->const_header(h_SecWebSocketKey).value().c_str());\n      sha1.update(Symbols::WebsocketMagicGUID);\n      Data wsAcceptKey = sha1.finalBin().base64encode();\n#endif\n      *responsePtr += \"Sec-WebSocket-Accept: \" + wsAcceptKey + \"\\r\\n\\r\\n\";\n   }\n   else if(isUsingDeprecatedSecWebSocketKeys())\n   {\n      ErrLog(<<\"WS client wants to use depracated protocol version, unsupported\");\n   }\n   else\n   {\n      ErrLog(<<\"No SecWebSocketKey header\");\n   }\n   return responsePtr;\n}\n\nbool ConnectionBase::isUsingDeprecatedSecWebSocketKeys()\n{\n   resip_assert(mMessage);\n   return mMessage->exists(h_SecWebSocketKey1) &&\n      mMessage->exists(h_SecWebSocketKey2);\n}\n\nbool ConnectionBase::isUsingSecWebSocketKey()\n{\n   resip_assert(mMessage);\n   return mMessage->exists(h_SecWebSocketKey);\n}\n\nbool\nConnectionBase::wsProcessData(int bytesRead)\n{\n   bool dropConnection = false;\n   // Always consumes the whole buffer:\n   std::auto_ptr<Data> msg = mWsFrameExtractor.processBytes((UInt8*)mBuffer, bytesRead, dropConnection);\n\n   while(msg.get())\n   {\n      // mWsBuffer should now contain a discrete SIP message, let the\n      // stack go to work on it\n\n      if(msg->size() == 4 && memcmp(msg->data(), \"\\r\\n\\r\\n\", 4) == 0)\n      {\n         // sending a keep alive reply now\n         StackLog(<<\"got a SIP ping embedded in WebSocket frame, replying\");\n         onDoubleCRLF();\n         msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);\n         continue;\n      }\n\n      resip_assert(mTransport);\n      mMessage = new SipMessage(&mTransport->getTuple());\n\n      mMessage->setSource(mWho);\n      mMessage->setTlsDomain(mTransport->tlsDomain());\n\n#ifdef USE_SSL\n      // Set TlsPeerName if message is from TlsConnection\n      TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n      if(tlsConnection)\n      {\n         std::list<Data> peerNameList;\n         tlsConnection->getPeerNames(peerNameList);\n         mMessage->setTlsPeerNames(peerNameList);\n      }\n#endif\n\n      WsConnectionBase *wsConnectionBase = dynamic_cast<WsConnectionBase *>(this);\n      if (wsConnectionBase)\n      {\n         mMessage->setWsCookies(wsConnectionBase->getCookies());\n         mMessage->setWsCookieContext(wsConnectionBase->getWsCookieContext());\n      }\n\n      Data::size_type msg_len = msg->size();\n      // cast permitted, as it is borrowed:\n      char *sipBuffer = (char *)msg->data();\n      mMessage->addBuffer(sipBuffer);\n      mMsgHeaderScanner.prepareForMessage(mMessage);\n      char *unprocessedCharPtr;\n      if (mMsgHeaderScanner.scanChunk(sipBuffer,\n                                 msg_len,\n                                 &unprocessedCharPtr) !=\n                    MsgHeaderScanner::scrEnd)\n      {\n         StackLog(<<\"Scanner rejecting WebSocket SIP message as unparsable, length = \" << msg_len);\n         StackLog(<< Data(sipBuffer, msg_len));\n         delete mMessage;\n         mMessage=0;\n      }\n\n      unsigned int used = unprocessedCharPtr - sipBuffer;\n      if (mMessage && (used < msg_len))\n      {\n         mMessage->setBody(sipBuffer+used, msg_len-used);\n      }\n\n      if (mMessage && !transport()->basicCheck(*mMessage))\n      {\n         delete mMessage;\n         mMessage = 0;\n      }\n\n      if (mMessage)\n      {\n         Transport::stampReceived(mMessage);\n         resip_assert( mTransport );\n         mTransport->pushRxMsgUp(mMessage);\n         mMessage = 0;\n      }\n      else\n      {\n         // Something wrong...\n         ErrLog(<< \"We don't have a valid SIP message, maybe drop the connection?\");\n      }\n      msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);\n   }\n\n   if(dropConnection)\n   {\n      return false;\n   }\n\n   return true;\n}\n\n#ifdef USE_SIGCOMP\nvoid\nConnectionBase::decompressNewBytes(int bytesRead)\n{\n  mConnState = SigComp;\n\n  if (!mSigcompFramer)\n  {\n    mSigcompFramer = new osc::TcpStream();\n  }\n\n  mSigcompFramer->addData(mBuffer, bytesRead);\n  size_t bytesUncompressed;\n  osc::StateChanges *sc = 0;\n  char *uncompressed = new char[65536];\n  while ((bytesUncompressed = mSigcompStack->uncompressMessage(\n                *mSigcompFramer, uncompressed, 65536, sc)) > 0)\n  {\n    DebugLog (<< \"Uncompressed Connection-oriented message\");\n    mMessage = new SipMessage(mWho.transport);\n\n    mMessage->setSource(mWho);\n    mMessage->setTlsDomain(mWho.transport->tlsDomain());\n\n#ifdef USE_SSL\n    // Set TlsPeerName if message is from TlsConnection\n    TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n    if(tlsConnection)\n    {\n       std::list<Data> peerNameList;\n       tlsConnection->getPeerNames(peerNameList);\n       mMessage->setTlsPeerNames(peerNameList);\n    }\n#endif\n\n    char *sipBuffer = new char[bytesUncompressed];\n    memmove(sipBuffer, uncompressed, bytesUncompressed);\n    mMessage->addBuffer(sipBuffer);\n    mMsgHeaderScanner.prepareForMessage(mMessage);\n    char *unprocessedCharPtr;\n    if (mMsgHeaderScanner.scanChunk(sipBuffer,\n                                    bytesUncompressed,\n                                    &unprocessedCharPtr) !=\n        MsgHeaderScanner::scrEnd)\n    {\n       StackLog(<<\"Scanner rejecting compressed message as unparsable\");\n       StackLog(<< Data(sipBuffer, bytesUncompressed));\n       delete mMessage;\n       mMessage=0;\n    }\n  \n    unsigned int used = unprocessedCharPtr - sipBuffer;\n    if (mMessage && (used < bytesUncompressed))\n    {\n      mMessage->setBody(sipBuffer+used, bytesUncompressed-used);\n    }\n\n    if (mMessage && !transport()->basicCheck(*mMessage))\n    {\n      delete mMessage;\n      mMessage = 0;\n    }\n\n    if (mMessage)\n    {\n      Transport::stampReceived(mMessage);\n      // If the message made it this far, we should let it store\n      // SigComp state: extract the compartment ID.\n      const Via &via = mMessage->const_header(h_Vias).front();\n      if (mMessage->isRequest())\n      {\n        // For requests, the compartment ID is read out of the\n        // top via header field; if not present, we use the\n        // TCP connection for identification purposes.\n        if (via.exists(p_sigcompId))\n        {\n            Data compId = via.param(p_sigcompId);\n            if(!compId.empty())\n            {\n                mSigcompStack->provideCompartmentId(sc, compId.data(), compId.size());\n            }\n        }\n        else\n        {\n          mSigcompStack->provideCompartmentId(sc, this, sizeof(this));\n        }\n      }\n      else\n      {\n        // For responses, the compartment ID is supposed to be\n        // the same as the compartment ID of the request. We\n        // *could* dig down into the transaction layer to try to\n        // figure this out, but that's a royal pain, and a rather\n        // severe layer violation. In practice, we're going to ferret\n        // the ID out of the the Via header field, which is where we\n        // squirreled it away when we sent this request in the first place.\n        Data compId = via.param(p_branch).getSigcompCompartment();\n        if(!compId.empty())\n        {\n           mSigcompStack->provideCompartmentId(sc, compId.data(), compId.size());\n        }\n      }\n      resip_assert( mTransport );\n      mTransport->pushRxMsgUp(mMessage);\n      mMessage = 0;\n      sc = 0;\n    }\n    else\n    {\n      delete sc;\n      sc = 0;\n    }\n  }\n  delete [] uncompressed;\n\n  // If there was a decompression failure, let the other side know.\n  osc::SigcompMessage *nack = mSigcompStack->getNack();\n  if (nack)\n  {\n    if (mSendingTransmissionFormat == Compressed)\n    {\n      // !bwc! We are not telling anyone that we're interested in having our\n      // FD put in the writable set...\n      mOutstandingSends.push_back(new SendData(\n                   who(),\n                   Data(nack->getStreamMessage(), nack->getStreamLength()),\n                   Data::Empty,\n                   Data::Empty,\n                   true));\n    }\n    else\n    {\n      delete nack;\n    }\n  }\n}\n#endif\n            \nstd::pair<char*, size_t> \nConnectionBase::getWriteBuffer()\n{\n   if (mConnState == NewMessage)\n   {\n      if (!mBuffer)\n      {\n         DebugLog (<< \"Creating buffer for \" << *this);\n\n         mBuffer = MsgHeaderScanner::allocateBuffer(ConnectionBase::ChunkSize);\n         mBufferSize = ConnectionBase::ChunkSize;\n      }\n      mBufferPos = 0;\n   }\n   return getCurrentWriteBuffer();\n}\n\nstd::pair<char*, size_t> \nConnectionBase::getCurrentWriteBuffer()\n{\n   return std::make_pair(mBuffer + mBufferPos, mBufferSize - mBufferPos);\n}\n\nchar*\nConnectionBase::getWriteBufferForExtraBytes(int currentPos, int extraBytes)\n{\n   if (currentPos > 0 && extraBytes > 0)\n   {\n      if ((currentPos + extraBytes) > mBufferSize)\n      {\n         mBufferSize = currentPos + extraBytes;\n         char* buffer = MsgHeaderScanner::allocateBuffer((int)mBufferSize);\n         memcpy(buffer, mBuffer, currentPos);\n         delete[] mBuffer;\n         mBuffer = buffer;\n      }\n      return &mBuffer[currentPos];\n   }\n   else\n   {\n      resip_assert(0);\n      return mBuffer;\n   }\n}\n            \nvoid \nConnectionBase::setBuffer(char* bytes, int count)\n{\n   mBuffer = bytes;\n   mBufferPos = 0;\n   mBufferSize = count;\n}\n\nTransport* \nConnectionBase::transport() const\n{\n   resip_assert(this);\n   return mTransport;\n}\n\nEncodeStream& \nresip::operator<<(EncodeStream& strm, \n                  const resip::ConnectionBase& c)\n\n{\n   strm << \"CONN_BASE: \" << &c << \" \" << c.mWho;\n   return strm;\n}\n\n/* ====================================================================\n * The Vovida Software License, Version 1.0 \n * \n * Copyright (c) 2000\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * \n * 3. The names \"VOCAL\", \"Vovida Open Communication Application Library\",\n *    and \"Vovida Open Communication Application Library (VOCAL)\" must\n *    not be used to endorse or promote products derived from this\n *    software without prior written permission. For written\n *    permission, please contact vocal@vovida.org.\n *\n * 4. Products derived from this software may not be called \"VOCAL\", nor\n *    may \"VOCAL\" appear in their name, without prior written\n *    permission of Vovida Networks, Inc.\n * \n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND\n * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL VOVIDA\n * NETWORKS, INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT DAMAGES\n * IN EXCESS OF $1,000, NOR FOR ANY INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n * \n * ====================================================================\n * \n * This software consists of voluntary contributions made by Vovida\n * Networks, Inc. and many individuals on behalf of Vovida Networks,\n * Inc.  For more information on Vovida Networks, Inc., please see\n * <http://www.vovida.org/>.\n *\n * vi: set shiftwidth=3 expandtab:\n */\n\n"], "fixing_code": ["#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#include <memory>\n\n#include \"rutil/Logger.hxx\"\n#include \"resip/stack/ConnectionBase.hxx\"\n#include \"resip/stack/WsConnectionBase.hxx\"\n#include \"resip/stack/SipMessage.hxx\"\n#include \"resip/stack/WsDecorator.hxx\"\n#include \"resip/stack/Cookie.hxx\"\n#include \"resip/stack/WsBaseTransport.hxx\"\n#include \"resip/stack/WsCookieContext.hxx\"\n#include \"resip/stack/WsCookieContextFactory.hxx\"\n#include \"resip/stack/Symbols.hxx\"\n#include \"rutil/WinLeakCheck.hxx\"\n#include \"rutil/SharedPtr.hxx\"\n#include \"rutil/Sha1.hxx\"\n\n#ifdef USE_SSL\n#include \"resip/stack/ssl/Security.hxx\"\n#include \"resip/stack/ssl/TlsConnection.hxx\"\n#include \"rutil/ssl/SHA1Stream.hxx\"\n#endif\n\n#include \"rutil/MD5Stream.hxx\"\n\n#ifdef USE_SIGCOMP\n#include <osc/Stack.h>\n#include <osc/TcpStream.h>\n#include <osc/SigcompMessage.h>\n#include <osc/StateChanges.h>\n#endif\n\nusing namespace resip;\n\n#define RESIPROCATE_SUBSYSTEM Subsystem::TRANSPORT\n\nchar \nConnectionBase::connectionStates[ConnectionBase::MAX][32] = { \"NewMessage\", \"ReadingHeaders\", \"PartialBody\" };\n\n#ifndef RESIP_SIP_MSG_MAX_BYTES\n#define RESIP_SIP_MSG_MAX_BYTES  10485760\n#endif\n\nsize_t\nConnectionBase::messageSizeMax = RESIP_SIP_MSG_MAX_BYTES;\n\nConnectionBase::ConnectionBase(Transport* transport, const Tuple& who, Compression &compression)\n   : mSendPos(0),\n     mTransport(transport),\n     mWho(who),\n     mFailureReason(TransportFailure::None),\n     mFailureSubCode(0),\n     mCompression(compression),\n// NO: #ifdef USE_SIGCOMP // class def doesn't decl members conditionally\n     mSigcompStack(0),\n     mSigcompFramer(0),\n// NO: #endif\n     mSendingTransmissionFormat(Unknown),\n     mReceivingTransmissionFormat(Unknown),\n     mMessage(0),\n     mBuffer(0),\n     mBufferPos(0),\n     mBufferSize(0),\n     mWsFrameExtractor(messageSizeMax),\n     mLastUsed(Timer::getTimeMs()),\n     mConnState(NewMessage)\n{\n   DebugLog (<< \"ConnectionBase::ConnectionBase, who: \" << mWho << \" \" << this);\n#ifdef USE_SIGCOMP\n   if (mCompression.isEnabled())\n   {\n      DebugLog (<< \"Compression enabled for connection: \" << this);\n      mSigcompStack = new osc::Stack(mCompression.getStateHandler());\n      mCompression.addCompressorsToStack(mSigcompStack);\n   }\n   else\n   {\n      DebugLog (<< \"Compression disabled for connection: \" << this);\n   }\n#else\n   DebugLog (<< \"No compression library available: \" << this);\n#endif\n\n   if(mTransport) \n   {\n      mWho.mTransportKey = mTransport->getKey();\n   }\n}\n\nConnectionBase::~ConnectionBase()\n{\n   if(mTransport)\n   {\n      mTransport->flowTerminated(mWho);\n   }\n\n   while (!mOutstandingSends.empty())\n   {\n      SendData* sendData = mOutstandingSends.front();\n      mTransport->fail(sendData->transactionId,\n         mFailureReason ? mFailureReason : TransportFailure::ConnectionUnknown,\n         mFailureSubCode);\n      delete sendData;\n      mOutstandingSends.pop_front();\n   }\n   delete [] mBuffer;\n   delete mMessage;\n#ifdef USE_SIGCOMP\n   delete mSigcompStack;\n#endif\n\n   DebugLog (<< \"ConnectionBase::~ConnectionBase \" << this);\n}\n\nvoid\nConnectionBase::setFailureReason(TransportFailure::FailureReason failReason, int subCode)\n{\n   if ( failReason > mFailureReason )\n   {\n      mFailureReason = failReason;\n      mFailureSubCode = subCode;\n   }\n}\n\nFlowKey\nConnectionBase::getFlowKey() const\n{\n   return mWho.mFlowKey;\n}\n\nbool\nConnectionBase::preparseNewBytes(int bytesRead)\n{\n   DebugLog(<< \"In State: \" << connectionStates[mConnState]);\n   \n  start:   // If there is an overhang come back here, effectively recursing\n   \n   switch(mConnState)\n   {\n      case NewMessage:\n      {\n         if (strncmp(mBuffer + mBufferPos, Symbols::CRLFCRLF, 4) == 0)\n         {\n            DebugLog(<< \"Got incoming double-CRLF keepalive (aka ping).\");\n            mBufferPos += 4;\n            bytesRead -= 4;\n            onDoubleCRLF();\n            if (bytesRead)\n            {\n               goto start;\n            }\n            else\n            {\n               delete [] mBuffer;\n               mBuffer = 0;\n               return true;\n            }\n         }\n         else if (strncmp(mBuffer + mBufferPos, Symbols::CRLF, 2) == 0)\n         {\n            //DebugLog(<< \"Got incoming CRLF keepalive response (aka pong).\");\n            mBufferPos += 2;\n            bytesRead -= 2;\n            onSingleCRLF();\n            if (bytesRead)\n            {\n               goto start;\n            }\n            else\n            {\n               delete [] mBuffer;\n               mBuffer = 0;\n               return true;\n            }\n         }\n\n         resip_assert(mTransport);\n         mMessage = new SipMessage(&mTransport->getTuple());\n         \n         DebugLog(<< \"ConnectionBase::process setting source \" << mWho);\n         mMessage->setSource(mWho);\n         mMessage->setTlsDomain(mTransport->tlsDomain());\n\n#ifdef USE_SSL\n         // Set TlsPeerName if message is from TlsConnection\n         TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n         if(tlsConnection)\n         {\n            std::list<Data> peerNameList;\n            tlsConnection->getPeerNames(peerNameList);\n            mMessage->setTlsPeerNames(peerNameList);\n         }\n#endif\n         mMsgHeaderScanner.prepareForMessage(mMessage);\n         // Fall through to the next case.\n      }\n      case ReadingHeaders:\n      {\n         unsigned int chunkLength = (unsigned int)mBufferPos + bytesRead;\n         char *unprocessedCharPtr;\n         MsgHeaderScanner::ScanChunkResult scanChunkResult =\n            mMsgHeaderScanner.scanChunk(mBuffer,\n                                        chunkLength,\n                                        &unprocessedCharPtr);\n         if (scanChunkResult == MsgHeaderScanner::scrError)\n         {\n            //.jacob. Not a terribly informative warning.\n            WarningLog(<< \"Discarding preparse!\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         if (mMsgHeaderScanner.getHeaderCount() > 1024)\n         {\n            WarningLog(<< \"Discarding preparse; too many headers\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         unsigned int numUnprocessedChars = \n            (unsigned int)((mBuffer + chunkLength) - unprocessedCharPtr);\n\n         if(numUnprocessedChars > ConnectionBase::ChunkSize &&\n            scanChunkResult == MsgHeaderScanner::scrNextChunk)\n         {\n            WarningLog(<< \"Discarding preparse; header-field-value (or \"\n                        \"header name) too long\");\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            mConnState = NewMessage;\n            return false;\n         }\n\n         if(numUnprocessedChars==chunkLength)\n         {\n            // .bwc. MsgHeaderScanner wasn't able to parse anything useful;\n            // don't bother mMessage yet, but make more room in mBuffer.\n            size_t size = numUnprocessedChars*3/2;\n            if (size < ConnectionBase::ChunkSize)\n            {\n               size = ConnectionBase::ChunkSize;\n            }\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=MsgHeaderScanner::allocateBuffer((int)size);\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n               return false;\n            }\n            memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n            delete [] mBuffer;\n            mBuffer = newBuffer;\n            mBufferPos = numUnprocessedChars;\n            mBufferSize = size;\n            mConnState = ReadingHeaders;\n            return true;\n         }\n\n         mMessage->addBuffer(mBuffer);\n         mBuffer=0;\n\n         if (scanChunkResult == MsgHeaderScanner::scrNextChunk)\n         {\n            // Message header is incomplete...\n            if (numUnprocessedChars == 0)\n            {\n               // ...but the chunk is completely processed.\n               //.jacob. I've discarded the \"assigned\" concept.\n               //DebugLog(<< \"Data assigned, not fragmented, not complete\");\n               try\n               {\n                  mBuffer = MsgHeaderScanner::allocateBuffer(ChunkSize);\n               }\n               catch(std::bad_alloc&)\n               {\n                  ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n                  return false;\n               }\n               mBufferPos = 0;\n               mBufferSize = ChunkSize;\n            }\n            else\n            {\n               // ...but some of the chunk must be shifted into the next one.\n               size_t size = numUnprocessedChars*3/2;\n               if (size < ConnectionBase::ChunkSize)\n               {\n                  size = ConnectionBase::ChunkSize;\n               }\n               char* newBuffer = 0;\n               try\n               {\n                  newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n               }\n               catch(std::bad_alloc&)\n               {\n                  ErrLog(<<\"Failed to alloc a buffer during preparse!\");\n                  return false;\n               }\n               memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n               mBuffer = newBuffer;\n               mBufferPos = numUnprocessedChars;\n               mBufferSize = size;\n            }\n            mConnState = ReadingHeaders;\n         }\n         else\n         {\n            size_t contentLength = 0;\n            \n            try\n            {\n               // The message header is complete.\n               contentLength=mMessage->const_header(h_ContentLength).value();\n            }\n            catch(resip::BaseException& e)  // Could be SipMessage::Exception or ParseException\n            {\n               WarningLog(<<\"Malformed Content-Length in connection-based transport\"\n                           \". Not much we can do to fix this.  \" << e);\n               // .bwc. Bad Content-Length. We are hosed.\n               delete mMessage;\n               mMessage = 0;\n               mBuffer = 0;\n               // .bwc. mMessage just took ownership of mBuffer, so we don't\n               // delete it here. We do zero it though, for completeness.\n               //.jacob. Shouldn't the state also be set here?\n               return false;\n            }\n            \n            if(contentLength > messageSizeMax || contentLength < 0)\n            {\n               WarningLog(<<\"Content-Length in connection-based \"\n                           \"transport exceeds maximum \" << messageSizeMax);\n               delete mMessage;\n               mMessage = 0;\n               mBuffer = 0;\n               // .bwc. mMessage just took ownership of mBuffer, so we don't\n               // delete it here. We do zero it though, for completeness.\n               //.jacob. Shouldn't the state also be set here?\n               return false;\n            }\n\n            if (numUnprocessedChars < contentLength)\n            {\n               // The message body is incomplete.\n               DebugLog(<< \"partial body received\");\n               size_t newSize=resipMin(resipMax((size_t)numUnprocessedChars*3/2,\n                                             (size_t)ConnectionBase::ChunkSize),\n                                    contentLength);\n               char* newBuffer = MsgHeaderScanner::allocateBuffer((int)newSize);\n               memcpy(newBuffer, unprocessedCharPtr, numUnprocessedChars);\n               mBufferPos = numUnprocessedChars;\n               mBufferSize = newSize;\n               mBuffer = newBuffer;\n               \n               mConnState = PartialBody;\n            }\n            else\n            {\n               // Do this stuff BEFORE we kick the message out the door.\n               // Remember, deleting or passing mMessage on invalidates our\n               // buffer!\n               int overHang = numUnprocessedChars - (int)contentLength;\n\n               mConnState = NewMessage;\n               mBuffer = 0;\n               if (overHang > 0) \n               {\n                  // The next message has been partially read.\n                  size_t size = overHang*3/2;\n                  if (size < ConnectionBase::ChunkSize)\n                  {\n                     size = ConnectionBase::ChunkSize;\n                  }\n                  char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                  memcpy(newBuffer,\n                         unprocessedCharPtr + contentLength,\n                         overHang);\n                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  //DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               // The message body is complete.\n               mMessage->setBody(unprocessedCharPtr, (UInt32)contentLength);\n               CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n               if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                     || (b==CongestionManager::REJECTING_NEW_WORK\n                        && mMessage->isRequest()))\n               {\n                  UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n                  // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n                  // requests but not responses ( ?bwc? is this right for ACK?). \n                  // If we are REJECTING_NON_ESSENTIAL, \n                  // we reject all incoming work, since losing something from the \n                  // wire will not cause instability or leaks (see \n                  // CongestionManager.hxx)\n                  \n                  // .bwc. This handles all appropriate checking for whether\n                  // this is a response or an ACK.\n                  std::auto_ptr<SendData> tryLater(transport()->make503(*mMessage, expectedWait/1000));\n                  if(tryLater.get())\n                  {\n                     transport()->send(tryLater);\n                  }\n                  delete mMessage; // dropping message due to congestion\n                  mMessage = 0;\n               }\n               else if (!transport()->basicCheck(*mMessage))\n               {\n                  delete mMessage;\n                  mMessage = 0;\n               }\n               else\n               {\n                  Transport::stampReceived(mMessage);\n                  DebugLog(<< \"##Connection: \" << *this << \" received: \" << *mMessage);\n                  resip_assert( mTransport );\n                  mTransport->pushRxMsgUp(mMessage);\n                  mMessage = 0;\n               }\n\n               if (overHang > 0) \n               {\n                  goto start;\n               }\n            }\n         }\n         break;\n      }\n      case PartialBody:\n      {\n         size_t contentLength = 0;\n\n         try\n         {\n             contentLength = mMessage->const_header(h_ContentLength).value();\n         }\n         catch(resip::BaseException& e)  // Could be SipMessage::Exception or ParseException\n         {\n            WarningLog(<<\"Malformed Content-Length in connection-based transport\"\n                        \". Not much we can do to fix this. \" << e);\n            // .bwc. Bad Content-Length. We are hosed.\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            //.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos >= contentLength)\n         {\n            int overHang = mBufferPos - (int)contentLength;\n            char *overHangStart = mBuffer + contentLength;\n\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mConnState = NewMessage;\n            mBuffer = 0;\n\n            if (overHang > 0)\n            {\n                // The next message has been partially read.\n                size_t size = overHang * 3 / 2;\n                if (size < ConnectionBase::ChunkSize)\n                {\n                    size = ConnectionBase::ChunkSize;\n                }\n                char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                memcpy(newBuffer, overHangStart, overHang);\n                mBuffer = newBuffer;\n                mBufferPos = 0;\n                mBufferSize = size;\n\n                DebugLog(<< \"Extra bytes after message: \" << overHang);\n                //DebugLog(<< Data(mBuffer, overHang));\n\n                bytesRead = overHang;\n            }\n\n            // .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            // if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n                     && mMessage->isRequest()))\n            {\n               UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n               // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n               // requests but not responses ( ?bwc? is this right for ACK?). \n               // If we are REJECTING_NON_ESSENTIAL, \n               // we reject all incoming work, since losing something from the \n               // wire will not cause instability or leaks (see \n               // CongestionManager.hxx)\n               \n               // .bwc. This handles all appropriate checking for whether\n               // this is a response or an ACK.\n               std::auto_ptr<SendData> tryLater = transport()->make503(*mMessage, expectedWait/1000);\n               if(tryLater.get())\n               {\n                  transport()->send(tryLater);\n               }\n               delete mMessage; // dropping message due to congestion\n               mMessage = 0;\n            }\n            else if (!transport()->basicCheck(*mMessage))\n            {\n               delete mMessage;\n               mMessage = 0;\n            }\n            else\n            {\n               DebugLog(<< \"##ConnectionBase: \" << *this << \" received: \" << *mMessage);\n\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            \n            if (overHang > 0) \n            {\n               goto start;\n            }\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            // .bwc. We've filled our buffer and haven't read contentLength bytes yet; go ahead and make more room.\n            assert(contentLength >= mBufferSize);\n            size_t newSize = resipMin(mBufferSize*3/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer while receiving body!\");\n               return false;\n            }\n            memcpy(newBuffer, mBuffer, mBufferSize);\n            mBufferSize=newSize;\n            delete [] mBuffer;\n            mBuffer = newBuffer;\n         }\n         break;\n      }\n      default:\n         resip_assert(0);\n   }\n   return true;\n}\n\nvoid\nConnectionBase::wsParseCookies(CookieList& cookieList, const SipMessage* message)\n{\n   Data name;\n   Data value;\n   StringCategories::const_iterator it = message->header(h_Cookies).begin();\n   for (; it != message->header(h_Cookies).end(); ++it)\n   {\n      ParseBuffer pb((*it).value());\n      while(!pb.eof())\n      {\n         const char* anchor =  pb.skipWhitespace();\n\n         pb.skipToChar(Symbols::EQUALS[0]);\n         pb.data(name, anchor);\n\n         anchor = pb.skipChar(Symbols::EQUALS[0]);\n         if(*(pb.position()) == Symbols::DOUBLE_QUOTE[0])\n         {\n            anchor = pb.skipChar(Symbols::DOUBLE_QUOTE[0]);\n            pb.skipToChar(Symbols::DOUBLE_QUOTE[0]);\n            pb.data(value, anchor);\n            pb.skipChar(Symbols::DOUBLE_QUOTE[0]);\n         }\n         else\n         {\n            pb.skipToOneOf(Symbols::SEMI_COLON, ParseBuffer::Whitespace);\n            pb.data(value, anchor);\n         }\n\n         Cookie cookie(name, value);\n         cookieList.push_back(cookie);\n         DebugLog(<< \"Cookie: \" << cookie);\n\n         if(!pb.eof() && *(pb.position()) == Symbols::SEMI_COLON[0])\n         {\n            pb.skipChar(Symbols::SEMI_COLON[0]);\n         }\n\n         pb.skipWhitespace();\n      }\n   }\n}\n\n/*\n * Returns true if handshake complete, false if more bytes needed\n * Sets dropConnection = true if an error occurs\n */\nbool\nConnectionBase::wsProcessHandshake(int bytesRead, bool &dropConnection)\n{\n   mConnState = WebSocket;\n   dropConnection = false;\n\n   if(mBufferPos + bytesRead > messageSizeMax)\n   {\n      WarningLog(<<\"Too many bytes received during WS handshake, dropping connection.  Max message size = \" << messageSizeMax);\n      dropConnection = true;\n      return false;\n   }\n\n   resip_assert(mTransport);\n   mMessage = new SipMessage(&mTransport->getTuple());\n   resip_assert(mMessage);\n\n   mMessage->setSource(mWho);   \n   mMessage->setTlsDomain(mTransport->tlsDomain());\n\n   if (!scanMsgHeader(bytesRead)) \n   {\n      return false;\n   }\n\n   try\n   {\n      WsConnectionBase* wsConnectionBase = dynamic_cast<WsConnectionBase*>(this);\n      CookieList cookieList;\n      if(wsConnectionBase)\n      {\n         SharedPtr<WsCookieContext> wsCookieContext((WsCookieContext*)0);\n         if (mMessage->exists(h_Cookies))\n         {\n            WsBaseTransport* wst = dynamic_cast<WsBaseTransport*>(mTransport);\n            resip_assert(wst);\n            try\n            {\n               wsParseCookies(cookieList, mMessage);\n               wsConnectionBase->setCookies(cookieList);\n               // Use of resip WsCookieContext capabilities is not mandatory,\n               // only try to use it if cookieContextFactory is available\n               if(wst->cookieContextFactory().get())\n               {\n                  Uri& requestUri = mMessage->header(h_RequestLine).uri();\n                  wsCookieContext = wst->cookieContextFactory()->makeCookieContext(cookieList, requestUri);\n                  wsConnectionBase->setWsCookieContext(wsCookieContext);\n               }\n            }\n            catch(ParseException& ex)\n            {\n               WarningLog(<<\"Failed to parse cookies into WsCookieContext: \" << ex);\n            }\n         }\n         SharedPtr<WsConnectionValidator> wsConnectionValidator = wsConnectionBase->connectionValidator();\n         if(wsConnectionValidator &&\n            (!wsCookieContext.get() || !wsConnectionValidator->validateConnection(*wsCookieContext)))\n         {\n            ErrLog(<<\"WebSocket cookie validation failed, dropping connection\");\n            // FIXME: should send back a HTTP error code:\n            //   400 if the cookie was not in the right syntax\n            //   403 if the cookie was well formed but rejected\n            //       due to expiry or a bad HMAC\n            delete mMessage;\n            mMessage = 0;\n            mBufferPos = 0;\n            dropConnection = true;\n            return false;\n         }\n      }\n\n      std::auto_ptr<Data> wsResponsePtr = makeWsHandshakeResponse();\n\n      if (wsResponsePtr.get())\n      {\n         DebugLog (<< \"WebSocket upgrade accepted, cookie count = \" << cookieList.size());\n\n         mOutstandingSends.push_back(new SendData(\n                  who(),\n                  *wsResponsePtr.get(),\n                  Data::Empty,\n                  Data::Empty,\n                  true));\n      }\n      else\n      {\n         ErrLog(<<\"Failed to parse WebSocket initialization request\");\n         delete mMessage;\n         mMessage = 0;\n         mBufferPos = 0;\n         dropConnection = true;\n         return false;\n      }\n   }\n   catch(resip::ParseException& e)\n   {\n      ErrLog(<<\"Cannot auth request is missing \" << e);\n      delete mMessage;\n      mMessage = 0;\n      mBufferPos = 0;\n      dropConnection = true;\n      return false;\n   }\n\n   delete mMessage;\n   mMessage=0;\n   mBufferPos = 0;\n\n   return true;\n}\n\nbool\nConnectionBase::scanMsgHeader(int bytesRead)\n{\n   mMsgHeaderScanner.prepareForMessage(mMessage);\n   char *unprocessedCharPtr;\n   MsgHeaderScanner::ScanChunkResult scanResult = mMsgHeaderScanner.scanChunk(mBuffer, mBufferPos + bytesRead, &unprocessedCharPtr);\n   if (scanResult != MsgHeaderScanner::scrEnd)\n   {\n      if(scanResult != MsgHeaderScanner::scrNextChunk)\n      {\n         StackLog(<<\"Failed to parse message, more bytes needed\");\n         StackLog(<< Data(mBuffer, bytesRead));\n      }\n      delete mMessage;\n      mMessage=0;\n      mBufferPos += bytesRead;\n      return false;\n   }\n   return true;\n}\n\nstd::auto_ptr<Data>\nConnectionBase::makeWsHandshakeResponse()\n{\n   std::auto_ptr<Data> responsePtr(0);\n   if(isUsingSecWebSocketKey())\n   {\n      responsePtr.reset(new Data(\"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"Connection: Upgrade\\r\\n\"\n         \"Sec-WebSocket-Protocol: sip\\r\\n\"));\n\n      // Assuming that OpenSSL implementation of SHA1 is more effient than our internal one\n#ifdef USE_SSL\n      SHA1Stream wsSha1Stream;\n      wsSha1Stream << (mMessage->const_header(h_SecWebSocketKey).value() + Symbols::WebsocketMagicGUID);\n      Data wsAcceptKey = wsSha1Stream.getBin(160).base64encode();\n#else\n      SHA1 sha1;\n      sha1.update(mMessage->const_header(h_SecWebSocketKey).value().c_str());\n      sha1.update(Symbols::WebsocketMagicGUID);\n      Data wsAcceptKey = sha1.finalBin().base64encode();\n#endif\n      *responsePtr += \"Sec-WebSocket-Accept: \" + wsAcceptKey + \"\\r\\n\\r\\n\";\n   }\n   else if(isUsingDeprecatedSecWebSocketKeys())\n   {\n      ErrLog(<<\"WS client wants to use depracated protocol version, unsupported\");\n   }\n   else\n   {\n      ErrLog(<<\"No SecWebSocketKey header\");\n   }\n   return responsePtr;\n}\n\nbool ConnectionBase::isUsingDeprecatedSecWebSocketKeys()\n{\n   resip_assert(mMessage);\n   return mMessage->exists(h_SecWebSocketKey1) &&\n      mMessage->exists(h_SecWebSocketKey2);\n}\n\nbool ConnectionBase::isUsingSecWebSocketKey()\n{\n   resip_assert(mMessage);\n   return mMessage->exists(h_SecWebSocketKey);\n}\n\nbool\nConnectionBase::wsProcessData(int bytesRead)\n{\n   bool dropConnection = false;\n   // Always consumes the whole buffer:\n   std::auto_ptr<Data> msg = mWsFrameExtractor.processBytes((UInt8*)mBuffer, bytesRead, dropConnection);\n\n   while(msg.get())\n   {\n      // mWsBuffer should now contain a discrete SIP message, let the\n      // stack go to work on it\n\n      if(msg->size() == 4 && memcmp(msg->data(), \"\\r\\n\\r\\n\", 4) == 0)\n      {\n         // sending a keep alive reply now\n         StackLog(<<\"got a SIP ping embedded in WebSocket frame, replying\");\n         onDoubleCRLF();\n         msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);\n         continue;\n      }\n\n      resip_assert(mTransport);\n      mMessage = new SipMessage(&mTransport->getTuple());\n\n      mMessage->setSource(mWho);\n      mMessage->setTlsDomain(mTransport->tlsDomain());\n\n#ifdef USE_SSL\n      // Set TlsPeerName if message is from TlsConnection\n      TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n      if(tlsConnection)\n      {\n         std::list<Data> peerNameList;\n         tlsConnection->getPeerNames(peerNameList);\n         mMessage->setTlsPeerNames(peerNameList);\n      }\n#endif\n\n      WsConnectionBase *wsConnectionBase = dynamic_cast<WsConnectionBase *>(this);\n      if (wsConnectionBase)\n      {\n         mMessage->setWsCookies(wsConnectionBase->getCookies());\n         mMessage->setWsCookieContext(wsConnectionBase->getWsCookieContext());\n      }\n\n      Data::size_type msg_len = msg->size();\n      // cast permitted, as it is borrowed:\n      char *sipBuffer = (char *)msg->data();\n      mMessage->addBuffer(sipBuffer);\n      mMsgHeaderScanner.prepareForMessage(mMessage);\n      char *unprocessedCharPtr;\n      if (mMsgHeaderScanner.scanChunk(sipBuffer,\n                                 msg_len,\n                                 &unprocessedCharPtr) !=\n                    MsgHeaderScanner::scrEnd)\n      {\n         StackLog(<<\"Scanner rejecting WebSocket SIP message as unparsable, length = \" << msg_len);\n         StackLog(<< Data(sipBuffer, msg_len));\n         delete mMessage;\n         mMessage=0;\n      }\n\n      unsigned int used = unprocessedCharPtr - sipBuffer;\n      if (mMessage && (used < msg_len))\n      {\n         mMessage->setBody(sipBuffer+used, msg_len-used);\n      }\n\n      if (mMessage && !transport()->basicCheck(*mMessage))\n      {\n         delete mMessage;\n         mMessage = 0;\n      }\n\n      if (mMessage)\n      {\n         Transport::stampReceived(mMessage);\n         resip_assert( mTransport );\n         mTransport->pushRxMsgUp(mMessage);\n         mMessage = 0;\n      }\n      else\n      {\n         // Something wrong...\n         ErrLog(<< \"We don't have a valid SIP message, maybe drop the connection?\");\n      }\n      msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);\n   }\n\n   if(dropConnection)\n   {\n      return false;\n   }\n\n   return true;\n}\n\n#ifdef USE_SIGCOMP\nvoid\nConnectionBase::decompressNewBytes(int bytesRead)\n{\n  mConnState = SigComp;\n\n  if (!mSigcompFramer)\n  {\n    mSigcompFramer = new osc::TcpStream();\n  }\n\n  mSigcompFramer->addData(mBuffer, bytesRead);\n  size_t bytesUncompressed;\n  osc::StateChanges *sc = 0;\n  char *uncompressed = new char[65536];\n  while ((bytesUncompressed = mSigcompStack->uncompressMessage(\n                *mSigcompFramer, uncompressed, 65536, sc)) > 0)\n  {\n    DebugLog (<< \"Uncompressed Connection-oriented message\");\n    mMessage = new SipMessage(mWho.transport);\n\n    mMessage->setSource(mWho);\n    mMessage->setTlsDomain(mWho.transport->tlsDomain());\n\n#ifdef USE_SSL\n    // Set TlsPeerName if message is from TlsConnection\n    TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);\n    if(tlsConnection)\n    {\n       std::list<Data> peerNameList;\n       tlsConnection->getPeerNames(peerNameList);\n       mMessage->setTlsPeerNames(peerNameList);\n    }\n#endif\n\n    char *sipBuffer = new char[bytesUncompressed];\n    memmove(sipBuffer, uncompressed, bytesUncompressed);\n    mMessage->addBuffer(sipBuffer);\n    mMsgHeaderScanner.prepareForMessage(mMessage);\n    char *unprocessedCharPtr;\n    if (mMsgHeaderScanner.scanChunk(sipBuffer,\n                                    bytesUncompressed,\n                                    &unprocessedCharPtr) !=\n        MsgHeaderScanner::scrEnd)\n    {\n       StackLog(<<\"Scanner rejecting compressed message as unparsable\");\n       StackLog(<< Data(sipBuffer, bytesUncompressed));\n       delete mMessage;\n       mMessage=0;\n    }\n  \n    unsigned int used = unprocessedCharPtr - sipBuffer;\n    if (mMessage && (used < bytesUncompressed))\n    {\n      mMessage->setBody(sipBuffer+used, bytesUncompressed-used);\n    }\n\n    if (mMessage && !transport()->basicCheck(*mMessage))\n    {\n      delete mMessage;\n      mMessage = 0;\n    }\n\n    if (mMessage)\n    {\n      Transport::stampReceived(mMessage);\n      // If the message made it this far, we should let it store\n      // SigComp state: extract the compartment ID.\n      const Via &via = mMessage->const_header(h_Vias).front();\n      if (mMessage->isRequest())\n      {\n        // For requests, the compartment ID is read out of the\n        // top via header field; if not present, we use the\n        // TCP connection for identification purposes.\n        if (via.exists(p_sigcompId))\n        {\n            Data compId = via.param(p_sigcompId);\n            if(!compId.empty())\n            {\n                mSigcompStack->provideCompartmentId(sc, compId.data(), compId.size());\n            }\n        }\n        else\n        {\n          mSigcompStack->provideCompartmentId(sc, this, sizeof(this));\n        }\n      }\n      else\n      {\n        // For responses, the compartment ID is supposed to be\n        // the same as the compartment ID of the request. We\n        // *could* dig down into the transaction layer to try to\n        // figure this out, but that's a royal pain, and a rather\n        // severe layer violation. In practice, we're going to ferret\n        // the ID out of the the Via header field, which is where we\n        // squirreled it away when we sent this request in the first place.\n        Data compId = via.param(p_branch).getSigcompCompartment();\n        if(!compId.empty())\n        {\n           mSigcompStack->provideCompartmentId(sc, compId.data(), compId.size());\n        }\n      }\n      resip_assert( mTransport );\n      mTransport->pushRxMsgUp(mMessage);\n      mMessage = 0;\n      sc = 0;\n    }\n    else\n    {\n      delete sc;\n      sc = 0;\n    }\n  }\n  delete [] uncompressed;\n\n  // If there was a decompression failure, let the other side know.\n  osc::SigcompMessage *nack = mSigcompStack->getNack();\n  if (nack)\n  {\n    if (mSendingTransmissionFormat == Compressed)\n    {\n      // !bwc! We are not telling anyone that we're interested in having our\n      // FD put in the writable set...\n      mOutstandingSends.push_back(new SendData(\n                   who(),\n                   Data(nack->getStreamMessage(), nack->getStreamLength()),\n                   Data::Empty,\n                   Data::Empty,\n                   true));\n    }\n    else\n    {\n      delete nack;\n    }\n  }\n}\n#endif\n            \nstd::pair<char*, size_t> \nConnectionBase::getWriteBuffer()\n{\n   if (mConnState == NewMessage)\n   {\n      if (!mBuffer)\n      {\n         DebugLog (<< \"Creating buffer for \" << *this);\n\n         mBuffer = MsgHeaderScanner::allocateBuffer(ConnectionBase::ChunkSize);\n         mBufferSize = ConnectionBase::ChunkSize;\n      }\n      mBufferPos = 0;\n   }\n   return getCurrentWriteBuffer();\n}\n\nstd::pair<char*, size_t> \nConnectionBase::getCurrentWriteBuffer()\n{\n   return std::make_pair(mBuffer + mBufferPos, mBufferSize - mBufferPos);\n}\n\nchar*\nConnectionBase::getWriteBufferForExtraBytes(int currentPos, int extraBytes)\n{\n   if (currentPos > 0 && extraBytes > 0)\n   {\n      if ((currentPos + extraBytes) > mBufferSize)\n      {\n         mBufferSize = currentPos + extraBytes;\n         char* buffer = MsgHeaderScanner::allocateBuffer((int)mBufferSize);\n         memcpy(buffer, mBuffer, currentPos);\n         delete[] mBuffer;\n         mBuffer = buffer;\n      }\n      return &mBuffer[currentPos];\n   }\n   else\n   {\n      resip_assert(0);\n      return mBuffer;\n   }\n}\n            \nvoid \nConnectionBase::setBuffer(char* bytes, int count)\n{\n   mBuffer = bytes;\n   mBufferPos = 0;\n   mBufferSize = count;\n}\n\nTransport* \nConnectionBase::transport() const\n{\n   resip_assert(this);\n   return mTransport;\n}\n\nEncodeStream& \nresip::operator<<(EncodeStream& strm, \n                  const resip::ConnectionBase& c)\n\n{\n   strm << \"CONN_BASE: \" << &c << \" \" << c.mWho;\n   return strm;\n}\n\n/* ====================================================================\n * The Vovida Software License, Version 1.0 \n * \n * Copyright (c) 2000\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * \n * 3. The names \"VOCAL\", \"Vovida Open Communication Application Library\",\n *    and \"Vovida Open Communication Application Library (VOCAL)\" must\n *    not be used to endorse or promote products derived from this\n *    software without prior written permission. For written\n *    permission, please contact vocal@vovida.org.\n *\n * 4. Products derived from this software may not be called \"VOCAL\", nor\n *    may \"VOCAL\" appear in their name, without prior written\n *    permission of Vovida Networks, Inc.\n * \n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND\n * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL VOVIDA\n * NETWORKS, INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT DAMAGES\n * IN EXCESS OF $1,000, NOR FOR ANY INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n * \n * ====================================================================\n * \n * This software consists of voluntary contributions made by Vovida\n * Networks, Inc. and many individuals on behalf of Vovida Networks,\n * Inc.  For more information on Vovida Networks, Inc., please see\n * <http://www.vovida.org/>.\n *\n * vi: set shiftwidth=3 expandtab:\n */\n\n"], "filenames": ["resip/stack/ConnectionBase.cxx"], "buggy_code_start_loc": [400], "buggy_code_end_loc": [523], "fixing_code_start_loc": [400], "fixing_code_end_loc": [553], "type": "CWE-120", "message": "The ConnectionBase::preparseNewBytes function in resip/stack/ConnectionBase.cxx in reSIProcate through 1.10.2 allows remote attackers to cause a denial of service (buffer overflow) or possibly execute arbitrary code when TLS communication is enabled.", "other": {"cve": {"id": "CVE-2018-12584", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-16T20:29:00.487", "lastModified": "2022-04-18T17:31:16.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ConnectionBase::preparseNewBytes function in resip/stack/ConnectionBase.cxx in reSIProcate through 1.10.2 allows remote attackers to cause a denial of service (buffer overflow) or possibly execute arbitrary code when TLS communication is enabled."}, {"lang": "es", "value": "La funci\u00f3n ConnectionBase::preparseNewBytes en resip/stack/ConnectionBase.cxx en reSIProcate hasta la versi\u00f3n 1.10.2 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer) o, posiblemente, ejecuten c\u00f3digo arbitrario cuando la comunicaci\u00f3n TLS est\u00e1 habilitada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.10.2", "matchCriteriaId": "D7A9B784-2E65-4DD9-A2BF-37E9423059E9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://joachimdezutter.webredirect.org/advisory.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://seclists.org/bugtraq/2018/Aug/14", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/resiprocate/resiprocate/commit/2cb291191c93c7c4e371e22cb89805a5b31d6608", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://packetstormsecurity.com/files/148856/reSIProcate-1.10.2-Heap-Overflow.html", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/45174/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/resiprocate/resiprocate/commit/2cb291191c93c7c4e371e22cb89805a5b31d6608"}}