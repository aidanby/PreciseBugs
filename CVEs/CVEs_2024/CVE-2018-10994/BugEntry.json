{"buggy_code": ["/* global Whisper: false */\n/* global i18n: false */\n/* global textsecure: false */\n/* global _: false */\n/* global emoji_util: false */\n/* global Mustache: false */\n/* global $: false */\n\n// eslint-disable-next-line func-names\n(function() {\n  'use strict';\n\n  const { Signal } = window;\n  const { loadAttachmentData } = window.Signal.Migrations;\n\n  window.Whisper = window.Whisper || {};\n\n  const ErrorIconView = Whisper.View.extend({\n    templateName: 'error-icon',\n    className: 'error-icon-container',\n    initialize() {\n      if (this.model.name === 'UnregisteredUserError') {\n        this.$el.addClass('unregistered-user-error');\n      }\n    },\n  });\n  const NetworkErrorView = Whisper.View.extend({\n    tagName: 'span',\n    className: 'hasRetry',\n    templateName: 'hasRetry',\n    render_attributes() {\n      let messageNotSent;\n\n      if (!this.model.someRecipientsFailed()) {\n        messageNotSent = i18n('messageNotSent');\n      }\n\n      return {\n        messageNotSent,\n        resend: i18n('resend'),\n      };\n    },\n  });\n  const SomeFailedView = Whisper.View.extend({\n    tagName: 'span',\n    className: 'some-failed',\n    templateName: 'some-failed',\n    render_attributes() {\n      return {\n        someFailed: i18n('someRecipientsFailed'),\n      };\n    },\n  });\n  const TimerView = Whisper.View.extend({\n    templateName: 'hourglass',\n    initialize() {\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    update() {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n      if (this.model.isExpired()) {\n        return this;\n      }\n      if (this.model.isExpiring()) {\n        this.render();\n        const totalTime = this.model.get('expireTimer') * 1000;\n        const remainingTime = this.model.msTilExpire();\n        const elapsed = (totalTime - remainingTime) / totalTime;\n        this.$('.sand').css('transform', `translateY(${elapsed * 100}%)`);\n        this.$el.css('display', 'inline-block');\n        this.timeout = setTimeout(\n          this.update.bind(this),\n          Math.max(totalTime / 100, 500)\n        );\n      }\n      return this;\n    },\n  });\n\n  Whisper.ExpirationTimerUpdateView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'expirationTimerUpdate advisory',\n    templateName: 'expirationTimerUpdate',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getExpirationTimerUpdateSource();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    render_attributes() {\n      const seconds = this.model.get('expirationTimerUpdate').expireTimer;\n      let timerMessage;\n\n      const timerUpdate = this.model.get('expirationTimerUpdate');\n      const prettySeconds = Whisper.ExpirationTimerOptions.getName(seconds);\n\n      if (timerUpdate && timerUpdate.fromSync) {\n        timerMessage = i18n('timerSetOnSync', prettySeconds);\n      } else if (this.conversation.id === textsecure.storage.user.getNumber()) {\n        timerMessage = i18n('youChangedTheTimer', prettySeconds);\n      } else {\n        timerMessage = i18n('theyChangedTheTimer', [\n          this.conversation.getTitle(),\n          prettySeconds,\n        ]);\n      }\n      return { content: timerMessage };\n    },\n  });\n\n  Whisper.KeyChangeView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'keychange advisory',\n    templateName: 'keychange',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getModelForKeyChange();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    events: {\n      'click .content': 'showIdentity',\n    },\n    render_attributes() {\n      return {\n        content: this.model.getNotificationText(),\n      };\n    },\n    showIdentity() {\n      this.$el.trigger('show-identity', this.conversation);\n    },\n  });\n\n  Whisper.VerifiedChangeView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'verified-change advisory',\n    templateName: 'verified-change',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getModelForVerifiedChange();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    events: {\n      'click .content': 'showIdentity',\n    },\n    render_attributes() {\n      let key;\n\n      if (this.model.get('verified')) {\n        if (this.model.get('local')) {\n          key = 'youMarkedAsVerified';\n        } else {\n          key = 'youMarkedAsVerifiedOtherDevice';\n        }\n        return {\n          icon: 'verified',\n          content: i18n(key, this.conversation.getTitle()),\n        };\n      }\n\n      if (this.model.get('local')) {\n        key = 'youMarkedAsNotVerified';\n      } else {\n        key = 'youMarkedAsNotVerifiedOtherDevice';\n      }\n\n      return {\n        icon: 'shield',\n        content: i18n(key, this.conversation.getTitle()),\n      };\n    },\n    showIdentity() {\n      this.$el.trigger('show-identity', this.conversation);\n    },\n  });\n\n  Whisper.MessageView = Whisper.View.extend({\n    tagName: 'li',\n    templateName: 'message',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      //   loadedAttachmentViews :: Promise (Array AttachmentView) | null\n      this.loadedAttachmentViews = null;\n\n      this.listenTo(this.model, 'change:errors', this.onErrorsChanged);\n      this.listenTo(this.model, 'change:body', this.render);\n      this.listenTo(this.model, 'change:delivered', this.renderDelivered);\n      this.listenTo(this.model, 'change:read_by', this.renderRead);\n      this.listenTo(\n        this.model,\n        'change:expirationStartTimestamp',\n        this.renderExpiring\n      );\n      this.listenTo(this.model, 'change', this.onChange);\n      this.listenTo(\n        this.model,\n        'change:flags change:group_update',\n        this.renderControl\n      );\n      this.listenTo(this.model, 'destroy', this.onDestroy);\n      this.listenTo(this.model, 'unload', this.onUnload);\n      this.listenTo(this.model, 'expired', this.onExpired);\n      this.listenTo(this.model, 'pending', this.renderPending);\n      this.listenTo(this.model, 'done', this.renderDone);\n      this.timeStampView = new Whisper.ExtendedTimestampView();\n\n      this.contact = this.model.isIncoming() ? this.model.getContact() : null;\n      if (this.contact) {\n        this.listenTo(this.contact, 'change:color', this.updateColor);\n      }\n    },\n    events: {\n      'click .retry': 'retryMessage',\n      'click .error-icon': 'select',\n      'click .timestamp': 'select',\n      'click .status': 'select',\n      'click .some-failed': 'select',\n      'click .error-message': 'select',\n      'click .menu-container': 'showMenu',\n      'click .menu-list .reply': 'onReply',\n    },\n    retryMessage() {\n      const retrys = _.filter(\n        this.model.get('errors'),\n        this.model.isReplayableError.bind(this.model)\n      );\n      _.map(retrys, 'number').forEach(number => {\n        this.model.resend(number);\n      });\n    },\n    showMenu(e) {\n      if (this.menuVisible) {\n        return;\n      }\n\n      this.menuVisible = true;\n      e.stopPropagation();\n\n      this.$('.menu-list').show();\n      $(document).one('click', () => {\n        this.hideMenu();\n      });\n    },\n    hideMenu() {\n      this.menuVisible = false;\n      this.$('.menu-list').hide();\n    },\n    onReply() {\n      this.model.trigger('reply', this.model);\n    },\n    onExpired() {\n      this.$el.addClass('expired');\n      this.$el.find('.bubble').one('webkitAnimationEnd animationend', e => {\n        if (e.target === this.$('.bubble')[0]) {\n          this.remove();\n        }\n      });\n\n      // Failsafe: if in the background, animation events don't fire\n      setTimeout(this.remove.bind(this), 1000);\n    },\n    onUnload() {\n      if (this.avatarView) {\n        this.avatarView.remove();\n      }\n      if (this.errorIconView) {\n        this.errorIconView.remove();\n      }\n      if (this.networkErrorView) {\n        this.networkErrorView.remove();\n      }\n      if (this.someFailedView) {\n        this.someFailedView.remove();\n      }\n      if (this.timeStampView) {\n        this.timeStampView.remove();\n      }\n      if (this.quoteView) {\n        this.quoteView.remove();\n      }\n\n      // NOTE: We have to do this in the background (`then` instead of `await`)\n      // as our tests rely on `onUnload` synchronously removing the view from\n      // the DOM.\n      // eslint-disable-next-line more/no-then\n      this.loadAttachmentViews().then(views =>\n        views.forEach(view => view.unload())\n      );\n\n      // No need to handle this one, since it listens to 'unload' itself:\n      //   this.timerView\n\n      this.remove();\n    },\n    onDestroy() {\n      if (this.$el.hasClass('expired')) {\n        return;\n      }\n      this.onUnload();\n    },\n    onChange() {\n      this.renderSent();\n      this.renderQuote();\n    },\n    select(e) {\n      this.$el.trigger('select', { message: this.model });\n      e.stopPropagation();\n    },\n    className() {\n      return ['entry', this.model.get('type')].join(' ');\n    },\n    renderPending() {\n      this.$el.addClass('pending');\n    },\n    renderDone() {\n      this.$el.removeClass('pending');\n    },\n    renderSent() {\n      if (this.model.isOutgoing()) {\n        this.$el.toggleClass('sent', !!this.model.get('sent'));\n      }\n    },\n    renderDelivered() {\n      if (this.model.get('delivered')) {\n        this.$el.addClass('delivered');\n      }\n    },\n    renderRead() {\n      if (!_.isEmpty(this.model.get('read_by'))) {\n        this.$el.addClass('read');\n      }\n    },\n    onErrorsChanged() {\n      if (this.model.isIncoming()) {\n        this.render();\n      } else {\n        this.renderErrors();\n      }\n    },\n    renderErrors() {\n      const errors = this.model.get('errors');\n\n      this.$('.error-icon-container').remove();\n      if (this.errorIconView) {\n        this.errorIconView.remove();\n        this.errorIconView = null;\n      }\n      if (_.size(errors) > 0) {\n        if (this.model.isIncoming()) {\n          this.$('.content')\n            .text(this.model.getDescription())\n            .addClass('error-message');\n        }\n        this.errorIconView = new ErrorIconView({ model: errors[0] });\n        this.errorIconView.render().$el.appendTo(this.$('.bubble'));\n      } else if (!this.hasContents()) {\n        const el = this.$('.content');\n        if (!el || el.length === 0) {\n          this.$('.inner-bubble').append(\"<div class='content'></div>\");\n        }\n        this.$('.content')\n          .text(i18n('noContents'))\n          .addClass('error-message');\n      }\n\n      this.$('.meta .hasRetry').remove();\n      if (this.networkErrorView) {\n        this.networkErrorView.remove();\n        this.networkErrorView = null;\n      }\n      if (this.model.hasNetworkError()) {\n        this.networkErrorView = new NetworkErrorView({ model: this.model });\n        this.$('.meta').prepend(this.networkErrorView.render().el);\n      }\n\n      this.$('.meta .some-failed').remove();\n      if (this.someFailedView) {\n        this.someFailedView.remove();\n        this.someFailedView = null;\n      }\n      if (this.model.someRecipientsFailed()) {\n        this.someFailedView = new SomeFailedView();\n        this.$('.meta').prepend(this.someFailedView.render().el);\n      }\n    },\n    renderControl() {\n      if (this.model.isEndSession() || this.model.isGroupUpdate()) {\n        this.$el.addClass('control');\n        const content = this.$('.content');\n        content.text(this.model.getDescription());\n        emoji_util.parse(content);\n      } else {\n        this.$el.removeClass('control');\n      }\n    },\n    renderExpiring() {\n      if (!this.timerView) {\n        this.timerView = new TimerView({ model: this.model });\n      }\n      this.timerView.setElement(this.$('.timer'));\n      this.timerView.update();\n    },\n    renderQuote() {\n      const props = this.model.getPropsForQuote();\n      if (!props) {\n        return;\n      }\n\n      const contact = this.model.getQuoteContact();\n      if (this.quoteView) {\n        this.quoteView.remove();\n        this.quoteView = null;\n      } else if (contact) {\n        this.listenTo(contact, 'change:color', this.renderQuote);\n      }\n\n      this.quoteView = new Whisper.ReactWrapperView({\n        className: 'quote-wrapper',\n        Component: window.Signal.Components.Quote,\n        props: Object.assign({}, props, {\n          text: props.text ? window.emoji.signalReplace(props.text) : null,\n        }),\n      });\n      this.$('.inner-bubble').prepend(this.quoteView.el);\n    },\n    isImageWithoutCaption() {\n      const attachments = this.model.get('attachments');\n      const body = this.model.get('body');\n      if (!attachments || attachments.length === 0) {\n        return false;\n      }\n\n      if (body && body.trim()) {\n        return false;\n      }\n\n      const first = attachments[0];\n      if (Signal.Util.GoogleChrome.isImageTypeSupported(first.contentType)) {\n        return true;\n      }\n\n      return false;\n    },\n    hasContents() {\n      const attachments = this.model.get('attachments');\n      const hasAttachments = attachments && attachments.length > 0;\n\n      return this.hasTextContents() || hasAttachments;\n    },\n    hasTextContents() {\n      const body = this.model.get('body');\n      const isGroupUpdate = this.model.isGroupUpdate();\n      const isEndSession = this.model.isEndSession();\n\n      const errors = this.model.get('errors');\n      const hasErrors = errors && errors.length > 0;\n      const errorsCanBeContents = this.model.isIncoming() && hasErrors;\n\n      return body || isGroupUpdate || isEndSession || errorsCanBeContents;\n    },\n    render() {\n      const contact = this.model.isIncoming() ? this.model.getContact() : null;\n      const attachments = this.model.get('attachments');\n\n      const errors = this.model.get('errors');\n      const hasErrors = errors && errors.length > 0;\n      const hasAttachments = attachments && attachments.length > 0;\n      const hasBody = this.hasTextContents();\n\n      this.$el.html(\n        Mustache.render(\n          _.result(this, 'template', ''),\n          {\n            message: this.model.get('body'),\n            hasBody,\n            timestamp: this.model.get('sent_at'),\n            sender: (contact && contact.getTitle()) || '',\n            avatar: contact && contact.getAvatar(),\n            profileName: contact && contact.getProfileName(),\n            innerBubbleClasses: this.isImageWithoutCaption() ? '' : 'with-tail',\n            hoverIcon: !hasErrors,\n            hasAttachments,\n            reply: i18n('replyToMessage'),\n          },\n          this.render_partials()\n        )\n      );\n      this.timeStampView.setElement(this.$('.timestamp'));\n      this.timeStampView.update();\n\n      this.renderControl();\n\n      const body = this.$('.body');\n\n      emoji_util.parse(body);\n\n      if (body.length > 0) {\n        const escapedBody = body.html();\n        body.html(Signal.HTML.render(escapedBody));\n      }\n\n      this.renderSent();\n      this.renderDelivered();\n      this.renderRead();\n      this.renderErrors();\n      this.renderExpiring();\n      this.renderQuote();\n\n      // NOTE: We have to do this in the background (`then` instead of `await`)\n      // as our code / Backbone seems to rely on `render` synchronously returning\n      // `this` instead of `Promise MessageView` (this):\n      // eslint-disable-next-line more/no-then\n      this.loadAttachmentViews().then(views =>\n        this.renderAttachmentViews(views)\n      );\n\n      return this;\n    },\n    updateColor() {\n      const bubble = this.$('.bubble');\n\n      // this.contact is known to be non-null if we're registered for color changes\n      const color = this.contact.getColor();\n      if (color) {\n        bubble.removeClass(Whisper.Conversation.COLORS);\n        bubble.addClass(color);\n      }\n      this.avatarView = new (Whisper.View.extend({\n        templateName: 'avatar',\n        render_attributes: { avatar: this.contact.getAvatar() },\n      }))();\n      this.$('.avatar').replaceWith(this.avatarView.render().$('.avatar'));\n    },\n    loadAttachmentViews() {\n      if (this.loadedAttachmentViews !== null) {\n        return this.loadedAttachmentViews;\n      }\n\n      const attachments = this.model.get('attachments') || [];\n      const loadedAttachmentViews = Promise.all(\n        attachments.map(\n          attachment =>\n            new Promise(async resolve => {\n              const attachmentWithData = await loadAttachmentData(attachment);\n              const view = new Whisper.AttachmentView({\n                model: attachmentWithData,\n                timestamp: this.model.get('sent_at'),\n              });\n\n              this.listenTo(view, 'update', () => {\n                // NOTE: Can we do without `updated` flag now that we use promises?\n                view.updated = true;\n                resolve(view);\n              });\n\n              view.render();\n            })\n        )\n      );\n\n      // Memoize attachment views to avoid double loading:\n      this.loadedAttachmentViews = loadedAttachmentViews;\n\n      return loadedAttachmentViews;\n    },\n    renderAttachmentViews(views) {\n      views.forEach(view => this.renderAttachmentView(view));\n    },\n    renderAttachmentView(view) {\n      if (!view.updated) {\n        throw new Error(\n          'Invariant violation:' +\n            ' Cannot render an attachment view that isn\u2019t ready'\n        );\n      }\n\n      const parent = this.$('.attachments')[0];\n      const isViewAlreadyChild = parent === view.el.parentNode;\n      if (isViewAlreadyChild) {\n        return;\n      }\n\n      if (view.el.parentNode) {\n        view.el.parentNode.removeChild(view.el);\n      }\n\n      this.trigger('beforeChangeHeight');\n      this.$('.attachments').append(view.el);\n      view.setElement(view.el);\n      this.trigger('afterChangeHeight');\n    },\n  });\n})();\n"], "fixing_code": ["/* global Whisper: false */\n/* global i18n: false */\n/* global textsecure: false */\n/* global _: false */\n/* global emoji_util: false */\n/* global Mustache: false */\n/* global $: false */\n\n// eslint-disable-next-line func-names\n(function() {\n  'use strict';\n\n  const { Signal } = window;\n  const { loadAttachmentData } = window.Signal.Migrations;\n\n  window.Whisper = window.Whisper || {};\n\n  const URL_REGEX = /(^|[\\s\\n]|<br\\/?>)((?:https?|ftp):\\/\\/[-A-Z0-9\\u00A0-\\uD7FF\\uE000-\\uFDCF\\uFDF0-\\uFFFD+\\u0026\\u2019@#/%?=()~_|!:,.;]*[-A-Z0-9+\\u0026@#/%=~()_|])/gi;\n\n  const ErrorIconView = Whisper.View.extend({\n    templateName: 'error-icon',\n    className: 'error-icon-container',\n    initialize() {\n      if (this.model.name === 'UnregisteredUserError') {\n        this.$el.addClass('unregistered-user-error');\n      }\n    },\n  });\n  const NetworkErrorView = Whisper.View.extend({\n    tagName: 'span',\n    className: 'hasRetry',\n    templateName: 'hasRetry',\n    render_attributes() {\n      let messageNotSent;\n\n      if (!this.model.someRecipientsFailed()) {\n        messageNotSent = i18n('messageNotSent');\n      }\n\n      return {\n        messageNotSent,\n        resend: i18n('resend'),\n      };\n    },\n  });\n  const SomeFailedView = Whisper.View.extend({\n    tagName: 'span',\n    className: 'some-failed',\n    templateName: 'some-failed',\n    render_attributes() {\n      return {\n        someFailed: i18n('someRecipientsFailed'),\n      };\n    },\n  });\n  const TimerView = Whisper.View.extend({\n    templateName: 'hourglass',\n    initialize() {\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    update() {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n      if (this.model.isExpired()) {\n        return this;\n      }\n      if (this.model.isExpiring()) {\n        this.render();\n        const totalTime = this.model.get('expireTimer') * 1000;\n        const remainingTime = this.model.msTilExpire();\n        const elapsed = (totalTime - remainingTime) / totalTime;\n        this.$('.sand').css('transform', `translateY(${elapsed * 100}%)`);\n        this.$el.css('display', 'inline-block');\n        this.timeout = setTimeout(\n          this.update.bind(this),\n          Math.max(totalTime / 100, 500)\n        );\n      }\n      return this;\n    },\n  });\n\n  Whisper.ExpirationTimerUpdateView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'expirationTimerUpdate advisory',\n    templateName: 'expirationTimerUpdate',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getExpirationTimerUpdateSource();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    render_attributes() {\n      const seconds = this.model.get('expirationTimerUpdate').expireTimer;\n      let timerMessage;\n\n      const timerUpdate = this.model.get('expirationTimerUpdate');\n      const prettySeconds = Whisper.ExpirationTimerOptions.getName(seconds);\n\n      if (timerUpdate && timerUpdate.fromSync) {\n        timerMessage = i18n('timerSetOnSync', prettySeconds);\n      } else if (this.conversation.id === textsecure.storage.user.getNumber()) {\n        timerMessage = i18n('youChangedTheTimer', prettySeconds);\n      } else {\n        timerMessage = i18n('theyChangedTheTimer', [\n          this.conversation.getTitle(),\n          prettySeconds,\n        ]);\n      }\n      return { content: timerMessage };\n    },\n  });\n\n  Whisper.KeyChangeView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'keychange advisory',\n    templateName: 'keychange',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getModelForKeyChange();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    events: {\n      'click .content': 'showIdentity',\n    },\n    render_attributes() {\n      return {\n        content: this.model.getNotificationText(),\n      };\n    },\n    showIdentity() {\n      this.$el.trigger('show-identity', this.conversation);\n    },\n  });\n\n  Whisper.VerifiedChangeView = Whisper.View.extend({\n    tagName: 'li',\n    className: 'verified-change advisory',\n    templateName: 'verified-change',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      this.conversation = this.model.getModelForVerifiedChange();\n      this.listenTo(this.conversation, 'change', this.render);\n      this.listenTo(this.model, 'unload', this.remove);\n    },\n    events: {\n      'click .content': 'showIdentity',\n    },\n    render_attributes() {\n      let key;\n\n      if (this.model.get('verified')) {\n        if (this.model.get('local')) {\n          key = 'youMarkedAsVerified';\n        } else {\n          key = 'youMarkedAsVerifiedOtherDevice';\n        }\n        return {\n          icon: 'verified',\n          content: i18n(key, this.conversation.getTitle()),\n        };\n      }\n\n      if (this.model.get('local')) {\n        key = 'youMarkedAsNotVerified';\n      } else {\n        key = 'youMarkedAsNotVerifiedOtherDevice';\n      }\n\n      return {\n        icon: 'shield',\n        content: i18n(key, this.conversation.getTitle()),\n      };\n    },\n    showIdentity() {\n      this.$el.trigger('show-identity', this.conversation);\n    },\n  });\n\n  Whisper.MessageView = Whisper.View.extend({\n    tagName: 'li',\n    templateName: 'message',\n    id() {\n      return this.model.id;\n    },\n    initialize() {\n      //   loadedAttachmentViews :: Promise (Array AttachmentView) | null\n      this.loadedAttachmentViews = null;\n\n      this.listenTo(this.model, 'change:errors', this.onErrorsChanged);\n      this.listenTo(this.model, 'change:body', this.render);\n      this.listenTo(this.model, 'change:delivered', this.renderDelivered);\n      this.listenTo(this.model, 'change:read_by', this.renderRead);\n      this.listenTo(\n        this.model,\n        'change:expirationStartTimestamp',\n        this.renderExpiring\n      );\n      this.listenTo(this.model, 'change', this.onChange);\n      this.listenTo(\n        this.model,\n        'change:flags change:group_update',\n        this.renderControl\n      );\n      this.listenTo(this.model, 'destroy', this.onDestroy);\n      this.listenTo(this.model, 'unload', this.onUnload);\n      this.listenTo(this.model, 'expired', this.onExpired);\n      this.listenTo(this.model, 'pending', this.renderPending);\n      this.listenTo(this.model, 'done', this.renderDone);\n      this.timeStampView = new Whisper.ExtendedTimestampView();\n\n      this.contact = this.model.isIncoming() ? this.model.getContact() : null;\n      if (this.contact) {\n        this.listenTo(this.contact, 'change:color', this.updateColor);\n      }\n    },\n    events: {\n      'click .retry': 'retryMessage',\n      'click .error-icon': 'select',\n      'click .timestamp': 'select',\n      'click .status': 'select',\n      'click .some-failed': 'select',\n      'click .error-message': 'select',\n      'click .menu-container': 'showMenu',\n      'click .menu-list .reply': 'onReply',\n    },\n    retryMessage() {\n      const retrys = _.filter(\n        this.model.get('errors'),\n        this.model.isReplayableError.bind(this.model)\n      );\n      _.map(retrys, 'number').forEach(number => {\n        this.model.resend(number);\n      });\n    },\n    showMenu(e) {\n      if (this.menuVisible) {\n        return;\n      }\n\n      this.menuVisible = true;\n      e.stopPropagation();\n\n      this.$('.menu-list').show();\n      $(document).one('click', () => {\n        this.hideMenu();\n      });\n    },\n    hideMenu() {\n      this.menuVisible = false;\n      this.$('.menu-list').hide();\n    },\n    onReply() {\n      this.model.trigger('reply', this.model);\n    },\n    onExpired() {\n      this.$el.addClass('expired');\n      this.$el.find('.bubble').one('webkitAnimationEnd animationend', e => {\n        if (e.target === this.$('.bubble')[0]) {\n          this.remove();\n        }\n      });\n\n      // Failsafe: if in the background, animation events don't fire\n      setTimeout(this.remove.bind(this), 1000);\n    },\n    onUnload() {\n      if (this.avatarView) {\n        this.avatarView.remove();\n      }\n      if (this.errorIconView) {\n        this.errorIconView.remove();\n      }\n      if (this.networkErrorView) {\n        this.networkErrorView.remove();\n      }\n      if (this.someFailedView) {\n        this.someFailedView.remove();\n      }\n      if (this.timeStampView) {\n        this.timeStampView.remove();\n      }\n      if (this.quoteView) {\n        this.quoteView.remove();\n      }\n\n      // NOTE: We have to do this in the background (`then` instead of `await`)\n      // as our tests rely on `onUnload` synchronously removing the view from\n      // the DOM.\n      // eslint-disable-next-line more/no-then\n      this.loadAttachmentViews().then(views =>\n        views.forEach(view => view.unload())\n      );\n\n      // No need to handle this one, since it listens to 'unload' itself:\n      //   this.timerView\n\n      this.remove();\n    },\n    onDestroy() {\n      if (this.$el.hasClass('expired')) {\n        return;\n      }\n      this.onUnload();\n    },\n    onChange() {\n      this.renderSent();\n      this.renderQuote();\n    },\n    select(e) {\n      this.$el.trigger('select', { message: this.model });\n      e.stopPropagation();\n    },\n    className() {\n      return ['entry', this.model.get('type')].join(' ');\n    },\n    renderPending() {\n      this.$el.addClass('pending');\n    },\n    renderDone() {\n      this.$el.removeClass('pending');\n    },\n    renderSent() {\n      if (this.model.isOutgoing()) {\n        this.$el.toggleClass('sent', !!this.model.get('sent'));\n      }\n    },\n    renderDelivered() {\n      if (this.model.get('delivered')) {\n        this.$el.addClass('delivered');\n      }\n    },\n    renderRead() {\n      if (!_.isEmpty(this.model.get('read_by'))) {\n        this.$el.addClass('read');\n      }\n    },\n    onErrorsChanged() {\n      if (this.model.isIncoming()) {\n        this.render();\n      } else {\n        this.renderErrors();\n      }\n    },\n    renderErrors() {\n      const errors = this.model.get('errors');\n\n      this.$('.error-icon-container').remove();\n      if (this.errorIconView) {\n        this.errorIconView.remove();\n        this.errorIconView = null;\n      }\n      if (_.size(errors) > 0) {\n        if (this.model.isIncoming()) {\n          this.$('.content')\n            .text(this.model.getDescription())\n            .addClass('error-message');\n        }\n        this.errorIconView = new ErrorIconView({ model: errors[0] });\n        this.errorIconView.render().$el.appendTo(this.$('.bubble'));\n      } else if (!this.hasContents()) {\n        const el = this.$('.content');\n        if (!el || el.length === 0) {\n          this.$('.inner-bubble').append(\"<div class='content'></div>\");\n        }\n        this.$('.content')\n          .text(i18n('noContents'))\n          .addClass('error-message');\n      }\n\n      this.$('.meta .hasRetry').remove();\n      if (this.networkErrorView) {\n        this.networkErrorView.remove();\n        this.networkErrorView = null;\n      }\n      if (this.model.hasNetworkError()) {\n        this.networkErrorView = new NetworkErrorView({ model: this.model });\n        this.$('.meta').prepend(this.networkErrorView.render().el);\n      }\n\n      this.$('.meta .some-failed').remove();\n      if (this.someFailedView) {\n        this.someFailedView.remove();\n        this.someFailedView = null;\n      }\n      if (this.model.someRecipientsFailed()) {\n        this.someFailedView = new SomeFailedView();\n        this.$('.meta').prepend(this.someFailedView.render().el);\n      }\n    },\n    renderControl() {\n      if (this.model.isEndSession() || this.model.isGroupUpdate()) {\n        this.$el.addClass('control');\n        const content = this.$('.content');\n        content.text(this.model.getDescription());\n        emoji_util.parse(content);\n      } else {\n        this.$el.removeClass('control');\n      }\n    },\n    renderExpiring() {\n      if (!this.timerView) {\n        this.timerView = new TimerView({ model: this.model });\n      }\n      this.timerView.setElement(this.$('.timer'));\n      this.timerView.update();\n    },\n    renderQuote() {\n      const props = this.model.getPropsForQuote();\n      if (!props) {\n        return;\n      }\n\n      const contact = this.model.getQuoteContact();\n      if (this.quoteView) {\n        this.quoteView.remove();\n        this.quoteView = null;\n      } else if (contact) {\n        this.listenTo(contact, 'change:color', this.renderQuote);\n      }\n\n      this.quoteView = new Whisper.ReactWrapperView({\n        className: 'quote-wrapper',\n        Component: window.Signal.Components.Quote,\n        props: Object.assign({}, props, {\n          text: props.text ? window.emoji.signalReplace(props.text) : null,\n        }),\n      });\n      this.$('.inner-bubble').prepend(this.quoteView.el);\n    },\n    isImageWithoutCaption() {\n      const attachments = this.model.get('attachments');\n      const body = this.model.get('body');\n      if (!attachments || attachments.length === 0) {\n        return false;\n      }\n\n      if (body && body.trim()) {\n        return false;\n      }\n\n      const first = attachments[0];\n      if (Signal.Util.GoogleChrome.isImageTypeSupported(first.contentType)) {\n        return true;\n      }\n\n      return false;\n    },\n    hasContents() {\n      const attachments = this.model.get('attachments');\n      const hasAttachments = attachments && attachments.length > 0;\n\n      return this.hasTextContents() || hasAttachments;\n    },\n    hasTextContents() {\n      const body = this.model.get('body');\n      const isGroupUpdate = this.model.isGroupUpdate();\n      const isEndSession = this.model.isEndSession();\n\n      const errors = this.model.get('errors');\n      const hasErrors = errors && errors.length > 0;\n      const errorsCanBeContents = this.model.isIncoming() && hasErrors;\n\n      return body || isGroupUpdate || isEndSession || errorsCanBeContents;\n    },\n    render() {\n      const contact = this.model.isIncoming() ? this.model.getContact() : null;\n      const attachments = this.model.get('attachments');\n\n      const errors = this.model.get('errors');\n      const hasErrors = errors && errors.length > 0;\n      const hasAttachments = attachments && attachments.length > 0;\n      const hasBody = this.hasTextContents();\n\n      this.$el.html(\n        Mustache.render(\n          _.result(this, 'template', ''),\n          {\n            message: this.model.get('body'),\n            hasBody,\n            timestamp: this.model.get('sent_at'),\n            sender: (contact && contact.getTitle()) || '',\n            avatar: contact && contact.getAvatar(),\n            profileName: contact && contact.getProfileName(),\n            innerBubbleClasses: this.isImageWithoutCaption() ? '' : 'with-tail',\n            hoverIcon: !hasErrors,\n            hasAttachments,\n            reply: i18n('replyToMessage'),\n          },\n          this.render_partials()\n        )\n      );\n      this.timeStampView.setElement(this.$('.timestamp'));\n      this.timeStampView.update();\n\n      this.renderControl();\n\n      const body = this.$('.body');\n\n      emoji_util.parse(body);\n\n      if (body.length > 0) {\n        const escapedBody = body.html();\n        body.html(\n          escapedBody\n            .replace(/\\n/g, '<br>')\n            .replace(URL_REGEX, \"$1<a href='$2' target='_blank'>$2</a>\")\n        );\n      }\n\n      this.renderSent();\n      this.renderDelivered();\n      this.renderRead();\n      this.renderErrors();\n      this.renderExpiring();\n      this.renderQuote();\n\n      // NOTE: We have to do this in the background (`then` instead of `await`)\n      // as our code / Backbone seems to rely on `render` synchronously returning\n      // `this` instead of `Promise MessageView` (this):\n      // eslint-disable-next-line more/no-then\n      this.loadAttachmentViews().then(views =>\n        this.renderAttachmentViews(views)\n      );\n\n      return this;\n    },\n    updateColor() {\n      const bubble = this.$('.bubble');\n\n      // this.contact is known to be non-null if we're registered for color changes\n      const color = this.contact.getColor();\n      if (color) {\n        bubble.removeClass(Whisper.Conversation.COLORS);\n        bubble.addClass(color);\n      }\n      this.avatarView = new (Whisper.View.extend({\n        templateName: 'avatar',\n        render_attributes: { avatar: this.contact.getAvatar() },\n      }))();\n      this.$('.avatar').replaceWith(this.avatarView.render().$('.avatar'));\n    },\n    loadAttachmentViews() {\n      if (this.loadedAttachmentViews !== null) {\n        return this.loadedAttachmentViews;\n      }\n\n      const attachments = this.model.get('attachments') || [];\n      const loadedAttachmentViews = Promise.all(\n        attachments.map(\n          attachment =>\n            new Promise(async resolve => {\n              const attachmentWithData = await loadAttachmentData(attachment);\n              const view = new Whisper.AttachmentView({\n                model: attachmentWithData,\n                timestamp: this.model.get('sent_at'),\n              });\n\n              this.listenTo(view, 'update', () => {\n                // NOTE: Can we do without `updated` flag now that we use promises?\n                view.updated = true;\n                resolve(view);\n              });\n\n              view.render();\n            })\n        )\n      );\n\n      // Memoize attachment views to avoid double loading:\n      this.loadedAttachmentViews = loadedAttachmentViews;\n\n      return loadedAttachmentViews;\n    },\n    renderAttachmentViews(views) {\n      views.forEach(view => this.renderAttachmentView(view));\n    },\n    renderAttachmentView(view) {\n      if (!view.updated) {\n        throw new Error(\n          'Invariant violation:' +\n            ' Cannot render an attachment view that isn\u2019t ready'\n        );\n      }\n\n      const parent = this.$('.attachments')[0];\n      const isViewAlreadyChild = parent === view.el.parentNode;\n      if (isViewAlreadyChild) {\n        return;\n      }\n\n      if (view.el.parentNode) {\n        view.el.parentNode.removeChild(view.el);\n      }\n\n      this.trigger('beforeChangeHeight');\n      this.$('.attachments').append(view.el);\n      view.setElement(view.el);\n      this.trigger('afterChangeHeight');\n    },\n  });\n})();\n"], "filenames": ["js/views/message_view.js"], "buggy_code_start_loc": [16], "buggy_code_end_loc": [512], "fixing_code_start_loc": [17], "fixing_code_end_loc": [518], "type": "CWE-79", "message": "js/views/message_view.js in Open Whisper Signal (aka Signal-Desktop) before 1.10.1 allows XSS via a URL.", "other": {"cve": {"id": "CVE-2018-10994", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-14T23:29:00.250", "lastModified": "2018-06-18T14:19:01.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "js/views/message_view.js in Open Whisper Signal (aka Signal-Desktop) before 1.10.1 allows XSS via a URL."}, {"lang": "es", "value": "js/views/message_view.js en Open Whisper Signal (tambi\u00e9n conocido como Signal-Desktop) en versiones anteriores a la 1.10.1 permite Cross-Site Scripting (XSS) mediante una URL."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:signal:signal-desktop:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "23C19769-6E5A-4095-A4F9-66A8D35680D5"}]}]}], "references": [{"url": "https://github.com/signalapp/Signal-Desktop/commit/bfbd84f5d1308cdfcb08a1727821f7103be151ea", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/signalapp/Signal-Desktop/releases/tag/v1.10.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://twitter.com/bcrypt/status/995057030304952320", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://twitter.com/lorenzoFB/status/995048605399633926", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://twitter.com/ortegaalfredo/status/995940738839056384", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/signalapp/Signal-Desktop/commit/bfbd84f5d1308cdfcb08a1727821f7103be151ea"}}