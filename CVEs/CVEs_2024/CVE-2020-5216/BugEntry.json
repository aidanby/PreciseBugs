{"buggy_code": ["# frozen_string_literal: true\nrequire_relative \"policy_management\"\nrequire_relative \"content_security_policy_config\"\n\nmodule SecureHeaders\n  class ContentSecurityPolicy\n    include PolicyManagement\n\n    def initialize(config = nil)\n      @config = if config.is_a?(Hash)\n        if config[:report_only]\n          ContentSecurityPolicyReportOnlyConfig.new(config || DEFAULT_CONFIG)\n        else\n          ContentSecurityPolicyConfig.new(config || DEFAULT_CONFIG)\n        end\n      elsif config.nil?\n        ContentSecurityPolicyConfig.new(DEFAULT_CONFIG)\n      else\n        config\n      end\n\n      @preserve_schemes = @config.preserve_schemes\n      @script_nonce = @config.script_nonce\n      @style_nonce = @config.style_nonce\n    end\n\n    ##\n    # Returns the name to use for the header. Either \"Content-Security-Policy\" or\n    # \"Content-Security-Policy-Report-Only\"\n    def name\n      @config.class.const_get(:HEADER_NAME)\n    end\n\n    ##\n    # Return the value of the CSP header\n    def value\n      @value ||= if @config\n        build_value\n      else\n        DEFAULT_VALUE\n      end\n    end\n\n    private\n\n    # Private: converts the config object into a string representing a policy.\n    # Places default-src at the first directive and report-uri as the last. All\n    # others are presented in alphabetical order.\n    #\n    # Returns a content security policy header value.\n    def build_value\n      directives.map do |directive_name|\n        case DIRECTIVE_VALUE_TYPES[directive_name]\n        when :source_list, :require_sri_for_list # require_sri is a simple set of strings that don't need to deal with symbol casing\n          build_source_list_directive(directive_name)\n        when :boolean\n          symbol_to_hyphen_case(directive_name) if @config.directive_value(directive_name)\n        when :sandbox_list\n          build_sandbox_list_directive(directive_name)\n        when :media_type_list\n          build_media_type_list_directive(directive_name)\n        end\n      end.compact.join(\"; \")\n    end\n\n    def build_sandbox_list_directive(directive)\n      return unless sandbox_list = @config.directive_value(directive)\n      max_strict_policy = case sandbox_list\n      when Array\n        sandbox_list.empty?\n      when true\n        true\n      else\n        false\n      end\n\n      # A maximally strict sandbox policy is just the `sandbox` directive,\n      # whith no configuraiton values.\n      if max_strict_policy\n        symbol_to_hyphen_case(directive)\n      elsif sandbox_list && sandbox_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          sandbox_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    def build_media_type_list_directive(directive)\n      return unless media_type_list = @config.directive_value(directive)\n      if media_type_list && media_type_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          media_type_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    # Private: builds a string that represents one directive in a minified form.\n    #\n    # directive_name - a symbol representing the various ALL_DIRECTIVES\n    #\n    # Returns a string representing a directive.\n    def build_source_list_directive(directive)\n      source_list = @config.directive_value(directive)\n      if source_list != OPT_OUT && source_list && source_list.any?\n        minified_source_list = minify_source_list(directive, source_list).join(\" \")\n\n        if minified_source_list.include?(\";\")\n          Kernel.warn(\"#{directive} contains a ; in '#{minified_source_list}' which will raise an error in future versions. It has been replaced with a blank space.\")\n        end\n\n        escaped_source_list = minified_source_list.gsub(\";\", \" \")\n        [symbol_to_hyphen_case(directive), escaped_source_list].join(\" \").strip\n      end\n    end\n\n    # If a directive contains *, all other values are omitted.\n    # If a directive contains 'none' but has other values, 'none' is ommitted.\n    # Schemes are stripped (see http://www.w3.org/TR/CSP2/#match-source-expression)\n    def minify_source_list(directive, source_list)\n      source_list = source_list.compact\n      if source_list.include?(STAR)\n        keep_wildcard_sources(source_list)\n      else\n        source_list = populate_nonces(directive, source_list)\n        source_list = reject_all_values_if_none(source_list)\n\n        unless directive == REPORT_URI || @preserve_schemes\n          source_list = strip_source_schemes(source_list)\n        end\n        dedup_source_list(source_list)\n      end\n    end\n\n    # Discard trailing entries (excluding unsafe-*) since * accomplishes the same.\n    def keep_wildcard_sources(source_list)\n      source_list.select { |value| WILDCARD_SOURCES.include?(value) }\n    end\n\n    # Discard any 'none' values if more directives are supplied since none may override values.\n    def reject_all_values_if_none(source_list)\n      if source_list.length > 1\n        source_list.reject { |value| value == NONE }\n      else\n        source_list\n      end\n    end\n\n    # Removes duplicates and sources that already match an existing wild card.\n    #\n    # e.g. *.github.com asdf.github.com becomes *.github.com\n    def dedup_source_list(sources)\n      sources = sources.uniq\n      wild_sources = sources.select { |source| source =~ STAR_REGEXP }\n\n      if wild_sources.any?\n        sources.reject do |source|\n          !wild_sources.include?(source) &&\n            wild_sources.any? { |pattern| File.fnmatch(pattern, source) }\n        end\n      else\n        sources\n      end\n    end\n\n    # Private: append a nonce to the script/style directories if script_nonce\n    # or style_nonce are provided.\n    def populate_nonces(directive, source_list)\n      case directive\n      when SCRIPT_SRC\n        append_nonce(source_list, @script_nonce)\n      when STYLE_SRC\n        append_nonce(source_list, @style_nonce)\n      else\n        source_list\n      end\n    end\n\n    # Private: adds a nonce or 'unsafe-inline' depending on browser support.\n    # If a nonce is populated, inline content is assumed.\n    #\n    # While CSP is backward compatible in that a policy with a nonce will ignore\n    # unsafe-inline, this is more concise.\n    def append_nonce(source_list, nonce)\n      if nonce\n        source_list.push(\"'nonce-#{nonce}'\")\n        source_list.push(UNSAFE_INLINE) unless @config[:disable_nonce_backwards_compatibility]\n      end\n\n      source_list\n    end\n\n    # Private: return the list of directives,\n    # starting with default-src and ending with report-uri.\n    def directives\n      [\n        DEFAULT_SRC,\n        BODY_DIRECTIVES,\n        REPORT_URI,\n      ].flatten\n    end\n\n    # Private: Remove scheme from source expressions.\n    def strip_source_schemes(source_list)\n      source_list.map { |source_expression| source_expression.sub(HTTP_SCHEME_REGEX, \"\") }\n    end\n\n    def symbol_to_hyphen_case(sym)\n      sym.to_s.tr(\"_\", \"-\")\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"spec_helper\"\n\nmodule SecureHeaders\n  describe ContentSecurityPolicy do\n    let (:default_opts) do\n      {\n        default_src: %w(https:),\n        img_src: %w(https: data:),\n        script_src: %w('unsafe-inline' 'unsafe-eval' https: data:),\n        style_src: %w('unsafe-inline' https: about:),\n        report_uri: %w(/csp_report)\n      }\n    end\n\n    describe \"#name\" do\n      context \"when in report-only mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts.merge(report_only: true)).name).to eq(ContentSecurityPolicyReportOnlyConfig::HEADER_NAME) }\n      end\n\n      context \"when in enforce mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts).name).to eq(ContentSecurityPolicyConfig::HEADER_NAME) }\n      end\n    end\n\n    describe \"#value\" do\n      it \"uses a safe but non-breaking default value\" do\n        expect(ContentSecurityPolicy.new.value).to eq(\"default-src https:; form-action 'self'; img-src https: data: 'self'; object-src 'none'; script-src https:; style-src 'self' 'unsafe-inline' https:\")\n      end\n\n      it \"deprecates and escapes semicolons in directive source lists\" do\n        expect(Kernel).to receive(:warn).with(\"frame_ancestors contains a ; in 'google.com;script-src *;.;' which will raise an error in future versions. It has been replaced with a blank space.\")\n        expect(ContentSecurityPolicy.new(frame_ancestors: %w(https://google.com;script-src https://*;.;)).value).to eq(\"frame-ancestors google.com script-src * .\")\n      end\n\n      it \"discards 'none' values if any other source expressions are present\" do\n        csp = ContentSecurityPolicy.new(default_opts.merge(child_src: %w('self' 'none')))\n        expect(csp.value).not_to include(\"'none'\")\n      end\n\n      it \"discards source expressions (besides unsafe-* and non-host source values) when * is present\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(* 'unsafe-inline' 'unsafe-eval' http: https: example.org data: blob:))\n        expect(csp.value).to eq(\"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:\")\n      end\n\n      it \"minifies source expressions based on overlapping wildcards\" do\n        config = {\n          default_src: %w(a.example.org b.example.org *.example.org https://*.example.org)\n        }\n        csp = ContentSecurityPolicy.new(config)\n        expect(csp.value).to eq(\"default-src *.example.org\")\n      end\n\n      it \"removes http/s schemes from hosts\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not build directives with a value of OPT_OUT (and bypasses directive requirements)\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), script_src: OPT_OUT)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not remove schemes from report-uri values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https:), report_uri: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src https:; report-uri https://example.org\")\n      end\n\n      it \"does not remove schemes when :preserve_schemes is true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), preserve_schemes: true)\n        expect(csp.value).to eq(\"default-src https://example.org\")\n      end\n\n      it \"removes nil from source lists\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\", nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is an empty array (or all nil)\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: [nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is nil\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: nil)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does add a boolean directive if the value is true\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: true)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content; upgrade-insecure-requests\")\n      end\n\n      it \"does not add a boolean directive if the value is false\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: false)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content\")\n      end\n\n      it \"deduplicates any source expressions\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org example.org example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed no sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: [])\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: true)\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates sandbox policy when passed valid sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: %w(allow-forms allow-scripts))\n        expect(csp.value).to eq(\"default-src example.org; sandbox allow-forms allow-scripts\")\n      end\n\n      it \"does not emit a warning when using frame-src\" do\n        expect(Kernel).to_not receive(:warn)\n        ContentSecurityPolicy.new(default_src: %w('self'), frame_src: %w('self')).value\n      end\n\n      it \"allows script as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(script))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for script\")\n      end\n\n      it \"allows style as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(style))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for style\")\n      end\n\n      it \"allows script and style as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(script style))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for script style\")\n      end\n\n      it \"includes prefetch-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), prefetch_src: %w(foo.com))\n        expect(csp.value).to eq(\"default-src 'self'; prefetch-src foo.com\")\n      end\n\n      it \"includes navigate-to\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), navigate_to: %w(foo.com))\n        expect(csp.value).to eq(\"default-src 'self'; navigate-to foo.com\")\n      end\n\n      it \"supports strict-dynamic\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456})\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456' 'unsafe-inline'\")\n      end\n\n      it \"supports strict-dynamic and opting out of the appended 'unsafe-inline'\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456, disable_nonce_backwards_compatibility: true })\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456'\")\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\nrequire_relative \"policy_management\"\nrequire_relative \"content_security_policy_config\"\n\nmodule SecureHeaders\n  class ContentSecurityPolicy\n    include PolicyManagement\n\n    def initialize(config = nil)\n      @config = if config.is_a?(Hash)\n        if config[:report_only]\n          ContentSecurityPolicyReportOnlyConfig.new(config || DEFAULT_CONFIG)\n        else\n          ContentSecurityPolicyConfig.new(config || DEFAULT_CONFIG)\n        end\n      elsif config.nil?\n        ContentSecurityPolicyConfig.new(DEFAULT_CONFIG)\n      else\n        config\n      end\n\n      @preserve_schemes = @config.preserve_schemes\n      @script_nonce = @config.script_nonce\n      @style_nonce = @config.style_nonce\n    end\n\n    ##\n    # Returns the name to use for the header. Either \"Content-Security-Policy\" or\n    # \"Content-Security-Policy-Report-Only\"\n    def name\n      @config.class.const_get(:HEADER_NAME)\n    end\n\n    ##\n    # Return the value of the CSP header\n    def value\n      @value ||= if @config\n        build_value\n      else\n        DEFAULT_VALUE\n      end\n    end\n\n    private\n\n    # Private: converts the config object into a string representing a policy.\n    # Places default-src at the first directive and report-uri as the last. All\n    # others are presented in alphabetical order.\n    #\n    # Returns a content security policy header value.\n    def build_value\n      directives.map do |directive_name|\n        case DIRECTIVE_VALUE_TYPES[directive_name]\n        when :source_list, :require_sri_for_list # require_sri is a simple set of strings that don't need to deal with symbol casing\n          build_source_list_directive(directive_name)\n        when :boolean\n          symbol_to_hyphen_case(directive_name) if @config.directive_value(directive_name)\n        when :sandbox_list\n          build_sandbox_list_directive(directive_name)\n        when :media_type_list\n          build_media_type_list_directive(directive_name)\n        end\n      end.compact.join(\"; \")\n    end\n\n    def build_sandbox_list_directive(directive)\n      return unless sandbox_list = @config.directive_value(directive)\n      max_strict_policy = case sandbox_list\n      when Array\n        sandbox_list.empty?\n      when true\n        true\n      else\n        false\n      end\n\n      # A maximally strict sandbox policy is just the `sandbox` directive,\n      # whith no configuraiton values.\n      if max_strict_policy\n        symbol_to_hyphen_case(directive)\n      elsif sandbox_list && sandbox_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          sandbox_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    def build_media_type_list_directive(directive)\n      return unless media_type_list = @config.directive_value(directive)\n      if media_type_list && media_type_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          media_type_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    # Private: builds a string that represents one directive in a minified form.\n    #\n    # directive_name - a symbol representing the various ALL_DIRECTIVES\n    #\n    # Returns a string representing a directive.\n    def build_source_list_directive(directive)\n      source_list = @config.directive_value(directive)\n      if source_list != OPT_OUT && source_list && source_list.any?\n        minified_source_list = minify_source_list(directive, source_list).join(\" \")\n\n        if minified_source_list =~ /(\\n|;)/\n          Kernel.warn(\"#{directive} contains a #{$1} in #{minified_source_list.inspect} which will raise an error in future versions. It has been replaced with a blank space.\")\n        end\n\n        escaped_source_list = minified_source_list.gsub(/[\\n;]/, \" \")\n        [symbol_to_hyphen_case(directive), escaped_source_list].join(\" \").strip\n      end\n    end\n\n    # If a directive contains *, all other values are omitted.\n    # If a directive contains 'none' but has other values, 'none' is ommitted.\n    # Schemes are stripped (see http://www.w3.org/TR/CSP2/#match-source-expression)\n    def minify_source_list(directive, source_list)\n      source_list = source_list.compact\n      if source_list.include?(STAR)\n        keep_wildcard_sources(source_list)\n      else\n        source_list = populate_nonces(directive, source_list)\n        source_list = reject_all_values_if_none(source_list)\n\n        unless directive == REPORT_URI || @preserve_schemes\n          source_list = strip_source_schemes(source_list)\n        end\n        dedup_source_list(source_list)\n      end\n    end\n\n    # Discard trailing entries (excluding unsafe-*) since * accomplishes the same.\n    def keep_wildcard_sources(source_list)\n      source_list.select { |value| WILDCARD_SOURCES.include?(value) }\n    end\n\n    # Discard any 'none' values if more directives are supplied since none may override values.\n    def reject_all_values_if_none(source_list)\n      if source_list.length > 1\n        source_list.reject { |value| value == NONE }\n      else\n        source_list\n      end\n    end\n\n    # Removes duplicates and sources that already match an existing wild card.\n    #\n    # e.g. *.github.com asdf.github.com becomes *.github.com\n    def dedup_source_list(sources)\n      sources = sources.uniq\n      wild_sources = sources.select { |source| source =~ STAR_REGEXP }\n\n      if wild_sources.any?\n        sources.reject do |source|\n          !wild_sources.include?(source) &&\n            wild_sources.any? { |pattern| File.fnmatch(pattern, source) }\n        end\n      else\n        sources\n      end\n    end\n\n    # Private: append a nonce to the script/style directories if script_nonce\n    # or style_nonce are provided.\n    def populate_nonces(directive, source_list)\n      case directive\n      when SCRIPT_SRC\n        append_nonce(source_list, @script_nonce)\n      when STYLE_SRC\n        append_nonce(source_list, @style_nonce)\n      else\n        source_list\n      end\n    end\n\n    # Private: adds a nonce or 'unsafe-inline' depending on browser support.\n    # If a nonce is populated, inline content is assumed.\n    #\n    # While CSP is backward compatible in that a policy with a nonce will ignore\n    # unsafe-inline, this is more concise.\n    def append_nonce(source_list, nonce)\n      if nonce\n        source_list.push(\"'nonce-#{nonce}'\")\n        source_list.push(UNSAFE_INLINE) unless @config[:disable_nonce_backwards_compatibility]\n      end\n\n      source_list\n    end\n\n    # Private: return the list of directives,\n    # starting with default-src and ending with report-uri.\n    def directives\n      [\n        DEFAULT_SRC,\n        BODY_DIRECTIVES,\n        REPORT_URI,\n      ].flatten\n    end\n\n    # Private: Remove scheme from source expressions.\n    def strip_source_schemes(source_list)\n      source_list.map { |source_expression| source_expression.sub(HTTP_SCHEME_REGEX, \"\") }\n    end\n\n    def symbol_to_hyphen_case(sym)\n      sym.to_s.tr(\"_\", \"-\")\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"spec_helper\"\n\nmodule SecureHeaders\n  describe ContentSecurityPolicy do\n    let (:default_opts) do\n      {\n        default_src: %w(https:),\n        img_src: %w(https: data:),\n        script_src: %w('unsafe-inline' 'unsafe-eval' https: data:),\n        style_src: %w('unsafe-inline' https: about:),\n        report_uri: %w(/csp_report)\n      }\n    end\n\n    describe \"#name\" do\n      context \"when in report-only mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts.merge(report_only: true)).name).to eq(ContentSecurityPolicyReportOnlyConfig::HEADER_NAME) }\n      end\n\n      context \"when in enforce mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts).name).to eq(ContentSecurityPolicyConfig::HEADER_NAME) }\n      end\n    end\n\n    describe \"#value\" do\n      it \"uses a safe but non-breaking default value\" do\n        expect(ContentSecurityPolicy.new.value).to eq(\"default-src https:; form-action 'self'; img-src https: data: 'self'; object-src 'none'; script-src https:; style-src 'self' 'unsafe-inline' https:\")\n      end\n\n      it \"deprecates and escapes semicolons in directive source lists\" do\n        expect(Kernel).to receive(:warn).with(%(frame_ancestors contains a ; in \"google.com;script-src *;.;\" which will raise an error in future versions. It has been replaced with a blank space.))\n        expect(ContentSecurityPolicy.new(frame_ancestors: %w(https://google.com;script-src https://*;.;)).value).to eq(\"frame-ancestors google.com script-src * .\")\n      end\n\n      it \"deprecates and escapes semicolons in directive source lists\" do\n        expect(Kernel).to receive(:warn).with(%(frame_ancestors contains a \\n in \"\\\\nfoo.com\\\\nhacked\" which will raise an error in future versions. It has been replaced with a blank space.))\n        expect(ContentSecurityPolicy.new(frame_ancestors: [\"\\nfoo.com\\nhacked\"]).value).to eq(\"frame-ancestors  foo.com hacked\")\n      end\n\n      it \"discards 'none' values if any other source expressions are present\" do\n        csp = ContentSecurityPolicy.new(default_opts.merge(child_src: %w('self' 'none')))\n        expect(csp.value).not_to include(\"'none'\")\n      end\n\n      it \"discards source expressions (besides unsafe-* and non-host source values) when * is present\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(* 'unsafe-inline' 'unsafe-eval' http: https: example.org data: blob:))\n        expect(csp.value).to eq(\"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:\")\n      end\n\n      it \"minifies source expressions based on overlapping wildcards\" do\n        config = {\n          default_src: %w(a.example.org b.example.org *.example.org https://*.example.org)\n        }\n        csp = ContentSecurityPolicy.new(config)\n        expect(csp.value).to eq(\"default-src *.example.org\")\n      end\n\n      it \"removes http/s schemes from hosts\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not build directives with a value of OPT_OUT (and bypasses directive requirements)\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), script_src: OPT_OUT)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not remove schemes from report-uri values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https:), report_uri: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src https:; report-uri https://example.org\")\n      end\n\n      it \"does not remove schemes when :preserve_schemes is true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), preserve_schemes: true)\n        expect(csp.value).to eq(\"default-src https://example.org\")\n      end\n\n      it \"removes nil from source lists\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\", nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is an empty array (or all nil)\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: [nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is nil\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: nil)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does add a boolean directive if the value is true\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: true)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content; upgrade-insecure-requests\")\n      end\n\n      it \"does not add a boolean directive if the value is false\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: false)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content\")\n      end\n\n      it \"deduplicates any source expressions\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org example.org example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed no sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: [])\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: true)\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates sandbox policy when passed valid sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: %w(allow-forms allow-scripts))\n        expect(csp.value).to eq(\"default-src example.org; sandbox allow-forms allow-scripts\")\n      end\n\n      it \"does not emit a warning when using frame-src\" do\n        expect(Kernel).to_not receive(:warn)\n        ContentSecurityPolicy.new(default_src: %w('self'), frame_src: %w('self')).value\n      end\n\n      it \"allows script as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(script))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for script\")\n      end\n\n      it \"allows style as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(style))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for style\")\n      end\n\n      it \"allows script and style as a require-sri-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), require_sri_for: %w(script style))\n        expect(csp.value).to eq(\"default-src 'self'; require-sri-for script style\")\n      end\n\n      it \"includes prefetch-src\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), prefetch_src: %w(foo.com))\n        expect(csp.value).to eq(\"default-src 'self'; prefetch-src foo.com\")\n      end\n\n      it \"includes navigate-to\" do\n        csp = ContentSecurityPolicy.new(default_src: %w('self'), navigate_to: %w(foo.com))\n        expect(csp.value).to eq(\"default-src 'self'; navigate-to foo.com\")\n      end\n\n      it \"supports strict-dynamic\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456})\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456' 'unsafe-inline'\")\n      end\n\n      it \"supports strict-dynamic and opting out of the appended 'unsafe-inline'\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456, disable_nonce_backwards_compatibility: true })\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456'\")\n      end\n    end\n  end\nend\n"], "filenames": ["lib/secure_headers/headers/content_security_policy.rb", "spec/lib/secure_headers/headers/content_security_policy_spec.rb"], "buggy_code_start_loc": [109, 32], "buggy_code_end_loc": [114, 33], "fixing_code_start_loc": [109, 32], "fixing_code_end_loc": [114, 39], "type": "CWE-74", "message": "In Secure Headers (RubyGem secure_headers), a directive injection vulnerability is present in versions before 3.9.0, 5.2.0, and 6.3.0. If user-supplied input was passed into append/override_content_security_policy_directives, a newline could be injected leading to limited header injection. Upon seeing a newline in the header, rails will silently create a new Content-Security-Policy header with the remaining value of the original string. It will continue to create new headers for each newline. This has been fixed in 6.3.0, 5.2.0, and 3.9.0.", "other": {"cve": {"id": "CVE-2020-5216", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-23T03:15:10.683", "lastModified": "2020-02-18T14:58:04.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Secure Headers (RubyGem secure_headers), a directive injection vulnerability is present in versions before 3.9.0, 5.2.0, and 6.3.0. If user-supplied input was passed into append/override_content_security_policy_directives, a newline could be injected leading to limited header injection. Upon seeing a newline in the header, rails will silently create a new Content-Security-Policy header with the remaining value of the original string. It will continue to create new headers for each newline. This has been fixed in 6.3.0, 5.2.0, and 3.9.0."}, {"lang": "es", "value": "En Secure Headers (secure_headers de RubyGem), una vulnerabilidad de inyecci\u00f3n de directiva est\u00e1 presente en las versiones anteriores a 3.9.0, 5.2.0 y 6.3.0. Si la entrada suministrada por el usuario fue pasada a append/override_content_security_policy_directives, una l\u00ednea nueva podr\u00eda ser inyectada conllevando a una inyecci\u00f3n de encabezado limitada. Al visualizar una nueva l\u00ednea en el encabezado, rails crear\u00e1 silenciosamente un nuevo encabezado Content-Security-Policy con el valor restante de la cadena original. Continuar\u00e1 creando nuevos encabezados para cada nueva l\u00ednea. Esto ha sido corregido en las versiones 6.3.0, 5.2.0 y 3.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-113"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.9.0", "matchCriteriaId": "A7C8E5CD-3CF2-439D-991F-EC4F561AF149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.0", "matchCriteriaId": "8EE2D852-886F-4500-8B6A-6CD4313BE0A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.3.0", "matchCriteriaId": "4C13DFD4-1B3B-4373-9048-82BBB0C594C9"}]}]}], "references": [{"url": "https://github.com/twitter/secure_headers/commit/301695706f6a70517c2a90c6ef9b32178440a2d0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/twitter/secure_headers/security/advisories/GHSA-w978-rmpf-qmwg", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/twitter/secure_headers/commit/301695706f6a70517c2a90c6ef9b32178440a2d0"}}