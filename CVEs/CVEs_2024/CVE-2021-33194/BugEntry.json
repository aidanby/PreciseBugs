{"buggy_code": ["// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage html\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\ta \"golang.org/x/net/html/atom\"\n)\n\n// A parser implements the HTML5 parsing algorithm:\n// https://html.spec.whatwg.org/multipage/syntax.html#tree-construction\ntype parser struct {\n\t// tokenizer provides the tokens for the parser.\n\ttokenizer *Tokenizer\n\t// tok is the most recently read token.\n\ttok Token\n\t// Self-closing tags like <hr/> are treated as start tags, except that\n\t// hasSelfClosingToken is set while they are being processed.\n\thasSelfClosingToken bool\n\t// doc is the document root element.\n\tdoc *Node\n\t// The stack of open elements (section 12.2.4.2) and active formatting\n\t// elements (section 12.2.4.3).\n\toe, afe nodeStack\n\t// Element pointers (section 12.2.4.4).\n\thead, form *Node\n\t// Other parsing state flags (section 12.2.4.5).\n\tscripting, framesetOK bool\n\t// The stack of template insertion modes\n\ttemplateStack insertionModeStack\n\t// im is the current insertion mode.\n\tim insertionMode\n\t// originalIM is the insertion mode to go back to after completing a text\n\t// or inTableText insertion mode.\n\toriginalIM insertionMode\n\t// fosterParenting is whether new elements should be inserted according to\n\t// the foster parenting rules (section 12.2.6.1).\n\tfosterParenting bool\n\t// quirks is whether the parser is operating in \"quirks mode.\"\n\tquirks bool\n\t// fragment is whether the parser is parsing an HTML fragment.\n\tfragment bool\n\t// context is the context element when parsing an HTML fragment\n\t// (section 12.4).\n\tcontext *Node\n}\n\nfunc (p *parser) top() *Node {\n\tif n := p.oe.top(); n != nil {\n\t\treturn n\n\t}\n\treturn p.doc\n}\n\n// Stop tags for use in popUntil. These come from section 12.2.4.2.\nvar (\n\tdefaultScopeStopTags = map[string][]a.Atom{\n\t\t\"\":     {a.Applet, a.Caption, a.Html, a.Table, a.Td, a.Th, a.Marquee, a.Object, a.Template},\n\t\t\"math\": {a.AnnotationXml, a.Mi, a.Mn, a.Mo, a.Ms, a.Mtext},\n\t\t\"svg\":  {a.Desc, a.ForeignObject, a.Title},\n\t}\n)\n\ntype scope int\n\nconst (\n\tdefaultScope scope = iota\n\tlistItemScope\n\tbuttonScope\n\ttableScope\n\ttableRowScope\n\ttableBodyScope\n\tselectScope\n)\n\n// popUntil pops the stack of open elements at the highest element whose tag\n// is in matchTags, provided there is no higher element in the scope's stop\n// tags (as defined in section 12.2.4.2). It returns whether or not there was\n// such an element. If there was not, popUntil leaves the stack unchanged.\n//\n// For example, the set of stop tags for table scope is: \"html\", \"table\". If\n// the stack was:\n// [\"html\", \"body\", \"font\", \"table\", \"b\", \"i\", \"u\"]\n// then popUntil(tableScope, \"font\") would return false, but\n// popUntil(tableScope, \"i\") would return true and the stack would become:\n// [\"html\", \"body\", \"font\", \"table\", \"b\"]\n//\n// If an element's tag is in both the stop tags and matchTags, then the stack\n// will be popped and the function returns true (provided, of course, there was\n// no higher element in the stack that was also in the stop tags). For example,\n// popUntil(tableScope, \"table\") returns true and leaves:\n// [\"html\", \"body\", \"font\"]\nfunc (p *parser) popUntil(s scope, matchTags ...a.Atom) bool {\n\tif i := p.indexOfElementInScope(s, matchTags...); i != -1 {\n\t\tp.oe = p.oe[:i]\n\t\treturn true\n\t}\n\treturn false\n}\n\n// indexOfElementInScope returns the index in p.oe of the highest element whose\n// tag is in matchTags that is in scope. If no matching element is in scope, it\n// returns -1.\nfunc (p *parser) indexOfElementInScope(s scope, matchTags ...a.Atom) int {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\ttagAtom := p.oe[i].DataAtom\n\t\tif p.oe[i].Namespace == \"\" {\n\t\t\tfor _, t := range matchTags {\n\t\t\t\tif t == tagAtom {\n\t\t\t\t\treturn i\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch s {\n\t\t\tcase defaultScope:\n\t\t\t\t// No-op.\n\t\t\tcase listItemScope:\n\t\t\t\tif tagAtom == a.Ol || tagAtom == a.Ul {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase buttonScope:\n\t\t\t\tif tagAtom == a.Button {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase tableScope:\n\t\t\t\tif tagAtom == a.Html || tagAtom == a.Table || tagAtom == a.Template {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase selectScope:\n\t\t\t\tif tagAtom != a.Optgroup && tagAtom != a.Option {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t}\n\t\tswitch s {\n\t\tcase defaultScope, listItemScope, buttonScope:\n\t\t\tfor _, t := range defaultScopeStopTags[p.oe[i].Namespace] {\n\t\t\t\tif t == tagAtom {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// elementInScope is like popUntil, except that it doesn't modify the stack of\n// open elements.\nfunc (p *parser) elementInScope(s scope, matchTags ...a.Atom) bool {\n\treturn p.indexOfElementInScope(s, matchTags...) != -1\n}\n\n// clearStackToContext pops elements off the stack of open elements until a\n// scope-defined element is found.\nfunc (p *parser) clearStackToContext(s scope) {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\ttagAtom := p.oe[i].DataAtom\n\t\tswitch s {\n\t\tcase tableScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Table || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tableRowScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Tr || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tableBodyScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Tbody || tagAtom == a.Tfoot || tagAtom == a.Thead || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\n// parseGenericRawTextElements implements the generic raw text element parsing\n// algorithm defined in 12.2.6.2.\n// https://html.spec.whatwg.org/multipage/parsing.html#parsing-elements-that-contain-only-text\n// TODO: Since both RAWTEXT and RCDATA states are treated as tokenizer's part\n// officially, need to make tokenizer consider both states.\nfunc (p *parser) parseGenericRawTextElement() {\n\tp.addElement()\n\tp.originalIM = p.im\n\tp.im = textIM\n}\n\n// generateImpliedEndTags pops nodes off the stack of open elements as long as\n// the top node has a tag name of dd, dt, li, optgroup, option, p, rb, rp, rt or rtc.\n// If exceptions are specified, nodes with that name will not be popped off.\nfunc (p *parser) generateImpliedEndTags(exceptions ...string) {\n\tvar i int\nloop:\n\tfor i = len(p.oe) - 1; i >= 0; i-- {\n\t\tn := p.oe[i]\n\t\tif n.Type != ElementNode {\n\t\t\tbreak\n\t\t}\n\t\tswitch n.DataAtom {\n\t\tcase a.Dd, a.Dt, a.Li, a.Optgroup, a.Option, a.P, a.Rb, a.Rp, a.Rt, a.Rtc:\n\t\t\tfor _, except := range exceptions {\n\t\t\t\tif n.Data == except {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tp.oe = p.oe[:i+1]\n}\n\n// addChild adds a child node n to the top element, and pushes n onto the stack\n// of open elements if it is an element node.\nfunc (p *parser) addChild(n *Node) {\n\tif p.shouldFosterParent() {\n\t\tp.fosterParent(n)\n\t} else {\n\t\tp.top().AppendChild(n)\n\t}\n\n\tif n.Type == ElementNode {\n\t\tp.oe = append(p.oe, n)\n\t}\n}\n\n// shouldFosterParent returns whether the next node to be added should be\n// foster parented.\nfunc (p *parser) shouldFosterParent() bool {\n\tif p.fosterParenting {\n\t\tswitch p.top().DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// fosterParent adds a child node according to the foster parenting rules.\n// Section 12.2.6.1, \"foster parenting\".\nfunc (p *parser) fosterParent(n *Node) {\n\tvar table, parent, prev, template *Node\n\tvar i int\n\tfor i = len(p.oe) - 1; i >= 0; i-- {\n\t\tif p.oe[i].DataAtom == a.Table {\n\t\t\ttable = p.oe[i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar j int\n\tfor j = len(p.oe) - 1; j >= 0; j-- {\n\t\tif p.oe[j].DataAtom == a.Template {\n\t\t\ttemplate = p.oe[j]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif template != nil && (table == nil || j > i) {\n\t\ttemplate.AppendChild(n)\n\t\treturn\n\t}\n\n\tif table == nil {\n\t\t// The foster parent is the html element.\n\t\tparent = p.oe[0]\n\t} else {\n\t\tparent = table.Parent\n\t}\n\tif parent == nil {\n\t\tparent = p.oe[i-1]\n\t}\n\n\tif table != nil {\n\t\tprev = table.PrevSibling\n\t} else {\n\t\tprev = parent.LastChild\n\t}\n\tif prev != nil && prev.Type == TextNode && n.Type == TextNode {\n\t\tprev.Data += n.Data\n\t\treturn\n\t}\n\n\tparent.InsertBefore(n, table)\n}\n\n// addText adds text to the preceding node if it is a text node, or else it\n// calls addChild with a new text node.\nfunc (p *parser) addText(text string) {\n\tif text == \"\" {\n\t\treturn\n\t}\n\n\tif p.shouldFosterParent() {\n\t\tp.fosterParent(&Node{\n\t\t\tType: TextNode,\n\t\t\tData: text,\n\t\t})\n\t\treturn\n\t}\n\n\tt := p.top()\n\tif n := t.LastChild; n != nil && n.Type == TextNode {\n\t\tn.Data += text\n\t\treturn\n\t}\n\tp.addChild(&Node{\n\t\tType: TextNode,\n\t\tData: text,\n\t})\n}\n\n// addElement adds a child element based on the current token.\nfunc (p *parser) addElement() {\n\tp.addChild(&Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: p.tok.DataAtom,\n\t\tData:     p.tok.Data,\n\t\tAttr:     p.tok.Attr,\n\t})\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) addFormattingElement() {\n\ttagAtom, attr := p.tok.DataAtom, p.tok.Attr\n\tp.addElement()\n\n\t// Implement the Noah's Ark clause, but with three per family instead of two.\n\tidenticalElements := 0\nfindIdenticalElements:\n\tfor i := len(p.afe) - 1; i >= 0; i-- {\n\t\tn := p.afe[i]\n\t\tif n.Type == scopeMarkerNode {\n\t\t\tbreak\n\t\t}\n\t\tif n.Type != ElementNode {\n\t\t\tcontinue\n\t\t}\n\t\tif n.Namespace != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif n.DataAtom != tagAtom {\n\t\t\tcontinue\n\t\t}\n\t\tif len(n.Attr) != len(attr) {\n\t\t\tcontinue\n\t\t}\n\tcompareAttributes:\n\t\tfor _, t0 := range n.Attr {\n\t\t\tfor _, t1 := range attr {\n\t\t\t\tif t0.Key == t1.Key && t0.Namespace == t1.Namespace && t0.Val == t1.Val {\n\t\t\t\t\t// Found a match for this attribute, continue with the next attribute.\n\t\t\t\t\tcontinue compareAttributes\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we get here, there is no attribute that matches a.\n\t\t\t// Therefore the element is not identical to the new one.\n\t\t\tcontinue findIdenticalElements\n\t\t}\n\n\t\tidenticalElements++\n\t\tif identicalElements >= 3 {\n\t\t\tp.afe.remove(n)\n\t\t}\n\t}\n\n\tp.afe = append(p.afe, p.top())\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) clearActiveFormattingElements() {\n\tfor {\n\t\tif n := p.afe.pop(); len(p.afe) == 0 || n.Type == scopeMarkerNode {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) reconstructActiveFormattingElements() {\n\tn := p.afe.top()\n\tif n == nil {\n\t\treturn\n\t}\n\tif n.Type == scopeMarkerNode || p.oe.index(n) != -1 {\n\t\treturn\n\t}\n\ti := len(p.afe) - 1\n\tfor n.Type != scopeMarkerNode && p.oe.index(n) == -1 {\n\t\tif i == 0 {\n\t\t\ti = -1\n\t\t\tbreak\n\t\t}\n\t\ti--\n\t\tn = p.afe[i]\n\t}\n\tfor {\n\t\ti++\n\t\tclone := p.afe[i].clone()\n\t\tp.addChild(clone)\n\t\tp.afe[i] = clone\n\t\tif i == len(p.afe)-1 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Section 12.2.5.\nfunc (p *parser) acknowledgeSelfClosingTag() {\n\tp.hasSelfClosingToken = false\n}\n\n// An insertion mode (section 12.2.4.1) is the state transition function from\n// a particular state in the HTML5 parser's state machine. It updates the\n// parser's fields depending on parser.tok (where ErrorToken means EOF).\n// It returns whether the token was consumed.\ntype insertionMode func(*parser) bool\n\n// setOriginalIM sets the insertion mode to return to after completing a text or\n// inTableText insertion mode.\n// Section 12.2.4.1, \"using the rules for\".\nfunc (p *parser) setOriginalIM() {\n\tif p.originalIM != nil {\n\t\tpanic(\"html: bad parser state: originalIM was set twice\")\n\t}\n\tp.originalIM = p.im\n}\n\n// Section 12.2.4.1, \"reset the insertion mode\".\nfunc (p *parser) resetInsertionMode() {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\tn := p.oe[i]\n\t\tlast := i == 0\n\t\tif last && p.context != nil {\n\t\t\tn = p.context\n\t\t}\n\n\t\tswitch n.DataAtom {\n\t\tcase a.Select:\n\t\t\tif !last {\n\t\t\t\tfor ancestor, first := n, p.oe[0]; ancestor != first; {\n\t\t\t\t\tancestor = p.oe[p.oe.index(ancestor)-1]\n\t\t\t\t\tswitch ancestor.DataAtom {\n\t\t\t\t\tcase a.Template:\n\t\t\t\t\t\tp.im = inSelectIM\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase a.Table:\n\t\t\t\t\t\tp.im = inSelectInTableIM\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.im = inSelectIM\n\t\tcase a.Td, a.Th:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.im = inCellIM\n\t\tcase a.Tr:\n\t\t\tp.im = inRowIM\n\t\tcase a.Tbody, a.Thead, a.Tfoot:\n\t\t\tp.im = inTableBodyIM\n\t\tcase a.Caption:\n\t\t\tp.im = inCaptionIM\n\t\tcase a.Colgroup:\n\t\t\tp.im = inColumnGroupIM\n\t\tcase a.Table:\n\t\t\tp.im = inTableIM\n\t\tcase a.Template:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\tif n.Namespace != \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.im = p.templateStack.top()\n\t\tcase a.Head:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.im = inHeadIM\n\t\tcase a.Body:\n\t\t\tp.im = inBodyIM\n\t\tcase a.Frameset:\n\t\t\tp.im = inFramesetIM\n\t\tcase a.Html:\n\t\t\tif p.head == nil {\n\t\t\t\tp.im = beforeHeadIM\n\t\t\t} else {\n\t\t\t\tp.im = afterHeadIM\n\t\t\t}\n\t\tdefault:\n\t\t\tif last {\n\t\t\t\tp.im = inBodyIM\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\treturn\n\t}\n}\n\nconst whitespace = \" \\t\\r\\n\\f\"\n\n// Section 12.2.6.4.1.\nfunc initialIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\tn, quirks := parseDoctype(p.tok.Data)\n\t\tp.doc.AppendChild(n)\n\t\tp.quirks = quirks\n\t\tp.im = beforeHTMLIM\n\t\treturn true\n\t}\n\tp.quirks = true\n\tp.im = beforeHTMLIM\n\treturn false\n}\n\n// Section 12.2.6.4.2.\nfunc beforeHTMLIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\tp.addElement()\n\t\t\tp.im = beforeHeadIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head, a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n\t\t\treturn false\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n\treturn false\n}\n\n// Section 12.2.6.4.3.\nfunc beforeHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head:\n\t\t\tp.addElement()\n\t\t\tp.head = p.top()\n\t\t\tp.im = inHeadIM\n\t\t\treturn true\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head, a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n\t\t\treturn false\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n\treturn false\n}\n\n// Section 12.2.6.4.4.\nfunc inHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\treturn true\n\t\tcase a.Noscript:\n\t\t\tif p.scripting {\n\t\t\t\tp.parseGenericRawTextElement()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.im = inHeadNoscriptIM\n\t\t\t// Don't let the tokenizer go into raw text mode when scripting is disabled.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\treturn true\n\t\tcase a.Script, a.Title:\n\t\t\tp.addElement()\n\t\t\tp.setOriginalIM()\n\t\t\tp.im = textIM\n\t\t\treturn true\n\t\tcase a.Noframes, a.Style:\n\t\t\tp.parseGenericRawTextElement()\n\t\t\treturn true\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inTemplateIM\n\t\t\tp.templateStack = append(p.templateStack, inTemplateIM)\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head:\n\t\t\tp.oe.pop()\n\t\t\tp.im = afterHeadIM\n\t\t\treturn true\n\t\tcase a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n\t\t\treturn false\n\t\tcase a.Template:\n\t\t\tif !p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.generateImpliedEndTags()\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tif n := p.oe[i]; n.Namespace == \"\" && n.DataAtom == a.Template {\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.templateStack.pop()\n\t\t\tp.resetInsertionMode()\n\t\t\treturn true\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n\treturn false\n}\n\n// 12.2.6.4.5.\nfunc inHeadNoscriptIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Style:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Noscript:\n\t\t\t// Don't let the tokenizer go into raw text mode even when a <noscript>\n\t\t\t// tag is in \"in head noscript\" insertion mode.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Noscript, a.Br:\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\treturn inHeadIM(p)\n\t}\n\tp.oe.pop()\n\tif p.top().DataAtom != a.Head {\n\t\tpanic(\"html: the new current node will be a head element.\")\n\t}\n\tp.im = inHeadIM\n\tif p.tok.DataAtom == a.Noscript {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Section 12.2.6.4.6.\nfunc afterHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Body:\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inBodyIM\n\t\t\treturn true\n\t\tcase a.Frameset:\n\t\t\tp.addElement()\n\t\t\tp.im = inFramesetIM\n\t\t\treturn true\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\tp.oe = append(p.oe, p.head)\n\t\t\tdefer p.oe.remove(p.head)\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Body, a.Html, a.Br:\n\t\t\t// Drop down to creating an implied <body> tag.\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(StartTagToken, a.Body, a.Body.String())\n\tp.framesetOK = true\n\treturn false\n}\n\n// copyAttributes copies attributes of src not found on dst to dst.\nfunc copyAttributes(dst *Node, src Token) {\n\tif len(src.Attr) == 0 {\n\t\treturn\n\t}\n\tattr := map[string]string{}\n\tfor _, t := range dst.Attr {\n\t\tattr[t.Key] = t.Val\n\t}\n\tfor _, t := range src.Attr {\n\t\tif _, ok := attr[t.Key]; !ok {\n\t\t\tdst.Attr = append(dst.Attr, t)\n\t\t\tattr[t.Key] = t.Val\n\t\t}\n\t}\n}\n\n// Section 12.2.6.4.7.\nfunc inBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\td := p.tok.Data\n\t\tswitch n := p.oe.top(); n.DataAtom {\n\t\tcase a.Pre, a.Listing:\n\t\t\tif n.FirstChild == nil {\n\t\t\t\t// Ignore a newline at the start of a <pre> block.\n\t\t\t\tif d != \"\" && d[0] == '\\r' {\n\t\t\t\t\td = d[1:]\n\t\t\t\t}\n\t\t\t\tif d != \"\" && d[0] == '\\n' {\n\t\t\t\t\td = d[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td = strings.Replace(d, \"\\x00\", \"\", -1)\n\t\tif d == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tp.reconstructActiveFormattingElements()\n\t\tp.addText(d)\n\t\tif p.framesetOK && strings.TrimLeft(d, whitespace) != \"\" {\n\t\t\t// There were non-whitespace characters inserted.\n\t\t\tp.framesetOK = false\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tcopyAttributes(p.oe[0], p.tok)\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Body:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif len(p.oe) >= 2 {\n\t\t\t\tbody := p.oe[1]\n\t\t\t\tif body.Type == ElementNode && body.DataAtom == a.Body {\n\t\t\t\t\tp.framesetOK = false\n\t\t\t\t\tcopyAttributes(body, p.tok)\n\t\t\t\t}\n\t\t\t}\n\t\tcase a.Frameset:\n\t\t\tif !p.framesetOK || len(p.oe) < 2 || p.oe[1].DataAtom != a.Body {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tbody := p.oe[1]\n\t\t\tif body.Parent != nil {\n\t\t\t\tbody.Parent.RemoveChild(body)\n\t\t\t}\n\t\t\tp.oe = p.oe[:1]\n\t\t\tp.addElement()\n\t\t\tp.im = inFramesetIM\n\t\t\treturn true\n\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Center, a.Details, a.Dialog, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Main, a.Menu, a.Nav, a.Ol, a.P, a.Section, a.Summary, a.Ul:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tswitch n := p.top(); n.DataAtom {\n\t\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Pre, a.Listing:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\t// The newline, if any, will be dealt with by the TextToken case.\n\t\t\tp.framesetOK = false\n\t\tcase a.Form:\n\t\t\tif p.form != nil && !p.oe.contains(a.Template) {\n\t\t\t\t// Ignore the token\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\tif !p.oe.contains(a.Template) {\n\t\t\t\tp.form = p.top()\n\t\t\t}\n\t\tcase a.Li:\n\t\t\tp.framesetOK = false\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tnode := p.oe[i]\n\t\t\t\tswitch node.DataAtom {\n\t\t\t\tcase a.Li:\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tcase a.Address, a.Div, a.P:\n\t\t\t\t\tcontinue\n\t\t\t\tdefault:\n\t\t\t\t\tif !isSpecialElement(node) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Dd, a.Dt:\n\t\t\tp.framesetOK = false\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tnode := p.oe[i]\n\t\t\t\tswitch node.DataAtom {\n\t\t\t\tcase a.Dd, a.Dt:\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tcase a.Address, a.Div, a.P:\n\t\t\t\t\tcontinue\n\t\t\t\tdefault:\n\t\t\t\t\tif !isSpecialElement(node) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Plaintext:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Button:\n\t\t\tp.popUntil(defaultScope, a.Button)\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\tcase a.A:\n\t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n\t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {\n\t\t\t\t\tp.inBodyEndTagFormatting(a.A, \"a\")\n\t\t\t\t\tp.oe.remove(n)\n\t\t\t\t\tp.afe.remove(n)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addFormattingElement()\n\t\tcase a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addFormattingElement()\n\t\tcase a.Nobr:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tif p.elementInScope(defaultScope, a.Nobr) {\n\t\t\t\tp.inBodyEndTagFormatting(a.Nobr, \"nobr\")\n\t\t\t\tp.reconstructActiveFormattingElements()\n\t\t\t}\n\t\t\tp.addFormattingElement()\n\t\tcase a.Applet, a.Marquee, a.Object:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.framesetOK = false\n\t\tcase a.Table:\n\t\t\tif !p.quirks {\n\t\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inTableIM\n\t\t\treturn true\n\t\tcase a.Area, a.Br, a.Embed, a.Img, a.Input, a.Keygen, a.Wbr:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\tif p.tok.DataAtom == a.Input {\n\t\t\t\tfor _, t := range p.tok.Attr {\n\t\t\t\t\tif t.Key == \"type\" {\n\t\t\t\t\t\tif strings.ToLower(t.Val) == \"hidden\" {\n\t\t\t\t\t\t\t// Skip setting framesetOK = false\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.framesetOK = false\n\t\tcase a.Param, a.Source, a.Track:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\tcase a.Hr:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\tp.framesetOK = false\n\t\tcase a.Image:\n\t\t\tp.tok.DataAtom = a.Img\n\t\t\tp.tok.Data = a.Img.String()\n\t\t\treturn false\n\t\tcase a.Textarea:\n\t\t\tp.addElement()\n\t\t\tp.setOriginalIM()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = textIM\n\t\tcase a.Xmp:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.framesetOK = false\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Iframe:\n\t\t\tp.framesetOK = false\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Noembed:\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Noscript:\n\t\t\tif p.scripting {\n\t\t\t\tp.parseGenericRawTextElement()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\t// Don't let the tokenizer go into raw text mode when scripting is disabled.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectIM\n\t\t\treturn true\n\t\tcase a.Optgroup, a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\tcase a.Rb, a.Rtc:\n\t\t\tif p.elementInScope(defaultScope, a.Ruby) {\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Rp, a.Rt:\n\t\t\tif p.elementInScope(defaultScope, a.Ruby) {\n\t\t\t\tp.generateImpliedEndTags(\"rtc\")\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Math, a.Svg:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tif p.tok.DataAtom == a.Math {\n\t\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n\t\t\t} else {\n\t\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n\t\t\t}\n\t\t\tadjustForeignAttributes(p.tok.Attr)\n\t\t\tp.addElement()\n\t\t\tp.top().Namespace = p.tok.Data\n\t\t\tif p.hasSelfClosingToken {\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\tdefault:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Body:\n\t\t\tif p.elementInScope(defaultScope, a.Body) {\n\t\t\t\tp.im = afterBodyIM\n\t\t\t}\n\t\tcase a.Html:\n\t\t\tif p.elementInScope(defaultScope, a.Body) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Body, a.Body.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Button, a.Center, a.Details, a.Dialog, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Listing, a.Main, a.Menu, a.Nav, a.Ol, a.Pre, a.Section, a.Summary, a.Ul:\n\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n\t\tcase a.Form:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\ti := p.indexOfElementInScope(defaultScope, a.Form)\n\t\t\t\tif i == -1 {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t\tif p.oe[i].DataAtom != a.Form {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.popUntil(defaultScope, a.Form)\n\t\t\t} else {\n\t\t\t\tnode := p.form\n\t\t\t\tp.form = nil\n\t\t\t\ti := p.indexOfElementInScope(defaultScope, a.Form)\n\t\t\t\tif node == nil || i == -1 || p.oe[i] != node {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t\tp.oe.remove(node)\n\t\t\t}\n\t\tcase a.P:\n\t\t\tif !p.elementInScope(buttonScope, a.P) {\n\t\t\t\tp.parseImpliedToken(StartTagToken, a.P, a.P.String())\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\tcase a.Li:\n\t\t\tp.popUntil(listItemScope, a.Li)\n\t\tcase a.Dd, a.Dt:\n\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\tp.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)\n\t\tcase a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n\t\t\tp.inBodyEndTagFormatting(p.tok.DataAtom, p.tok.Data)\n\t\tcase a.Applet, a.Marquee, a.Object:\n\t\t\tif p.popUntil(defaultScope, p.tok.DataAtom) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t}\n\t\tcase a.Br:\n\t\t\tp.tok.Type = StartTagToken\n\t\t\treturn false\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\tp.inBodyEndTagOther(p.tok.DataAtom, p.tok.Data)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase ErrorToken:\n\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\tif len(p.templateStack) > 0 {\n\t\t\tp.im = inTemplateIM\n\t\t\treturn false\n\t\t}\n\t\tfor _, e := range p.oe {\n\t\t\tswitch e.DataAtom {\n\t\t\tcase a.Dd, a.Dt, a.Li, a.Optgroup, a.Option, a.P, a.Rb, a.Rp, a.Rt, a.Rtc, a.Tbody, a.Td, a.Tfoot, a.Th,\n\t\t\t\ta.Thead, a.Tr, a.Body, a.Html:\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (p *parser) inBodyEndTagFormatting(tagAtom a.Atom, tagName string) {\n\t// This is the \"adoption agency\" algorithm, described at\n\t// https://html.spec.whatwg.org/multipage/syntax.html#adoptionAgency\n\n\t// TODO: this is a fairly literal line-by-line translation of that algorithm.\n\t// Once the code successfully parses the comprehensive test suite, we should\n\t// refactor this code to be more idiomatic.\n\n\t// Steps 1-2\n\tif current := p.oe.top(); current.Data == tagName && p.afe.index(current) == -1 {\n\t\tp.oe.pop()\n\t\treturn\n\t}\n\n\t// Steps 3-5. The outer loop.\n\tfor i := 0; i < 8; i++ {\n\t\t// Step 6. Find the formatting element.\n\t\tvar formattingElement *Node\n\t\tfor j := len(p.afe) - 1; j >= 0; j-- {\n\t\t\tif p.afe[j].Type == scopeMarkerNode {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif p.afe[j].DataAtom == tagAtom {\n\t\t\t\tformattingElement = p.afe[j]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif formattingElement == nil {\n\t\t\tp.inBodyEndTagOther(tagAtom, tagName)\n\t\t\treturn\n\t\t}\n\n\t\t// Step 7. Ignore the tag if formatting element is not in the stack of open elements.\n\t\tfeIndex := p.oe.index(formattingElement)\n\t\tif feIndex == -1 {\n\t\t\tp.afe.remove(formattingElement)\n\t\t\treturn\n\t\t}\n\t\t// Step 8. Ignore the tag if formatting element is not in the scope.\n\t\tif !p.elementInScope(defaultScope, tagAtom) {\n\t\t\t// Ignore the tag.\n\t\t\treturn\n\t\t}\n\n\t\t// Step 9. This step is omitted because it's just a parse error but no need to return.\n\n\t\t// Steps 10-11. Find the furthest block.\n\t\tvar furthestBlock *Node\n\t\tfor _, e := range p.oe[feIndex:] {\n\t\t\tif isSpecialElement(e) {\n\t\t\t\tfurthestBlock = e\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif furthestBlock == nil {\n\t\t\te := p.oe.pop()\n\t\t\tfor e != formattingElement {\n\t\t\t\te = p.oe.pop()\n\t\t\t}\n\t\t\tp.afe.remove(e)\n\t\t\treturn\n\t\t}\n\n\t\t// Steps 12-13. Find the common ancestor and bookmark node.\n\t\tcommonAncestor := p.oe[feIndex-1]\n\t\tbookmark := p.afe.index(formattingElement)\n\n\t\t// Step 14. The inner loop. Find the lastNode to reparent.\n\t\tlastNode := furthestBlock\n\t\tnode := furthestBlock\n\t\tx := p.oe.index(node)\n\t\t// Step 14.1.\n\t\tj := 0\n\t\tfor {\n\t\t\t// Step 14.2.\n\t\t\tj++\n\t\t\t// Step. 14.3.\n\t\t\tx--\n\t\t\tnode = p.oe[x]\n\t\t\t// Step 14.4. Go to the next step if node is formatting element.\n\t\t\tif node == formattingElement {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Step 14.5. Remove node from the list of active formatting elements if\n\t\t\t// inner loop counter is greater than three and node is in the list of\n\t\t\t// active formatting elements.\n\t\t\tif ni := p.afe.index(node); j > 3 && ni > -1 {\n\t\t\t\tp.afe.remove(node)\n\t\t\t\t// If any element of the list of active formatting elements is removed,\n\t\t\t\t// we need to take care whether bookmark should be decremented or not.\n\t\t\t\t// This is because the value of bookmark may exceed the size of the\n\t\t\t\t// list by removing elements from the list.\n\t\t\t\tif ni <= bookmark {\n\t\t\t\t\tbookmark--\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Step 14.6. Continue the next inner loop if node is not in the list of\n\t\t\t// active formatting elements.\n\t\t\tif p.afe.index(node) == -1 {\n\t\t\t\tp.oe.remove(node)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Step 14.7.\n\t\t\tclone := node.clone()\n\t\t\tp.afe[p.afe.index(node)] = clone\n\t\t\tp.oe[p.oe.index(node)] = clone\n\t\t\tnode = clone\n\t\t\t// Step 14.8.\n\t\t\tif lastNode == furthestBlock {\n\t\t\t\tbookmark = p.afe.index(node) + 1\n\t\t\t}\n\t\t\t// Step 14.9.\n\t\t\tif lastNode.Parent != nil {\n\t\t\t\tlastNode.Parent.RemoveChild(lastNode)\n\t\t\t}\n\t\t\tnode.AppendChild(lastNode)\n\t\t\t// Step 14.10.\n\t\t\tlastNode = node\n\t\t}\n\n\t\t// Step 15. Reparent lastNode to the common ancestor,\n\t\t// or for misnested table nodes, to the foster parent.\n\t\tif lastNode.Parent != nil {\n\t\t\tlastNode.Parent.RemoveChild(lastNode)\n\t\t}\n\t\tswitch commonAncestor.DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tp.fosterParent(lastNode)\n\t\tdefault:\n\t\t\tcommonAncestor.AppendChild(lastNode)\n\t\t}\n\n\t\t// Steps 16-18. Reparent nodes from the furthest block's children\n\t\t// to a clone of the formatting element.\n\t\tclone := formattingElement.clone()\n\t\treparentChildren(clone, furthestBlock)\n\t\tfurthestBlock.AppendChild(clone)\n\n\t\t// Step 19. Fix up the list of active formatting elements.\n\t\tif oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {\n\t\t\t// Move the bookmark with the rest of the list.\n\t\t\tbookmark--\n\t\t}\n\t\tp.afe.remove(formattingElement)\n\t\tp.afe.insert(bookmark, clone)\n\n\t\t// Step 20. Fix up the stack of open elements.\n\t\tp.oe.remove(formattingElement)\n\t\tp.oe.insert(p.oe.index(furthestBlock)+1, clone)\n\t}\n}\n\n// inBodyEndTagOther performs the \"any other end tag\" algorithm for inBodyIM.\n// \"Any other end tag\" handling from 12.2.6.5 The rules for parsing tokens in foreign content\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inforeign\nfunc (p *parser) inBodyEndTagOther(tagAtom a.Atom, tagName string) {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t// Two element nodes have the same tag if they have the same Data (a\n\t\t// string-typed field). As an optimization, for common HTML tags, each\n\t\t// Data string is assigned a unique, non-zero DataAtom (a uint32-typed\n\t\t// field), since integer comparison is faster than string comparison.\n\t\t// Uncommon (custom) tags get a zero DataAtom.\n\t\t//\n\t\t// The if condition here is equivalent to (p.oe[i].Data == tagName).\n\t\tif (p.oe[i].DataAtom == tagAtom) &&\n\t\t\t((tagAtom != 0) || (p.oe[i].Data == tagName)) {\n\t\t\tp.oe = p.oe[:i]\n\t\t\tbreak\n\t\t}\n\t\tif isSpecialElement(p.oe[i]) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Section 12.2.6.4.8.\nfunc textIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\tp.oe.pop()\n\tcase TextToken:\n\t\td := p.tok.Data\n\t\tif n := p.oe.top(); n.DataAtom == a.Textarea && n.FirstChild == nil {\n\t\t\t// Ignore a newline at the start of a <textarea> block.\n\t\t\tif d != \"\" && d[0] == '\\r' {\n\t\t\t\td = d[1:]\n\t\t\t}\n\t\t\tif d != \"\" && d[0] == '\\n' {\n\t\t\t\td = d[1:]\n\t\t\t}\n\t\t}\n\t\tif d == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tp.addText(d)\n\t\treturn true\n\tcase EndTagToken:\n\t\tp.oe.pop()\n\t}\n\tp.im = p.originalIM\n\tp.originalIM = nil\n\treturn p.tok.Type == EndTagToken\n}\n\n// Section 12.2.6.4.9.\nfunc inTableIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\", -1)\n\t\tswitch p.oe.top().DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif strings.Trim(p.tok.Data, whitespace) == \"\" {\n\t\t\t\tp.addText(p.tok.Data)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.addElement()\n\t\t\tp.im = inCaptionIM\n\t\t\treturn true\n\t\tcase a.Colgroup:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inColumnGroupIM\n\t\t\treturn true\n\t\tcase a.Col:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Colgroup, a.Colgroup.String())\n\t\t\treturn false\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inTableBodyIM\n\t\t\treturn true\n\t\tcase a.Td, a.Th, a.Tr:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Tbody, a.Tbody.String())\n\t\t\treturn false\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Table) {\n\t\t\t\tp.resetInsertionMode()\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Style, a.Script, a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Input:\n\t\t\tfor _, t := range p.tok.Attr {\n\t\t\t\tif t.Key == \"type\" && strings.ToLower(t.Val) == \"hidden\" {\n\t\t\t\t\tp.addElement()\n\t\t\t\t\tp.oe.pop()\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise drop down to the default action.\n\t\tcase a.Form:\n\t\t\tif p.oe.contains(a.Template) || p.form != nil {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.form = p.oe.pop()\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tswitch p.top().DataAtom {\n\t\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\t\tp.fosterParenting = true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.fosterParenting = false\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Table) {\n\t\t\t\tp.resetInsertionMode()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\n\tp.fosterParenting = true\n\tdefer func() { p.fosterParenting = false }()\n\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.11.\nfunc inCaptionIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif !p.popUntil(tableScope, a.Caption) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption:\n\t\t\tif p.popUntil(tableScope, a.Caption) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif !p.popUntil(tableScope, a.Caption) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Body, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t}\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.12.\nfunc inColumnGroupIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Col:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Colgroup:\n\t\t\tif p.oe.top().DataAtom == a.Colgroup {\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Col:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\tif p.oe.top().DataAtom != a.Colgroup {\n\t\treturn true\n\t}\n\tp.oe.pop()\n\tp.im = inTableIM\n\treturn false\n}\n\n// Section 12.2.6.4.13.\nfunc inTableBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tr:\n\t\t\tp.clearStackToContext(tableBodyScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inRowIM\n\t\t\treturn true\n\t\tcase a.Td, a.Th:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Tr, a.Tr.String())\n\t\t\treturn false\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n\t\t\t\tp.im = inTableIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\tp.clearStackToContext(tableBodyScope)\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n\t\t\t\tp.im = inTableIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\n\treturn inTableIM(p)\n}\n\n// Section 12.2.6.4.14.\nfunc inRowIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Td, a.Th:\n\t\t\tp.clearStackToContext(tableRowScope)\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.im = inCellIM\n\t\t\treturn true\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Tr, a.Tr.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn inTableIM(p)\n}\n\n// Section 12.2.6.4.15.\nfunc inCellIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Td, a.Th) {\n\t\t\t\t// Close the cell and reprocess.\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t\tp.im = inRowIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Td, a.Th:\n\t\t\tif !p.popUntil(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inRowIM\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif !p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Close the cell and reprocess.\n\t\t\tif p.popUntil(tableScope, a.Td, a.Th) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t}\n\t\t\tp.im = inRowIM\n\t\t\treturn false\n\t\t}\n\t}\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.16.\nfunc inSelectIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.addText(strings.Replace(p.tok.Data, \"\\x00\", \"\", -1))\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Optgroup:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tif p.top().DataAtom == a.Optgroup {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Select:\n\t\t\tif !p.popUntil(selectScope, a.Select) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\tcase a.Input, a.Keygen, a.Textarea:\n\t\t\tif p.elementInScope(selectScope, a.Select) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// In order to properly ignore <textarea>, we need to change the tokenizer mode.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Script, a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Iframe, a.Noembed, a.Noframes, a.Noscript, a.Plaintext, a.Style, a.Title, a.Xmp:\n\t\t\t// Don't let the tokenizer go into raw text mode when there are raw tags\n\t\t\t// to be ignored. These tags should be ignored from the tokenizer\n\t\t\t// properly.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\tcase a.Optgroup:\n\t\t\ti := len(p.oe) - 1\n\t\t\tif p.oe[i].DataAtom == a.Option {\n\t\t\t\ti--\n\t\t\t}\n\t\t\tif p.oe[i].DataAtom == a.Optgroup {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t}\n\t\tcase a.Select:\n\t\t\tif !p.popUntil(selectScope, a.Select) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\n\treturn true\n}\n\n// Section 12.2.6.4.17.\nfunc inSelectInTableIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken, EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:\n\t\t\tif p.tok.Type == EndTagToken && !p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// This is like p.popUntil(selectScope, a.Select), but it also\n\t\t\t// matches <math select>, not just <select>. Matching the MathML\n\t\t\t// tag is arguably incorrect (conceptually), but it mimics what\n\t\t\t// Chromium does.\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tif n := p.oe[i]; n.DataAtom == a.Select {\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\t\treturn false\n\t\t}\n\t}\n\treturn inSelectIM(p)\n}\n\n// Section 12.2.6.4.18.\nfunc inTemplateIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken, CommentToken, DoctypeToken:\n\t\treturn inBodyIM(p)\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Caption, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inTableIM)\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Col:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inColumnGroupIM)\n\t\t\tp.im = inColumnGroupIM\n\t\t\treturn false\n\t\tcase a.Tr:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inTableBodyIM)\n\t\t\tp.im = inTableBodyIM\n\t\t\treturn false\n\t\tcase a.Td, a.Th:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inRowIM)\n\t\t\tp.im = inRowIM\n\t\t\treturn false\n\t\tdefault:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inBodyIM)\n\t\t\tp.im = inBodyIM\n\t\t\treturn false\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase ErrorToken:\n\t\tif !p.oe.contains(a.Template) {\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t//\n\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\tp.generateImpliedEndTags()\n\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\tif n := p.oe[i]; n.Namespace == \"\" && n.DataAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tp.clearActiveFormattingElements()\n\t\tp.templateStack.pop()\n\t\tp.resetInsertionMode()\n\t\treturn false\n\t}\n\treturn false\n}\n\n// Section 12.2.6.4.19.\nfunc afterBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\t// Stop parsing.\n\t\treturn true\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\tif !p.fragment {\n\t\t\t\tp.im = afterAfterBodyIM\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\t// The comment is attached to the <html> element.\n\t\tif len(p.oe) < 1 || p.oe[0].DataAtom != a.Html {\n\t\t\tpanic(\"html: bad parser state: <html> element not found, in the after-body insertion mode\")\n\t\t}\n\t\tp.oe[0].AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\tp.im = inBodyIM\n\treturn false\n}\n\n// Section 12.2.6.4.20.\nfunc inFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.addText(s)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Frameset:\n\t\t\tp.addElement()\n\t\tcase a.Frame:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Frameset:\n\t\t\tif p.oe.top().DataAtom != a.Html {\n\t\t\t\tp.oe.pop()\n\t\t\t\tif p.oe.top().DataAtom != a.Frameset {\n\t\t\t\t\tp.im = afterFramesetIM\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.6.4.21.\nfunc afterFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.addText(s)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\tp.im = afterAfterFramesetIM\n\t\t\treturn true\n\t\t}\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.6.4.22.\nfunc afterAfterBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\t// Stop parsing.\n\t\treturn true\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\treturn inBodyIM(p)\n\t}\n\tp.im = inBodyIM\n\treturn false\n}\n\n// Section 12.2.6.4.23.\nfunc afterAfterFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.tok.Data = s\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase DoctypeToken:\n\t\treturn inBodyIM(p)\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\nconst whitespaceOrNUL = whitespace + \"\\x00\"\n\n// Section 12.2.6.5\nfunc parseForeignContent(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tif p.framesetOK {\n\t\t\tp.framesetOK = strings.TrimLeft(p.tok.Data, whitespaceOrNUL) == \"\"\n\t\t}\n\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\\ufffd\", -1)\n\t\tp.addText(p.tok.Data)\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase StartTagToken:\n\t\tif !p.fragment {\n\t\t\tb := breakout[p.tok.Data]\n\t\t\tif p.tok.DataAtom == a.Font {\n\t\t\tloop:\n\t\t\t\tfor _, attr := range p.tok.Attr {\n\t\t\t\t\tswitch attr.Key {\n\t\t\t\t\tcase \"color\", \"face\", \"size\":\n\t\t\t\t\t\tb = true\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif b {\n\t\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\t\tn := p.oe[i]\n\t\t\t\t\tif n.Namespace == \"\" || htmlIntegrationPoint(n) || mathMLTextIntegrationPoint(n) {\n\t\t\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tcurrent := p.adjustedCurrentNode()\n\t\tswitch current.Namespace {\n\t\tcase \"math\":\n\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n\t\tcase \"svg\":\n\t\t\t// Adjust SVG tag names. The tokenizer lower-cases tag names, but\n\t\t\t// SVG wants e.g. \"foreignObject\" with a capital second \"O\".\n\t\t\tif x := svgTagNameAdjustments[p.tok.Data]; x != \"\" {\n\t\t\t\tp.tok.DataAtom = a.Lookup([]byte(x))\n\t\t\t\tp.tok.Data = x\n\t\t\t}\n\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n\t\tdefault:\n\t\t\tpanic(\"html: bad parser state: unexpected namespace\")\n\t\t}\n\t\tadjustForeignAttributes(p.tok.Attr)\n\t\tnamespace := current.Namespace\n\t\tp.addElement()\n\t\tp.top().Namespace = namespace\n\t\tif namespace != \"\" {\n\t\t\t// Don't let the tokenizer go into raw text mode in foreign content\n\t\t\t// (e.g. in an SVG <title> tag).\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t}\n\t\tif p.hasSelfClosingToken {\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t}\n\tcase EndTagToken:\n\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\tif p.oe[i].Namespace == \"\" {\n\t\t\t\treturn p.im(p)\n\t\t\t}\n\t\t\tif strings.EqualFold(p.oe[i].Data, p.tok.Data) {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.4.2.\nfunc (p *parser) adjustedCurrentNode() *Node {\n\tif len(p.oe) == 1 && p.fragment && p.context != nil {\n\t\treturn p.context\n\t}\n\treturn p.oe.top()\n}\n\n// Section 12.2.6.\nfunc (p *parser) inForeignContent() bool {\n\tif len(p.oe) == 0 {\n\t\treturn false\n\t}\n\tn := p.adjustedCurrentNode()\n\tif n.Namespace == \"\" {\n\t\treturn false\n\t}\n\tif mathMLTextIntegrationPoint(n) {\n\t\tif p.tok.Type == StartTagToken && p.tok.DataAtom != a.Mglyph && p.tok.DataAtom != a.Malignmark {\n\t\t\treturn false\n\t\t}\n\t\tif p.tok.Type == TextToken {\n\t\t\treturn false\n\t\t}\n\t}\n\tif n.Namespace == \"math\" && n.DataAtom == a.AnnotationXml && p.tok.Type == StartTagToken && p.tok.DataAtom == a.Svg {\n\t\treturn false\n\t}\n\tif htmlIntegrationPoint(n) && (p.tok.Type == StartTagToken || p.tok.Type == TextToken) {\n\t\treturn false\n\t}\n\tif p.tok.Type == ErrorToken {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// parseImpliedToken parses a token as though it had appeared in the parser's\n// input.\nfunc (p *parser) parseImpliedToken(t TokenType, dataAtom a.Atom, data string) {\n\trealToken, selfClosing := p.tok, p.hasSelfClosingToken\n\tp.tok = Token{\n\t\tType:     t,\n\t\tDataAtom: dataAtom,\n\t\tData:     data,\n\t}\n\tp.hasSelfClosingToken = false\n\tp.parseCurrentToken()\n\tp.tok, p.hasSelfClosingToken = realToken, selfClosing\n}\n\n// parseCurrentToken runs the current token through the parsing routines\n// until it is consumed.\nfunc (p *parser) parseCurrentToken() {\n\tif p.tok.Type == SelfClosingTagToken {\n\t\tp.hasSelfClosingToken = true\n\t\tp.tok.Type = StartTagToken\n\t}\n\n\tconsumed := false\n\tfor !consumed {\n\t\tif p.inForeignContent() {\n\t\t\tconsumed = parseForeignContent(p)\n\t\t} else {\n\t\t\tconsumed = p.im(p)\n\t\t}\n\t}\n\n\tif p.hasSelfClosingToken {\n\t\t// This is a parse error, but ignore it.\n\t\tp.hasSelfClosingToken = false\n\t}\n}\n\nfunc (p *parser) parse() error {\n\t// Iterate until EOF. Any other error will cause an early return.\n\tvar err error\n\tfor err != io.EOF {\n\t\t// CDATA sections are allowed only in foreign content.\n\t\tn := p.oe.top()\n\t\tp.tokenizer.AllowCDATA(n != nil && n.Namespace != \"\")\n\t\t// Read and parse the next token.\n\t\tp.tokenizer.Next()\n\t\tp.tok = p.tokenizer.Token()\n\t\tif p.tok.Type == ErrorToken {\n\t\t\terr = p.tokenizer.Err()\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.parseCurrentToken()\n\t}\n\treturn nil\n}\n\n// Parse returns the parse tree for the HTML from the given Reader.\n//\n// It implements the HTML5 parsing algorithm\n// (https://html.spec.whatwg.org/multipage/syntax.html#tree-construction),\n// which is very complicated. The resultant tree can contain implicitly created\n// nodes that have no explicit <tag> listed in r's data, and nodes' parents can\n// differ from the nesting implied by a naive processing of start and end\n// <tag>s. Conversely, explicit <tag>s in r's data can be silently dropped,\n// with no corresponding node in the resulting tree.\n//\n// The input is assumed to be UTF-8 encoded.\nfunc Parse(r io.Reader) (*Node, error) {\n\treturn ParseWithOptions(r)\n}\n\n// ParseFragment parses a fragment of HTML and returns the nodes that were\n// found. If the fragment is the InnerHTML for an existing element, pass that\n// element in context.\n//\n// It has the same intricacies as Parse.\nfunc ParseFragment(r io.Reader, context *Node) ([]*Node, error) {\n\treturn ParseFragmentWithOptions(r, context)\n}\n\n// ParseOption configures a parser.\ntype ParseOption func(p *parser)\n\n// ParseOptionEnableScripting configures the scripting flag.\n// https://html.spec.whatwg.org/multipage/webappapis.html#enabling-and-disabling-scripting\n//\n// By default, scripting is enabled.\nfunc ParseOptionEnableScripting(enable bool) ParseOption {\n\treturn func(p *parser) {\n\t\tp.scripting = enable\n\t}\n}\n\n// ParseWithOptions is like Parse, with options.\nfunc ParseWithOptions(r io.Reader, opts ...ParseOption) (*Node, error) {\n\tp := &parser{\n\t\ttokenizer: NewTokenizer(r),\n\t\tdoc: &Node{\n\t\t\tType: DocumentNode,\n\t\t},\n\t\tscripting:  true,\n\t\tframesetOK: true,\n\t\tim:         initialIM,\n\t}\n\n\tfor _, f := range opts {\n\t\tf(p)\n\t}\n\n\tif err := p.parse(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p.doc, nil\n}\n\n// ParseFragmentWithOptions is like ParseFragment, with options.\nfunc ParseFragmentWithOptions(r io.Reader, context *Node, opts ...ParseOption) ([]*Node, error) {\n\tcontextTag := \"\"\n\tif context != nil {\n\t\tif context.Type != ElementNode {\n\t\t\treturn nil, errors.New(\"html: ParseFragment of non-element Node\")\n\t\t}\n\t\t// The next check isn't just context.DataAtom.String() == context.Data because\n\t\t// it is valid to pass an element whose tag isn't a known atom. For example,\n\t\t// DataAtom == 0 and Data = \"tagfromthefuture\" is perfectly consistent.\n\t\tif context.DataAtom != a.Lookup([]byte(context.Data)) {\n\t\t\treturn nil, fmt.Errorf(\"html: inconsistent Node: DataAtom=%q, Data=%q\", context.DataAtom, context.Data)\n\t\t}\n\t\tcontextTag = context.DataAtom.String()\n\t}\n\tp := &parser{\n\t\tdoc: &Node{\n\t\t\tType: DocumentNode,\n\t\t},\n\t\tscripting: true,\n\t\tfragment:  true,\n\t\tcontext:   context,\n\t}\n\tif context != nil && context.Namespace != \"\" {\n\t\tp.tokenizer = NewTokenizer(r)\n\t} else {\n\t\tp.tokenizer = NewTokenizerFragment(r, contextTag)\n\t}\n\n\tfor _, f := range opts {\n\t\tf(p)\n\t}\n\n\troot := &Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: a.Html,\n\t\tData:     a.Html.String(),\n\t}\n\tp.doc.AppendChild(root)\n\tp.oe = nodeStack{root}\n\tif context != nil && context.DataAtom == a.Template {\n\t\tp.templateStack = append(p.templateStack, inTemplateIM)\n\t}\n\tp.resetInsertionMode()\n\n\tfor n := context; n != nil; n = n.Parent {\n\t\tif n.Type == ElementNode && n.DataAtom == a.Form {\n\t\t\tp.form = n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := p.parse(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tparent := p.doc\n\tif context != nil {\n\t\tparent = root\n\t}\n\n\tvar result []*Node\n\tfor c := parent.FirstChild; c != nil; {\n\t\tnext := c.NextSibling\n\t\tparent.RemoveChild(c)\n\t\tresult = append(result, c)\n\t\tc = next\n\t}\n\treturn result, nil\n}\n", "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage html\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"golang.org/x/net/html/atom\"\n)\n\ntype testAttrs struct {\n\ttext, want, context string\n\tscripting           bool\n}\n\n// readParseTest reads a single test case from r.\nfunc readParseTest(r *bufio.Reader) (*testAttrs, error) {\n\tta := &testAttrs{scripting: true}\n\tline, err := r.ReadSlice('\\n')\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar b []byte\n\n\t// Read the HTML.\n\tif string(line) != \"#data\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#data\\n\"`, line)\n\t}\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif line[0] == '#' {\n\t\t\tbreak\n\t\t}\n\t\tb = append(b, line...)\n\t}\n\tta.text = strings.TrimSuffix(string(b), \"\\n\")\n\tb = b[:0]\n\n\t// Skip the error list.\n\tif string(line) != \"#errors\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#errors\\n\"`, line)\n\t}\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif line[0] == '#' {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Skip the new-errors list.\n\tif string(line) == \"#new-errors\\n\" {\n\t\tfor {\n\t\t\tline, err = r.ReadSlice('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif line[0] == '#' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif ls := string(line); strings.HasPrefix(ls, \"#script-\") {\n\t\tswitch {\n\t\tcase strings.HasSuffix(ls, \"-on\\n\"):\n\t\t\tta.scripting = true\n\t\tcase strings.HasSuffix(ls, \"-off\\n\"):\n\t\t\tta.scripting = false\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(`got %q, want \"#script-on\" or \"#script-off\"`, line)\n\t\t}\n\t\tfor {\n\t\t\tline, err = r.ReadSlice('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif line[0] == '#' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif string(line) == \"#document-fragment\\n\" {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tta.context = strings.TrimSpace(string(line))\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Read the dump of what the parse tree should be.\n\tif string(line) != \"#document\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#document\\n\"`, line)\n\t}\n\tinQuote := false\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn nil, err\n\t\t}\n\t\ttrimmed := bytes.Trim(line, \"| \\n\")\n\t\tif len(trimmed) > 0 {\n\t\t\tif line[0] == '|' && trimmed[0] == '\"' {\n\t\t\t\tinQuote = true\n\t\t\t}\n\t\t\tif trimmed[len(trimmed)-1] == '\"' && !(line[0] == '|' && len(trimmed) == 1) {\n\t\t\t\tinQuote = false\n\t\t\t}\n\t\t}\n\t\tif len(line) == 0 || len(line) == 1 && line[0] == '\\n' && !inQuote {\n\t\t\tbreak\n\t\t}\n\t\tb = append(b, line...)\n\t}\n\tta.want = string(b)\n\treturn ta, nil\n}\n\nfunc dumpIndent(w io.Writer, level int) {\n\tio.WriteString(w, \"| \")\n\tfor i := 0; i < level; i++ {\n\t\tio.WriteString(w, \"  \")\n\t}\n}\n\ntype sortedAttributes []Attribute\n\nfunc (a sortedAttributes) Len() int {\n\treturn len(a)\n}\n\nfunc (a sortedAttributes) Less(i, j int) bool {\n\tif a[i].Namespace != a[j].Namespace {\n\t\treturn a[i].Namespace < a[j].Namespace\n\t}\n\treturn a[i].Key < a[j].Key\n}\n\nfunc (a sortedAttributes) Swap(i, j int) {\n\ta[i], a[j] = a[j], a[i]\n}\n\nfunc dumpLevel(w io.Writer, n *Node, level int) error {\n\tdumpIndent(w, level)\n\tlevel++\n\tswitch n.Type {\n\tcase ErrorNode:\n\t\treturn errors.New(\"unexpected ErrorNode\")\n\tcase DocumentNode:\n\t\treturn errors.New(\"unexpected DocumentNode\")\n\tcase ElementNode:\n\t\tif n.Namespace != \"\" {\n\t\t\tfmt.Fprintf(w, \"<%s %s>\", n.Namespace, n.Data)\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n\t\t}\n\t\tattr := sortedAttributes(n.Attr)\n\t\tsort.Sort(attr)\n\t\tfor _, a := range attr {\n\t\t\tio.WriteString(w, \"\\n\")\n\t\t\tdumpIndent(w, level)\n\t\t\tif a.Namespace != \"\" {\n\t\t\t\tfmt.Fprintf(w, `%s %s=\"%s\"`, a.Namespace, a.Key, a.Val)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n\t\t\t}\n\t\t}\n\t\tif n.Namespace == \"\" && n.DataAtom == atom.Template {\n\t\t\tio.WriteString(w, \"\\n\")\n\t\t\tdumpIndent(w, level)\n\t\t\tlevel++\n\t\t\tio.WriteString(w, \"content\")\n\t\t}\n\tcase TextNode:\n\t\tfmt.Fprintf(w, `\"%s\"`, n.Data)\n\tcase CommentNode:\n\t\tfmt.Fprintf(w, \"<!-- %s -->\", n.Data)\n\tcase DoctypeNode:\n\t\tfmt.Fprintf(w, \"<!DOCTYPE %s\", n.Data)\n\t\tif n.Attr != nil {\n\t\t\tvar p, s string\n\t\t\tfor _, a := range n.Attr {\n\t\t\t\tswitch a.Key {\n\t\t\t\tcase \"public\":\n\t\t\t\t\tp = a.Val\n\t\t\t\tcase \"system\":\n\t\t\t\t\ts = a.Val\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p != \"\" || s != \"\" {\n\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, p)\n\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, s)\n\t\t\t}\n\t\t}\n\t\tio.WriteString(w, \">\")\n\tcase scopeMarkerNode:\n\t\treturn errors.New(\"unexpected scopeMarkerNode\")\n\tdefault:\n\t\treturn errors.New(\"unknown node type\")\n\t}\n\tio.WriteString(w, \"\\n\")\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif err := dumpLevel(w, c, level); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc dump(n *Node) (string, error) {\n\tif n == nil || n.FirstChild == nil {\n\t\treturn \"\", nil\n\t}\n\tvar b bytes.Buffer\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif err := dumpLevel(&b, c, 0); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn b.String(), nil\n}\n\nvar testDataDirs = []string{\"testdata/webkit/\", \"testdata/go/\"}\n\nfunc TestParser(t *testing.T) {\n\tfor _, testDataDir := range testDataDirs {\n\t\ttestFiles, err := filepath.Glob(testDataDir + \"*.dat\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, tf := range testFiles {\n\t\t\tf, err := os.Open(tf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tr := bufio.NewReader(f)\n\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tta, err := readParseTest(r)\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\terr = testParseCase(ta.text, ta.want, ta.context, ParseOptionEnableScripting(ta.scripting))\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"%s test #%d %q, %s\", tf, i, ta.text, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue 16318\nfunc TestParserWithoutScripting(t *testing.T) {\n\ttext := `<noscript><img src='https://golang.org/doc/gopher/frontpage.png' /></noscript><p><img src='https://golang.org/doc/gopher/doc.png' /></p>`\n\twant := `| <html>\n|   <head>\n|     <noscript>\n|   <body>\n|     <img>\n|       src=\"https://golang.org/doc/gopher/frontpage.png\"\n|     <p>\n|       <img>\n|         src=\"https://golang.org/doc/gopher/doc.png\"\n`\n\n\tif err := testParseCase(text, want, \"\", ParseOptionEnableScripting(false)); err != nil {\n\t\tt.Errorf(\"test with scripting is disabled, %q, %s\", text, err)\n\t}\n}\n\n// testParseCase tests one test case from the test files. If the test does not\n// pass, it returns an error that explains the failure.\n// text is the HTML to be parsed, want is a dump of the correct parse tree,\n// and context is the name of the context node, if any.\nfunc testParseCase(text, want, context string, opts ...ParseOption) (err error) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tswitch e := x.(type) {\n\t\t\tcase error:\n\t\t\t\terr = e\n\t\t\tdefault:\n\t\t\t\terr = fmt.Errorf(\"%v\", e)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar doc *Node\n\tif context == \"\" {\n\t\tdoc, err = ParseWithOptions(strings.NewReader(text), opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tnamespace := \"\"\n\t\tif i := strings.IndexByte(context, ' '); i >= 0 {\n\t\t\tnamespace, context = context[:i], context[i+1:]\n\t\t}\n\t\tcontextNode := &Node{\n\t\t\tData:      context,\n\t\t\tDataAtom:  atom.Lookup([]byte(context)),\n\t\t\tNamespace: namespace,\n\t\t\tType:      ElementNode,\n\t\t}\n\t\tnodes, err := ParseFragmentWithOptions(strings.NewReader(text), contextNode, opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdoc = &Node{\n\t\t\tType: DocumentNode,\n\t\t}\n\t\tfor _, n := range nodes {\n\t\t\tdoc.AppendChild(n)\n\t\t}\n\t}\n\n\tif err := checkTreeConsistency(doc); err != nil {\n\t\treturn err\n\t}\n\n\tgot, err := dump(doc)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Compare the parsed tree to the #document section.\n\tif got != want {\n\t\treturn fmt.Errorf(\"got vs want:\\n----\\n%s----\\n%s----\", got, want)\n\t}\n\n\tif renderTestBlacklist[text] || context != \"\" {\n\t\treturn nil\n\t}\n\n\t// Check that rendering and re-parsing results in an identical tree.\n\tpr, pw := io.Pipe()\n\tgo func() {\n\t\tpw.CloseWithError(Render(pw, doc))\n\t}()\n\tdoc1, err := ParseWithOptions(pr, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgot1, err := dump(doc1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif got != got1 {\n\t\treturn fmt.Errorf(\"got vs got1:\\n----\\n%s----\\n%s----\", got, got1)\n\t}\n\n\treturn nil\n}\n\n// Some test input result in parse trees are not 'well-formed' despite\n// following the HTML5 recovery algorithms. Rendering and re-parsing such a\n// tree will not result in an exact clone of that tree. We blacklist such\n// inputs from the render test.\nvar renderTestBlacklist = map[string]bool{\n\t// The second <a> will be reparented to the first <table>'s parent. This\n\t// results in an <a> whose parent is an <a>, which is not 'well-formed'.\n\t`<a><table><td><a><table></table><a></tr><a></table><b>X</b>C<a>Y`: true,\n\t// The same thing with a <p>:\n\t`<p><table></p>`: true,\n\t// More cases of <a> being reparented:\n\t`<a href=\"blah\">aba<table><a href=\"foo\">br<tr><td></td></tr>x</table>aoe`: true,\n\t`<a><table><a></table><p><a><div><a>`:                                     true,\n\t`<a><table><td><a><table></table><a></tr><a></table><a>`:                  true,\n\t`<template><a><table><a>`:                                                 true,\n\t// A similar reparenting situation involving <nobr>:\n\t`<!DOCTYPE html><body><b><nobr>1<table><nobr></b><i><nobr>2<nobr></i>3`: true,\n\t// A <plaintext> element is reparented, putting it before a table.\n\t// A <plaintext> element can't have anything after it in HTML.\n\t`<table><plaintext><td>`:                                   true,\n\t`<!doctype html><table><plaintext></plaintext>`:            true,\n\t`<!doctype html><table><tbody><plaintext></plaintext>`:     true,\n\t`<!doctype html><table><tbody><tr><plaintext></plaintext>`: true,\n\t// A form inside a table inside a form doesn't work either.\n\t`<!doctype html><form><table></form><form></table></form>`: true,\n\t// A script that ends at EOF may escape its own closing tag when rendered.\n\t`<!doctype html><script><!--<script `:          true,\n\t`<!doctype html><script><!--<script <`:         true,\n\t`<!doctype html><script><!--<script <a`:        true,\n\t`<!doctype html><script><!--<script </`:        true,\n\t`<!doctype html><script><!--<script </s`:       true,\n\t`<!doctype html><script><!--<script </script`:  true,\n\t`<!doctype html><script><!--<script </scripta`: true,\n\t`<!doctype html><script><!--<script -`:         true,\n\t`<!doctype html><script><!--<script -a`:        true,\n\t`<!doctype html><script><!--<script -<`:        true,\n\t`<!doctype html><script><!--<script --`:        true,\n\t`<!doctype html><script><!--<script --a`:       true,\n\t`<!doctype html><script><!--<script --<`:       true,\n\t`<script><!--<script `:                         true,\n\t`<script><!--<script <a`:                       true,\n\t`<script><!--<script </script`:                 true,\n\t`<script><!--<script </scripta`:                true,\n\t`<script><!--<script -`:                        true,\n\t`<script><!--<script -a`:                       true,\n\t`<script><!--<script --`:                       true,\n\t`<script><!--<script --a`:                      true,\n\t`<script><!--<script <`:                        true,\n\t`<script><!--<script </`:                       true,\n\t`<script><!--<script </s`:                      true,\n\t// Reconstructing the active formatting elements results in a <plaintext>\n\t// element that contains an <a> element.\n\t`<!doctype html><p><a><plaintext>b`:                       true,\n\t`<table><math><select><mi><select></table>`:               true,\n\t`<!doctype html><table><colgroup><plaintext></plaintext>`: true,\n\t`<!doctype html><svg><plaintext>a</plaintext>b`:           true,\n}\n\nfunc TestNodeConsistency(t *testing.T) {\n\t// inconsistentNode is a Node whose DataAtom and Data do not agree.\n\tinconsistentNode := &Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: atom.Frameset,\n\t\tData:     \"table\",\n\t}\n\tif _, err := ParseFragment(strings.NewReader(\"<p>hello</p>\"), inconsistentNode); err == nil {\n\t\tt.Errorf(\"got nil error, want non-nil\")\n\t}\n}\n\nfunc TestParseFragmentWithNilContext(t *testing.T) {\n\t// This shouldn't panic.\n\tParseFragment(strings.NewReader(\"<p>hello</p>\"), nil)\n}\n\nfunc BenchmarkParser(b *testing.B) {\n\tbuf, err := ioutil.ReadFile(\"testdata/go1.html\")\n\tif err != nil {\n\t\tb.Fatalf(\"could not read testdata/go1.html: %v\", err)\n\t}\n\tb.SetBytes(int64(len(buf)))\n\truntime.GC()\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tParse(bytes.NewBuffer(buf))\n\t}\n}\n"], "fixing_code": ["// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage html\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\ta \"golang.org/x/net/html/atom\"\n)\n\n// A parser implements the HTML5 parsing algorithm:\n// https://html.spec.whatwg.org/multipage/syntax.html#tree-construction\ntype parser struct {\n\t// tokenizer provides the tokens for the parser.\n\ttokenizer *Tokenizer\n\t// tok is the most recently read token.\n\ttok Token\n\t// Self-closing tags like <hr/> are treated as start tags, except that\n\t// hasSelfClosingToken is set while they are being processed.\n\thasSelfClosingToken bool\n\t// doc is the document root element.\n\tdoc *Node\n\t// The stack of open elements (section 12.2.4.2) and active formatting\n\t// elements (section 12.2.4.3).\n\toe, afe nodeStack\n\t// Element pointers (section 12.2.4.4).\n\thead, form *Node\n\t// Other parsing state flags (section 12.2.4.5).\n\tscripting, framesetOK bool\n\t// The stack of template insertion modes\n\ttemplateStack insertionModeStack\n\t// im is the current insertion mode.\n\tim insertionMode\n\t// originalIM is the insertion mode to go back to after completing a text\n\t// or inTableText insertion mode.\n\toriginalIM insertionMode\n\t// fosterParenting is whether new elements should be inserted according to\n\t// the foster parenting rules (section 12.2.6.1).\n\tfosterParenting bool\n\t// quirks is whether the parser is operating in \"quirks mode.\"\n\tquirks bool\n\t// fragment is whether the parser is parsing an HTML fragment.\n\tfragment bool\n\t// context is the context element when parsing an HTML fragment\n\t// (section 12.4).\n\tcontext *Node\n}\n\nfunc (p *parser) top() *Node {\n\tif n := p.oe.top(); n != nil {\n\t\treturn n\n\t}\n\treturn p.doc\n}\n\n// Stop tags for use in popUntil. These come from section 12.2.4.2.\nvar (\n\tdefaultScopeStopTags = map[string][]a.Atom{\n\t\t\"\":     {a.Applet, a.Caption, a.Html, a.Table, a.Td, a.Th, a.Marquee, a.Object, a.Template},\n\t\t\"math\": {a.AnnotationXml, a.Mi, a.Mn, a.Mo, a.Ms, a.Mtext},\n\t\t\"svg\":  {a.Desc, a.ForeignObject, a.Title},\n\t}\n)\n\ntype scope int\n\nconst (\n\tdefaultScope scope = iota\n\tlistItemScope\n\tbuttonScope\n\ttableScope\n\ttableRowScope\n\ttableBodyScope\n\tselectScope\n)\n\n// popUntil pops the stack of open elements at the highest element whose tag\n// is in matchTags, provided there is no higher element in the scope's stop\n// tags (as defined in section 12.2.4.2). It returns whether or not there was\n// such an element. If there was not, popUntil leaves the stack unchanged.\n//\n// For example, the set of stop tags for table scope is: \"html\", \"table\". If\n// the stack was:\n// [\"html\", \"body\", \"font\", \"table\", \"b\", \"i\", \"u\"]\n// then popUntil(tableScope, \"font\") would return false, but\n// popUntil(tableScope, \"i\") would return true and the stack would become:\n// [\"html\", \"body\", \"font\", \"table\", \"b\"]\n//\n// If an element's tag is in both the stop tags and matchTags, then the stack\n// will be popped and the function returns true (provided, of course, there was\n// no higher element in the stack that was also in the stop tags). For example,\n// popUntil(tableScope, \"table\") returns true and leaves:\n// [\"html\", \"body\", \"font\"]\nfunc (p *parser) popUntil(s scope, matchTags ...a.Atom) bool {\n\tif i := p.indexOfElementInScope(s, matchTags...); i != -1 {\n\t\tp.oe = p.oe[:i]\n\t\treturn true\n\t}\n\treturn false\n}\n\n// indexOfElementInScope returns the index in p.oe of the highest element whose\n// tag is in matchTags that is in scope. If no matching element is in scope, it\n// returns -1.\nfunc (p *parser) indexOfElementInScope(s scope, matchTags ...a.Atom) int {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\ttagAtom := p.oe[i].DataAtom\n\t\tif p.oe[i].Namespace == \"\" {\n\t\t\tfor _, t := range matchTags {\n\t\t\t\tif t == tagAtom {\n\t\t\t\t\treturn i\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch s {\n\t\t\tcase defaultScope:\n\t\t\t\t// No-op.\n\t\t\tcase listItemScope:\n\t\t\t\tif tagAtom == a.Ol || tagAtom == a.Ul {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase buttonScope:\n\t\t\t\tif tagAtom == a.Button {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase tableScope:\n\t\t\t\tif tagAtom == a.Html || tagAtom == a.Table || tagAtom == a.Template {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tcase selectScope:\n\t\t\t\tif tagAtom != a.Optgroup && tagAtom != a.Option {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t}\n\t\tswitch s {\n\t\tcase defaultScope, listItemScope, buttonScope:\n\t\t\tfor _, t := range defaultScopeStopTags[p.oe[i].Namespace] {\n\t\t\t\tif t == tagAtom {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// elementInScope is like popUntil, except that it doesn't modify the stack of\n// open elements.\nfunc (p *parser) elementInScope(s scope, matchTags ...a.Atom) bool {\n\treturn p.indexOfElementInScope(s, matchTags...) != -1\n}\n\n// clearStackToContext pops elements off the stack of open elements until a\n// scope-defined element is found.\nfunc (p *parser) clearStackToContext(s scope) {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\ttagAtom := p.oe[i].DataAtom\n\t\tswitch s {\n\t\tcase tableScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Table || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tableRowScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Tr || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tableBodyScope:\n\t\t\tif tagAtom == a.Html || tagAtom == a.Tbody || tagAtom == a.Tfoot || tagAtom == a.Thead || tagAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\n// parseGenericRawTextElements implements the generic raw text element parsing\n// algorithm defined in 12.2.6.2.\n// https://html.spec.whatwg.org/multipage/parsing.html#parsing-elements-that-contain-only-text\n// TODO: Since both RAWTEXT and RCDATA states are treated as tokenizer's part\n// officially, need to make tokenizer consider both states.\nfunc (p *parser) parseGenericRawTextElement() {\n\tp.addElement()\n\tp.originalIM = p.im\n\tp.im = textIM\n}\n\n// generateImpliedEndTags pops nodes off the stack of open elements as long as\n// the top node has a tag name of dd, dt, li, optgroup, option, p, rb, rp, rt or rtc.\n// If exceptions are specified, nodes with that name will not be popped off.\nfunc (p *parser) generateImpliedEndTags(exceptions ...string) {\n\tvar i int\nloop:\n\tfor i = len(p.oe) - 1; i >= 0; i-- {\n\t\tn := p.oe[i]\n\t\tif n.Type != ElementNode {\n\t\t\tbreak\n\t\t}\n\t\tswitch n.DataAtom {\n\t\tcase a.Dd, a.Dt, a.Li, a.Optgroup, a.Option, a.P, a.Rb, a.Rp, a.Rt, a.Rtc:\n\t\t\tfor _, except := range exceptions {\n\t\t\t\tif n.Data == except {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tp.oe = p.oe[:i+1]\n}\n\n// addChild adds a child node n to the top element, and pushes n onto the stack\n// of open elements if it is an element node.\nfunc (p *parser) addChild(n *Node) {\n\tif p.shouldFosterParent() {\n\t\tp.fosterParent(n)\n\t} else {\n\t\tp.top().AppendChild(n)\n\t}\n\n\tif n.Type == ElementNode {\n\t\tp.oe = append(p.oe, n)\n\t}\n}\n\n// shouldFosterParent returns whether the next node to be added should be\n// foster parented.\nfunc (p *parser) shouldFosterParent() bool {\n\tif p.fosterParenting {\n\t\tswitch p.top().DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// fosterParent adds a child node according to the foster parenting rules.\n// Section 12.2.6.1, \"foster parenting\".\nfunc (p *parser) fosterParent(n *Node) {\n\tvar table, parent, prev, template *Node\n\tvar i int\n\tfor i = len(p.oe) - 1; i >= 0; i-- {\n\t\tif p.oe[i].DataAtom == a.Table {\n\t\t\ttable = p.oe[i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar j int\n\tfor j = len(p.oe) - 1; j >= 0; j-- {\n\t\tif p.oe[j].DataAtom == a.Template {\n\t\t\ttemplate = p.oe[j]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif template != nil && (table == nil || j > i) {\n\t\ttemplate.AppendChild(n)\n\t\treturn\n\t}\n\n\tif table == nil {\n\t\t// The foster parent is the html element.\n\t\tparent = p.oe[0]\n\t} else {\n\t\tparent = table.Parent\n\t}\n\tif parent == nil {\n\t\tparent = p.oe[i-1]\n\t}\n\n\tif table != nil {\n\t\tprev = table.PrevSibling\n\t} else {\n\t\tprev = parent.LastChild\n\t}\n\tif prev != nil && prev.Type == TextNode && n.Type == TextNode {\n\t\tprev.Data += n.Data\n\t\treturn\n\t}\n\n\tparent.InsertBefore(n, table)\n}\n\n// addText adds text to the preceding node if it is a text node, or else it\n// calls addChild with a new text node.\nfunc (p *parser) addText(text string) {\n\tif text == \"\" {\n\t\treturn\n\t}\n\n\tif p.shouldFosterParent() {\n\t\tp.fosterParent(&Node{\n\t\t\tType: TextNode,\n\t\t\tData: text,\n\t\t})\n\t\treturn\n\t}\n\n\tt := p.top()\n\tif n := t.LastChild; n != nil && n.Type == TextNode {\n\t\tn.Data += text\n\t\treturn\n\t}\n\tp.addChild(&Node{\n\t\tType: TextNode,\n\t\tData: text,\n\t})\n}\n\n// addElement adds a child element based on the current token.\nfunc (p *parser) addElement() {\n\tp.addChild(&Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: p.tok.DataAtom,\n\t\tData:     p.tok.Data,\n\t\tAttr:     p.tok.Attr,\n\t})\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) addFormattingElement() {\n\ttagAtom, attr := p.tok.DataAtom, p.tok.Attr\n\tp.addElement()\n\n\t// Implement the Noah's Ark clause, but with three per family instead of two.\n\tidenticalElements := 0\nfindIdenticalElements:\n\tfor i := len(p.afe) - 1; i >= 0; i-- {\n\t\tn := p.afe[i]\n\t\tif n.Type == scopeMarkerNode {\n\t\t\tbreak\n\t\t}\n\t\tif n.Type != ElementNode {\n\t\t\tcontinue\n\t\t}\n\t\tif n.Namespace != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif n.DataAtom != tagAtom {\n\t\t\tcontinue\n\t\t}\n\t\tif len(n.Attr) != len(attr) {\n\t\t\tcontinue\n\t\t}\n\tcompareAttributes:\n\t\tfor _, t0 := range n.Attr {\n\t\t\tfor _, t1 := range attr {\n\t\t\t\tif t0.Key == t1.Key && t0.Namespace == t1.Namespace && t0.Val == t1.Val {\n\t\t\t\t\t// Found a match for this attribute, continue with the next attribute.\n\t\t\t\t\tcontinue compareAttributes\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we get here, there is no attribute that matches a.\n\t\t\t// Therefore the element is not identical to the new one.\n\t\t\tcontinue findIdenticalElements\n\t\t}\n\n\t\tidenticalElements++\n\t\tif identicalElements >= 3 {\n\t\t\tp.afe.remove(n)\n\t\t}\n\t}\n\n\tp.afe = append(p.afe, p.top())\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) clearActiveFormattingElements() {\n\tfor {\n\t\tif n := p.afe.pop(); len(p.afe) == 0 || n.Type == scopeMarkerNode {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Section 12.2.4.3.\nfunc (p *parser) reconstructActiveFormattingElements() {\n\tn := p.afe.top()\n\tif n == nil {\n\t\treturn\n\t}\n\tif n.Type == scopeMarkerNode || p.oe.index(n) != -1 {\n\t\treturn\n\t}\n\ti := len(p.afe) - 1\n\tfor n.Type != scopeMarkerNode && p.oe.index(n) == -1 {\n\t\tif i == 0 {\n\t\t\ti = -1\n\t\t\tbreak\n\t\t}\n\t\ti--\n\t\tn = p.afe[i]\n\t}\n\tfor {\n\t\ti++\n\t\tclone := p.afe[i].clone()\n\t\tp.addChild(clone)\n\t\tp.afe[i] = clone\n\t\tif i == len(p.afe)-1 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Section 12.2.5.\nfunc (p *parser) acknowledgeSelfClosingTag() {\n\tp.hasSelfClosingToken = false\n}\n\n// An insertion mode (section 12.2.4.1) is the state transition function from\n// a particular state in the HTML5 parser's state machine. It updates the\n// parser's fields depending on parser.tok (where ErrorToken means EOF).\n// It returns whether the token was consumed.\ntype insertionMode func(*parser) bool\n\n// setOriginalIM sets the insertion mode to return to after completing a text or\n// inTableText insertion mode.\n// Section 12.2.4.1, \"using the rules for\".\nfunc (p *parser) setOriginalIM() {\n\tif p.originalIM != nil {\n\t\tpanic(\"html: bad parser state: originalIM was set twice\")\n\t}\n\tp.originalIM = p.im\n}\n\n// Section 12.2.4.1, \"reset the insertion mode\".\nfunc (p *parser) resetInsertionMode() {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\tn := p.oe[i]\n\t\tlast := i == 0\n\t\tif last && p.context != nil {\n\t\t\tn = p.context\n\t\t}\n\n\t\tswitch n.DataAtom {\n\t\tcase a.Select:\n\t\t\tif !last {\n\t\t\t\tfor ancestor, first := n, p.oe[0]; ancestor != first; {\n\t\t\t\t\tancestor = p.oe[p.oe.index(ancestor)-1]\n\t\t\t\t\tswitch ancestor.DataAtom {\n\t\t\t\t\tcase a.Template:\n\t\t\t\t\t\tp.im = inSelectIM\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase a.Table:\n\t\t\t\t\t\tp.im = inSelectInTableIM\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.im = inSelectIM\n\t\tcase a.Td, a.Th:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.im = inCellIM\n\t\tcase a.Tr:\n\t\t\tp.im = inRowIM\n\t\tcase a.Tbody, a.Thead, a.Tfoot:\n\t\t\tp.im = inTableBodyIM\n\t\tcase a.Caption:\n\t\t\tp.im = inCaptionIM\n\t\tcase a.Colgroup:\n\t\t\tp.im = inColumnGroupIM\n\t\tcase a.Table:\n\t\t\tp.im = inTableIM\n\t\tcase a.Template:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\tif n.Namespace != \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.im = p.templateStack.top()\n\t\tcase a.Head:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.im = inHeadIM\n\t\tcase a.Body:\n\t\t\tp.im = inBodyIM\n\t\tcase a.Frameset:\n\t\t\tp.im = inFramesetIM\n\t\tcase a.Html:\n\t\t\tif p.head == nil {\n\t\t\t\tp.im = beforeHeadIM\n\t\t\t} else {\n\t\t\t\tp.im = afterHeadIM\n\t\t\t}\n\t\tdefault:\n\t\t\tif last {\n\t\t\t\tp.im = inBodyIM\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\treturn\n\t}\n}\n\nconst whitespace = \" \\t\\r\\n\\f\"\n\n// Section 12.2.6.4.1.\nfunc initialIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\tn, quirks := parseDoctype(p.tok.Data)\n\t\tp.doc.AppendChild(n)\n\t\tp.quirks = quirks\n\t\tp.im = beforeHTMLIM\n\t\treturn true\n\t}\n\tp.quirks = true\n\tp.im = beforeHTMLIM\n\treturn false\n}\n\n// Section 12.2.6.4.2.\nfunc beforeHTMLIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\tp.addElement()\n\t\t\tp.im = beforeHeadIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head, a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n\t\t\treturn false\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n\treturn false\n}\n\n// Section 12.2.6.4.3.\nfunc beforeHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(p.tok.Data) == 0 {\n\t\t\t// It was all whitespace, so ignore it.\n\t\t\treturn true\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head:\n\t\t\tp.addElement()\n\t\t\tp.head = p.top()\n\t\t\tp.im = inHeadIM\n\t\t\treturn true\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head, a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n\t\t\treturn false\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n\treturn false\n}\n\n// Section 12.2.6.4.4.\nfunc inHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\treturn true\n\t\tcase a.Noscript:\n\t\t\tif p.scripting {\n\t\t\t\tp.parseGenericRawTextElement()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.im = inHeadNoscriptIM\n\t\t\t// Don't let the tokenizer go into raw text mode when scripting is disabled.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\treturn true\n\t\tcase a.Script, a.Title:\n\t\t\tp.addElement()\n\t\t\tp.setOriginalIM()\n\t\t\tp.im = textIM\n\t\t\treturn true\n\t\tcase a.Noframes, a.Style:\n\t\t\tp.parseGenericRawTextElement()\n\t\t\treturn true\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// We don't handle all of the corner cases when mixing foreign\n\t\t\t// content (i.e. <math> or <svg>) with <template>. Without this\n\t\t\t// early return, we can get into an infinite loop, possibly because\n\t\t\t// of the \"TODO... further divergence\" a little below.\n\t\t\t//\n\t\t\t// As a workaround, if we are mixing foreign content and templates,\n\t\t\t// just ignore the rest of the HTML. Foreign content is rare and a\n\t\t\t// relatively old HTML feature. Templates are also rare and a\n\t\t\t// relatively new HTML feature. Their combination is very rare.\n\t\t\tfor _, e := range p.oe {\n\t\t\t\tif e.Namespace != \"\" {\n\t\t\t\t\tp.im = ignoreTheRemainingTokens\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inTemplateIM\n\t\t\tp.templateStack = append(p.templateStack, inTemplateIM)\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Head:\n\t\t\tp.oe.pop()\n\t\t\tp.im = afterHeadIM\n\t\t\treturn true\n\t\tcase a.Body, a.Html, a.Br:\n\t\t\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n\t\t\treturn false\n\t\tcase a.Template:\n\t\t\tif !p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// TODO: remove this further divergence from the HTML5 spec.\n\t\t\t//\n\t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\t\tp.generateImpliedEndTags()\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tif n := p.oe[i]; n.Namespace == \"\" && n.DataAtom == a.Template {\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.templateStack.pop()\n\t\t\tp.resetInsertionMode()\n\t\t\treturn true\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n\treturn false\n}\n\n// 12.2.6.4.5.\nfunc inHeadNoscriptIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Style:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Noscript:\n\t\t\t// Don't let the tokenizer go into raw text mode even when a <noscript>\n\t\t\t// tag is in \"in head noscript\" insertion mode.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Noscript, a.Br:\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\treturn inHeadIM(p)\n\t}\n\tp.oe.pop()\n\tif p.top().DataAtom != a.Head {\n\t\tpanic(\"html: the new current node will be a head element.\")\n\t}\n\tp.im = inHeadIM\n\tif p.tok.DataAtom == a.Noscript {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Section 12.2.6.4.6.\nfunc afterHeadIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Body:\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inBodyIM\n\t\t\treturn true\n\t\tcase a.Frameset:\n\t\t\tp.addElement()\n\t\t\tp.im = inFramesetIM\n\t\t\treturn true\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\tp.oe = append(p.oe, p.head)\n\t\t\tdefer p.oe.remove(p.head)\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Head:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Body, a.Html, a.Br:\n\t\t\t// Drop down to creating an implied <body> tag.\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\t}\n\n\tp.parseImpliedToken(StartTagToken, a.Body, a.Body.String())\n\tp.framesetOK = true\n\treturn false\n}\n\n// copyAttributes copies attributes of src not found on dst to dst.\nfunc copyAttributes(dst *Node, src Token) {\n\tif len(src.Attr) == 0 {\n\t\treturn\n\t}\n\tattr := map[string]string{}\n\tfor _, t := range dst.Attr {\n\t\tattr[t.Key] = t.Val\n\t}\n\tfor _, t := range src.Attr {\n\t\tif _, ok := attr[t.Key]; !ok {\n\t\t\tdst.Attr = append(dst.Attr, t)\n\t\t\tattr[t.Key] = t.Val\n\t\t}\n\t}\n}\n\n// Section 12.2.6.4.7.\nfunc inBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\td := p.tok.Data\n\t\tswitch n := p.oe.top(); n.DataAtom {\n\t\tcase a.Pre, a.Listing:\n\t\t\tif n.FirstChild == nil {\n\t\t\t\t// Ignore a newline at the start of a <pre> block.\n\t\t\t\tif d != \"\" && d[0] == '\\r' {\n\t\t\t\t\td = d[1:]\n\t\t\t\t}\n\t\t\t\tif d != \"\" && d[0] == '\\n' {\n\t\t\t\t\td = d[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td = strings.Replace(d, \"\\x00\", \"\", -1)\n\t\tif d == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tp.reconstructActiveFormattingElements()\n\t\tp.addText(d)\n\t\tif p.framesetOK && strings.TrimLeft(d, whitespace) != \"\" {\n\t\t\t// There were non-whitespace characters inserted.\n\t\t\tp.framesetOK = false\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tcopyAttributes(p.oe[0], p.tok)\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Body:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif len(p.oe) >= 2 {\n\t\t\t\tbody := p.oe[1]\n\t\t\t\tif body.Type == ElementNode && body.DataAtom == a.Body {\n\t\t\t\t\tp.framesetOK = false\n\t\t\t\t\tcopyAttributes(body, p.tok)\n\t\t\t\t}\n\t\t\t}\n\t\tcase a.Frameset:\n\t\t\tif !p.framesetOK || len(p.oe) < 2 || p.oe[1].DataAtom != a.Body {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tbody := p.oe[1]\n\t\t\tif body.Parent != nil {\n\t\t\t\tbody.Parent.RemoveChild(body)\n\t\t\t}\n\t\t\tp.oe = p.oe[:1]\n\t\t\tp.addElement()\n\t\t\tp.im = inFramesetIM\n\t\t\treturn true\n\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Center, a.Details, a.Dialog, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Main, a.Menu, a.Nav, a.Ol, a.P, a.Section, a.Summary, a.Ul:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tswitch n := p.top(); n.DataAtom {\n\t\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Pre, a.Listing:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\t// The newline, if any, will be dealt with by the TextToken case.\n\t\t\tp.framesetOK = false\n\t\tcase a.Form:\n\t\t\tif p.form != nil && !p.oe.contains(a.Template) {\n\t\t\t\t// Ignore the token\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\tif !p.oe.contains(a.Template) {\n\t\t\t\tp.form = p.top()\n\t\t\t}\n\t\tcase a.Li:\n\t\t\tp.framesetOK = false\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tnode := p.oe[i]\n\t\t\t\tswitch node.DataAtom {\n\t\t\t\tcase a.Li:\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tcase a.Address, a.Div, a.P:\n\t\t\t\t\tcontinue\n\t\t\t\tdefault:\n\t\t\t\t\tif !isSpecialElement(node) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Dd, a.Dt:\n\t\t\tp.framesetOK = false\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tnode := p.oe[i]\n\t\t\t\tswitch node.DataAtom {\n\t\t\t\tcase a.Dd, a.Dt:\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tcase a.Address, a.Div, a.P:\n\t\t\t\t\tcontinue\n\t\t\t\tdefault:\n\t\t\t\t\tif !isSpecialElement(node) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Plaintext:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\tcase a.Button:\n\t\t\tp.popUntil(defaultScope, a.Button)\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\tcase a.A:\n\t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n\t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {\n\t\t\t\t\tp.inBodyEndTagFormatting(a.A, \"a\")\n\t\t\t\t\tp.oe.remove(n)\n\t\t\t\t\tp.afe.remove(n)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addFormattingElement()\n\t\tcase a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addFormattingElement()\n\t\tcase a.Nobr:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tif p.elementInScope(defaultScope, a.Nobr) {\n\t\t\t\tp.inBodyEndTagFormatting(a.Nobr, \"nobr\")\n\t\t\t\tp.reconstructActiveFormattingElements()\n\t\t\t}\n\t\t\tp.addFormattingElement()\n\t\tcase a.Applet, a.Marquee, a.Object:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.framesetOK = false\n\t\tcase a.Table:\n\t\t\tif !p.quirks {\n\t\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inTableIM\n\t\t\treturn true\n\t\tcase a.Area, a.Br, a.Embed, a.Img, a.Input, a.Keygen, a.Wbr:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\tif p.tok.DataAtom == a.Input {\n\t\t\t\tfor _, t := range p.tok.Attr {\n\t\t\t\t\tif t.Key == \"type\" {\n\t\t\t\t\t\tif strings.ToLower(t.Val) == \"hidden\" {\n\t\t\t\t\t\t\t// Skip setting framesetOK = false\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.framesetOK = false\n\t\tcase a.Param, a.Source, a.Track:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\tcase a.Hr:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\tp.framesetOK = false\n\t\tcase a.Image:\n\t\t\tp.tok.DataAtom = a.Img\n\t\t\tp.tok.Data = a.Img.String()\n\t\t\treturn false\n\t\tcase a.Textarea:\n\t\t\tp.addElement()\n\t\t\tp.setOriginalIM()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = textIM\n\t\tcase a.Xmp:\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.framesetOK = false\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Iframe:\n\t\t\tp.framesetOK = false\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Noembed:\n\t\t\tp.parseGenericRawTextElement()\n\t\tcase a.Noscript:\n\t\t\tif p.scripting {\n\t\t\t\tp.parseGenericRawTextElement()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\t// Don't let the tokenizer go into raw text mode when scripting is disabled.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectIM\n\t\t\treturn true\n\t\tcase a.Optgroup, a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\tcase a.Rb, a.Rtc:\n\t\t\tif p.elementInScope(defaultScope, a.Ruby) {\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Rp, a.Rt:\n\t\t\tif p.elementInScope(defaultScope, a.Ruby) {\n\t\t\t\tp.generateImpliedEndTags(\"rtc\")\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Math, a.Svg:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tif p.tok.DataAtom == a.Math {\n\t\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n\t\t\t} else {\n\t\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n\t\t\t}\n\t\t\tadjustForeignAttributes(p.tok.Attr)\n\t\t\tp.addElement()\n\t\t\tp.top().Namespace = p.tok.Data\n\t\t\tif p.hasSelfClosingToken {\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\tdefault:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Body:\n\t\t\tif p.elementInScope(defaultScope, a.Body) {\n\t\t\t\tp.im = afterBodyIM\n\t\t\t}\n\t\tcase a.Html:\n\t\t\tif p.elementInScope(defaultScope, a.Body) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Body, a.Body.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Button, a.Center, a.Details, a.Dialog, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Listing, a.Main, a.Menu, a.Nav, a.Ol, a.Pre, a.Section, a.Summary, a.Ul:\n\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n\t\tcase a.Form:\n\t\t\tif p.oe.contains(a.Template) {\n\t\t\t\ti := p.indexOfElementInScope(defaultScope, a.Form)\n\t\t\t\tif i == -1 {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t\tif p.oe[i].DataAtom != a.Form {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.popUntil(defaultScope, a.Form)\n\t\t\t} else {\n\t\t\t\tnode := p.form\n\t\t\t\tp.form = nil\n\t\t\t\ti := p.indexOfElementInScope(defaultScope, a.Form)\n\t\t\t\tif node == nil || i == -1 || p.oe[i] != node {\n\t\t\t\t\t// Ignore the token.\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tp.generateImpliedEndTags()\n\t\t\t\tp.oe.remove(node)\n\t\t\t}\n\t\tcase a.P:\n\t\t\tif !p.elementInScope(buttonScope, a.P) {\n\t\t\t\tp.parseImpliedToken(StartTagToken, a.P, a.P.String())\n\t\t\t}\n\t\t\tp.popUntil(buttonScope, a.P)\n\t\tcase a.Li:\n\t\t\tp.popUntil(listItemScope, a.Li)\n\t\tcase a.Dd, a.Dt:\n\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n\t\t\tp.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)\n\t\tcase a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n\t\t\tp.inBodyEndTagFormatting(p.tok.DataAtom, p.tok.Data)\n\t\tcase a.Applet, a.Marquee, a.Object:\n\t\t\tif p.popUntil(defaultScope, p.tok.DataAtom) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t}\n\t\tcase a.Br:\n\t\t\tp.tok.Type = StartTagToken\n\t\t\treturn false\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\tp.inBodyEndTagOther(p.tok.DataAtom, p.tok.Data)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase ErrorToken:\n\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\tif len(p.templateStack) > 0 {\n\t\t\tp.im = inTemplateIM\n\t\t\treturn false\n\t\t}\n\t\tfor _, e := range p.oe {\n\t\t\tswitch e.DataAtom {\n\t\t\tcase a.Dd, a.Dt, a.Li, a.Optgroup, a.Option, a.P, a.Rb, a.Rp, a.Rt, a.Rtc, a.Tbody, a.Td, a.Tfoot, a.Th,\n\t\t\t\ta.Thead, a.Tr, a.Body, a.Html:\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (p *parser) inBodyEndTagFormatting(tagAtom a.Atom, tagName string) {\n\t// This is the \"adoption agency\" algorithm, described at\n\t// https://html.spec.whatwg.org/multipage/syntax.html#adoptionAgency\n\n\t// TODO: this is a fairly literal line-by-line translation of that algorithm.\n\t// Once the code successfully parses the comprehensive test suite, we should\n\t// refactor this code to be more idiomatic.\n\n\t// Steps 1-2\n\tif current := p.oe.top(); current.Data == tagName && p.afe.index(current) == -1 {\n\t\tp.oe.pop()\n\t\treturn\n\t}\n\n\t// Steps 3-5. The outer loop.\n\tfor i := 0; i < 8; i++ {\n\t\t// Step 6. Find the formatting element.\n\t\tvar formattingElement *Node\n\t\tfor j := len(p.afe) - 1; j >= 0; j-- {\n\t\t\tif p.afe[j].Type == scopeMarkerNode {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif p.afe[j].DataAtom == tagAtom {\n\t\t\t\tformattingElement = p.afe[j]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif formattingElement == nil {\n\t\t\tp.inBodyEndTagOther(tagAtom, tagName)\n\t\t\treturn\n\t\t}\n\n\t\t// Step 7. Ignore the tag if formatting element is not in the stack of open elements.\n\t\tfeIndex := p.oe.index(formattingElement)\n\t\tif feIndex == -1 {\n\t\t\tp.afe.remove(formattingElement)\n\t\t\treturn\n\t\t}\n\t\t// Step 8. Ignore the tag if formatting element is not in the scope.\n\t\tif !p.elementInScope(defaultScope, tagAtom) {\n\t\t\t// Ignore the tag.\n\t\t\treturn\n\t\t}\n\n\t\t// Step 9. This step is omitted because it's just a parse error but no need to return.\n\n\t\t// Steps 10-11. Find the furthest block.\n\t\tvar furthestBlock *Node\n\t\tfor _, e := range p.oe[feIndex:] {\n\t\t\tif isSpecialElement(e) {\n\t\t\t\tfurthestBlock = e\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif furthestBlock == nil {\n\t\t\te := p.oe.pop()\n\t\t\tfor e != formattingElement {\n\t\t\t\te = p.oe.pop()\n\t\t\t}\n\t\t\tp.afe.remove(e)\n\t\t\treturn\n\t\t}\n\n\t\t// Steps 12-13. Find the common ancestor and bookmark node.\n\t\tcommonAncestor := p.oe[feIndex-1]\n\t\tbookmark := p.afe.index(formattingElement)\n\n\t\t// Step 14. The inner loop. Find the lastNode to reparent.\n\t\tlastNode := furthestBlock\n\t\tnode := furthestBlock\n\t\tx := p.oe.index(node)\n\t\t// Step 14.1.\n\t\tj := 0\n\t\tfor {\n\t\t\t// Step 14.2.\n\t\t\tj++\n\t\t\t// Step. 14.3.\n\t\t\tx--\n\t\t\tnode = p.oe[x]\n\t\t\t// Step 14.4. Go to the next step if node is formatting element.\n\t\t\tif node == formattingElement {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Step 14.5. Remove node from the list of active formatting elements if\n\t\t\t// inner loop counter is greater than three and node is in the list of\n\t\t\t// active formatting elements.\n\t\t\tif ni := p.afe.index(node); j > 3 && ni > -1 {\n\t\t\t\tp.afe.remove(node)\n\t\t\t\t// If any element of the list of active formatting elements is removed,\n\t\t\t\t// we need to take care whether bookmark should be decremented or not.\n\t\t\t\t// This is because the value of bookmark may exceed the size of the\n\t\t\t\t// list by removing elements from the list.\n\t\t\t\tif ni <= bookmark {\n\t\t\t\t\tbookmark--\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Step 14.6. Continue the next inner loop if node is not in the list of\n\t\t\t// active formatting elements.\n\t\t\tif p.afe.index(node) == -1 {\n\t\t\t\tp.oe.remove(node)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Step 14.7.\n\t\t\tclone := node.clone()\n\t\t\tp.afe[p.afe.index(node)] = clone\n\t\t\tp.oe[p.oe.index(node)] = clone\n\t\t\tnode = clone\n\t\t\t// Step 14.8.\n\t\t\tif lastNode == furthestBlock {\n\t\t\t\tbookmark = p.afe.index(node) + 1\n\t\t\t}\n\t\t\t// Step 14.9.\n\t\t\tif lastNode.Parent != nil {\n\t\t\t\tlastNode.Parent.RemoveChild(lastNode)\n\t\t\t}\n\t\t\tnode.AppendChild(lastNode)\n\t\t\t// Step 14.10.\n\t\t\tlastNode = node\n\t\t}\n\n\t\t// Step 15. Reparent lastNode to the common ancestor,\n\t\t// or for misnested table nodes, to the foster parent.\n\t\tif lastNode.Parent != nil {\n\t\t\tlastNode.Parent.RemoveChild(lastNode)\n\t\t}\n\t\tswitch commonAncestor.DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tp.fosterParent(lastNode)\n\t\tdefault:\n\t\t\tcommonAncestor.AppendChild(lastNode)\n\t\t}\n\n\t\t// Steps 16-18. Reparent nodes from the furthest block's children\n\t\t// to a clone of the formatting element.\n\t\tclone := formattingElement.clone()\n\t\treparentChildren(clone, furthestBlock)\n\t\tfurthestBlock.AppendChild(clone)\n\n\t\t// Step 19. Fix up the list of active formatting elements.\n\t\tif oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {\n\t\t\t// Move the bookmark with the rest of the list.\n\t\t\tbookmark--\n\t\t}\n\t\tp.afe.remove(formattingElement)\n\t\tp.afe.insert(bookmark, clone)\n\n\t\t// Step 20. Fix up the stack of open elements.\n\t\tp.oe.remove(formattingElement)\n\t\tp.oe.insert(p.oe.index(furthestBlock)+1, clone)\n\t}\n}\n\n// inBodyEndTagOther performs the \"any other end tag\" algorithm for inBodyIM.\n// \"Any other end tag\" handling from 12.2.6.5 The rules for parsing tokens in foreign content\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inforeign\nfunc (p *parser) inBodyEndTagOther(tagAtom a.Atom, tagName string) {\n\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t// Two element nodes have the same tag if they have the same Data (a\n\t\t// string-typed field). As an optimization, for common HTML tags, each\n\t\t// Data string is assigned a unique, non-zero DataAtom (a uint32-typed\n\t\t// field), since integer comparison is faster than string comparison.\n\t\t// Uncommon (custom) tags get a zero DataAtom.\n\t\t//\n\t\t// The if condition here is equivalent to (p.oe[i].Data == tagName).\n\t\tif (p.oe[i].DataAtom == tagAtom) &&\n\t\t\t((tagAtom != 0) || (p.oe[i].Data == tagName)) {\n\t\t\tp.oe = p.oe[:i]\n\t\t\tbreak\n\t\t}\n\t\tif isSpecialElement(p.oe[i]) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Section 12.2.6.4.8.\nfunc textIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\tp.oe.pop()\n\tcase TextToken:\n\t\td := p.tok.Data\n\t\tif n := p.oe.top(); n.DataAtom == a.Textarea && n.FirstChild == nil {\n\t\t\t// Ignore a newline at the start of a <textarea> block.\n\t\t\tif d != \"\" && d[0] == '\\r' {\n\t\t\t\td = d[1:]\n\t\t\t}\n\t\t\tif d != \"\" && d[0] == '\\n' {\n\t\t\t\td = d[1:]\n\t\t\t}\n\t\t}\n\t\tif d == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tp.addText(d)\n\t\treturn true\n\tcase EndTagToken:\n\t\tp.oe.pop()\n\t}\n\tp.im = p.originalIM\n\tp.originalIM = nil\n\treturn p.tok.Type == EndTagToken\n}\n\n// Section 12.2.6.4.9.\nfunc inTableIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\", -1)\n\t\tswitch p.oe.top().DataAtom {\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif strings.Trim(p.tok.Data, whitespace) == \"\" {\n\t\t\t\tp.addText(p.tok.Data)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.addElement()\n\t\t\tp.im = inCaptionIM\n\t\t\treturn true\n\t\tcase a.Colgroup:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inColumnGroupIM\n\t\t\treturn true\n\t\tcase a.Col:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Colgroup, a.Colgroup.String())\n\t\t\treturn false\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tp.clearStackToContext(tableScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inTableBodyIM\n\t\t\treturn true\n\t\tcase a.Td, a.Th, a.Tr:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Tbody, a.Tbody.String())\n\t\t\treturn false\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Table) {\n\t\t\t\tp.resetInsertionMode()\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Style, a.Script, a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Input:\n\t\t\tfor _, t := range p.tok.Attr {\n\t\t\t\tif t.Key == \"type\" && strings.ToLower(t.Val) == \"hidden\" {\n\t\t\t\t\tp.addElement()\n\t\t\t\t\tp.oe.pop()\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise drop down to the default action.\n\t\tcase a.Form:\n\t\t\tif p.oe.contains(a.Template) || p.form != nil {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.form = p.oe.pop()\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tswitch p.top().DataAtom {\n\t\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\t\tp.fosterParenting = true\n\t\t\t}\n\t\t\tp.addElement()\n\t\t\tp.fosterParenting = false\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Table) {\n\t\t\t\tp.resetInsertionMode()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\n\tp.fosterParenting = true\n\tdefer func() { p.fosterParenting = false }()\n\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.11.\nfunc inCaptionIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif !p.popUntil(tableScope, a.Caption) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption:\n\t\t\tif p.popUntil(tableScope, a.Caption) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif !p.popUntil(tableScope, a.Caption) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Body, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t}\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.12.\nfunc inColumnGroupIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) < len(p.tok.Data) {\n\t\t\t// Add the initial whitespace to the current node.\n\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n\t\t\tif s == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.tok.Data = s\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Col:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Colgroup:\n\t\t\tif p.oe.top().DataAtom == a.Colgroup {\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Col:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\tif p.oe.top().DataAtom != a.Colgroup {\n\t\treturn true\n\t}\n\tp.oe.pop()\n\tp.im = inTableIM\n\treturn false\n}\n\n// Section 12.2.6.4.13.\nfunc inTableBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tr:\n\t\t\tp.clearStackToContext(tableBodyScope)\n\t\t\tp.addElement()\n\t\t\tp.im = inRowIM\n\t\t\treturn true\n\t\tcase a.Td, a.Th:\n\t\t\tp.parseImpliedToken(StartTagToken, a.Tr, a.Tr.String())\n\t\t\treturn false\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n\t\t\t\tp.im = inTableIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\tp.clearStackToContext(tableBodyScope)\n\t\t\t\tp.oe.pop()\n\t\t\t\tp.im = inTableIM\n\t\t\t}\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n\t\t\t\tp.im = inTableIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th, a.Tr:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\n\treturn inTableIM(p)\n}\n\n// Section 12.2.6.4.14.\nfunc inRowIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Td, a.Th:\n\t\t\tp.clearStackToContext(tableRowScope)\n\t\t\tp.addElement()\n\t\t\tp.afe = append(p.afe, &scopeMarker)\n\t\t\tp.im = inCellIM\n\t\t\treturn true\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Table:\n\t\t\tif p.popUntil(tableScope, a.Tr) {\n\t\t\t\tp.im = inTableBodyIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Tbody, a.Tfoot, a.Thead:\n\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Tr, a.Tr.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn inTableIM(p)\n}\n\n// Section 12.2.6.4.15.\nfunc inCellIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n\t\t\tif p.popUntil(tableScope, a.Td, a.Th) {\n\t\t\t\t// Close the cell and reprocess.\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t\tp.im = inRowIM\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Select:\n\t\t\tp.reconstructActiveFormattingElements()\n\t\t\tp.addElement()\n\t\t\tp.framesetOK = false\n\t\t\tp.im = inSelectInTableIM\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Td, a.Th:\n\t\t\tif !p.popUntil(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.clearActiveFormattingElements()\n\t\t\tp.im = inRowIM\n\t\t\treturn true\n\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n\t\t\tif !p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Close the cell and reprocess.\n\t\t\tif p.popUntil(tableScope, a.Td, a.Th) {\n\t\t\t\tp.clearActiveFormattingElements()\n\t\t\t}\n\t\t\tp.im = inRowIM\n\t\t\treturn false\n\t\t}\n\t}\n\treturn inBodyIM(p)\n}\n\n// Section 12.2.6.4.16.\nfunc inSelectIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tp.addText(strings.Replace(p.tok.Data, \"\\x00\", \"\", -1))\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Optgroup:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tif p.top().DataAtom == a.Optgroup {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\t\tp.addElement()\n\t\tcase a.Select:\n\t\t\tif !p.popUntil(selectScope, a.Select) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\tcase a.Input, a.Keygen, a.Textarea:\n\t\t\tif p.elementInScope(selectScope, a.Select) {\n\t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// In order to properly ignore <textarea>, we need to change the tokenizer mode.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\tcase a.Script, a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Iframe, a.Noembed, a.Noframes, a.Noscript, a.Plaintext, a.Style, a.Title, a.Xmp:\n\t\t\t// Don't let the tokenizer go into raw text mode when there are raw tags\n\t\t\t// to be ignored. These tags should be ignored from the tokenizer\n\t\t\t// properly.\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Option:\n\t\t\tif p.top().DataAtom == a.Option {\n\t\t\t\tp.oe.pop()\n\t\t\t}\n\t\tcase a.Optgroup:\n\t\t\ti := len(p.oe) - 1\n\t\t\tif p.oe[i].DataAtom == a.Option {\n\t\t\t\ti--\n\t\t\t}\n\t\t\tif p.oe[i].DataAtom == a.Optgroup {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t}\n\t\tcase a.Select:\n\t\t\tif !p.popUntil(selectScope, a.Select) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase DoctypeToken:\n\t\t// Ignore the token.\n\t\treturn true\n\tcase ErrorToken:\n\t\treturn inBodyIM(p)\n\t}\n\n\treturn true\n}\n\n// Section 12.2.6.4.17.\nfunc inSelectInTableIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase StartTagToken, EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:\n\t\t\tif p.tok.Type == EndTagToken && !p.elementInScope(tableScope, p.tok.DataAtom) {\n\t\t\t\t// Ignore the token.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// This is like p.popUntil(selectScope, a.Select), but it also\n\t\t\t// matches <math select>, not just <select>. Matching the MathML\n\t\t\t// tag is arguably incorrect (conceptually), but it mimics what\n\t\t\t// Chromium does.\n\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\tif n := p.oe[i]; n.DataAtom == a.Select {\n\t\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.resetInsertionMode()\n\t\t\treturn false\n\t\t}\n\t}\n\treturn inSelectIM(p)\n}\n\n// Section 12.2.6.4.18.\nfunc inTemplateIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken, CommentToken, DoctypeToken:\n\t\treturn inBodyIM(p)\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Template, a.Title:\n\t\t\treturn inHeadIM(p)\n\t\tcase a.Caption, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inTableIM)\n\t\t\tp.im = inTableIM\n\t\t\treturn false\n\t\tcase a.Col:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inColumnGroupIM)\n\t\t\tp.im = inColumnGroupIM\n\t\t\treturn false\n\t\tcase a.Tr:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inTableBodyIM)\n\t\t\tp.im = inTableBodyIM\n\t\t\treturn false\n\t\tcase a.Td, a.Th:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inRowIM)\n\t\t\tp.im = inRowIM\n\t\t\treturn false\n\t\tdefault:\n\t\t\tp.templateStack.pop()\n\t\t\tp.templateStack = append(p.templateStack, inBodyIM)\n\t\t\tp.im = inBodyIM\n\t\t\treturn false\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Template:\n\t\t\treturn inHeadIM(p)\n\t\tdefault:\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\tcase ErrorToken:\n\t\tif !p.oe.contains(a.Template) {\n\t\t\t// Ignore the token.\n\t\t\treturn true\n\t\t}\n\t\t// TODO: remove this divergence from the HTML5 spec.\n\t\t//\n\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668\n\t\tp.generateImpliedEndTags()\n\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\tif n := p.oe[i]; n.Namespace == \"\" && n.DataAtom == a.Template {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tp.clearActiveFormattingElements()\n\t\tp.templateStack.pop()\n\t\tp.resetInsertionMode()\n\t\treturn false\n\t}\n\treturn false\n}\n\n// Section 12.2.6.4.19.\nfunc afterBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\t// Stop parsing.\n\t\treturn true\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\tif !p.fragment {\n\t\t\t\tp.im = afterAfterBodyIM\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\tcase CommentToken:\n\t\t// The comment is attached to the <html> element.\n\t\tif len(p.oe) < 1 || p.oe[0].DataAtom != a.Html {\n\t\t\tpanic(\"html: bad parser state: <html> element not found, in the after-body insertion mode\")\n\t\t}\n\t\tp.oe[0].AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\t}\n\tp.im = inBodyIM\n\treturn false\n}\n\n// Section 12.2.6.4.20.\nfunc inFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.addText(s)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Frameset:\n\t\t\tp.addElement()\n\t\tcase a.Frame:\n\t\t\tp.addElement()\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Frameset:\n\t\t\tif p.oe.top().DataAtom != a.Html {\n\t\t\t\tp.oe.pop()\n\t\t\t\tif p.oe.top().DataAtom != a.Frameset {\n\t\t\t\t\tp.im = afterFramesetIM\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.6.4.21.\nfunc afterFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.addText(s)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase EndTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\tp.im = afterAfterFramesetIM\n\t\t\treturn true\n\t\t}\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.6.4.22.\nfunc afterAfterBodyIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase ErrorToken:\n\t\t// Stop parsing.\n\t\treturn true\n\tcase TextToken:\n\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n\t\tif len(s) == 0 {\n\t\t\t// It was all whitespace.\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tif p.tok.DataAtom == a.Html {\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\t\treturn true\n\tcase DoctypeToken:\n\t\treturn inBodyIM(p)\n\t}\n\tp.im = inBodyIM\n\treturn false\n}\n\n// Section 12.2.6.4.23.\nfunc afterAfterFramesetIM(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase CommentToken:\n\t\tp.doc.AppendChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase TextToken:\n\t\t// Ignore all text but whitespace.\n\t\ts := strings.Map(func(c rune) rune {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n\t\t\t\treturn c\n\t\t\t}\n\t\t\treturn -1\n\t\t}, p.tok.Data)\n\t\tif s != \"\" {\n\t\t\tp.tok.Data = s\n\t\t\treturn inBodyIM(p)\n\t\t}\n\tcase StartTagToken:\n\t\tswitch p.tok.DataAtom {\n\t\tcase a.Html:\n\t\t\treturn inBodyIM(p)\n\t\tcase a.Noframes:\n\t\t\treturn inHeadIM(p)\n\t\t}\n\tcase DoctypeToken:\n\t\treturn inBodyIM(p)\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\nfunc ignoreTheRemainingTokens(p *parser) bool {\n\treturn true\n}\n\nconst whitespaceOrNUL = whitespace + \"\\x00\"\n\n// Section 12.2.6.5\nfunc parseForeignContent(p *parser) bool {\n\tswitch p.tok.Type {\n\tcase TextToken:\n\t\tif p.framesetOK {\n\t\t\tp.framesetOK = strings.TrimLeft(p.tok.Data, whitespaceOrNUL) == \"\"\n\t\t}\n\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\\ufffd\", -1)\n\t\tp.addText(p.tok.Data)\n\tcase CommentToken:\n\t\tp.addChild(&Node{\n\t\t\tType: CommentNode,\n\t\t\tData: p.tok.Data,\n\t\t})\n\tcase StartTagToken:\n\t\tif !p.fragment {\n\t\t\tb := breakout[p.tok.Data]\n\t\t\tif p.tok.DataAtom == a.Font {\n\t\t\tloop:\n\t\t\t\tfor _, attr := range p.tok.Attr {\n\t\t\t\t\tswitch attr.Key {\n\t\t\t\t\tcase \"color\", \"face\", \"size\":\n\t\t\t\t\t\tb = true\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif b {\n\t\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\t\t\tn := p.oe[i]\n\t\t\t\t\tif n.Namespace == \"\" || htmlIntegrationPoint(n) || mathMLTextIntegrationPoint(n) {\n\t\t\t\t\t\tp.oe = p.oe[:i+1]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tcurrent := p.adjustedCurrentNode()\n\t\tswitch current.Namespace {\n\t\tcase \"math\":\n\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n\t\tcase \"svg\":\n\t\t\t// Adjust SVG tag names. The tokenizer lower-cases tag names, but\n\t\t\t// SVG wants e.g. \"foreignObject\" with a capital second \"O\".\n\t\t\tif x := svgTagNameAdjustments[p.tok.Data]; x != \"\" {\n\t\t\t\tp.tok.DataAtom = a.Lookup([]byte(x))\n\t\t\t\tp.tok.Data = x\n\t\t\t}\n\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n\t\tdefault:\n\t\t\tpanic(\"html: bad parser state: unexpected namespace\")\n\t\t}\n\t\tadjustForeignAttributes(p.tok.Attr)\n\t\tnamespace := current.Namespace\n\t\tp.addElement()\n\t\tp.top().Namespace = namespace\n\t\tif namespace != \"\" {\n\t\t\t// Don't let the tokenizer go into raw text mode in foreign content\n\t\t\t// (e.g. in an SVG <title> tag).\n\t\t\tp.tokenizer.NextIsNotRawText()\n\t\t}\n\t\tif p.hasSelfClosingToken {\n\t\t\tp.oe.pop()\n\t\t\tp.acknowledgeSelfClosingTag()\n\t\t}\n\tcase EndTagToken:\n\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n\t\t\tif p.oe[i].Namespace == \"\" {\n\t\t\t\treturn p.im(p)\n\t\t\t}\n\t\t\tif strings.EqualFold(p.oe[i].Data, p.tok.Data) {\n\t\t\t\tp.oe = p.oe[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\t// Ignore the token.\n\t}\n\treturn true\n}\n\n// Section 12.2.4.2.\nfunc (p *parser) adjustedCurrentNode() *Node {\n\tif len(p.oe) == 1 && p.fragment && p.context != nil {\n\t\treturn p.context\n\t}\n\treturn p.oe.top()\n}\n\n// Section 12.2.6.\nfunc (p *parser) inForeignContent() bool {\n\tif len(p.oe) == 0 {\n\t\treturn false\n\t}\n\tn := p.adjustedCurrentNode()\n\tif n.Namespace == \"\" {\n\t\treturn false\n\t}\n\tif mathMLTextIntegrationPoint(n) {\n\t\tif p.tok.Type == StartTagToken && p.tok.DataAtom != a.Mglyph && p.tok.DataAtom != a.Malignmark {\n\t\t\treturn false\n\t\t}\n\t\tif p.tok.Type == TextToken {\n\t\t\treturn false\n\t\t}\n\t}\n\tif n.Namespace == \"math\" && n.DataAtom == a.AnnotationXml && p.tok.Type == StartTagToken && p.tok.DataAtom == a.Svg {\n\t\treturn false\n\t}\n\tif htmlIntegrationPoint(n) && (p.tok.Type == StartTagToken || p.tok.Type == TextToken) {\n\t\treturn false\n\t}\n\tif p.tok.Type == ErrorToken {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// parseImpliedToken parses a token as though it had appeared in the parser's\n// input.\nfunc (p *parser) parseImpliedToken(t TokenType, dataAtom a.Atom, data string) {\n\trealToken, selfClosing := p.tok, p.hasSelfClosingToken\n\tp.tok = Token{\n\t\tType:     t,\n\t\tDataAtom: dataAtom,\n\t\tData:     data,\n\t}\n\tp.hasSelfClosingToken = false\n\tp.parseCurrentToken()\n\tp.tok, p.hasSelfClosingToken = realToken, selfClosing\n}\n\n// parseCurrentToken runs the current token through the parsing routines\n// until it is consumed.\nfunc (p *parser) parseCurrentToken() {\n\tif p.tok.Type == SelfClosingTagToken {\n\t\tp.hasSelfClosingToken = true\n\t\tp.tok.Type = StartTagToken\n\t}\n\n\tconsumed := false\n\tfor !consumed {\n\t\tif p.inForeignContent() {\n\t\t\tconsumed = parseForeignContent(p)\n\t\t} else {\n\t\t\tconsumed = p.im(p)\n\t\t}\n\t}\n\n\tif p.hasSelfClosingToken {\n\t\t// This is a parse error, but ignore it.\n\t\tp.hasSelfClosingToken = false\n\t}\n}\n\nfunc (p *parser) parse() error {\n\t// Iterate until EOF. Any other error will cause an early return.\n\tvar err error\n\tfor err != io.EOF {\n\t\t// CDATA sections are allowed only in foreign content.\n\t\tn := p.oe.top()\n\t\tp.tokenizer.AllowCDATA(n != nil && n.Namespace != \"\")\n\t\t// Read and parse the next token.\n\t\tp.tokenizer.Next()\n\t\tp.tok = p.tokenizer.Token()\n\t\tif p.tok.Type == ErrorToken {\n\t\t\terr = p.tokenizer.Err()\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.parseCurrentToken()\n\t}\n\treturn nil\n}\n\n// Parse returns the parse tree for the HTML from the given Reader.\n//\n// It implements the HTML5 parsing algorithm\n// (https://html.spec.whatwg.org/multipage/syntax.html#tree-construction),\n// which is very complicated. The resultant tree can contain implicitly created\n// nodes that have no explicit <tag> listed in r's data, and nodes' parents can\n// differ from the nesting implied by a naive processing of start and end\n// <tag>s. Conversely, explicit <tag>s in r's data can be silently dropped,\n// with no corresponding node in the resulting tree.\n//\n// The input is assumed to be UTF-8 encoded.\nfunc Parse(r io.Reader) (*Node, error) {\n\treturn ParseWithOptions(r)\n}\n\n// ParseFragment parses a fragment of HTML and returns the nodes that were\n// found. If the fragment is the InnerHTML for an existing element, pass that\n// element in context.\n//\n// It has the same intricacies as Parse.\nfunc ParseFragment(r io.Reader, context *Node) ([]*Node, error) {\n\treturn ParseFragmentWithOptions(r, context)\n}\n\n// ParseOption configures a parser.\ntype ParseOption func(p *parser)\n\n// ParseOptionEnableScripting configures the scripting flag.\n// https://html.spec.whatwg.org/multipage/webappapis.html#enabling-and-disabling-scripting\n//\n// By default, scripting is enabled.\nfunc ParseOptionEnableScripting(enable bool) ParseOption {\n\treturn func(p *parser) {\n\t\tp.scripting = enable\n\t}\n}\n\n// ParseWithOptions is like Parse, with options.\nfunc ParseWithOptions(r io.Reader, opts ...ParseOption) (*Node, error) {\n\tp := &parser{\n\t\ttokenizer: NewTokenizer(r),\n\t\tdoc: &Node{\n\t\t\tType: DocumentNode,\n\t\t},\n\t\tscripting:  true,\n\t\tframesetOK: true,\n\t\tim:         initialIM,\n\t}\n\n\tfor _, f := range opts {\n\t\tf(p)\n\t}\n\n\tif err := p.parse(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p.doc, nil\n}\n\n// ParseFragmentWithOptions is like ParseFragment, with options.\nfunc ParseFragmentWithOptions(r io.Reader, context *Node, opts ...ParseOption) ([]*Node, error) {\n\tcontextTag := \"\"\n\tif context != nil {\n\t\tif context.Type != ElementNode {\n\t\t\treturn nil, errors.New(\"html: ParseFragment of non-element Node\")\n\t\t}\n\t\t// The next check isn't just context.DataAtom.String() == context.Data because\n\t\t// it is valid to pass an element whose tag isn't a known atom. For example,\n\t\t// DataAtom == 0 and Data = \"tagfromthefuture\" is perfectly consistent.\n\t\tif context.DataAtom != a.Lookup([]byte(context.Data)) {\n\t\t\treturn nil, fmt.Errorf(\"html: inconsistent Node: DataAtom=%q, Data=%q\", context.DataAtom, context.Data)\n\t\t}\n\t\tcontextTag = context.DataAtom.String()\n\t}\n\tp := &parser{\n\t\tdoc: &Node{\n\t\t\tType: DocumentNode,\n\t\t},\n\t\tscripting: true,\n\t\tfragment:  true,\n\t\tcontext:   context,\n\t}\n\tif context != nil && context.Namespace != \"\" {\n\t\tp.tokenizer = NewTokenizer(r)\n\t} else {\n\t\tp.tokenizer = NewTokenizerFragment(r, contextTag)\n\t}\n\n\tfor _, f := range opts {\n\t\tf(p)\n\t}\n\n\troot := &Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: a.Html,\n\t\tData:     a.Html.String(),\n\t}\n\tp.doc.AppendChild(root)\n\tp.oe = nodeStack{root}\n\tif context != nil && context.DataAtom == a.Template {\n\t\tp.templateStack = append(p.templateStack, inTemplateIM)\n\t}\n\tp.resetInsertionMode()\n\n\tfor n := context; n != nil; n = n.Parent {\n\t\tif n.Type == ElementNode && n.DataAtom == a.Form {\n\t\t\tp.form = n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := p.parse(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tparent := p.doc\n\tif context != nil {\n\t\tparent = root\n\t}\n\n\tvar result []*Node\n\tfor c := parent.FirstChild; c != nil; {\n\t\tnext := c.NextSibling\n\t\tparent.RemoveChild(c)\n\t\tresult = append(result, c)\n\t\tc = next\n\t}\n\treturn result, nil\n}\n", "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage html\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"golang.org/x/net/html/atom\"\n)\n\ntype testAttrs struct {\n\ttext, want, context string\n\tscripting           bool\n}\n\n// readParseTest reads a single test case from r.\nfunc readParseTest(r *bufio.Reader) (*testAttrs, error) {\n\tta := &testAttrs{scripting: true}\n\tline, err := r.ReadSlice('\\n')\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar b []byte\n\n\t// Read the HTML.\n\tif string(line) != \"#data\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#data\\n\"`, line)\n\t}\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif line[0] == '#' {\n\t\t\tbreak\n\t\t}\n\t\tb = append(b, line...)\n\t}\n\tta.text = strings.TrimSuffix(string(b), \"\\n\")\n\tb = b[:0]\n\n\t// Skip the error list.\n\tif string(line) != \"#errors\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#errors\\n\"`, line)\n\t}\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif line[0] == '#' {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Skip the new-errors list.\n\tif string(line) == \"#new-errors\\n\" {\n\t\tfor {\n\t\t\tline, err = r.ReadSlice('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif line[0] == '#' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif ls := string(line); strings.HasPrefix(ls, \"#script-\") {\n\t\tswitch {\n\t\tcase strings.HasSuffix(ls, \"-on\\n\"):\n\t\t\tta.scripting = true\n\t\tcase strings.HasSuffix(ls, \"-off\\n\"):\n\t\t\tta.scripting = false\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(`got %q, want \"#script-on\" or \"#script-off\"`, line)\n\t\t}\n\t\tfor {\n\t\t\tline, err = r.ReadSlice('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif line[0] == '#' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif string(line) == \"#document-fragment\\n\" {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tta.context = strings.TrimSpace(string(line))\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Read the dump of what the parse tree should be.\n\tif string(line) != \"#document\\n\" {\n\t\treturn nil, fmt.Errorf(`got %q want \"#document\\n\"`, line)\n\t}\n\tinQuote := false\n\tfor {\n\t\tline, err = r.ReadSlice('\\n')\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn nil, err\n\t\t}\n\t\ttrimmed := bytes.Trim(line, \"| \\n\")\n\t\tif len(trimmed) > 0 {\n\t\t\tif line[0] == '|' && trimmed[0] == '\"' {\n\t\t\t\tinQuote = true\n\t\t\t}\n\t\t\tif trimmed[len(trimmed)-1] == '\"' && !(line[0] == '|' && len(trimmed) == 1) {\n\t\t\t\tinQuote = false\n\t\t\t}\n\t\t}\n\t\tif len(line) == 0 || len(line) == 1 && line[0] == '\\n' && !inQuote {\n\t\t\tbreak\n\t\t}\n\t\tb = append(b, line...)\n\t}\n\tta.want = string(b)\n\treturn ta, nil\n}\n\nfunc dumpIndent(w io.Writer, level int) {\n\tio.WriteString(w, \"| \")\n\tfor i := 0; i < level; i++ {\n\t\tio.WriteString(w, \"  \")\n\t}\n}\n\ntype sortedAttributes []Attribute\n\nfunc (a sortedAttributes) Len() int {\n\treturn len(a)\n}\n\nfunc (a sortedAttributes) Less(i, j int) bool {\n\tif a[i].Namespace != a[j].Namespace {\n\t\treturn a[i].Namespace < a[j].Namespace\n\t}\n\treturn a[i].Key < a[j].Key\n}\n\nfunc (a sortedAttributes) Swap(i, j int) {\n\ta[i], a[j] = a[j], a[i]\n}\n\nfunc dumpLevel(w io.Writer, n *Node, level int) error {\n\tdumpIndent(w, level)\n\tlevel++\n\tswitch n.Type {\n\tcase ErrorNode:\n\t\treturn errors.New(\"unexpected ErrorNode\")\n\tcase DocumentNode:\n\t\treturn errors.New(\"unexpected DocumentNode\")\n\tcase ElementNode:\n\t\tif n.Namespace != \"\" {\n\t\t\tfmt.Fprintf(w, \"<%s %s>\", n.Namespace, n.Data)\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n\t\t}\n\t\tattr := sortedAttributes(n.Attr)\n\t\tsort.Sort(attr)\n\t\tfor _, a := range attr {\n\t\t\tio.WriteString(w, \"\\n\")\n\t\t\tdumpIndent(w, level)\n\t\t\tif a.Namespace != \"\" {\n\t\t\t\tfmt.Fprintf(w, `%s %s=\"%s\"`, a.Namespace, a.Key, a.Val)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n\t\t\t}\n\t\t}\n\t\tif n.Namespace == \"\" && n.DataAtom == atom.Template {\n\t\t\tio.WriteString(w, \"\\n\")\n\t\t\tdumpIndent(w, level)\n\t\t\tlevel++\n\t\t\tio.WriteString(w, \"content\")\n\t\t}\n\tcase TextNode:\n\t\tfmt.Fprintf(w, `\"%s\"`, n.Data)\n\tcase CommentNode:\n\t\tfmt.Fprintf(w, \"<!-- %s -->\", n.Data)\n\tcase DoctypeNode:\n\t\tfmt.Fprintf(w, \"<!DOCTYPE %s\", n.Data)\n\t\tif n.Attr != nil {\n\t\t\tvar p, s string\n\t\t\tfor _, a := range n.Attr {\n\t\t\t\tswitch a.Key {\n\t\t\t\tcase \"public\":\n\t\t\t\t\tp = a.Val\n\t\t\t\tcase \"system\":\n\t\t\t\t\ts = a.Val\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p != \"\" || s != \"\" {\n\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, p)\n\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, s)\n\t\t\t}\n\t\t}\n\t\tio.WriteString(w, \">\")\n\tcase scopeMarkerNode:\n\t\treturn errors.New(\"unexpected scopeMarkerNode\")\n\tdefault:\n\t\treturn errors.New(\"unknown node type\")\n\t}\n\tio.WriteString(w, \"\\n\")\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif err := dumpLevel(w, c, level); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc dump(n *Node) (string, error) {\n\tif n == nil || n.FirstChild == nil {\n\t\treturn \"\", nil\n\t}\n\tvar b bytes.Buffer\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif err := dumpLevel(&b, c, 0); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn b.String(), nil\n}\n\nvar testDataDirs = []string{\"testdata/webkit/\", \"testdata/go/\"}\n\nfunc TestParser(t *testing.T) {\n\tfor _, testDataDir := range testDataDirs {\n\t\ttestFiles, err := filepath.Glob(testDataDir + \"*.dat\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, tf := range testFiles {\n\t\t\tf, err := os.Open(tf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tr := bufio.NewReader(f)\n\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tta, err := readParseTest(r)\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif parseTestBlacklist[ta.text] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\terr = testParseCase(ta.text, ta.want, ta.context, ParseOptionEnableScripting(ta.scripting))\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"%s test #%d %q, %s\", tf, i, ta.text, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue 16318\nfunc TestParserWithoutScripting(t *testing.T) {\n\ttext := `<noscript><img src='https://golang.org/doc/gopher/frontpage.png' /></noscript><p><img src='https://golang.org/doc/gopher/doc.png' /></p>`\n\twant := `| <html>\n|   <head>\n|     <noscript>\n|   <body>\n|     <img>\n|       src=\"https://golang.org/doc/gopher/frontpage.png\"\n|     <p>\n|       <img>\n|         src=\"https://golang.org/doc/gopher/doc.png\"\n`\n\n\tif err := testParseCase(text, want, \"\", ParseOptionEnableScripting(false)); err != nil {\n\t\tt.Errorf(\"test with scripting is disabled, %q, %s\", text, err)\n\t}\n}\n\n// testParseCase tests one test case from the test files. If the test does not\n// pass, it returns an error that explains the failure.\n// text is the HTML to be parsed, want is a dump of the correct parse tree,\n// and context is the name of the context node, if any.\nfunc testParseCase(text, want, context string, opts ...ParseOption) (err error) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tswitch e := x.(type) {\n\t\t\tcase error:\n\t\t\t\terr = e\n\t\t\tdefault:\n\t\t\t\terr = fmt.Errorf(\"%v\", e)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar doc *Node\n\tif context == \"\" {\n\t\tdoc, err = ParseWithOptions(strings.NewReader(text), opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tnamespace := \"\"\n\t\tif i := strings.IndexByte(context, ' '); i >= 0 {\n\t\t\tnamespace, context = context[:i], context[i+1:]\n\t\t}\n\t\tcontextNode := &Node{\n\t\t\tData:      context,\n\t\t\tDataAtom:  atom.Lookup([]byte(context)),\n\t\t\tNamespace: namespace,\n\t\t\tType:      ElementNode,\n\t\t}\n\t\tnodes, err := ParseFragmentWithOptions(strings.NewReader(text), contextNode, opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdoc = &Node{\n\t\t\tType: DocumentNode,\n\t\t}\n\t\tfor _, n := range nodes {\n\t\t\tdoc.AppendChild(n)\n\t\t}\n\t}\n\n\tif err := checkTreeConsistency(doc); err != nil {\n\t\treturn err\n\t}\n\n\tgot, err := dump(doc)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Compare the parsed tree to the #document section.\n\tif got != want {\n\t\treturn fmt.Errorf(\"got vs want:\\n----\\n%s----\\n%s----\", got, want)\n\t}\n\n\tif renderTestBlacklist[text] || context != \"\" {\n\t\treturn nil\n\t}\n\n\t// Check that rendering and re-parsing results in an identical tree.\n\tpr, pw := io.Pipe()\n\tgo func() {\n\t\tpw.CloseWithError(Render(pw, doc))\n\t}()\n\tdoc1, err := ParseWithOptions(pr, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgot1, err := dump(doc1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif got != got1 {\n\t\treturn fmt.Errorf(\"got vs got1:\\n----\\n%s----\\n%s----\", got, got1)\n\t}\n\n\treturn nil\n}\n\n// Some test inputs are simply skipped - we would otherwise fail the test. We\n// blacklist such inputs from the parse test.\nvar parseTestBlacklist = map[string]bool{\n\t// See the a.Template TODO in inHeadIM.\n\t`<math><template><mo><template>`:                                     true,\n\t`<template><svg><foo><template><foreignObject><div></template><div>`: true,\n}\n\n// Some test input result in parse trees are not 'well-formed' despite\n// following the HTML5 recovery algorithms. Rendering and re-parsing such a\n// tree will not result in an exact clone of that tree. We blacklist such\n// inputs from the render test.\nvar renderTestBlacklist = map[string]bool{\n\t// The second <a> will be reparented to the first <table>'s parent. This\n\t// results in an <a> whose parent is an <a>, which is not 'well-formed'.\n\t`<a><table><td><a><table></table><a></tr><a></table><b>X</b>C<a>Y`: true,\n\t// The same thing with a <p>:\n\t`<p><table></p>`: true,\n\t// More cases of <a> being reparented:\n\t`<a href=\"blah\">aba<table><a href=\"foo\">br<tr><td></td></tr>x</table>aoe`: true,\n\t`<a><table><a></table><p><a><div><a>`:                                     true,\n\t`<a><table><td><a><table></table><a></tr><a></table><a>`:                  true,\n\t`<template><a><table><a>`:                                                 true,\n\t// A similar reparenting situation involving <nobr>:\n\t`<!DOCTYPE html><body><b><nobr>1<table><nobr></b><i><nobr>2<nobr></i>3`: true,\n\t// A <plaintext> element is reparented, putting it before a table.\n\t// A <plaintext> element can't have anything after it in HTML.\n\t`<table><plaintext><td>`:                                   true,\n\t`<!doctype html><table><plaintext></plaintext>`:            true,\n\t`<!doctype html><table><tbody><plaintext></plaintext>`:     true,\n\t`<!doctype html><table><tbody><tr><plaintext></plaintext>`: true,\n\t// A form inside a table inside a form doesn't work either.\n\t`<!doctype html><form><table></form><form></table></form>`: true,\n\t// A script that ends at EOF may escape its own closing tag when rendered.\n\t`<!doctype html><script><!--<script `:          true,\n\t`<!doctype html><script><!--<script <`:         true,\n\t`<!doctype html><script><!--<script <a`:        true,\n\t`<!doctype html><script><!--<script </`:        true,\n\t`<!doctype html><script><!--<script </s`:       true,\n\t`<!doctype html><script><!--<script </script`:  true,\n\t`<!doctype html><script><!--<script </scripta`: true,\n\t`<!doctype html><script><!--<script -`:         true,\n\t`<!doctype html><script><!--<script -a`:        true,\n\t`<!doctype html><script><!--<script -<`:        true,\n\t`<!doctype html><script><!--<script --`:        true,\n\t`<!doctype html><script><!--<script --a`:       true,\n\t`<!doctype html><script><!--<script --<`:       true,\n\t`<script><!--<script `:                         true,\n\t`<script><!--<script <a`:                       true,\n\t`<script><!--<script </script`:                 true,\n\t`<script><!--<script </scripta`:                true,\n\t`<script><!--<script -`:                        true,\n\t`<script><!--<script -a`:                       true,\n\t`<script><!--<script --`:                       true,\n\t`<script><!--<script --a`:                      true,\n\t`<script><!--<script <`:                        true,\n\t`<script><!--<script </`:                       true,\n\t`<script><!--<script </s`:                      true,\n\t// Reconstructing the active formatting elements results in a <plaintext>\n\t// element that contains an <a> element.\n\t`<!doctype html><p><a><plaintext>b`:                       true,\n\t`<table><math><select><mi><select></table>`:               true,\n\t`<!doctype html><table><colgroup><plaintext></plaintext>`: true,\n\t`<!doctype html><svg><plaintext>a</plaintext>b`:           true,\n}\n\nfunc TestNodeConsistency(t *testing.T) {\n\t// inconsistentNode is a Node whose DataAtom and Data do not agree.\n\tinconsistentNode := &Node{\n\t\tType:     ElementNode,\n\t\tDataAtom: atom.Frameset,\n\t\tData:     \"table\",\n\t}\n\tif _, err := ParseFragment(strings.NewReader(\"<p>hello</p>\"), inconsistentNode); err == nil {\n\t\tt.Errorf(\"got nil error, want non-nil\")\n\t}\n}\n\nfunc TestParseFragmentWithNilContext(t *testing.T) {\n\t// This shouldn't panic.\n\tParseFragment(strings.NewReader(\"<p>hello</p>\"), nil)\n}\n\nfunc TestParseFragmentForeignContentTemplates(t *testing.T) {\n\tsrcs := []string{\n\t\t\"<math><html><template><mn><template></template></template>\",\n\t\t\"<math><math><head><mi><template>\",\n\t}\n\tfor _, src := range srcs {\n\t\t// The next line shouldn't infinite-loop.\n\t\tParseFragment(strings.NewReader(src), nil)\n\t}\n}\n\nfunc BenchmarkParser(b *testing.B) {\n\tbuf, err := ioutil.ReadFile(\"testdata/go1.html\")\n\tif err != nil {\n\t\tb.Fatalf(\"could not read testdata/go1.html: %v\", err)\n\t}\n\tb.SetBytes(int64(len(buf)))\n\truntime.GC()\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tParse(bytes.NewBuffer(buf))\n\t}\n}\n"], "filenames": ["html/parse.go", "html/parse_test.go"], "buggy_code_start_loc": [665, 269], "buggy_code_end_loc": [2129, 456], "fixing_code_start_loc": [666, 270], "fixing_code_end_loc": [2152, 479], "type": "CWE-835", "message": "golang.org/x/net before v0.0.0-20210520170846-37e1c6afe023 allows attackers to cause a denial of service (infinite loop) via crafted ParseFragment input.", "other": {"cve": {"id": "CVE-2021-33194", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-26T15:15:08.217", "lastModified": "2022-06-03T19:29:37.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "golang.org/x/net before v0.0.0-20210520170846-37e1c6afe023 allows attackers to cause a denial of service (infinite loop) via crafted ParseFragment input."}, {"lang": "es", "value": "golang.org/x/net antes de v0.0.0-20210520170846-37e1c6afe023 permite a los atacantes provocar una denegaci\u00f3n de servicio (bucle infinito) a trav\u00e9s de una entrada ParseFragment manipulada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.15.12", "matchCriteriaId": "17BEA7D1-9189-4A8D-AF67-807332ECC57A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.16.0", "versionEndIncluding": "1.16.4", "matchCriteriaId": "B885E59F-8343-4978-B580-707971E75689"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/golang/net/commit/37e1c6afe02340126705deced573a85ab75209d7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/g/golang-announce/c/wPunbCPkWUg", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4CHKSFMHZVOBCZSSVRE3UEYNKARTBMTM/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/net/commit/37e1c6afe02340126705deced573a85ab75209d7"}}