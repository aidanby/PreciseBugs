{"buggy_code": ["cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)\nproject(pichi LANGUAGES CXX)\n\noption(BUILD_SERVER \"Build pichi application\" ON)\noption(BUILD_TEST \"Build unit test cases\" ON)\noption(STATIC_LINK \"Static linking\" ON)\noption(INSTALL_DEVEL \"Install files for development\" OFF)\noption(ENABLE_TLS \"Enable TLS adapters\" ON)\n\nset(PICHI_LIBRARY pichi_lib)\nset(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)\n\ninclude(ProcessOptions)\n\nfind_package(Boost 1.67.0 REQUIRED COMPONENTS ${BOOST_COMPONENTS} REQUIRED)\nfind_package(MbedTLS 2.7.0 REQUIRED)\nfind_package(Sodium 1.0.12 REQUIRED)\nfind_package(MaxmindDB 1.3.0 REQUIRED)\nfind_package(Rapidjson 1.1.0 REQUIRED)\nfind_package(Threads REQUIRED)\nif (ENABLE_TLS)\n  find_package(OpenSSL REQUIRED)\n  include_directories(${OPENSSL_INCLUDE_DIR})\n  link_libraries(${OPENSSL_LIBRARIES} ${CMAKE_DL_LIBS})\nendif ()\n\ninclude(Configure)\n\ninclude_directories(\n  ${CMAKE_SOURCE_DIR}/include\n  ${CMAKE_BINARY_DIR}/include\n  ${Boost_INCLUDE_DIRS}\n  ${MbedTLS_INCLUDE_DIRS}\n  ${Sodium_INCLUDE_DIRS}\n  ${MaxmindDB_INCLUDE_DIRS}\n  ${Rapidjson_INCLUDE_DIRS}\n)\n\nlink_libraries(\n  ${MbedTLS_LIBRARIES}\n  ${Sodium_LIBRARIES}\n  ${MaxmindDB_LIBRARIES}\n  ${CMAKE_THREAD_LIBS_INIT}\n)\n\nadd_subdirectory(src)\n\nlink_libraries(${PICHI_LIBRARY})\n\nif (BUILD_SERVER)\n  add_subdirectory(server)\nendif ()\n\nif (BUILD_TEST)\n  enable_testing()\n  add_subdirectory(test)\nendif ()\n", "#include <pichi/config.hpp>\n// Include config.hpp first\n#include <array>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/read.hpp>\n#include <boost/asio/spawn2.hpp>\n#include <boost/asio/write.hpp>\n#include <pichi/api/balancer.hpp>\n#include <pichi/api/vos.hpp>\n#include <pichi/asserts.hpp>\n#include <pichi/common.hpp>\n#include <pichi/crypto/key.hpp>\n#include <pichi/net/adapter.hpp>\n#include <pichi/net/asio.hpp>\n#include <pichi/net/common.hpp>\n#include <pichi/net/direct.hpp>\n#include <pichi/net/helpers.hpp>\n#include <pichi/net/http.hpp>\n#include <pichi/net/reject.hpp>\n#include <pichi/net/socks5.hpp>\n#include <pichi/net/ssaead.hpp>\n#include <pichi/net/ssstream.hpp>\n#include <pichi/net/tunnel.hpp>\n#include <pichi/test/socket.hpp>\n\n#ifdef ENABLE_TLS\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#endif // ENABLE_TLS\n\nusing namespace std;\nnamespace asio = boost::asio;\nnamespace ip = asio::ip;\nnamespace ssl = asio::ssl;\nnamespace sys = boost::system;\nusing ip::tcp;\nusing pichi::crypto::CryptoMethod;\nusing TcpSocket = tcp::socket;\nusing TlsSocket = ssl::stream<TcpSocket>;\n\nnamespace pichi::net {\n\n#ifdef ENABLE_TLS\nstatic auto createTlsContext(api::IngressVO const& vo)\n{\n  auto ctx = ssl::context{ssl::context::tls_server};\n  ctx.use_certificate_chain_file(*vo.certFile_);\n  ctx.use_private_key_file(*vo.keyFile_, ssl::context::pem);\n  return ctx;\n}\n\nstatic auto createTlsContext(api::EgressVO const& vo)\n{\n  auto ctx = ssl::context{ssl::context::tls_client};\n  if (*vo.insecure_) {\n    ctx.set_verify_mode(ssl::context::verify_none);\n  }\n  else {\n    ctx.set_verify_mode(ssl::context::verify_peer);\n    ctx.set_default_verify_paths();\n    if (vo.caFile_.has_value()) ctx.load_verify_file(*vo.caFile_);\n  }\n  return ctx;\n}\n#endif // ENABLE_TLS\n\ntemplate <typename Socket, typename Yield>\nvoid connect(Endpoint const& endpoint, Socket& s, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef ENABLE_TLS\n  if constexpr (IsSslStreamV<Socket>) {\n    connect(endpoint, s.next_layer(), yield);\n    s.async_handshake(ssl::stream_base::handshake_type::client, yield);\n  }\n  else\n#endif // ENABLE_TLS\n#ifdef BUILD_TEST\n      if constexpr (is_same_v<Socket, pichi::test::Stream>) {\n    s.connect();\n  }\n  else\n#endif // BUILD_TEST\n    asio::async_connect(s,\n                        tcp::resolver{s.get_executor()\n#ifndef RESOLVER_CONSTRUCTED_FROM_EXECUTOR\n                                          .context()\n#endif // RESOLVER_CONSTRUCTED_FROM_EXECUTOR\n                        }\n                            .async_resolve(endpoint.host_, endpoint.port_, yield),\n                        yield);\n}\n\ntemplate <typename Socket, typename Yield>\nvoid read(Socket& s, MutableBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    asio::read(s, asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    asio::async_read(s, asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield>\nsize_t readSome(Socket& s, MutableBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    return s.read_some(asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    return s.async_read_some(asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield>\nvoid write(Socket& s, ConstBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    asio::write(s, asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    asio::async_write(s, asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield> void close(Socket& s, Yield yield)\n{\n  // This function is supposed to be 'noexcept' because it's always invoked in the desturctors.\n  // TODO log it\n  auto ec = sys::error_code{};\n  if constexpr (IsSslStreamV<Socket>) {\n    s.async_shutdown(yield[ec]);\n    close(s.next_layer(), yield);\n  }\n  else {\n    suppressC4100(yield);\n    s.close(ec);\n  }\n}\n\ntemplate <typename Socket> bool isOpen(Socket const& s)\n{\n  if constexpr (IsSslStreamV<Socket>) {\n    return isOpen(s.next_layer());\n  }\n  else {\n    return s.is_open();\n  }\n}\n\ntemplate <typename Socket> unique_ptr<Ingress> makeIngress(api::IngressHolder& holder, Socket&& s)\n{\n  auto container = array<uint8_t, 1024>{0};\n  auto psk = MutableBuffer<uint8_t>{container};\n  auto& vo = holder.vo_;\n  switch (vo.type_) {\n  case AdapterType::HTTP:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<HttpIngress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<HttpIngress<TcpSocket>>(vo.credentials_, forward<Socket>(s));\n  case AdapterType::SOCKS5:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<Socks5Ingress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<Socks5Ingress<TcpSocket>>(vo.credentials_, forward<Socket>(s));\n  case AdapterType::SS:\n    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};\n    switch (*vo.method_) {\n    case CryptoMethod::RC4_MD5:\n      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::BF_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_128_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_192_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_256_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::SALSA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20_IETF:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, Socket>>(psk,\n                                                                               forward<Socket>(s));\n    case CryptoMethod::AES_128_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_192_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_256_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::XCHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, Socket>>(\n          psk, forward<Socket>(s));\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  case AdapterType::TUNNEL:\n    return make_unique<TunnelIngress<api::IngressIterator, Socket>>(*holder.balancer_,\n                                                                    forward<Socket>(s));\n  default:\n    fail(PichiError::BAD_PROTO);\n  }\n}\n\nunique_ptr<Egress> makeEgress(api::EgressVO const& vo, asio::io_context& io)\n{\n  auto container = array<uint8_t, 1024>{0};\n  auto psk = MutableBuffer<uint8_t>{container};\n  switch (vo.type_) {\n  case AdapterType::HTTP:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<HttpEgress<TlsSocket>>(vo.credential_, io, ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<HttpEgress<TcpSocket>>(vo.credential_, io);\n  case AdapterType::SOCKS5:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<Socks5Egress<ssl::stream<tcp::socket>>>(vo.credential_, io, ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<Socks5Egress<tcp::socket>>(vo.credential_, io);\n  case AdapterType::DIRECT:\n    return make_unique<DirectAdapter>(io);\n  case AdapterType::REJECT:\n    switch (*vo.mode_) {\n    case api::DelayMode::RANDOM:\n      return make_unique<RejectEgress>(io);\n    case api::DelayMode::FIXED:\n      return make_unique<RejectEgress>(io, *vo.delay_);\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  case AdapterType::SS:\n    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};\n    switch (*vo.method_) {\n    case CryptoMethod::RC4_MD5:\n      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, TcpSocket>>(psk, io);\n    case CryptoMethod::BF_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, TcpSocket>>(psk, io);\n    case CryptoMethod::SALSA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20_IETF:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);\n    case CryptoMethod::XCHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  default:\n    fail(PichiError::BAD_PROTO);\n  }\n}\n\nusing Yield = asio::yield_context;\n\ntemplate void connect<>(Endpoint const&, TcpSocket&, Yield);\ntemplate void read<>(TcpSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(TcpSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(TcpSocket&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(TcpSocket&, Yield);\ntemplate bool isOpen<>(TcpSocket const&);\n\n#ifdef ENABLE_TLS\ntemplate void connect<>(Endpoint const&, TlsSocket&, Yield);\ntemplate void read<>(TlsSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(TlsSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(TlsSocket&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(TlsSocket&, Yield);\ntemplate bool isOpen<>(TlsSocket const&);\n#endif // ENABLE_TLS\n\n#ifdef BUILD_TEST\ntemplate void connect<>(Endpoint const&, pichi::test::Stream&, Yield);\ntemplate void read<>(pichi::test::Stream&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(pichi::test::Stream&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(pichi::test::Stream&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(pichi::test::Stream&, Yield);\ntemplate bool isOpen<>(pichi::test::Stream const&);\n#endif // BUILD_TEST\n\ntemplate unique_ptr<Ingress> makeIngress<>(api::IngressHolder&, TcpSocket&&);\n\n} // namespace pichi::net\n"], "fixing_code": ["cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)\nproject(pichi LANGUAGES CXX)\n\noption(BUILD_SERVER \"Build pichi application\" ON)\noption(BUILD_TEST \"Build unit test cases\" ON)\noption(STATIC_LINK \"Static linking\" ON)\noption(INSTALL_DEVEL \"Install files for development\" OFF)\noption(ENABLE_TLS \"Enable TLS adapters\" ON)\n\nset(PICHI_LIBRARY pichi_lib)\nset(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)\n\ninclude(ProcessOptions)\n\nfind_package(Boost 1.67.0 REQUIRED COMPONENTS ${BOOST_COMPONENTS} REQUIRED)\nfind_package(MbedTLS 2.7.0 REQUIRED)\nfind_package(Sodium 1.0.12 REQUIRED)\nfind_package(MaxmindDB 1.3.0 REQUIRED)\nfind_package(Rapidjson 1.1.0 REQUIRED)\nfind_package(Threads REQUIRED)\nif (ENABLE_TLS)\n  find_package(OpenSSL REQUIRED)\n  include_directories(${OPENSSL_INCLUDE_DIR})\n  link_libraries(${OPENSSL_LIBRARIES} ${CMAKE_DL_LIBS})\n  if (WIN32 AND STATIC_LINK)\n    link_libraries(crypt32)\n  endif ()\nendif ()\n\ninclude(Configure)\n\ninclude_directories(\n  ${CMAKE_SOURCE_DIR}/include\n  ${CMAKE_BINARY_DIR}/include\n  ${Boost_INCLUDE_DIRS}\n  ${MbedTLS_INCLUDE_DIRS}\n  ${Sodium_INCLUDE_DIRS}\n  ${MaxmindDB_INCLUDE_DIRS}\n  ${Rapidjson_INCLUDE_DIRS}\n)\n\nlink_libraries(\n  ${MbedTLS_LIBRARIES}\n  ${Sodium_LIBRARIES}\n  ${MaxmindDB_LIBRARIES}\n  ${CMAKE_THREAD_LIBS_INIT}\n)\n\nadd_subdirectory(src)\n\nlink_libraries(${PICHI_LIBRARY})\n\nif (BUILD_SERVER)\n  add_subdirectory(server)\nendif ()\n\nif (BUILD_TEST)\n  enable_testing()\n  add_subdirectory(test)\nendif ()\n", "#include <pichi/config.hpp>\n// Include config.hpp first\n#include <array>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/read.hpp>\n#include <boost/asio/spawn2.hpp>\n#include <boost/asio/write.hpp>\n#include <pichi/api/balancer.hpp>\n#include <pichi/api/vos.hpp>\n#include <pichi/asserts.hpp>\n#include <pichi/common.hpp>\n#include <pichi/crypto/key.hpp>\n#include <pichi/net/adapter.hpp>\n#include <pichi/net/asio.hpp>\n#include <pichi/net/common.hpp>\n#include <pichi/net/direct.hpp>\n#include <pichi/net/helpers.hpp>\n#include <pichi/net/http.hpp>\n#include <pichi/net/reject.hpp>\n#include <pichi/net/socks5.hpp>\n#include <pichi/net/ssaead.hpp>\n#include <pichi/net/ssstream.hpp>\n#include <pichi/net/tunnel.hpp>\n#include <pichi/test/socket.hpp>\n\n#ifdef ENABLE_TLS\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/rfc2818_verification.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#endif // ENABLE_TLS\n\nusing namespace std;\nnamespace asio = boost::asio;\nnamespace ip = asio::ip;\nnamespace ssl = asio::ssl;\nnamespace sys = boost::system;\nusing ip::tcp;\nusing pichi::crypto::CryptoMethod;\nusing TcpSocket = tcp::socket;\nusing TlsSocket = ssl::stream<TcpSocket>;\n\nnamespace pichi::net {\n\n#ifdef ENABLE_TLS\nstatic auto createTlsContext(api::IngressVO const& vo)\n{\n  auto ctx = ssl::context{ssl::context::tls_server};\n  ctx.use_certificate_chain_file(*vo.certFile_);\n  ctx.use_private_key_file(*vo.keyFile_, ssl::context::pem);\n  return ctx;\n}\n\nstatic auto createTlsContext(api::EgressVO const& vo)\n{\n  auto ctx = ssl::context{ssl::context::tls_client};\n  if (*vo.insecure_) {\n    ctx.set_verify_mode(ssl::context::verify_none);\n    return ctx;\n  }\n\n  ctx.set_verify_mode(ssl::context::verify_peer);\n  if (vo.caFile_.has_value())\n    ctx.load_verify_file(*vo.caFile_);\n  else {\n    ctx.set_default_verify_paths();\n    ctx.set_verify_callback(ssl::rfc2818_verification{*vo.host_});\n  }\n  return ctx;\n}\n#endif // ENABLE_TLS\n\ntemplate <typename Socket, typename Yield>\nvoid connect(Endpoint const& endpoint, Socket& s, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef ENABLE_TLS\n  if constexpr (IsSslStreamV<Socket>) {\n    connect(endpoint, s.next_layer(), yield);\n    s.async_handshake(ssl::stream_base::handshake_type::client, yield);\n  }\n  else\n#endif // ENABLE_TLS\n#ifdef BUILD_TEST\n      if constexpr (is_same_v<Socket, pichi::test::Stream>) {\n    s.connect();\n  }\n  else\n#endif // BUILD_TEST\n    asio::async_connect(s,\n                        tcp::resolver{s.get_executor()\n#ifndef RESOLVER_CONSTRUCTED_FROM_EXECUTOR\n                                          .context()\n#endif // RESOLVER_CONSTRUCTED_FROM_EXECUTOR\n                        }\n                            .async_resolve(endpoint.host_, endpoint.port_, yield),\n                        yield);\n}\n\ntemplate <typename Socket, typename Yield>\nvoid read(Socket& s, MutableBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    asio::read(s, asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    asio::async_read(s, asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield>\nsize_t readSome(Socket& s, MutableBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    return s.read_some(asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    return s.async_read_some(asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield>\nvoid write(Socket& s, ConstBuffer<uint8_t> buf, Yield yield)\n{\n  suppressC4100(yield);\n#ifdef BUILD_TEST\n  if constexpr (is_same_v<Socket, pichi::test::Stream>)\n    asio::write(s, asio::buffer(buf));\n  else\n#endif // BUILD_TEST\n    asio::async_write(s, asio::buffer(buf), yield);\n}\n\ntemplate <typename Socket, typename Yield> void close(Socket& s, Yield yield)\n{\n  // This function is supposed to be 'noexcept' because it's always invoked in the desturctors.\n  // TODO log it\n  auto ec = sys::error_code{};\n  if constexpr (IsSslStreamV<Socket>) {\n    s.async_shutdown(yield[ec]);\n    close(s.next_layer(), yield);\n  }\n  else {\n    suppressC4100(yield);\n    s.close(ec);\n  }\n}\n\ntemplate <typename Socket> bool isOpen(Socket const& s)\n{\n  if constexpr (IsSslStreamV<Socket>) {\n    return isOpen(s.next_layer());\n  }\n  else {\n    return s.is_open();\n  }\n}\n\ntemplate <typename Socket> unique_ptr<Ingress> makeIngress(api::IngressHolder& holder, Socket&& s)\n{\n  auto container = array<uint8_t, 1024>{0};\n  auto psk = MutableBuffer<uint8_t>{container};\n  auto& vo = holder.vo_;\n  switch (vo.type_) {\n  case AdapterType::HTTP:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<HttpIngress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<HttpIngress<TcpSocket>>(vo.credentials_, forward<Socket>(s));\n  case AdapterType::SOCKS5:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<Socks5Ingress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<Socks5Ingress<TcpSocket>>(vo.credentials_, forward<Socket>(s));\n  case AdapterType::SS:\n    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};\n    switch (*vo.method_) {\n    case CryptoMethod::RC4_MD5:\n      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::BF_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_128_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_192_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_256_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::AES_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, Socket>>(psk,\n                                                                             forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CAMELLIA_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::SALSA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20_IETF:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, Socket>>(psk,\n                                                                               forward<Socket>(s));\n    case CryptoMethod::AES_128_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_192_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::AES_256_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, Socket>>(psk, forward<Socket>(s));\n    case CryptoMethod::CHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, Socket>>(\n          psk, forward<Socket>(s));\n    case CryptoMethod::XCHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, Socket>>(\n          psk, forward<Socket>(s));\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  case AdapterType::TUNNEL:\n    return make_unique<TunnelIngress<api::IngressIterator, Socket>>(*holder.balancer_,\n                                                                    forward<Socket>(s));\n  default:\n    fail(PichiError::BAD_PROTO);\n  }\n}\n\nunique_ptr<Egress> makeEgress(api::EgressVO const& vo, asio::io_context& io)\n{\n  auto container = array<uint8_t, 1024>{0};\n  auto psk = MutableBuffer<uint8_t>{container};\n  switch (vo.type_) {\n  case AdapterType::HTTP:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<HttpEgress<TlsSocket>>(vo.credential_, io, ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<HttpEgress<TcpSocket>>(vo.credential_, io);\n  case AdapterType::SOCKS5:\n#ifdef ENABLE_TLS\n    if (*vo.tls_) {\n      auto ctx = createTlsContext(vo);\n      return make_unique<Socks5Egress<ssl::stream<tcp::socket>>>(vo.credential_, io, ctx);\n    }\n    else\n#endif // ENABLE_TLS\n      return make_unique<Socks5Egress<tcp::socket>>(vo.credential_, io);\n  case AdapterType::DIRECT:\n    return make_unique<DirectAdapter>(io);\n  case AdapterType::REJECT:\n    switch (*vo.mode_) {\n    case api::DelayMode::RANDOM:\n      return make_unique<RejectEgress>(io);\n    case api::DelayMode::FIXED:\n      return make_unique<RejectEgress>(io, *vo.delay_);\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  case AdapterType::SS:\n    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};\n    switch (*vo.method_) {\n    case CryptoMethod::RC4_MD5:\n      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, TcpSocket>>(psk, io);\n    case CryptoMethod::BF_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_CTR:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_128_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_192_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CAMELLIA_256_CFB:\n      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, TcpSocket>>(psk, io);\n    case CryptoMethod::SALSA20:\n      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20_IETF:\n      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_128_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_192_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::AES_256_GCM:\n      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, TcpSocket>>(psk, io);\n    case CryptoMethod::CHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);\n    case CryptoMethod::XCHACHA20_IETF_POLY1305:\n      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);\n    default:\n      fail(PichiError::BAD_PROTO);\n    }\n  default:\n    fail(PichiError::BAD_PROTO);\n  }\n}\n\nusing Yield = asio::yield_context;\n\ntemplate void connect<>(Endpoint const&, TcpSocket&, Yield);\ntemplate void read<>(TcpSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(TcpSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(TcpSocket&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(TcpSocket&, Yield);\ntemplate bool isOpen<>(TcpSocket const&);\n\n#ifdef ENABLE_TLS\ntemplate void connect<>(Endpoint const&, TlsSocket&, Yield);\ntemplate void read<>(TlsSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(TlsSocket&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(TlsSocket&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(TlsSocket&, Yield);\ntemplate bool isOpen<>(TlsSocket const&);\n#endif // ENABLE_TLS\n\n#ifdef BUILD_TEST\ntemplate void connect<>(Endpoint const&, pichi::test::Stream&, Yield);\ntemplate void read<>(pichi::test::Stream&, MutableBuffer<uint8_t>, Yield);\ntemplate size_t readSome<>(pichi::test::Stream&, MutableBuffer<uint8_t>, Yield);\ntemplate void write<>(pichi::test::Stream&, ConstBuffer<uint8_t>, Yield);\ntemplate void close<>(pichi::test::Stream&, Yield);\ntemplate bool isOpen<>(pichi::test::Stream const&);\n#endif // BUILD_TEST\n\ntemplate unique_ptr<Ingress> makeIngress<>(api::IngressHolder&, TcpSocket&&);\n\n} // namespace pichi::net\n"], "filenames": ["CMakeLists.txt", "src/net/asio.cpp"], "buggy_code_start_loc": [24, 29], "buggy_code_end_loc": [24, 64], "fixing_code_start_loc": [25, 30], "fixing_code_end_loc": [28, 69], "type": "CWE-295", "message": "The boost ASIO wrapper in net/asio.cpp in Pichi before 1.3.0 lacks TLS hostname verification.", "other": {"cve": {"id": "CVE-2020-13616", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-26T23:15:11.083", "lastModified": "2020-05-29T20:04:15.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The boost ASIO wrapper in net/asio.cpp in Pichi before 1.3.0 lacks TLS hostname verification."}, {"lang": "es", "value": "El contenedor boost ASIO en el archivo net/asio.cpp en Pichi versiones anteriores a 1.3.0, carece de la verificaci\u00f3n del nombre de host TLS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pichi_project:pichi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "35496D8A-180E-4DF4-B1F1-417806D39DF7"}]}]}], "references": [{"url": "https://github.com/pichi-router/pichi/commit/4698664233bc324f26658d2b041bfe6ea022c573", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pichi-router/pichi/releases/tag/1.3.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pichi-router/pichi/commit/4698664233bc324f26658d2b041bfe6ea022c573"}}