{"buggy_code": ["<?php\n\n/**\n * Filesystem configuration options.\n *\n * Changes to these config files are not supported by BookStack and may break upon updates.\n * Configuration should be altered via the `.env` file or environment variables.\n * Do not edit this file unless you're happy to maintain any changes yourself.\n */\n\nreturn [\n\n    // Default Filesystem Disk\n    // Options: local, local_secure, s3\n    'default' => env('STORAGE_TYPE', 'local'),\n\n    // Filesystem to use specifically for image uploads.\n    'images' => env('STORAGE_IMAGE_TYPE', env('STORAGE_TYPE', 'local')),\n\n    // Filesystem to use specifically for file attachments.\n    'attachments' => env('STORAGE_ATTACHMENT_TYPE', env('STORAGE_TYPE', 'local')),\n\n    // Storage URL\n    // This is the url to where the storage is located for when using an external\n    // file storage service, such as s3, to store publicly accessible assets.\n    'url' => env('STORAGE_URL', false),\n\n    // Default Cloud Filesystem Disk\n    'cloud' => 's3',\n\n    // Available filesystem disks\n    // Only local, local_secure & s3 are supported by BookStack\n    'disks' => [\n\n        'local' => [\n            'driver' => 'local',\n            'root'   => public_path(),\n        ],\n\n        'local_secure' => [\n            'driver' => 'local',\n            'root'   => storage_path(),\n        ],\n\n        's3' => [\n            'driver'                  => 's3',\n            'key'                     => env('STORAGE_S3_KEY', 'your-key'),\n            'secret'                  => env('STORAGE_S3_SECRET', 'your-secret'),\n            'region'                  => env('STORAGE_S3_REGION', 'your-region'),\n            'bucket'                  => env('STORAGE_S3_BUCKET', 'your-bucket'),\n            'endpoint'                => env('STORAGE_S3_ENDPOINT', null),\n            'use_path_style_endpoint' => env('STORAGE_S3_ENDPOINT', null) !== null,\n        ],\n\n    ],\n\n];\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\FileUploadException;\nuse Exception;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Str;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass AttachmentService\n{\n    protected $fileSystem;\n\n    /**\n     * AttachmentService constructor.\n     */\n    public function __construct(FileSystem $fileSystem)\n    {\n        $this->fileSystem = $fileSystem;\n    }\n\n    /**\n     * Get the storage that will be used for storing files.\n     */\n    protected function getStorage(): FileSystemInstance\n    {\n        $storageType = config('filesystems.attachments');\n\n        // Override default location if set to local public to ensure not visible.\n        if ($storageType === 'local') {\n            $storageType = 'local_secure';\n        }\n\n        return $this->fileSystem->disk($storageType);\n    }\n\n    /**\n     * Get an attachment from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getAttachmentFromStorage(Attachment $attachment): string\n    {\n        return $this->getStorage()->get($attachment->path);\n    }\n\n    /**\n     * Store a new attachment upon user upload.\n     *\n     * @param UploadedFile $uploadedFile\n     * @param int          $page_id\n     *\n     * @throws FileUploadException\n     *\n     * @return Attachment\n     */\n    public function saveNewUpload(UploadedFile $uploadedFile, $page_id)\n    {\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n        $largestExistingOrder = Attachment::where('uploaded_to', '=', $page_id)->max('order');\n\n        $attachment = Attachment::forceCreate([\n            'name'        => $attachmentName,\n            'path'        => $attachmentPath,\n            'extension'   => $uploadedFile->getClientOriginalExtension(),\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n\n        return $attachment;\n    }\n\n    /**\n     * Store a upload, saving to a file and deleting any existing uploads\n     * attached to that file.\n     *\n     * @param UploadedFile $uploadedFile\n     * @param Attachment   $attachment\n     *\n     * @throws FileUploadException\n     *\n     * @return Attachment\n     */\n    public function saveUpdatedUpload(UploadedFile $uploadedFile, Attachment $attachment)\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n\n        $attachment->name = $attachmentName;\n        $attachment->path = $attachmentPath;\n        $attachment->external = false;\n        $attachment->extension = $uploadedFile->getClientOriginalExtension();\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Save a new File attachment from a given link and name.\n     */\n    public function saveNewFromLink(string $name, string $link, int $page_id): Attachment\n    {\n        $largestExistingOrder = Attachment::where('uploaded_to', '=', $page_id)->max('order');\n\n        return Attachment::forceCreate([\n            'name'        => $name,\n            'path'        => $link,\n            'external'    => true,\n            'extension'   => '',\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n    }\n\n    /**\n     * Updates the ordering for a listing of attached files.\n     */\n    public function updateFileOrderWithinPage(array $attachmentOrder, string $pageId)\n    {\n        foreach ($attachmentOrder as $index => $attachmentId) {\n            Attachment::query()->where('uploaded_to', '=', $pageId)\n                ->where('id', '=', $attachmentId)\n                ->update(['order' => $index]);\n        }\n    }\n\n    /**\n     * Update the details of a file.\n     */\n    public function updateFile(Attachment $attachment, array $requestData): Attachment\n    {\n        $attachment->name = $requestData['name'];\n\n        if (isset($requestData['link']) && trim($requestData['link']) !== '') {\n            $attachment->path = $requestData['link'];\n            if (!$attachment->external) {\n                $this->deleteFileInStorage($attachment);\n                $attachment->external = true;\n            }\n        }\n\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Delete a File from the database and storage.\n     *\n     * @param Attachment $attachment\n     *\n     * @throws Exception\n     */\n    public function deleteFile(Attachment $attachment)\n    {\n        if ($attachment->external) {\n            $attachment->delete();\n\n            return;\n        }\n\n        $this->deleteFileInStorage($attachment);\n        $attachment->delete();\n    }\n\n    /**\n     * Delete a file from the filesystem it sits on.\n     * Cleans any empty leftover folders.\n     *\n     * @param Attachment $attachment\n     */\n    protected function deleteFileInStorage(Attachment $attachment)\n    {\n        $storage = $this->getStorage();\n        $dirPath = dirname($attachment->path);\n\n        $storage->delete($attachment->path);\n        if (count($storage->allFiles($dirPath)) === 0) {\n            $storage->deleteDirectory($dirPath);\n        }\n    }\n\n    /**\n     * Store a file in storage with the given filename.\n     *\n     * @param UploadedFile $uploadedFile\n     *\n     * @throws FileUploadException\n     *\n     * @return string\n     */\n    protected function putFileInStorage(UploadedFile $uploadedFile)\n    {\n        $attachmentData = file_get_contents($uploadedFile->getRealPath());\n\n        $storage = $this->getStorage();\n        $basePath = 'uploads/files/' . date('Y-m-M') . '/';\n\n        $uploadFileName = Str::random(16) . '.' . $uploadedFile->getClientOriginalExtension();\n        while ($storage->exists($basePath . $uploadFileName)) {\n            $uploadFileName = Str::random(3) . $uploadFileName;\n        }\n\n        $attachmentPath = $basePath . $uploadFileName;\n\n        try {\n            $storage->put($attachmentPath, $attachmentData);\n        } catch (Exception $e) {\n            Log::error('Error when attempting file upload:' . $e->getMessage());\n\n            throw new FileUploadException(trans('errors.path_not_writable', ['filePath' => $attachmentPath]));\n        }\n\n        return $attachmentPath;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse ErrorException;\nuse Exception;\nuse Illuminate\\Contracts\\Cache\\Repository as Cache;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as Storage;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Str;\nuse Intervention\\Image\\Exception\\NotSupportedException;\nuse Intervention\\Image\\ImageManager;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass ImageService\n{\n    protected $imageTool;\n    protected $cache;\n    protected $storageUrl;\n    protected $image;\n    protected $fileSystem;\n\n    /**\n     * ImageService constructor.\n     */\n    public function __construct(Image $image, ImageManager $imageTool, FileSystem $fileSystem, Cache $cache)\n    {\n        $this->image = $image;\n        $this->imageTool = $imageTool;\n        $this->fileSystem = $fileSystem;\n        $this->cache = $cache;\n    }\n\n    /**\n     * Get the storage that will be used for storing images.\n     */\n    protected function getStorage(string $type = ''): FileSystemInstance\n    {\n        $storageType = config('filesystems.images');\n\n        // Ensure system images (App logo) are uploaded to a public space\n        if ($type === 'system' && $storageType === 'local_secure') {\n            $storageType = 'local';\n        }\n\n        return $this->fileSystem->disk($storageType);\n    }\n\n    /**\n     * Saves a new image from an upload.\n     *\n     * @throws ImageUploadException\n     *\n     * @return mixed\n     */\n    public function saveNewFromUpload(\n        UploadedFile $uploadedFile,\n        string $type,\n        int $uploadedTo = 0,\n        int $resizeWidth = null,\n        int $resizeHeight = null,\n        bool $keepRatio = true\n    ) {\n        $imageName = $uploadedFile->getClientOriginalName();\n        $imageData = file_get_contents($uploadedFile->getRealPath());\n\n        if ($resizeWidth !== null || $resizeHeight !== null) {\n            $imageData = $this->resizeImage($imageData, $resizeWidth, $resizeHeight, $keepRatio);\n        }\n\n        return $this->saveNew($imageName, $imageData, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image from a uri-encoded base64 string of data.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromBase64Uri(string $base64Uri, string $name, string $type, int $uploadedTo = 0): Image\n    {\n        $splitData = explode(';base64,', $base64Uri);\n        if (count($splitData) < 2) {\n            throw new ImageUploadException('Invalid base64 image data provided');\n        }\n        $data = base64_decode($splitData[1]);\n\n        return $this->saveNew($name, $data, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image into storage.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(string $imageName, string $imageData, string $type, int $uploadedTo = 0): Image\n    {\n        $storage = $this->getStorage($type);\n        $secureUploads = setting('app-secure-images');\n        $fileName = $this->cleanImageFileName($imageName);\n\n        $imagePath = '/uploads/images/' . $type . '/' . date('Y-m') . '/';\n\n        while ($storage->exists($imagePath . $fileName)) {\n            $fileName = Str::random(3) . $fileName;\n        }\n\n        $fullPath = $imagePath . $fileName;\n        if ($secureUploads) {\n            $fullPath = $imagePath . Str::random(16) . '-' . $fileName;\n        }\n\n        try {\n            $this->saveImageDataInPublicSpace($storage, $fullPath, $imageData);\n        } catch (Exception $e) {\n            \\Log::error('Error when attempting image upload:' . $e->getMessage());\n\n            throw new ImageUploadException(trans('errors.path_not_writable', ['filePath' => $fullPath]));\n        }\n\n        $imageDetails = [\n            'name'        => $imageName,\n            'path'        => $fullPath,\n            'url'         => $this->getPublicUrl($fullPath),\n            'type'        => $type,\n            'uploaded_to' => $uploadedTo,\n        ];\n\n        if (user()->id !== 0) {\n            $userId = user()->id;\n            $imageDetails['created_by'] = $userId;\n            $imageDetails['updated_by'] = $userId;\n        }\n\n        $image = $this->image->newInstance();\n        $image->forceFill($imageDetails)->save();\n\n        return $image;\n    }\n\n    /**\n     * Save image data for the given path in the public space, if possible,\n     * for the provided storage mechanism.\n     */\n    protected function saveImageDataInPublicSpace(Storage $storage, string $path, string $data)\n    {\n        $storage->put($path, $data);\n\n        // Set visibility when a non-AWS-s3, s3-like storage option is in use.\n        // Done since this call can break s3-like services but desired for other image stores.\n        // Attempting to set ACL during above put request requires different permissions\n        // hence would technically be a breaking change for actual s3 usage.\n        $usingS3 = strtolower(config('filesystems.images')) === 's3';\n        $usingS3Like = $usingS3 && !is_null(config('filesystems.disks.s3.endpoint'));\n        if (!$usingS3Like) {\n            $storage->setVisibility($path, 'public');\n        }\n    }\n\n    /**\n     * Clean up an image file name to be both URL and storage safe.\n     */\n    protected function cleanImageFileName(string $name): string\n    {\n        $name = str_replace(' ', '-', $name);\n        $nameParts = explode('.', $name);\n        $extension = array_pop($nameParts);\n        $name = implode('-', $nameParts);\n        $name = Str::slug($name);\n\n        if (strlen($name) === 0) {\n            $name = Str::random(10);\n        }\n\n        return $name . '.' . $extension;\n    }\n\n    /**\n     * Checks if the image is a gif. Returns true if it is, else false.\n     */\n    protected function isGif(Image $image): bool\n    {\n        return strtolower(pathinfo($image->path, PATHINFO_EXTENSION)) === 'gif';\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @param Image $image\n     * @param int   $width\n     * @param int   $height\n     * @param bool  $keepRatio\n     *\n     * @throws Exception\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    public function getThumbnail(Image $image, $width = 220, $height = 220, $keepRatio = false)\n    {\n        if ($keepRatio && $this->isGif($image)) {\n            return $this->getPublicUrl($image->path);\n        }\n\n        $thumbDirName = '/' . ($keepRatio ? 'scaled-' : 'thumbs-') . $width . '-' . $height . '/';\n        $imagePath = $image->path;\n        $thumbFilePath = dirname($imagePath) . $thumbDirName . basename($imagePath);\n\n        if ($this->cache->has('images-' . $image->id . '-' . $thumbFilePath) && $this->cache->get('images-' . $thumbFilePath)) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $storage = $this->getStorage($image->type);\n        if ($storage->exists($thumbFilePath)) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $thumbData = $this->resizeImage($storage->get($imagePath), $width, $height, $keepRatio);\n\n        $this->saveImageDataInPublicSpace($storage, $thumbFilePath, $thumbData);\n        $this->cache->put('images-' . $image->id . '-' . $thumbFilePath, $thumbFilePath, 60 * 60 * 72);\n\n        return $this->getPublicUrl($thumbFilePath);\n    }\n\n    /**\n     * Resize image data.\n     *\n     * @param string $imageData\n     * @param int    $width\n     * @param int    $height\n     * @param bool   $keepRatio\n     *\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    protected function resizeImage(string $imageData, $width = 220, $height = null, bool $keepRatio = true)\n    {\n        try {\n            $thumb = $this->imageTool->make($imageData);\n        } catch (Exception $e) {\n            if ($e instanceof ErrorException || $e instanceof NotSupportedException) {\n                throw new ImageUploadException(trans('errors.cannot_create_thumbs'));\n            }\n\n            throw $e;\n        }\n\n        if ($keepRatio) {\n            $thumb->resize($width, $height, function ($constraint) {\n                $constraint->aspectRatio();\n                $constraint->upsize();\n            });\n        } else {\n            $thumb->fit($width, $height);\n        }\n\n        $thumbData = (string) $thumb->encode();\n\n        // Use original image data if we're keeping the ratio\n        // and the resizing does not save any space.\n        if ($keepRatio && strlen($thumbData) > strlen($imageData)) {\n            return $imageData;\n        }\n\n        return $thumbData;\n    }\n\n    /**\n     * Get the raw data content from an image.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getImageData(Image $image): string\n    {\n        $imagePath = $image->path;\n        $storage = $this->getStorage();\n\n        return $storage->get($imagePath);\n    }\n\n    /**\n     * Destroy an image along with its revisions, thumbnails and remaining folders.\n     *\n     * @throws Exception\n     */\n    public function destroy(Image $image)\n    {\n        $this->destroyImagesFromPath($image->path);\n        $image->delete();\n    }\n\n    /**\n     * Destroys an image at the given path.\n     * Searches for image thumbnails in addition to main provided path.\n     */\n    protected function destroyImagesFromPath(string $path): bool\n    {\n        $storage = $this->getStorage();\n\n        $imageFolder = dirname($path);\n        $imageFileName = basename($path);\n        $allImages = collect($storage->allFiles($imageFolder));\n\n        // Delete image files\n        $imagesToDelete = $allImages->filter(function ($imagePath) use ($imageFileName) {\n            return basename($imagePath) === $imageFileName;\n        });\n        $storage->delete($imagesToDelete->all());\n\n        // Cleanup of empty folders\n        $foldersInvolved = array_merge([$imageFolder], $storage->directories($imageFolder));\n        foreach ($foldersInvolved as $directory) {\n            if ($this->isFolderEmpty($storage, $directory)) {\n                $storage->deleteDirectory($directory);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether or not a folder is empty.\n     */\n    protected function isFolderEmpty(FileSystemInstance $storage, string $path): bool\n    {\n        $files = $storage->files($path);\n        $folders = $storage->directories($path);\n\n        return count($files) === 0 && count($folders) === 0;\n    }\n\n    /**\n     * Delete gallery and drawings that are not within HTML content of pages or page revisions.\n     * Checks based off of only the image name.\n     * Could be much improved to be more specific but kept it generic for now to be safe.\n     *\n     * Returns the path of the images that would be/have been deleted.\n     */\n    public function deleteUnusedImages(bool $checkRevisions = true, bool $dryRun = true)\n    {\n        $types = ['gallery', 'drawio'];\n        $deletedPaths = [];\n\n        $this->image->newQuery()->whereIn('type', $types)\n            ->chunk(1000, function ($images) use ($checkRevisions, &$deletedPaths, $dryRun) {\n                foreach ($images as $image) {\n                    $searchQuery = '%' . basename($image->path) . '%';\n                    $inPage = DB::table('pages')\n                            ->where('html', 'like', $searchQuery)->count() > 0;\n\n                    $inRevision = false;\n                    if ($checkRevisions) {\n                        $inRevision = DB::table('page_revisions')\n                                ->where('html', 'like', $searchQuery)->count() > 0;\n                    }\n\n                    if (!$inPage && !$inRevision) {\n                        $deletedPaths[] = $image->path;\n                        if (!$dryRun) {\n                            $this->destroy($image);\n                        }\n                    }\n                }\n            });\n\n        return $deletedPaths;\n    }\n\n    /**\n     * Convert a image URI to a Base64 encoded string.\n     * Attempts to convert the URL to a system storage url then\n     * fetch the data from the disk or storage location.\n     * Returns null if the image data cannot be fetched from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function imageUriToBase64(string $uri): ?string\n    {\n        $storagePath = $this->imageUrlToStoragePath($uri);\n        if (empty($uri) || is_null($storagePath)) {\n            return null;\n        }\n\n        $storage = $this->getStorage();\n        $imageData = null;\n        if ($storage->exists($storagePath)) {\n            $imageData = $storage->get($storagePath);\n        }\n\n        if (is_null($imageData)) {\n            return null;\n        }\n\n        $extension = pathinfo($uri, PATHINFO_EXTENSION);\n        if ($extension === 'svg') {\n            $extension = 'svg+xml';\n        }\n\n        return 'data:image/' . $extension . ';base64,' . base64_encode($imageData);\n    }\n\n    /**\n     * Get a storage path for the given image URL.\n     * Ensures the path will start with \"uploads/images\".\n     * Returns null if the url cannot be resolved to a local URL.\n     */\n    private function imageUrlToStoragePath(string $url): ?string\n    {\n        $url = ltrim(trim($url), '/');\n\n        // Handle potential relative paths\n        $isRelative = strpos($url, 'http') !== 0;\n        if ($isRelative) {\n            if (strpos(strtolower($url), 'uploads/images') === 0) {\n                return trim($url, '/');\n            }\n\n            return null;\n        }\n\n        // Handle local images based on paths on the same domain\n        $potentialHostPaths = [\n            url('uploads/images/'),\n            $this->getPublicUrl('/uploads/images/'),\n        ];\n\n        foreach ($potentialHostPaths as $potentialBasePath) {\n            $potentialBasePath = strtolower($potentialBasePath);\n            if (strpos(strtolower($url), $potentialBasePath) === 0) {\n                return 'uploads/images/' . trim(substr($url, strlen($potentialBasePath)), '/');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets a public facing url for an image by checking relevant environment variables.\n     * If s3-style store is in use it will default to guessing a public bucket URL.\n     */\n    private function getPublicUrl(string $filePath): string\n    {\n        if ($this->storageUrl === null) {\n            $storageUrl = config('filesystems.url');\n\n            // Get the standard public s3 url if s3 is set as storage type\n            // Uses the nice, short URL if bucket name has no periods in otherwise the longer\n            // region-based url will be used to prevent http issues.\n            if ($storageUrl == false && config('filesystems.images') === 's3') {\n                $storageDetails = config('filesystems.disks.s3');\n                if (strpos($storageDetails['bucket'], '.') === false) {\n                    $storageUrl = 'https://' . $storageDetails['bucket'] . '.s3.amazonaws.com';\n                } else {\n                    $storageUrl = 'https://s3-' . $storageDetails['region'] . '.amazonaws.com/' . $storageDetails['bucket'];\n                }\n            }\n            $this->storageUrl = $storageUrl;\n        }\n\n        $basePath = ($this->storageUrl == false) ? url('/') : $this->storageUrl;\n\n        return rtrim($basePath, '/') . $filePath;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Filesystem configuration options.\n *\n * Changes to these config files are not supported by BookStack and may break upon updates.\n * Configuration should be altered via the `.env` file or environment variables.\n * Do not edit this file unless you're happy to maintain any changes yourself.\n */\n\nreturn [\n\n    // Default Filesystem Disk\n    // Options: local, local_secure, s3\n    'default' => env('STORAGE_TYPE', 'local'),\n\n    // Filesystem to use specifically for image uploads.\n    'images' => env('STORAGE_IMAGE_TYPE', env('STORAGE_TYPE', 'local')),\n\n    // Filesystem to use specifically for file attachments.\n    'attachments' => env('STORAGE_ATTACHMENT_TYPE', env('STORAGE_TYPE', 'local')),\n\n    // Storage URL\n    // This is the url to where the storage is located for when using an external\n    // file storage service, such as s3, to store publicly accessible assets.\n    'url' => env('STORAGE_URL', false),\n\n    // Default Cloud Filesystem Disk\n    'cloud' => 's3',\n\n    // Available filesystem disks\n    // Only local, local_secure & s3 are supported by BookStack\n    'disks' => [\n\n        'local' => [\n            'driver' => 'local',\n            'root'   => public_path(),\n        ],\n\n        'local_secure_attachments' => [\n            'driver' => 'local',\n            'root'   => storage_path('uploads/files/'),\n        ],\n\n        'local_secure_images' => [\n            'driver' => 'local',\n            'root'   => storage_path('uploads/images/'),\n        ],\n\n        's3' => [\n            'driver'                  => 's3',\n            'key'                     => env('STORAGE_S3_KEY', 'your-key'),\n            'secret'                  => env('STORAGE_S3_SECRET', 'your-secret'),\n            'region'                  => env('STORAGE_S3_REGION', 'your-region'),\n            'bucket'                  => env('STORAGE_S3_BUCKET', 'your-bucket'),\n            'endpoint'                => env('STORAGE_S3_ENDPOINT', null),\n            'use_path_style_endpoint' => env('STORAGE_S3_ENDPOINT', null) !== null,\n        ],\n\n    ],\n\n];\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\FileUploadException;\nuse Exception;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Str;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass AttachmentService\n{\n    protected $fileSystem;\n\n    /**\n     * AttachmentService constructor.\n     */\n    public function __construct(FileSystem $fileSystem)\n    {\n        $this->fileSystem = $fileSystem;\n    }\n\n    /**\n     * Get the storage that will be used for storing files.\n     */\n    protected function getStorage(): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName());\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(): string\n    {\n        $storageType = config('filesystems.attachments');\n\n        // Change to our secure-attachment disk if any of the local options\n        // are used to prevent escaping that location.\n        if ($storageType === 'local' || $storageType === 'local_secure') {\n            $storageType = 'local_secure_attachments';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/files/', '', $path));\n\n        if ($this->getStorageDiskName() === 'local_secure_attachments') {\n            return $path;\n        }\n\n        return 'uploads/files/' . $path;\n    }\n\n    /**\n     * Get an attachment from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getAttachmentFromStorage(Attachment $attachment): string\n    {\n        return $this->getStorage()->get($this->adjustPathForStorageDisk($attachment->path));\n    }\n\n    /**\n     * Store a new attachment upon user upload.\n     * @throws FileUploadException\n     */\n    public function saveNewUpload(UploadedFile $uploadedFile, int $page_id): Attachment\n    {\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n        $largestExistingOrder = Attachment::query()->where('uploaded_to', '=', $page_id)->max('order');\n\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->forceCreate([\n            'name'        => $attachmentName,\n            'path'        => $attachmentPath,\n            'extension'   => $uploadedFile->getClientOriginalExtension(),\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n\n        return $attachment;\n    }\n\n    /**\n     * Store an upload, saving to a file and deleting any existing uploads\n     * attached to that file.\n     *\n     * @throws FileUploadException\n     */\n    public function saveUpdatedUpload(UploadedFile $uploadedFile, Attachment $attachment): Attachment\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n\n        $attachment->name = $attachmentName;\n        $attachment->path = $attachmentPath;\n        $attachment->external = false;\n        $attachment->extension = $uploadedFile->getClientOriginalExtension();\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Save a new File attachment from a given link and name.\n     */\n    public function saveNewFromLink(string $name, string $link, int $page_id): Attachment\n    {\n        $largestExistingOrder = Attachment::where('uploaded_to', '=', $page_id)->max('order');\n\n        return Attachment::forceCreate([\n            'name'        => $name,\n            'path'        => $link,\n            'external'    => true,\n            'extension'   => '',\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n    }\n\n    /**\n     * Updates the ordering for a listing of attached files.\n     */\n    public function updateFileOrderWithinPage(array $attachmentOrder, string $pageId)\n    {\n        foreach ($attachmentOrder as $index => $attachmentId) {\n            Attachment::query()->where('uploaded_to', '=', $pageId)\n                ->where('id', '=', $attachmentId)\n                ->update(['order' => $index]);\n        }\n    }\n\n    /**\n     * Update the details of a file.\n     */\n    public function updateFile(Attachment $attachment, array $requestData): Attachment\n    {\n        $attachment->name = $requestData['name'];\n\n        if (isset($requestData['link']) && trim($requestData['link']) !== '') {\n            $attachment->path = $requestData['link'];\n            if (!$attachment->external) {\n                $this->deleteFileInStorage($attachment);\n                $attachment->external = true;\n            }\n        }\n\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Delete a File from the database and storage.\n     * @throws Exception\n     */\n    public function deleteFile(Attachment $attachment)\n    {\n        if ($attachment->external) {\n            $attachment->delete();\n\n            return;\n        }\n\n        $this->deleteFileInStorage($attachment);\n        $attachment->delete();\n    }\n\n    /**\n     * Delete a file from the filesystem it sits on.\n     * Cleans any empty leftover folders.\n     */\n    protected function deleteFileInStorage(Attachment $attachment)\n    {\n        $storage = $this->getStorage();\n        $dirPath = $this->adjustPathForStorageDisk(dirname($attachment->path));\n\n        $storage->delete($this->adjustPathForStorageDisk($attachment->path));\n        if (count($storage->allFiles($dirPath)) === 0) {\n            $storage->deleteDirectory($dirPath);\n        }\n    }\n\n    /**\n     * Store a file in storage with the given filename.\n     * @throws FileUploadException\n     */\n    protected function putFileInStorage(UploadedFile $uploadedFile): string\n    {\n        $attachmentData = file_get_contents($uploadedFile->getRealPath());\n\n        $storage = $this->getStorage();\n        $basePath = 'uploads/files/' . date('Y-m-M') . '/';\n\n        $uploadFileName = Str::random(16) . '.' . $uploadedFile->getClientOriginalExtension();\n        while ($storage->exists($this->adjustPathForStorageDisk($basePath . $uploadFileName))) {\n            $uploadFileName = Str::random(3) . $uploadFileName;\n        }\n\n        $attachmentPath = $basePath . $uploadFileName;\n\n        try {\n            $storage->put($this->adjustPathForStorageDisk($attachmentPath), $attachmentData);\n        } catch (Exception $e) {\n            Log::error('Error when attempting file upload:' . $e->getMessage());\n\n            throw new FileUploadException(trans('errors.path_not_writable', ['filePath' => $attachmentPath]));\n        }\n\n        return $attachmentPath;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse ErrorException;\nuse Exception;\nuse Illuminate\\Contracts\\Cache\\Repository as Cache;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as Storage;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Str;\nuse Intervention\\Image\\Exception\\NotSupportedException;\nuse Intervention\\Image\\ImageManager;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass ImageService\n{\n    protected $imageTool;\n    protected $cache;\n    protected $storageUrl;\n    protected $image;\n    protected $fileSystem;\n\n    /**\n     * ImageService constructor.\n     */\n    public function __construct(Image $image, ImageManager $imageTool, FileSystem $fileSystem, Cache $cache)\n    {\n        $this->image = $image;\n        $this->imageTool = $imageTool;\n        $this->fileSystem = $fileSystem;\n        $this->cache = $cache;\n    }\n\n    /**\n     * Get the storage that will be used for storing images.\n     */\n    protected function getStorage(string $imageType = ''): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName($imageType));\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path, string $imageType = ''): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/images/', '', $path));\n\n        if ($this->getStorageDiskName($imageType) === 'local_secure_images') {\n            return $path;\n        }\n\n        return 'uploads/images/' . $path;\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(string $imageType): string\n    {\n        $storageType = config('filesystems.images');\n\n        // Ensure system images (App logo) are uploaded to a public space\n        if ($imageType === 'system' && $storageType === 'local_secure') {\n            $storageType = 'local';\n        }\n\n        if ($storageType === 'local_secure') {\n            $storageType = 'local_secure_images';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Saves a new image from an upload.\n     *\n     * @throws ImageUploadException\n     *\n     * @return mixed\n     */\n    public function saveNewFromUpload(\n        UploadedFile $uploadedFile,\n        string $type,\n        int $uploadedTo = 0,\n        int $resizeWidth = null,\n        int $resizeHeight = null,\n        bool $keepRatio = true\n    ) {\n        $imageName = $uploadedFile->getClientOriginalName();\n        $imageData = file_get_contents($uploadedFile->getRealPath());\n\n        if ($resizeWidth !== null || $resizeHeight !== null) {\n            $imageData = $this->resizeImage($imageData, $resizeWidth, $resizeHeight, $keepRatio);\n        }\n\n        return $this->saveNew($imageName, $imageData, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image from a uri-encoded base64 string of data.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromBase64Uri(string $base64Uri, string $name, string $type, int $uploadedTo = 0): Image\n    {\n        $splitData = explode(';base64,', $base64Uri);\n        if (count($splitData) < 2) {\n            throw new ImageUploadException('Invalid base64 image data provided');\n        }\n        $data = base64_decode($splitData[1]);\n\n        return $this->saveNew($name, $data, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image into storage.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(string $imageName, string $imageData, string $type, int $uploadedTo = 0): Image\n    {\n        $storage = $this->getStorage($type);\n        $secureUploads = setting('app-secure-images');\n        $fileName = $this->cleanImageFileName($imageName);\n\n        $imagePath = '/uploads/images/' . $type . '/' . date('Y-m') . '/';\n\n        while ($storage->exists($this->adjustPathForStorageDisk($imagePath . $fileName, $type))) {\n            $fileName = Str::random(3) . $fileName;\n        }\n\n        $fullPath = $imagePath . $fileName;\n        if ($secureUploads) {\n            $fullPath = $imagePath . Str::random(16) . '-' . $fileName;\n        }\n\n        try {\n            $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($fullPath, $type), $imageData);\n        } catch (Exception $e) {\n            \\Log::error('Error when attempting image upload:' . $e->getMessage());\n\n            throw new ImageUploadException(trans('errors.path_not_writable', ['filePath' => $fullPath]));\n        }\n\n        $imageDetails = [\n            'name'        => $imageName,\n            'path'        => $fullPath,\n            'url'         => $this->getPublicUrl($fullPath),\n            'type'        => $type,\n            'uploaded_to' => $uploadedTo,\n        ];\n\n        if (user()->id !== 0) {\n            $userId = user()->id;\n            $imageDetails['created_by'] = $userId;\n            $imageDetails['updated_by'] = $userId;\n        }\n\n        $image = $this->image->newInstance();\n        $image->forceFill($imageDetails)->save();\n\n        return $image;\n    }\n\n    /**\n     * Save image data for the given path in the public space, if possible,\n     * for the provided storage mechanism.\n     */\n    protected function saveImageDataInPublicSpace(Storage $storage, string $path, string $data)\n    {\n        $storage->put($path, $data);\n\n        // Set visibility when a non-AWS-s3, s3-like storage option is in use.\n        // Done since this call can break s3-like services but desired for other image stores.\n        // Attempting to set ACL during above put request requires different permissions\n        // hence would technically be a breaking change for actual s3 usage.\n        $usingS3 = strtolower(config('filesystems.images')) === 's3';\n        $usingS3Like = $usingS3 && !is_null(config('filesystems.disks.s3.endpoint'));\n        if (!$usingS3Like) {\n            $storage->setVisibility($path, 'public');\n        }\n    }\n\n    /**\n     * Clean up an image file name to be both URL and storage safe.\n     */\n    protected function cleanImageFileName(string $name): string\n    {\n        $name = str_replace(' ', '-', $name);\n        $nameParts = explode('.', $name);\n        $extension = array_pop($nameParts);\n        $name = implode('-', $nameParts);\n        $name = Str::slug($name);\n\n        if (strlen($name) === 0) {\n            $name = Str::random(10);\n        }\n\n        return $name . '.' . $extension;\n    }\n\n    /**\n     * Checks if the image is a gif. Returns true if it is, else false.\n     */\n    protected function isGif(Image $image): bool\n    {\n        return strtolower(pathinfo($image->path, PATHINFO_EXTENSION)) === 'gif';\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @param Image $image\n     * @param int   $width\n     * @param int   $height\n     * @param bool  $keepRatio\n     *\n     * @throws Exception\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    public function getThumbnail(Image $image, $width = 220, $height = 220, $keepRatio = false)\n    {\n        if ($keepRatio && $this->isGif($image)) {\n            return $this->getPublicUrl($image->path);\n        }\n\n        $thumbDirName = '/' . ($keepRatio ? 'scaled-' : 'thumbs-') . $width . '-' . $height . '/';\n        $imagePath = $image->path;\n        $thumbFilePath = dirname($imagePath) . $thumbDirName . basename($imagePath);\n\n        if ($this->cache->has('images-' . $image->id . '-' . $thumbFilePath) && $this->cache->get('images-' . $thumbFilePath)) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $storage = $this->getStorage($image->type);\n        if ($storage->exists($this->adjustPathForStorageDisk($thumbFilePath, $image->type))) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $thumbData = $this->resizeImage($storage->get($this->adjustPathForStorageDisk($imagePath, $image->type)), $width, $height, $keepRatio);\n\n        $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($thumbFilePath, $image->type), $thumbData);\n        $this->cache->put('images-' . $image->id . '-' . $thumbFilePath, $thumbFilePath, 60 * 60 * 72);\n\n        return $this->getPublicUrl($thumbFilePath);\n    }\n\n    /**\n     * Resize image data.\n     *\n     * @param string $imageData\n     * @param int    $width\n     * @param int    $height\n     * @param bool   $keepRatio\n     *\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    protected function resizeImage(string $imageData, $width = 220, $height = null, bool $keepRatio = true)\n    {\n        try {\n            $thumb = $this->imageTool->make($imageData);\n        } catch (Exception $e) {\n            if ($e instanceof ErrorException || $e instanceof NotSupportedException) {\n                throw new ImageUploadException(trans('errors.cannot_create_thumbs'));\n            }\n\n            throw $e;\n        }\n\n        if ($keepRatio) {\n            $thumb->resize($width, $height, function ($constraint) {\n                $constraint->aspectRatio();\n                $constraint->upsize();\n            });\n        } else {\n            $thumb->fit($width, $height);\n        }\n\n        $thumbData = (string) $thumb->encode();\n\n        // Use original image data if we're keeping the ratio\n        // and the resizing does not save any space.\n        if ($keepRatio && strlen($thumbData) > strlen($imageData)) {\n            return $imageData;\n        }\n\n        return $thumbData;\n    }\n\n    /**\n     * Get the raw data content from an image.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getImageData(Image $image): string\n    {\n        $storage = $this->getStorage();\n        return $storage->get($this->adjustPathForStorageDisk($image->path, $image->type));\n    }\n\n    /**\n     * Destroy an image along with its revisions, thumbnails and remaining folders.\n     *\n     * @throws Exception\n     */\n    public function destroy(Image $image)\n    {\n        $this->destroyImagesFromPath($image->path, $image->type);\n        $image->delete();\n    }\n\n    /**\n     * Destroys an image at the given path.\n     * Searches for image thumbnails in addition to main provided path.\n     */\n    protected function destroyImagesFromPath(string $path, string $imageType): bool\n    {\n        $path = $this->adjustPathForStorageDisk($path, $imageType);\n        $storage = $this->getStorage($imageType);\n\n        $imageFolder = dirname($path);\n        $imageFileName = basename($path);\n        $allImages = collect($storage->allFiles($imageFolder));\n\n        // Delete image files\n        $imagesToDelete = $allImages->filter(function ($imagePath) use ($imageFileName) {\n            return basename($imagePath) === $imageFileName;\n        });\n        $storage->delete($imagesToDelete->all());\n\n        // Cleanup of empty folders\n        $foldersInvolved = array_merge([$imageFolder], $storage->directories($imageFolder));\n        foreach ($foldersInvolved as $directory) {\n            if ($this->isFolderEmpty($storage, $directory)) {\n                $storage->deleteDirectory($directory);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a folder is empty.\n     */\n    protected function isFolderEmpty(FileSystemInstance $storage, string $path): bool\n    {\n        $files = $storage->files($path);\n        $folders = $storage->directories($path);\n\n        return count($files) === 0 && count($folders) === 0;\n    }\n\n    /**\n     * Delete gallery and drawings that are not within HTML content of pages or page revisions.\n     * Checks based off of only the image name.\n     * Could be much improved to be more specific but kept it generic for now to be safe.\n     *\n     * Returns the path of the images that would be/have been deleted.\n     */\n    public function deleteUnusedImages(bool $checkRevisions = true, bool $dryRun = true)\n    {\n        $types = ['gallery', 'drawio'];\n        $deletedPaths = [];\n\n        $this->image->newQuery()->whereIn('type', $types)\n            ->chunk(1000, function ($images) use ($checkRevisions, &$deletedPaths, $dryRun) {\n                foreach ($images as $image) {\n                    $searchQuery = '%' . basename($image->path) . '%';\n                    $inPage = DB::table('pages')\n                            ->where('html', 'like', $searchQuery)->count() > 0;\n\n                    $inRevision = false;\n                    if ($checkRevisions) {\n                        $inRevision = DB::table('page_revisions')\n                                ->where('html', 'like', $searchQuery)->count() > 0;\n                    }\n\n                    if (!$inPage && !$inRevision) {\n                        $deletedPaths[] = $image->path;\n                        if (!$dryRun) {\n                            $this->destroy($image);\n                        }\n                    }\n                }\n            });\n\n        return $deletedPaths;\n    }\n\n    /**\n     * Convert an image URI to a Base64 encoded string.\n     * Attempts to convert the URL to a system storage url then\n     * fetch the data from the disk or storage location.\n     * Returns null if the image data cannot be fetched from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function imageUriToBase64(string $uri): ?string\n    {\n        $storagePath = $this->imageUrlToStoragePath($uri);\n        if (empty($uri) || is_null($storagePath)) {\n            return null;\n        }\n\n        $storagePath = $this->adjustPathForStorageDisk($storagePath);\n        $storage = $this->getStorage();\n        $imageData = null;\n        if ($storage->exists($storagePath)) {\n            $imageData = $storage->get($storagePath);\n        }\n\n        if (is_null($imageData)) {\n            return null;\n        }\n\n        $extension = pathinfo($uri, PATHINFO_EXTENSION);\n        if ($extension === 'svg') {\n            $extension = 'svg+xml';\n        }\n\n        return 'data:image/' . $extension . ';base64,' . base64_encode($imageData);\n    }\n\n    /**\n     * Get a storage path for the given image URL.\n     * Ensures the path will start with \"uploads/images\".\n     * Returns null if the url cannot be resolved to a local URL.\n     */\n    private function imageUrlToStoragePath(string $url): ?string\n    {\n        $url = ltrim(trim($url), '/');\n\n        // Handle potential relative paths\n        $isRelative = strpos($url, 'http') !== 0;\n        if ($isRelative) {\n            if (strpos(strtolower($url), 'uploads/images') === 0) {\n                return trim($url, '/');\n            }\n\n            return null;\n        }\n\n        // Handle local images based on paths on the same domain\n        $potentialHostPaths = [\n            url('uploads/images/'),\n            $this->getPublicUrl('/uploads/images/'),\n        ];\n\n        foreach ($potentialHostPaths as $potentialBasePath) {\n            $potentialBasePath = strtolower($potentialBasePath);\n            if (strpos(strtolower($url), $potentialBasePath) === 0) {\n                return 'uploads/images/' . trim(substr($url, strlen($potentialBasePath)), '/');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets a public facing url for an image by checking relevant environment variables.\n     * If s3-style store is in use it will default to guessing a public bucket URL.\n     */\n    private function getPublicUrl(string $filePath): string\n    {\n        if ($this->storageUrl === null) {\n            $storageUrl = config('filesystems.url');\n\n            // Get the standard public s3 url if s3 is set as storage type\n            // Uses the nice, short URL if bucket name has no periods in otherwise the longer\n            // region-based url will be used to prevent http issues.\n            if ($storageUrl == false && config('filesystems.images') === 's3') {\n                $storageDetails = config('filesystems.disks.s3');\n                if (strpos($storageDetails['bucket'], '.') === false) {\n                    $storageUrl = 'https://' . $storageDetails['bucket'] . '.s3.amazonaws.com';\n                } else {\n                    $storageUrl = 'https://s3-' . $storageDetails['region'] . '.amazonaws.com/' . $storageDetails['bucket'];\n                }\n            }\n            $this->storageUrl = $storageUrl;\n        }\n\n        $basePath = ($this->storageUrl == false) ? url('/') : $this->storageUrl;\n\n        return rtrim($basePath, '/') . $filePath;\n    }\n}\n"], "filenames": ["app/Config/filesystems.php", "app/Uploads/AttachmentService.php", "app/Uploads/ImageService.php"], "buggy_code_start_loc": [40, 11, 16], "buggy_code_end_loc": [43, 221, 390], "fixing_code_start_loc": [40, 12, 17], "fixing_code_end_loc": [48, 226, 419], "type": "CWE-22", "message": "bookstack is vulnerable to Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "other": {"cve": {"id": "CVE-2021-3874", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-15T14:15:07.757", "lastModified": "2021-10-20T19:40:39.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bookstack is vulnerable to Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"}, {"lang": "es", "value": "bookstack es vulnerable a una Limitaci\u00f3n Inapropiada de un nombre de ruta a un directorio restringido (\"Salto de Ruta\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bookstackapp:bookstack:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.08.5", "matchCriteriaId": "76DDD7E8-B040-4418-9FAA-B5195976C962"}]}]}], "references": [{"url": "https://github.com/bookstackapp/bookstack/commit/7224fbcc89f00f2b71644e36bb1b1d96addd1d5a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ac268a17-72b5-446f-a09a-9945ef58607a", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bookstackapp/bookstack/commit/7224fbcc89f00f2b71644e36bb1b1d96addd1d5a"}}