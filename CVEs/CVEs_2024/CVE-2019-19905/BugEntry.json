{"buggy_code": ["/* NetHack 3.6\tfiles.c\t$NHDT-Date: 1574116097 2019/11/18 22:28:17 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.272 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Derek S. Ray, 2015. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#define NEED_VARARGS\n\n#include \"hack.h\"\n#include \"dlb.h\"\n\n#ifdef TTY_GRAPHICS\n#include \"wintty.h\" /* more() */\n#endif\n\n#if (!defined(MAC) && !defined(O_WRONLY) && !defined(AZTEC_C)) \\\n    || defined(USE_FCNTL)\n#include <fcntl.h>\n#endif\n\n#include <errno.h>\n#ifdef _MSC_VER /* MSC 6.0 defines errno quite differently */\n#if (_MSC_VER >= 600)\n#define SKIP_ERRNO\n#endif\n#else\n#ifdef NHSTDC\n#define SKIP_ERRNO\n#endif\n#endif\n#ifndef SKIP_ERRNO\n#ifdef _DCC\nconst\n#endif\n    extern int errno;\n#endif\n\n#ifdef ZLIB_COMP /* RLC 09 Mar 1999: Support internal ZLIB */\n#include \"zlib.h\"\n#ifndef COMPRESS_EXTENSION\n#define COMPRESS_EXTENSION \".gz\"\n#endif\n#endif\n\n#if defined(UNIX) && defined(QT_GRAPHICS)\n#include <sys/types.h>\n#include <dirent.h>\n#include <stdlib.h>\n#endif\n\n#if defined(UNIX) || defined(VMS) || !defined(NO_SIGNAL)\n#include <signal.h>\n#endif\n\n#if defined(MSDOS) || defined(OS2) || defined(TOS) || defined(WIN32)\n#ifndef __DJGPP__\n#include <sys\\stat.h>\n#else\n#include <sys/stat.h>\n#endif\n#endif\n#ifndef O_BINARY /* used for micros, no-op for others */\n#define O_BINARY 0\n#endif\n\n#ifdef PREFIXES_IN_USE\n#define FQN_NUMBUF 4\nstatic char fqn_filename_buffer[FQN_NUMBUF][FQN_MAX_FILENAME];\n#endif\n\n#if !defined(MFLOPPY) && !defined(VMS) && !defined(WIN32)\nchar bones[] = \"bonesnn.xxx\";\nchar lock[PL_NSIZ + 14] = \"1lock\"; /* long enough for uid+name+.99 */\n#else\n#if defined(MFLOPPY)\nchar bones[FILENAME]; /* pathname of bones files */\nchar lock[FILENAME];  /* pathname of level files */\n#endif\n#if defined(VMS)\nchar bones[] = \"bonesnn.xxx;1\";\nchar lock[PL_NSIZ + 17] = \"1lock\"; /* long enough for _uid+name+.99;1 */\n#endif\n#if defined(WIN32)\nchar bones[] = \"bonesnn.xxx\";\nchar lock[PL_NSIZ + 25]; /* long enough for username+-+name+.99 */\n#endif\n#endif\n\n#if defined(UNIX) || defined(__BEOS__)\n#define SAVESIZE (PL_NSIZ + 13) /* save/99999player.e */\n#else\n#ifdef VMS\n#define SAVESIZE (PL_NSIZ + 22) /* [.save]<uid>player.e;1 */\n#else\n#if defined(WIN32)\n#define SAVESIZE (PL_NSIZ + 40) /* username-player.NetHack-saved-game */\n#else\n#define SAVESIZE FILENAME /* from macconf.h or pcconf.h */\n#endif\n#endif\n#endif\n\n#if !defined(SAVE_EXTENSION)\n#ifdef MICRO\n#define SAVE_EXTENSION \".sav\"\n#endif\n#ifdef WIN32\n#define SAVE_EXTENSION \".NetHack-saved-game\"\n#endif\n#endif\n\nchar SAVEF[SAVESIZE]; /* holds relative path of save file from playground */\n#ifdef MICRO\nchar SAVEP[SAVESIZE]; /* holds path of directory for save file */\n#endif\n\n#ifdef HOLD_LOCKFILE_OPEN\nstruct level_ftrack {\n    int init;\n    int fd;    /* file descriptor for level file     */\n    int oflag; /* open flags                         */\n    boolean nethack_thinks_it_is_open; /* Does NetHack think it's open? */\n} lftrack;\n#if defined(WIN32)\n#include <share.h>\n#endif\n#endif /*HOLD_LOCKFILE_OPEN*/\n\n#define WIZKIT_MAX 128\nstatic char wizkit[WIZKIT_MAX];\nSTATIC_DCL FILE *NDECL(fopen_wizkit_file);\nSTATIC_DCL void FDECL(wizkit_addinv, (struct obj *));\n\n#ifdef AMIGA\nextern char PATH[]; /* see sys/amiga/amidos.c */\nextern char bbs_id[];\nstatic int lockptr;\n#ifdef __SASC_60\n#include <proto/dos.h>\n#endif\n\n#include <libraries/dos.h>\nextern void FDECL(amii_set_text_font, (char *, int));\n#endif\n\n#if defined(WIN32) || defined(MSDOS)\nstatic int lockptr;\n#ifdef MSDOS\n#define Delay(a) msleep(a)\n#endif\n#define Close close\n#ifndef WIN_CE\n#define DeleteFile unlink\n#endif\n#ifdef WIN32\n/*from windmain.c */\nextern char *FDECL(translate_path_variables, (const char *, char *));\n#endif\n#endif\n\n#ifdef MAC\n#undef unlink\n#define unlink macunlink\n#endif\n\n#if (defined(macintosh) && (defined(__SC__) || defined(__MRC__))) \\\n    || defined(__MWERKS__)\n#define PRAGMA_UNUSED\n#endif\n\n#ifdef USER_SOUNDS\nextern char *sounddir;\n#endif\n\nextern int n_dgns; /* from dungeon.c */\n\n#if defined(UNIX) && defined(QT_GRAPHICS)\n#define SELECTSAVED\n#endif\n\n#ifdef SELECTSAVED\nSTATIC_PTR int FDECL(CFDECLSPEC strcmp_wrap, (const void *, const void *));\n#endif\nSTATIC_DCL char *FDECL(set_bonesfile_name, (char *, d_level *));\nSTATIC_DCL char *NDECL(set_bonestemp_name);\n#ifdef COMPRESS\nSTATIC_DCL void FDECL(redirect, (const char *, const char *, FILE *,\n                                 BOOLEAN_P));\n#endif\n#if defined(COMPRESS) || defined(ZLIB_COMP)\nSTATIC_DCL void FDECL(docompress_file, (const char *, BOOLEAN_P));\n#endif\n#if defined(ZLIB_COMP)\nSTATIC_DCL boolean FDECL(make_compressed_name, (const char *, char *));\n#endif\n#ifndef USE_FCNTL\nSTATIC_DCL char *FDECL(make_lockname, (const char *, char *));\n#endif\nSTATIC_DCL void FDECL(set_configfile_name, (const char *));\nSTATIC_DCL FILE *FDECL(fopen_config_file, (const char *, int));\nSTATIC_DCL int FDECL(get_uchars, (char *, uchar *, BOOLEAN_P,\n                                  int, const char *));\nboolean FDECL(proc_wizkit_line, (char *));\nboolean FDECL(parse_config_line, (char *));\nSTATIC_DCL boolean FDECL(parse_conf_file, (FILE *, boolean (*proc)(char *)));\nSTATIC_DCL FILE *NDECL(fopen_sym_file);\nboolean FDECL(proc_symset_line, (char *));\nSTATIC_DCL void FDECL(set_symhandling, (char *, int));\n#ifdef NOCWD_ASSUMPTIONS\nSTATIC_DCL void FDECL(adjust_prefix, (char *, int));\n#endif\nSTATIC_DCL boolean FDECL(config_error_nextline, (const char *));\nSTATIC_DCL void NDECL(free_config_sections);\nSTATIC_DCL char *FDECL(choose_random_part, (char *, CHAR_P));\nSTATIC_DCL boolean FDECL(is_config_section, (const char *));\nSTATIC_DCL boolean FDECL(handle_config_section, (char *));\n#ifdef SELF_RECOVER\nSTATIC_DCL boolean FDECL(copy_bytes, (int, int));\n#endif\n#ifdef HOLD_LOCKFILE_OPEN\nSTATIC_DCL int FDECL(open_levelfile_exclusively, (const char *, int, int));\n#endif\n\n\nstatic char *config_section_chosen = (char *) 0;\nstatic char *config_section_current = (char *) 0;\n\n/*\n * fname_encode()\n *\n *   Args:\n *      legal       zero-terminated list of acceptable file name characters\n *      quotechar   lead-in character used to quote illegal characters as\n *                  hex digits\n *      s           string to encode\n *      callerbuf   buffer to house result\n *      bufsz       size of callerbuf\n *\n *   Notes:\n *      The hex digits 0-9 and A-F are always part of the legal set due to\n *      their use in the encoding scheme, even if not explicitly included in\n *      'legal'.\n *\n *   Sample:\n *      The following call:\n *  (void)fname_encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n *                     '%', \"This is a % test!\", buf, 512);\n *      results in this encoding:\n *          \"This%20is%20a%20%25%20test%21\"\n */\nchar *\nfname_encode(legal, quotechar, s, callerbuf, bufsz)\nconst char *legal;\nchar quotechar;\nchar *s, *callerbuf;\nint bufsz;\n{\n    char *sp, *op;\n    int cnt = 0;\n    static char hexdigits[] = \"0123456789ABCDEF\";\n\n    sp = s;\n    op = callerbuf;\n    *op = '\\0';\n\n    while (*sp) {\n        /* Do we have room for one more character or encoding? */\n        if ((bufsz - cnt) <= 4)\n            return callerbuf;\n\n        if (*sp == quotechar) {\n            (void) sprintf(op, \"%c%02X\", quotechar, *sp);\n            op += 3;\n            cnt += 3;\n        } else if ((index(legal, *sp) != 0) || (index(hexdigits, *sp) != 0)) {\n            *op++ = *sp;\n            *op = '\\0';\n            cnt++;\n        } else {\n            (void) sprintf(op, \"%c%02X\", quotechar, *sp);\n            op += 3;\n            cnt += 3;\n        }\n        sp++;\n    }\n    return callerbuf;\n}\n\n/*\n * fname_decode()\n *\n *   Args:\n *      quotechar   lead-in character used to quote illegal characters as\n *                  hex digits\n *      s           string to decode\n *      callerbuf   buffer to house result\n *      bufsz       size of callerbuf\n */\nchar *\nfname_decode(quotechar, s, callerbuf, bufsz)\nchar quotechar;\nchar *s, *callerbuf;\nint bufsz;\n{\n    char *sp, *op;\n    int k, calc, cnt = 0;\n    static char hexdigits[] = \"0123456789ABCDEF\";\n\n    sp = s;\n    op = callerbuf;\n    *op = '\\0';\n    calc = 0;\n\n    while (*sp) {\n        /* Do we have room for one more character? */\n        if ((bufsz - cnt) <= 2)\n            return callerbuf;\n        if (*sp == quotechar) {\n            sp++;\n            for (k = 0; k < 16; ++k)\n                if (*sp == hexdigits[k])\n                    break;\n            if (k >= 16)\n                return callerbuf; /* impossible, so bail */\n            calc = k << 4;\n            sp++;\n            for (k = 0; k < 16; ++k)\n                if (*sp == hexdigits[k])\n                    break;\n            if (k >= 16)\n                return callerbuf; /* impossible, so bail */\n            calc += k;\n            sp++;\n            *op++ = calc;\n            *op = '\\0';\n        } else {\n            *op++ = *sp++;\n            *op = '\\0';\n        }\n        cnt++;\n    }\n    return callerbuf;\n}\n\n#ifdef PREFIXES_IN_USE\n#define UNUSED_if_not_PREFIXES_IN_USE /*empty*/\n#else\n#define UNUSED_if_not_PREFIXES_IN_USE UNUSED\n#endif\n\n/*ARGSUSED*/\nconst char *\nfqname(basenam, whichprefix, buffnum)\nconst char *basenam;\nint whichprefix UNUSED_if_not_PREFIXES_IN_USE;\nint buffnum UNUSED_if_not_PREFIXES_IN_USE;\n{\n#ifdef PREFIXES_IN_USE\n    char *bufptr;\n#endif\n#ifdef WIN32\n    char tmpbuf[BUFSZ];\n#endif\n\n#ifndef PREFIXES_IN_USE\n    return basenam;\n#else\n    if (!basenam || whichprefix < 0 || whichprefix >= PREFIX_COUNT)\n        return basenam;\n    if (!fqn_prefix[whichprefix])\n        return basenam;\n    if (buffnum < 0 || buffnum >= FQN_NUMBUF) {\n        impossible(\"Invalid fqn_filename_buffer specified: %d\", buffnum);\n        buffnum = 0;\n    }\n    bufptr = fqn_prefix[whichprefix];\n#ifdef WIN32\n    if (strchr(fqn_prefix[whichprefix], '%')\n        || strchr(fqn_prefix[whichprefix], '~'))\n        bufptr = translate_path_variables(fqn_prefix[whichprefix], tmpbuf);\n#endif\n    if (strlen(bufptr) + strlen(basenam) >= FQN_MAX_FILENAME) {\n        impossible(\"fqname too long: %s + %s\", bufptr, basenam);\n        return basenam; /* XXX */\n    }\n    Strcpy(fqn_filename_buffer[buffnum], bufptr);\n    return strcat(fqn_filename_buffer[buffnum], basenam);\n#endif /* !PREFIXES_IN_USE */\n}\n\nint\nvalidate_prefix_locations(reasonbuf)\nchar *reasonbuf; /* reasonbuf must be at least BUFSZ, supplied by caller */\n{\n#if defined(NOCWD_ASSUMPTIONS)\n    FILE *fp;\n    const char *filename;\n    int prefcnt, failcount = 0;\n    char panicbuf1[BUFSZ], panicbuf2[BUFSZ];\n    const char *details;\n#endif\n\n    if (reasonbuf)\n        reasonbuf[0] = '\\0';\n#if defined(NOCWD_ASSUMPTIONS)\n    for (prefcnt = 1; prefcnt < PREFIX_COUNT; prefcnt++) {\n        /* don't test writing to configdir or datadir; they're readonly */\n        if (prefcnt == SYSCONFPREFIX || prefcnt == CONFIGPREFIX\n            || prefcnt == DATAPREFIX)\n            continue;\n        filename = fqname(\"validate\", prefcnt, 3);\n        if ((fp = fopen(filename, \"w\"))) {\n            fclose(fp);\n            (void) unlink(filename);\n        } else {\n            if (reasonbuf) {\n                if (failcount)\n                    Strcat(reasonbuf, \", \");\n                Strcat(reasonbuf, fqn_prefix_names[prefcnt]);\n            }\n            /* the paniclog entry gets the value of errno as well */\n            Sprintf(panicbuf1, \"Invalid %s\", fqn_prefix_names[prefcnt]);\n#if defined(NHSTDC) && !defined(NOTSTDC)\n            if (!(details = strerror(errno)))\n#endif\n                details = \"\";\n            Sprintf(panicbuf2, \"\\\"%s\\\", (%d) %s\", fqn_prefix[prefcnt], errno,\n                    details);\n            paniclog(panicbuf1, panicbuf2);\n            failcount++;\n        }\n    }\n    if (failcount)\n        return 0;\n    else\n#endif\n        return 1;\n}\n\n/* fopen a file, with OS-dependent bells and whistles */\n/* NOTE: a simpler version of this routine also exists in util/dlb_main.c */\nFILE *\nfopen_datafile(filename, mode, prefix)\nconst char *filename, *mode;\nint prefix;\n{\n    FILE *fp;\n\n    filename = fqname(filename, prefix, prefix == TROUBLEPREFIX ? 3 : 0);\n    fp = fopen(filename, mode);\n    return fp;\n}\n\n/* ----------  BEGIN LEVEL FILE HANDLING ----------- */\n\n#ifdef MFLOPPY\n/* Set names for bones[] and lock[] */\nvoid\nset_lock_and_bones()\n{\n    if (!ramdisk) {\n        Strcpy(levels, permbones);\n        Strcpy(bones, permbones);\n    }\n    append_slash(permbones);\n    append_slash(levels);\n#ifdef AMIGA\n    strncat(levels, bbs_id, PATHLEN);\n#endif\n    append_slash(bones);\n    Strcat(bones, \"bonesnn.*\");\n    Strcpy(lock, levels);\n#ifndef AMIGA\n    Strcat(lock, alllevels);\n#endif\n    return;\n}\n#endif /* MFLOPPY */\n\n/* Construct a file name for a level-type file, which is of the form\n * something.level (with any old level stripped off).\n * This assumes there is space on the end of 'file' to append\n * a two digit number.  This is true for 'level'\n * but be careful if you use it for other things -dgk\n */\nvoid\nset_levelfile_name(file, lev)\nchar *file;\nint lev;\n{\n    char *tf;\n\n    tf = rindex(file, '.');\n    if (!tf)\n        tf = eos(file);\n    Sprintf(tf, \".%d\", lev);\n#ifdef VMS\n    Strcat(tf, \";1\");\n#endif\n    return;\n}\n\nint\ncreate_levelfile(lev, errbuf)\nint lev;\nchar errbuf[];\n{\n    int fd;\n    const char *fq_lock;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    set_levelfile_name(lock, lev);\n    fq_lock = fqname(lock, LEVELPREFIX, 0);\n\n#if defined(MICRO) || defined(WIN32)\n/* Use O_TRUNC to force the file to be shortened if it already\n * exists and is currently longer.\n */\n#ifdef HOLD_LOCKFILE_OPEN\n    if (lev == 0)\n        fd = open_levelfile_exclusively(\n            fq_lock, lev, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY);\n    else\n#endif\n        fd = open(fq_lock, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(fq_lock, LEVL_TYPE);\n#else\n    fd = creat(fq_lock, FCMASK);\n#endif\n#endif /* MICRO || WIN32 */\n\n    if (fd >= 0)\n        level_info[lev].flags |= LFILE_EXISTS;\n    else if (errbuf) /* failure explanation */\n        Sprintf(errbuf, \"Cannot create file \\\"%s\\\" for level %d (errno %d).\",\n                lock, lev, errno);\n\n    return fd;\n}\n\nint\nopen_levelfile(lev, errbuf)\nint lev;\nchar errbuf[];\n{\n    int fd;\n    const char *fq_lock;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    set_levelfile_name(lock, lev);\n    fq_lock = fqname(lock, LEVELPREFIX, 0);\n#ifdef MFLOPPY\n    /* If not currently accessible, swap it in. */\n    if (level_info[lev].where != ACTIVE)\n        swapin_file(lev);\n#endif\n#ifdef MAC\n    fd = macopen(fq_lock, O_RDONLY | O_BINARY, LEVL_TYPE);\n#else\n#ifdef HOLD_LOCKFILE_OPEN\n    if (lev == 0)\n        fd = open_levelfile_exclusively(fq_lock, lev, O_RDONLY | O_BINARY);\n    else\n#endif\n        fd = open(fq_lock, O_RDONLY | O_BINARY, 0);\n#endif\n\n    /* for failure, return an explanation that our caller can use;\n       settle for `lock' instead of `fq_lock' because the latter\n       might end up being too big for nethack's BUFSZ */\n    if (fd < 0 && errbuf)\n        Sprintf(errbuf, \"Cannot open file \\\"%s\\\" for level %d (errno %d).\",\n                lock, lev, errno);\n\n    return fd;\n}\n\nvoid\ndelete_levelfile(lev)\nint lev;\n{\n    /*\n     * Level 0 might be created by port specific code that doesn't\n     * call create_levfile(), so always assume that it exists.\n     */\n    if (lev == 0 || (level_info[lev].flags & LFILE_EXISTS)) {\n        set_levelfile_name(lock, lev);\n#ifdef HOLD_LOCKFILE_OPEN\n        if (lev == 0)\n            really_close();\n#endif\n        (void) unlink(fqname(lock, LEVELPREFIX, 0));\n        level_info[lev].flags &= ~LFILE_EXISTS;\n    }\n}\n\nvoid\nclearlocks()\n{\n#ifdef HANGUPHANDLING\n    if (program_state.preserve_locks)\n        return;\n#endif\n#if !defined(PC_LOCKING) && defined(MFLOPPY) && !defined(AMIGA)\n    eraseall(levels, alllevels);\n    if (ramdisk)\n        eraseall(permbones, alllevels);\n#else\n    {\n        register int x;\n\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, SIG_IGN);\n#endif\n#if defined(UNIX) || defined(VMS)\n        sethanguphandler((void FDECL((*), (int) )) SIG_IGN);\n#endif\n        /* can't access maxledgerno() before dungeons are created -dlc */\n        for (x = (n_dgns ? maxledgerno() : 0); x >= 0; x--)\n            delete_levelfile(x); /* not all levels need be present */\n    }\n#endif /* ?PC_LOCKING,&c */\n}\n\n#if defined(SELECTSAVED)\n/* qsort comparison routine */\nSTATIC_OVL int CFDECLSPEC\nstrcmp_wrap(p, q)\nconst void *p;\nconst void *q;\n{\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    return strncasecmp(*(char **) p, *(char **) q, 16);\n#else\n    return strncmpi(*(char **) p, *(char **) q, 16);\n#endif\n}\n#endif\n\n#ifdef HOLD_LOCKFILE_OPEN\nSTATIC_OVL int\nopen_levelfile_exclusively(name, lev, oflag)\nconst char *name;\nint lev, oflag;\n{\n    int reslt, fd;\n\n    if (!lftrack.init) {\n        lftrack.init = 1;\n        lftrack.fd = -1;\n    }\n    if (lftrack.fd >= 0) {\n        /* check for compatible access */\n        if (lftrack.oflag == oflag) {\n            fd = lftrack.fd;\n            reslt = lseek(fd, 0L, SEEK_SET);\n            if (reslt == -1L)\n                panic(\"open_levelfile_exclusively: lseek failed %d\", errno);\n            lftrack.nethack_thinks_it_is_open = TRUE;\n        } else {\n            really_close();\n            fd = sopen(name, oflag, SH_DENYRW, FCMASK);\n            lftrack.fd = fd;\n            lftrack.oflag = oflag;\n            lftrack.nethack_thinks_it_is_open = TRUE;\n        }\n    } else {\n        fd = sopen(name, oflag, SH_DENYRW, FCMASK);\n        lftrack.fd = fd;\n        lftrack.oflag = oflag;\n        if (fd >= 0)\n            lftrack.nethack_thinks_it_is_open = TRUE;\n    }\n    return fd;\n}\n\nvoid\nreally_close()\n{\n    int fd;\n\n    if (lftrack.init) {\n        fd = lftrack.fd;\n\n        lftrack.nethack_thinks_it_is_open = FALSE;\n        lftrack.fd = -1;\n        lftrack.oflag = 0;\n        if (fd != -1)\n            (void) close(fd);\n    }\n    return;\n}\n\nint\nnhclose(fd)\nint fd;\n{\n    if (lftrack.fd == fd) {\n        really_close(); /* close it, but reopen it to hold it */\n        fd = open_levelfile(0, (char *) 0);\n        lftrack.nethack_thinks_it_is_open = FALSE;\n        return 0;\n    }\n    return close(fd);\n}\n#else /* !HOLD_LOCKFILE_OPEN */\n\nint\nnhclose(fd)\nint fd;\n{\n    return close(fd);\n}\n#endif /* ?HOLD_LOCKFILE_OPEN */\n\n/* ----------  END LEVEL FILE HANDLING ----------- */\n\n/* ----------  BEGIN BONES FILE HANDLING ----------- */\n\n/* set up \"file\" to be file name for retrieving bones, and return a\n * bonesid to be read/written in the bones file.\n */\nSTATIC_OVL char *\nset_bonesfile_name(file, lev)\nchar *file;\nd_level *lev;\n{\n    s_level *sptr;\n    char *dptr;\n\n    /*\n     * \"bonD0.nn\"   = bones for level nn in the main dungeon;\n     * \"bonM0.T\"    = bones for Minetown;\n     * \"bonQBar.n\"  = bones for level n in the Barbarian quest;\n     * \"bon3D0.nn\"  = \\\n     * \"bon3M0.T\"   =  > same as above, but for bones pool #3.\n     * \"bon3QBar.n\" = /\n     *\n     * Return value for content validation skips \"bon\" and the\n     * pool number (if present), making it feasible for the admin\n     * to manually move a bones file from one pool to another by\n     * renaming it.\n     */\n    Strcpy(file, \"bon\");\n#ifdef SYSCF\n    if (sysopt.bones_pools > 1) {\n        unsigned poolnum = min((unsigned) sysopt.bones_pools, 10);\n\n        poolnum = (unsigned) ubirthday % poolnum; /* 0..9 */\n        Sprintf(eos(file), \"%u\", poolnum);\n    }\n#endif\n    dptr = eos(file); /* this used to be after the following Sprintf()\n                         and the return value was (dptr - 2) */\n    /* when this naming scheme was adopted, 'filecode' was one letter;\n       3.3.0 turned it into a three letter string (via roles[] in role.c);\n       from that version through 3.6.0, 'dptr' pointed past the filecode\n       and the return value of (dptr - 2)  was wrong for bones produced\n       in the quest branch, skipping the boneid character 'Q' and the\n       first letter of the role's filecode; bones loading still worked\n       because the bonesid used for validation had the same error */\n    Sprintf(dptr, \"%c%s\", dungeons[lev->dnum].boneid,\n            In_quest(lev) ? urole.filecode : \"0\");\n    if ((sptr = Is_special(lev)) != 0)\n        Sprintf(eos(dptr), \".%c\", sptr->boneid);\n    else\n        Sprintf(eos(dptr), \".%d\", lev->dlevel);\n#ifdef VMS\n    Strcat(dptr, \";1\");\n#endif\n    return dptr;\n}\n\n/* set up temporary file name for writing bones, to avoid another game's\n * trying to read from an uncompleted bones file.  we want an uncontentious\n * name, so use one in the namespace reserved for this game's level files.\n * (we are not reading or writing level files while writing bones files, so\n * the same array may be used instead of copying.)\n */\nSTATIC_OVL char *\nset_bonestemp_name()\n{\n    char *tf;\n\n    tf = rindex(lock, '.');\n    if (!tf)\n        tf = eos(lock);\n    Sprintf(tf, \".bn\");\n#ifdef VMS\n    Strcat(tf, \";1\");\n#endif\n    return lock;\n}\n\nint\ncreate_bonesfile(lev, bonesid, errbuf)\nd_level *lev;\nchar **bonesid;\nchar errbuf[];\n{\n    const char *file;\n    int fd;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    *bonesid = set_bonesfile_name(bones, lev);\n    file = set_bonestemp_name();\n    file = fqname(file, BONESPREFIX, 0);\n\n#if defined(MICRO) || defined(WIN32)\n    /* Use O_TRUNC to force the file to be shortened if it already\n     * exists and is currently longer.\n     */\n    fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(file, BONE_TYPE);\n#else\n    fd = creat(file, FCMASK);\n#endif\n#endif\n    if (fd < 0 && errbuf) /* failure explanation */\n        Sprintf(errbuf, \"Cannot create bones \\\"%s\\\", id %s (errno %d).\", lock,\n                *bonesid, errno);\n\n#if defined(VMS) && !defined(SECURE)\n    /*\n       Re-protect bones file with world:read+write+execute+delete access.\n       umask() doesn't seem very reliable; also, vaxcrtl won't let us set\n       delete access without write access, which is what's really wanted.\n       Can't simply create it with the desired protection because creat\n       ANDs the mask with the user's default protection, which usually\n       denies some or all access to world.\n     */\n    (void) chmod(file, FCMASK | 007); /* allow other users full access */\n#endif /* VMS && !SECURE */\n\n    return fd;\n}\n\n#ifdef MFLOPPY\n/* remove partial bonesfile in process of creation */\nvoid\ncancel_bonesfile()\n{\n    const char *tempname;\n\n    tempname = set_bonestemp_name();\n    tempname = fqname(tempname, BONESPREFIX, 0);\n    (void) unlink(tempname);\n}\n#endif /* MFLOPPY */\n\n/* move completed bones file to proper name */\nvoid\ncommit_bonesfile(lev)\nd_level *lev;\n{\n    const char *fq_bones, *tempname;\n    int ret;\n\n    (void) set_bonesfile_name(bones, lev);\n    fq_bones = fqname(bones, BONESPREFIX, 0);\n    tempname = set_bonestemp_name();\n    tempname = fqname(tempname, BONESPREFIX, 1);\n\n#if (defined(SYSV) && !defined(SVR4)) || defined(GENIX)\n    /* old SYSVs don't have rename.  Some SVR3's may, but since they\n     * also have link/unlink, it doesn't matter. :-)\n     */\n    (void) unlink(fq_bones);\n    ret = link(tempname, fq_bones);\n    ret += unlink(tempname);\n#else\n    ret = rename(tempname, fq_bones);\n#endif\n    if (wizard && ret != 0)\n        pline(\"couldn't rename %s to %s.\", tempname, fq_bones);\n}\n\nint\nopen_bonesfile(lev, bonesid)\nd_level *lev;\nchar **bonesid;\n{\n    const char *fq_bones;\n    int fd;\n\n    *bonesid = set_bonesfile_name(bones, lev);\n    fq_bones = fqname(bones, BONESPREFIX, 0);\n    nh_uncompress(fq_bones); /* no effect if nonexistent */\n#ifdef MAC\n    fd = macopen(fq_bones, O_RDONLY | O_BINARY, BONE_TYPE);\n#else\n    fd = open(fq_bones, O_RDONLY | O_BINARY, 0);\n#endif\n    return fd;\n}\n\nint\ndelete_bonesfile(lev)\nd_level *lev;\n{\n    (void) set_bonesfile_name(bones, lev);\n    return !(unlink(fqname(bones, BONESPREFIX, 0)) < 0);\n}\n\n/* assume we're compressing the recently read or created bonesfile, so the\n * file name is already set properly */\nvoid\ncompress_bonesfile()\n{\n    nh_compress(fqname(bones, BONESPREFIX, 0));\n}\n\n/* ----------  END BONES FILE HANDLING ----------- */\n\n/* ----------  BEGIN SAVE FILE HANDLING ----------- */\n\n/* set savefile name in OS-dependent manner from pre-existing plname,\n * avoiding troublesome characters */\nvoid\nset_savefile_name(regularize_it)\nboolean regularize_it;\n{\n#ifdef VMS\n    Sprintf(SAVEF, \"[.save]%d%s\", getuid(), plname);\n    if (regularize_it)\n        regularize(SAVEF + 7);\n    Strcat(SAVEF, \";1\");\n#else\n#if defined(MICRO)\n    Strcpy(SAVEF, SAVEP);\n#ifdef AMIGA\n    strncat(SAVEF, bbs_id, PATHLEN);\n#endif\n    {\n        int i = strlen(SAVEP);\n#ifdef AMIGA\n        /* plname has to share space with SAVEP and \".sav\" */\n        (void) strncat(SAVEF, plname, FILENAME - i - 4);\n#else\n        (void) strncat(SAVEF, plname, 8);\n#endif\n        if (regularize_it)\n            regularize(SAVEF + i);\n    }\n    Strcat(SAVEF, SAVE_EXTENSION);\n#else\n#if defined(WIN32)\n    {\n        static const char okchars[] =\n            \"*ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-.\";\n        const char *legal = okchars;\n        char fnamebuf[BUFSZ], encodedfnamebuf[BUFSZ];\n\n        /* Obtain the name of the logged on user and incorporate\n         * it into the name. */\n        Sprintf(fnamebuf, \"%s\", plname);\n        if (regularize_it)\n            ++legal; /* skip '*' wildcard character */\n        (void) fname_encode(legal, '%', fnamebuf, encodedfnamebuf, BUFSZ);\n        Sprintf(SAVEF, \"%s%s\", encodedfnamebuf, SAVE_EXTENSION);\n    }\n#else  /* not VMS or MICRO or WIN32 */\n    Sprintf(SAVEF, \"save/%d%s\", (int) getuid(), plname);\n    if (regularize_it)\n        regularize(SAVEF + 5); /* avoid . or / in name */\n#endif /* WIN32 */\n#endif /* MICRO */\n#endif /* VMS   */\n}\n\n#ifdef INSURANCE\nvoid\nsave_savefile_name(fd)\nint fd;\n{\n    (void) write(fd, (genericptr_t) SAVEF, sizeof(SAVEF));\n}\n#endif\n\n#ifndef MICRO\n/* change pre-existing savefile name to indicate an error savefile */\nvoid\nset_error_savefile()\n{\n#ifdef VMS\n    {\n        char *semi_colon = rindex(SAVEF, ';');\n\n        if (semi_colon)\n            *semi_colon = '\\0';\n    }\n    Strcat(SAVEF, \".e;1\");\n#else\n#ifdef MAC\n    Strcat(SAVEF, \"-e\");\n#else\n    Strcat(SAVEF, \".e\");\n#endif\n#endif\n}\n#endif\n\n/* create save file, overwriting one if it already exists */\nint\ncreate_savefile()\n{\n    const char *fq_save;\n    int fd;\n\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n#if defined(MICRO) || defined(WIN32)\n    fd = open(fq_save, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(fq_save, SAVE_TYPE);\n#else\n    fd = creat(fq_save, FCMASK);\n#endif\n#if defined(VMS) && !defined(SECURE)\n    /*\n       Make sure the save file is owned by the current process.  That's\n       the default for non-privileged users, but for priv'd users the\n       file will be owned by the directory's owner instead of the user.\n    */\n#undef getuid\n    (void) chown(fq_save, getuid(), getgid());\n#define getuid() vms_getuid()\n#endif /* VMS && !SECURE */\n#endif /* MICRO */\n\n    return fd;\n}\n\n/* open savefile for reading */\nint\nopen_savefile()\n{\n    const char *fq_save;\n    int fd;\n\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n#ifdef MAC\n    fd = macopen(fq_save, O_RDONLY | O_BINARY, SAVE_TYPE);\n#else\n    fd = open(fq_save, O_RDONLY | O_BINARY, 0);\n#endif\n    return fd;\n}\n\n/* delete savefile */\nint\ndelete_savefile()\n{\n    (void) unlink(fqname(SAVEF, SAVEPREFIX, 0));\n    return 0; /* for restore_saved_game() (ex-xxxmain.c) test */\n}\n\n/* try to open up a save file and prepare to restore it */\nint\nrestore_saved_game()\n{\n    const char *fq_save;\n    int fd;\n\n    reset_restpref();\n    set_savefile_name(TRUE);\n#ifdef MFLOPPY\n    if (!saveDiskPrompt(1))\n        return -1;\n#endif /* MFLOPPY */\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n\n    nh_uncompress(fq_save);\n    if ((fd = open_savefile()) < 0)\n        return fd;\n\n    if (validate(fd, fq_save) != 0) {\n        (void) nhclose(fd), fd = -1;\n        (void) delete_savefile();\n    }\n    return fd;\n}\n\n#if defined(SELECTSAVED)\nchar *\nplname_from_file(filename)\nconst char *filename;\n{\n    int fd;\n    char *result = 0;\n\n    Strcpy(SAVEF, filename);\n#ifdef COMPRESS_EXTENSION\n    SAVEF[strlen(SAVEF) - strlen(COMPRESS_EXTENSION)] = '\\0';\n#endif\n    nh_uncompress(SAVEF);\n    if ((fd = open_savefile()) >= 0) {\n        if (validate(fd, filename) == 0) {\n            char tplname[PL_NSIZ];\n            get_plname_from_file(fd, tplname);\n            result = dupstr(tplname);\n        }\n        (void) nhclose(fd);\n    }\n    nh_compress(SAVEF);\n\n    return result;\n#if 0\n/* --------- obsolete - used to be ifndef STORE_PLNAME_IN_FILE ----*/\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    /* Name not stored in save file, so we have to extract it from\n       the filename, which loses information\n       (eg. \"/\", \"_\", and \".\" characters are lost. */\n    int k;\n    int uid;\n    char name[64]; /* more than PL_NSIZ */\n#ifdef COMPRESS_EXTENSION\n#define EXTSTR COMPRESS_EXTENSION\n#else\n#define EXTSTR \"\"\n#endif\n\n    if ( sscanf( filename, \"%*[^/]/%d%63[^.]\" EXTSTR, &uid, name ) == 2 ) {\n#undef EXTSTR\n        /* \"_\" most likely means \" \", which certainly looks nicer */\n        for (k=0; name[k]; k++)\n            if ( name[k] == '_' )\n                name[k] = ' ';\n        return dupstr(name);\n    } else\n#endif /* UNIX && QT_GRAPHICS */\n    {\n        return 0;\n    }\n/* --------- end of obsolete code ----*/\n#endif /* 0 - WAS STORE_PLNAME_IN_FILE*/\n}\n#endif /* defined(SELECTSAVED) */\n\nchar **\nget_saved_games()\n{\n#if defined(SELECTSAVED)\n    int n, j = 0;\n    char **result = 0;\n#ifdef WIN32\n    {\n        char *foundfile;\n        const char *fq_save;\n        const char *fq_new_save;\n        const char *fq_old_save;\n        char **files = 0;\n        int i;\n\n        Strcpy(plname, \"*\");\n        set_savefile_name(FALSE);\n#if defined(ZLIB_COMP)\n        Strcat(SAVEF, COMPRESS_EXTENSION);\n#endif\n        fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n\n        n = 0;\n        foundfile = foundfile_buffer();\n        if (findfirst((char *) fq_save)) {\n            do {\n                ++n;\n            } while (findnext());\n        }\n\n        if (n > 0) {\n            files = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) files, 0, (n + 1) * sizeof(char *));\n            if (findfirst((char *) fq_save)) {\n                i = 0;\n                do {\n                    files[i++] = strdup(foundfile);\n                } while (findnext());\n            }\n        }\n\n        if (n > 0) {\n            result = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) result, 0, (n + 1) * sizeof(char *));\n            for(i = 0; i < n; i++) {\n                char *r;\n                r = plname_from_file(files[i]);\n\n                if (r) {\n\n                    /* rename file if it is not named as expected */\n                    Strcpy(plname, r);\n                    set_savefile_name(FALSE);\n                    fq_new_save = fqname(SAVEF, SAVEPREFIX, 0);\n                    fq_old_save = fqname(files[i], SAVEPREFIX, 1);\n\n                    if(strcmp(fq_old_save, fq_new_save) != 0 &&\n                        !file_exists(fq_new_save))\n                        rename(fq_old_save, fq_new_save);\n\n                    result[j++] = r;\n                }\n            }\n        }\n\n        free_saved_games(files);\n\n    }\n#endif\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    /* posixly correct version */\n    int myuid = getuid();\n    DIR *dir;\n\n    if ((dir = opendir(fqname(\"save\", SAVEPREFIX, 0)))) {\n        for (n = 0; readdir(dir); n++)\n            ;\n        closedir(dir);\n        if (n > 0) {\n            int i;\n\n            if (!(dir = opendir(fqname(\"save\", SAVEPREFIX, 0))))\n                return 0;\n            result = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) result, 0, (n + 1) * sizeof(char *));\n            for (i = 0, j = 0; i < n; i++) {\n                int uid;\n                char name[64]; /* more than PL_NSIZ */\n                struct dirent *entry = readdir(dir);\n\n                if (!entry)\n                    break;\n                if (sscanf(entry->d_name, \"%d%63s\", &uid, name) == 2) {\n                    if (uid == myuid) {\n                        char filename[BUFSZ];\n                        char *r;\n\n                        Sprintf(filename, \"save/%d%s\", uid, name);\n                        r = plname_from_file(filename);\n                        if (r)\n                            result[j++] = r;\n                    }\n                }\n            }\n            closedir(dir);\n        }\n    }\n#endif\n#ifdef VMS\n    Strcpy(plname, \"*\");\n    set_savefile_name(FALSE);\n    j = vms_get_saved_games(SAVEF, &result);\n#endif /* VMS */\n\n    if (j > 0) {\n        if (j > 1)\n            qsort(result, j, sizeof (char *), strcmp_wrap);\n        result[j] = 0;\n        return result;\n    } else if (result) { /* could happen if save files are obsolete */\n        free_saved_games(result);\n    }\n#endif /* SELECTSAVED */\n    return 0;\n}\n\nvoid\nfree_saved_games(saved)\nchar **saved;\n{\n    if (saved) {\n        int i = 0;\n\n        while (saved[i])\n            free((genericptr_t) saved[i++]);\n        free((genericptr_t) saved);\n    }\n}\n\n/* ----------  END SAVE FILE HANDLING ----------- */\n\n/* ----------  BEGIN FILE COMPRESSION HANDLING ----------- */\n\n#ifdef COMPRESS\n\nSTATIC_OVL void\nredirect(filename, mode, stream, uncomp)\nconst char *filename, *mode;\nFILE *stream;\nboolean uncomp;\n{\n    if (freopen(filename, mode, stream) == (FILE *) 0) {\n        (void) fprintf(stderr, \"freopen of %s for %scompress failed\\n\",\n                       filename, uncomp ? \"un\" : \"\");\n        nh_terminate(EXIT_FAILURE);\n    }\n}\n\n/*\n * using system() is simpler, but opens up security holes and causes\n * problems on at least Interactive UNIX 3.0.1 (SVR3.2), where any\n * setuid is renounced by /bin/sh, so the files cannot be accessed.\n *\n * cf. child() in unixunix.c.\n */\nSTATIC_OVL void\ndocompress_file(filename, uncomp)\nconst char *filename;\nboolean uncomp;\n{\n    char cfn[80];\n    FILE *cf;\n    const char *args[10];\n#ifdef COMPRESS_OPTIONS\n    char opts[80];\n#endif\n    int i = 0;\n    int f;\n#ifdef TTY_GRAPHICS\n    boolean istty = WINDOWPORT(\"tty\");\n#endif\n\n    Strcpy(cfn, filename);\n#ifdef COMPRESS_EXTENSION\n    Strcat(cfn, COMPRESS_EXTENSION);\n#endif\n    /* when compressing, we know the file exists */\n    if (uncomp) {\n        if ((cf = fopen(cfn, RDBMODE)) == (FILE *) 0)\n            return;\n        (void) fclose(cf);\n    }\n\n    args[0] = COMPRESS;\n    if (uncomp)\n        args[++i] = \"-d\"; /* uncompress */\n#ifdef COMPRESS_OPTIONS\n    {\n        /* we can't guarantee there's only one additional option, sigh */\n        char *opt;\n        boolean inword = FALSE;\n\n        Strcpy(opts, COMPRESS_OPTIONS);\n        opt = opts;\n        while (*opt) {\n            if ((*opt == ' ') || (*opt == '\\t')) {\n                if (inword) {\n                    *opt = '\\0';\n                    inword = FALSE;\n                }\n            } else if (!inword) {\n                args[++i] = opt;\n                inword = TRUE;\n            }\n            opt++;\n        }\n    }\n#endif\n    args[++i] = (char *) 0;\n\n#ifdef TTY_GRAPHICS\n    /* If we don't do this and we are right after a y/n question *and*\n     * there is an error message from the compression, the 'y' or 'n' can\n     * end up being displayed after the error message.\n     */\n    if (istty)\n        mark_synch();\n#endif\n    f = fork();\n    if (f == 0) { /* child */\n#ifdef TTY_GRAPHICS\n        /* any error messages from the compression must come out after\n         * the first line, because the more() to let the user read\n         * them will have to clear the first line.  This should be\n         * invisible if there are no error messages.\n         */\n        if (istty)\n            raw_print(\"\");\n#endif\n        /* run compressor without privileges, in case other programs\n         * have surprises along the line of gzip once taking filenames\n         * in GZIP.\n         */\n        /* assume all compressors will compress stdin to stdout\n         * without explicit filenames.  this is true of at least\n         * compress and gzip, those mentioned in config.h.\n         */\n        if (uncomp) {\n            redirect(cfn, RDBMODE, stdin, uncomp);\n            redirect(filename, WRBMODE, stdout, uncomp);\n        } else {\n            redirect(filename, RDBMODE, stdin, uncomp);\n            redirect(cfn, WRBMODE, stdout, uncomp);\n        }\n        (void) setgid(getgid());\n        (void) setuid(getuid());\n        (void) execv(args[0], (char *const *) args);\n        perror((char *) 0);\n        (void) fprintf(stderr, \"Exec to %scompress %s failed.\\n\",\n                       uncomp ? \"un\" : \"\", filename);\n        nh_terminate(EXIT_FAILURE);\n    } else if (f == -1) {\n        perror((char *) 0);\n        pline(\"Fork to %scompress %s failed.\", uncomp ? \"un\" : \"\", filename);\n        return;\n    }\n#ifndef NO_SIGNAL\n    (void) signal(SIGINT, SIG_IGN);\n    (void) signal(SIGQUIT, SIG_IGN);\n    (void) wait((int *) &i);\n    (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n    if (wizard)\n        (void) signal(SIGQUIT, SIG_DFL);\n#else\n    /* I don't think we can really cope with external compression\n     * without signals, so we'll declare that compress failed and\n     * go on.  (We could do a better job by forcing off external\n     * compression if there are no signals, but we want this for\n     * testing with FailSafeC\n     */\n    i = 1;\n#endif\n    if (i == 0) {\n        /* (un)compress succeeded: remove file left behind */\n        if (uncomp)\n            (void) unlink(cfn);\n        else\n            (void) unlink(filename);\n    } else {\n        /* (un)compress failed; remove the new, bad file */\n        if (uncomp) {\n            raw_printf(\"Unable to uncompress %s\", filename);\n            (void) unlink(filename);\n        } else {\n            /* no message needed for compress case; life will go on */\n            (void) unlink(cfn);\n        }\n#ifdef TTY_GRAPHICS\n        /* Give them a chance to read any error messages from the\n         * compression--these would go to stdout or stderr and would get\n         * overwritten only in tty mode.  It's still ugly, since the\n         * messages are being written on top of the screen, but at least\n         * the user can read them.\n         */\n        if (istty && iflags.window_inited) {\n            clear_nhwindow(WIN_MESSAGE);\n            more();\n            /* No way to know if this is feasible */\n            /* doredraw(); */\n        }\n#endif\n    }\n}\n#endif /* COMPRESS */\n\n#if defined(COMPRESS) || defined(ZLIB_COMP)\n#define UNUSED_if_not_COMPRESS /*empty*/\n#else\n#define UNUSED_if_not_COMPRESS UNUSED\n#endif\n\n/* compress file */\nvoid\nnh_compress(filename)\nconst char *filename UNUSED_if_not_COMPRESS;\n{\n#if !defined(COMPRESS) && !defined(ZLIB_COMP)\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n#else\n    docompress_file(filename, FALSE);\n#endif\n}\n\n/* uncompress file if it exists */\nvoid\nnh_uncompress(filename)\nconst char *filename UNUSED_if_not_COMPRESS;\n{\n#if !defined(COMPRESS) && !defined(ZLIB_COMP)\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n#else\n    docompress_file(filename, TRUE);\n#endif\n}\n\n#ifdef ZLIB_COMP /* RLC 09 Mar 1999: Support internal ZLIB */\nSTATIC_OVL boolean\nmake_compressed_name(filename, cfn)\nconst char *filename;\nchar *cfn;\n{\n#ifndef SHORT_FILENAMES\n    /* Assume free-form filename with no 8.3 restrictions */\n    strcpy(cfn, filename);\n    strcat(cfn, COMPRESS_EXTENSION);\n    return TRUE;\n#else\n#ifdef SAVE_EXTENSION\n    char *bp = (char *) 0;\n\n    strcpy(cfn, filename);\n    if ((bp = strstri(cfn, SAVE_EXTENSION))) {\n        strsubst(bp, SAVE_EXTENSION, \".saz\");\n        return TRUE;\n    } else {\n        /* find last occurrence of bon */\n        bp = eos(cfn);\n        while (bp-- > cfn) {\n            if (strstri(bp, \"bon\")) {\n                strsubst(bp, \"bon\", \"boz\");\n                return TRUE;\n            }\n        }\n    }\n#endif /* SAVE_EXTENSION */\n    return FALSE;\n#endif /* SHORT_FILENAMES */\n}\n\nSTATIC_OVL void\ndocompress_file(filename, uncomp)\nconst char *filename;\nboolean uncomp;\n{\n    gzFile compressedfile;\n    FILE *uncompressedfile;\n    char cfn[256];\n    char buf[1024];\n    unsigned len, len2;\n\n    if (!make_compressed_name(filename, cfn))\n        return;\n\n    if (!uncomp) {\n        /* Open the input and output files */\n        /* Note that gzopen takes \"wb\" as its mode, even on systems where\n           fopen takes \"r\" and \"w\" */\n\n        uncompressedfile = fopen(filename, RDBMODE);\n        if (!uncompressedfile) {\n            pline(\"Error in zlib docompress_file %s\", filename);\n            return;\n        }\n        compressedfile = gzopen(cfn, \"wb\");\n        if (compressedfile == NULL) {\n            if (errno == 0) {\n                pline(\"zlib failed to allocate memory\");\n            } else {\n                panic(\"Error in docompress_file %d\", errno);\n            }\n            fclose(uncompressedfile);\n            return;\n        }\n\n        /* Copy from the uncompressed to the compressed file */\n\n        while (1) {\n            len = fread(buf, 1, sizeof(buf), uncompressedfile);\n            if (ferror(uncompressedfile)) {\n                pline(\"Failure reading uncompressed file\");\n                pline(\"Can't compress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(cfn);\n                return;\n            }\n            if (len == 0)\n                break; /* End of file */\n\n            len2 = gzwrite(compressedfile, buf, len);\n            if (len2 == 0) {\n                pline(\"Failure writing compressed file\");\n                pline(\"Can't compress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(cfn);\n                return;\n            }\n        }\n\n        fclose(uncompressedfile);\n        gzclose(compressedfile);\n\n        /* Delete the file left behind */\n\n        (void) unlink(filename);\n\n    } else { /* uncomp */\n\n        /* Open the input and output files */\n        /* Note that gzopen takes \"rb\" as its mode, even on systems where\n           fopen takes \"r\" and \"w\" */\n\n        compressedfile = gzopen(cfn, \"rb\");\n        if (compressedfile == NULL) {\n            if (errno == 0) {\n                pline(\"zlib failed to allocate memory\");\n            } else if (errno != ENOENT) {\n                panic(\"Error in zlib docompress_file %s, %d\", filename,\n                      errno);\n            }\n            return;\n        }\n        uncompressedfile = fopen(filename, WRBMODE);\n        if (!uncompressedfile) {\n            pline(\"Error in zlib docompress file uncompress %s\", filename);\n            gzclose(compressedfile);\n            return;\n        }\n\n        /* Copy from the compressed to the uncompressed file */\n\n        while (1) {\n            len = gzread(compressedfile, buf, sizeof(buf));\n            if (len == (unsigned) -1) {\n                pline(\"Failure reading compressed file\");\n                pline(\"Can't uncompress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(filename);\n                return;\n            }\n            if (len == 0)\n                break; /* End of file */\n\n            fwrite(buf, 1, len, uncompressedfile);\n            if (ferror(uncompressedfile)) {\n                pline(\"Failure writing uncompressed file\");\n                pline(\"Can't uncompress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(filename);\n                return;\n            }\n        }\n\n        fclose(uncompressedfile);\n        gzclose(compressedfile);\n\n        /* Delete the file left behind */\n        (void) unlink(cfn);\n    }\n}\n#endif /* RLC 09 Mar 1999: End ZLIB patch */\n\n/* ----------  END FILE COMPRESSION HANDLING ----------- */\n\n/* ----------  BEGIN FILE LOCKING HANDLING ----------- */\n\nstatic int nesting = 0;\n\n#if defined(NO_FILE_LINKS) || defined(USE_FCNTL) /* implies UNIX */\nstatic int lockfd = -1; /* for lock_file() to pass to unlock_file() */\n#endif\n#ifdef USE_FCNTL\nstruct flock sflock; /* for unlocking, same as above */\n#endif\n\n#define HUP if (!program_state.done_hup)\n\n#ifndef USE_FCNTL\nSTATIC_OVL char *\nmake_lockname(filename, lockname)\nconst char *filename;\nchar *lockname;\n{\n#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(WIN32) \\\n    || defined(MSDOS)\n#ifdef NO_FILE_LINKS\n    Strcpy(lockname, LOCKDIR);\n    Strcat(lockname, \"/\");\n    Strcat(lockname, filename);\n#else\n    Strcpy(lockname, filename);\n#endif\n#ifdef VMS\n    {\n        char *semi_colon = rindex(lockname, ';');\n        if (semi_colon)\n            *semi_colon = '\\0';\n    }\n    Strcat(lockname, \".lock;1\");\n#else\n    Strcat(lockname, \"_lock\");\n#endif\n    return lockname;\n#else /* !(UNIX || VMS || AMIGA || WIN32 || MSDOS) */\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n    lockname[0] = '\\0';\n    return (char *) 0;\n#endif\n}\n#endif /* !USE_FCNTL */\n\n/* lock a file */\nboolean\nlock_file(filename, whichprefix, retryct)\nconst char *filename;\nint whichprefix;\nint retryct;\n{\n#if defined(PRAGMA_UNUSED) && !(defined(UNIX) || defined(VMS)) \\\n    && !(defined(AMIGA) || defined(WIN32) || defined(MSDOS))\n#pragma unused(retryct)\n#endif\n#ifndef USE_FCNTL\n    char locknambuf[BUFSZ];\n    const char *lockname;\n#endif\n\n    nesting++;\n    if (nesting > 1) {\n        impossible(\"TRIED TO NEST LOCKS\");\n        return TRUE;\n    }\n\n#ifndef USE_FCNTL\n    lockname = make_lockname(filename, locknambuf);\n#ifndef NO_FILE_LINKS /* LOCKDIR should be subsumed by LOCKPREFIX */\n    lockname = fqname(lockname, LOCKPREFIX, 2);\n#endif\n#endif\n    filename = fqname(filename, whichprefix, 0);\n#ifdef USE_FCNTL\n    lockfd = open(filename, O_RDWR);\n    if (lockfd == -1) {\n        HUP raw_printf(\"Cannot open file %s.  Is NetHack installed correctly?\",\n                       filename);\n        nesting--;\n        return FALSE;\n    }\n    sflock.l_type = F_WRLCK;\n    sflock.l_whence = SEEK_SET;\n    sflock.l_start = 0;\n    sflock.l_len = 0;\n#endif\n\n#if defined(UNIX) || defined(VMS)\n#ifdef USE_FCNTL\n    while (fcntl(lockfd, F_SETLK, &sflock) == -1) {\n#else\n#ifdef NO_FILE_LINKS\n    while ((lockfd = open(lockname, O_RDWR | O_CREAT | O_EXCL, 0666)) == -1) {\n#else\n    while (link(filename, lockname) == -1) {\n#endif\n#endif\n\n#ifdef USE_FCNTL\n        if (retryct--) {\n            HUP raw_printf(\n               \"Waiting for release of fcntl lock on %s.  (%d retries left.)\",\n                           filename, retryct);\n            sleep(1);\n        } else {\n            HUP(void) raw_print(\"I give up.  Sorry.\");\n            HUP raw_printf(\"Some other process has an unnatural grip on %s.\",\n                           filename);\n            nesting--;\n            return FALSE;\n        }\n#else\n        int errnosv = errno;\n\n        switch (errnosv) { /* George Barbanis */\n        case EEXIST:\n            if (retryct--) {\n                HUP raw_printf(\n                    \"Waiting for access to %s.  (%d retries left).\", filename,\n                    retryct);\n#if defined(SYSV) || defined(ULTRIX) || defined(VMS)\n                (void)\n#endif\n                    sleep(1);\n            } else {\n                HUP(void) raw_print(\"I give up.  Sorry.\");\n                HUP raw_printf(\"Perhaps there is an old %s around?\",\n                               lockname);\n                nesting--;\n                return FALSE;\n            }\n\n            break;\n        case ENOENT:\n            HUP raw_printf(\"Can't find file %s to lock!\", filename);\n            nesting--;\n            return FALSE;\n        case EACCES:\n            HUP raw_printf(\"No write permission to lock %s!\", filename);\n            nesting--;\n            return FALSE;\n#ifdef VMS /* c__translate(vmsfiles.c) */\n        case EPERM:\n            /* could be misleading, but usually right */\n            HUP raw_printf(\"Can't lock %s due to directory protection.\",\n                           filename);\n            nesting--;\n            return FALSE;\n#endif\n        case EROFS:\n            /* take a wild guess at the underlying cause */\n            HUP perror(lockname);\n            HUP raw_printf(\"Cannot lock %s.\", filename);\n            HUP raw_printf(\n  \"(Perhaps you are running NetHack from inside the distribution package?).\");\n            nesting--;\n            return FALSE;\n        default:\n            HUP perror(lockname);\n            HUP raw_printf(\"Cannot lock %s for unknown reason (%d).\",\n                           filename, errnosv);\n            nesting--;\n            return FALSE;\n        }\n#endif /* USE_FCNTL */\n    }\n#endif /* UNIX || VMS */\n\n#if (defined(AMIGA) || defined(WIN32) || defined(MSDOS)) \\\n    && !defined(USE_FCNTL)\n#ifdef AMIGA\n#define OPENFAILURE(fd) (!fd)\n    lockptr = 0;\n#else\n#define OPENFAILURE(fd) (fd < 0)\n    lockptr = -1;\n#endif\n    while (--retryct && OPENFAILURE(lockptr)) {\n#if defined(WIN32) && !defined(WIN_CE)\n        lockptr = sopen(lockname, O_RDWR | O_CREAT, SH_DENYRW, S_IWRITE);\n#else\n        (void) DeleteFile(lockname); /* in case dead process was here first */\n#ifdef AMIGA\n        lockptr = Open(lockname, MODE_NEWFILE);\n#else\n        lockptr = open(lockname, O_RDWR | O_CREAT | O_EXCL, S_IWRITE);\n#endif\n#endif\n        if (OPENFAILURE(lockptr)) {\n            raw_printf(\"Waiting for access to %s.  (%d retries left).\",\n                       filename, retryct);\n            Delay(50);\n        }\n    }\n    if (!retryct) {\n        raw_printf(\"I give up.  Sorry.\");\n        nesting--;\n        return FALSE;\n    }\n#endif /* AMIGA || WIN32 || MSDOS */\n    return TRUE;\n}\n\n#ifdef VMS /* for unlock_file, use the unlink() routine in vmsunix.c */\n#ifdef unlink\n#undef unlink\n#endif\n#define unlink(foo) vms_unlink(foo)\n#endif\n\n/* unlock file, which must be currently locked by lock_file */\nvoid\nunlock_file(filename)\nconst char *filename;\n{\n#ifndef USE_FCNTL\n    char locknambuf[BUFSZ];\n    const char *lockname;\n#endif\n\n    if (nesting == 1) {\n#ifdef USE_FCNTL\n        sflock.l_type = F_UNLCK;\n        if (lockfd >= 0) {\n            if (fcntl(lockfd, F_SETLK, &sflock) == -1)\n                HUP raw_printf(\"Can't remove fcntl lock on %s.\", filename);\n            (void) close(lockfd), lockfd = -1;\n        }\n#else\n        lockname = make_lockname(filename, locknambuf);\n#ifndef NO_FILE_LINKS /* LOCKDIR should be subsumed by LOCKPREFIX */\n        lockname = fqname(lockname, LOCKPREFIX, 2);\n#endif\n\n#if defined(UNIX) || defined(VMS)\n        if (unlink(lockname) < 0)\n            HUP raw_printf(\"Can't unlink %s.\", lockname);\n#ifdef NO_FILE_LINKS\n        (void) nhclose(lockfd), lockfd = -1;\n#endif\n\n#endif /* UNIX || VMS */\n\n#if defined(AMIGA) || defined(WIN32) || defined(MSDOS)\n        if (lockptr)\n            Close(lockptr);\n        DeleteFile(lockname);\n        lockptr = 0;\n#endif /* AMIGA || WIN32 || MSDOS */\n#endif /* USE_FCNTL */\n    }\n\n    nesting--;\n}\n\n/* ----------  END FILE LOCKING HANDLING ----------- */\n\n/* ----------  BEGIN CONFIG FILE HANDLING ----------- */\n\nconst char *default_configfile =\n#ifdef UNIX\n    \".nethackrc\";\n#else\n#if defined(MAC) || defined(__BEOS__)\n    \"NetHack Defaults\";\n#else\n#if defined(MSDOS) || defined(WIN32)\n    CONFIG_FILE;\n#else\n    \"NetHack.cnf\";\n#endif\n#endif\n#endif\n\n/* used for messaging */\nchar configfile[BUFSZ];\n\n#ifdef MSDOS\n/* conflict with speed-dial under windows\n * for XXX.cnf file so support of NetHack.cnf\n * is for backward compatibility only.\n * Preferred name (and first tried) is now defaults.nh but\n * the game will try the old name if there\n * is no defaults.nh.\n */\nconst char *backward_compat_configfile = \"nethack.cnf\";\n#endif\n\n/* remember the name of the file we're accessing;\n   if may be used in option reject messages */\nSTATIC_OVL void\nset_configfile_name(fname)\nconst char *fname;\n{\n    (void) strncpy(configfile, fname, sizeof configfile - 1);\n    configfile[sizeof configfile - 1] = '\\0';\n}\n\n#ifndef MFLOPPY\n#define fopenp fopen\n#endif\n\nSTATIC_OVL FILE *\nfopen_config_file(filename, src)\nconst char *filename;\nint src;\n{\n    FILE *fp;\n#if defined(UNIX) || defined(VMS)\n    char tmp_config[BUFSZ];\n    char *envp;\n#endif\n\n    if (src == SET_IN_SYS) {\n        /* SYSCF_FILE; if we can't open it, caller will bail */\n        if (filename && *filename) {\n            set_configfile_name(fqname(filename, SYSCONFPREFIX, 0));\n            fp = fopenp(configfile, \"r\");\n        } else\n            fp = (FILE *) 0;\n        return  fp;\n    }\n    /* If src != SET_IN_SYS, \"filename\" is an environment variable, so it\n     * should hang around. If set, it is expected to be a full path name\n     * (if relevant)\n     */\n    if (filename && *filename) {\n        set_configfile_name(filename);\n#ifdef UNIX\n        if (access(configfile, 4) == -1) { /* 4 is R_OK on newer systems */\n            /* nasty sneaky attempt to read file through\n             * NetHack's setuid permissions -- this is the only\n             * place a file name may be wholly under the player's\n             * control (but SYSCF_FILE is not under the player's\n             * control so it's OK).\n             */\n            raw_printf(\"Access to %s denied (%d).\", configfile, errno);\n            wait_synch();\n            /* fall through to standard names */\n        } else\n#endif\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n            return  fp;\n#if defined(UNIX) || defined(VMS)\n        } else {\n            /* access() above probably caught most problems for UNIX */\n            raw_printf(\"Couldn't open requested config file %s (%d).\",\n                       configfile, errno);\n            wait_synch();\n#endif\n        }\n    }\n    /* fall through to standard names */\n\n#if defined(MICRO) || defined(MAC) || defined(__BEOS__) || defined(WIN32)\n    set_configfile_name(fqname(default_configfile, CONFIGPREFIX, 0));\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n        return fp;\n    } else if (strcmp(default_configfile, configfile)) {\n        set_configfile_name(default_configfile);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#ifdef MSDOS\n    set_configfile_name(fqname(backward_compat_configfile, CONFIGPREFIX, 0));\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n        return fp;\n    } else if (strcmp(backward_compat_configfile, configfile)) {\n        set_configfile_name(backward_compat_configfile);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#endif\n#else\n/* constructed full path names don't need fqname() */\n#ifdef VMS\n    /* no punctuation, so might be a logical name */\n    set_configfile_name(\"nethackini\");\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n    set_configfile_name(\"sys$login:nethack.ini\");\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n\n    envp = nh_getenv(\"HOME\");\n    if (!envp || !*envp)\n        Strcpy(tmp_config, \"NetHack.cnf\");\n    else\n        Sprintf(tmp_config, \"%s%s%s\", envp,\n                !index(\":]>/\", envp[strlen(envp) - 1]) ? \"/\" : \"\",\n                \"NetHack.cnf\");\n    set_configfile_name(tmp_config);\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n#else /* should be only UNIX left */\n    envp = nh_getenv(\"HOME\");\n    if (!envp)\n        Strcpy(tmp_config, \".nethackrc\");\n    else\n        Sprintf(tmp_config, \"%s/%s\", envp, \".nethackrc\");\n\n    set_configfile_name(tmp_config);\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n#if defined(__APPLE__) /* UNIX+__APPLE__ => MacOSX */\n    /* try an alternative */\n    if (envp) {\n        /* OSX-style configuration settings */\n        Sprintf(tmp_config, \"%s/%s\", envp,\n                \"Library/Preferences/NetHack Defaults\");\n        set_configfile_name(tmp_config);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n        /* may be easier for user to edit if filename has '.txt' suffix */\n        Sprintf(tmp_config, \"%s/%s\", envp,\n                \"Library/Preferences/NetHack Defaults.txt\");\n        set_configfile_name(tmp_config);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#endif /*__APPLE__*/\n    if (errno != ENOENT) {\n        const char *details;\n\n        /* e.g., problems when setuid NetHack can't search home\n           directory restricted to user */\n#if defined(NHSTDC) && !defined(NOTSTDC)\n        if ((details = strerror(errno)) == 0)\n#endif\n            details = \"\";\n        raw_printf(\"Couldn't open default config file %s %s(%d).\",\n                   configfile, details, errno);\n        wait_synch();\n    }\n#endif /* !VMS => Unix */\n#endif /* !(MICRO || MAC || __BEOS__ || WIN32) */\n    return (FILE *) 0;\n}\n\n/*\n * Retrieve a list of integers from buf into a uchar array.\n *\n * NOTE: zeros are inserted unless modlist is TRUE, in which case the list\n *  location is unchanged.  Callers must handle zeros if modlist is FALSE.\n */\nSTATIC_OVL int\nget_uchars(bufp, list, modlist, size, name)\nchar *bufp;       /* current pointer */\nuchar *list;      /* return list */\nboolean modlist;  /* TRUE: list is being modified in place */\nint size;         /* return list size */\nconst char *name; /* name of option for error message */\n{\n    unsigned int num = 0;\n    int count = 0;\n    boolean havenum = FALSE;\n\n    while (1) {\n        switch (*bufp) {\n        case ' ':\n        case '\\0':\n        case '\\t':\n        case '\\n':\n            if (havenum) {\n                /* if modifying in place, don't insert zeros */\n                if (num || !modlist)\n                    list[count] = num;\n                count++;\n                num = 0;\n                havenum = FALSE;\n            }\n            if (count == size || !*bufp)\n                return count;\n            bufp++;\n            break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            havenum = TRUE;\n            num = num * 10 + (*bufp - '0');\n            bufp++;\n            break;\n\n        case '\\\\':\n            goto gi_error;\n            break;\n\n        default:\n gi_error:\n            raw_printf(\"Syntax error in %s\", name);\n            wait_synch();\n            return count;\n        }\n    }\n    /*NOTREACHED*/\n}\n\n#ifdef NOCWD_ASSUMPTIONS\nSTATIC_OVL void\nadjust_prefix(bufp, prefixid)\nchar *bufp;\nint prefixid;\n{\n    char *ptr;\n\n    if (!bufp)\n        return;\n#ifdef WIN32\n    if (fqn_prefix_locked[prefixid])\n        return;\n#endif\n    /* Backward compatibility, ignore trailing ;n */\n    if ((ptr = index(bufp, ';')) != 0)\n        *ptr = '\\0';\n    if (strlen(bufp) > 0) {\n        fqn_prefix[prefixid] = (char *) alloc(strlen(bufp) + 2);\n        Strcpy(fqn_prefix[prefixid], bufp);\n        append_slash(fqn_prefix[prefixid]);\n    }\n}\n#endif\n\n/* Choose at random one of the sep separated parts from str. Mangles str. */\nSTATIC_OVL char *\nchoose_random_part(str,sep)\nchar *str;\nchar sep;\n{\n    int nsep = 1;\n    int csep;\n    int len = 0;\n    char *begin = str;\n\n    if (!str)\n        return (char *) 0;\n\n    while (*str) {\n        if (*str == sep)\n            nsep++;\n        str++;\n    }\n    csep = rn2(nsep);\n    str = begin;\n    while ((csep > 0) && *str) {\n        str++;\n        if (*str == sep)\n            csep--;\n    }\n    if (*str) {\n        if (*str == sep)\n            str++;\n        begin = str;\n        while (*str && *str != sep) {\n            str++;\n            len++;\n        }\n        *str = '\\0';\n        if (len)\n            return begin;\n    }\n    return (char *) 0;\n}\n\nSTATIC_OVL void\nfree_config_sections()\n{\n    if (config_section_chosen) {\n        free(config_section_chosen);\n        config_section_chosen = NULL;\n    }\n    if (config_section_current) {\n        free(config_section_current);\n        config_section_current = NULL;\n    }\n}\n\nSTATIC_OVL boolean\nis_config_section(str)\nconst char *str;\n{\n    const char *a = rindex(str, ']');\n\n    return (a && *str == '[' && *(a+1) == '\\0' && (int)(a - str) > 0);\n}\n\nSTATIC_OVL boolean\nhandle_config_section(buf)\nchar *buf;\n{\n    if (is_config_section(buf)) {\n        char *send;\n        if (config_section_current) {\n            free(config_section_current);\n        }\n        config_section_current = dupstr(&buf[1]);\n        send = rindex(config_section_current, ']');\n        *send = '\\0';\n        debugpline1(\"set config section: '%s'\", config_section_current);\n        return TRUE;\n    }\n\n    if (config_section_current) {\n        if (!config_section_chosen)\n            return TRUE;\n        if (strcmp(config_section_current, config_section_chosen))\n            return TRUE;\n    }\n    return FALSE;\n}\n\n#define match_varname(INP, NAM, LEN) match_optname(INP, NAM, LEN, TRUE)\n\n/* find the '=' or ':' */\nchar *\nfind_optparam(buf)\nconst char *buf;\n{\n    char *bufp, *altp;\n\n    bufp = index(buf, '=');\n    altp = index(buf, ':');\n    if (!bufp || (altp && altp < bufp))\n        bufp = altp;\n\n    return bufp;\n}\n\nboolean\nparse_config_line(origbuf)\nchar *origbuf;\n{\n#if defined(MICRO) && !defined(NOCWD_ASSUMPTIONS)\n    static boolean ramdisk_specified = FALSE;\n#endif\n#ifdef SYSCF\n    int n, src = iflags.parse_config_file_src;\n#endif\n    char *bufp, buf[4 * BUFSZ];\n    uchar translate[MAXPCHARS];\n    int len;\n    boolean retval = TRUE;\n\n    while (*origbuf == ' ' || *origbuf == '\\t') /* skip leading whitespace */\n        ++origbuf;                   /* (caller probably already did this) */\n    (void) strncpy(buf, origbuf, sizeof buf - 1);\n    buf[sizeof buf - 1] = '\\0'; /* strncpy not guaranteed to NUL terminate */\n    /* convert any tab to space, condense consecutive spaces into one,\n       remove leading and trailing spaces (exception: if there is nothing\n       but spaces, one of them will be kept even though it leads/trails) */\n    mungspaces(buf);\n\n    /* find the '=' or ':' */\n    bufp = find_optparam(buf);\n    if (!bufp) {\n        config_error_add(\"Not a config statement, missing '='\");\n        return FALSE;\n    }\n    /* skip past '=', then space between it and value, if any */\n    ++bufp;\n    if (*bufp == ' ')\n        ++bufp;\n\n    /* Go through possible variables */\n    /* some of these (at least LEVELS and SAVE) should now set the\n     * appropriate fqn_prefix[] rather than specialized variables\n     */\n    if (match_varname(buf, \"OPTIONS\", 4)) {\n        /* hack: un-mungspaces to allow consecutive spaces in\n           general options until we verify that this is unnecessary;\n           '=' or ':' is guaranteed to be present */\n        bufp = find_optparam(origbuf);\n        ++bufp; /* skip '='; parseoptions() handles spaces */\n\n        if (!parseoptions(bufp, TRUE, TRUE))\n            retval = FALSE;\n    } else if (match_varname(buf, \"AUTOPICKUP_EXCEPTION\", 5)) {\n        add_autopickup_exception(bufp);\n    } else if (match_varname(buf, \"BINDINGS\", 4)) {\n        if (!parsebindings(bufp))\n            retval = FALSE;\n    } else if (match_varname(buf, \"AUTOCOMPLETE\", 5)) {\n        parseautocomplete(bufp, TRUE);\n    } else if (match_varname(buf, \"MSGTYPE\", 7)) {\n        if (!msgtype_parse_add(bufp))\n            retval = FALSE;\n#ifdef NOCWD_ASSUMPTIONS\n    } else if (match_varname(buf, \"HACKDIR\", 4)) {\n        adjust_prefix(bufp, HACKPREFIX);\n    } else if (match_varname(buf, \"LEVELDIR\", 4)\n               || match_varname(buf, \"LEVELS\", 4)) {\n        adjust_prefix(bufp, LEVELPREFIX);\n    } else if (match_varname(buf, \"SAVEDIR\", 4)) {\n        adjust_prefix(bufp, SAVEPREFIX);\n    } else if (match_varname(buf, \"BONESDIR\", 5)) {\n        adjust_prefix(bufp, BONESPREFIX);\n    } else if (match_varname(buf, \"DATADIR\", 4)) {\n        adjust_prefix(bufp, DATAPREFIX);\n    } else if (match_varname(buf, \"SCOREDIR\", 4)) {\n        adjust_prefix(bufp, SCOREPREFIX);\n    } else if (match_varname(buf, \"LOCKDIR\", 4)) {\n        adjust_prefix(bufp, LOCKPREFIX);\n    } else if (match_varname(buf, \"CONFIGDIR\", 4)) {\n        adjust_prefix(bufp, CONFIGPREFIX);\n    } else if (match_varname(buf, \"TROUBLEDIR\", 4)) {\n        adjust_prefix(bufp, TROUBLEPREFIX);\n#else /*NOCWD_ASSUMPTIONS*/\n#ifdef MICRO\n    } else if (match_varname(buf, \"HACKDIR\", 4)) {\n        (void) strncpy(hackdir, bufp, PATHLEN - 1);\n#ifdef MFLOPPY\n    } else if (match_varname(buf, \"RAMDISK\", 3)) {\n/* The following ifdef is NOT in the wrong\n * place.  For now, we accept and silently\n * ignore RAMDISK */\n#ifndef AMIGA\n        if (strlen(bufp) >= PATHLEN)\n            bufp[PATHLEN - 1] = '\\0';\n        Strcpy(levels, bufp);\n        ramdisk = (strcmp(permbones, levels) != 0);\n        ramdisk_specified = TRUE;\n#endif\n#endif\n    } else if (match_varname(buf, \"LEVELS\", 4)) {\n        if (strlen(bufp) >= PATHLEN)\n            bufp[PATHLEN - 1] = '\\0';\n        Strcpy(permbones, bufp);\n        if (!ramdisk_specified || !*levels)\n            Strcpy(levels, bufp);\n        ramdisk = (strcmp(permbones, levels) != 0);\n    } else if (match_varname(buf, \"SAVE\", 4)) {\n#ifdef MFLOPPY\n        extern int saveprompt;\n#endif\n        char *ptr;\n\n        if ((ptr = index(bufp, ';')) != 0) {\n            *ptr = '\\0';\n#ifdef MFLOPPY\n            if (*(ptr + 1) == 'n' || *(ptr + 1) == 'N') {\n                saveprompt = FALSE;\n            }\n#endif\n        }\n#if defined(SYSFLAGS) && defined(MFLOPPY)\n        else\n            saveprompt = sysflags.asksavedisk;\n#endif\n\n        (void) strncpy(SAVEP, bufp, SAVESIZE - 1);\n        append_slash(SAVEP);\n#endif /* MICRO */\n#endif /*NOCWD_ASSUMPTIONS*/\n\n    } else if (match_varname(buf, \"NAME\", 4)) {\n        (void) strncpy(plname, bufp, PL_NSIZ - 1);\n    } else if (match_varname(buf, \"ROLE\", 4)\n               || match_varname(buf, \"CHARACTER\", 4)) {\n        if ((len = str2role(bufp)) >= 0)\n            flags.initrole = len;\n    } else if (match_varname(buf, \"DOGNAME\", 3)) {\n        (void) strncpy(dogname, bufp, PL_PSIZ - 1);\n    } else if (match_varname(buf, \"CATNAME\", 3)) {\n        (void) strncpy(catname, bufp, PL_PSIZ - 1);\n\n#ifdef SYSCF\n    } else if (src == SET_IN_SYS && match_varname(buf, \"WIZARDS\", 7)) {\n        if (sysopt.wizards)\n            free((genericptr_t) sysopt.wizards);\n        sysopt.wizards = dupstr(bufp);\n        if (strlen(sysopt.wizards) && strcmp(sysopt.wizards, \"*\")) {\n            /* pre-format WIZARDS list now; it's displayed during a panic\n               and since that panic might be due to running out of memory,\n               we don't want to risk attempting to allocate any memory then */\n            if (sysopt.fmtd_wizard_list)\n                free((genericptr_t) sysopt.fmtd_wizard_list);\n            sysopt.fmtd_wizard_list = build_english_list(sysopt.wizards);\n        }\n    } else if (src == SET_IN_SYS && match_varname(buf, \"SHELLERS\", 8)) {\n        if (sysopt.shellers)\n            free((genericptr_t) sysopt.shellers);\n        sysopt.shellers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"EXPLORERS\", 7)) {\n        if (sysopt.explorers)\n            free((genericptr_t) sysopt.explorers);\n        sysopt.explorers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"DEBUGFILES\", 5)) {\n        /* if showdebug() has already been called (perhaps we've added\n           some debugpline() calls to option processing) and has found\n           a value for getenv(\"DEBUGFILES\"), don't override that */\n        if (sysopt.env_dbgfl <= 0) {\n            if (sysopt.debugfiles)\n                free((genericptr_t) sysopt.debugfiles);\n            sysopt.debugfiles = dupstr(bufp);\n        }\n    } else if (src == SET_IN_SYS && match_varname(buf, \"DUMPLOGFILE\", 7)) {\n#ifdef DUMPLOG\n        if (sysopt.dumplogfile)\n            free((genericptr_t) sysopt.dumplogfile);\n        sysopt.dumplogfile = dupstr(bufp);\n#endif\n#ifdef WIN32\n    } else if (src == SET_IN_SYS && match_varname(buf, \"portable_device_top\", 8)) {\n        if (sysopt.portable_device_top)\n            free((genericptr_t) sysopt.portable_device_top);\n        sysopt.portable_device_top = dupstr(bufp);\n#endif\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GENERICUSERS\", 12)) {\n        if (sysopt.genericusers)\n            free((genericptr_t) sysopt.genericusers);\n        sysopt.genericusers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"BONES_POOLS\", 10)) {\n        /* max value of 10 guarantees (N % bones.pools) will be one digit\n           so we don't lose control of the length of bones file names */\n        n = atoi(bufp);\n        sysopt.bones_pools = (n <= 0) ? 0 : min(n, 10);\n        /* note: right now bones_pools==0 is the same as bones_pools==1,\n           but we could change that and make bones_pools==0 become an\n           indicator to suppress bones usage altogether */\n    } else if (src == SET_IN_SYS && match_varname(buf, \"SUPPORT\", 7)) {\n        if (sysopt.support)\n            free((genericptr_t) sysopt.support);\n        sysopt.support = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"RECOVER\", 7)) {\n        if (sysopt.recover)\n            free((genericptr_t) sysopt.recover);\n        sysopt.recover = dupstr(bufp);\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"CHECK_SAVE_UID\", 14)) {\n        n = atoi(bufp);\n        sysopt.check_save_uid = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"CHECK_PLNAME\", 12)) {\n        n = atoi(bufp);\n        sysopt.check_plname = n;\n    } else if (match_varname(buf, \"SEDUCE\", 6)) {\n        n = !!atoi(bufp); /* XXX this could be tighter */\n        /* allow anyone to turn it off, but only sysconf to turn it on*/\n        if (src != SET_IN_SYS && n != 0) {\n            config_error_add(\"Illegal value in SEDUCE\");\n            return FALSE;\n        }\n        sysopt.seduce = n;\n        sysopt_seduce_set(sysopt.seduce);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"MAXPLAYERS\", 10)) {\n        n = atoi(bufp);\n        /* XXX to get more than 25, need to rewrite all lock code */\n        if (n < 0 || n > 25) {\n            config_error_add(\"Illegal value in MAXPLAYERS (maximum is 25).\");\n            return FALSE;\n        }\n        sysopt.maxplayers = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"PERSMAX\", 7)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\"Illegal value in PERSMAX (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.persmax = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"PERS_IS_UID\", 11)) {\n        n = atoi(bufp);\n        if (n != 0 && n != 1) {\n            config_error_add(\"Illegal value in PERS_IS_UID (must be 0 or 1).\");\n            return FALSE;\n        }\n        sysopt.pers_is_uid = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"ENTRYMAX\", 8)) {\n        n = atoi(bufp);\n        if (n < 10) {\n            config_error_add(\"Illegal value in ENTRYMAX (minimum is 10).\");\n            return FALSE;\n        }\n        sysopt.entrymax = n;\n    } else if ((src == SET_IN_SYS) && match_varname(buf, \"POINTSMIN\", 9)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\"Illegal value in POINTSMIN (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.pointsmin = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"MAX_STATUENAME_RANK\", 10)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\n                      \"Illegal value in MAX_STATUENAME_RANK (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.tt_oname_maxrank = n;\n\n    /* SYSCF PANICTRACE options */\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"PANICTRACE_LIBC\", 15)) {\n        n = atoi(bufp);\n#if defined(PANICTRACE) && defined(PANICTRACE_LIBC)\n        if (n < 0 || n > 2) {\n            config_error_add(\"Illegal value in PANICTRACE_LIBC (not 0,1,2).\");\n            return FALSE;\n        }\n#endif\n        sysopt.panictrace_libc = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"PANICTRACE_GDB\", 14)) {\n        n = atoi(bufp);\n#if defined(PANICTRACE)\n        if (n < 0 || n > 2) {\n            config_error_add(\"Illegal value in PANICTRACE_GDB (not 0,1,2).\");\n            return FALSE;\n        }\n#endif\n        sysopt.panictrace_gdb = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GDBPATH\", 7)) {\n#if defined(PANICTRACE) && !defined(VMS)\n        if (!file_exists(bufp)) {\n            config_error_add(\"File specified in GDBPATH does not exist.\");\n            return FALSE;\n        }\n#endif\n        if (sysopt.gdbpath)\n            free((genericptr_t) sysopt.gdbpath);\n        sysopt.gdbpath = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GREPPATH\", 7)) {\n#if defined(PANICTRACE) && !defined(VMS)\n        if (!file_exists(bufp)) {\n            config_error_add(\"File specified in GREPPATH does not exist.\");\n            return FALSE;\n        }\n#endif\n        if (sysopt.greppath)\n            free((genericptr_t) sysopt.greppath);\n        sysopt.greppath = dupstr(bufp);\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"ACCESSIBILITY\", 13)) {\n        n = atoi(bufp);\n        if (n < 0 || n > 1) {\n            config_error_add(\"Illegal value in ACCESSIBILITY (not 0,1).\");\n            return FALSE;\n        }\n        sysopt.accessibility = n;\n#endif /* SYSCF */\n\n    } else if (match_varname(buf, \"BOULDER\", 3)) {\n        (void) get_uchars(bufp, &ov_primary_syms[SYM_BOULDER + SYM_OFF_X],\n                          TRUE, 1, \"BOULDER\");\n    } else if (match_varname(buf, \"MENUCOLOR\", 9)) {\n        if (!add_menu_coloring(bufp))\n            retval = FALSE;\n    } else if (match_varname(buf, \"HILITE_STATUS\", 6)) {\n#ifdef STATUS_HILITES\n        if (!parse_status_hl1(bufp, TRUE))\n            retval = FALSE;\n#endif\n    } else if (match_varname(buf, \"WARNINGS\", 5)) {\n        (void) get_uchars(bufp, translate, FALSE, WARNCOUNT,\n                          \"WARNINGS\");\n        assign_warnings(translate);\n    } else if (match_varname(buf, \"ROGUESYMBOLS\", 4)) {\n        if (!parsesymbols(bufp, ROGUESET)) {\n            config_error_add(\"Error in ROGUESYMBOLS definition '%s'\", bufp);\n            retval = FALSE;\n        }\n        switch_symbols(TRUE);\n    } else if (match_varname(buf, \"SYMBOLS\", 4)) {\n        if (!parsesymbols(bufp, PRIMARY)) {\n            config_error_add(\"Error in SYMBOLS definition '%s'\", bufp);\n            retval = FALSE;\n        }\n        switch_symbols(TRUE);\n    } else if (match_varname(buf, \"WIZKIT\", 6)) {\n        (void) strncpy(wizkit, bufp, WIZKIT_MAX - 1);\n#ifdef AMIGA\n    } else if (match_varname(buf, \"FONT\", 4)) {\n        char *t;\n\n        if (t = strchr(buf + 5, ':')) {\n            *t = 0;\n            amii_set_text_font(buf + 5, atoi(t + 1));\n            *t = ':';\n        }\n    } else if (match_varname(buf, \"PATH\", 4)) {\n        (void) strncpy(PATH, bufp, PATHLEN - 1);\n    } else if (match_varname(buf, \"DEPTH\", 5)) {\n        extern int amii_numcolors;\n        int val = atoi(bufp);\n\n        amii_numcolors = 1L << min(DEPTH, val);\n#ifdef SYSFLAGS\n    } else if (match_varname(buf, \"DRIPENS\", 7)) {\n        int i, val;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\"); t != (char *) 0;\n             i < 20 && (t = strtok((char *) 0, \",/\")), ++i) {\n            sscanf(t, \"%d\", &val);\n            sysflags.amii_dripens[i] = val;\n        }\n#endif\n    } else if (match_varname(buf, \"SCREENMODE\", 10)) {\n        extern long amii_scrnmode;\n\n        if (!stricmp(bufp, \"req\"))\n            amii_scrnmode = 0xffffffff; /* Requester */\n        else if (sscanf(bufp, \"%x\", &amii_scrnmode) != 1)\n            amii_scrnmode = 0;\n    } else if (match_varname(buf, \"MSGPENS\", 7)) {\n        extern int amii_msgAPen, amii_msgBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_msgAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_msgBPen);\n        }\n    } else if (match_varname(buf, \"TEXTPENS\", 8)) {\n        extern int amii_textAPen, amii_textBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_textAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_textBPen);\n        }\n    } else if (match_varname(buf, \"MENUPENS\", 8)) {\n        extern int amii_menuAPen, amii_menuBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_menuAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_menuBPen);\n        }\n    } else if (match_varname(buf, \"STATUSPENS\", 10)) {\n        extern int amii_statAPen, amii_statBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_statAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_statBPen);\n        }\n    } else if (match_varname(buf, \"OTHERPENS\", 9)) {\n        extern int amii_otherAPen, amii_otherBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_otherAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_otherBPen);\n        }\n    } else if (match_varname(buf, \"PENS\", 4)) {\n        extern unsigned short amii_init_map[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%hx\", &amii_init_map[i]);\n        }\n        amii_setpens(amii_numcolors = i);\n    } else if (match_varname(buf, \"FGPENS\", 6)) {\n        extern int foreg[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%d\", &foreg[i]);\n        }\n    } else if (match_varname(buf, \"BGPENS\", 6)) {\n        extern int backg[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%d\", &backg[i]);\n        }\n#endif /*AMIGA*/\n#ifdef USER_SOUNDS\n    } else if (match_varname(buf, \"SOUNDDIR\", 8)) {\n        sounddir = dupstr(bufp);\n    } else if (match_varname(buf, \"SOUND\", 5)) {\n        add_sound_mapping(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_TILEWIDTH\", 12)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_tilewidth;\n\n        if (qt_tilewidth == NULL)\n            qt_tilewidth = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_TILEHEIGHT\", 13)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_tileheight;\n\n        if (qt_tileheight == NULL)\n            qt_tileheight = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_FONTSIZE\", 11)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_fontsize;\n\n        if (qt_fontsize == NULL)\n            qt_fontsize = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_COMPACT\", 10)) {\n#ifdef QT_GRAPHICS\n        extern int qt_compact_mode;\n\n        qt_compact_mode = atoi(bufp);\n#endif\n    } else {\n        config_error_add(\"Unknown config statement\");\n        return FALSE;\n    }\n    return retval;\n}\n\n#ifdef USER_SOUNDS\nboolean\ncan_read_file(filename)\nconst char *filename;\n{\n    return (boolean) (access(filename, 4) == 0);\n}\n#endif /* USER_SOUNDS */\n\nstruct _config_error_frame {\n    int line_num;\n    int num_errors;\n    boolean origline_shown;\n    boolean fromfile;\n    boolean secure;\n    char origline[4 * BUFSZ];\n    char source[BUFSZ];\n    struct _config_error_frame *next;\n};\n\nstatic struct _config_error_frame *config_error_data = 0;\n\nvoid\nconfig_error_init(from_file, sourcename, secure)\nboolean from_file;\nconst char *sourcename;\nboolean secure;\n{\n    struct _config_error_frame *tmp = (struct _config_error_frame *)\n        alloc(sizeof (struct _config_error_frame));\n\n    tmp->line_num = 0;\n    tmp->num_errors = 0;\n    tmp->origline_shown = FALSE;\n    tmp->fromfile = from_file;\n    tmp->secure = secure;\n    tmp->origline[0] = '\\0';\n    if (sourcename && sourcename[0]) {\n        (void) strncpy(tmp->source, sourcename, sizeof (tmp->source) - 1);\n        tmp->source[sizeof (tmp->source) - 1] = '\\0';\n    } else\n        tmp->source[0] = '\\0';\n\n    tmp->next = config_error_data;\n    config_error_data = tmp;\n}\n\nSTATIC_OVL boolean\nconfig_error_nextline(line)\nconst char *line;\n{\n    struct _config_error_frame *ced = config_error_data;\n\n    if (!ced)\n        return FALSE;\n\n    if (ced->num_errors && ced->secure)\n        return FALSE;\n\n    ced->line_num++;\n    ced->origline_shown = FALSE;\n    if (line && line[0]) {\n        (void) strncpy(ced->origline, line, sizeof (ced->origline) - 1);\n        ced->origline[sizeof (ced->origline) - 1] = '\\0';\n    } else\n        ced->origline[0] = '\\0';\n\n    return TRUE;\n}\n\n/* varargs 'config_error_add()' moved to pline.c */\nvoid\nconfig_erradd(buf)\nconst char *buf;\n{\n    char lineno[QBUFSZ];\n\n    if (!buf || !*buf)\n        buf = \"Unknown error\";\n\n    if (!config_error_data) {\n        /* either very early, where pline() will use raw_print(), or\n           player gave bad value when prompted by interactive 'O' command */\n        pline(\"%s%s.\", !iflags.window_inited ? \"config_error_add: \" : \"\", buf);\n        wait_synch();\n        return;\n    }\n\n    config_error_data->num_errors++;\n    if (!config_error_data->origline_shown && !config_error_data->secure) {\n        pline(\"\\n%s\", config_error_data->origline);\n        config_error_data->origline_shown = TRUE;\n    }\n    if (config_error_data->line_num > 0 && !config_error_data->secure) {\n        Sprintf(lineno, \"Line %d: \", config_error_data->line_num);\n    } else\n        lineno[0] = '\\0';\n\n    pline(\"%s %s%s.\", config_error_data->secure ? \"Error:\" : \" *\",\n          lineno, buf);\n}\n\nint\nconfig_error_done()\n{\n    int n;\n    struct _config_error_frame *tmp = config_error_data;\n\n    if (!config_error_data)\n        return 0;\n    n = config_error_data->num_errors;\n    if (n) {\n        pline(\"\\n%d error%s in %s.\\n\", n,\n                   (n > 1) ? \"s\" : \"\",\n                   *config_error_data->source\n              ? config_error_data->source : configfile);\n        wait_synch();\n    }\n    config_error_data = tmp->next;\n    free(tmp);\n    return n;\n}\n\nboolean\nread_config_file(filename, src)\nconst char *filename;\nint src;\n{\n    FILE *fp;\n    boolean rv = TRUE;\n\n    if (!(fp = fopen_config_file(filename, src)))\n        return FALSE;\n\n    /* begin detection of duplicate configfile options */\n    set_duplicate_opt_detection(1);\n    free_config_sections();\n    iflags.parse_config_file_src = src;\n\n    rv = parse_conf_file(fp, parse_config_line);\n    (void) fclose(fp);\n\n    free_config_sections();\n    /* turn off detection of duplicate configfile options */\n    set_duplicate_opt_detection(0);\n    return rv;\n}\n\nSTATIC_OVL FILE *\nfopen_wizkit_file()\n{\n    FILE *fp;\n#if defined(VMS) || defined(UNIX)\n    char tmp_wizkit[BUFSZ];\n#endif\n    char *envp;\n\n    envp = nh_getenv(\"WIZKIT\");\n    if (envp && *envp)\n        (void) strncpy(wizkit, envp, WIZKIT_MAX - 1);\n    if (!wizkit[0])\n        return (FILE *) 0;\n\n#ifdef UNIX\n    if (access(wizkit, 4) == -1) {\n        /* 4 is R_OK on newer systems */\n        /* nasty sneaky attempt to read file through\n         * NetHack's setuid permissions -- this is a\n         * place a file name may be wholly under the player's\n         * control\n         */\n        raw_printf(\"Access to %s denied (%d).\", wizkit, errno);\n        wait_synch();\n        /* fall through to standard names */\n    } else\n#endif\n        if ((fp = fopenp(wizkit, \"r\")) != (FILE *) 0) {\n        return fp;\n#if defined(UNIX) || defined(VMS)\n    } else {\n        /* access() above probably caught most problems for UNIX */\n        raw_printf(\"Couldn't open requested config file %s (%d).\", wizkit,\n                   errno);\n        wait_synch();\n#endif\n    }\n\n#if defined(MICRO) || defined(MAC) || defined(__BEOS__) || defined(WIN32)\n    if ((fp = fopenp(fqname(wizkit, CONFIGPREFIX, 0), \"r\")) != (FILE *) 0)\n        return fp;\n#else\n#ifdef VMS\n    envp = nh_getenv(\"HOME\");\n    if (envp)\n        Sprintf(tmp_wizkit, \"%s%s\", envp, wizkit);\n    else\n        Sprintf(tmp_wizkit, \"%s%s\", \"sys$login:\", wizkit);\n    if ((fp = fopenp(tmp_wizkit, \"r\")) != (FILE *) 0)\n        return fp;\n#else /* should be only UNIX left */\n    envp = nh_getenv(\"HOME\");\n    if (envp)\n        Sprintf(tmp_wizkit, \"%s/%s\", envp, wizkit);\n    else\n        Strcpy(tmp_wizkit, wizkit);\n    if ((fp = fopenp(tmp_wizkit, \"r\")) != (FILE *) 0)\n        return fp;\n    else if (errno != ENOENT) {\n        /* e.g., problems when setuid NetHack can't search home\n         * directory restricted to user */\n        raw_printf(\"Couldn't open default wizkit file %s (%d).\", tmp_wizkit,\n                   errno);\n        wait_synch();\n    }\n#endif\n#endif\n    return (FILE *) 0;\n}\n\n/* add to hero's inventory if there's room, otherwise put item on floor */\nSTATIC_DCL void\nwizkit_addinv(obj)\nstruct obj *obj;\n{\n    if (!obj || obj == &zeroobj)\n        return;\n\n    /* subset of starting inventory pre-ID */\n    obj->dknown = 1;\n    if (Role_if(PM_PRIEST))\n        obj->bknown = 1; /* ok to bypass set_bknown() */\n    /* same criteria as lift_object()'s check for available inventory slot */\n    if (obj->oclass != COIN_CLASS && inv_cnt(FALSE) >= 52\n        && !merge_choice(invent, obj)) {\n        /* inventory overflow; can't just place & stack object since\n           hero isn't in position yet, so schedule for arrival later */\n        add_to_migration(obj);\n        obj->ox = 0; /* index of main dungeon */\n        obj->oy = 1; /* starting level number */\n        obj->owornmask =\n            (long) (MIGR_WITH_HERO | MIGR_NOBREAK | MIGR_NOSCATTER);\n    } else {\n        (void) addinv(obj);\n    }\n}\n\n\nboolean\nproc_wizkit_line(buf)\nchar *buf;\n{\n    struct obj *otmp;\n\n    if (strlen(buf) >= BUFSZ)\n        buf[BUFSZ - 1] = '\\0';\n    otmp = readobjnam(buf, (struct obj *) 0);\n\n    if (otmp) {\n        if (otmp != &zeroobj)\n            wizkit_addinv(otmp);\n    } else {\n        /* .60 limits output line width to 79 chars */\n        config_error_add(\"Bad wizkit item: \\\"%.60s\\\"\", buf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nvoid\nread_wizkit()\n{\n    FILE *fp;\n\n    if (!wizard || !(fp = fopen_wizkit_file()))\n        return;\n\n    program_state.wizkit_wishing = 1;\n    config_error_init(TRUE, \"WIZKIT\", FALSE);\n\n    parse_conf_file(fp, proc_wizkit_line);\n    (void) fclose(fp);\n\n    config_error_done();\n    program_state.wizkit_wishing = 0;\n\n    return;\n}\n\n/* parse_conf_file\n *\n * Read from file fp, handling comments, empty lines, config sections,\n * CHOOSE, and line continuation, calling proc for every valid line.\n *\n * Continued lines are merged together with one space in between.\n */\nSTATIC_OVL boolean\nparse_conf_file(fp, proc)\nFILE *fp;\nboolean FDECL((*proc), (char *));\n{\n    char inbuf[4 * BUFSZ];\n    boolean rv = TRUE; /* assume successful parse */\n    char *ep;\n    boolean skip = FALSE, morelines = FALSE;\n    char *buf = (char *) 0;\n    size_t inbufsz = sizeof inbuf;\n\n    free_config_sections();\n\n    while (fgets(inbuf, (int) inbufsz, fp)) {\n        ep = index(inbuf, '\\n');\n        if (skip) { /* in case previous line was too long */\n            if (ep)\n                skip = FALSE; /* found newline; next line is normal */\n        } else {\n            if (!ep) {  /* newline missing */\n                if (strlen(inbuf) < (inbufsz - 2)) {\n                    /* likely the last line of file is just\n                       missing a newline; process it anyway  */\n                    ep = eos(inbuf);\n                } else {\n                    config_error_add(\"Line too long, skipping\");\n                    skip = TRUE; /* discard next fgets */\n                }\n            } else {\n                *ep = '\\0'; /* remove newline */\n            }\n            if (ep) {\n                char *tmpbuf = (char *) 0;\n                int len;\n                boolean ignoreline = FALSE;\n                boolean oldline = FALSE;\n\n                /* line continuation (trailing '\\') */\n                morelines = (--ep >= inbuf && *ep == '\\\\');\n                if (morelines)\n                    *ep = '\\0';\n\n                /* trim off spaces at end of line */\n                while (ep >= inbuf\n                       && (*ep == ' ' || *ep == '\\t' || *ep == '\\r'))\n                    *ep-- = '\\0';\n\n                if (!config_error_nextline(inbuf)) {\n                    rv = FALSE;\n                    if (buf)\n                        free(buf), buf = (char *) 0;\n                    break;\n                }\n\n                ep = inbuf;\n                while (*ep == ' ' || *ep == '\\t')\n                    ++ep;\n\n                /* ignore empty lines and full-line comment lines */\n                if (!*ep || *ep == '#')\n                    ignoreline = TRUE;\n\n                if (buf)\n                    oldline = TRUE;\n\n                /* merge now read line with previous ones, if necessary */\n                if (!ignoreline) {\n                    len = (int) strlen(ep) + 1; /* +1: final '\\0' */\n                    if (buf)\n                        len += (int) strlen(buf) + 1; /* +1: space */\n                    tmpbuf = (char *) alloc(len);\n                    *tmpbuf = '\\0';\n                    if (buf) {\n                        Strcat(strcpy(tmpbuf, buf), \" \");\n                        free(buf);\n                    }\n                    buf = strcat(tmpbuf, ep);\n                    buf[sizeof inbuf - 1] = '\\0';\n                }\n\n                if (morelines || (ignoreline && !oldline))\n                    continue;\n\n                if (handle_config_section(buf)) {\n                    free(buf);\n                    buf = (char *) 0;\n                    continue;\n                }\n\n                /* from here onwards, we'll handle buf only */\n\n                if (match_varname(buf, \"CHOOSE\", 6)) {\n                    char *section;\n                    char *bufp = find_optparam(buf);\n\n                    if (!bufp) {\n                        config_error_add(\n                                    \"Format is CHOOSE=section1,section2,...\");\n                        rv = FALSE;\n                        free(buf);\n                        buf = (char *) 0;\n                        continue;\n                    }\n                    bufp++;\n                    if (config_section_chosen)\n                        free(config_section_chosen), config_section_chosen = 0;\n                    section = choose_random_part(bufp, ',');\n                    if (section) {\n                        config_section_chosen = dupstr(section);\n                    } else {\n                        config_error_add(\"No config section to choose\");\n                        rv = FALSE;\n                    }\n                    free(buf);\n                    buf = (char *) 0;\n                    continue;\n                }\n\n                if (!proc(buf))\n                    rv = FALSE;\n\n                free(buf);\n                buf = (char *) 0;\n            }\n        }\n    }\n\n    if (buf)\n        free(buf);\n\n    free_config_sections();\n    return rv;\n}\n\nextern struct symsetentry *symset_list;  /* options.c */\nextern const char *known_handling[];     /* drawing.c */\nextern const char *known_restrictions[]; /* drawing.c */\nstatic int symset_count = 0;             /* for pick-list building only */\nstatic boolean chosen_symset_start = FALSE, chosen_symset_end = FALSE;\nstatic int symset_which_set = 0;\n\nSTATIC_OVL\nFILE *\nfopen_sym_file()\n{\n    FILE *fp;\n\n    fp = fopen_datafile(SYMBOLS, \"r\",\n#ifdef WIN32\n                            SYSCONFPREFIX\n#else\n                            HACKPREFIX\n#endif\n                       );\n\n    return fp;\n}\n\n/*\n * Returns 1 if the chose symset was found and loaded.\n *         0 if it wasn't found in the sym file or other problem.\n */\nint\nread_sym_file(which_set)\nint which_set;\n{\n    FILE *fp;\n\n    symset[which_set].explicitly = FALSE;\n    if (!(fp = fopen_sym_file()))\n        return 0;\n\n    symset[which_set].explicitly = TRUE;\n    symset_count = 0;\n    chosen_symset_start = chosen_symset_end = FALSE;\n    symset_which_set = which_set;\n\n    config_error_init(TRUE, \"symbols\", FALSE);\n\n    parse_conf_file(fp, proc_symset_line);\n    (void) fclose(fp);\n\n    if (!chosen_symset_start && !chosen_symset_end) {\n        /* name caller put in symset[which_set].name was not found;\n           if it looks like \"Default symbols\", null it out and return\n           success to use the default; otherwise, return failure */\n        if (symset[which_set].name\n            && (fuzzymatch(symset[which_set].name, \"Default symbols\",\n                           \" -_\", TRUE)\n                || !strcmpi(symset[which_set].name, \"default\")))\n            clear_symsetentry(which_set, TRUE);\n        config_error_done();\n\n        /* If name was defined, it was invalid... Then we're loading fallback */\n        if (symset[which_set].name) {\n            symset[which_set].explicitly = FALSE;\n            return 0;\n        }\n\n        return 1;\n    }\n    if (!chosen_symset_end)\n        config_error_add(\"Missing finish for symset \\\"%s\\\"\",\n                         symset[which_set].name ? symset[which_set].name\n                                                : \"unknown\");\n    config_error_done();\n    return 1;\n}\n\nboolean\nproc_symset_line(buf)\nchar *buf;\n{\n    return !((boolean) parse_sym_line(buf, symset_which_set));\n}\n\n/* returns 0 on error */\nint\nparse_sym_line(buf, which_set)\nchar *buf;\nint which_set;\n{\n    int val, i;\n    struct symparse *symp;\n    char *bufp, *commentp, *altp;\n\n    if (strlen(buf) >= BUFSZ)\n        buf[BUFSZ - 1] = '\\0';\n    /* convert each instance of whitespace (tabs, consecutive spaces)\n       into a single space; leading and trailing spaces are stripped */\n    mungspaces(buf);\n\n    /* remove trailing comment, if any (this isn't strictly needed for\n       individual symbols, and it won't matter if \"X#comment\" without\n       separating space slips through; for handling or set description,\n       symbol set creator is responsible for preceding '#' with a space\n       and that comment itself doesn't contain \" #\") */\n    if ((commentp = rindex(buf, '#')) != 0 && commentp[-1] == ' ')\n        commentp[-1] = '\\0';\n\n    /* find the '=' or ':' */\n    bufp = index(buf, '=');\n    altp = index(buf, ':');\n    if (!bufp || (altp && altp < bufp))\n        bufp = altp;\n    if (!bufp) {\n        if (strncmpi(buf, \"finish\", 6) == 0) {\n            /* end current graphics set */\n            if (chosen_symset_start)\n                chosen_symset_end = TRUE;\n            chosen_symset_start = FALSE;\n            return 1;\n        }\n        config_error_add(\"No \\\"finish\\\"\");\n        return 0;\n    }\n    /* skip '=' and space which follows, if any */\n    ++bufp;\n    if (*bufp == ' ')\n        ++bufp;\n\n    symp = match_sym(buf);\n    if (!symp) {\n        config_error_add(\"Unknown sym keyword\");\n        return 0;\n    }\n\n    if (!symset[which_set].name) {\n        /* A null symset name indicates that we're just\n           building a pick-list of possible symset\n           values from the file, so only do that */\n        if (symp->range == SYM_CONTROL) {\n            struct symsetentry *tmpsp, *lastsp;\n\n            for (lastsp = symset_list; lastsp; lastsp = lastsp->next)\n                if (!lastsp->next)\n                    break;\n            switch (symp->idx) {\n            case 0:\n                tmpsp = (struct symsetentry *) alloc(sizeof *tmpsp);\n                tmpsp->next = (struct symsetentry *) 0;\n                if (!lastsp)\n                    symset_list = tmpsp;\n                else\n                    lastsp->next = tmpsp;\n                tmpsp->idx = symset_count++;\n                tmpsp->name = dupstr(bufp);\n                tmpsp->desc = (char *) 0;\n                tmpsp->handling = H_UNK;\n                /* initialize restriction bits */\n                tmpsp->nocolor = 0;\n                tmpsp->primary = 0;\n                tmpsp->rogue = 0;\n                break;\n            case 2:\n                /* handler type identified */\n                tmpsp = lastsp; /* most recent symset */\n                for (i = 0; known_handling[i]; ++i)\n                    if (!strcmpi(known_handling[i], bufp)) {\n                        tmpsp->handling = i;\n                        break; /* for loop */\n                    }\n                break;\n            case 3:\n                /* description:something */\n                tmpsp = lastsp; /* most recent symset */\n                if (tmpsp && !tmpsp->desc)\n                    tmpsp->desc = dupstr(bufp);\n                break;\n            case 5:\n                /* restrictions: xxxx*/\n                tmpsp = lastsp; /* most recent symset */\n                for (i = 0; known_restrictions[i]; ++i) {\n                    if (!strcmpi(known_restrictions[i], bufp)) {\n                        switch (i) {\n                        case 0:\n                            tmpsp->primary = 1;\n                            break;\n                        case 1:\n                            tmpsp->rogue = 1;\n                            break;\n                        }\n                        break; /* while loop */\n                    }\n                }\n                break;\n            }\n        }\n        return 1;\n    }\n    if (symp->range) {\n        if (symp->range == SYM_CONTROL) {\n            switch (symp->idx) {\n            case 0:\n                /* start of symset */\n                if (!strcmpi(bufp, symset[which_set].name)) {\n                    /* matches desired one */\n                    chosen_symset_start = TRUE;\n                    /* these init_*() functions clear symset fields too */\n                    if (which_set == ROGUESET)\n                        init_rogue_symbols();\n                    else if (which_set == PRIMARY)\n                        init_primary_symbols();\n                }\n                break;\n            case 1:\n                /* finish symset */\n                if (chosen_symset_start)\n                    chosen_symset_end = TRUE;\n                chosen_symset_start = FALSE;\n                break;\n            case 2:\n                /* handler type identified */\n                if (chosen_symset_start)\n                    set_symhandling(bufp, which_set);\n                break;\n            /* case 3: (description) is ignored here */\n            case 4: /* color:off */\n                if (chosen_symset_start) {\n                    if (bufp) {\n                        if (!strcmpi(bufp, \"true\") || !strcmpi(bufp, \"yes\")\n                            || !strcmpi(bufp, \"on\"))\n                            symset[which_set].nocolor = 0;\n                        else if (!strcmpi(bufp, \"false\")\n                                 || !strcmpi(bufp, \"no\")\n                                 || !strcmpi(bufp, \"off\"))\n                            symset[which_set].nocolor = 1;\n                    }\n                }\n                break;\n            case 5: /* restrictions: xxxx*/\n                if (chosen_symset_start) {\n                    int n = 0;\n\n                    while (known_restrictions[n]) {\n                        if (!strcmpi(known_restrictions[n], bufp)) {\n                            switch (n) {\n                            case 0:\n                                symset[which_set].primary = 1;\n                                break;\n                            case 1:\n                                symset[which_set].rogue = 1;\n                                break;\n                            }\n                            break; /* while loop */\n                        }\n                        n++;\n                    }\n                }\n                break;\n            }\n        } else { /* !SYM_CONTROL */\n            val = sym_val(bufp);\n            if (chosen_symset_start) {\n                if (which_set == PRIMARY) {\n                    update_primary_symset(symp, val);\n                } else if (which_set == ROGUESET) {\n                    update_rogue_symset(symp, val);\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nSTATIC_OVL void\nset_symhandling(handling, which_set)\nchar *handling;\nint which_set;\n{\n    int i = 0;\n\n    symset[which_set].handling = H_UNK;\n    while (known_handling[i]) {\n        if (!strcmpi(known_handling[i], handling)) {\n            symset[which_set].handling = i;\n            return;\n        }\n        i++;\n    }\n}\n\n/* ----------  END CONFIG FILE HANDLING ----------- */\n\n/* ----------  BEGIN SCOREBOARD CREATION ----------- */\n\n#ifdef OS2_CODEVIEW\n#define UNUSED_if_not_OS2_CODEVIEW /*empty*/\n#else\n#define UNUSED_if_not_OS2_CODEVIEW UNUSED\n#endif\n\n/* verify that we can write to scoreboard file; if not, try to create one */\n/*ARGUSED*/\nvoid\ncheck_recordfile(dir)\nconst char *dir UNUSED_if_not_OS2_CODEVIEW;\n{\n#if defined(PRAGMA_UNUSED) && !defined(OS2_CODEVIEW)\n#pragma unused(dir)\n#endif\n    const char *fq_record;\n    int fd;\n\n#if defined(UNIX) || defined(VMS)\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n    fd = open(fq_record, O_RDWR, 0);\n    if (fd >= 0) {\n#ifdef VMS /* must be stream-lf to use UPDATE_RECORD_IN_PLACE */\n        if (!file_is_stmlf(fd)) {\n            raw_printf(\n                   \"Warning: scoreboard file '%s' is not in stream_lf format\",\n                       fq_record);\n            wait_synch();\n        }\n#endif\n        (void) nhclose(fd); /* RECORD is accessible */\n    } else if ((fd = open(fq_record, O_CREAT | O_RDWR, FCMASK)) >= 0) {\n        (void) nhclose(fd); /* RECORD newly created */\n#if defined(VMS) && !defined(SECURE)\n        /* Re-protect RECORD with world:read+write+execute+delete access. */\n        (void) chmod(fq_record, FCMASK | 007);\n#endif /* VMS && !SECURE */\n    } else {\n        raw_printf(\"Warning: cannot write scoreboard file '%s'\", fq_record);\n        wait_synch();\n    }\n#endif /* !UNIX && !VMS */\n#if defined(MICRO) || defined(WIN32)\n    char tmp[PATHLEN];\n\n#ifdef OS2_CODEVIEW /* explicit path on opening for OS/2 */\n    /* how does this work when there isn't an explicit path or fopenp\n     * for later access to the file via fopen_datafile? ? */\n    (void) strncpy(tmp, dir, PATHLEN - 1);\n    tmp[PATHLEN - 1] = '\\0';\n    if ((strlen(tmp) + 1 + strlen(RECORD)) < (PATHLEN - 1)) {\n        append_slash(tmp);\n        Strcat(tmp, RECORD);\n    }\n    fq_record = tmp;\n#else\n    Strcpy(tmp, RECORD);\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n#endif\n#ifdef WIN32\n    /* If dir is NULL it indicates create but\n       only if it doesn't already exist */\n    if (!dir) {\n        char buf[BUFSZ];\n\n        buf[0] = '\\0';\n        fd = open(fq_record, O_RDWR);\n        if (!(fd == -1 && errno == ENOENT)) {\n            if (fd >= 0) {\n                (void) nhclose(fd);\n            } else {\n                /* explanation for failure other than missing file */\n                Sprintf(buf, \"error   \\\"%s\\\", (errno %d).\",\n                        fq_record, errno);\n                paniclog(\"scorefile\", buf);\n            }\n            return;\n        }\n        Sprintf(buf, \"missing \\\"%s\\\", creating new scorefile.\",\n                fq_record);\n        paniclog(\"scorefile\", buf);\n    }\n#endif\n\n    if ((fd = open(fq_record, O_RDWR)) < 0) {\n        /* try to create empty 'record' */\n#if defined(AZTEC_C) || defined(_DCC) \\\n    || (defined(__GNUC__) && defined(__AMIGA__))\n        /* Aztec doesn't use the third argument */\n        /* DICE doesn't like it */\n        fd = open(fq_record, O_CREAT | O_RDWR);\n#else\n        fd = open(fq_record, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);\n#endif\n        if (fd <= 0) {\n            raw_printf(\"Warning: cannot write record '%s'\", tmp);\n            wait_synch();\n        } else {\n            (void) nhclose(fd);\n        }\n    } else {\n        /* open succeeded => 'record' exists */\n        (void) nhclose(fd);\n    }\n#else /* MICRO || WIN32*/\n\n#ifdef MAC\n    /* Create the \"record\" file, if necessary */\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n    fd = macopen(fq_record, O_RDWR | O_CREAT, TEXT_TYPE);\n    if (fd != -1)\n        macclose(fd);\n#endif /* MAC */\n\n#endif /* MICRO || WIN32*/\n}\n\n/* ----------  END SCOREBOARD CREATION ----------- */\n\n/* ----------  BEGIN PANIC/IMPOSSIBLE/TESTING LOG ----------- */\n\n/*ARGSUSED*/\nvoid\npaniclog(type, reason)\nconst char *type;   /* panic, impossible, trickery */\nconst char *reason; /* explanation */\n{\n#ifdef PANICLOG\n    FILE *lfile;\n    char buf[BUFSZ];\n\n    if (!program_state.in_paniclog) {\n        program_state.in_paniclog = 1;\n        lfile = fopen_datafile(PANICLOG, \"a\", TROUBLEPREFIX);\n        if (lfile) {\n#ifdef PANICLOG_FMT2\n            (void) fprintf(lfile, \"%ld %s: %s %s\\n\",\n                           ubirthday, (plname ? plname : \"(none)\"),\n                           type, reason);\n#else\n            time_t now = getnow();\n            int uid = getuid();\n            char playmode = wizard ? 'D' : discover ? 'X' : '-';\n\n            (void) fprintf(lfile, \"%s %08ld %06ld %d %c: %s %s\\n\",\n                           version_string(buf), yyyymmdd(now), hhmmss(now),\n                           uid, playmode, type, reason);\n#endif /* !PANICLOG_FMT2 */\n            (void) fclose(lfile);\n        }\n        program_state.in_paniclog = 0;\n    }\n#endif /* PANICLOG */\n    return;\n}\n\nvoid\ntestinglog(filenm, type, reason)\nconst char *filenm;   /* ad hoc file name */\nconst char *type;\nconst char *reason;   /* explanation */\n{\n    FILE *lfile;\n    char fnbuf[BUFSZ];\n\n    if (!filenm)\n        return;\n    Strcpy(fnbuf, filenm);\n    if (index(fnbuf, '.') == 0)\n        Strcat(fnbuf, \".log\");\n    lfile = fopen_datafile(fnbuf, \"a\", TROUBLEPREFIX);\n    if (lfile) {\n        (void) fprintf(lfile, \"%s\\n%s\\n\", type, reason);\n        (void) fclose(lfile);\n    }\n    return;\n}\n\n/* ----------  END PANIC/IMPOSSIBLE/TESTING LOG ----------- */\n\n#ifdef SELF_RECOVER\n\n/* ----------  BEGIN INTERNAL RECOVER ----------- */\nboolean\nrecover_savefile()\n{\n    int gfd, lfd, sfd;\n    int lev, savelev, hpid, pltmpsiz;\n    xchar levc;\n    struct version_info version_data;\n    int processed[256];\n    char savename[SAVESIZE], errbuf[BUFSZ];\n    struct savefile_info sfi;\n    char tmpplbuf[PL_NSIZ];\n\n    for (lev = 0; lev < 256; lev++)\n        processed[lev] = 0;\n\n    /* level 0 file contains:\n     *  pid of creating process (ignored here)\n     *  level number for current level of save file\n     *  name of save file nethack would have created\n     *  savefile info\n     *  player name\n     *  and game state\n     */\n    gfd = open_levelfile(0, errbuf);\n    if (gfd < 0) {\n        raw_printf(\"%s\\n\", errbuf);\n        return FALSE;\n    }\n    if (read(gfd, (genericptr_t) &hpid, sizeof hpid) != sizeof hpid) {\n        raw_printf(\"\\n%s\\n%s\\n\",\n            \"Checkpoint data incompletely written or subsequently clobbered.\",\n                   \"Recovery impossible.\");\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n    if (read(gfd, (genericptr_t) &savelev, sizeof(savelev))\n        != sizeof(savelev)) {\n        raw_printf(\n         \"\\nCheckpointing was not in effect for %s -- recovery impossible.\\n\",\n                   lock);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n    if ((read(gfd, (genericptr_t) savename, sizeof savename)\n         != sizeof savename)\n        || (read(gfd, (genericptr_t) &version_data, sizeof version_data)\n            != sizeof version_data)\n        || (read(gfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi)\n        || (read(gfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)\n            != sizeof pltmpsiz) || (pltmpsiz > PL_NSIZ)\n        || (read(gfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz)) {\n        raw_printf(\"\\nError reading %s -- can't recover.\\n\", lock);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n\n    /* save file should contain:\n     *  version info\n     *  savefile info\n     *  player name\n     *  current level (including pets)\n     *  (non-level-based) game state\n     *  other levels\n     */\n    set_savefile_name(TRUE);\n    sfd = create_savefile();\n    if (sfd < 0) {\n        raw_printf(\"\\nCannot recover savefile %s.\\n\", SAVEF);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n\n    lfd = open_levelfile(savelev, errbuf);\n    if (lfd < 0) {\n        raw_printf(\"\\n%s\\n\", errbuf);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &version_data, sizeof version_data)\n        != sizeof version_data) {\n        raw_printf(\"\\nError writing %s; recovery failed.\", SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi) {\n        raw_printf(\"\\nError writing %s; recovery failed (savefile_info).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)\n        != sizeof pltmpsiz) {\n        raw_printf(\"Error writing %s; recovery failed (player name size).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz) {\n        raw_printf(\"Error writing %s; recovery failed (player name).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (!copy_bytes(lfd, sfd)) {\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n    (void) nhclose(lfd);\n    processed[savelev] = 1;\n\n    if (!copy_bytes(gfd, sfd)) {\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        delete_savefile();\n        return FALSE;\n    }\n    (void) nhclose(gfd);\n    processed[0] = 1;\n\n    for (lev = 1; lev < 256; lev++) {\n        /* level numbers are kept in xchars in save.c, so the\n         * maximum level number (for the endlevel) must be < 256\n         */\n        if (lev != savelev) {\n            lfd = open_levelfile(lev, (char *) 0);\n            if (lfd >= 0) {\n                /* any or all of these may not exist */\n                levc = (xchar) lev;\n                write(sfd, (genericptr_t) &levc, sizeof(levc));\n                if (!copy_bytes(lfd, sfd)) {\n                    (void) nhclose(lfd);\n                    (void) nhclose(sfd);\n                    delete_savefile();\n                    return FALSE;\n                }\n                (void) nhclose(lfd);\n                processed[lev] = 1;\n            }\n        }\n    }\n    (void) nhclose(sfd);\n\n#ifdef HOLD_LOCKFILE_OPEN\n    really_close();\n#endif\n    /*\n     * We have a successful savefile!\n     * Only now do we erase the level files.\n     */\n    for (lev = 0; lev < 256; lev++) {\n        if (processed[lev]) {\n            const char *fq_lock;\n\n            set_levelfile_name(lock, lev);\n            fq_lock = fqname(lock, LEVELPREFIX, 3);\n            (void) unlink(fq_lock);\n        }\n    }\n    return TRUE;\n}\n\nboolean\ncopy_bytes(ifd, ofd)\nint ifd, ofd;\n{\n    char buf[BUFSIZ];\n    int nfrom, nto;\n\n    do {\n        nfrom = read(ifd, buf, BUFSIZ);\n        nto = write(ofd, buf, nfrom);\n        if (nto != nfrom)\n            return FALSE;\n    } while (nfrom == BUFSIZ);\n    return TRUE;\n}\n\n/* ----------  END INTERNAL RECOVER ----------- */\n#endif /*SELF_RECOVER*/\n\n/* ----------  OTHER ----------- */\n\n#ifdef SYSCF\n#ifdef SYSCF_FILE\nvoid\nassure_syscf_file()\n{\n    int fd;\n\n#ifdef WIN32\n    /* We are checking that the sysconf exists ... lock the path */\n    fqn_prefix_locked[SYSCONFPREFIX] = TRUE;\n#endif\n    /*\n     * All we really care about is the end result - can we read the file?\n     * So just check that directly.\n     *\n     * Not tested on most of the old platforms (which don't attempt\n     * to implement SYSCF).\n     * Some ports don't like open()'s optional third argument;\n     * VMS overrides open() usage with a macro which requires it.\n     */\n#ifndef VMS\n# if defined(NOCWD_ASSUMPTIONS) && defined(WIN32)\n    fd = open(fqname(SYSCF_FILE, SYSCONFPREFIX, 0), O_RDONLY);\n# else\n    fd = open(SYSCF_FILE, O_RDONLY);\n# endif\n#else\n    fd = open(SYSCF_FILE, O_RDONLY, 0);\n#endif\n    if (fd >= 0) {\n        /* readable */\n        close(fd);\n        return;\n    }\n    raw_printf(\"Unable to open SYSCF_FILE.\\n\");\n    exit(EXIT_FAILURE);\n}\n\n#endif /* SYSCF_FILE */\n#endif /* SYSCF */\n\n#ifdef DEBUG\n/* used by debugpline() to decide whether to issue a message\n * from a particular source file; caller passes __FILE__ and we check\n * whether it is in the source file list supplied by SYSCF's DEBUGFILES\n *\n * pass FALSE to override wildcard matching; useful for files\n * like dungeon.c and questpgr.c, which generate a ridiculous amount of\n * output if DEBUG is defined and effectively block the use of a wildcard */\nboolean\ndebugcore(filename, wildcards)\nconst char *filename;\nboolean wildcards;\n{\n    const char *debugfiles, *p;\n\n    if (!filename || !*filename)\n        return FALSE; /* sanity precaution */\n\n    if (sysopt.env_dbgfl == 0) {\n        /* check once for DEBUGFILES in the environment;\n           if found, it supersedes the sysconf value\n           [note: getenv() rather than nh_getenv() since a long value\n           is valid and doesn't pose any sort of overflow risk here] */\n        if ((p = getenv(\"DEBUGFILES\")) != 0) {\n            if (sysopt.debugfiles)\n                free((genericptr_t) sysopt.debugfiles);\n            sysopt.debugfiles = dupstr(p);\n            sysopt.env_dbgfl = 1;\n        } else\n            sysopt.env_dbgfl = -1;\n    }\n\n    debugfiles = sysopt.debugfiles;\n    /* usual case: sysopt.debugfiles will be empty */\n    if (!debugfiles || !*debugfiles)\n        return FALSE;\n\n/* strip filename's path if present */\n#ifdef UNIX\n    if ((p = rindex(filename, '/')) != 0)\n        filename = p + 1;\n#endif\n#ifdef VMS\n    filename = vms_basename(filename);\n    /* vms_basename strips off 'type' suffix as well as path and version;\n       we want to put suffix back (\".c\" assumed); since it always returns\n       a pointer to a static buffer, we can safely modify its result */\n    Strcat((char *) filename, \".c\");\n#endif\n\n    /*\n     * Wildcard match will only work if there's a single pattern (which\n     * might be a single file name without any wildcarding) rather than\n     * a space-separated list.\n     * [to NOT do: We could step through the space-separated list and\n     * attempt a wildcard match against each element, but that would be\n     * overkill for the intended usage.]\n     */\n    if (wildcards && pmatch(debugfiles, filename))\n        return TRUE;\n\n    /* check whether filename is an element of the list */\n    if ((p = strstr(debugfiles, filename)) != 0) {\n        int l = (int) strlen(filename);\n\n        if ((p == debugfiles || p[-1] == ' ' || p[-1] == '/')\n            && (p[l] == ' ' || p[l] == '\\0'))\n            return TRUE;\n    }\n    return FALSE;\n}\n\n#endif /*DEBUG*/\n\n#ifdef UNIX\n#ifndef PATH_MAX\n#include <limits.h>\n#endif\n#endif\n\nvoid\nreveal_paths(VOID_ARGS)\n{\n    const char *fqn, *nodumpreason;\n    char buf[BUFSZ];\n#if defined(SYSCF) || !defined(UNIX) || defined(DLB)\n    const char *filep;\n#ifdef SYSCF\n    const char *gamename = (hname && *hname) ? hname : \"NetHack\";\n#endif\n#endif\n#ifdef UNIX\n    char *endp, *envp, cwdbuf[PATH_MAX];\n#endif\n#ifdef PREFIXES_IN_USE\n    const char *strp;\n    int i, maxlen = 0;\n\n    raw_print(\"Variable playground locations:\");\n    for (i = 0; i < PREFIX_COUNT; i++)\n        raw_printf(\"    [%-10s]=\\\"%s\\\"\", fqn_prefix_names[i],\n                   fqn_prefix[i] ? fqn_prefix[i] : \"not set\");\n#endif\n\n    /* sysconf file */\n\n#ifdef SYSCF\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[SYSCONFPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#else\n    buf[0] = '\\0';\n#endif\n    raw_printf(\"%s system configuration file%s:\", s_suffix(gamename), buf);\n#ifdef SYSCF_FILE\n    filep = SYSCF_FILE;\n#else\n    filep = \"sysconf\";\n#endif\n    fqn = fqname(filep, SYSCONFPREFIX, 0);\n    if (fqn) {\n        set_configfile_name(fqn);\n        filep = configfile;\n    }\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#else /* !SYSCF */\n    raw_printf(\"No system configuration file.\");\n#endif /* ?SYSCF */\n\n    /* symbols file */\n\n    buf[0] = '\\0';\n#ifndef UNIX\n#ifdef PREFIXES_IN_USE\n#ifdef WIN32\n    strp = fqn_prefix_names[SYSCONFPREFIX];\n#else\n    strp = fqn_prefix_names[HACKPREFIX];\n#endif /* WIN32 */\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"The loadable symbols file%s:\", buf);\n#endif /* UNIX */\n\n#ifdef UNIX\n    envp = getcwd(cwdbuf, PATH_MAX);\n    if (envp) {\n        raw_print(\"The loadable symbols file:\");\n        raw_printf(\"    \\\"%s/%s\\\"\", envp, SYMBOLS);\n    }\n#else /* UNIX */\n    filep = SYMBOLS;\n#ifdef PREFIXES_IN_USE\n#ifdef WIN32\n    fqn = fqname(filep, SYSCONFPREFIX, 1);\n#else\n    fqn = fqname(filep, HACKPREFIX, 1);\n#endif /* WIN32 */\n    if (fqn)\n        filep = fqn;\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#endif /* UNIX */\n\n    /* dlb vs non-dlb */\n\n    buf[0] = '\\0';\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[DATAPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif\n#ifdef DLB\n    raw_printf(\"Basic data files%s are collected inside:\", buf);\n    filep = DLBFILE;\n#ifdef VERSION_IN_DLB_FILENAME\n    Strcpy(buf, build_dlb_filename((const char *) 0));\n#ifdef PREFIXES_IN_USE\n    fqn = fqname(buf, DATAPREFIX, 1);\n    if (fqn)\n        filep = fqn;\n#endif /* PREFIXES_IN_USE */\n#endif\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#ifdef DLBFILE2\n    filep = DLBFILE2;\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#endif\n#else /* !DLB */\n    raw_printf(\"Basic data files%s are in many separate files.\", buf);\n#endif /* ?DLB */\n\n    /* dumplog */\n\n#ifndef DUMPLOG\n    nodumpreason = \"not supported\";\n#else\n    nodumpreason = \"disabled\";\n#ifdef SYSCF\n    fqn = sysopt.dumplogfile;\n#else  /* !SYSCF */\n#ifdef DUMPLOG_FILE\n    fqn = DUMPLOG_FILE;\n#else\n    fqn = (char *) 0;\n#endif\n#endif /* ?SYSCF */\n    if (fqn && *fqn) {\n        raw_print(\"Your end-of-game disclosure file:\");\n        (void) dump_fmtstr(fqn, buf, FALSE);\n        buf[sizeof buf - sizeof \"    \\\"\\\"\"] = '\\0';\n        raw_printf(\"    \\\"%s\\\"\", buf);\n    } else\n#endif /* ?DUMPLOG */\n        raw_printf(\"No end-of-game disclosure file (%s).\", nodumpreason);\n\n#ifdef WIN32\n    if (sysopt.portable_device_top) {\n        const char *pd = get_portable_device();\n\n        raw_printf(\"Writable folder for portable device config (sysconf %s):\",\n                    \"portable_device_top\");\n        raw_printf(\"    \\\"%s\\\"\", pd);\n    }\n#endif\n\n    /* personal configuration file */\n\n    buf[0] = '\\0';\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[CONFIGPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"Your personal configuration file%s:\", buf);\n\n#ifdef UNIX\n    buf[0] = '\\0';\n    if ((envp = nh_getenv(\"HOME\")) != 0) {\n        copynchars(buf, envp, (int) sizeof buf - 1 - 1);\n        Strcat(buf, \"/\");\n    }\n    endp = eos(buf);\n    copynchars(endp, default_configfile,\n               (int) (sizeof buf - 1 - strlen(buf)));\n#if defined(__APPLE__) /* UNIX+__APPLE__ => MacOSX aka OSX aka macOS */\n    if (envp) {\n        if (access(buf, 4) == -1) { /* 4: R_OK, -1: failure */\n            /* read access to default failed; might be protected excessively\n               but more likely it doesn't exist; try first alternate:\n               \"$HOME/Library/Pref...\"; 'endp' points past '/' */\n            copynchars(endp, \"Library/Preferences/NetHack Defaults\",\n                       (int) (sizeof buf - 1 - strlen(buf)));\n            if (access(buf, 4) == -1) {\n                /* first alternate failed, try second:\n                   \".../NetHack Defaults.txt\"; no 'endp', just append */\n                copynchars(eos(buf), \".txt\",\n                           (int) (sizeof buf - 1 - strlen(buf)));\n                if (access(buf, 4) == -1) {\n                    /* second alternate failed too, so revert to the\n                       original default (\"$HOME/.nethackrc\") for message */\n                    copynchars(endp, default_configfile,\n                               (int) (sizeof buf - 1 - strlen(buf)));\n                }\n            }\n        }\n    }\n#endif /* __APPLE__ */\n    raw_printf(\"    \\\"%s\\\"\", buf);\n#else /* !UNIX */\n    fqn = (const char *) 0;\n#ifdef PREFIXES_IN_USE\n    fqn = fqname(default_configfile, CONFIGPREFIX, 2);\n#endif\n    raw_printf(\"    \\\"%s\\\"\", fqn ? fqn : default_configfile);\n#endif  /* ?UNIX */\n\n    raw_print(\"\");\n}\n\n/* ----------  BEGIN TRIBUTE ----------- */\n\n/* 3.6 tribute code\n */\n\n#define SECTIONSCOPE 1\n#define TITLESCOPE 2\n#define PASSAGESCOPE 3\n\n#define MAXPASSAGES SIZE(context.novel.pasg) /* 20 */\n\nstatic int FDECL(choose_passage, (int, unsigned));\n\n/* choose a random passage that hasn't been chosen yet; once all have\n   been chosen, reset the tracking to make all passages available again */\nstatic int\nchoose_passage(passagecnt, oid)\nint passagecnt; /* total of available passages */\nunsigned oid; /* book.o_id, used to determine whether re-reading same book */\n{\n    int idx, res;\n\n    if (passagecnt < 1)\n        return 0;\n\n    /* if a different book or we've used up all the passages already,\n       reset in order to have all 'passagecnt' passages available */\n    if (oid != context.novel.id || context.novel.count == 0) {\n        int i, range = passagecnt, limit = MAXPASSAGES;\n\n        context.novel.id = oid;\n        if (range <= limit) {\n            /* collect all of the N indices */\n            context.novel.count = passagecnt;\n            for (idx = 0; idx < MAXPASSAGES; idx++)\n                context.novel.pasg[idx] = (xchar) ((idx < passagecnt)\n                                                   ? idx + 1 : 0);\n        } else {\n            /* collect MAXPASSAGES of the N indices */\n            context.novel.count = MAXPASSAGES;\n            for (idx = i = 0; i < passagecnt; ++i, --range)\n                if (range > 0 && rn2(range) < limit) {\n                    context.novel.pasg[idx++] = (xchar) (i + 1);\n                    --limit;\n                }\n        }\n    }\n\n    idx = rn2(context.novel.count);\n    res = (int) context.novel.pasg[idx];\n    /* move the last slot's passage index into the slot just used\n       and reduce the number of passages available */\n    context.novel.pasg[idx] = context.novel.pasg[--context.novel.count];\n    return res;\n}\n\n/* Returns True if you were able to read something. */\nboolean\nread_tribute(tribsection, tribtitle, tribpassage, nowin_buf, bufsz, oid)\nconst char *tribsection, *tribtitle;\nint tribpassage, bufsz;\nchar *nowin_buf;\nunsigned oid; /* book identifier */\n{\n    dlb *fp;\n    char line[BUFSZ], lastline[BUFSZ];\n\n    int scope = 0;\n    int linect = 0, passagecnt = 0, targetpassage = 0;\n    const char *badtranslation = \"an incomprehensible foreign translation\";\n    boolean matchedsection = FALSE, matchedtitle = FALSE;\n    winid tribwin = WIN_ERR;\n    boolean grasped = FALSE;\n    boolean foundpassage = FALSE;\n\n    if (nowin_buf)\n        *nowin_buf = '\\0';\n\n    /* check for mandatories */\n    if (!tribsection || !tribtitle) {\n        if (!nowin_buf)\n            pline(\"It's %s of \\\"%s\\\"!\", badtranslation, tribtitle);\n        return grasped;\n    }\n\n    debugpline3(\"read_tribute %s, %s, %d.\", tribsection, tribtitle,\n                tribpassage);\n\n    fp = dlb_fopen(TRIBUTEFILE, \"r\");\n    if (!fp) {\n        /* this is actually an error - cannot open tribute file! */\n        if (!nowin_buf)\n            pline(\"You feel too overwhelmed to continue!\");\n        return grasped;\n    }\n\n    /*\n     * Syntax (not case-sensitive):\n     *  %section books\n     *\n     * In the books section:\n     *    %title booktitle (n)\n     *          where booktitle=book title without quotes\n     *          (n)= total number of passages present for this title\n     *    %passage k\n     *          where k=sequential passage number\n     *\n     * %e ends the passage/book/section\n     *    If in a passage, it marks the end of that passage.\n     *    If in a book, it marks the end of that book.\n     *    If in a section, it marks the end of that section.\n     *\n     *  %section death\n     */\n\n    *line = *lastline = '\\0';\n    while (dlb_fgets(line, sizeof line, fp) != 0) {\n        linect++;\n        (void) strip_newline(line);\n        switch (line[0]) {\n        case '%':\n            if (!strncmpi(&line[1], \"section \", sizeof \"section \" - 1)) {\n                char *st = &line[9]; /* 9 from \"%section \" */\n\n                scope = SECTIONSCOPE;\n                matchedsection = !strcmpi(st, tribsection) ? TRUE : FALSE;\n            } else if (!strncmpi(&line[1], \"title \", sizeof \"title \" - 1)) {\n                char *st = &line[7]; /* 7 from \"%title \" */\n                char *p1, *p2;\n\n                if ((p1 = index(st, '(')) != 0) {\n                    *p1++ = '\\0';\n                    (void) mungspaces(st);\n                    if ((p2 = index(p1, ')')) != 0) {\n                        *p2 = '\\0';\n                        passagecnt = atoi(p1);\n                        scope = TITLESCOPE;\n                        if (matchedsection && !strcmpi(st, tribtitle)) {\n                            matchedtitle = TRUE;\n                            targetpassage = !tribpassage\n                                             ? choose_passage(passagecnt, oid)\n                                             : (tribpassage <= passagecnt)\n                                                ? tribpassage : 0;\n                        } else {\n                            matchedtitle = FALSE;\n                        }\n                    }\n                }\n            } else if (!strncmpi(&line[1], \"passage \",\n                                 sizeof \"passage \" - 1)) {\n                int passagenum = 0;\n                char *st = &line[9]; /* 9 from \"%passage \" */\n\n                mungspaces(st);\n                passagenum = atoi(st);\n                if (passagenum > 0 && passagenum <= passagecnt) {\n                    scope = PASSAGESCOPE;\n                    if (matchedtitle && passagenum == targetpassage) {\n                        foundpassage = TRUE;\n                        if (!nowin_buf) {\n                            tribwin = create_nhwindow(NHW_MENU);\n                            if (tribwin == WIN_ERR)\n                                goto cleanup;\n                        }\n                    }\n                }\n            } else if (!strncmpi(&line[1], \"e \", sizeof \"e \" - 1)) {\n                if (foundpassage)\n                    goto cleanup;\n                if (scope == TITLESCOPE)\n                    matchedtitle = FALSE;\n                if (scope == SECTIONSCOPE)\n                    matchedsection = FALSE;\n                if (scope)\n                    --scope;\n            } else {\n                debugpline1(\"tribute file error: bad %% command, line %d.\",\n                            linect);\n            }\n            break;\n        case '#':\n            /* comment only, next! */\n            break;\n        default:\n            if (foundpassage) {\n                if (!nowin_buf) {\n                    /* outputting multi-line passage to text window */\n                    putstr(tribwin, 0, line);\n                    if (*line)\n                        Strcpy(lastline, line);\n                } else {\n                    /* fetching one-line passage into buffer */\n                    copynchars(nowin_buf, line, bufsz - 1);\n                    goto cleanup; /* don't wait for \"%e passage\" */\n                }\n            }\n        }\n    }\n\n cleanup:\n    (void) dlb_fclose(fp);\n    if (nowin_buf) {\n        /* one-line buffer */\n        grasped = *nowin_buf ? TRUE : FALSE;\n    } else {\n        if (tribwin != WIN_ERR) { /* implies 'foundpassage' */\n            /* multi-line window, normal case;\n               if lastline is empty, there were no non-empty lines between\n               \"%passage n\" and \"%e passage\" so we leave 'grasped' False */\n            if (*lastline) {\n                display_nhwindow(tribwin, FALSE);\n                /* put the final attribution line into message history,\n                   analogous to the summary line from long quest messages */\n                if (index(lastline, '['))\n                    mungspaces(lastline); /* to remove leading spaces */\n                else /* construct one if necessary */\n                    Sprintf(lastline, \"[%s, by Terry Pratchett]\", tribtitle);\n                putmsghistory(lastline, FALSE);\n                grasped = TRUE;\n            }\n            destroy_nhwindow(tribwin);\n        }\n        if (!grasped)\n            /* multi-line window, problem */\n            pline(\"It seems to be %s of \\\"%s\\\"!\", badtranslation, tribtitle);\n    }\n    return grasped;\n}\n\nboolean\nDeath_quote(buf, bufsz)\nchar *buf;\nint bufsz;\n{\n    unsigned death_oid = 1; /* chance of oid #1 being a novel is negligible */\n\n    return read_tribute(\"Death\", \"Death Quotes\", 0, buf, bufsz, death_oid);\n}\n\n/* ----------  END TRIBUTE ----------- */\n\n/*files.c*/\n"], "fixing_code": ["/* NetHack 3.6\tfiles.c\t$NHDT-Date: 1576626110 2019/12/17 23:41:50 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.276 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Derek S. Ray, 2015. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#define NEED_VARARGS\n\n#include \"hack.h\"\n#include \"dlb.h\"\n\n#ifdef TTY_GRAPHICS\n#include \"wintty.h\" /* more() */\n#endif\n\n#if (!defined(MAC) && !defined(O_WRONLY) && !defined(AZTEC_C)) \\\n    || defined(USE_FCNTL)\n#include <fcntl.h>\n#endif\n\n#include <errno.h>\n#ifdef _MSC_VER /* MSC 6.0 defines errno quite differently */\n#if (_MSC_VER >= 600)\n#define SKIP_ERRNO\n#endif\n#else\n#ifdef NHSTDC\n#define SKIP_ERRNO\n#endif\n#endif\n#ifndef SKIP_ERRNO\n#ifdef _DCC\nconst\n#endif\n    extern int errno;\n#endif\n\n#ifdef ZLIB_COMP /* RLC 09 Mar 1999: Support internal ZLIB */\n#include \"zlib.h\"\n#ifndef COMPRESS_EXTENSION\n#define COMPRESS_EXTENSION \".gz\"\n#endif\n#endif\n\n#if defined(UNIX) && defined(QT_GRAPHICS)\n#include <sys/types.h>\n#include <dirent.h>\n#include <stdlib.h>\n#endif\n\n#if defined(UNIX) || defined(VMS) || !defined(NO_SIGNAL)\n#include <signal.h>\n#endif\n\n#if defined(MSDOS) || defined(OS2) || defined(TOS) || defined(WIN32)\n#ifndef __DJGPP__\n#include <sys\\stat.h>\n#else\n#include <sys/stat.h>\n#endif\n#endif\n#ifndef O_BINARY /* used for micros, no-op for others */\n#define O_BINARY 0\n#endif\n\n#ifdef PREFIXES_IN_USE\n#define FQN_NUMBUF 4\nstatic char fqn_filename_buffer[FQN_NUMBUF][FQN_MAX_FILENAME];\n#endif\n\n#if !defined(MFLOPPY) && !defined(VMS) && !defined(WIN32)\nchar bones[] = \"bonesnn.xxx\";\nchar lock[PL_NSIZ + 14] = \"1lock\"; /* long enough for uid+name+.99 */\n#else\n#if defined(MFLOPPY)\nchar bones[FILENAME]; /* pathname of bones files */\nchar lock[FILENAME];  /* pathname of level files */\n#endif\n#if defined(VMS)\nchar bones[] = \"bonesnn.xxx;1\";\nchar lock[PL_NSIZ + 17] = \"1lock\"; /* long enough for _uid+name+.99;1 */\n#endif\n#if defined(WIN32)\nchar bones[] = \"bonesnn.xxx\";\nchar lock[PL_NSIZ + 25]; /* long enough for username+-+name+.99 */\n#endif\n#endif\n\n#if defined(UNIX) || defined(__BEOS__)\n#define SAVESIZE (PL_NSIZ + 13) /* save/99999player.e */\n#else\n#ifdef VMS\n#define SAVESIZE (PL_NSIZ + 22) /* [.save]<uid>player.e;1 */\n#else\n#if defined(WIN32)\n#define SAVESIZE (PL_NSIZ + 40) /* username-player.NetHack-saved-game */\n#else\n#define SAVESIZE FILENAME /* from macconf.h or pcconf.h */\n#endif\n#endif\n#endif\n\n#if !defined(SAVE_EXTENSION)\n#ifdef MICRO\n#define SAVE_EXTENSION \".sav\"\n#endif\n#ifdef WIN32\n#define SAVE_EXTENSION \".NetHack-saved-game\"\n#endif\n#endif\n\nchar SAVEF[SAVESIZE]; /* holds relative path of save file from playground */\n#ifdef MICRO\nchar SAVEP[SAVESIZE]; /* holds path of directory for save file */\n#endif\n\n#ifdef HOLD_LOCKFILE_OPEN\nstruct level_ftrack {\n    int init;\n    int fd;    /* file descriptor for level file     */\n    int oflag; /* open flags                         */\n    boolean nethack_thinks_it_is_open; /* Does NetHack think it's open? */\n} lftrack;\n#if defined(WIN32)\n#include <share.h>\n#endif\n#endif /*HOLD_LOCKFILE_OPEN*/\n\n#define WIZKIT_MAX 128\nstatic char wizkit[WIZKIT_MAX];\nSTATIC_DCL FILE *NDECL(fopen_wizkit_file);\nSTATIC_DCL void FDECL(wizkit_addinv, (struct obj *));\n\n#ifdef AMIGA\nextern char PATH[]; /* see sys/amiga/amidos.c */\nextern char bbs_id[];\nstatic int lockptr;\n#ifdef __SASC_60\n#include <proto/dos.h>\n#endif\n\n#include <libraries/dos.h>\nextern void FDECL(amii_set_text_font, (char *, int));\n#endif\n\n#if defined(WIN32) || defined(MSDOS)\nstatic int lockptr;\n#ifdef MSDOS\n#define Delay(a) msleep(a)\n#endif\n#define Close close\n#ifndef WIN_CE\n#define DeleteFile unlink\n#endif\n#ifdef WIN32\n/*from windmain.c */\nextern char *FDECL(translate_path_variables, (const char *, char *));\n#endif\n#endif\n\n#ifdef MAC\n#undef unlink\n#define unlink macunlink\n#endif\n\n#if (defined(macintosh) && (defined(__SC__) || defined(__MRC__))) \\\n    || defined(__MWERKS__)\n#define PRAGMA_UNUSED\n#endif\n\n#ifdef USER_SOUNDS\nextern char *sounddir;\n#endif\n\nextern int n_dgns; /* from dungeon.c */\n\n#if defined(UNIX) && defined(QT_GRAPHICS)\n#define SELECTSAVED\n#endif\n\n#ifdef SELECTSAVED\nSTATIC_PTR int FDECL(CFDECLSPEC strcmp_wrap, (const void *, const void *));\n#endif\nSTATIC_DCL char *FDECL(set_bonesfile_name, (char *, d_level *));\nSTATIC_DCL char *NDECL(set_bonestemp_name);\n#ifdef COMPRESS\nSTATIC_DCL void FDECL(redirect, (const char *, const char *, FILE *,\n                                 BOOLEAN_P));\n#endif\n#if defined(COMPRESS) || defined(ZLIB_COMP)\nSTATIC_DCL void FDECL(docompress_file, (const char *, BOOLEAN_P));\n#endif\n#if defined(ZLIB_COMP)\nSTATIC_DCL boolean FDECL(make_compressed_name, (const char *, char *));\n#endif\n#ifndef USE_FCNTL\nSTATIC_DCL char *FDECL(make_lockname, (const char *, char *));\n#endif\nSTATIC_DCL void FDECL(set_configfile_name, (const char *));\nSTATIC_DCL FILE *FDECL(fopen_config_file, (const char *, int));\nSTATIC_DCL int FDECL(get_uchars, (char *, uchar *, BOOLEAN_P,\n                                  int, const char *));\nboolean FDECL(proc_wizkit_line, (char *));\nboolean FDECL(parse_config_line, (char *));\nSTATIC_DCL boolean FDECL(parse_conf_file, (FILE *, boolean (*proc)(char *)));\nSTATIC_DCL FILE *NDECL(fopen_sym_file);\nboolean FDECL(proc_symset_line, (char *));\nSTATIC_DCL void FDECL(set_symhandling, (char *, int));\n#ifdef NOCWD_ASSUMPTIONS\nSTATIC_DCL void FDECL(adjust_prefix, (char *, int));\n#endif\nSTATIC_DCL boolean FDECL(config_error_nextline, (const char *));\nSTATIC_DCL void NDECL(free_config_sections);\nSTATIC_DCL char *FDECL(choose_random_part, (char *, CHAR_P));\nSTATIC_DCL boolean FDECL(is_config_section, (const char *));\nSTATIC_DCL boolean FDECL(handle_config_section, (char *));\n#ifdef SELF_RECOVER\nSTATIC_DCL boolean FDECL(copy_bytes, (int, int));\n#endif\n#ifdef HOLD_LOCKFILE_OPEN\nSTATIC_DCL int FDECL(open_levelfile_exclusively, (const char *, int, int));\n#endif\n\n\nstatic char *config_section_chosen = (char *) 0;\nstatic char *config_section_current = (char *) 0;\n\n/*\n * fname_encode()\n *\n *   Args:\n *      legal       zero-terminated list of acceptable file name characters\n *      quotechar   lead-in character used to quote illegal characters as\n *                  hex digits\n *      s           string to encode\n *      callerbuf   buffer to house result\n *      bufsz       size of callerbuf\n *\n *   Notes:\n *      The hex digits 0-9 and A-F are always part of the legal set due to\n *      their use in the encoding scheme, even if not explicitly included in\n *      'legal'.\n *\n *   Sample:\n *      The following call:\n *  (void)fname_encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n *                     '%', \"This is a % test!\", buf, 512);\n *      results in this encoding:\n *          \"This%20is%20a%20%25%20test%21\"\n */\nchar *\nfname_encode(legal, quotechar, s, callerbuf, bufsz)\nconst char *legal;\nchar quotechar;\nchar *s, *callerbuf;\nint bufsz;\n{\n    char *sp, *op;\n    int cnt = 0;\n    static char hexdigits[] = \"0123456789ABCDEF\";\n\n    sp = s;\n    op = callerbuf;\n    *op = '\\0';\n\n    while (*sp) {\n        /* Do we have room for one more character or encoding? */\n        if ((bufsz - cnt) <= 4)\n            return callerbuf;\n\n        if (*sp == quotechar) {\n            (void) sprintf(op, \"%c%02X\", quotechar, *sp);\n            op += 3;\n            cnt += 3;\n        } else if ((index(legal, *sp) != 0) || (index(hexdigits, *sp) != 0)) {\n            *op++ = *sp;\n            *op = '\\0';\n            cnt++;\n        } else {\n            (void) sprintf(op, \"%c%02X\", quotechar, *sp);\n            op += 3;\n            cnt += 3;\n        }\n        sp++;\n    }\n    return callerbuf;\n}\n\n/*\n * fname_decode()\n *\n *   Args:\n *      quotechar   lead-in character used to quote illegal characters as\n *                  hex digits\n *      s           string to decode\n *      callerbuf   buffer to house result\n *      bufsz       size of callerbuf\n */\nchar *\nfname_decode(quotechar, s, callerbuf, bufsz)\nchar quotechar;\nchar *s, *callerbuf;\nint bufsz;\n{\n    char *sp, *op;\n    int k, calc, cnt = 0;\n    static char hexdigits[] = \"0123456789ABCDEF\";\n\n    sp = s;\n    op = callerbuf;\n    *op = '\\0';\n    calc = 0;\n\n    while (*sp) {\n        /* Do we have room for one more character? */\n        if ((bufsz - cnt) <= 2)\n            return callerbuf;\n        if (*sp == quotechar) {\n            sp++;\n            for (k = 0; k < 16; ++k)\n                if (*sp == hexdigits[k])\n                    break;\n            if (k >= 16)\n                return callerbuf; /* impossible, so bail */\n            calc = k << 4;\n            sp++;\n            for (k = 0; k < 16; ++k)\n                if (*sp == hexdigits[k])\n                    break;\n            if (k >= 16)\n                return callerbuf; /* impossible, so bail */\n            calc += k;\n            sp++;\n            *op++ = calc;\n            *op = '\\0';\n        } else {\n            *op++ = *sp++;\n            *op = '\\0';\n        }\n        cnt++;\n    }\n    return callerbuf;\n}\n\n#ifdef PREFIXES_IN_USE\n#define UNUSED_if_not_PREFIXES_IN_USE /*empty*/\n#else\n#define UNUSED_if_not_PREFIXES_IN_USE UNUSED\n#endif\n\n/*ARGSUSED*/\nconst char *\nfqname(basenam, whichprefix, buffnum)\nconst char *basenam;\nint whichprefix UNUSED_if_not_PREFIXES_IN_USE;\nint buffnum UNUSED_if_not_PREFIXES_IN_USE;\n{\n#ifdef PREFIXES_IN_USE\n    char *bufptr;\n#endif\n#ifdef WIN32\n    char tmpbuf[BUFSZ];\n#endif\n\n#ifndef PREFIXES_IN_USE\n    return basenam;\n#else\n    if (!basenam || whichprefix < 0 || whichprefix >= PREFIX_COUNT)\n        return basenam;\n    if (!fqn_prefix[whichprefix])\n        return basenam;\n    if (buffnum < 0 || buffnum >= FQN_NUMBUF) {\n        impossible(\"Invalid fqn_filename_buffer specified: %d\", buffnum);\n        buffnum = 0;\n    }\n    bufptr = fqn_prefix[whichprefix];\n#ifdef WIN32\n    if (strchr(fqn_prefix[whichprefix], '%')\n        || strchr(fqn_prefix[whichprefix], '~'))\n        bufptr = translate_path_variables(fqn_prefix[whichprefix], tmpbuf);\n#endif\n    if (strlen(bufptr) + strlen(basenam) >= FQN_MAX_FILENAME) {\n        impossible(\"fqname too long: %s + %s\", bufptr, basenam);\n        return basenam; /* XXX */\n    }\n    Strcpy(fqn_filename_buffer[buffnum], bufptr);\n    return strcat(fqn_filename_buffer[buffnum], basenam);\n#endif /* !PREFIXES_IN_USE */\n}\n\nint\nvalidate_prefix_locations(reasonbuf)\nchar *reasonbuf; /* reasonbuf must be at least BUFSZ, supplied by caller */\n{\n#if defined(NOCWD_ASSUMPTIONS)\n    FILE *fp;\n    const char *filename;\n    int prefcnt, failcount = 0;\n    char panicbuf1[BUFSZ], panicbuf2[BUFSZ];\n    const char *details;\n#endif\n\n    if (reasonbuf)\n        reasonbuf[0] = '\\0';\n#if defined(NOCWD_ASSUMPTIONS)\n    for (prefcnt = 1; prefcnt < PREFIX_COUNT; prefcnt++) {\n        /* don't test writing to configdir or datadir; they're readonly */\n        if (prefcnt == SYSCONFPREFIX || prefcnt == CONFIGPREFIX\n            || prefcnt == DATAPREFIX)\n            continue;\n        filename = fqname(\"validate\", prefcnt, 3);\n        if ((fp = fopen(filename, \"w\"))) {\n            fclose(fp);\n            (void) unlink(filename);\n        } else {\n            if (reasonbuf) {\n                if (failcount)\n                    Strcat(reasonbuf, \", \");\n                Strcat(reasonbuf, fqn_prefix_names[prefcnt]);\n            }\n            /* the paniclog entry gets the value of errno as well */\n            Sprintf(panicbuf1, \"Invalid %s\", fqn_prefix_names[prefcnt]);\n#if defined(NHSTDC) && !defined(NOTSTDC)\n            if (!(details = strerror(errno)))\n#endif\n                details = \"\";\n            Sprintf(panicbuf2, \"\\\"%s\\\", (%d) %s\", fqn_prefix[prefcnt], errno,\n                    details);\n            paniclog(panicbuf1, panicbuf2);\n            failcount++;\n        }\n    }\n    if (failcount)\n        return 0;\n    else\n#endif\n        return 1;\n}\n\n/* fopen a file, with OS-dependent bells and whistles */\n/* NOTE: a simpler version of this routine also exists in util/dlb_main.c */\nFILE *\nfopen_datafile(filename, mode, prefix)\nconst char *filename, *mode;\nint prefix;\n{\n    FILE *fp;\n\n    filename = fqname(filename, prefix, prefix == TROUBLEPREFIX ? 3 : 0);\n    fp = fopen(filename, mode);\n    return fp;\n}\n\n/* ----------  BEGIN LEVEL FILE HANDLING ----------- */\n\n#ifdef MFLOPPY\n/* Set names for bones[] and lock[] */\nvoid\nset_lock_and_bones()\n{\n    if (!ramdisk) {\n        Strcpy(levels, permbones);\n        Strcpy(bones, permbones);\n    }\n    append_slash(permbones);\n    append_slash(levels);\n#ifdef AMIGA\n    strncat(levels, bbs_id, PATHLEN);\n#endif\n    append_slash(bones);\n    Strcat(bones, \"bonesnn.*\");\n    Strcpy(lock, levels);\n#ifndef AMIGA\n    Strcat(lock, alllevels);\n#endif\n    return;\n}\n#endif /* MFLOPPY */\n\n/* Construct a file name for a level-type file, which is of the form\n * something.level (with any old level stripped off).\n * This assumes there is space on the end of 'file' to append\n * a two digit number.  This is true for 'level'\n * but be careful if you use it for other things -dgk\n */\nvoid\nset_levelfile_name(file, lev)\nchar *file;\nint lev;\n{\n    char *tf;\n\n    tf = rindex(file, '.');\n    if (!tf)\n        tf = eos(file);\n    Sprintf(tf, \".%d\", lev);\n#ifdef VMS\n    Strcat(tf, \";1\");\n#endif\n    return;\n}\n\nint\ncreate_levelfile(lev, errbuf)\nint lev;\nchar errbuf[];\n{\n    int fd;\n    const char *fq_lock;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    set_levelfile_name(lock, lev);\n    fq_lock = fqname(lock, LEVELPREFIX, 0);\n\n#if defined(MICRO) || defined(WIN32)\n/* Use O_TRUNC to force the file to be shortened if it already\n * exists and is currently longer.\n */\n#ifdef HOLD_LOCKFILE_OPEN\n    if (lev == 0)\n        fd = open_levelfile_exclusively(\n            fq_lock, lev, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY);\n    else\n#endif\n        fd = open(fq_lock, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(fq_lock, LEVL_TYPE);\n#else\n    fd = creat(fq_lock, FCMASK);\n#endif\n#endif /* MICRO || WIN32 */\n\n    if (fd >= 0)\n        level_info[lev].flags |= LFILE_EXISTS;\n    else if (errbuf) /* failure explanation */\n        Sprintf(errbuf, \"Cannot create file \\\"%s\\\" for level %d (errno %d).\",\n                lock, lev, errno);\n\n    return fd;\n}\n\nint\nopen_levelfile(lev, errbuf)\nint lev;\nchar errbuf[];\n{\n    int fd;\n    const char *fq_lock;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    set_levelfile_name(lock, lev);\n    fq_lock = fqname(lock, LEVELPREFIX, 0);\n#ifdef MFLOPPY\n    /* If not currently accessible, swap it in. */\n    if (level_info[lev].where != ACTIVE)\n        swapin_file(lev);\n#endif\n#ifdef MAC\n    fd = macopen(fq_lock, O_RDONLY | O_BINARY, LEVL_TYPE);\n#else\n#ifdef HOLD_LOCKFILE_OPEN\n    if (lev == 0)\n        fd = open_levelfile_exclusively(fq_lock, lev, O_RDONLY | O_BINARY);\n    else\n#endif\n        fd = open(fq_lock, O_RDONLY | O_BINARY, 0);\n#endif\n\n    /* for failure, return an explanation that our caller can use;\n       settle for `lock' instead of `fq_lock' because the latter\n       might end up being too big for nethack's BUFSZ */\n    if (fd < 0 && errbuf)\n        Sprintf(errbuf, \"Cannot open file \\\"%s\\\" for level %d (errno %d).\",\n                lock, lev, errno);\n\n    return fd;\n}\n\nvoid\ndelete_levelfile(lev)\nint lev;\n{\n    /*\n     * Level 0 might be created by port specific code that doesn't\n     * call create_levfile(), so always assume that it exists.\n     */\n    if (lev == 0 || (level_info[lev].flags & LFILE_EXISTS)) {\n        set_levelfile_name(lock, lev);\n#ifdef HOLD_LOCKFILE_OPEN\n        if (lev == 0)\n            really_close();\n#endif\n        (void) unlink(fqname(lock, LEVELPREFIX, 0));\n        level_info[lev].flags &= ~LFILE_EXISTS;\n    }\n}\n\nvoid\nclearlocks()\n{\n#ifdef HANGUPHANDLING\n    if (program_state.preserve_locks)\n        return;\n#endif\n#if !defined(PC_LOCKING) && defined(MFLOPPY) && !defined(AMIGA)\n    eraseall(levels, alllevels);\n    if (ramdisk)\n        eraseall(permbones, alllevels);\n#else\n    {\n        register int x;\n\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, SIG_IGN);\n#endif\n#if defined(UNIX) || defined(VMS)\n        sethanguphandler((void FDECL((*), (int) )) SIG_IGN);\n#endif\n        /* can't access maxledgerno() before dungeons are created -dlc */\n        for (x = (n_dgns ? maxledgerno() : 0); x >= 0; x--)\n            delete_levelfile(x); /* not all levels need be present */\n    }\n#endif /* ?PC_LOCKING,&c */\n}\n\n#if defined(SELECTSAVED)\n/* qsort comparison routine */\nSTATIC_OVL int CFDECLSPEC\nstrcmp_wrap(p, q)\nconst void *p;\nconst void *q;\n{\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    return strncasecmp(*(char **) p, *(char **) q, 16);\n#else\n    return strncmpi(*(char **) p, *(char **) q, 16);\n#endif\n}\n#endif\n\n#ifdef HOLD_LOCKFILE_OPEN\nSTATIC_OVL int\nopen_levelfile_exclusively(name, lev, oflag)\nconst char *name;\nint lev, oflag;\n{\n    int reslt, fd;\n\n    if (!lftrack.init) {\n        lftrack.init = 1;\n        lftrack.fd = -1;\n    }\n    if (lftrack.fd >= 0) {\n        /* check for compatible access */\n        if (lftrack.oflag == oflag) {\n            fd = lftrack.fd;\n            reslt = lseek(fd, 0L, SEEK_SET);\n            if (reslt == -1L)\n                panic(\"open_levelfile_exclusively: lseek failed %d\", errno);\n            lftrack.nethack_thinks_it_is_open = TRUE;\n        } else {\n            really_close();\n            fd = sopen(name, oflag, SH_DENYRW, FCMASK);\n            lftrack.fd = fd;\n            lftrack.oflag = oflag;\n            lftrack.nethack_thinks_it_is_open = TRUE;\n        }\n    } else {\n        fd = sopen(name, oflag, SH_DENYRW, FCMASK);\n        lftrack.fd = fd;\n        lftrack.oflag = oflag;\n        if (fd >= 0)\n            lftrack.nethack_thinks_it_is_open = TRUE;\n    }\n    return fd;\n}\n\nvoid\nreally_close()\n{\n    int fd;\n\n    if (lftrack.init) {\n        fd = lftrack.fd;\n\n        lftrack.nethack_thinks_it_is_open = FALSE;\n        lftrack.fd = -1;\n        lftrack.oflag = 0;\n        if (fd != -1)\n            (void) close(fd);\n    }\n    return;\n}\n\nint\nnhclose(fd)\nint fd;\n{\n    if (lftrack.fd == fd) {\n        really_close(); /* close it, but reopen it to hold it */\n        fd = open_levelfile(0, (char *) 0);\n        lftrack.nethack_thinks_it_is_open = FALSE;\n        return 0;\n    }\n    return close(fd);\n}\n#else /* !HOLD_LOCKFILE_OPEN */\n\nint\nnhclose(fd)\nint fd;\n{\n    return close(fd);\n}\n#endif /* ?HOLD_LOCKFILE_OPEN */\n\n/* ----------  END LEVEL FILE HANDLING ----------- */\n\n/* ----------  BEGIN BONES FILE HANDLING ----------- */\n\n/* set up \"file\" to be file name for retrieving bones, and return a\n * bonesid to be read/written in the bones file.\n */\nSTATIC_OVL char *\nset_bonesfile_name(file, lev)\nchar *file;\nd_level *lev;\n{\n    s_level *sptr;\n    char *dptr;\n\n    /*\n     * \"bonD0.nn\"   = bones for level nn in the main dungeon;\n     * \"bonM0.T\"    = bones for Minetown;\n     * \"bonQBar.n\"  = bones for level n in the Barbarian quest;\n     * \"bon3D0.nn\"  = \\\n     * \"bon3M0.T\"   =  > same as above, but for bones pool #3.\n     * \"bon3QBar.n\" = /\n     *\n     * Return value for content validation skips \"bon\" and the\n     * pool number (if present), making it feasible for the admin\n     * to manually move a bones file from one pool to another by\n     * renaming it.\n     */\n    Strcpy(file, \"bon\");\n#ifdef SYSCF\n    if (sysopt.bones_pools > 1) {\n        unsigned poolnum = min((unsigned) sysopt.bones_pools, 10);\n\n        poolnum = (unsigned) ubirthday % poolnum; /* 0..9 */\n        Sprintf(eos(file), \"%u\", poolnum);\n    }\n#endif\n    dptr = eos(file); /* this used to be after the following Sprintf()\n                         and the return value was (dptr - 2) */\n    /* when this naming scheme was adopted, 'filecode' was one letter;\n       3.3.0 turned it into a three letter string (via roles[] in role.c);\n       from that version through 3.6.0, 'dptr' pointed past the filecode\n       and the return value of (dptr - 2)  was wrong for bones produced\n       in the quest branch, skipping the boneid character 'Q' and the\n       first letter of the role's filecode; bones loading still worked\n       because the bonesid used for validation had the same error */\n    Sprintf(dptr, \"%c%s\", dungeons[lev->dnum].boneid,\n            In_quest(lev) ? urole.filecode : \"0\");\n    if ((sptr = Is_special(lev)) != 0)\n        Sprintf(eos(dptr), \".%c\", sptr->boneid);\n    else\n        Sprintf(eos(dptr), \".%d\", lev->dlevel);\n#ifdef VMS\n    Strcat(dptr, \";1\");\n#endif\n    return dptr;\n}\n\n/* set up temporary file name for writing bones, to avoid another game's\n * trying to read from an uncompleted bones file.  we want an uncontentious\n * name, so use one in the namespace reserved for this game's level files.\n * (we are not reading or writing level files while writing bones files, so\n * the same array may be used instead of copying.)\n */\nSTATIC_OVL char *\nset_bonestemp_name()\n{\n    char *tf;\n\n    tf = rindex(lock, '.');\n    if (!tf)\n        tf = eos(lock);\n    Sprintf(tf, \".bn\");\n#ifdef VMS\n    Strcat(tf, \";1\");\n#endif\n    return lock;\n}\n\nint\ncreate_bonesfile(lev, bonesid, errbuf)\nd_level *lev;\nchar **bonesid;\nchar errbuf[];\n{\n    const char *file;\n    int fd;\n\n    if (errbuf)\n        *errbuf = '\\0';\n    *bonesid = set_bonesfile_name(bones, lev);\n    file = set_bonestemp_name();\n    file = fqname(file, BONESPREFIX, 0);\n\n#if defined(MICRO) || defined(WIN32)\n    /* Use O_TRUNC to force the file to be shortened if it already\n     * exists and is currently longer.\n     */\n    fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(file, BONE_TYPE);\n#else\n    fd = creat(file, FCMASK);\n#endif\n#endif\n    if (fd < 0 && errbuf) /* failure explanation */\n        Sprintf(errbuf, \"Cannot create bones \\\"%s\\\", id %s (errno %d).\", lock,\n                *bonesid, errno);\n\n#if defined(VMS) && !defined(SECURE)\n    /*\n       Re-protect bones file with world:read+write+execute+delete access.\n       umask() doesn't seem very reliable; also, vaxcrtl won't let us set\n       delete access without write access, which is what's really wanted.\n       Can't simply create it with the desired protection because creat\n       ANDs the mask with the user's default protection, which usually\n       denies some or all access to world.\n     */\n    (void) chmod(file, FCMASK | 007); /* allow other users full access */\n#endif /* VMS && !SECURE */\n\n    return fd;\n}\n\n#ifdef MFLOPPY\n/* remove partial bonesfile in process of creation */\nvoid\ncancel_bonesfile()\n{\n    const char *tempname;\n\n    tempname = set_bonestemp_name();\n    tempname = fqname(tempname, BONESPREFIX, 0);\n    (void) unlink(tempname);\n}\n#endif /* MFLOPPY */\n\n/* move completed bones file to proper name */\nvoid\ncommit_bonesfile(lev)\nd_level *lev;\n{\n    const char *fq_bones, *tempname;\n    int ret;\n\n    (void) set_bonesfile_name(bones, lev);\n    fq_bones = fqname(bones, BONESPREFIX, 0);\n    tempname = set_bonestemp_name();\n    tempname = fqname(tempname, BONESPREFIX, 1);\n\n#if (defined(SYSV) && !defined(SVR4)) || defined(GENIX)\n    /* old SYSVs don't have rename.  Some SVR3's may, but since they\n     * also have link/unlink, it doesn't matter. :-)\n     */\n    (void) unlink(fq_bones);\n    ret = link(tempname, fq_bones);\n    ret += unlink(tempname);\n#else\n    ret = rename(tempname, fq_bones);\n#endif\n    if (wizard && ret != 0)\n        pline(\"couldn't rename %s to %s.\", tempname, fq_bones);\n}\n\nint\nopen_bonesfile(lev, bonesid)\nd_level *lev;\nchar **bonesid;\n{\n    const char *fq_bones;\n    int fd;\n\n    *bonesid = set_bonesfile_name(bones, lev);\n    fq_bones = fqname(bones, BONESPREFIX, 0);\n    nh_uncompress(fq_bones); /* no effect if nonexistent */\n#ifdef MAC\n    fd = macopen(fq_bones, O_RDONLY | O_BINARY, BONE_TYPE);\n#else\n    fd = open(fq_bones, O_RDONLY | O_BINARY, 0);\n#endif\n    return fd;\n}\n\nint\ndelete_bonesfile(lev)\nd_level *lev;\n{\n    (void) set_bonesfile_name(bones, lev);\n    return !(unlink(fqname(bones, BONESPREFIX, 0)) < 0);\n}\n\n/* assume we're compressing the recently read or created bonesfile, so the\n * file name is already set properly */\nvoid\ncompress_bonesfile()\n{\n    nh_compress(fqname(bones, BONESPREFIX, 0));\n}\n\n/* ----------  END BONES FILE HANDLING ----------- */\n\n/* ----------  BEGIN SAVE FILE HANDLING ----------- */\n\n/* set savefile name in OS-dependent manner from pre-existing plname,\n * avoiding troublesome characters */\nvoid\nset_savefile_name(regularize_it)\nboolean regularize_it;\n{\n#ifdef VMS\n    Sprintf(SAVEF, \"[.save]%d%s\", getuid(), plname);\n    if (regularize_it)\n        regularize(SAVEF + 7);\n    Strcat(SAVEF, \";1\");\n#else\n#if defined(MICRO)\n    Strcpy(SAVEF, SAVEP);\n#ifdef AMIGA\n    strncat(SAVEF, bbs_id, PATHLEN);\n#endif\n    {\n        int i = strlen(SAVEP);\n#ifdef AMIGA\n        /* plname has to share space with SAVEP and \".sav\" */\n        (void) strncat(SAVEF, plname, FILENAME - i - 4);\n#else\n        (void) strncat(SAVEF, plname, 8);\n#endif\n        if (regularize_it)\n            regularize(SAVEF + i);\n    }\n    Strcat(SAVEF, SAVE_EXTENSION);\n#else\n#if defined(WIN32)\n    {\n        static const char okchars[] =\n            \"*ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-.\";\n        const char *legal = okchars;\n        char fnamebuf[BUFSZ], encodedfnamebuf[BUFSZ];\n\n        /* Obtain the name of the logged on user and incorporate\n         * it into the name. */\n        Sprintf(fnamebuf, \"%s\", plname);\n        if (regularize_it)\n            ++legal; /* skip '*' wildcard character */\n        (void) fname_encode(legal, '%', fnamebuf, encodedfnamebuf, BUFSZ);\n        Sprintf(SAVEF, \"%s%s\", encodedfnamebuf, SAVE_EXTENSION);\n    }\n#else  /* not VMS or MICRO or WIN32 */\n    Sprintf(SAVEF, \"save/%d%s\", (int) getuid(), plname);\n    if (regularize_it)\n        regularize(SAVEF + 5); /* avoid . or / in name */\n#endif /* WIN32 */\n#endif /* MICRO */\n#endif /* VMS   */\n}\n\n#ifdef INSURANCE\nvoid\nsave_savefile_name(fd)\nint fd;\n{\n    (void) write(fd, (genericptr_t) SAVEF, sizeof(SAVEF));\n}\n#endif\n\n#ifndef MICRO\n/* change pre-existing savefile name to indicate an error savefile */\nvoid\nset_error_savefile()\n{\n#ifdef VMS\n    {\n        char *semi_colon = rindex(SAVEF, ';');\n\n        if (semi_colon)\n            *semi_colon = '\\0';\n    }\n    Strcat(SAVEF, \".e;1\");\n#else\n#ifdef MAC\n    Strcat(SAVEF, \"-e\");\n#else\n    Strcat(SAVEF, \".e\");\n#endif\n#endif\n}\n#endif\n\n/* create save file, overwriting one if it already exists */\nint\ncreate_savefile()\n{\n    const char *fq_save;\n    int fd;\n\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n#if defined(MICRO) || defined(WIN32)\n    fd = open(fq_save, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);\n#else\n#ifdef MAC\n    fd = maccreat(fq_save, SAVE_TYPE);\n#else\n    fd = creat(fq_save, FCMASK);\n#endif\n#if defined(VMS) && !defined(SECURE)\n    /*\n       Make sure the save file is owned by the current process.  That's\n       the default for non-privileged users, but for priv'd users the\n       file will be owned by the directory's owner instead of the user.\n    */\n#undef getuid\n    (void) chown(fq_save, getuid(), getgid());\n#define getuid() vms_getuid()\n#endif /* VMS && !SECURE */\n#endif /* MICRO */\n\n    return fd;\n}\n\n/* open savefile for reading */\nint\nopen_savefile()\n{\n    const char *fq_save;\n    int fd;\n\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n#ifdef MAC\n    fd = macopen(fq_save, O_RDONLY | O_BINARY, SAVE_TYPE);\n#else\n    fd = open(fq_save, O_RDONLY | O_BINARY, 0);\n#endif\n    return fd;\n}\n\n/* delete savefile */\nint\ndelete_savefile()\n{\n    (void) unlink(fqname(SAVEF, SAVEPREFIX, 0));\n    return 0; /* for restore_saved_game() (ex-xxxmain.c) test */\n}\n\n/* try to open up a save file and prepare to restore it */\nint\nrestore_saved_game()\n{\n    const char *fq_save;\n    int fd;\n\n    reset_restpref();\n    set_savefile_name(TRUE);\n#ifdef MFLOPPY\n    if (!saveDiskPrompt(1))\n        return -1;\n#endif /* MFLOPPY */\n    fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n\n    nh_uncompress(fq_save);\n    if ((fd = open_savefile()) < 0)\n        return fd;\n\n    if (validate(fd, fq_save) != 0) {\n        (void) nhclose(fd), fd = -1;\n        (void) delete_savefile();\n    }\n    return fd;\n}\n\n#if defined(SELECTSAVED)\nchar *\nplname_from_file(filename)\nconst char *filename;\n{\n    int fd;\n    char *result = 0;\n\n    Strcpy(SAVEF, filename);\n#ifdef COMPRESS_EXTENSION\n    SAVEF[strlen(SAVEF) - strlen(COMPRESS_EXTENSION)] = '\\0';\n#endif\n    nh_uncompress(SAVEF);\n    if ((fd = open_savefile()) >= 0) {\n        if (validate(fd, filename) == 0) {\n            char tplname[PL_NSIZ];\n            get_plname_from_file(fd, tplname);\n            result = dupstr(tplname);\n        }\n        (void) nhclose(fd);\n    }\n    nh_compress(SAVEF);\n\n    return result;\n#if 0\n/* --------- obsolete - used to be ifndef STORE_PLNAME_IN_FILE ----*/\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    /* Name not stored in save file, so we have to extract it from\n       the filename, which loses information\n       (eg. \"/\", \"_\", and \".\" characters are lost. */\n    int k;\n    int uid;\n    char name[64]; /* more than PL_NSIZ */\n#ifdef COMPRESS_EXTENSION\n#define EXTSTR COMPRESS_EXTENSION\n#else\n#define EXTSTR \"\"\n#endif\n\n    if ( sscanf( filename, \"%*[^/]/%d%63[^.]\" EXTSTR, &uid, name ) == 2 ) {\n#undef EXTSTR\n        /* \"_\" most likely means \" \", which certainly looks nicer */\n        for (k=0; name[k]; k++)\n            if ( name[k] == '_' )\n                name[k] = ' ';\n        return dupstr(name);\n    } else\n#endif /* UNIX && QT_GRAPHICS */\n    {\n        return 0;\n    }\n/* --------- end of obsolete code ----*/\n#endif /* 0 - WAS STORE_PLNAME_IN_FILE*/\n}\n#endif /* defined(SELECTSAVED) */\n\nchar **\nget_saved_games()\n{\n#if defined(SELECTSAVED)\n    int n, j = 0;\n    char **result = 0;\n#ifdef WIN32\n    {\n        char *foundfile;\n        const char *fq_save;\n        const char *fq_new_save;\n        const char *fq_old_save;\n        char **files = 0;\n        int i;\n\n        Strcpy(plname, \"*\");\n        set_savefile_name(FALSE);\n#if defined(ZLIB_COMP)\n        Strcat(SAVEF, COMPRESS_EXTENSION);\n#endif\n        fq_save = fqname(SAVEF, SAVEPREFIX, 0);\n\n        n = 0;\n        foundfile = foundfile_buffer();\n        if (findfirst((char *) fq_save)) {\n            do {\n                ++n;\n            } while (findnext());\n        }\n\n        if (n > 0) {\n            files = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) files, 0, (n + 1) * sizeof(char *));\n            if (findfirst((char *) fq_save)) {\n                i = 0;\n                do {\n                    files[i++] = strdup(foundfile);\n                } while (findnext());\n            }\n        }\n\n        if (n > 0) {\n            result = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) result, 0, (n + 1) * sizeof(char *));\n            for(i = 0; i < n; i++) {\n                char *r;\n                r = plname_from_file(files[i]);\n\n                if (r) {\n\n                    /* rename file if it is not named as expected */\n                    Strcpy(plname, r);\n                    set_savefile_name(FALSE);\n                    fq_new_save = fqname(SAVEF, SAVEPREFIX, 0);\n                    fq_old_save = fqname(files[i], SAVEPREFIX, 1);\n\n                    if(strcmp(fq_old_save, fq_new_save) != 0 &&\n                        !file_exists(fq_new_save))\n                        rename(fq_old_save, fq_new_save);\n\n                    result[j++] = r;\n                }\n            }\n        }\n\n        free_saved_games(files);\n\n    }\n#endif\n#if defined(UNIX) && defined(QT_GRAPHICS)\n    /* posixly correct version */\n    int myuid = getuid();\n    DIR *dir;\n\n    if ((dir = opendir(fqname(\"save\", SAVEPREFIX, 0)))) {\n        for (n = 0; readdir(dir); n++)\n            ;\n        closedir(dir);\n        if (n > 0) {\n            int i;\n\n            if (!(dir = opendir(fqname(\"save\", SAVEPREFIX, 0))))\n                return 0;\n            result = (char **) alloc((n + 1) * sizeof(char *)); /* at most */\n            (void) memset((genericptr_t) result, 0, (n + 1) * sizeof(char *));\n            for (i = 0, j = 0; i < n; i++) {\n                int uid;\n                char name[64]; /* more than PL_NSIZ */\n                struct dirent *entry = readdir(dir);\n\n                if (!entry)\n                    break;\n                if (sscanf(entry->d_name, \"%d%63s\", &uid, name) == 2) {\n                    if (uid == myuid) {\n                        char filename[BUFSZ];\n                        char *r;\n\n                        Sprintf(filename, \"save/%d%s\", uid, name);\n                        r = plname_from_file(filename);\n                        if (r)\n                            result[j++] = r;\n                    }\n                }\n            }\n            closedir(dir);\n        }\n    }\n#endif\n#ifdef VMS\n    Strcpy(plname, \"*\");\n    set_savefile_name(FALSE);\n    j = vms_get_saved_games(SAVEF, &result);\n#endif /* VMS */\n\n    if (j > 0) {\n        if (j > 1)\n            qsort(result, j, sizeof (char *), strcmp_wrap);\n        result[j] = 0;\n        return result;\n    } else if (result) { /* could happen if save files are obsolete */\n        free_saved_games(result);\n    }\n#endif /* SELECTSAVED */\n    return 0;\n}\n\nvoid\nfree_saved_games(saved)\nchar **saved;\n{\n    if (saved) {\n        int i = 0;\n\n        while (saved[i])\n            free((genericptr_t) saved[i++]);\n        free((genericptr_t) saved);\n    }\n}\n\n/* ----------  END SAVE FILE HANDLING ----------- */\n\n/* ----------  BEGIN FILE COMPRESSION HANDLING ----------- */\n\n#ifdef COMPRESS\n\nSTATIC_OVL void\nredirect(filename, mode, stream, uncomp)\nconst char *filename, *mode;\nFILE *stream;\nboolean uncomp;\n{\n    if (freopen(filename, mode, stream) == (FILE *) 0) {\n        (void) fprintf(stderr, \"freopen of %s for %scompress failed\\n\",\n                       filename, uncomp ? \"un\" : \"\");\n        nh_terminate(EXIT_FAILURE);\n    }\n}\n\n/*\n * using system() is simpler, but opens up security holes and causes\n * problems on at least Interactive UNIX 3.0.1 (SVR3.2), where any\n * setuid is renounced by /bin/sh, so the files cannot be accessed.\n *\n * cf. child() in unixunix.c.\n */\nSTATIC_OVL void\ndocompress_file(filename, uncomp)\nconst char *filename;\nboolean uncomp;\n{\n    char cfn[80];\n    FILE *cf;\n    const char *args[10];\n#ifdef COMPRESS_OPTIONS\n    char opts[80];\n#endif\n    int i = 0;\n    int f;\n#ifdef TTY_GRAPHICS\n    boolean istty = WINDOWPORT(\"tty\");\n#endif\n\n    Strcpy(cfn, filename);\n#ifdef COMPRESS_EXTENSION\n    Strcat(cfn, COMPRESS_EXTENSION);\n#endif\n    /* when compressing, we know the file exists */\n    if (uncomp) {\n        if ((cf = fopen(cfn, RDBMODE)) == (FILE *) 0)\n            return;\n        (void) fclose(cf);\n    }\n\n    args[0] = COMPRESS;\n    if (uncomp)\n        args[++i] = \"-d\"; /* uncompress */\n#ifdef COMPRESS_OPTIONS\n    {\n        /* we can't guarantee there's only one additional option, sigh */\n        char *opt;\n        boolean inword = FALSE;\n\n        Strcpy(opts, COMPRESS_OPTIONS);\n        opt = opts;\n        while (*opt) {\n            if ((*opt == ' ') || (*opt == '\\t')) {\n                if (inword) {\n                    *opt = '\\0';\n                    inword = FALSE;\n                }\n            } else if (!inword) {\n                args[++i] = opt;\n                inword = TRUE;\n            }\n            opt++;\n        }\n    }\n#endif\n    args[++i] = (char *) 0;\n\n#ifdef TTY_GRAPHICS\n    /* If we don't do this and we are right after a y/n question *and*\n     * there is an error message from the compression, the 'y' or 'n' can\n     * end up being displayed after the error message.\n     */\n    if (istty)\n        mark_synch();\n#endif\n    f = fork();\n    if (f == 0) { /* child */\n#ifdef TTY_GRAPHICS\n        /* any error messages from the compression must come out after\n         * the first line, because the more() to let the user read\n         * them will have to clear the first line.  This should be\n         * invisible if there are no error messages.\n         */\n        if (istty)\n            raw_print(\"\");\n#endif\n        /* run compressor without privileges, in case other programs\n         * have surprises along the line of gzip once taking filenames\n         * in GZIP.\n         */\n        /* assume all compressors will compress stdin to stdout\n         * without explicit filenames.  this is true of at least\n         * compress and gzip, those mentioned in config.h.\n         */\n        if (uncomp) {\n            redirect(cfn, RDBMODE, stdin, uncomp);\n            redirect(filename, WRBMODE, stdout, uncomp);\n        } else {\n            redirect(filename, RDBMODE, stdin, uncomp);\n            redirect(cfn, WRBMODE, stdout, uncomp);\n        }\n        (void) setgid(getgid());\n        (void) setuid(getuid());\n        (void) execv(args[0], (char *const *) args);\n        perror((char *) 0);\n        (void) fprintf(stderr, \"Exec to %scompress %s failed.\\n\",\n                       uncomp ? \"un\" : \"\", filename);\n        nh_terminate(EXIT_FAILURE);\n    } else if (f == -1) {\n        perror((char *) 0);\n        pline(\"Fork to %scompress %s failed.\", uncomp ? \"un\" : \"\", filename);\n        return;\n    }\n#ifndef NO_SIGNAL\n    (void) signal(SIGINT, SIG_IGN);\n    (void) signal(SIGQUIT, SIG_IGN);\n    (void) wait((int *) &i);\n    (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n    if (wizard)\n        (void) signal(SIGQUIT, SIG_DFL);\n#else\n    /* I don't think we can really cope with external compression\n     * without signals, so we'll declare that compress failed and\n     * go on.  (We could do a better job by forcing off external\n     * compression if there are no signals, but we want this for\n     * testing with FailSafeC\n     */\n    i = 1;\n#endif\n    if (i == 0) {\n        /* (un)compress succeeded: remove file left behind */\n        if (uncomp)\n            (void) unlink(cfn);\n        else\n            (void) unlink(filename);\n    } else {\n        /* (un)compress failed; remove the new, bad file */\n        if (uncomp) {\n            raw_printf(\"Unable to uncompress %s\", filename);\n            (void) unlink(filename);\n        } else {\n            /* no message needed for compress case; life will go on */\n            (void) unlink(cfn);\n        }\n#ifdef TTY_GRAPHICS\n        /* Give them a chance to read any error messages from the\n         * compression--these would go to stdout or stderr and would get\n         * overwritten only in tty mode.  It's still ugly, since the\n         * messages are being written on top of the screen, but at least\n         * the user can read them.\n         */\n        if (istty && iflags.window_inited) {\n            clear_nhwindow(WIN_MESSAGE);\n            more();\n            /* No way to know if this is feasible */\n            /* doredraw(); */\n        }\n#endif\n    }\n}\n#endif /* COMPRESS */\n\n#if defined(COMPRESS) || defined(ZLIB_COMP)\n#define UNUSED_if_not_COMPRESS /*empty*/\n#else\n#define UNUSED_if_not_COMPRESS UNUSED\n#endif\n\n/* compress file */\nvoid\nnh_compress(filename)\nconst char *filename UNUSED_if_not_COMPRESS;\n{\n#if !defined(COMPRESS) && !defined(ZLIB_COMP)\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n#else\n    docompress_file(filename, FALSE);\n#endif\n}\n\n/* uncompress file if it exists */\nvoid\nnh_uncompress(filename)\nconst char *filename UNUSED_if_not_COMPRESS;\n{\n#if !defined(COMPRESS) && !defined(ZLIB_COMP)\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n#else\n    docompress_file(filename, TRUE);\n#endif\n}\n\n#ifdef ZLIB_COMP /* RLC 09 Mar 1999: Support internal ZLIB */\nSTATIC_OVL boolean\nmake_compressed_name(filename, cfn)\nconst char *filename;\nchar *cfn;\n{\n#ifndef SHORT_FILENAMES\n    /* Assume free-form filename with no 8.3 restrictions */\n    strcpy(cfn, filename);\n    strcat(cfn, COMPRESS_EXTENSION);\n    return TRUE;\n#else\n#ifdef SAVE_EXTENSION\n    char *bp = (char *) 0;\n\n    strcpy(cfn, filename);\n    if ((bp = strstri(cfn, SAVE_EXTENSION))) {\n        strsubst(bp, SAVE_EXTENSION, \".saz\");\n        return TRUE;\n    } else {\n        /* find last occurrence of bon */\n        bp = eos(cfn);\n        while (bp-- > cfn) {\n            if (strstri(bp, \"bon\")) {\n                strsubst(bp, \"bon\", \"boz\");\n                return TRUE;\n            }\n        }\n    }\n#endif /* SAVE_EXTENSION */\n    return FALSE;\n#endif /* SHORT_FILENAMES */\n}\n\nSTATIC_OVL void\ndocompress_file(filename, uncomp)\nconst char *filename;\nboolean uncomp;\n{\n    gzFile compressedfile;\n    FILE *uncompressedfile;\n    char cfn[256];\n    char buf[1024];\n    unsigned len, len2;\n\n    if (!make_compressed_name(filename, cfn))\n        return;\n\n    if (!uncomp) {\n        /* Open the input and output files */\n        /* Note that gzopen takes \"wb\" as its mode, even on systems where\n           fopen takes \"r\" and \"w\" */\n\n        uncompressedfile = fopen(filename, RDBMODE);\n        if (!uncompressedfile) {\n            pline(\"Error in zlib docompress_file %s\", filename);\n            return;\n        }\n        compressedfile = gzopen(cfn, \"wb\");\n        if (compressedfile == NULL) {\n            if (errno == 0) {\n                pline(\"zlib failed to allocate memory\");\n            } else {\n                panic(\"Error in docompress_file %d\", errno);\n            }\n            fclose(uncompressedfile);\n            return;\n        }\n\n        /* Copy from the uncompressed to the compressed file */\n\n        while (1) {\n            len = fread(buf, 1, sizeof(buf), uncompressedfile);\n            if (ferror(uncompressedfile)) {\n                pline(\"Failure reading uncompressed file\");\n                pline(\"Can't compress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(cfn);\n                return;\n            }\n            if (len == 0)\n                break; /* End of file */\n\n            len2 = gzwrite(compressedfile, buf, len);\n            if (len2 == 0) {\n                pline(\"Failure writing compressed file\");\n                pline(\"Can't compress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(cfn);\n                return;\n            }\n        }\n\n        fclose(uncompressedfile);\n        gzclose(compressedfile);\n\n        /* Delete the file left behind */\n\n        (void) unlink(filename);\n\n    } else { /* uncomp */\n\n        /* Open the input and output files */\n        /* Note that gzopen takes \"rb\" as its mode, even on systems where\n           fopen takes \"r\" and \"w\" */\n\n        compressedfile = gzopen(cfn, \"rb\");\n        if (compressedfile == NULL) {\n            if (errno == 0) {\n                pline(\"zlib failed to allocate memory\");\n            } else if (errno != ENOENT) {\n                panic(\"Error in zlib docompress_file %s, %d\", filename,\n                      errno);\n            }\n            return;\n        }\n        uncompressedfile = fopen(filename, WRBMODE);\n        if (!uncompressedfile) {\n            pline(\"Error in zlib docompress file uncompress %s\", filename);\n            gzclose(compressedfile);\n            return;\n        }\n\n        /* Copy from the compressed to the uncompressed file */\n\n        while (1) {\n            len = gzread(compressedfile, buf, sizeof(buf));\n            if (len == (unsigned) -1) {\n                pline(\"Failure reading compressed file\");\n                pline(\"Can't uncompress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(filename);\n                return;\n            }\n            if (len == 0)\n                break; /* End of file */\n\n            fwrite(buf, 1, len, uncompressedfile);\n            if (ferror(uncompressedfile)) {\n                pline(\"Failure writing uncompressed file\");\n                pline(\"Can't uncompress %s.\", filename);\n                fclose(uncompressedfile);\n                gzclose(compressedfile);\n                (void) unlink(filename);\n                return;\n            }\n        }\n\n        fclose(uncompressedfile);\n        gzclose(compressedfile);\n\n        /* Delete the file left behind */\n        (void) unlink(cfn);\n    }\n}\n#endif /* RLC 09 Mar 1999: End ZLIB patch */\n\n/* ----------  END FILE COMPRESSION HANDLING ----------- */\n\n/* ----------  BEGIN FILE LOCKING HANDLING ----------- */\n\nstatic int nesting = 0;\n\n#if defined(NO_FILE_LINKS) || defined(USE_FCNTL) /* implies UNIX */\nstatic int lockfd = -1; /* for lock_file() to pass to unlock_file() */\n#endif\n#ifdef USE_FCNTL\nstruct flock sflock; /* for unlocking, same as above */\n#endif\n\n#define HUP if (!program_state.done_hup)\n\n#ifndef USE_FCNTL\nSTATIC_OVL char *\nmake_lockname(filename, lockname)\nconst char *filename;\nchar *lockname;\n{\n#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(WIN32) \\\n    || defined(MSDOS)\n#ifdef NO_FILE_LINKS\n    Strcpy(lockname, LOCKDIR);\n    Strcat(lockname, \"/\");\n    Strcat(lockname, filename);\n#else\n    Strcpy(lockname, filename);\n#endif\n#ifdef VMS\n    {\n        char *semi_colon = rindex(lockname, ';');\n        if (semi_colon)\n            *semi_colon = '\\0';\n    }\n    Strcat(lockname, \".lock;1\");\n#else\n    Strcat(lockname, \"_lock\");\n#endif\n    return lockname;\n#else /* !(UNIX || VMS || AMIGA || WIN32 || MSDOS) */\n#ifdef PRAGMA_UNUSED\n#pragma unused(filename)\n#endif\n    lockname[0] = '\\0';\n    return (char *) 0;\n#endif\n}\n#endif /* !USE_FCNTL */\n\n/* lock a file */\nboolean\nlock_file(filename, whichprefix, retryct)\nconst char *filename;\nint whichprefix;\nint retryct;\n{\n#if defined(PRAGMA_UNUSED) && !(defined(UNIX) || defined(VMS)) \\\n    && !(defined(AMIGA) || defined(WIN32) || defined(MSDOS))\n#pragma unused(retryct)\n#endif\n#ifndef USE_FCNTL\n    char locknambuf[BUFSZ];\n    const char *lockname;\n#endif\n\n    nesting++;\n    if (nesting > 1) {\n        impossible(\"TRIED TO NEST LOCKS\");\n        return TRUE;\n    }\n\n#ifndef USE_FCNTL\n    lockname = make_lockname(filename, locknambuf);\n#ifndef NO_FILE_LINKS /* LOCKDIR should be subsumed by LOCKPREFIX */\n    lockname = fqname(lockname, LOCKPREFIX, 2);\n#endif\n#endif\n    filename = fqname(filename, whichprefix, 0);\n#ifdef USE_FCNTL\n    lockfd = open(filename, O_RDWR);\n    if (lockfd == -1) {\n        HUP raw_printf(\"Cannot open file %s.  Is NetHack installed correctly?\",\n                       filename);\n        nesting--;\n        return FALSE;\n    }\n    sflock.l_type = F_WRLCK;\n    sflock.l_whence = SEEK_SET;\n    sflock.l_start = 0;\n    sflock.l_len = 0;\n#endif\n\n#if defined(UNIX) || defined(VMS)\n#ifdef USE_FCNTL\n    while (fcntl(lockfd, F_SETLK, &sflock) == -1) {\n#else\n#ifdef NO_FILE_LINKS\n    while ((lockfd = open(lockname, O_RDWR | O_CREAT | O_EXCL, 0666)) == -1) {\n#else\n    while (link(filename, lockname) == -1) {\n#endif\n#endif\n\n#ifdef USE_FCNTL\n        if (retryct--) {\n            HUP raw_printf(\n               \"Waiting for release of fcntl lock on %s.  (%d retries left.)\",\n                           filename, retryct);\n            sleep(1);\n        } else {\n            HUP(void) raw_print(\"I give up.  Sorry.\");\n            HUP raw_printf(\"Some other process has an unnatural grip on %s.\",\n                           filename);\n            nesting--;\n            return FALSE;\n        }\n#else\n        int errnosv = errno;\n\n        switch (errnosv) { /* George Barbanis */\n        case EEXIST:\n            if (retryct--) {\n                HUP raw_printf(\n                    \"Waiting for access to %s.  (%d retries left).\", filename,\n                    retryct);\n#if defined(SYSV) || defined(ULTRIX) || defined(VMS)\n                (void)\n#endif\n                    sleep(1);\n            } else {\n                HUP(void) raw_print(\"I give up.  Sorry.\");\n                HUP raw_printf(\"Perhaps there is an old %s around?\",\n                               lockname);\n                nesting--;\n                return FALSE;\n            }\n\n            break;\n        case ENOENT:\n            HUP raw_printf(\"Can't find file %s to lock!\", filename);\n            nesting--;\n            return FALSE;\n        case EACCES:\n            HUP raw_printf(\"No write permission to lock %s!\", filename);\n            nesting--;\n            return FALSE;\n#ifdef VMS /* c__translate(vmsfiles.c) */\n        case EPERM:\n            /* could be misleading, but usually right */\n            HUP raw_printf(\"Can't lock %s due to directory protection.\",\n                           filename);\n            nesting--;\n            return FALSE;\n#endif\n        case EROFS:\n            /* take a wild guess at the underlying cause */\n            HUP perror(lockname);\n            HUP raw_printf(\"Cannot lock %s.\", filename);\n            HUP raw_printf(\n  \"(Perhaps you are running NetHack from inside the distribution package?).\");\n            nesting--;\n            return FALSE;\n        default:\n            HUP perror(lockname);\n            HUP raw_printf(\"Cannot lock %s for unknown reason (%d).\",\n                           filename, errnosv);\n            nesting--;\n            return FALSE;\n        }\n#endif /* USE_FCNTL */\n    }\n#endif /* UNIX || VMS */\n\n#if (defined(AMIGA) || defined(WIN32) || defined(MSDOS)) \\\n    && !defined(USE_FCNTL)\n#ifdef AMIGA\n#define OPENFAILURE(fd) (!fd)\n    lockptr = 0;\n#else\n#define OPENFAILURE(fd) (fd < 0)\n    lockptr = -1;\n#endif\n    while (--retryct && OPENFAILURE(lockptr)) {\n#if defined(WIN32) && !defined(WIN_CE)\n        lockptr = sopen(lockname, O_RDWR | O_CREAT, SH_DENYRW, S_IWRITE);\n#else\n        (void) DeleteFile(lockname); /* in case dead process was here first */\n#ifdef AMIGA\n        lockptr = Open(lockname, MODE_NEWFILE);\n#else\n        lockptr = open(lockname, O_RDWR | O_CREAT | O_EXCL, S_IWRITE);\n#endif\n#endif\n        if (OPENFAILURE(lockptr)) {\n            raw_printf(\"Waiting for access to %s.  (%d retries left).\",\n                       filename, retryct);\n            Delay(50);\n        }\n    }\n    if (!retryct) {\n        raw_printf(\"I give up.  Sorry.\");\n        nesting--;\n        return FALSE;\n    }\n#endif /* AMIGA || WIN32 || MSDOS */\n    return TRUE;\n}\n\n#ifdef VMS /* for unlock_file, use the unlink() routine in vmsunix.c */\n#ifdef unlink\n#undef unlink\n#endif\n#define unlink(foo) vms_unlink(foo)\n#endif\n\n/* unlock file, which must be currently locked by lock_file */\nvoid\nunlock_file(filename)\nconst char *filename;\n{\n#ifndef USE_FCNTL\n    char locknambuf[BUFSZ];\n    const char *lockname;\n#endif\n\n    if (nesting == 1) {\n#ifdef USE_FCNTL\n        sflock.l_type = F_UNLCK;\n        if (lockfd >= 0) {\n            if (fcntl(lockfd, F_SETLK, &sflock) == -1)\n                HUP raw_printf(\"Can't remove fcntl lock on %s.\", filename);\n            (void) close(lockfd), lockfd = -1;\n        }\n#else\n        lockname = make_lockname(filename, locknambuf);\n#ifndef NO_FILE_LINKS /* LOCKDIR should be subsumed by LOCKPREFIX */\n        lockname = fqname(lockname, LOCKPREFIX, 2);\n#endif\n\n#if defined(UNIX) || defined(VMS)\n        if (unlink(lockname) < 0)\n            HUP raw_printf(\"Can't unlink %s.\", lockname);\n#ifdef NO_FILE_LINKS\n        (void) nhclose(lockfd), lockfd = -1;\n#endif\n\n#endif /* UNIX || VMS */\n\n#if defined(AMIGA) || defined(WIN32) || defined(MSDOS)\n        if (lockptr)\n            Close(lockptr);\n        DeleteFile(lockname);\n        lockptr = 0;\n#endif /* AMIGA || WIN32 || MSDOS */\n#endif /* USE_FCNTL */\n    }\n\n    nesting--;\n}\n\n/* ----------  END FILE LOCKING HANDLING ----------- */\n\n/* ----------  BEGIN CONFIG FILE HANDLING ----------- */\n\nconst char *default_configfile =\n#ifdef UNIX\n    \".nethackrc\";\n#else\n#if defined(MAC) || defined(__BEOS__)\n    \"NetHack Defaults\";\n#else\n#if defined(MSDOS) || defined(WIN32)\n    CONFIG_FILE;\n#else\n    \"NetHack.cnf\";\n#endif\n#endif\n#endif\n\n/* used for messaging */\nchar configfile[BUFSZ];\n\n#ifdef MSDOS\n/* conflict with speed-dial under windows\n * for XXX.cnf file so support of NetHack.cnf\n * is for backward compatibility only.\n * Preferred name (and first tried) is now defaults.nh but\n * the game will try the old name if there\n * is no defaults.nh.\n */\nconst char *backward_compat_configfile = \"nethack.cnf\";\n#endif\n\n/* remember the name of the file we're accessing;\n   if may be used in option reject messages */\nSTATIC_OVL void\nset_configfile_name(fname)\nconst char *fname;\n{\n    (void) strncpy(configfile, fname, sizeof configfile - 1);\n    configfile[sizeof configfile - 1] = '\\0';\n}\n\n#ifndef MFLOPPY\n#define fopenp fopen\n#endif\n\nSTATIC_OVL FILE *\nfopen_config_file(filename, src)\nconst char *filename;\nint src;\n{\n    FILE *fp;\n#if defined(UNIX) || defined(VMS)\n    char tmp_config[BUFSZ];\n    char *envp;\n#endif\n\n    if (src == SET_IN_SYS) {\n        /* SYSCF_FILE; if we can't open it, caller will bail */\n        if (filename && *filename) {\n            set_configfile_name(fqname(filename, SYSCONFPREFIX, 0));\n            fp = fopenp(configfile, \"r\");\n        } else\n            fp = (FILE *) 0;\n        return  fp;\n    }\n    /* If src != SET_IN_SYS, \"filename\" is an environment variable, so it\n     * should hang around. If set, it is expected to be a full path name\n     * (if relevant)\n     */\n    if (filename && *filename) {\n        set_configfile_name(filename);\n#ifdef UNIX\n        if (access(configfile, 4) == -1) { /* 4 is R_OK on newer systems */\n            /* nasty sneaky attempt to read file through\n             * NetHack's setuid permissions -- this is the only\n             * place a file name may be wholly under the player's\n             * control (but SYSCF_FILE is not under the player's\n             * control so it's OK).\n             */\n            raw_printf(\"Access to %s denied (%d).\", configfile, errno);\n            wait_synch();\n            /* fall through to standard names */\n        } else\n#endif\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n            return  fp;\n#if defined(UNIX) || defined(VMS)\n        } else {\n            /* access() above probably caught most problems for UNIX */\n            raw_printf(\"Couldn't open requested config file %s (%d).\",\n                       configfile, errno);\n            wait_synch();\n#endif\n        }\n    }\n    /* fall through to standard names */\n\n#if defined(MICRO) || defined(MAC) || defined(__BEOS__) || defined(WIN32)\n    set_configfile_name(fqname(default_configfile, CONFIGPREFIX, 0));\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n        return fp;\n    } else if (strcmp(default_configfile, configfile)) {\n        set_configfile_name(default_configfile);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#ifdef MSDOS\n    set_configfile_name(fqname(backward_compat_configfile, CONFIGPREFIX, 0));\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0) {\n        return fp;\n    } else if (strcmp(backward_compat_configfile, configfile)) {\n        set_configfile_name(backward_compat_configfile);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#endif\n#else\n/* constructed full path names don't need fqname() */\n#ifdef VMS\n    /* no punctuation, so might be a logical name */\n    set_configfile_name(\"nethackini\");\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n    set_configfile_name(\"sys$login:nethack.ini\");\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n\n    envp = nh_getenv(\"HOME\");\n    if (!envp || !*envp)\n        Strcpy(tmp_config, \"NetHack.cnf\");\n    else\n        Sprintf(tmp_config, \"%s%s%s\", envp,\n                !index(\":]>/\", envp[strlen(envp) - 1]) ? \"/\" : \"\",\n                \"NetHack.cnf\");\n    set_configfile_name(tmp_config);\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n#else /* should be only UNIX left */\n    envp = nh_getenv(\"HOME\");\n    if (!envp)\n        Strcpy(tmp_config, \".nethackrc\");\n    else\n        Sprintf(tmp_config, \"%s/%s\", envp, \".nethackrc\");\n\n    set_configfile_name(tmp_config);\n    if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n        return fp;\n#if defined(__APPLE__) /* UNIX+__APPLE__ => MacOSX */\n    /* try an alternative */\n    if (envp) {\n        /* OSX-style configuration settings */\n        Sprintf(tmp_config, \"%s/%s\", envp,\n                \"Library/Preferences/NetHack Defaults\");\n        set_configfile_name(tmp_config);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n        /* may be easier for user to edit if filename has '.txt' suffix */\n        Sprintf(tmp_config, \"%s/%s\", envp,\n                \"Library/Preferences/NetHack Defaults.txt\");\n        set_configfile_name(tmp_config);\n        if ((fp = fopenp(configfile, \"r\")) != (FILE *) 0)\n            return fp;\n    }\n#endif /*__APPLE__*/\n    if (errno != ENOENT) {\n        const char *details;\n\n        /* e.g., problems when setuid NetHack can't search home\n           directory restricted to user */\n#if defined(NHSTDC) && !defined(NOTSTDC)\n        if ((details = strerror(errno)) == 0)\n#endif\n            details = \"\";\n        raw_printf(\"Couldn't open default config file %s %s(%d).\",\n                   configfile, details, errno);\n        wait_synch();\n    }\n#endif /* !VMS => Unix */\n#endif /* !(MICRO || MAC || __BEOS__ || WIN32) */\n    return (FILE *) 0;\n}\n\n/*\n * Retrieve a list of integers from buf into a uchar array.\n *\n * NOTE: zeros are inserted unless modlist is TRUE, in which case the list\n *  location is unchanged.  Callers must handle zeros if modlist is FALSE.\n */\nSTATIC_OVL int\nget_uchars(bufp, list, modlist, size, name)\nchar *bufp;       /* current pointer */\nuchar *list;      /* return list */\nboolean modlist;  /* TRUE: list is being modified in place */\nint size;         /* return list size */\nconst char *name; /* name of option for error message */\n{\n    unsigned int num = 0;\n    int count = 0;\n    boolean havenum = FALSE;\n\n    while (1) {\n        switch (*bufp) {\n        case ' ':\n        case '\\0':\n        case '\\t':\n        case '\\n':\n            if (havenum) {\n                /* if modifying in place, don't insert zeros */\n                if (num || !modlist)\n                    list[count] = num;\n                count++;\n                num = 0;\n                havenum = FALSE;\n            }\n            if (count == size || !*bufp)\n                return count;\n            bufp++;\n            break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            havenum = TRUE;\n            num = num * 10 + (*bufp - '0');\n            bufp++;\n            break;\n\n        case '\\\\':\n            goto gi_error;\n            break;\n\n        default:\n gi_error:\n            raw_printf(\"Syntax error in %s\", name);\n            wait_synch();\n            return count;\n        }\n    }\n    /*NOTREACHED*/\n}\n\n#ifdef NOCWD_ASSUMPTIONS\nSTATIC_OVL void\nadjust_prefix(bufp, prefixid)\nchar *bufp;\nint prefixid;\n{\n    char *ptr;\n\n    if (!bufp)\n        return;\n#ifdef WIN32\n    if (fqn_prefix_locked[prefixid])\n        return;\n#endif\n    /* Backward compatibility, ignore trailing ;n */\n    if ((ptr = index(bufp, ';')) != 0)\n        *ptr = '\\0';\n    if (strlen(bufp) > 0) {\n        fqn_prefix[prefixid] = (char *) alloc(strlen(bufp) + 2);\n        Strcpy(fqn_prefix[prefixid], bufp);\n        append_slash(fqn_prefix[prefixid]);\n    }\n}\n#endif\n\n/* Choose at random one of the sep separated parts from str. Mangles str. */\nSTATIC_OVL char *\nchoose_random_part(str,sep)\nchar *str;\nchar sep;\n{\n    int nsep = 1;\n    int csep;\n    int len = 0;\n    char *begin = str;\n\n    if (!str)\n        return (char *) 0;\n\n    while (*str) {\n        if (*str == sep)\n            nsep++;\n        str++;\n    }\n    csep = rn2(nsep);\n    str = begin;\n    while ((csep > 0) && *str) {\n        str++;\n        if (*str == sep)\n            csep--;\n    }\n    if (*str) {\n        if (*str == sep)\n            str++;\n        begin = str;\n        while (*str && *str != sep) {\n            str++;\n            len++;\n        }\n        *str = '\\0';\n        if (len)\n            return begin;\n    }\n    return (char *) 0;\n}\n\nSTATIC_OVL void\nfree_config_sections()\n{\n    if (config_section_chosen) {\n        free(config_section_chosen);\n        config_section_chosen = NULL;\n    }\n    if (config_section_current) {\n        free(config_section_current);\n        config_section_current = NULL;\n    }\n}\n\nSTATIC_OVL boolean\nis_config_section(str)\nconst char *str;\n{\n    const char *a = rindex(str, ']');\n\n    return (a && *str == '[' && *(a+1) == '\\0' && (int)(a - str) > 0);\n}\n\nSTATIC_OVL boolean\nhandle_config_section(buf)\nchar *buf;\n{\n    if (is_config_section(buf)) {\n        char *send;\n        if (config_section_current) {\n            free(config_section_current);\n        }\n        config_section_current = dupstr(&buf[1]);\n        send = rindex(config_section_current, ']');\n        *send = '\\0';\n        debugpline1(\"set config section: '%s'\", config_section_current);\n        return TRUE;\n    }\n\n    if (config_section_current) {\n        if (!config_section_chosen)\n            return TRUE;\n        if (strcmp(config_section_current, config_section_chosen))\n            return TRUE;\n    }\n    return FALSE;\n}\n\n#define match_varname(INP, NAM, LEN) match_optname(INP, NAM, LEN, TRUE)\n\n/* find the '=' or ':' */\nchar *\nfind_optparam(buf)\nconst char *buf;\n{\n    char *bufp, *altp;\n\n    bufp = index(buf, '=');\n    altp = index(buf, ':');\n    if (!bufp || (altp && altp < bufp))\n        bufp = altp;\n\n    return bufp;\n}\n\nboolean\nparse_config_line(origbuf)\nchar *origbuf;\n{\n#if defined(MICRO) && !defined(NOCWD_ASSUMPTIONS)\n    static boolean ramdisk_specified = FALSE;\n#endif\n#ifdef SYSCF\n    int n, src = iflags.parse_config_file_src;\n#endif\n    char *bufp, buf[4 * BUFSZ];\n    uchar translate[MAXPCHARS];\n    int len;\n    boolean retval = TRUE;\n\n    while (*origbuf == ' ' || *origbuf == '\\t') /* skip leading whitespace */\n        ++origbuf;                   /* (caller probably already did this) */\n    (void) strncpy(buf, origbuf, sizeof buf - 1);\n    buf[sizeof buf - 1] = '\\0'; /* strncpy not guaranteed to NUL terminate */\n    /* convert any tab to space, condense consecutive spaces into one,\n       remove leading and trailing spaces (exception: if there is nothing\n       but spaces, one of them will be kept even though it leads/trails) */\n    mungspaces(buf);\n\n    /* find the '=' or ':' */\n    bufp = find_optparam(buf);\n    if (!bufp) {\n        config_error_add(\"Not a config statement, missing '='\");\n        return FALSE;\n    }\n    /* skip past '=', then space between it and value, if any */\n    ++bufp;\n    if (*bufp == ' ')\n        ++bufp;\n\n    /* Go through possible variables */\n    /* some of these (at least LEVELS and SAVE) should now set the\n     * appropriate fqn_prefix[] rather than specialized variables\n     */\n    if (match_varname(buf, \"OPTIONS\", 4)) {\n        /* hack: un-mungspaces to allow consecutive spaces in\n           general options until we verify that this is unnecessary;\n           '=' or ':' is guaranteed to be present */\n        bufp = find_optparam(origbuf);\n        ++bufp; /* skip '='; parseoptions() handles spaces */\n\n        if (!parseoptions(bufp, TRUE, TRUE))\n            retval = FALSE;\n    } else if (match_varname(buf, \"AUTOPICKUP_EXCEPTION\", 5)) {\n        add_autopickup_exception(bufp);\n    } else if (match_varname(buf, \"BINDINGS\", 4)) {\n        if (!parsebindings(bufp))\n            retval = FALSE;\n    } else if (match_varname(buf, \"AUTOCOMPLETE\", 5)) {\n        parseautocomplete(bufp, TRUE);\n    } else if (match_varname(buf, \"MSGTYPE\", 7)) {\n        if (!msgtype_parse_add(bufp))\n            retval = FALSE;\n#ifdef NOCWD_ASSUMPTIONS\n    } else if (match_varname(buf, \"HACKDIR\", 4)) {\n        adjust_prefix(bufp, HACKPREFIX);\n    } else if (match_varname(buf, \"LEVELDIR\", 4)\n               || match_varname(buf, \"LEVELS\", 4)) {\n        adjust_prefix(bufp, LEVELPREFIX);\n    } else if (match_varname(buf, \"SAVEDIR\", 4)) {\n        adjust_prefix(bufp, SAVEPREFIX);\n    } else if (match_varname(buf, \"BONESDIR\", 5)) {\n        adjust_prefix(bufp, BONESPREFIX);\n    } else if (match_varname(buf, \"DATADIR\", 4)) {\n        adjust_prefix(bufp, DATAPREFIX);\n    } else if (match_varname(buf, \"SCOREDIR\", 4)) {\n        adjust_prefix(bufp, SCOREPREFIX);\n    } else if (match_varname(buf, \"LOCKDIR\", 4)) {\n        adjust_prefix(bufp, LOCKPREFIX);\n    } else if (match_varname(buf, \"CONFIGDIR\", 4)) {\n        adjust_prefix(bufp, CONFIGPREFIX);\n    } else if (match_varname(buf, \"TROUBLEDIR\", 4)) {\n        adjust_prefix(bufp, TROUBLEPREFIX);\n#else /*NOCWD_ASSUMPTIONS*/\n#ifdef MICRO\n    } else if (match_varname(buf, \"HACKDIR\", 4)) {\n        (void) strncpy(hackdir, bufp, PATHLEN - 1);\n#ifdef MFLOPPY\n    } else if (match_varname(buf, \"RAMDISK\", 3)) {\n/* The following ifdef is NOT in the wrong\n * place.  For now, we accept and silently\n * ignore RAMDISK */\n#ifndef AMIGA\n        if (strlen(bufp) >= PATHLEN)\n            bufp[PATHLEN - 1] = '\\0';\n        Strcpy(levels, bufp);\n        ramdisk = (strcmp(permbones, levels) != 0);\n        ramdisk_specified = TRUE;\n#endif\n#endif\n    } else if (match_varname(buf, \"LEVELS\", 4)) {\n        if (strlen(bufp) >= PATHLEN)\n            bufp[PATHLEN - 1] = '\\0';\n        Strcpy(permbones, bufp);\n        if (!ramdisk_specified || !*levels)\n            Strcpy(levels, bufp);\n        ramdisk = (strcmp(permbones, levels) != 0);\n    } else if (match_varname(buf, \"SAVE\", 4)) {\n#ifdef MFLOPPY\n        extern int saveprompt;\n#endif\n        char *ptr;\n\n        if ((ptr = index(bufp, ';')) != 0) {\n            *ptr = '\\0';\n#ifdef MFLOPPY\n            if (*(ptr + 1) == 'n' || *(ptr + 1) == 'N') {\n                saveprompt = FALSE;\n            }\n#endif\n        }\n#if defined(SYSFLAGS) && defined(MFLOPPY)\n        else\n            saveprompt = sysflags.asksavedisk;\n#endif\n\n        (void) strncpy(SAVEP, bufp, SAVESIZE - 1);\n        append_slash(SAVEP);\n#endif /* MICRO */\n#endif /*NOCWD_ASSUMPTIONS*/\n\n    } else if (match_varname(buf, \"NAME\", 4)) {\n        (void) strncpy(plname, bufp, PL_NSIZ - 1);\n    } else if (match_varname(buf, \"ROLE\", 4)\n               || match_varname(buf, \"CHARACTER\", 4)) {\n        if ((len = str2role(bufp)) >= 0)\n            flags.initrole = len;\n    } else if (match_varname(buf, \"DOGNAME\", 3)) {\n        (void) strncpy(dogname, bufp, PL_PSIZ - 1);\n    } else if (match_varname(buf, \"CATNAME\", 3)) {\n        (void) strncpy(catname, bufp, PL_PSIZ - 1);\n\n#ifdef SYSCF\n    } else if (src == SET_IN_SYS && match_varname(buf, \"WIZARDS\", 7)) {\n        if (sysopt.wizards)\n            free((genericptr_t) sysopt.wizards);\n        sysopt.wizards = dupstr(bufp);\n        if (strlen(sysopt.wizards) && strcmp(sysopt.wizards, \"*\")) {\n            /* pre-format WIZARDS list now; it's displayed during a panic\n               and since that panic might be due to running out of memory,\n               we don't want to risk attempting to allocate any memory then */\n            if (sysopt.fmtd_wizard_list)\n                free((genericptr_t) sysopt.fmtd_wizard_list);\n            sysopt.fmtd_wizard_list = build_english_list(sysopt.wizards);\n        }\n    } else if (src == SET_IN_SYS && match_varname(buf, \"SHELLERS\", 8)) {\n        if (sysopt.shellers)\n            free((genericptr_t) sysopt.shellers);\n        sysopt.shellers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"EXPLORERS\", 7)) {\n        if (sysopt.explorers)\n            free((genericptr_t) sysopt.explorers);\n        sysopt.explorers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"DEBUGFILES\", 5)) {\n        /* if showdebug() has already been called (perhaps we've added\n           some debugpline() calls to option processing) and has found\n           a value for getenv(\"DEBUGFILES\"), don't override that */\n        if (sysopt.env_dbgfl <= 0) {\n            if (sysopt.debugfiles)\n                free((genericptr_t) sysopt.debugfiles);\n            sysopt.debugfiles = dupstr(bufp);\n        }\n    } else if (src == SET_IN_SYS && match_varname(buf, \"DUMPLOGFILE\", 7)) {\n#ifdef DUMPLOG\n        if (sysopt.dumplogfile)\n            free((genericptr_t) sysopt.dumplogfile);\n        sysopt.dumplogfile = dupstr(bufp);\n#endif\n#ifdef WIN32\n    } else if (src == SET_IN_SYS && match_varname(buf, \"portable_device_top\", 8)) {\n        if (sysopt.portable_device_top)\n            free((genericptr_t) sysopt.portable_device_top);\n        sysopt.portable_device_top = dupstr(bufp);\n#endif\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GENERICUSERS\", 12)) {\n        if (sysopt.genericusers)\n            free((genericptr_t) sysopt.genericusers);\n        sysopt.genericusers = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"BONES_POOLS\", 10)) {\n        /* max value of 10 guarantees (N % bones.pools) will be one digit\n           so we don't lose control of the length of bones file names */\n        n = atoi(bufp);\n        sysopt.bones_pools = (n <= 0) ? 0 : min(n, 10);\n        /* note: right now bones_pools==0 is the same as bones_pools==1,\n           but we could change that and make bones_pools==0 become an\n           indicator to suppress bones usage altogether */\n    } else if (src == SET_IN_SYS && match_varname(buf, \"SUPPORT\", 7)) {\n        if (sysopt.support)\n            free((genericptr_t) sysopt.support);\n        sysopt.support = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"RECOVER\", 7)) {\n        if (sysopt.recover)\n            free((genericptr_t) sysopt.recover);\n        sysopt.recover = dupstr(bufp);\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"CHECK_SAVE_UID\", 14)) {\n        n = atoi(bufp);\n        sysopt.check_save_uid = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"CHECK_PLNAME\", 12)) {\n        n = atoi(bufp);\n        sysopt.check_plname = n;\n    } else if (match_varname(buf, \"SEDUCE\", 6)) {\n        n = !!atoi(bufp); /* XXX this could be tighter */\n        /* allow anyone to turn it off, but only sysconf to turn it on*/\n        if (src != SET_IN_SYS && n != 0) {\n            config_error_add(\"Illegal value in SEDUCE\");\n            return FALSE;\n        }\n        sysopt.seduce = n;\n        sysopt_seduce_set(sysopt.seduce);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"MAXPLAYERS\", 10)) {\n        n = atoi(bufp);\n        /* XXX to get more than 25, need to rewrite all lock code */\n        if (n < 0 || n > 25) {\n            config_error_add(\"Illegal value in MAXPLAYERS (maximum is 25).\");\n            return FALSE;\n        }\n        sysopt.maxplayers = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"PERSMAX\", 7)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\"Illegal value in PERSMAX (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.persmax = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"PERS_IS_UID\", 11)) {\n        n = atoi(bufp);\n        if (n != 0 && n != 1) {\n            config_error_add(\"Illegal value in PERS_IS_UID (must be 0 or 1).\");\n            return FALSE;\n        }\n        sysopt.pers_is_uid = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"ENTRYMAX\", 8)) {\n        n = atoi(bufp);\n        if (n < 10) {\n            config_error_add(\"Illegal value in ENTRYMAX (minimum is 10).\");\n            return FALSE;\n        }\n        sysopt.entrymax = n;\n    } else if ((src == SET_IN_SYS) && match_varname(buf, \"POINTSMIN\", 9)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\"Illegal value in POINTSMIN (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.pointsmin = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"MAX_STATUENAME_RANK\", 10)) {\n        n = atoi(bufp);\n        if (n < 1) {\n            config_error_add(\n                      \"Illegal value in MAX_STATUENAME_RANK (minimum is 1).\");\n            return FALSE;\n        }\n        sysopt.tt_oname_maxrank = n;\n\n    /* SYSCF PANICTRACE options */\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"PANICTRACE_LIBC\", 15)) {\n        n = atoi(bufp);\n#if defined(PANICTRACE) && defined(PANICTRACE_LIBC)\n        if (n < 0 || n > 2) {\n            config_error_add(\"Illegal value in PANICTRACE_LIBC (not 0,1,2).\");\n            return FALSE;\n        }\n#endif\n        sysopt.panictrace_libc = n;\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"PANICTRACE_GDB\", 14)) {\n        n = atoi(bufp);\n#if defined(PANICTRACE)\n        if (n < 0 || n > 2) {\n            config_error_add(\"Illegal value in PANICTRACE_GDB (not 0,1,2).\");\n            return FALSE;\n        }\n#endif\n        sysopt.panictrace_gdb = n;\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GDBPATH\", 7)) {\n#if defined(PANICTRACE) && !defined(VMS)\n        if (!file_exists(bufp)) {\n            config_error_add(\"File specified in GDBPATH does not exist.\");\n            return FALSE;\n        }\n#endif\n        if (sysopt.gdbpath)\n            free((genericptr_t) sysopt.gdbpath);\n        sysopt.gdbpath = dupstr(bufp);\n    } else if (src == SET_IN_SYS && match_varname(buf, \"GREPPATH\", 7)) {\n#if defined(PANICTRACE) && !defined(VMS)\n        if (!file_exists(bufp)) {\n            config_error_add(\"File specified in GREPPATH does not exist.\");\n            return FALSE;\n        }\n#endif\n        if (sysopt.greppath)\n            free((genericptr_t) sysopt.greppath);\n        sysopt.greppath = dupstr(bufp);\n    } else if (src == SET_IN_SYS\n               && match_varname(buf, \"ACCESSIBILITY\", 13)) {\n        n = atoi(bufp);\n        if (n < 0 || n > 1) {\n            config_error_add(\"Illegal value in ACCESSIBILITY (not 0,1).\");\n            return FALSE;\n        }\n        sysopt.accessibility = n;\n#endif /* SYSCF */\n\n    } else if (match_varname(buf, \"BOULDER\", 3)) {\n        (void) get_uchars(bufp, &ov_primary_syms[SYM_BOULDER + SYM_OFF_X],\n                          TRUE, 1, \"BOULDER\");\n    } else if (match_varname(buf, \"MENUCOLOR\", 9)) {\n        if (!add_menu_coloring(bufp))\n            retval = FALSE;\n    } else if (match_varname(buf, \"HILITE_STATUS\", 6)) {\n#ifdef STATUS_HILITES\n        if (!parse_status_hl1(bufp, TRUE))\n            retval = FALSE;\n#endif\n    } else if (match_varname(buf, \"WARNINGS\", 5)) {\n        (void) get_uchars(bufp, translate, FALSE, WARNCOUNT,\n                          \"WARNINGS\");\n        assign_warnings(translate);\n    } else if (match_varname(buf, \"ROGUESYMBOLS\", 4)) {\n        if (!parsesymbols(bufp, ROGUESET)) {\n            config_error_add(\"Error in ROGUESYMBOLS definition '%s'\", bufp);\n            retval = FALSE;\n        }\n        switch_symbols(TRUE);\n    } else if (match_varname(buf, \"SYMBOLS\", 4)) {\n        if (!parsesymbols(bufp, PRIMARY)) {\n            config_error_add(\"Error in SYMBOLS definition '%s'\", bufp);\n            retval = FALSE;\n        }\n        switch_symbols(TRUE);\n    } else if (match_varname(buf, \"WIZKIT\", 6)) {\n        (void) strncpy(wizkit, bufp, WIZKIT_MAX - 1);\n#ifdef AMIGA\n    } else if (match_varname(buf, \"FONT\", 4)) {\n        char *t;\n\n        if (t = strchr(buf + 5, ':')) {\n            *t = 0;\n            amii_set_text_font(buf + 5, atoi(t + 1));\n            *t = ':';\n        }\n    } else if (match_varname(buf, \"PATH\", 4)) {\n        (void) strncpy(PATH, bufp, PATHLEN - 1);\n    } else if (match_varname(buf, \"DEPTH\", 5)) {\n        extern int amii_numcolors;\n        int val = atoi(bufp);\n\n        amii_numcolors = 1L << min(DEPTH, val);\n#ifdef SYSFLAGS\n    } else if (match_varname(buf, \"DRIPENS\", 7)) {\n        int i, val;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\"); t != (char *) 0;\n             i < 20 && (t = strtok((char *) 0, \",/\")), ++i) {\n            sscanf(t, \"%d\", &val);\n            sysflags.amii_dripens[i] = val;\n        }\n#endif\n    } else if (match_varname(buf, \"SCREENMODE\", 10)) {\n        extern long amii_scrnmode;\n\n        if (!stricmp(bufp, \"req\"))\n            amii_scrnmode = 0xffffffff; /* Requester */\n        else if (sscanf(bufp, \"%x\", &amii_scrnmode) != 1)\n            amii_scrnmode = 0;\n    } else if (match_varname(buf, \"MSGPENS\", 7)) {\n        extern int amii_msgAPen, amii_msgBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_msgAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_msgBPen);\n        }\n    } else if (match_varname(buf, \"TEXTPENS\", 8)) {\n        extern int amii_textAPen, amii_textBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_textAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_textBPen);\n        }\n    } else if (match_varname(buf, \"MENUPENS\", 8)) {\n        extern int amii_menuAPen, amii_menuBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_menuAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_menuBPen);\n        }\n    } else if (match_varname(buf, \"STATUSPENS\", 10)) {\n        extern int amii_statAPen, amii_statBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_statAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_statBPen);\n        }\n    } else if (match_varname(buf, \"OTHERPENS\", 9)) {\n        extern int amii_otherAPen, amii_otherBPen;\n        char *t = strtok(bufp, \",/\");\n\n        if (t) {\n            sscanf(t, \"%d\", &amii_otherAPen);\n            if (t = strtok((char *) 0, \",/\"))\n                sscanf(t, \"%d\", &amii_otherBPen);\n        }\n    } else if (match_varname(buf, \"PENS\", 4)) {\n        extern unsigned short amii_init_map[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%hx\", &amii_init_map[i]);\n        }\n        amii_setpens(amii_numcolors = i);\n    } else if (match_varname(buf, \"FGPENS\", 6)) {\n        extern int foreg[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%d\", &foreg[i]);\n        }\n    } else if (match_varname(buf, \"BGPENS\", 6)) {\n        extern int backg[AMII_MAXCOLORS];\n        int i;\n        char *t;\n\n        for (i = 0, t = strtok(bufp, \",/\");\n             i < AMII_MAXCOLORS && t != (char *) 0;\n             t = strtok((char *) 0, \",/\"), ++i) {\n            sscanf(t, \"%d\", &backg[i]);\n        }\n#endif /*AMIGA*/\n#ifdef USER_SOUNDS\n    } else if (match_varname(buf, \"SOUNDDIR\", 8)) {\n        sounddir = dupstr(bufp);\n    } else if (match_varname(buf, \"SOUND\", 5)) {\n        add_sound_mapping(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_TILEWIDTH\", 12)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_tilewidth;\n\n        if (qt_tilewidth == NULL)\n            qt_tilewidth = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_TILEHEIGHT\", 13)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_tileheight;\n\n        if (qt_tileheight == NULL)\n            qt_tileheight = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_FONTSIZE\", 11)) {\n#ifdef QT_GRAPHICS\n        extern char *qt_fontsize;\n\n        if (qt_fontsize == NULL)\n            qt_fontsize = dupstr(bufp);\n#endif\n    } else if (match_varname(buf, \"QT_COMPACT\", 10)) {\n#ifdef QT_GRAPHICS\n        extern int qt_compact_mode;\n\n        qt_compact_mode = atoi(bufp);\n#endif\n    } else {\n        config_error_add(\"Unknown config statement\");\n        return FALSE;\n    }\n    return retval;\n}\n\n#ifdef USER_SOUNDS\nboolean\ncan_read_file(filename)\nconst char *filename;\n{\n    return (boolean) (access(filename, 4) == 0);\n}\n#endif /* USER_SOUNDS */\n\nstruct _config_error_frame {\n    int line_num;\n    int num_errors;\n    boolean origline_shown;\n    boolean fromfile;\n    boolean secure;\n    char origline[4 * BUFSZ];\n    char source[BUFSZ];\n    struct _config_error_frame *next;\n};\n\nstatic struct _config_error_frame *config_error_data = 0;\n\nvoid\nconfig_error_init(from_file, sourcename, secure)\nboolean from_file;\nconst char *sourcename;\nboolean secure;\n{\n    struct _config_error_frame *tmp = (struct _config_error_frame *)\n        alloc(sizeof (struct _config_error_frame));\n\n    tmp->line_num = 0;\n    tmp->num_errors = 0;\n    tmp->origline_shown = FALSE;\n    tmp->fromfile = from_file;\n    tmp->secure = secure;\n    tmp->origline[0] = '\\0';\n    if (sourcename && sourcename[0]) {\n        (void) strncpy(tmp->source, sourcename, sizeof (tmp->source) - 1);\n        tmp->source[sizeof (tmp->source) - 1] = '\\0';\n    } else\n        tmp->source[0] = '\\0';\n\n    tmp->next = config_error_data;\n    config_error_data = tmp;\n}\n\nSTATIC_OVL boolean\nconfig_error_nextline(line)\nconst char *line;\n{\n    struct _config_error_frame *ced = config_error_data;\n\n    if (!ced)\n        return FALSE;\n\n    if (ced->num_errors && ced->secure)\n        return FALSE;\n\n    ced->line_num++;\n    ced->origline_shown = FALSE;\n    if (line && line[0]) {\n        (void) strncpy(ced->origline, line, sizeof (ced->origline) - 1);\n        ced->origline[sizeof (ced->origline) - 1] = '\\0';\n    } else\n        ced->origline[0] = '\\0';\n\n    return TRUE;\n}\n\n/* varargs 'config_error_add()' moved to pline.c */\nvoid\nconfig_erradd(buf)\nconst char *buf;\n{\n    char lineno[QBUFSZ];\n\n    if (!buf || !*buf)\n        buf = \"Unknown error\";\n\n    if (!config_error_data) {\n        /* either very early, where pline() will use raw_print(), or\n           player gave bad value when prompted by interactive 'O' command */\n        pline(\"%s%s.\", !iflags.window_inited ? \"config_error_add: \" : \"\", buf);\n        wait_synch();\n        return;\n    }\n\n    config_error_data->num_errors++;\n    if (!config_error_data->origline_shown && !config_error_data->secure) {\n        pline(\"\\n%s\", config_error_data->origline);\n        config_error_data->origline_shown = TRUE;\n    }\n    if (config_error_data->line_num > 0 && !config_error_data->secure) {\n        Sprintf(lineno, \"Line %d: \", config_error_data->line_num);\n    } else\n        lineno[0] = '\\0';\n\n    pline(\"%s %s%s.\", config_error_data->secure ? \"Error:\" : \" *\",\n          lineno, buf);\n}\n\nint\nconfig_error_done()\n{\n    int n;\n    struct _config_error_frame *tmp = config_error_data;\n\n    if (!config_error_data)\n        return 0;\n    n = config_error_data->num_errors;\n    if (n) {\n        pline(\"\\n%d error%s in %s.\\n\", n,\n                   (n > 1) ? \"s\" : \"\",\n                   *config_error_data->source\n              ? config_error_data->source : configfile);\n        wait_synch();\n    }\n    config_error_data = tmp->next;\n    free(tmp);\n    return n;\n}\n\nboolean\nread_config_file(filename, src)\nconst char *filename;\nint src;\n{\n    FILE *fp;\n    boolean rv = TRUE;\n\n    if (!(fp = fopen_config_file(filename, src)))\n        return FALSE;\n\n    /* begin detection of duplicate configfile options */\n    set_duplicate_opt_detection(1);\n    free_config_sections();\n    iflags.parse_config_file_src = src;\n\n    rv = parse_conf_file(fp, parse_config_line);\n    (void) fclose(fp);\n\n    free_config_sections();\n    /* turn off detection of duplicate configfile options */\n    set_duplicate_opt_detection(0);\n    return rv;\n}\n\nSTATIC_OVL FILE *\nfopen_wizkit_file()\n{\n    FILE *fp;\n#if defined(VMS) || defined(UNIX)\n    char tmp_wizkit[BUFSZ];\n#endif\n    char *envp;\n\n    envp = nh_getenv(\"WIZKIT\");\n    if (envp && *envp)\n        (void) strncpy(wizkit, envp, WIZKIT_MAX - 1);\n    if (!wizkit[0])\n        return (FILE *) 0;\n\n#ifdef UNIX\n    if (access(wizkit, 4) == -1) {\n        /* 4 is R_OK on newer systems */\n        /* nasty sneaky attempt to read file through\n         * NetHack's setuid permissions -- this is a\n         * place a file name may be wholly under the player's\n         * control\n         */\n        raw_printf(\"Access to %s denied (%d).\", wizkit, errno);\n        wait_synch();\n        /* fall through to standard names */\n    } else\n#endif\n        if ((fp = fopenp(wizkit, \"r\")) != (FILE *) 0) {\n        return fp;\n#if defined(UNIX) || defined(VMS)\n    } else {\n        /* access() above probably caught most problems for UNIX */\n        raw_printf(\"Couldn't open requested config file %s (%d).\", wizkit,\n                   errno);\n        wait_synch();\n#endif\n    }\n\n#if defined(MICRO) || defined(MAC) || defined(__BEOS__) || defined(WIN32)\n    if ((fp = fopenp(fqname(wizkit, CONFIGPREFIX, 0), \"r\")) != (FILE *) 0)\n        return fp;\n#else\n#ifdef VMS\n    envp = nh_getenv(\"HOME\");\n    if (envp)\n        Sprintf(tmp_wizkit, \"%s%s\", envp, wizkit);\n    else\n        Sprintf(tmp_wizkit, \"%s%s\", \"sys$login:\", wizkit);\n    if ((fp = fopenp(tmp_wizkit, \"r\")) != (FILE *) 0)\n        return fp;\n#else /* should be only UNIX left */\n    envp = nh_getenv(\"HOME\");\n    if (envp)\n        Sprintf(tmp_wizkit, \"%s/%s\", envp, wizkit);\n    else\n        Strcpy(tmp_wizkit, wizkit);\n    if ((fp = fopenp(tmp_wizkit, \"r\")) != (FILE *) 0)\n        return fp;\n    else if (errno != ENOENT) {\n        /* e.g., problems when setuid NetHack can't search home\n         * directory restricted to user */\n        raw_printf(\"Couldn't open default wizkit file %s (%d).\", tmp_wizkit,\n                   errno);\n        wait_synch();\n    }\n#endif\n#endif\n    return (FILE *) 0;\n}\n\n/* add to hero's inventory if there's room, otherwise put item on floor */\nSTATIC_DCL void\nwizkit_addinv(obj)\nstruct obj *obj;\n{\n    if (!obj || obj == &zeroobj)\n        return;\n\n    /* subset of starting inventory pre-ID */\n    obj->dknown = 1;\n    if (Role_if(PM_PRIEST))\n        obj->bknown = 1; /* ok to bypass set_bknown() */\n    /* same criteria as lift_object()'s check for available inventory slot */\n    if (obj->oclass != COIN_CLASS && inv_cnt(FALSE) >= 52\n        && !merge_choice(invent, obj)) {\n        /* inventory overflow; can't just place & stack object since\n           hero isn't in position yet, so schedule for arrival later */\n        add_to_migration(obj);\n        obj->ox = 0; /* index of main dungeon */\n        obj->oy = 1; /* starting level number */\n        obj->owornmask =\n            (long) (MIGR_WITH_HERO | MIGR_NOBREAK | MIGR_NOSCATTER);\n    } else {\n        (void) addinv(obj);\n    }\n}\n\n\nboolean\nproc_wizkit_line(buf)\nchar *buf;\n{\n    struct obj *otmp;\n\n    if (strlen(buf) >= BUFSZ)\n        buf[BUFSZ - 1] = '\\0';\n    otmp = readobjnam(buf, (struct obj *) 0);\n\n    if (otmp) {\n        if (otmp != &zeroobj)\n            wizkit_addinv(otmp);\n    } else {\n        /* .60 limits output line width to 79 chars */\n        config_error_add(\"Bad wizkit item: \\\"%.60s\\\"\", buf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nvoid\nread_wizkit()\n{\n    FILE *fp;\n\n    if (!wizard || !(fp = fopen_wizkit_file()))\n        return;\n\n    program_state.wizkit_wishing = 1;\n    config_error_init(TRUE, \"WIZKIT\", FALSE);\n\n    parse_conf_file(fp, proc_wizkit_line);\n    (void) fclose(fp);\n\n    config_error_done();\n    program_state.wizkit_wishing = 0;\n\n    return;\n}\n\n/* parse_conf_file\n *\n * Read from file fp, handling comments, empty lines, config sections,\n * CHOOSE, and line continuation, calling proc for every valid line.\n *\n * Continued lines are merged together with one space in between.\n */\nSTATIC_OVL boolean\nparse_conf_file(fp, proc)\nFILE *fp;\nboolean FDECL((*proc), (char *));\n{\n    char inbuf[4 * BUFSZ];\n    boolean rv = TRUE; /* assume successful parse */\n    char *ep;\n    boolean skip = FALSE, morelines = FALSE;\n    char *buf = (char *) 0;\n    size_t inbufsz = sizeof inbuf;\n\n    free_config_sections();\n\n    while (fgets(inbuf, (int) inbufsz, fp)) {\n        ep = index(inbuf, '\\n');\n        if (skip) { /* in case previous line was too long */\n            if (ep)\n                skip = FALSE; /* found newline; next line is normal */\n        } else {\n            if (!ep) {  /* newline missing */\n                if (strlen(inbuf) < (inbufsz - 2)) {\n                    /* likely the last line of file is just\n                       missing a newline; process it anyway  */\n                    ep = eos(inbuf);\n                } else {\n                    config_error_add(\"Line too long, skipping\");\n                    skip = TRUE; /* discard next fgets */\n                }\n            } else {\n                *ep = '\\0'; /* remove newline */\n            }\n            if (ep) {\n                char *tmpbuf = (char *) 0;\n                int len;\n                boolean ignoreline = FALSE;\n                boolean oldline = FALSE;\n\n                /* line continuation (trailing '\\') */\n                morelines = (--ep >= inbuf && *ep == '\\\\');\n                if (morelines)\n                    *ep = '\\0';\n\n                /* trim off spaces at end of line */\n                while (ep >= inbuf\n                       && (*ep == ' ' || *ep == '\\t' || *ep == '\\r'))\n                    *ep-- = '\\0';\n\n                if (!config_error_nextline(inbuf)) {\n                    rv = FALSE;\n                    if (buf)\n                        free(buf), buf = (char *) 0;\n                    break;\n                }\n\n                ep = inbuf;\n                while (*ep == ' ' || *ep == '\\t')\n                    ++ep;\n\n                /* ignore empty lines and full-line comment lines */\n                if (!*ep || *ep == '#')\n                    ignoreline = TRUE;\n\n                if (buf)\n                    oldline = TRUE;\n\n                /* merge now read line with previous ones, if necessary */\n                if (!ignoreline) {\n                    len = (int) strlen(ep) + 1; /* +1: final '\\0' */\n                    if (buf)\n                        len += (int) strlen(buf) + 1; /* +1: space */\n                    tmpbuf = (char *) alloc(len);\n                    *tmpbuf = '\\0';\n                    if (buf) {\n                        Strcat(strcpy(tmpbuf, buf), \" \");\n                        free(buf);\n                    }\n                    buf = strcat(tmpbuf, ep);\n                    if (strlen(buf) >= sizeof inbuf)\n                        buf[sizeof inbuf - 1] = '\\0';\n                }\n\n                if (morelines || (ignoreline && !oldline))\n                    continue;\n\n                if (handle_config_section(buf)) {\n                    free(buf);\n                    buf = (char *) 0;\n                    continue;\n                }\n\n                /* from here onwards, we'll handle buf only */\n\n                if (match_varname(buf, \"CHOOSE\", 6)) {\n                    char *section;\n                    char *bufp = find_optparam(buf);\n\n                    if (!bufp) {\n                        config_error_add(\n                                    \"Format is CHOOSE=section1,section2,...\");\n                        rv = FALSE;\n                        free(buf);\n                        buf = (char *) 0;\n                        continue;\n                    }\n                    bufp++;\n                    if (config_section_chosen)\n                        free(config_section_chosen), config_section_chosen = 0;\n                    section = choose_random_part(bufp, ',');\n                    if (section) {\n                        config_section_chosen = dupstr(section);\n                    } else {\n                        config_error_add(\"No config section to choose\");\n                        rv = FALSE;\n                    }\n                    free(buf);\n                    buf = (char *) 0;\n                    continue;\n                }\n\n                if (!proc(buf))\n                    rv = FALSE;\n\n                free(buf);\n                buf = (char *) 0;\n            }\n        }\n    }\n\n    if (buf)\n        free(buf);\n\n    free_config_sections();\n    return rv;\n}\n\nextern struct symsetentry *symset_list;  /* options.c */\nextern const char *known_handling[];     /* drawing.c */\nextern const char *known_restrictions[]; /* drawing.c */\nstatic int symset_count = 0;             /* for pick-list building only */\nstatic boolean chosen_symset_start = FALSE, chosen_symset_end = FALSE;\nstatic int symset_which_set = 0;\n\nSTATIC_OVL\nFILE *\nfopen_sym_file()\n{\n    FILE *fp;\n\n    fp = fopen_datafile(SYMBOLS, \"r\",\n#ifdef WIN32\n                            SYSCONFPREFIX\n#else\n                            HACKPREFIX\n#endif\n                       );\n\n    return fp;\n}\n\n/*\n * Returns 1 if the chose symset was found and loaded.\n *         0 if it wasn't found in the sym file or other problem.\n */\nint\nread_sym_file(which_set)\nint which_set;\n{\n    FILE *fp;\n\n    symset[which_set].explicitly = FALSE;\n    if (!(fp = fopen_sym_file()))\n        return 0;\n\n    symset[which_set].explicitly = TRUE;\n    symset_count = 0;\n    chosen_symset_start = chosen_symset_end = FALSE;\n    symset_which_set = which_set;\n\n    config_error_init(TRUE, \"symbols\", FALSE);\n\n    parse_conf_file(fp, proc_symset_line);\n    (void) fclose(fp);\n\n    if (!chosen_symset_start && !chosen_symset_end) {\n        /* name caller put in symset[which_set].name was not found;\n           if it looks like \"Default symbols\", null it out and return\n           success to use the default; otherwise, return failure */\n        if (symset[which_set].name\n            && (fuzzymatch(symset[which_set].name, \"Default symbols\",\n                           \" -_\", TRUE)\n                || !strcmpi(symset[which_set].name, \"default\")))\n            clear_symsetentry(which_set, TRUE);\n        config_error_done();\n\n        /* If name was defined, it was invalid... Then we're loading fallback */\n        if (symset[which_set].name) {\n            symset[which_set].explicitly = FALSE;\n            return 0;\n        }\n\n        return 1;\n    }\n    if (!chosen_symset_end)\n        config_error_add(\"Missing finish for symset \\\"%s\\\"\",\n                         symset[which_set].name ? symset[which_set].name\n                                                : \"unknown\");\n    config_error_done();\n    return 1;\n}\n\nboolean\nproc_symset_line(buf)\nchar *buf;\n{\n    return !((boolean) parse_sym_line(buf, symset_which_set));\n}\n\n/* returns 0 on error */\nint\nparse_sym_line(buf, which_set)\nchar *buf;\nint which_set;\n{\n    int val, i;\n    struct symparse *symp;\n    char *bufp, *commentp, *altp;\n\n    if (strlen(buf) >= BUFSZ)\n        buf[BUFSZ - 1] = '\\0';\n    /* convert each instance of whitespace (tabs, consecutive spaces)\n       into a single space; leading and trailing spaces are stripped */\n    mungspaces(buf);\n\n    /* remove trailing comment, if any (this isn't strictly needed for\n       individual symbols, and it won't matter if \"X#comment\" without\n       separating space slips through; for handling or set description,\n       symbol set creator is responsible for preceding '#' with a space\n       and that comment itself doesn't contain \" #\") */\n    if ((commentp = rindex(buf, '#')) != 0 && commentp[-1] == ' ')\n        commentp[-1] = '\\0';\n\n    /* find the '=' or ':' */\n    bufp = index(buf, '=');\n    altp = index(buf, ':');\n    if (!bufp || (altp && altp < bufp))\n        bufp = altp;\n    if (!bufp) {\n        if (strncmpi(buf, \"finish\", 6) == 0) {\n            /* end current graphics set */\n            if (chosen_symset_start)\n                chosen_symset_end = TRUE;\n            chosen_symset_start = FALSE;\n            return 1;\n        }\n        config_error_add(\"No \\\"finish\\\"\");\n        return 0;\n    }\n    /* skip '=' and space which follows, if any */\n    ++bufp;\n    if (*bufp == ' ')\n        ++bufp;\n\n    symp = match_sym(buf);\n    if (!symp) {\n        config_error_add(\"Unknown sym keyword\");\n        return 0;\n    }\n\n    if (!symset[which_set].name) {\n        /* A null symset name indicates that we're just\n           building a pick-list of possible symset\n           values from the file, so only do that */\n        if (symp->range == SYM_CONTROL) {\n            struct symsetentry *tmpsp, *lastsp;\n\n            for (lastsp = symset_list; lastsp; lastsp = lastsp->next)\n                if (!lastsp->next)\n                    break;\n            switch (symp->idx) {\n            case 0:\n                tmpsp = (struct symsetentry *) alloc(sizeof *tmpsp);\n                tmpsp->next = (struct symsetentry *) 0;\n                if (!lastsp)\n                    symset_list = tmpsp;\n                else\n                    lastsp->next = tmpsp;\n                tmpsp->idx = symset_count++;\n                tmpsp->name = dupstr(bufp);\n                tmpsp->desc = (char *) 0;\n                tmpsp->handling = H_UNK;\n                /* initialize restriction bits */\n                tmpsp->nocolor = 0;\n                tmpsp->primary = 0;\n                tmpsp->rogue = 0;\n                break;\n            case 2:\n                /* handler type identified */\n                tmpsp = lastsp; /* most recent symset */\n                for (i = 0; known_handling[i]; ++i)\n                    if (!strcmpi(known_handling[i], bufp)) {\n                        tmpsp->handling = i;\n                        break; /* for loop */\n                    }\n                break;\n            case 3:\n                /* description:something */\n                tmpsp = lastsp; /* most recent symset */\n                if (tmpsp && !tmpsp->desc)\n                    tmpsp->desc = dupstr(bufp);\n                break;\n            case 5:\n                /* restrictions: xxxx*/\n                tmpsp = lastsp; /* most recent symset */\n                for (i = 0; known_restrictions[i]; ++i) {\n                    if (!strcmpi(known_restrictions[i], bufp)) {\n                        switch (i) {\n                        case 0:\n                            tmpsp->primary = 1;\n                            break;\n                        case 1:\n                            tmpsp->rogue = 1;\n                            break;\n                        }\n                        break; /* while loop */\n                    }\n                }\n                break;\n            }\n        }\n        return 1;\n    }\n    if (symp->range) {\n        if (symp->range == SYM_CONTROL) {\n            switch (symp->idx) {\n            case 0:\n                /* start of symset */\n                if (!strcmpi(bufp, symset[which_set].name)) {\n                    /* matches desired one */\n                    chosen_symset_start = TRUE;\n                    /* these init_*() functions clear symset fields too */\n                    if (which_set == ROGUESET)\n                        init_rogue_symbols();\n                    else if (which_set == PRIMARY)\n                        init_primary_symbols();\n                }\n                break;\n            case 1:\n                /* finish symset */\n                if (chosen_symset_start)\n                    chosen_symset_end = TRUE;\n                chosen_symset_start = FALSE;\n                break;\n            case 2:\n                /* handler type identified */\n                if (chosen_symset_start)\n                    set_symhandling(bufp, which_set);\n                break;\n            /* case 3: (description) is ignored here */\n            case 4: /* color:off */\n                if (chosen_symset_start) {\n                    if (bufp) {\n                        if (!strcmpi(bufp, \"true\") || !strcmpi(bufp, \"yes\")\n                            || !strcmpi(bufp, \"on\"))\n                            symset[which_set].nocolor = 0;\n                        else if (!strcmpi(bufp, \"false\")\n                                 || !strcmpi(bufp, \"no\")\n                                 || !strcmpi(bufp, \"off\"))\n                            symset[which_set].nocolor = 1;\n                    }\n                }\n                break;\n            case 5: /* restrictions: xxxx*/\n                if (chosen_symset_start) {\n                    int n = 0;\n\n                    while (known_restrictions[n]) {\n                        if (!strcmpi(known_restrictions[n], bufp)) {\n                            switch (n) {\n                            case 0:\n                                symset[which_set].primary = 1;\n                                break;\n                            case 1:\n                                symset[which_set].rogue = 1;\n                                break;\n                            }\n                            break; /* while loop */\n                        }\n                        n++;\n                    }\n                }\n                break;\n            }\n        } else { /* !SYM_CONTROL */\n            val = sym_val(bufp);\n            if (chosen_symset_start) {\n                if (which_set == PRIMARY) {\n                    update_primary_symset(symp, val);\n                } else if (which_set == ROGUESET) {\n                    update_rogue_symset(symp, val);\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nSTATIC_OVL void\nset_symhandling(handling, which_set)\nchar *handling;\nint which_set;\n{\n    int i = 0;\n\n    symset[which_set].handling = H_UNK;\n    while (known_handling[i]) {\n        if (!strcmpi(known_handling[i], handling)) {\n            symset[which_set].handling = i;\n            return;\n        }\n        i++;\n    }\n}\n\n/* ----------  END CONFIG FILE HANDLING ----------- */\n\n/* ----------  BEGIN SCOREBOARD CREATION ----------- */\n\n#ifdef OS2_CODEVIEW\n#define UNUSED_if_not_OS2_CODEVIEW /*empty*/\n#else\n#define UNUSED_if_not_OS2_CODEVIEW UNUSED\n#endif\n\n/* verify that we can write to scoreboard file; if not, try to create one */\n/*ARGUSED*/\nvoid\ncheck_recordfile(dir)\nconst char *dir UNUSED_if_not_OS2_CODEVIEW;\n{\n#if defined(PRAGMA_UNUSED) && !defined(OS2_CODEVIEW)\n#pragma unused(dir)\n#endif\n    const char *fq_record;\n    int fd;\n\n#if defined(UNIX) || defined(VMS)\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n    fd = open(fq_record, O_RDWR, 0);\n    if (fd >= 0) {\n#ifdef VMS /* must be stream-lf to use UPDATE_RECORD_IN_PLACE */\n        if (!file_is_stmlf(fd)) {\n            raw_printf(\n                   \"Warning: scoreboard file '%s' is not in stream_lf format\",\n                       fq_record);\n            wait_synch();\n        }\n#endif\n        (void) nhclose(fd); /* RECORD is accessible */\n    } else if ((fd = open(fq_record, O_CREAT | O_RDWR, FCMASK)) >= 0) {\n        (void) nhclose(fd); /* RECORD newly created */\n#if defined(VMS) && !defined(SECURE)\n        /* Re-protect RECORD with world:read+write+execute+delete access. */\n        (void) chmod(fq_record, FCMASK | 007);\n#endif /* VMS && !SECURE */\n    } else {\n        raw_printf(\"Warning: cannot write scoreboard file '%s'\", fq_record);\n        wait_synch();\n    }\n#endif /* !UNIX && !VMS */\n#if defined(MICRO) || defined(WIN32)\n    char tmp[PATHLEN];\n\n#ifdef OS2_CODEVIEW /* explicit path on opening for OS/2 */\n    /* how does this work when there isn't an explicit path or fopenp\n     * for later access to the file via fopen_datafile? ? */\n    (void) strncpy(tmp, dir, PATHLEN - 1);\n    tmp[PATHLEN - 1] = '\\0';\n    if ((strlen(tmp) + 1 + strlen(RECORD)) < (PATHLEN - 1)) {\n        append_slash(tmp);\n        Strcat(tmp, RECORD);\n    }\n    fq_record = tmp;\n#else\n    Strcpy(tmp, RECORD);\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n#endif\n#ifdef WIN32\n    /* If dir is NULL it indicates create but\n       only if it doesn't already exist */\n    if (!dir) {\n        char buf[BUFSZ];\n\n        buf[0] = '\\0';\n        fd = open(fq_record, O_RDWR);\n        if (!(fd == -1 && errno == ENOENT)) {\n            if (fd >= 0) {\n                (void) nhclose(fd);\n            } else {\n                /* explanation for failure other than missing file */\n                Sprintf(buf, \"error   \\\"%s\\\", (errno %d).\",\n                        fq_record, errno);\n                paniclog(\"scorefile\", buf);\n            }\n            return;\n        }\n        Sprintf(buf, \"missing \\\"%s\\\", creating new scorefile.\",\n                fq_record);\n        paniclog(\"scorefile\", buf);\n    }\n#endif\n\n    if ((fd = open(fq_record, O_RDWR)) < 0) {\n        /* try to create empty 'record' */\n#if defined(AZTEC_C) || defined(_DCC) \\\n    || (defined(__GNUC__) && defined(__AMIGA__))\n        /* Aztec doesn't use the third argument */\n        /* DICE doesn't like it */\n        fd = open(fq_record, O_CREAT | O_RDWR);\n#else\n        fd = open(fq_record, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);\n#endif\n        if (fd <= 0) {\n            raw_printf(\"Warning: cannot write record '%s'\", tmp);\n            wait_synch();\n        } else {\n            (void) nhclose(fd);\n        }\n    } else {\n        /* open succeeded => 'record' exists */\n        (void) nhclose(fd);\n    }\n#else /* MICRO || WIN32*/\n\n#ifdef MAC\n    /* Create the \"record\" file, if necessary */\n    fq_record = fqname(RECORD, SCOREPREFIX, 0);\n    fd = macopen(fq_record, O_RDWR | O_CREAT, TEXT_TYPE);\n    if (fd != -1)\n        macclose(fd);\n#endif /* MAC */\n\n#endif /* MICRO || WIN32*/\n}\n\n/* ----------  END SCOREBOARD CREATION ----------- */\n\n/* ----------  BEGIN PANIC/IMPOSSIBLE/TESTING LOG ----------- */\n\n/*ARGSUSED*/\nvoid\npaniclog(type, reason)\nconst char *type;   /* panic, impossible, trickery */\nconst char *reason; /* explanation */\n{\n#ifdef PANICLOG\n    FILE *lfile;\n    char buf[BUFSZ];\n\n    if (!program_state.in_paniclog) {\n        program_state.in_paniclog = 1;\n        lfile = fopen_datafile(PANICLOG, \"a\", TROUBLEPREFIX);\n        if (lfile) {\n#ifdef PANICLOG_FMT2\n            (void) fprintf(lfile, \"%ld %s: %s %s\\n\",\n                           ubirthday, (plname ? plname : \"(none)\"),\n                           type, reason);\n#else\n            time_t now = getnow();\n            int uid = getuid();\n            char playmode = wizard ? 'D' : discover ? 'X' : '-';\n\n            (void) fprintf(lfile, \"%s %08ld %06ld %d %c: %s %s\\n\",\n                           version_string(buf), yyyymmdd(now), hhmmss(now),\n                           uid, playmode, type, reason);\n#endif /* !PANICLOG_FMT2 */\n            (void) fclose(lfile);\n        }\n        program_state.in_paniclog = 0;\n    }\n#endif /* PANICLOG */\n    return;\n}\n\nvoid\ntestinglog(filenm, type, reason)\nconst char *filenm;   /* ad hoc file name */\nconst char *type;\nconst char *reason;   /* explanation */\n{\n    FILE *lfile;\n    char fnbuf[BUFSZ];\n\n    if (!filenm)\n        return;\n    Strcpy(fnbuf, filenm);\n    if (index(fnbuf, '.') == 0)\n        Strcat(fnbuf, \".log\");\n    lfile = fopen_datafile(fnbuf, \"a\", TROUBLEPREFIX);\n    if (lfile) {\n        (void) fprintf(lfile, \"%s\\n%s\\n\", type, reason);\n        (void) fclose(lfile);\n    }\n    return;\n}\n\n/* ----------  END PANIC/IMPOSSIBLE/TESTING LOG ----------- */\n\n#ifdef SELF_RECOVER\n\n/* ----------  BEGIN INTERNAL RECOVER ----------- */\nboolean\nrecover_savefile()\n{\n    int gfd, lfd, sfd;\n    int lev, savelev, hpid, pltmpsiz;\n    xchar levc;\n    struct version_info version_data;\n    int processed[256];\n    char savename[SAVESIZE], errbuf[BUFSZ];\n    struct savefile_info sfi;\n    char tmpplbuf[PL_NSIZ];\n\n    for (lev = 0; lev < 256; lev++)\n        processed[lev] = 0;\n\n    /* level 0 file contains:\n     *  pid of creating process (ignored here)\n     *  level number for current level of save file\n     *  name of save file nethack would have created\n     *  savefile info\n     *  player name\n     *  and game state\n     */\n    gfd = open_levelfile(0, errbuf);\n    if (gfd < 0) {\n        raw_printf(\"%s\\n\", errbuf);\n        return FALSE;\n    }\n    if (read(gfd, (genericptr_t) &hpid, sizeof hpid) != sizeof hpid) {\n        raw_printf(\"\\n%s\\n%s\\n\",\n            \"Checkpoint data incompletely written or subsequently clobbered.\",\n                   \"Recovery impossible.\");\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n    if (read(gfd, (genericptr_t) &savelev, sizeof(savelev))\n        != sizeof(savelev)) {\n        raw_printf(\n         \"\\nCheckpointing was not in effect for %s -- recovery impossible.\\n\",\n                   lock);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n    if ((read(gfd, (genericptr_t) savename, sizeof savename)\n         != sizeof savename)\n        || (read(gfd, (genericptr_t) &version_data, sizeof version_data)\n            != sizeof version_data)\n        || (read(gfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi)\n        || (read(gfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)\n            != sizeof pltmpsiz) || (pltmpsiz > PL_NSIZ)\n        || (read(gfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz)) {\n        raw_printf(\"\\nError reading %s -- can't recover.\\n\", lock);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n\n    /* save file should contain:\n     *  version info\n     *  savefile info\n     *  player name\n     *  current level (including pets)\n     *  (non-level-based) game state\n     *  other levels\n     */\n    set_savefile_name(TRUE);\n    sfd = create_savefile();\n    if (sfd < 0) {\n        raw_printf(\"\\nCannot recover savefile %s.\\n\", SAVEF);\n        (void) nhclose(gfd);\n        return FALSE;\n    }\n\n    lfd = open_levelfile(savelev, errbuf);\n    if (lfd < 0) {\n        raw_printf(\"\\n%s\\n\", errbuf);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &version_data, sizeof version_data)\n        != sizeof version_data) {\n        raw_printf(\"\\nError writing %s; recovery failed.\", SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi) {\n        raw_printf(\"\\nError writing %s; recovery failed (savefile_info).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)\n        != sizeof pltmpsiz) {\n        raw_printf(\"Error writing %s; recovery failed (player name size).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (write(sfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz) {\n        raw_printf(\"Error writing %s; recovery failed (player name).\\n\",\n                   SAVEF);\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n\n    if (!copy_bytes(lfd, sfd)) {\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        (void) nhclose(lfd);\n        delete_savefile();\n        return FALSE;\n    }\n    (void) nhclose(lfd);\n    processed[savelev] = 1;\n\n    if (!copy_bytes(gfd, sfd)) {\n        (void) nhclose(gfd);\n        (void) nhclose(sfd);\n        delete_savefile();\n        return FALSE;\n    }\n    (void) nhclose(gfd);\n    processed[0] = 1;\n\n    for (lev = 1; lev < 256; lev++) {\n        /* level numbers are kept in xchars in save.c, so the\n         * maximum level number (for the endlevel) must be < 256\n         */\n        if (lev != savelev) {\n            lfd = open_levelfile(lev, (char *) 0);\n            if (lfd >= 0) {\n                /* any or all of these may not exist */\n                levc = (xchar) lev;\n                write(sfd, (genericptr_t) &levc, sizeof(levc));\n                if (!copy_bytes(lfd, sfd)) {\n                    (void) nhclose(lfd);\n                    (void) nhclose(sfd);\n                    delete_savefile();\n                    return FALSE;\n                }\n                (void) nhclose(lfd);\n                processed[lev] = 1;\n            }\n        }\n    }\n    (void) nhclose(sfd);\n\n#ifdef HOLD_LOCKFILE_OPEN\n    really_close();\n#endif\n    /*\n     * We have a successful savefile!\n     * Only now do we erase the level files.\n     */\n    for (lev = 0; lev < 256; lev++) {\n        if (processed[lev]) {\n            const char *fq_lock;\n\n            set_levelfile_name(lock, lev);\n            fq_lock = fqname(lock, LEVELPREFIX, 3);\n            (void) unlink(fq_lock);\n        }\n    }\n    return TRUE;\n}\n\nboolean\ncopy_bytes(ifd, ofd)\nint ifd, ofd;\n{\n    char buf[BUFSIZ];\n    int nfrom, nto;\n\n    do {\n        nfrom = read(ifd, buf, BUFSIZ);\n        nto = write(ofd, buf, nfrom);\n        if (nto != nfrom)\n            return FALSE;\n    } while (nfrom == BUFSIZ);\n    return TRUE;\n}\n\n/* ----------  END INTERNAL RECOVER ----------- */\n#endif /*SELF_RECOVER*/\n\n/* ----------  OTHER ----------- */\n\n#ifdef SYSCF\n#ifdef SYSCF_FILE\nvoid\nassure_syscf_file()\n{\n    int fd;\n\n#ifdef WIN32\n    /* We are checking that the sysconf exists ... lock the path */\n    fqn_prefix_locked[SYSCONFPREFIX] = TRUE;\n#endif\n    /*\n     * All we really care about is the end result - can we read the file?\n     * So just check that directly.\n     *\n     * Not tested on most of the old platforms (which don't attempt\n     * to implement SYSCF).\n     * Some ports don't like open()'s optional third argument;\n     * VMS overrides open() usage with a macro which requires it.\n     */\n#ifndef VMS\n# if defined(NOCWD_ASSUMPTIONS) && defined(WIN32)\n    fd = open(fqname(SYSCF_FILE, SYSCONFPREFIX, 0), O_RDONLY);\n# else\n    fd = open(SYSCF_FILE, O_RDONLY);\n# endif\n#else\n    fd = open(SYSCF_FILE, O_RDONLY, 0);\n#endif\n    if (fd >= 0) {\n        /* readable */\n        close(fd);\n        return;\n    }\n    raw_printf(\"Unable to open SYSCF_FILE.\\n\");\n    exit(EXIT_FAILURE);\n}\n\n#endif /* SYSCF_FILE */\n#endif /* SYSCF */\n\n#ifdef DEBUG\n/* used by debugpline() to decide whether to issue a message\n * from a particular source file; caller passes __FILE__ and we check\n * whether it is in the source file list supplied by SYSCF's DEBUGFILES\n *\n * pass FALSE to override wildcard matching; useful for files\n * like dungeon.c and questpgr.c, which generate a ridiculous amount of\n * output if DEBUG is defined and effectively block the use of a wildcard */\nboolean\ndebugcore(filename, wildcards)\nconst char *filename;\nboolean wildcards;\n{\n    const char *debugfiles, *p;\n\n    if (!filename || !*filename)\n        return FALSE; /* sanity precaution */\n\n    if (sysopt.env_dbgfl == 0) {\n        /* check once for DEBUGFILES in the environment;\n           if found, it supersedes the sysconf value\n           [note: getenv() rather than nh_getenv() since a long value\n           is valid and doesn't pose any sort of overflow risk here] */\n        if ((p = getenv(\"DEBUGFILES\")) != 0) {\n            if (sysopt.debugfiles)\n                free((genericptr_t) sysopt.debugfiles);\n            sysopt.debugfiles = dupstr(p);\n            sysopt.env_dbgfl = 1;\n        } else\n            sysopt.env_dbgfl = -1;\n    }\n\n    debugfiles = sysopt.debugfiles;\n    /* usual case: sysopt.debugfiles will be empty */\n    if (!debugfiles || !*debugfiles)\n        return FALSE;\n\n/* strip filename's path if present */\n#ifdef UNIX\n    if ((p = rindex(filename, '/')) != 0)\n        filename = p + 1;\n#endif\n#ifdef VMS\n    filename = vms_basename(filename);\n    /* vms_basename strips off 'type' suffix as well as path and version;\n       we want to put suffix back (\".c\" assumed); since it always returns\n       a pointer to a static buffer, we can safely modify its result */\n    Strcat((char *) filename, \".c\");\n#endif\n\n    /*\n     * Wildcard match will only work if there's a single pattern (which\n     * might be a single file name without any wildcarding) rather than\n     * a space-separated list.\n     * [to NOT do: We could step through the space-separated list and\n     * attempt a wildcard match against each element, but that would be\n     * overkill for the intended usage.]\n     */\n    if (wildcards && pmatch(debugfiles, filename))\n        return TRUE;\n\n    /* check whether filename is an element of the list */\n    if ((p = strstr(debugfiles, filename)) != 0) {\n        int l = (int) strlen(filename);\n\n        if ((p == debugfiles || p[-1] == ' ' || p[-1] == '/')\n            && (p[l] == ' ' || p[l] == '\\0'))\n            return TRUE;\n    }\n    return FALSE;\n}\n\n#endif /*DEBUG*/\n\n#ifdef UNIX\n#ifndef PATH_MAX\n#include <limits.h>\n#endif\n#endif\n\nvoid\nreveal_paths(VOID_ARGS)\n{\n    const char *fqn, *nodumpreason;\n    char buf[BUFSZ];\n#if defined(SYSCF) || !defined(UNIX) || defined(DLB)\n    const char *filep;\n#ifdef SYSCF\n    const char *gamename = (hname && *hname) ? hname : \"NetHack\";\n#endif\n#endif\n#ifdef UNIX\n    char *endp, *envp, cwdbuf[PATH_MAX];\n#endif\n#ifdef PREFIXES_IN_USE\n    const char *strp;\n    int i, maxlen = 0;\n\n    raw_print(\"Variable playground locations:\");\n    for (i = 0; i < PREFIX_COUNT; i++)\n        raw_printf(\"    [%-10s]=\\\"%s\\\"\", fqn_prefix_names[i],\n                   fqn_prefix[i] ? fqn_prefix[i] : \"not set\");\n#endif\n\n    /* sysconf file */\n\n#ifdef SYSCF\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[SYSCONFPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#else\n    buf[0] = '\\0';\n#endif\n    raw_printf(\"%s system configuration file%s:\", s_suffix(gamename), buf);\n#ifdef SYSCF_FILE\n    filep = SYSCF_FILE;\n#else\n    filep = \"sysconf\";\n#endif\n    fqn = fqname(filep, SYSCONFPREFIX, 0);\n    if (fqn) {\n        set_configfile_name(fqn);\n        filep = configfile;\n    }\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#else /* !SYSCF */\n    raw_printf(\"No system configuration file.\");\n#endif /* ?SYSCF */\n\n    /* symbols file */\n\n    buf[0] = '\\0';\n#ifndef UNIX\n#ifdef PREFIXES_IN_USE\n#ifdef WIN32\n    strp = fqn_prefix_names[SYSCONFPREFIX];\n#else\n    strp = fqn_prefix_names[HACKPREFIX];\n#endif /* WIN32 */\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"The loadable symbols file%s:\", buf);\n#endif /* UNIX */\n\n#ifdef UNIX\n    envp = getcwd(cwdbuf, PATH_MAX);\n    if (envp) {\n        raw_print(\"The loadable symbols file:\");\n        raw_printf(\"    \\\"%s/%s\\\"\", envp, SYMBOLS);\n    }\n#else /* UNIX */\n    filep = SYMBOLS;\n#ifdef PREFIXES_IN_USE\n#ifdef WIN32\n    fqn = fqname(filep, SYSCONFPREFIX, 1);\n#else\n    fqn = fqname(filep, HACKPREFIX, 1);\n#endif /* WIN32 */\n    if (fqn)\n        filep = fqn;\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#endif /* UNIX */\n\n    /* dlb vs non-dlb */\n\n    buf[0] = '\\0';\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[DATAPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif\n#ifdef DLB\n    raw_printf(\"Basic data files%s are collected inside:\", buf);\n    filep = DLBFILE;\n#ifdef VERSION_IN_DLB_FILENAME\n    Strcpy(buf, build_dlb_filename((const char *) 0));\n#ifdef PREFIXES_IN_USE\n    fqn = fqname(buf, DATAPREFIX, 1);\n    if (fqn)\n        filep = fqn;\n#endif /* PREFIXES_IN_USE */\n#endif\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#ifdef DLBFILE2\n    filep = DLBFILE2;\n    raw_printf(\"    \\\"%s\\\"\", filep);\n#endif\n#else /* !DLB */\n    raw_printf(\"Basic data files%s are in many separate files.\", buf);\n#endif /* ?DLB */\n\n    /* dumplog */\n\n#ifndef DUMPLOG\n    nodumpreason = \"not supported\";\n#else\n    nodumpreason = \"disabled\";\n#ifdef SYSCF\n    fqn = sysopt.dumplogfile;\n#else  /* !SYSCF */\n#ifdef DUMPLOG_FILE\n    fqn = DUMPLOG_FILE;\n#else\n    fqn = (char *) 0;\n#endif\n#endif /* ?SYSCF */\n    if (fqn && *fqn) {\n        raw_print(\"Your end-of-game disclosure file:\");\n        (void) dump_fmtstr(fqn, buf, FALSE);\n        buf[sizeof buf - sizeof \"    \\\"\\\"\"] = '\\0';\n        raw_printf(\"    \\\"%s\\\"\", buf);\n    } else\n#endif /* ?DUMPLOG */\n        raw_printf(\"No end-of-game disclosure file (%s).\", nodumpreason);\n\n#ifdef WIN32\n    if (sysopt.portable_device_top) {\n        const char *pd = get_portable_device();\n\n        raw_printf(\"Writable folder for portable device config (sysconf %s):\",\n                    \"portable_device_top\");\n        raw_printf(\"    \\\"%s\\\"\", pd);\n    }\n#endif\n\n    /* personal configuration file */\n\n    buf[0] = '\\0';\n#ifdef PREFIXES_IN_USE\n    strp = fqn_prefix_names[CONFIGPREFIX];\n    maxlen = BUFSZ - sizeof \" (in )\";\n    if (strp && (int) strlen(strp) < maxlen)\n        Sprintf(buf, \" (in %s)\", strp);\n#endif /* PREFIXES_IN_USE */\n    raw_printf(\"Your personal configuration file%s:\", buf);\n\n#ifdef UNIX\n    buf[0] = '\\0';\n    if ((envp = nh_getenv(\"HOME\")) != 0) {\n        copynchars(buf, envp, (int) sizeof buf - 1 - 1);\n        Strcat(buf, \"/\");\n    }\n    endp = eos(buf);\n    copynchars(endp, default_configfile,\n               (int) (sizeof buf - 1 - strlen(buf)));\n#if defined(__APPLE__) /* UNIX+__APPLE__ => MacOSX aka OSX aka macOS */\n    if (envp) {\n        if (access(buf, 4) == -1) { /* 4: R_OK, -1: failure */\n            /* read access to default failed; might be protected excessively\n               but more likely it doesn't exist; try first alternate:\n               \"$HOME/Library/Pref...\"; 'endp' points past '/' */\n            copynchars(endp, \"Library/Preferences/NetHack Defaults\",\n                       (int) (sizeof buf - 1 - strlen(buf)));\n            if (access(buf, 4) == -1) {\n                /* first alternate failed, try second:\n                   \".../NetHack Defaults.txt\"; no 'endp', just append */\n                copynchars(eos(buf), \".txt\",\n                           (int) (sizeof buf - 1 - strlen(buf)));\n                if (access(buf, 4) == -1) {\n                    /* second alternate failed too, so revert to the\n                       original default (\"$HOME/.nethackrc\") for message */\n                    copynchars(endp, default_configfile,\n                               (int) (sizeof buf - 1 - strlen(buf)));\n                }\n            }\n        }\n    }\n#endif /* __APPLE__ */\n    raw_printf(\"    \\\"%s\\\"\", buf);\n#else /* !UNIX */\n    fqn = (const char *) 0;\n#ifdef PREFIXES_IN_USE\n    fqn = fqname(default_configfile, CONFIGPREFIX, 2);\n#endif\n    raw_printf(\"    \\\"%s\\\"\", fqn ? fqn : default_configfile);\n#endif  /* ?UNIX */\n\n    raw_print(\"\");\n}\n\n/* ----------  BEGIN TRIBUTE ----------- */\n\n/* 3.6 tribute code\n */\n\n#define SECTIONSCOPE 1\n#define TITLESCOPE 2\n#define PASSAGESCOPE 3\n\n#define MAXPASSAGES SIZE(context.novel.pasg) /* 20 */\n\nstatic int FDECL(choose_passage, (int, unsigned));\n\n/* choose a random passage that hasn't been chosen yet; once all have\n   been chosen, reset the tracking to make all passages available again */\nstatic int\nchoose_passage(passagecnt, oid)\nint passagecnt; /* total of available passages */\nunsigned oid; /* book.o_id, used to determine whether re-reading same book */\n{\n    int idx, res;\n\n    if (passagecnt < 1)\n        return 0;\n\n    /* if a different book or we've used up all the passages already,\n       reset in order to have all 'passagecnt' passages available */\n    if (oid != context.novel.id || context.novel.count == 0) {\n        int i, range = passagecnt, limit = MAXPASSAGES;\n\n        context.novel.id = oid;\n        if (range <= limit) {\n            /* collect all of the N indices */\n            context.novel.count = passagecnt;\n            for (idx = 0; idx < MAXPASSAGES; idx++)\n                context.novel.pasg[idx] = (xchar) ((idx < passagecnt)\n                                                   ? idx + 1 : 0);\n        } else {\n            /* collect MAXPASSAGES of the N indices */\n            context.novel.count = MAXPASSAGES;\n            for (idx = i = 0; i < passagecnt; ++i, --range)\n                if (range > 0 && rn2(range) < limit) {\n                    context.novel.pasg[idx++] = (xchar) (i + 1);\n                    --limit;\n                }\n        }\n    }\n\n    idx = rn2(context.novel.count);\n    res = (int) context.novel.pasg[idx];\n    /* move the last slot's passage index into the slot just used\n       and reduce the number of passages available */\n    context.novel.pasg[idx] = context.novel.pasg[--context.novel.count];\n    return res;\n}\n\n/* Returns True if you were able to read something. */\nboolean\nread_tribute(tribsection, tribtitle, tribpassage, nowin_buf, bufsz, oid)\nconst char *tribsection, *tribtitle;\nint tribpassage, bufsz;\nchar *nowin_buf;\nunsigned oid; /* book identifier */\n{\n    dlb *fp;\n    char line[BUFSZ], lastline[BUFSZ];\n\n    int scope = 0;\n    int linect = 0, passagecnt = 0, targetpassage = 0;\n    const char *badtranslation = \"an incomprehensible foreign translation\";\n    boolean matchedsection = FALSE, matchedtitle = FALSE;\n    winid tribwin = WIN_ERR;\n    boolean grasped = FALSE;\n    boolean foundpassage = FALSE;\n\n    if (nowin_buf)\n        *nowin_buf = '\\0';\n\n    /* check for mandatories */\n    if (!tribsection || !tribtitle) {\n        if (!nowin_buf)\n            pline(\"It's %s of \\\"%s\\\"!\", badtranslation, tribtitle);\n        return grasped;\n    }\n\n    debugpline3(\"read_tribute %s, %s, %d.\", tribsection, tribtitle,\n                tribpassage);\n\n    fp = dlb_fopen(TRIBUTEFILE, \"r\");\n    if (!fp) {\n        /* this is actually an error - cannot open tribute file! */\n        if (!nowin_buf)\n            pline(\"You feel too overwhelmed to continue!\");\n        return grasped;\n    }\n\n    /*\n     * Syntax (not case-sensitive):\n     *  %section books\n     *\n     * In the books section:\n     *    %title booktitle (n)\n     *          where booktitle=book title without quotes\n     *          (n)= total number of passages present for this title\n     *    %passage k\n     *          where k=sequential passage number\n     *\n     * %e ends the passage/book/section\n     *    If in a passage, it marks the end of that passage.\n     *    If in a book, it marks the end of that book.\n     *    If in a section, it marks the end of that section.\n     *\n     *  %section death\n     */\n\n    *line = *lastline = '\\0';\n    while (dlb_fgets(line, sizeof line, fp) != 0) {\n        linect++;\n        (void) strip_newline(line);\n        switch (line[0]) {\n        case '%':\n            if (!strncmpi(&line[1], \"section \", sizeof \"section \" - 1)) {\n                char *st = &line[9]; /* 9 from \"%section \" */\n\n                scope = SECTIONSCOPE;\n                matchedsection = !strcmpi(st, tribsection) ? TRUE : FALSE;\n            } else if (!strncmpi(&line[1], \"title \", sizeof \"title \" - 1)) {\n                char *st = &line[7]; /* 7 from \"%title \" */\n                char *p1, *p2;\n\n                if ((p1 = index(st, '(')) != 0) {\n                    *p1++ = '\\0';\n                    (void) mungspaces(st);\n                    if ((p2 = index(p1, ')')) != 0) {\n                        *p2 = '\\0';\n                        passagecnt = atoi(p1);\n                        scope = TITLESCOPE;\n                        if (matchedsection && !strcmpi(st, tribtitle)) {\n                            matchedtitle = TRUE;\n                            targetpassage = !tribpassage\n                                             ? choose_passage(passagecnt, oid)\n                                             : (tribpassage <= passagecnt)\n                                                ? tribpassage : 0;\n                        } else {\n                            matchedtitle = FALSE;\n                        }\n                    }\n                }\n            } else if (!strncmpi(&line[1], \"passage \",\n                                 sizeof \"passage \" - 1)) {\n                int passagenum = 0;\n                char *st = &line[9]; /* 9 from \"%passage \" */\n\n                mungspaces(st);\n                passagenum = atoi(st);\n                if (passagenum > 0 && passagenum <= passagecnt) {\n                    scope = PASSAGESCOPE;\n                    if (matchedtitle && passagenum == targetpassage) {\n                        foundpassage = TRUE;\n                        if (!nowin_buf) {\n                            tribwin = create_nhwindow(NHW_MENU);\n                            if (tribwin == WIN_ERR)\n                                goto cleanup;\n                        }\n                    }\n                }\n            } else if (!strncmpi(&line[1], \"e \", sizeof \"e \" - 1)) {\n                if (foundpassage)\n                    goto cleanup;\n                if (scope == TITLESCOPE)\n                    matchedtitle = FALSE;\n                if (scope == SECTIONSCOPE)\n                    matchedsection = FALSE;\n                if (scope)\n                    --scope;\n            } else {\n                debugpline1(\"tribute file error: bad %% command, line %d.\",\n                            linect);\n            }\n            break;\n        case '#':\n            /* comment only, next! */\n            break;\n        default:\n            if (foundpassage) {\n                if (!nowin_buf) {\n                    /* outputting multi-line passage to text window */\n                    putstr(tribwin, 0, line);\n                    if (*line)\n                        Strcpy(lastline, line);\n                } else {\n                    /* fetching one-line passage into buffer */\n                    copynchars(nowin_buf, line, bufsz - 1);\n                    goto cleanup; /* don't wait for \"%e passage\" */\n                }\n            }\n        }\n    }\n\n cleanup:\n    (void) dlb_fclose(fp);\n    if (nowin_buf) {\n        /* one-line buffer */\n        grasped = *nowin_buf ? TRUE : FALSE;\n    } else {\n        if (tribwin != WIN_ERR) { /* implies 'foundpassage' */\n            /* multi-line window, normal case;\n               if lastline is empty, there were no non-empty lines between\n               \"%passage n\" and \"%e passage\" so we leave 'grasped' False */\n            if (*lastline) {\n                display_nhwindow(tribwin, FALSE);\n                /* put the final attribution line into message history,\n                   analogous to the summary line from long quest messages */\n                if (index(lastline, '['))\n                    mungspaces(lastline); /* to remove leading spaces */\n                else /* construct one if necessary */\n                    Sprintf(lastline, \"[%s, by Terry Pratchett]\", tribtitle);\n                putmsghistory(lastline, FALSE);\n                grasped = TRUE;\n            }\n            destroy_nhwindow(tribwin);\n        }\n        if (!grasped)\n            /* multi-line window, problem */\n            pline(\"It seems to be %s of \\\"%s\\\"!\", badtranslation, tribtitle);\n    }\n    return grasped;\n}\n\nboolean\nDeath_quote(buf, bufsz)\nchar *buf;\nint bufsz;\n{\n    unsigned death_oid = 1; /* chance of oid #1 being a novel is negligible */\n\n    return read_tribute(\"Death\", \"Death Quotes\", 0, buf, bufsz, death_oid);\n}\n\n/* ----------  END TRIBUTE ----------- */\n\n/*files.c*/\n"], "filenames": ["src/files.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [3164], "fixing_code_start_loc": [1], "fixing_code_end_loc": [3165], "type": "CWE-120", "message": "NetHack 3.6.x before 3.6.4 is prone to a buffer overflow vulnerability when reading very long lines from configuration files. This affects systems that have NetHack installed suid/sgid, and shared systems that allow users to upload their own configuration files.", "other": {"cve": {"id": "CVE-2019-19905", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-19T18:15:12.647", "lastModified": "2019-12-27T18:00:37.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NetHack 3.6.x before 3.6.4 is prone to a buffer overflow vulnerability when reading very long lines from configuration files. This affects systems that have NetHack installed suid/sgid, and shared systems that allow users to upload their own configuration files."}, {"lang": "es", "value": "NetHack 3.6.x anterior a la versi\u00f3n  de 3.6.4 es propenso a una vulnerabilidad de desbordamiento de b\u00fafer al leer l\u00edneas muy largas de archivos de configuraci\u00f3n. Esto afecta los sistemas que tienen NetHack instalado suid / sgid y los sistemas compartidos que permiten a los usuarios cargar sus propios archivos de configuraci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nethack:nethack:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.6.0", "versionEndExcluding": "3.6.4", "matchCriteriaId": "21916598-6BD2-411E-AE14-65470AD56570"}]}]}], "references": [{"url": "https://bugs.debian.org/947005", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/NetHack/NetHack/commit/f001de79542b8c38b1f8e6d7eaefbbd28ab94b47", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/NetHack/NetHack/security/advisories/GHSA-3cm7-rgh5-9pq5", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://nethack.org/security/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/NetHack/NetHack/commit/f001de79542b8c38b1f8e6d7eaefbbd28ab94b47"}}