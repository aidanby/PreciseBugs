{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/tools.h>\n#include <gpac/network.h>\n\n#if defined(_WIN32_WCE)\n\n#include <winbase.h>\n#include <winsock.h>\n#include <tlhelp32.h>\n//#include <direct.h>\n\n#if !defined(__GNUC__)\n#pragma comment(lib, \"toolhelp\")\n#endif\n\n#elif defined(WIN32)\n\n#include <time.h>\n#include <sys/timeb.h>\n#include <io.h>\n#include <windows.h>\n#include <tlhelp32.h>\n#include <direct.h>\n\n#if !defined(__GNUC__)\n#pragma comment(lib, \"winmm\")\n#endif\n\n#else\n\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/resource.h>\n\n#ifndef __BEOS__\n#include <errno.h>\n#endif\n\n#define SLEEP_ABS_SELECT\t\t1\n\nstatic u32 sys_start_time = 0;\nstatic u64 sys_start_time_hr = 0;\n#endif\n\n\n#ifndef _WIN32_WCE\n#include <locale.h>\n#endif\n\n\n#ifndef WIN32\n\nGF_EXPORT\nu32 gf_sys_clock()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (u32) ( ( (now.tv_sec)*1000 + (now.tv_usec) / 1000) - sys_start_time );\n}\n\nGF_EXPORT\nu64 gf_sys_clock_high_res()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (now.tv_sec)*1000000 + (now.tv_usec) - sys_start_time_hr;\n}\n\n#endif\n\n\n\nGF_EXPORT\nvoid gf_sleep(u32 ms)\n{\n#ifdef WIN32\n\tSleep(ms);\n#else\n\ts32 sel_err;\n\tstruct timeval tv;\n\n#ifndef SLEEP_ABS_SELECT\n\tu32 prev, now, elapsed;\n#endif\n\n#ifdef SLEEP_ABS_SELECT\n\ttv.tv_sec = ms/1000;\n\ttv.tv_usec = (ms%1000)*1000;\n#else\n\tprev = gf_sys_clock();\n#endif\n\n\tdo {\n\t\terrno = 0;\n\n#ifndef SLEEP_ABS_SELECT\n\t\tnow = gf_sys_clock();\n\t\telapsed = (now - prev);\n\t\tif ( elapsed >= ms ) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = now;\n\t\tms -= elapsed;\n\t\ttv.tv_sec = ms/1000;\n\t\ttv.tv_usec = (ms%1000)*1000;\n#endif\n\n\t\tsel_err = select(0, NULL, NULL, NULL, &tv);\n\t} while ( sel_err && (errno == EINTR) );\n#endif\n}\n\n#ifndef gettimeofday\n#ifdef _WIN32_WCE\n\n#include <time.h>\n//#include <wce_time.h>\n\n/*\n * Author of first version (timeval.h): by Wu Yongwei\n * Author of Windows CE version: Mateusz Loskot (mateusz@loskot.net)\n *\n * All code here is considered in the public domain though we do wish our names\n * could be retained if anyone uses them.\n */\n\n/*\n * Constants used internally by time functions.\n */\n\n#ifndef _TM_DEFINED\nstruct tm\n{\n\tint tm_sec;     /* seconds after the minute - [0,59] */\n\tint tm_min;     /* minutes after the hour - [0,59] */\n\tint tm_hour;\t/* hours since midnight - [0,23] */\n\tint tm_mday;\t/* day of the month - [1,31] */\n\tint tm_mon;     /* months since January - [0,11] */\n\tint tm_year;\t/* years since 1900 */\n\tint tm_wday;\t/* days since Sunday - [0,6] */\n\tint tm_yday;\t/* days since January 1 - [0,365] */\n\tint tm_isdst;\t/* daylight savings time flag */\n};\n#define _TM_DEFINED\n#endif /* _TM_DEFINED */\n\n#ifndef _TIMEZONE_DEFINED\nstruct timezone\n{\n\tint tz_minuteswest; /* minutes W of Greenwich */\n\tint tz_dsttime;     /* type of dst correction */\n};\n#define _TIMEZONE_DEFINED\n#endif /* _TIMEZONE_DEFINED */\n\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n#define EPOCHFILETIME (116444736000000000i64)\n#else\n#define EPOCHFILETIME (116444736000000000LL)\n#endif\n\nint gettimeofday(struct timeval *tp, struct timezone *tzp)\n{\n\tSYSTEMTIME      st;\n\tFILETIME        ft;\n\tLARGE_INTEGER   li;\n\tTIME_ZONE_INFORMATION tzi;\n\t__int64         t;\n\tstatic int      tzflag;\n\n\tif (NULL != tp)\n\t{\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &ft);\n\t\tli.LowPart  = ft.dwLowDateTime;\n\t\tli.HighPart = ft.dwHighDateTime;\n\t\tt  = li.QuadPart;       /* In 100-nanosecond intervals */\n\t\tt -= EPOCHFILETIME;     /* Offset to the Epoch time */\n\t\tt /= 10;                /* In microseconds */\n\t\ttp->tv_sec  = (long)(t / 1000000);\n\t\ttp->tv_usec = (long)(t % 1000000);\n\t}\n\n\tif (NULL != tzp)\n\t{\n\t\tGetTimeZoneInformation(&tzi);\n\n\t\ttzp->tz_minuteswest = tzi.Bias;\n\t\tif (tzi.StandardDate.wMonth != 0)\n\t\t{\n\t\t\ttzp->tz_minuteswest += tzi.StandardBias * 60;\n\t\t}\n\n\t\tif (tzi.DaylightDate.wMonth != 0)\n\t\t{\n\t\t\ttzp->tz_dsttime = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttzp->tz_dsttime = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if _GPAC_UNUSED\n/*\n\ttime between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds\n\tFILETIME in Win32 is from jan 1, 1601\n*/\n\ns32 __gettimeofday(struct timeval *tp, void *tz)\n{\n\tFILETIME ft;\n\tSYSTEMTIME st;\n\ts32 val;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\n\tval = (s32) ((*(LONGLONG *) &ft - TIMESPEC_TO_FILETIME_OFFSET) / 10000000);\n\ttp->tv_sec = (u32) val;\n\tval = (s32 ) ((*(LONGLONG *) &ft - TIMESPEC_TO_FILETIME_OFFSET - ((LONGLONG) val * (LONGLONG) 10000000)) * 100);\n\ttp->tv_usec = val;\n\treturn 0;\n}\n#endif\n\n\n#elif defined(WIN32)\n\nstatic s32 gettimeofday(struct timeval *tp, void *tz)\n{\n\tstruct _timeb timebuffer;\n\n\t_ftime( &timebuffer );\n\ttp->tv_sec  = (long) (timebuffer.time);\n\ttp->tv_usec = timebuffer.millitm * 1000;\n\treturn 0;\n}\n#endif\n\n#endif\n\n#ifdef _WIN32_WCE\n\nvoid CE_Assert(u32 valid, char *file, u32 line)\n{\n\tif (!valid) {\n\t\tchar szBuf[2048];\n\t\tu16 wcBuf[2048];\n\t\tsprintf(szBuf, \"File %s : line %d\", file, line);\n\t\tCE_CharToWide(szBuf, wcBuf);\n\t\tMessageBox(NULL, wcBuf, _T(\"GPAC Assertion Failure\"), MB_OK);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}\n\nvoid CE_CharToWide(char *str, unsigned short *w_str)\n{\n\tMultiByteToWideChar(CP_ACP, 0, str, -1, w_str, GF_MAX_PATH);\n}\n\n\n#endif\n\nGF_EXPORT\nvoid gf_rand_init(Bool Reset)\n{\n\tif (Reset) {\n\t\tsrand(1);\n\t} else {\n#if defined(_WIN32_WCE)\n\t\tsrand( (u32) GetTickCount() );\n#else\n\t\tsrand( (u32) time(NULL) );\n#endif\n\t}\n}\n\nGF_EXPORT\nu32 gf_rand()\n{\n\treturn rand();\n}\n\n#ifndef _WIN32_WCE\n#include <sys/stat.h>\n#endif\n\nGF_EXPORT\nvoid gf_utc_time_since_1970(u32 *sec, u32 *msec)\n{\n#if defined (WIN32) && !defined(_WIN32_WCE)\n\tstruct _timeb\ttb;\n\t_ftime( &tb );\n\t*sec = (u32) tb.time;\n\t*msec = tb.millitm;\n#else\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\t*sec = (u32) tv.tv_sec;\n\t*msec = tv.tv_usec/1000;\n#endif\n}\n\nGF_EXPORT\nvoid gf_get_user_name(char *buf, u32 buf_size)\n{\n\tstrcpy(buf, \"mpeg4-user\");\n\n#if 0\n\ts32 len;\n\tchar *t;\n\tstrcpy(buf, \"\");\n\tlen = 1024;\n\tGetUserName(buf, &len);\n\tif (!len) {\n\t\tt = getenv(\"USER\");\n\t\tif (t) strcpy(buf, t);\n\t}\n#endif\n#if 0\n\tstruct passwd *pw;\n\tpw = getpwuid(getuid());\n\tstrcpy(buf, \"\");\n\tif (pw && pw->pw_name) strcpy(name, pw->pw_name);\n#endif\n}\n\n\n#ifndef WIN32\nGF_EXPORT\nchar * my_str_upr(char *str)\n{\n\tu32 i;\n\tfor (i=0; i<strlen(str); i++) {\n\t\tstr[i] = toupper(str[i]);\n\t}\n\treturn str;\n}\n\nGF_EXPORT\nchar * my_str_lwr(char *str)\n{\n\tu32 i;\n\tfor (i=0; i<strlen(str); i++) {\n\t\tstr[i] = tolower(str[i]);\n\t}\n\treturn str;\n}\n#endif\n\n/*seems OK under mingw also*/\n#ifdef WIN32\n#ifdef _WIN32_WCE\n\nBool gf_prompt_has_input()\n{\n\treturn 0;\n}\nchar gf_prompt_get_char() {\n\treturn 0;\n}\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off) {\n\treturn;\n}\n\n#else\n\n#include <conio.h>\n#include <windows.h>\n\nBool gf_prompt_has_input()\n{\n\treturn kbhit();\n}\n\nchar gf_prompt_get_char()\n{\n\treturn getchar();\n}\n\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off)\n{\n\tDWORD flags;\n\tHANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);\n\tBOOL ret = GetConsoleMode(hStdin, &flags);\n\tif (!ret) {\n\t\tDWORD err = GetLastError();\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"[Console] GetConsoleMode() return with the following error code: %d\\n\", err));\n\t}\n\tif (echo_off) flags &= ~ENABLE_ECHO_INPUT;\n\telse flags |= ENABLE_ECHO_INPUT;\n\tSetConsoleMode(hStdin, flags);\n}\n#endif\n#else\n/*linux kbhit/getchar- borrowed on debian mailing lists, (author Mike Brownlow)*/\n#include <termios.h>\n\nstatic struct termios t_orig, t_new;\nstatic s32 ch_peek = -1;\n\nstatic void init_keyboard()\n{\n\ttcgetattr(0, &t_orig);\n\tt_new = t_orig;\n\tt_new.c_lflag &= ~ICANON;\n\tt_new.c_lflag &= ~ECHO;\n\tt_new.c_lflag &= ~ISIG;\n\tt_new.c_cc[VMIN] = 1;\n\tt_new.c_cc[VTIME] = 0;\n\ttcsetattr(0, TCSANOW, &t_new);\n}\nstatic void close_keyboard(Bool new_line)\n{\n\ttcsetattr(0,TCSANOW, &t_orig);\n\tif (new_line) fprintf(stderr, \"\\n\");\n}\n\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off)\n{\n\tinit_keyboard();\n\tif (echo_off) t_orig.c_lflag &= ~ECHO;\n\telse t_orig.c_lflag |= ECHO;\n\tclose_keyboard(0);\n}\n\nGF_EXPORT\nBool gf_prompt_has_input()\n{\n\tu8 ch;\n\ts32 nread;\n\tpid_t fg = tcgetpgrp(STDIN_FILENO);\n\n\t//we are not foreground nor piped (used for IDEs), can't read stdin\n\tif ((fg!=-1) && (fg != getpgrp())) {\n\t\treturn 0;\n\t}\n\tinit_keyboard();\n\tif (ch_peek != -1) return 1;\n\tt_new.c_cc[VMIN]=0;\n\ttcsetattr(0, TCSANOW, &t_new);\n\tnread = (s32) read(0, &ch, 1);\n\tt_new.c_cc[VMIN]=1;\n\ttcsetattr(0, TCSANOW, &t_new);\n\tif(nread == 1) {\n\t\tch_peek = ch;\n\t\treturn 1;\n\t}\n\tclose_keyboard(0);\n\treturn 0;\n}\n\nGF_EXPORT\nchar gf_prompt_get_char()\n{\n\tchar ch;\n\tif (ch_peek != -1) {\n\t\tch = ch_peek;\n\t\tch_peek = -1;\n\t\tclose_keyboard(1);\n\t\treturn ch;\n\t}\n\tif (0==read(0,&ch,1))\n\t\tch = 0;\n\tclose_keyboard(1);\n\treturn ch;\n}\n\n#endif\n\n\nstatic u32 sys_init = 0;\nstatic u32 last_update_time = 0;\nstatic u64 last_process_k_u_time = 0;\nGF_SystemRTInfo the_rti;\n\n\n#if defined(_WIN32_WCE)\nstatic LARGE_INTEGER frequency , init_counter;\nstatic u64 last_total_k_u_time = 0;\nstatic u32 mem_usage_at_startup = 0;\n\n\n#ifndef GetCurrentPermissions\nDWORD GetCurrentPermissions();\n#endif\n#ifndef SetProcPermissions\nvoid SetProcPermissions(DWORD );\n#endif\n\n#elif defined(WIN32)\nstatic LARGE_INTEGER frequency , init_counter;\nstatic u64 last_proc_idle_time = 0;\nstatic u64 last_proc_k_u_time = 0;\n\nstatic HINSTANCE psapi_hinst = NULL;\ntypedef BOOL(WINAPI* NTGetSystemTimes)(VOID *,VOID *,VOID *);\nNTGetSystemTimes MyGetSystemTimes = NULL;\ntypedef BOOL(WINAPI* NTGetProcessMemoryInfo)(HANDLE,VOID *,DWORD);\nNTGetProcessMemoryInfo MyGetProcessMemoryInfo = NULL;\ntypedef int(WINAPI* NTQuerySystemInfo)(ULONG,PVOID,ULONG,PULONG);\nNTQuerySystemInfo MyQuerySystemInfo = NULL;\n\n#ifndef PROCESS_MEMORY_COUNTERS\ntypedef struct _PROCESS_MEMORY_COUNTERS\n{\n\tDWORD cb;\n\tDWORD PageFaultCount;\n\tSIZE_T PeakWorkingSetSize;\n\tSIZE_T WorkingSetSize;\n\tSIZE_T QuotaPeakPagedPoolUsage;\n\tSIZE_T QuotaPagedPoolUsage;\n\tSIZE_T QuotaPeakNonPagedPoolUsage;\n\tSIZE_T QuotaNonPagedPoolUsage;\n\tSIZE_T PagefileUsage;\n\tSIZE_T PeakPagefileUsage;\n} PROCESS_MEMORY_COUNTERS;\n#endif\n\n#ifndef SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\ntypedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\n{\n\tLARGE_INTEGER IdleTime;\n\tLARGE_INTEGER KernelTime;\n\tLARGE_INTEGER UserTime;\n\tLARGE_INTEGER Reserved1[2];\n\tULONG Reserved2;\n} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;\n#endif\n\n\n#else\n\nstatic u64 last_cpu_u_k_time = 0;\nstatic u64 last_cpu_idle_time = 0;\nstatic u64 mem_at_startup = 0;\n\n#endif\n\n#ifdef WIN32\nstatic u32 (*OS_GetSysClock)();\n\nu32 gf_sys_clock()\n{\n\treturn OS_GetSysClock();\n}\n\n\nstatic u64 (*OS_GetSysClockHR)();\nu64 gf_sys_clock_high_res()\n{\n\treturn OS_GetSysClockHR();\n}\n#endif\n\n\n#ifdef WIN32\n\nstatic u32 OS_GetSysClockHIGHRES()\n{\n\tLARGE_INTEGER now;\n\tQueryPerformanceCounter(&now);\n\tnow.QuadPart -= init_counter.QuadPart;\n\treturn (u32) ((now.QuadPart * 1000) / frequency.QuadPart);\n}\n\nstatic u64 OS_GetSysClockHIGHRES_FULL()\n{\n\tLARGE_INTEGER now;\n\tQueryPerformanceCounter(&now);\n\tnow.QuadPart -= init_counter.QuadPart;\n\treturn (u64) ((now.QuadPart * 1000000) / frequency.QuadPart);\n}\n\nstatic u32 OS_GetSysClockNORMAL()\n{\n#ifdef _WIN32_WCE\n\treturn GetTickCount();\n#else\n\treturn timeGetTime();\n#endif\n}\n\nstatic u64 OS_GetSysClockNORMAL_FULL()\n{\n\tu64 res = OS_GetSysClockNORMAL();\n\treturn res*1000;\n}\n\n#endif /* WIN32 */\n\n#if defined(__sh__)\n/* Avoid exception for denormalized floating point values */\nstatic int\nsh4_get_fpscr()\n{\n\tint ret;\n\tasm volatile (\"sts fpscr,%0\" : \"=r\" (ret));\n\treturn ret;\n}\n\nstatic void\nsh4_put_fpscr(int nv)\n{\n\tasm volatile (\"lds %0,fpscr\" : : \"r\" (nv));\n}\n\n#define SH4_FPSCR_FR 0x00200000\n#define SH4_FPSCR_SZ 0x00100000\n#define SH4_FPSCR_PR 0x00080000\n#define SH4_FPSCR_DN 0x00040000\n#define SH4_FPSCR_RN 0x00000003\n#define SH4_FPSCR_RN_N 0\n#define SH4_FPSCR_RN_Z 1\n\nextern int __fpscr_values[2];\n\nvoid\nsh4_change_fpscr(int off, int on)\n{\n\tint b = sh4_get_fpscr();\n\toff = ~off;\n\toff |=   0x00180000;\n\ton  &= ~ 0x00180000;\n\tb &= off;\n\tb |= on;\n\tsh4_put_fpscr(b);\n\t__fpscr_values[0] &= off;\n\t__fpscr_values[0] |= on;\n\t__fpscr_values[1] &= off;\n\t__fpscr_values[1] |= on;\n}\n\n#endif\n\n#ifdef GPAC_MEMORY_TRACKING\nvoid gf_mem_enable_tracker(Bool enable_backtrace);\n#endif\n\nstatic u64 memory_at_gpac_startup = 0;\n\nstatic u32 gpac_argc = 0;\nconst char **gpac_argv = NULL;\n\nGF_EXPORT\nvoid gf_sys_set_args(s32 argc, const char **argv)\n{\n\t//for OSX we allow overwrite of argc/argv due to different behavior between console-mode apps and GUI\n#if !defined(__DARWIN__) && !defined(__APPLE__)\n\tif (!gpac_argc && (argc>=0) )\n#endif\n\t{\n\t\tgpac_argc = (u32) argc;\n\t\tgpac_argv = argv;\n\t}\n}\nGF_EXPORT\nu32 gf_sys_get_argc()\n{\n\treturn gpac_argc;\n}\n\nGF_EXPORT\nconst char *gf_sys_get_arg(u32 arg)\n{\n\tif (!gpac_argc || !gpac_argv) return NULL;\n\tif (arg>=gpac_argc) return NULL;\n\treturn gpac_argv[arg];\n}\n\n\nGF_EXPORT\nvoid gf_sys_init(GF_MemTrackerType mem_tracker_type)\n{\n\tif (!sys_init) {\n#if defined (WIN32)\n#if defined(_WIN32_WCE)\n\t\tMEMORYSTATUS ms;\n#else\n\t\tSYSTEM_INFO sysinfo;\n#endif\n#endif\n\n\t\tif (mem_tracker_type!=GF_MemTrackerNone) {\n#ifdef GPAC_MEMORY_TRACKING\n            gf_mem_enable_tracker( (mem_tracker_type==GF_MemTrackerBackTrace) ? GF_TRUE : GF_FALSE);\n#endif\n\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\t/*by default log subsystem is initialized to error on all tools, and info on console to debug scripts*/\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_ERROR);\n\t\tgf_log_set_tool_level(GF_LOG_CONSOLE, GF_LOG_INFO);\n#endif\n\n\n#if defined(__sh__)\n\t\t/* Round all denormalized floatting point number to 0.0 */\n\t\tsh4_change_fpscr(0,SH4_FPSCR_DN) ;\n#endif\n\n#if defined(WIN32)\n\t\tfrequency.QuadPart = 0;\n\t\t/*clock setup*/\n\t\tif (QueryPerformanceFrequency(&frequency)) {\n\t\t\tQueryPerformanceCounter(&init_counter);\n\t\t\tOS_GetSysClock = OS_GetSysClockHIGHRES;\n\t\t\tOS_GetSysClockHR = OS_GetSysClockHIGHRES_FULL;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] using WIN32 performance timer\\n\"));\n\t\t} else {\n\t\t\tOS_GetSysClock = OS_GetSysClockNORMAL;\n\t\t\tOS_GetSysClockHR = OS_GetSysClockNORMAL_FULL;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] using WIN32 regular timer\\n\"));\n\t\t}\n\n#ifndef _WIN32_WCE\n\t\ttimeBeginPeriod(1);\n#endif\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] checking for run-time info tools\"));\n#if defined(_WIN32_WCE)\n\t\tlast_total_k_u_time = last_process_k_u_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = GetCurrentProcessId();\n\t\tthe_rti.nb_cores = 1;\n\t\tGlobalMemoryStatus(&ms);\n\t\tmem_usage_at_startup = ms.dwAvailPhys;\n#else\n\t\t/*cpu usage tools are buried in win32 dlls...*/\n\t\tMyGetSystemTimes = (NTGetSystemTimes) GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"GetSystemTimes\");\n\t\tif (!MyGetSystemTimes) {\n\t\t\tMyQuerySystemInfo = (NTQuerySystemInfo) GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"NtQuerySystemInformation\");\n\t\t\tif (MyQuerySystemInfo) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - CPU: QuerySystemInformation\"));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - CPU: GetSystemsTimes\"));\n\t\t}\n\t\tpsapi_hinst = LoadLibrary(\"psapi.dll\");\n\t\tMyGetProcessMemoryInfo = (NTGetProcessMemoryInfo) GetProcAddress(psapi_hinst, \"GetProcessMemoryInfo\");\n\t\tif (MyGetProcessMemoryInfo) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - memory: GetProcessMemoryInfo\"));\n\t\t}\n\t\tlast_process_k_u_time = last_proc_idle_time = last_proc_k_u_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = GetCurrentProcessId();\n\n\t\tGetSystemInfo( &sysinfo );\n\t\tthe_rti.nb_cores = sysinfo.dwNumberOfProcessors;\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"\\n\"));\n\n#else\n\t\t/*linux threads and OSX...*/\n\t\tlast_process_k_u_time = 0;\n\t\tlast_cpu_u_k_time = last_cpu_idle_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = getpid();\n\t\tthe_rti.nb_cores = (u32) sysconf( _SC_NPROCESSORS_ONLN );\n\t\tsys_start_time = gf_sys_clock();\n\t\tsys_start_time_hr = gf_sys_clock_high_res();\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] process id %d\\n\", the_rti.pid));\n\n#ifndef _WIN32_WCE\n\t\tsetlocale( LC_NUMERIC, \"C\" );\n#endif\n\t}\n\tsys_init += 1;\n\n\n\t/*init RTI stats*/\n\tif (!memory_at_gpac_startup) {\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(500, &rti, GF_RTI_SYSTEM_MEMORY_ONLY)) {\n\t\t\tmemory_at_gpac_startup = rti.physical_memory_avail;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] System init OK - process id %d - %d MB physical RAM - %d cores\\n\", rti.pid, (u32) (rti.physical_memory/1024/1024), rti.nb_cores));\n\t\t} else {\n\t\t\tmemory_at_gpac_startup = 0;\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_sys_close()\n{\n\tif (sys_init > 0) {\n\t\tsys_init --;\n\t\tif (sys_init) return;\n\t\t/*prevent any call*/\n\t\tlast_update_time = 0xFFFFFFFF;\n\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\t\ttimeEndPeriod(1);\n\n\t\tMyGetSystemTimes = NULL;\n\t\tMyGetProcessMemoryInfo = NULL;\n\t\tMyQuerySystemInfo = NULL;\n\t\tif (psapi_hinst) FreeLibrary(psapi_hinst);\n\t\tpsapi_hinst = NULL;\n#endif\n\t}\n}\n\n#ifdef GPAC_MEMORY_TRACKING\nextern size_t gpac_allocated_memory;\nextern size_t gpac_nb_alloc_blocs;\n#endif\n\n/*CPU and Memory Usage*/\n#ifdef WIN32\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n#if defined(_WIN32_WCE)\n\tTHREADENTRY32 tentry;\n\tu64 total_cpu_time, process_cpu_time;\n\tDWORD orig_perm;\n#endif\n\tMEMORYSTATUS ms;\n\tu64 creation, exit, kernel, user, process_k_u_time, proc_idle_time, proc_k_u_time;\n\tu32 entry_time;\n\tHANDLE hSnapShot;\n\n\tassert(sys_init);\n\n\tif (!rti) return GF_FALSE;\n\n\tproc_idle_time = proc_k_u_time = process_k_u_time = 0;\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn GF_FALSE;\n\t}\n\n\tif (flags & GF_RTI_SYSTEM_MEMORY_ONLY) {\n\t\tmemset(rti, 0, sizeof(GF_SystemRTInfo));\n\t\trti->sampling_instant = last_update_time;\n\t\tGlobalMemoryStatus(&ms);\n\t\trti->physical_memory = ms.dwTotalPhys;\n\t\trti->physical_memory_avail = ms.dwAvailPhys;\n#ifdef GPAC_MEMORY_TRACKING\n\t\trti->gpac_memory = (u64) gpac_allocated_memory;\n#endif\n\t\treturn GF_TRUE;\n\t}\n\n#if defined (_WIN32_WCE)\n\n\ttotal_cpu_time = process_cpu_time = 0;\n\n\t/*get a snapshot of all running threads*/\n\torig_perm = GetCurrentPermissions();\n\tSetProcPermissions(0xFFFFFFFF);\n\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n\tif (hSnapShot) {\n\t\ttentry.dwSize = sizeof(THREADENTRY32);\n\t\tthe_rti.thread_count = 0;\n\t\t/*note we always act as if GF_RTI_ALL_PROCESSES_TIMES flag is set, since there is no other way\n\t\tto enumerate threads from a process, and GetProcessTimes doesn't exist on CE*/\n\t\tif (Thread32First(hSnapShot, &tentry)) {\n\t\t\tdo {\n\t\t\t\t/*get thread times*/\n\t\t\t\tif (GetThreadTimes( (HANDLE) tentry.th32ThreadID, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user)) {\n\t\t\t\t\ttotal_cpu_time += user + kernel;\n\t\t\t\t\tif (tentry.th32OwnerProcessID==the_rti.pid) {\n\t\t\t\t\t\tprocess_cpu_time += user + kernel;\n\t\t\t\t\t\tthe_rti.thread_count ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (Thread32Next(hSnapShot, &tentry));\n\t\t}\n\t\tCloseToolhelp32Snapshot(hSnapShot);\n\t}\n\n\tif (flags & GF_RTI_PROCESS_MEMORY) {\n\t\tHEAPLIST32 hlentry;\n\t\tHEAPENTRY32 hentry;\n\t\tthe_rti.process_memory = 0;\n\t\thlentry.dwSize = sizeof(HEAPLIST32);\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, the_rti.pid);\n\t\tif (hSnapShot && Heap32ListFirst(hSnapShot, &hlentry)) {\n\t\t\tdo {\n\t\t\t\thentry.dwSize = sizeof(hentry);\n\t\t\t\tif (Heap32First(hSnapShot, &hentry, hlentry.th32ProcessID, hlentry.th32HeapID)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tthe_rti.process_memory += hentry.dwBlockSize;\n\t\t\t\t\t} while (Heap32Next(hSnapShot, &hentry));\n\t\t\t\t}\n\t\t\t} while (Heap32ListNext(hSnapShot, &hlentry));\n\t\t}\n\t\tCloseToolhelp32Snapshot(hSnapShot);\n\t}\n\tSetProcPermissions(orig_perm);\n\ttotal_cpu_time /= 10;\n\tprocess_cpu_time /= 10;\n\n#else\n\t/*XP-SP1 and Win2003 servers only have GetSystemTimes support. This will give a better estimation\n\tof CPU usage since we can take into account the idle time*/\n\tif (MyGetSystemTimes) {\n\t\tu64 u_time;\n\t\tMyGetSystemTimes(&proc_idle_time, &proc_k_u_time, &u_time);\n\t\tproc_k_u_time += u_time;\n\t\tproc_idle_time /= 10;\n\t\tproc_k_u_time /= 10;\n\t}\n\t/*same rq for NtQuerySystemInformation*/\n\telse if (MyQuerySystemInfo) {\n\t\tDWORD ret;\n\t\tSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION info;\n\t\tMyQuerySystemInfo(0x8 /*SystemProcessorPerformanceInformation*/, &info, sizeof(info), &ret);\n\t\tif (ret && (ret<=sizeof(info))) {\n\t\t\tproc_idle_time = info.IdleTime.QuadPart / 10;\n\t\t\tproc_k_u_time = (info.KernelTime.QuadPart + info.UserTime.QuadPart) / 10;\n\t\t}\n\t}\n\t/*no special API available, ONLY FETCH TIMES if requested (may eat up some time)*/\n\telse if (flags & GF_RTI_ALL_PROCESSES_TIMES) {\n\t\tPROCESSENTRY32 pentry;\n\t\t/*get a snapshot of all running threads*/\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t\tif (!hSnapShot) return GF_FALSE;\n\t\tpentry.dwSize = sizeof(PROCESSENTRY32);\n\t\tif (Process32First(hSnapShot, &pentry)) {\n\t\t\tdo {\n\t\t\t\tHANDLE procH = NULL;\n\t\t\t\tif (pentry.th32ProcessID) procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pentry.th32ProcessID);\n\t\t\t\tif (procH && GetProcessTimes(procH, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user) ) {\n\t\t\t\t\tuser += kernel;\n\t\t\t\t\tproc_k_u_time += user;\n\t\t\t\t\tif (pentry.th32ProcessID==the_rti.pid) {\n\t\t\t\t\t\tprocess_k_u_time = user;\n\t\t\t\t\t\t//nb_threads = pentry.cntThreads;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (procH) CloseHandle(procH);\n\t\t\t} while (Process32Next(hSnapShot, &pentry));\n\t\t}\n\t\tCloseHandle(hSnapShot);\n\t\tproc_k_u_time /= 10;\n\t}\n\n\n\tif (!process_k_u_time) {\n\t\tHANDLE procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, the_rti.pid);\n\t\tif (procH && GetProcessTimes(procH, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user) ) {\n\t\t\tprocess_k_u_time = user + kernel;\n\t\t}\n\t\tif (procH) CloseHandle(procH);\n\t\tif (!process_k_u_time) return GF_FALSE;\n\t}\n\tprocess_k_u_time /= 10;\n\n\t/*this won't cost a lot*/\n\tif (MyGetProcessMemoryInfo) {\n\t\tPROCESS_MEMORY_COUNTERS pmc;\n\t\tHANDLE procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, the_rti.pid);\n\t\tMyGetProcessMemoryInfo(procH, &pmc, sizeof (pmc));\n\t\tthe_rti.process_memory = pmc.WorkingSetSize;\n\t\tif (procH) CloseHandle(procH);\n\t}\n\t/*THIS IS VERY HEAVY (eats up mem and time) - only perform if requested*/\n\telse if (flags & GF_RTI_PROCESS_MEMORY) {\n\t\tHEAPLIST32 hlentry;\n\t\tHEAPENTRY32 hentry;\n\t\tthe_rti.process_memory = 0;\n\t\thlentry.dwSize = sizeof(HEAPLIST32);\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, the_rti.pid);\n\t\tif (hSnapShot && Heap32ListFirst(hSnapShot, &hlentry)) {\n\t\t\tdo {\n\t\t\t\thentry.dwSize = sizeof(hentry);\n\t\t\t\tif (Heap32First(&hentry, hlentry.th32ProcessID, hlentry.th32HeapID)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tthe_rti.process_memory += hentry.dwBlockSize;\n\t\t\t\t\t} while (Heap32Next(&hentry));\n\t\t\t\t}\n\t\t\t} while (Heap32ListNext(hSnapShot, &hlentry));\n\t\t}\n\t\tCloseHandle(hSnapShot);\n\t}\n#endif\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = entry_time - last_update_time;\n\t\tthe_rti.process_cpu_time_diff = (u32) ((process_k_u_time - last_process_k_u_time)/1000);\n\n#if defined(_WIN32_WCE)\n\t\tthe_rti.total_cpu_time_diff = (u32) ((total_cpu_time - last_total_k_u_time)/1000);\n\t\t/*we're not that accurate....*/\n\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration)\n\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\n\t\t/*rough values*/\n\t\tthe_rti.cpu_idle_time = the_rti.sampling_period_duration - the_rti.total_cpu_time_diff;\n\t\tif (!the_rti.sampling_period_duration) the_rti.sampling_period_duration=1;\n\t\tthe_rti.total_cpu_usage = (u32) (100 * the_rti.total_cpu_time_diff / the_rti.sampling_period_duration);\n\t\tif (the_rti.total_cpu_time_diff + the_rti.cpu_idle_time==0) the_rti.total_cpu_time_diff ++;\n\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / (the_rti.total_cpu_time_diff + the_rti.cpu_idle_time) );\n\n#else\n\t\t/*oops, we have no choice but to assume 100% cpu usage during this period*/\n\t\tif (!proc_k_u_time) {\n\t\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t\tproc_k_u_time = last_proc_k_u_time + the_rti.sampling_period_duration;\n\t\t\tthe_rti.cpu_idle_time = 0;\n\t\t\tthe_rti.total_cpu_usage = 100;\n\t\t\tif (the_rti.sampling_period_duration)\n\t\t\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / the_rti.sampling_period_duration);\n\t\t} else {\n\t\t\tu64 samp_sys_time, idle;\n\t\t\tthe_rti.total_cpu_time_diff = (u32) ((proc_k_u_time - last_proc_k_u_time)/1000);\n\n\t\t\t/*we're not that accurate....*/\n\t\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration) {\n\t\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\t\t\t}\n\n\t\t\tif (!proc_idle_time)\n\t\t\t\tproc_idle_time = last_proc_idle_time + (the_rti.sampling_period_duration - the_rti.total_cpu_time_diff);\n\n\t\t\tsamp_sys_time = proc_k_u_time - last_proc_k_u_time;\n\t\t\tidle = proc_idle_time - last_proc_idle_time;\n\t\t\tthe_rti.cpu_idle_time = (u32) (idle/1000);\n\t\t\tif (samp_sys_time) {\n\t\t\t\tthe_rti.total_cpu_usage = (u32) ( (samp_sys_time - idle) / (samp_sys_time / 100) );\n\t\t\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / (samp_sys_time/1000));\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tlast_update_time = entry_time;\n\tlast_process_k_u_time = process_k_u_time;\n\n\tGlobalMemoryStatus(&ms);\n\tthe_rti.physical_memory = ms.dwTotalPhys;\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = (u64) gpac_allocated_memory;\n#endif\n\tthe_rti.physical_memory_avail = ms.dwAvailPhys;\n\n#if defined(_WIN32_WCE)\n\tlast_total_k_u_time = total_cpu_time;\n\tif (!the_rti.process_memory) the_rti.process_memory = mem_usage_at_startup - ms.dwAvailPhys;\n#else\n\tlast_proc_idle_time = proc_idle_time;\n\tlast_proc_k_u_time = proc_k_u_time;\n#endif\n\n\tif (!the_rti.gpac_memory) the_rti.gpac_memory = the_rti.process_memory;\n\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn GF_TRUE;\n}\n\n\n#elif defined(GPAC_CONFIG_DARWIN) && !defined(GPAC_IPHONE)\n\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <sys/vmmeter.h>\n#include <mach/mach_init.h>\n#include <mach/mach_host.h>\n#include <mach/mach_port.h>\n#include <mach/mach_traps.h>\n#include <mach/task_info.h>\n#include <mach/thread_info.h>\n#include <mach/thread_act.h>\n#include <mach/vm_region.h>\n#include <mach/vm_map.h>\n#include <mach/task.h>\n#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060\n#include <mach/shared_region.h>\n#else\n#include <mach/shared_memory_server.h>\n#endif\n#include <mach/mach_error.h>\n\nstatic u64 total_physical_memory = 0;\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tsize_t length;\n\tu32 entry_time, i, percent;\n\tint mib[6];\n\tu64 result;\n\tint pagesize;\n\tu64 process_u_k_time;\n\tdouble utime, stime;\n\tvm_statistics_data_t vmstat;\n\ttask_t task;\n\tkern_return_t error;\n\tthread_array_t thread_table;\n\tunsigned table_size;\n\tthread_basic_info_t thi;\n\tthread_basic_info_data_t thi_data;\n\tstruct task_basic_info ti;\n\tmach_msg_type_number_t count = HOST_VM_INFO_COUNT, size = sizeof(ti);\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn 0;\n\t}\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_PAGESIZE;\n\tlength = sizeof(pagesize);\n\tif (sysctl(mib, 2, &pagesize, &length, NULL, 0) < 0) {\n\t\treturn 0;\n\t}\n\n\tif (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS) {\n\t\treturn 0;\n\t}\n\n\tthe_rti.physical_memory = (vmstat.wire_count + vmstat.active_count + vmstat.inactive_count + vmstat.free_count)* pagesize;\n\tthe_rti.physical_memory_avail = vmstat.free_count * pagesize;\n\n\tif (!total_physical_memory) {\n\t\tmib[0] = CTL_HW;\n\t\tmib[1] = HW_MEMSIZE;\n\t\tlength = sizeof(u64);\n\t\tif (sysctl(mib, 2, &result, &length, NULL, 0) >= 0) {\n\t\t\ttotal_physical_memory = result;\n\t\t}\n\t}\n\tthe_rti.physical_memory = total_physical_memory;\n\n\terror = task_for_pid(mach_task_self(), the_rti.pid, &task);\n\tif (error) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get process task for PID %d: error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\n\terror = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&ti, &size);\n\tif (error) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get process task info (PID %d): error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\n\tpercent = 0;\n\tutime = ti.user_time.seconds + ti.user_time.microseconds * 1e-6;\n\tstime = ti.system_time.seconds + ti.system_time.microseconds * 1e-6;\n\terror = task_threads(task, &thread_table, &table_size);\n\tif (error != KERN_SUCCESS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get threads task for PID %d: error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\tthi = &thi_data;\n\tfor (i = 0; i != table_size; ++i) {\n\t\tcount = THREAD_BASIC_INFO_COUNT;\n\t\terror = thread_info(thread_table[i], THREAD_BASIC_INFO, (thread_info_t)thi, &count);\n\t\tif (error != KERN_SUCCESS) {\n\t\t\tmach_error(\"[RTI] Unexpected thread_info() call return\", error);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[RTI] Unexpected thread info for PID %d\\n\", the_rti.pid));\n\t\t\tbreak;\n\t\t}\n\t\tif ((thi->flags & TH_FLAGS_IDLE) == 0) {\n\t\t\tutime += thi->user_time.seconds + thi->user_time.microseconds * 1e-6;\n\t\t\tstime += thi->system_time.seconds + thi->system_time.microseconds * 1e-6;\n\t\t\tpercent +=  (u32) (100 * (double)thi->cpu_usage / TH_USAGE_SCALE);\n\t\t}\n\t}\n\tvm_deallocate(mach_task_self(), (vm_offset_t)thread_table, table_size * sizeof(thread_array_t));\n\tmach_port_deallocate(mach_task_self(), task);\n\n\tprocess_u_k_time = utime + stime;\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = (entry_time - last_update_time);\n\t\tthe_rti.process_cpu_time_diff = (process_u_k_time - last_process_k_u_time) * 10;\n\n\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t/*TODO*/\n\t\tthe_rti.cpu_idle_time = 0;\n\t\tthe_rti.total_cpu_usage = 0;\n\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\n\t\tthe_rti.process_cpu_usage = percent;\n\t} else {\n\t\tmem_at_startup = the_rti.physical_memory_avail;\n\t}\n\tthe_rti.process_memory = mem_at_startup - the_rti.physical_memory_avail;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = gpac_allocated_memory;\n#endif\n\n\tlast_process_k_u_time = process_u_k_time;\n\tlast_cpu_idle_time = 0;\n\tlast_update_time = entry_time;\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn 1;\n}\n\n//linux\n#else\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tu32 entry_time;\n\tu64 process_u_k_time;\n\tu32 u_k_time, idle_time;\n#if 0\n\tchar szProc[100];\n#endif\n\tchar line[2048];\n\tFILE *f;\n\n\tassert(sys_init);\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn 0;\n\t}\n\n\tu_k_time = idle_time = 0;\n\tf = gf_fopen(\"/proc/stat\", \"r\");\n\tif (f) {\n\t\tu32 k_time, nice_time, u_time;\n\t\tif (fgets(line, 128, f) != NULL) {\n\t\t\tif (sscanf(line, \"cpu  %u %u %u %u\\n\", &u_time, &k_time, &nice_time, &idle_time) == 4) {\n\t\t\t\tu_k_time = u_time + k_time + nice_time;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t}\n\n\tprocess_u_k_time = 0;\n\tthe_rti.process_memory = 0;\n\n\t/*FIXME? under LinuxThreads this will only fetch stats for the calling thread, we would have to enumerate /proc to get\n\tthe complete CPU usage of all therads of the process...*/\n#if 0\n\tsprintf(szProc, \"/proc/%d/stat\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\tfflush(f);\n\t\tif (fgets(line, 2048, f) != NULL) {\n\t\t\tchar state;\n\t\t\tchar *start;\n\t\t\tlong cutime, cstime, priority, nice, itrealvalue, rss;\n\t\t\tint exit_signal, processor;\n\t\t\tunsigned long flags, minflt, cminflt, majflt, cmajflt, utime, stime,starttime, vsize, rlim, startcode, endcode, startstack, kstkesp, kstkeip, signal, blocked, sigignore, sigcatch, wchan, nswap, cnswap, rem;\n\t\t\tint ppid, pgrp ,session, tty_nr, tty_pgrp, res;\n\t\t\tstart = strchr(line, ')');\n\t\t\tif (start) start += 2;\n\t\t\telse {\n\t\t\t\tstart = strchr(line, ' ');\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tres = sscanf(start,\"%c %d %d %d %d %d %lu %lu %lu %lu \\\n%lu %lu %lu %ld %ld %ld %ld %ld %ld %lu \\\n%lu %ld %lu %lu %lu %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %d %d\",\n\t\t\t             &state, &ppid, &pgrp, &session, &tty_nr, &tty_pgrp, &flags, &minflt, &cminflt, &majflt,\n\t\t\t             &cmajflt, &utime, &stime, &cutime, &cstime, &priority, &nice, &itrealvalue, &rem, &starttime,\n\t\t\t             &vsize, &rss, &rlim, &startcode, &endcode, &startstack, &kstkesp, &kstkeip, &signal, &blocked,\n\t\t\t             &sigignore, &sigcatch, &wchan, &nswap, &cnswap, &exit_signal, &processor);\n\n\t\t\tif (res) process_u_k_time = (u64) (cutime + cstime);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] PROC %s parse error\\n\", szProc));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] error reading pid/stat\\n\\n\", szProc));\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n\tsprintf(szProc, \"/proc/%d/status\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"VmSize:\", 7)) {\n\t\t\t\tsscanf(line, \"VmSize: %\"LLD\" kB\",  &the_rti.process_memory);\n\t\t\t\tthe_rti.process_memory *= 1024;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n#endif\n\n\n#ifndef GPAC_IPHONE\n\tthe_rti.physical_memory = the_rti.physical_memory_avail = 0;\n\tf = gf_fopen(\"/proc/meminfo\", \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"MemTotal:\", 9)) {\n\t\t\t\tsscanf(line, \"MemTotal: \"LLU\" kB\",  &the_rti.physical_memory);\n\t\t\t\tthe_rti.physical_memory *= 1024;\n\t\t\t} else if (!strnicmp(line, \"MemFree:\", 8)) {\n\t\t\t\tsscanf(line, \"MemFree: \"LLU\" kB\",  &the_rti.physical_memory_avail);\n\t\t\t\tthe_rti.physical_memory_avail *= 1024;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open /proc/meminfo\\n\"));\n\t}\n#endif\n\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = (entry_time - last_update_time);\n\t\tthe_rti.process_cpu_time_diff = (u32) (process_u_k_time - last_process_k_u_time) * 10;\n\n\t\t/*oops, we have no choice but to assume 100% cpu usage during this period*/\n\t\tif (!u_k_time) {\n\t\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t\tu_k_time = (u32) (last_cpu_u_k_time + the_rti.sampling_period_duration);\n\t\t\tthe_rti.cpu_idle_time = 0;\n\t\t\tthe_rti.total_cpu_usage = 100;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / the_rti.sampling_period_duration);\n\t\t} else {\n\t\t\tu64 samp_sys_time;\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.total_cpu_time_diff = (u32) (u_k_time - last_cpu_u_k_time)*10;\n\n\t\t\t/*we're not that accurate....*/\n\t\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration)\n\t\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\n\n\t\t\tif (!idle_time) idle_time = (the_rti.sampling_period_duration - the_rti.total_cpu_time_diff)/10;\n\t\t\tsamp_sys_time = u_k_time - last_cpu_u_k_time;\n\t\t\tthe_rti.cpu_idle_time = (u32) (idle_time - last_cpu_idle_time);\n\t\t\tthe_rti.total_cpu_usage = (u32) ( 100 * samp_sys_time / (the_rti.cpu_idle_time + samp_sys_time ) );\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.cpu_idle_time *= 10;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / (the_rti.cpu_idle_time + 10*samp_sys_time ) );\n\t\t}\n\t} else {\n\t\tmem_at_startup = the_rti.physical_memory_avail;\n\t}\n\tthe_rti.process_memory = mem_at_startup - the_rti.physical_memory_avail;\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = gpac_allocated_memory;\n#endif\n\n\tlast_process_k_u_time = process_u_k_time;\n\tlast_cpu_idle_time = idle_time;\n\tlast_cpu_u_k_time = u_k_time;\n\tlast_update_time = entry_time;\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn 1;\n}\n\n#endif\n\nGF_EXPORT\nBool gf_sys_get_rti(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tBool res = gf_sys_get_rti_os(refresh_time_ms, rti, flags);\n\tif (res) {\n\t\tif (!rti->process_memory) rti->process_memory = memory_at_gpac_startup - rti->physical_memory_avail;\n\t\tif (!rti->gpac_memory) rti->gpac_memory = memory_at_gpac_startup - rti->physical_memory_avail;\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nchar * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\n\troot_tmp = gf_strdup(szPath);\n\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\n\tstrcat(szPath, \"gpac_cache\");\n\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}\n\n\nGF_EXPORT\nBool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}\n\n\nstruct GF_GlobalLock {\n\tconst char * resourceName;\n};\n\n\n#ifndef WIN32\n#define CPF_CLOEXEC 1\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nstruct _GF_GlobalLock_opaque {\n\tchar * resourceName;\n\tchar * pidFile;\n\tint fd;\n};\n\nGF_GlobalLock * gf_create_PID_file( const char * resourceName )\n{\n\tconst char * prefix = \"/gpac_lock_\";\n\tconst char * dir = gf_get_default_cache_directory();\n\tchar * pidfile;\n\tint flags;\n\tint status;\n\tpidfile = gf_malloc(strlen(dir)+strlen(prefix)+strlen(resourceName)+1);\n\tstrcpy(pidfile, dir);\n\tstrcat(pidfile, prefix);\n\t/* Use only valid names for file */\n\t{\n\t\tconst char *res;\n\t\tchar * pid = &(pidfile[strlen(pidfile)]);\n\t\tfor (res = resourceName; *res ; res++) {\n\t\t\tif (*res >= 'A' && *res <= 'z')\n\t\t\t\t*pid = * res;\n\t\t\telse\n\t\t\t\t*pid = '_';\n\t\t\tpid++;\n\t\t}\n\t\t*pid = '\\0';\n\t}\n\tint fd = open(pidfile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t\tgoto exit;\n\t/* Get the flags */\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags == -1) {\n\t\tgoto exit;\n\t}\n\t/* Set FD_CLOEXEC, so exclusive lock will be removed on exit, so even if GPAC crashes,\n\t* lock will be allowed for next instance */\n\tflags |= FD_CLOEXEC;\n\t/* Now, update the flags */\n\tif (fcntl(fd, F_SETFD, flags) == -1) {\n\t\tgoto exit;\n\t}\n\n\t/* Now, we try to lock the file */\n\t{\n\t\tstruct flock fl;\n\t\tfl.l_type = F_WRLCK;\n\t\tfl.l_whence = SEEK_SET;\n\t\tfl.l_start = fl.l_len = 0;\n\t\tstatus = fcntl(fd, F_SETLK, &fl);\n\t}\n\n\tif (status == -1) {\n\t\tgoto exit;\n\t}\n\n\tif (ftruncate(fd, 0) == -1) {\n\t\tgoto exit;\n\t}\n\t/* Write the PID */\n\t{\n\t\tint sz = 100;\n\t\tchar * buf = gf_malloc( sz );\n\t\tsz = snprintf(buf, sz, \"%ld\\n\", (long) getpid());\n\t\tif (write(fd, buf, sz) != sz) {\n\t\t\tgf_free(buf);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tsync();\n\t{\n\t\tGF_GlobalLock * lock = gf_malloc( sizeof(GF_GlobalLock));\n\t\tlock->resourceName = gf_strdup(resourceName);\n\t\tlock->pidFile = pidfile;\n\t\tlock->fd = fd;\n\t\treturn lock;\n\t}\nexit:\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn NULL;\n}\n#else /* WIN32 */\nstruct _GF_GlobalLock_opaque {\n\tchar * resourceName;\n\tHANDLE hMutex; /*a named mutex is a system-mode object on windows*/\n};\n#endif\n\nGF_EXPORT\nGF_GlobalLock * gf_global_resource_lock(const char * resourceName) {\n#ifdef WIN32\n#ifdef _WIN32_WCE\n\tunsigned short sWResourceName[MAX_PATH];\n#endif\n\tDWORD lastErr;\n\tGF_GlobalLock *lock = gf_malloc(sizeof(GF_GlobalLock));\n\tlock->resourceName = gf_strdup(resourceName);\n\n\t/*first ensure mutex is created*/\n#ifdef _WIN32_WCE\n\tCE_CharToWide((char *)resourceName, sWResourceName);\n\tlock->hMutex = CreateMutex(NULL, TRUE, sWResourceName);\n#else\n\tlock->hMutex = CreateMutex(NULL, TRUE, resourceName);\n#endif\n\tlastErr = GetLastError();\n\tif (lastErr && lastErr == ERROR_ALREADY_EXISTS)\n\t\treturn NULL;\n\tif (!lock->hMutex)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't create mutex for global lock: %d\\n\", lastErr));\n\t\treturn NULL;\n\t}\n\n\t/*then lock it*/\n\tswitch (WaitForSingleObject(lock->hMutex, INFINITE)) {\n\tcase WAIT_ABANDONED:\n\tcase WAIT_TIMEOUT:\n\t\tassert(0); /*serious error: someone has modified the object elsewhere*/\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't get the global lock\\n\"));\n\t\tgf_global_resource_unlock(lock);\n\t\treturn NULL;\n\t}\n\n\treturn lock;\n#else /* WIN32 */\n\treturn gf_create_PID_file(resourceName);\n#endif /* WIN32 */\n}\n\n/*!\n * Unlock a previouly locked resource\n * \\param lock The resource to unlock\n * \\return GF_OK if evertything went fine\n */\nGF_EXPORT\nGF_Err gf_global_resource_unlock(GF_GlobalLock * lock) {\n\tif (!lock)\n\t\treturn GF_BAD_PARAM;\n#ifndef WIN32\n\tassert( lock->pidFile);\n\tclose(lock->fd);\n\tif (unlink(lock->pidFile))\n\t\tperror(\"Failed to unlink lock file\");\n\tgf_free(lock->pidFile);\n\tlock->pidFile = NULL;\n\tlock->fd = -1;\n#else /* WIN32 */\n\t{\n\t\t/*MSDN: \"The mutex object is destroyed when its last handle has been closed.\"*/\n\t\tBOOL ret = ReleaseMutex(lock->hMutex);\n\t\tif (!ret) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't release mutex for global lock: %d\\n\", err));\n\t\t}\n\t\tret = CloseHandle(lock->hMutex);\n\t\tif (!ret) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't destroy mutex for global lock: %d\\n\", err));\n\t\t}\n\t}\n#endif\n\tif (lock->resourceName)\n\t\tgf_free(lock->resourceName);\n\tlock->resourceName = NULL;\n\tgf_free(lock);\n\treturn GF_OK;\n}\n\n#ifdef GPAC_ANDROID\n\nfm_callback_func fm_cbk = NULL;\nstatic void *fm_cbk_obj = NULL;\n\nvoid gf_fm_request_set_callback(void *cbk_obj, fm_callback_func cbk_func) {\n\tfm_cbk = cbk_func;\n\tfm_cbk_obj = cbk_obj;\n}\n\nvoid gf_fm_request_call(u32 type, u32 param, int *value) {\n\tif (fm_cbk)\n\t\tfm_cbk(fm_cbk_obj, type, param, value);\n}\n\n#endif //GPAC_ANDROID\n\nGF_EXPORT\ns32 gf_gettimeofday(struct timeval *tp, void *tz) {\n\treturn gettimeofday(tp, tz);\n}\n\n\nstatic u32 ntp_shift = GF_NTP_SEC_1900_TO_1970;\n\nGF_EXPORT\nvoid gf_net_set_ntp_shift(s32 shift)\n{\n\tntp_shift = GF_NTP_SEC_1900_TO_1970 + shift;\n}\n\n/*\n\t\tNTP tools\n*/\nGF_EXPORT\nvoid gf_net_get_ntp(u32 *sec, u32 *frac)\n{\n\tu64 frac_part;\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\tif (sec) {\n\t\t*sec = (u32) (now.tv_sec) + ntp_shift;\n\t}\n\n\tif (frac) {\n\t\tfrac_part = now.tv_usec * 0xFFFFFFFFULL;\n\t\tfrac_part /= 1000000;\n\t\t*frac = (u32) ( frac_part );\n\t}\n}\n\nGF_EXPORT\nu64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}\n\nGF_EXPORT\ns32 gf_net_get_ntp_diff_ms(u64 ntp)\n{\n\tu32 remote_s, remote_f, local_s, local_f;\n\ts64 local, remote;\n\n\tremote_s = (ntp >> 32);\n\tremote_f = (u32) (ntp & 0xFFFFFFFFULL);\n\tgf_net_get_ntp(&local_s, &local_f);\n\n\tlocal = local_s;\n\tlocal *= 1000;\n\tlocal += ((u64) local_f)*1000 / 0xFFFFFFFFULL;\n\n\tremote = remote_s;\n\tremote *= 1000;\n\tremote += ((u64) remote_f)*1000 / 0xFFFFFFFFULL;\n\n\treturn (s32) (local - remote);\n}\n\n\n\nGF_EXPORT\ns32 gf_net_get_timezone()\n{\n#if defined(_WIN32_WCE)\n\treturn 0;\n#else\n\t//this has been commented due to some reports of broken implementation on some systems ...\n\t//\t\ts32 val = timezone;\n\t//\t\treturn val;\n\n\n\t/*FIXME - avoid errors at midnight when estimating timezone this does not work !!*/\n\ts32 t_timezone;\n\tstruct tm t_gmt, t_local;\n\ttime_t t_time;\n\tt_time = time(NULL);\n\tt_gmt = *gmtime(&t_time);\n\tt_local = *localtime(&t_time);\n\n\tt_timezone = (t_gmt.tm_hour - t_local.tm_hour) * 3600 + (t_gmt.tm_min - t_local.tm_min) * 60;\n\treturn t_timezone;\n#endif\n\n}\n\n//no mkgmtime on mingw..., use our own\n#if (defined(WIN32) && defined(__GNUC__))\n\nstatic Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\tstatic const u32 days_per_month[2][12] = {\n\t\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n\t\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n\t};\n\ttime_t time=0;\n\tint i;\n\n\tfor (i=70; i<tm->tm_year; i++) {\n\t\ttime += leap_year(i) ? 366 : 365;\n\t}\n\n\tfor (i=0; i<tm->tm_mon; ++i) {\n\t\ttime += days_per_month[leap_year(tm->tm_year)][i];\n\t}\n\ttime += tm->tm_mday - 1;\n\ttime *= 24;\n\ttime += tm->tm_hour;\n\ttime *= 60;\n\ttime += tm->tm_min;\n\ttime *= 60;\n\ttime += tm->tm_sec;\n\treturn time;\n}\n\n#elif defined(WIN32)\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn  _mkgmtime(tm);\n}\n\n#elif defined(GPAC_ANDROID)\n#include <time64.h>\n#if defined(__LP64__)\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn timegm64(tm);\n}\n#else\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\tstatic const time_t kTimeMax = ~(1L << (sizeof(time_t) * CHAR_BIT - 1));\n\tstatic const time_t kTimeMin = (1L << (sizeof(time_t) * CHAR_BIT - 1));\n\ttime64_t result = timegm64(tm);\n\tif (result < kTimeMin || result > kTimeMax)\n\t\treturn -1;\n\treturn result;\n}\n#endif\n\n#else\n\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn timegm(tm);\n}\n\n#endif\n\nGF_EXPORT\nu64 gf_net_parse_date(const char *val)\n{\n\tu64 current_time;\n\tchar szDay[50], szMonth[50];\n\tu32 year, month, day, h, m, s, ms;\n\ts32 oh, om;\n\tFloat secs;\n\tBool neg_time_zone = GF_FALSE;\n\n#ifdef _WIN32_WCE\n\tSYSTEMTIME syst;\n\tFILETIME filet;\n#else\n\tstruct tm t;\n\tmemset(&t, 0, sizeof(struct tm));\n#endif\n\n\tszDay[0] = szMonth[0] = 0;\n\tyear = month = day = h = m = s = 0;\n\toh = om = 0;\n\tsecs = 0;\n\n\tif (sscanf(val, \"%d-%d-%dT%d:%d:%gZ\", &year, &month, &day, &h, &m, &secs) == 6) {\n\t}\n\telse if (sscanf(val, \"%d-%d-%dT%d:%d:%g-%d:%d\", &year, &month, &day, &h, &m, &secs, &oh, &om) == 8) {\n\t\tneg_time_zone = GF_TRUE;\n\t}\n\telse if (sscanf(val, \"%d-%d-%dT%d:%d:%g+%d:%d\", &year, &month, &day, &h, &m, &secs, &oh, &om) == 8) {\n\t}\n\telse if (sscanf(val, \"%3s, %d %3s %d %d:%d:%d\", szDay, &day, szMonth, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse if (sscanf(val, \"%9s, %d-%3s-%d %02d:%02d:%02d GMT\", szDay, &day, szMonth, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse if (sscanf(val, \"%3s %3s %d %02d:%02d:%02d %d\", szDay, szMonth, &day, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[Core] Cannot parse date string %s\\n\", val));\n\t\treturn 0;\n\t}\n\n\tif (month) {\n\t\tmonth -= 1;\n\t} else {\n\t\tif (!strcmp(szMonth, \"Jan\")) month = 0;\n\t\telse if (!strcmp(szMonth, \"Feb\")) month = 1;\n\t\telse if (!strcmp(szMonth, \"Mar\")) month = 2;\n\t\telse if (!strcmp(szMonth, \"Apr\")) month = 3;\n\t\telse if (!strcmp(szMonth, \"May\")) month = 4;\n\t\telse if (!strcmp(szMonth, \"Jun\")) month = 5;\n\t\telse if (!strcmp(szMonth, \"Jul\")) month = 6;\n\t\telse if (!strcmp(szMonth, \"Aug\")) month = 7;\n\t\telse if (!strcmp(szMonth, \"Sep\")) month = 8;\n\t\telse if (!strcmp(szMonth, \"Oct\")) month = 9;\n\t\telse if (!strcmp(szMonth, \"Nov\")) month = 10;\n\t\telse if (!strcmp(szMonth, \"Dec\")) month = 11;\n\t}\n\n#ifdef _WIN32_WCE\n\tmemset(&syst, 0, sizeof(SYSTEMTIME));\n\tsyst.wYear = year;\n\tsyst.wMonth = month + 1;\n\tsyst.wDay = day;\n\tsyst.wHour = h;\n\tsyst.wMinute = m;\n\tsyst.wSecond = (u32) secs;\n\tSystemTimeToFileTime(&syst, &filet);\n\tcurrent_time = (u64) ((*(LONGLONG *) &filet - TIMESPEC_TO_FILETIME_OFFSET) / 10000000);\n\n#else\n\n\tt.tm_year = year>1000 ? year-1900 : year;\n\tt.tm_mday = day;\n\tt.tm_hour = h;\n\tt.tm_min = m;\n\tt.tm_sec = (u32) secs;\n\tt.tm_mon = month;\n\n\tif (strlen(szDay) ) {\n\t\tif (!strcmp(szDay, \"Mon\") || !strcmp(szDay, \"Monday\")) t.tm_wday = 0;\n\t\telse if (!strcmp(szDay, \"Tue\") || !strcmp(szDay, \"Tuesday\")) t.tm_wday = 1;\n\t\telse if (!strcmp(szDay, \"Wed\") || !strcmp(szDay, \"Wednesday\")) t.tm_wday = 2;\n\t\telse if (!strcmp(szDay, \"Thu\") || !strcmp(szDay, \"Thursday\")) t.tm_wday = 3;\n\t\telse if (!strcmp(szDay, \"Fri\") || !strcmp(szDay, \"Friday\")) t.tm_wday = 4;\n\t\telse if (!strcmp(szDay, \"Sat\") || !strcmp(szDay, \"Saturday\")) t.tm_wday = 5;\n\t\telse if (!strcmp(szDay, \"Sun\") || !strcmp(szDay, \"Sunday\")) t.tm_wday = 6;\n\t}\n\n\tcurrent_time = gf_mktime_utc(&t);\n\n\tif ((s64) current_time == -1) {\n\t\t//use 1 ms\n\t\treturn 1;\n\t}\n\tif (current_time == 0) {\n\t\t//use 1 ms\n\t\treturn 1;\n\t}\n\n#endif\n\n\tif (om || oh) {\n\t\ts32 diff = (60*oh + om)*60;\n\t\tif (neg_time_zone) diff = -diff;\n\t\tcurrent_time = current_time + diff;\n\t}\n\tcurrent_time *= 1000;\n\tms = (u32) ( (secs - (u32) secs) * 1000);\n\treturn current_time + ms;\n}\n\nGF_EXPORT\nu64 gf_net_get_utc()\n{\n\tu64 current_time;\n\tDouble msec;\n\tu32 sec, frac;\n\n\tgf_net_get_ntp(&sec, &frac);\n\tcurrent_time = sec - GF_NTP_SEC_1900_TO_1970;\n\tcurrent_time *= 1000;\n\tmsec = frac*1000.0;\n\tmsec /= 0xFFFFFFFF;\n\tcurrent_time += (u64) msec;\n\treturn current_time;\n}\n\n\n\nGF_EXPORT\nGF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/tools.h>\n#include <gpac/network.h>\n\n#if defined(_WIN32_WCE)\n\n#include <winbase.h>\n#include <winsock.h>\n#include <tlhelp32.h>\n//#include <direct.h>\n\n#if !defined(__GNUC__)\n#pragma comment(lib, \"toolhelp\")\n#endif\n\n#elif defined(WIN32)\n\n#include <time.h>\n#include <sys/timeb.h>\n#include <io.h>\n#include <windows.h>\n#include <tlhelp32.h>\n#include <direct.h>\n\n#if !defined(__GNUC__)\n#pragma comment(lib, \"winmm\")\n#endif\n\n#else\n\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/resource.h>\n\n#ifndef __BEOS__\n#include <errno.h>\n#endif\n\n#define SLEEP_ABS_SELECT\t\t1\n\nstatic u32 sys_start_time = 0;\nstatic u64 sys_start_time_hr = 0;\n#endif\n\n\n#ifndef _WIN32_WCE\n#include <locale.h>\n#endif\n\n\n#ifndef WIN32\n\nGF_EXPORT\nu32 gf_sys_clock()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (u32) ( ( (now.tv_sec)*1000 + (now.tv_usec) / 1000) - sys_start_time );\n}\n\nGF_EXPORT\nu64 gf_sys_clock_high_res()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (now.tv_sec)*1000000 + (now.tv_usec) - sys_start_time_hr;\n}\n\n#endif\n\n\n\nGF_EXPORT\nvoid gf_sleep(u32 ms)\n{\n#ifdef WIN32\n\tSleep(ms);\n#else\n\ts32 sel_err;\n\tstruct timeval tv;\n\n#ifndef SLEEP_ABS_SELECT\n\tu32 prev, now, elapsed;\n#endif\n\n#ifdef SLEEP_ABS_SELECT\n\ttv.tv_sec = ms/1000;\n\ttv.tv_usec = (ms%1000)*1000;\n#else\n\tprev = gf_sys_clock();\n#endif\n\n\tdo {\n\t\terrno = 0;\n\n#ifndef SLEEP_ABS_SELECT\n\t\tnow = gf_sys_clock();\n\t\telapsed = (now - prev);\n\t\tif ( elapsed >= ms ) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = now;\n\t\tms -= elapsed;\n\t\ttv.tv_sec = ms/1000;\n\t\ttv.tv_usec = (ms%1000)*1000;\n#endif\n\n\t\tsel_err = select(0, NULL, NULL, NULL, &tv);\n\t} while ( sel_err && (errno == EINTR) );\n#endif\n}\n\n#ifndef gettimeofday\n#ifdef _WIN32_WCE\n\n#include <time.h>\n//#include <wce_time.h>\n\n/*\n * Author of first version (timeval.h): by Wu Yongwei\n * Author of Windows CE version: Mateusz Loskot (mateusz@loskot.net)\n *\n * All code here is considered in the public domain though we do wish our names\n * could be retained if anyone uses them.\n */\n\n/*\n * Constants used internally by time functions.\n */\n\n#ifndef _TM_DEFINED\nstruct tm\n{\n\tint tm_sec;     /* seconds after the minute - [0,59] */\n\tint tm_min;     /* minutes after the hour - [0,59] */\n\tint tm_hour;\t/* hours since midnight - [0,23] */\n\tint tm_mday;\t/* day of the month - [1,31] */\n\tint tm_mon;     /* months since January - [0,11] */\n\tint tm_year;\t/* years since 1900 */\n\tint tm_wday;\t/* days since Sunday - [0,6] */\n\tint tm_yday;\t/* days since January 1 - [0,365] */\n\tint tm_isdst;\t/* daylight savings time flag */\n};\n#define _TM_DEFINED\n#endif /* _TM_DEFINED */\n\n#ifndef _TIMEZONE_DEFINED\nstruct timezone\n{\n\tint tz_minuteswest; /* minutes W of Greenwich */\n\tint tz_dsttime;     /* type of dst correction */\n};\n#define _TIMEZONE_DEFINED\n#endif /* _TIMEZONE_DEFINED */\n\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n#define EPOCHFILETIME (116444736000000000i64)\n#else\n#define EPOCHFILETIME (116444736000000000LL)\n#endif\n\nint gettimeofday(struct timeval *tp, struct timezone *tzp)\n{\n\tSYSTEMTIME      st;\n\tFILETIME        ft;\n\tLARGE_INTEGER   li;\n\tTIME_ZONE_INFORMATION tzi;\n\t__int64         t;\n\tstatic int      tzflag;\n\n\tif (NULL != tp)\n\t{\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &ft);\n\t\tli.LowPart  = ft.dwLowDateTime;\n\t\tli.HighPart = ft.dwHighDateTime;\n\t\tt  = li.QuadPart;       /* In 100-nanosecond intervals */\n\t\tt -= EPOCHFILETIME;     /* Offset to the Epoch time */\n\t\tt /= 10;                /* In microseconds */\n\t\ttp->tv_sec  = (long)(t / 1000000);\n\t\ttp->tv_usec = (long)(t % 1000000);\n\t}\n\n\tif (NULL != tzp)\n\t{\n\t\tGetTimeZoneInformation(&tzi);\n\n\t\ttzp->tz_minuteswest = tzi.Bias;\n\t\tif (tzi.StandardDate.wMonth != 0)\n\t\t{\n\t\t\ttzp->tz_minuteswest += tzi.StandardBias * 60;\n\t\t}\n\n\t\tif (tzi.DaylightDate.wMonth != 0)\n\t\t{\n\t\t\ttzp->tz_dsttime = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttzp->tz_dsttime = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if _GPAC_UNUSED\n/*\n\ttime between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds\n\tFILETIME in Win32 is from jan 1, 1601\n*/\n\ns32 __gettimeofday(struct timeval *tp, void *tz)\n{\n\tFILETIME ft;\n\tSYSTEMTIME st;\n\ts32 val;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\n\tval = (s32) ((*(LONGLONG *) &ft - TIMESPEC_TO_FILETIME_OFFSET) / 10000000);\n\ttp->tv_sec = (u32) val;\n\tval = (s32 ) ((*(LONGLONG *) &ft - TIMESPEC_TO_FILETIME_OFFSET - ((LONGLONG) val * (LONGLONG) 10000000)) * 100);\n\ttp->tv_usec = val;\n\treturn 0;\n}\n#endif\n\n\n#elif defined(WIN32)\n\nstatic s32 gettimeofday(struct timeval *tp, void *tz)\n{\n\tstruct _timeb timebuffer;\n\n\t_ftime( &timebuffer );\n\ttp->tv_sec  = (long) (timebuffer.time);\n\ttp->tv_usec = timebuffer.millitm * 1000;\n\treturn 0;\n}\n#endif\n\n#endif\n\n#ifdef _WIN32_WCE\n\nvoid CE_Assert(u32 valid, char *file, u32 line)\n{\n\tif (!valid) {\n\t\tchar szBuf[2048];\n\t\tu16 wcBuf[2048];\n\t\tsprintf(szBuf, \"File %s : line %d\", file, line);\n\t\tCE_CharToWide(szBuf, wcBuf);\n\t\tMessageBox(NULL, wcBuf, _T(\"GPAC Assertion Failure\"), MB_OK);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nvoid CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}\n\nvoid CE_CharToWide(char *str, unsigned short *w_str)\n{\n\tMultiByteToWideChar(CP_ACP, 0, str, -1, w_str, GF_MAX_PATH);\n}\n\n\n#endif\n\nGF_EXPORT\nvoid gf_rand_init(Bool Reset)\n{\n\tif (Reset) {\n\t\tsrand(1);\n\t} else {\n#if defined(_WIN32_WCE)\n\t\tsrand( (u32) GetTickCount() );\n#else\n\t\tsrand( (u32) time(NULL) );\n#endif\n\t}\n}\n\nGF_EXPORT\nu32 gf_rand()\n{\n\treturn rand();\n}\n\n#ifndef _WIN32_WCE\n#include <sys/stat.h>\n#endif\n\nGF_EXPORT\nvoid gf_utc_time_since_1970(u32 *sec, u32 *msec)\n{\n#if defined (WIN32) && !defined(_WIN32_WCE)\n\tstruct _timeb\ttb;\n\t_ftime( &tb );\n\t*sec = (u32) tb.time;\n\t*msec = tb.millitm;\n#else\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\t*sec = (u32) tv.tv_sec;\n\t*msec = tv.tv_usec/1000;\n#endif\n}\n\nGF_EXPORT\nvoid gf_get_user_name(char *buf, u32 buf_size)\n{\n\tstrcpy(buf, \"mpeg4-user\");\n\n#if 0\n\ts32 len;\n\tchar *t;\n\tstrcpy(buf, \"\");\n\tlen = 1024;\n\tGetUserName(buf, &len);\n\tif (!len) {\n\t\tt = getenv(\"USER\");\n\t\tif (t) strcpy(buf, t);\n\t}\n#endif\n#if 0\n\tstruct passwd *pw;\n\tpw = getpwuid(getuid());\n\tstrcpy(buf, \"\");\n\tif (pw && pw->pw_name) strcpy(name, pw->pw_name);\n#endif\n}\n\n\n#ifndef WIN32\nGF_EXPORT\nchar * my_str_upr(char *str)\n{\n\tu32 i;\n\tfor (i=0; i<strlen(str); i++) {\n\t\tstr[i] = toupper(str[i]);\n\t}\n\treturn str;\n}\n\nGF_EXPORT\nchar * my_str_lwr(char *str)\n{\n\tu32 i;\n\tfor (i=0; i<strlen(str); i++) {\n\t\tstr[i] = tolower(str[i]);\n\t}\n\treturn str;\n}\n#endif\n\n/*seems OK under mingw also*/\n#ifdef WIN32\n#ifdef _WIN32_WCE\n\nBool gf_prompt_has_input()\n{\n\treturn 0;\n}\nchar gf_prompt_get_char() {\n\treturn 0;\n}\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off) {\n\treturn;\n}\n\n#else\n\n#include <conio.h>\n#include <windows.h>\n\nBool gf_prompt_has_input()\n{\n\treturn kbhit();\n}\n\nchar gf_prompt_get_char()\n{\n\treturn getchar();\n}\n\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off)\n{\n\tDWORD flags;\n\tHANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);\n\tBOOL ret = GetConsoleMode(hStdin, &flags);\n\tif (!ret) {\n\t\tDWORD err = GetLastError();\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"[Console] GetConsoleMode() return with the following error code: %d\\n\", err));\n\t}\n\tif (echo_off) flags &= ~ENABLE_ECHO_INPUT;\n\telse flags |= ENABLE_ECHO_INPUT;\n\tSetConsoleMode(hStdin, flags);\n}\n#endif\n#else\n/*linux kbhit/getchar- borrowed on debian mailing lists, (author Mike Brownlow)*/\n#include <termios.h>\n\nstatic struct termios t_orig, t_new;\nstatic s32 ch_peek = -1;\n\nstatic void init_keyboard()\n{\n\ttcgetattr(0, &t_orig);\n\tt_new = t_orig;\n\tt_new.c_lflag &= ~ICANON;\n\tt_new.c_lflag &= ~ECHO;\n\tt_new.c_lflag &= ~ISIG;\n\tt_new.c_cc[VMIN] = 1;\n\tt_new.c_cc[VTIME] = 0;\n\ttcsetattr(0, TCSANOW, &t_new);\n}\nstatic void close_keyboard(Bool new_line)\n{\n\ttcsetattr(0,TCSANOW, &t_orig);\n\tif (new_line) fprintf(stderr, \"\\n\");\n}\n\nGF_EXPORT\nvoid gf_prompt_set_echo_off(Bool echo_off)\n{\n\tinit_keyboard();\n\tif (echo_off) t_orig.c_lflag &= ~ECHO;\n\telse t_orig.c_lflag |= ECHO;\n\tclose_keyboard(0);\n}\n\nGF_EXPORT\nBool gf_prompt_has_input()\n{\n\tu8 ch;\n\ts32 nread;\n\tpid_t fg = tcgetpgrp(STDIN_FILENO);\n\n\t//we are not foreground nor piped (used for IDEs), can't read stdin\n\tif ((fg!=-1) && (fg != getpgrp())) {\n\t\treturn 0;\n\t}\n\tinit_keyboard();\n\tif (ch_peek != -1) return 1;\n\tt_new.c_cc[VMIN]=0;\n\ttcsetattr(0, TCSANOW, &t_new);\n\tnread = (s32) read(0, &ch, 1);\n\tt_new.c_cc[VMIN]=1;\n\ttcsetattr(0, TCSANOW, &t_new);\n\tif(nread == 1) {\n\t\tch_peek = ch;\n\t\treturn 1;\n\t}\n\tclose_keyboard(0);\n\treturn 0;\n}\n\nGF_EXPORT\nchar gf_prompt_get_char()\n{\n\tchar ch;\n\tif (ch_peek != -1) {\n\t\tch = ch_peek;\n\t\tch_peek = -1;\n\t\tclose_keyboard(1);\n\t\treturn ch;\n\t}\n\tif (0==read(0,&ch,1))\n\t\tch = 0;\n\tclose_keyboard(1);\n\treturn ch;\n}\n\n#endif\n\n\nstatic u32 sys_init = 0;\nstatic u32 last_update_time = 0;\nstatic u64 last_process_k_u_time = 0;\nGF_SystemRTInfo the_rti;\n\n\n#if defined(_WIN32_WCE)\nstatic LARGE_INTEGER frequency , init_counter;\nstatic u64 last_total_k_u_time = 0;\nstatic u32 mem_usage_at_startup = 0;\n\n\n#ifndef GetCurrentPermissions\nDWORD GetCurrentPermissions();\n#endif\n#ifndef SetProcPermissions\nvoid SetProcPermissions(DWORD );\n#endif\n\n#elif defined(WIN32)\nstatic LARGE_INTEGER frequency , init_counter;\nstatic u64 last_proc_idle_time = 0;\nstatic u64 last_proc_k_u_time = 0;\n\nstatic HINSTANCE psapi_hinst = NULL;\ntypedef BOOL(WINAPI* NTGetSystemTimes)(VOID *,VOID *,VOID *);\nNTGetSystemTimes MyGetSystemTimes = NULL;\ntypedef BOOL(WINAPI* NTGetProcessMemoryInfo)(HANDLE,VOID *,DWORD);\nNTGetProcessMemoryInfo MyGetProcessMemoryInfo = NULL;\ntypedef int(WINAPI* NTQuerySystemInfo)(ULONG,PVOID,ULONG,PULONG);\nNTQuerySystemInfo MyQuerySystemInfo = NULL;\n\n#ifndef PROCESS_MEMORY_COUNTERS\ntypedef struct _PROCESS_MEMORY_COUNTERS\n{\n\tDWORD cb;\n\tDWORD PageFaultCount;\n\tSIZE_T PeakWorkingSetSize;\n\tSIZE_T WorkingSetSize;\n\tSIZE_T QuotaPeakPagedPoolUsage;\n\tSIZE_T QuotaPagedPoolUsage;\n\tSIZE_T QuotaPeakNonPagedPoolUsage;\n\tSIZE_T QuotaNonPagedPoolUsage;\n\tSIZE_T PagefileUsage;\n\tSIZE_T PeakPagefileUsage;\n} PROCESS_MEMORY_COUNTERS;\n#endif\n\n#ifndef SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\ntypedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\n{\n\tLARGE_INTEGER IdleTime;\n\tLARGE_INTEGER KernelTime;\n\tLARGE_INTEGER UserTime;\n\tLARGE_INTEGER Reserved1[2];\n\tULONG Reserved2;\n} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;\n#endif\n\n\n#else\n\nstatic u64 last_cpu_u_k_time = 0;\nstatic u64 last_cpu_idle_time = 0;\nstatic u64 mem_at_startup = 0;\n\n#endif\n\n#ifdef WIN32\nstatic u32 (*OS_GetSysClock)();\n\nu32 gf_sys_clock()\n{\n\treturn OS_GetSysClock();\n}\n\n\nstatic u64 (*OS_GetSysClockHR)();\nu64 gf_sys_clock_high_res()\n{\n\treturn OS_GetSysClockHR();\n}\n#endif\n\n\n#ifdef WIN32\n\nstatic u32 OS_GetSysClockHIGHRES()\n{\n\tLARGE_INTEGER now;\n\tQueryPerformanceCounter(&now);\n\tnow.QuadPart -= init_counter.QuadPart;\n\treturn (u32) ((now.QuadPart * 1000) / frequency.QuadPart);\n}\n\nstatic u64 OS_GetSysClockHIGHRES_FULL()\n{\n\tLARGE_INTEGER now;\n\tQueryPerformanceCounter(&now);\n\tnow.QuadPart -= init_counter.QuadPart;\n\treturn (u64) ((now.QuadPart * 1000000) / frequency.QuadPart);\n}\n\nstatic u32 OS_GetSysClockNORMAL()\n{\n#ifdef _WIN32_WCE\n\treturn GetTickCount();\n#else\n\treturn timeGetTime();\n#endif\n}\n\nstatic u64 OS_GetSysClockNORMAL_FULL()\n{\n\tu64 res = OS_GetSysClockNORMAL();\n\treturn res*1000;\n}\n\n#endif /* WIN32 */\n\n#if defined(__sh__)\n/* Avoid exception for denormalized floating point values */\nstatic int\nsh4_get_fpscr()\n{\n\tint ret;\n\tasm volatile (\"sts fpscr,%0\" : \"=r\" (ret));\n\treturn ret;\n}\n\nstatic void\nsh4_put_fpscr(int nv)\n{\n\tasm volatile (\"lds %0,fpscr\" : : \"r\" (nv));\n}\n\n#define SH4_FPSCR_FR 0x00200000\n#define SH4_FPSCR_SZ 0x00100000\n#define SH4_FPSCR_PR 0x00080000\n#define SH4_FPSCR_DN 0x00040000\n#define SH4_FPSCR_RN 0x00000003\n#define SH4_FPSCR_RN_N 0\n#define SH4_FPSCR_RN_Z 1\n\nextern int __fpscr_values[2];\n\nvoid\nsh4_change_fpscr(int off, int on)\n{\n\tint b = sh4_get_fpscr();\n\toff = ~off;\n\toff |=   0x00180000;\n\ton  &= ~ 0x00180000;\n\tb &= off;\n\tb |= on;\n\tsh4_put_fpscr(b);\n\t__fpscr_values[0] &= off;\n\t__fpscr_values[0] |= on;\n\t__fpscr_values[1] &= off;\n\t__fpscr_values[1] |= on;\n}\n\n#endif\n\n#ifdef GPAC_MEMORY_TRACKING\nvoid gf_mem_enable_tracker(Bool enable_backtrace);\n#endif\n\nstatic u64 memory_at_gpac_startup = 0;\n\nstatic u32 gpac_argc = 0;\nconst char **gpac_argv = NULL;\n\nGF_EXPORT\nvoid gf_sys_set_args(s32 argc, const char **argv)\n{\n\t//for OSX we allow overwrite of argc/argv due to different behavior between console-mode apps and GUI\n#if !defined(__DARWIN__) && !defined(__APPLE__)\n\tif (!gpac_argc && (argc>=0) )\n#endif\n\t{\n\t\tgpac_argc = (u32) argc;\n\t\tgpac_argv = argv;\n\t}\n}\nGF_EXPORT\nu32 gf_sys_get_argc()\n{\n\treturn gpac_argc;\n}\n\nGF_EXPORT\nconst char *gf_sys_get_arg(u32 arg)\n{\n\tif (!gpac_argc || !gpac_argv) return NULL;\n\tif (arg>=gpac_argc) return NULL;\n\treturn gpac_argv[arg];\n}\n\n\nGF_EXPORT\nvoid gf_sys_init(GF_MemTrackerType mem_tracker_type)\n{\n\tif (!sys_init) {\n#if defined (WIN32)\n#if defined(_WIN32_WCE)\n\t\tMEMORYSTATUS ms;\n#else\n\t\tSYSTEM_INFO sysinfo;\n#endif\n#endif\n\n\t\tif (mem_tracker_type!=GF_MemTrackerNone) {\n#ifdef GPAC_MEMORY_TRACKING\n            gf_mem_enable_tracker( (mem_tracker_type==GF_MemTrackerBackTrace) ? GF_TRUE : GF_FALSE);\n#endif\n\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\t/*by default log subsystem is initialized to error on all tools, and info on console to debug scripts*/\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_ERROR);\n\t\tgf_log_set_tool_level(GF_LOG_CONSOLE, GF_LOG_INFO);\n#endif\n\n\n#if defined(__sh__)\n\t\t/* Round all denormalized floatting point number to 0.0 */\n\t\tsh4_change_fpscr(0,SH4_FPSCR_DN) ;\n#endif\n\n#if defined(WIN32)\n\t\tfrequency.QuadPart = 0;\n\t\t/*clock setup*/\n\t\tif (QueryPerformanceFrequency(&frequency)) {\n\t\t\tQueryPerformanceCounter(&init_counter);\n\t\t\tOS_GetSysClock = OS_GetSysClockHIGHRES;\n\t\t\tOS_GetSysClockHR = OS_GetSysClockHIGHRES_FULL;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] using WIN32 performance timer\\n\"));\n\t\t} else {\n\t\t\tOS_GetSysClock = OS_GetSysClockNORMAL;\n\t\t\tOS_GetSysClockHR = OS_GetSysClockNORMAL_FULL;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] using WIN32 regular timer\\n\"));\n\t\t}\n\n#ifndef _WIN32_WCE\n\t\ttimeBeginPeriod(1);\n#endif\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] checking for run-time info tools\"));\n#if defined(_WIN32_WCE)\n\t\tlast_total_k_u_time = last_process_k_u_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = GetCurrentProcessId();\n\t\tthe_rti.nb_cores = 1;\n\t\tGlobalMemoryStatus(&ms);\n\t\tmem_usage_at_startup = ms.dwAvailPhys;\n#else\n\t\t/*cpu usage tools are buried in win32 dlls...*/\n\t\tMyGetSystemTimes = (NTGetSystemTimes) GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"GetSystemTimes\");\n\t\tif (!MyGetSystemTimes) {\n\t\t\tMyQuerySystemInfo = (NTQuerySystemInfo) GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"NtQuerySystemInformation\");\n\t\t\tif (MyQuerySystemInfo) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - CPU: QuerySystemInformation\"));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - CPU: GetSystemsTimes\"));\n\t\t}\n\t\tpsapi_hinst = LoadLibrary(\"psapi.dll\");\n\t\tMyGetProcessMemoryInfo = (NTGetProcessMemoryInfo) GetProcAddress(psapi_hinst, \"GetProcessMemoryInfo\");\n\t\tif (MyGetProcessMemoryInfo) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\" - memory: GetProcessMemoryInfo\"));\n\t\t}\n\t\tlast_process_k_u_time = last_proc_idle_time = last_proc_k_u_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = GetCurrentProcessId();\n\n\t\tGetSystemInfo( &sysinfo );\n\t\tthe_rti.nb_cores = sysinfo.dwNumberOfProcessors;\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"\\n\"));\n\n#else\n\t\t/*linux threads and OSX...*/\n\t\tlast_process_k_u_time = 0;\n\t\tlast_cpu_u_k_time = last_cpu_idle_time = 0;\n\t\tlast_update_time = 0;\n\t\tmemset(&the_rti, 0, sizeof(GF_SystemRTInfo));\n\t\tthe_rti.pid = getpid();\n\t\tthe_rti.nb_cores = (u32) sysconf( _SC_NPROCESSORS_ONLN );\n\t\tsys_start_time = gf_sys_clock();\n\t\tsys_start_time_hr = gf_sys_clock_high_res();\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] process id %d\\n\", the_rti.pid));\n\n#ifndef _WIN32_WCE\n\t\tsetlocale( LC_NUMERIC, \"C\" );\n#endif\n\t}\n\tsys_init += 1;\n\n\n\t/*init RTI stats*/\n\tif (!memory_at_gpac_startup) {\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(500, &rti, GF_RTI_SYSTEM_MEMORY_ONLY)) {\n\t\t\tmemory_at_gpac_startup = rti.physical_memory_avail;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CORE, (\"[core] System init OK - process id %d - %d MB physical RAM - %d cores\\n\", rti.pid, (u32) (rti.physical_memory/1024/1024), rti.nb_cores));\n\t\t} else {\n\t\t\tmemory_at_gpac_startup = 0;\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_sys_close()\n{\n\tif (sys_init > 0) {\n\t\tsys_init --;\n\t\tif (sys_init) return;\n\t\t/*prevent any call*/\n\t\tlast_update_time = 0xFFFFFFFF;\n\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\t\ttimeEndPeriod(1);\n\n\t\tMyGetSystemTimes = NULL;\n\t\tMyGetProcessMemoryInfo = NULL;\n\t\tMyQuerySystemInfo = NULL;\n\t\tif (psapi_hinst) FreeLibrary(psapi_hinst);\n\t\tpsapi_hinst = NULL;\n#endif\n\t}\n}\n\n#ifdef GPAC_MEMORY_TRACKING\nextern size_t gpac_allocated_memory;\nextern size_t gpac_nb_alloc_blocs;\n#endif\n\n/*CPU and Memory Usage*/\n#ifdef WIN32\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n#if defined(_WIN32_WCE)\n\tTHREADENTRY32 tentry;\n\tu64 total_cpu_time, process_cpu_time;\n\tDWORD orig_perm;\n#endif\n\tMEMORYSTATUS ms;\n\tu64 creation, exit, kernel, user, process_k_u_time, proc_idle_time, proc_k_u_time;\n\tu32 entry_time;\n\tHANDLE hSnapShot;\n\n\tassert(sys_init);\n\n\tif (!rti) return GF_FALSE;\n\n\tproc_idle_time = proc_k_u_time = process_k_u_time = 0;\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn GF_FALSE;\n\t}\n\n\tif (flags & GF_RTI_SYSTEM_MEMORY_ONLY) {\n\t\tmemset(rti, 0, sizeof(GF_SystemRTInfo));\n\t\trti->sampling_instant = last_update_time;\n\t\tGlobalMemoryStatus(&ms);\n\t\trti->physical_memory = ms.dwTotalPhys;\n\t\trti->physical_memory_avail = ms.dwAvailPhys;\n#ifdef GPAC_MEMORY_TRACKING\n\t\trti->gpac_memory = (u64) gpac_allocated_memory;\n#endif\n\t\treturn GF_TRUE;\n\t}\n\n#if defined (_WIN32_WCE)\n\n\ttotal_cpu_time = process_cpu_time = 0;\n\n\t/*get a snapshot of all running threads*/\n\torig_perm = GetCurrentPermissions();\n\tSetProcPermissions(0xFFFFFFFF);\n\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n\tif (hSnapShot) {\n\t\ttentry.dwSize = sizeof(THREADENTRY32);\n\t\tthe_rti.thread_count = 0;\n\t\t/*note we always act as if GF_RTI_ALL_PROCESSES_TIMES flag is set, since there is no other way\n\t\tto enumerate threads from a process, and GetProcessTimes doesn't exist on CE*/\n\t\tif (Thread32First(hSnapShot, &tentry)) {\n\t\t\tdo {\n\t\t\t\t/*get thread times*/\n\t\t\t\tif (GetThreadTimes( (HANDLE) tentry.th32ThreadID, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user)) {\n\t\t\t\t\ttotal_cpu_time += user + kernel;\n\t\t\t\t\tif (tentry.th32OwnerProcessID==the_rti.pid) {\n\t\t\t\t\t\tprocess_cpu_time += user + kernel;\n\t\t\t\t\t\tthe_rti.thread_count ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (Thread32Next(hSnapShot, &tentry));\n\t\t}\n\t\tCloseToolhelp32Snapshot(hSnapShot);\n\t}\n\n\tif (flags & GF_RTI_PROCESS_MEMORY) {\n\t\tHEAPLIST32 hlentry;\n\t\tHEAPENTRY32 hentry;\n\t\tthe_rti.process_memory = 0;\n\t\thlentry.dwSize = sizeof(HEAPLIST32);\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, the_rti.pid);\n\t\tif (hSnapShot && Heap32ListFirst(hSnapShot, &hlentry)) {\n\t\t\tdo {\n\t\t\t\thentry.dwSize = sizeof(hentry);\n\t\t\t\tif (Heap32First(hSnapShot, &hentry, hlentry.th32ProcessID, hlentry.th32HeapID)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tthe_rti.process_memory += hentry.dwBlockSize;\n\t\t\t\t\t} while (Heap32Next(hSnapShot, &hentry));\n\t\t\t\t}\n\t\t\t} while (Heap32ListNext(hSnapShot, &hlentry));\n\t\t}\n\t\tCloseToolhelp32Snapshot(hSnapShot);\n\t}\n\tSetProcPermissions(orig_perm);\n\ttotal_cpu_time /= 10;\n\tprocess_cpu_time /= 10;\n\n#else\n\t/*XP-SP1 and Win2003 servers only have GetSystemTimes support. This will give a better estimation\n\tof CPU usage since we can take into account the idle time*/\n\tif (MyGetSystemTimes) {\n\t\tu64 u_time;\n\t\tMyGetSystemTimes(&proc_idle_time, &proc_k_u_time, &u_time);\n\t\tproc_k_u_time += u_time;\n\t\tproc_idle_time /= 10;\n\t\tproc_k_u_time /= 10;\n\t}\n\t/*same rq for NtQuerySystemInformation*/\n\telse if (MyQuerySystemInfo) {\n\t\tDWORD ret;\n\t\tSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION info;\n\t\tMyQuerySystemInfo(0x8 /*SystemProcessorPerformanceInformation*/, &info, sizeof(info), &ret);\n\t\tif (ret && (ret<=sizeof(info))) {\n\t\t\tproc_idle_time = info.IdleTime.QuadPart / 10;\n\t\t\tproc_k_u_time = (info.KernelTime.QuadPart + info.UserTime.QuadPart) / 10;\n\t\t}\n\t}\n\t/*no special API available, ONLY FETCH TIMES if requested (may eat up some time)*/\n\telse if (flags & GF_RTI_ALL_PROCESSES_TIMES) {\n\t\tPROCESSENTRY32 pentry;\n\t\t/*get a snapshot of all running threads*/\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t\tif (!hSnapShot) return GF_FALSE;\n\t\tpentry.dwSize = sizeof(PROCESSENTRY32);\n\t\tif (Process32First(hSnapShot, &pentry)) {\n\t\t\tdo {\n\t\t\t\tHANDLE procH = NULL;\n\t\t\t\tif (pentry.th32ProcessID) procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pentry.th32ProcessID);\n\t\t\t\tif (procH && GetProcessTimes(procH, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user) ) {\n\t\t\t\t\tuser += kernel;\n\t\t\t\t\tproc_k_u_time += user;\n\t\t\t\t\tif (pentry.th32ProcessID==the_rti.pid) {\n\t\t\t\t\t\tprocess_k_u_time = user;\n\t\t\t\t\t\t//nb_threads = pentry.cntThreads;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (procH) CloseHandle(procH);\n\t\t\t} while (Process32Next(hSnapShot, &pentry));\n\t\t}\n\t\tCloseHandle(hSnapShot);\n\t\tproc_k_u_time /= 10;\n\t}\n\n\n\tif (!process_k_u_time) {\n\t\tHANDLE procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, the_rti.pid);\n\t\tif (procH && GetProcessTimes(procH, (FILETIME *) &creation, (FILETIME *) &exit, (FILETIME *) &kernel, (FILETIME *) &user) ) {\n\t\t\tprocess_k_u_time = user + kernel;\n\t\t}\n\t\tif (procH) CloseHandle(procH);\n\t\tif (!process_k_u_time) return GF_FALSE;\n\t}\n\tprocess_k_u_time /= 10;\n\n\t/*this won't cost a lot*/\n\tif (MyGetProcessMemoryInfo) {\n\t\tPROCESS_MEMORY_COUNTERS pmc;\n\t\tHANDLE procH = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, the_rti.pid);\n\t\tMyGetProcessMemoryInfo(procH, &pmc, sizeof (pmc));\n\t\tthe_rti.process_memory = pmc.WorkingSetSize;\n\t\tif (procH) CloseHandle(procH);\n\t}\n\t/*THIS IS VERY HEAVY (eats up mem and time) - only perform if requested*/\n\telse if (flags & GF_RTI_PROCESS_MEMORY) {\n\t\tHEAPLIST32 hlentry;\n\t\tHEAPENTRY32 hentry;\n\t\tthe_rti.process_memory = 0;\n\t\thlentry.dwSize = sizeof(HEAPLIST32);\n\t\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, the_rti.pid);\n\t\tif (hSnapShot && Heap32ListFirst(hSnapShot, &hlentry)) {\n\t\t\tdo {\n\t\t\t\thentry.dwSize = sizeof(hentry);\n\t\t\t\tif (Heap32First(&hentry, hlentry.th32ProcessID, hlentry.th32HeapID)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tthe_rti.process_memory += hentry.dwBlockSize;\n\t\t\t\t\t} while (Heap32Next(&hentry));\n\t\t\t\t}\n\t\t\t} while (Heap32ListNext(hSnapShot, &hlentry));\n\t\t}\n\t\tCloseHandle(hSnapShot);\n\t}\n#endif\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = entry_time - last_update_time;\n\t\tthe_rti.process_cpu_time_diff = (u32) ((process_k_u_time - last_process_k_u_time)/1000);\n\n#if defined(_WIN32_WCE)\n\t\tthe_rti.total_cpu_time_diff = (u32) ((total_cpu_time - last_total_k_u_time)/1000);\n\t\t/*we're not that accurate....*/\n\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration)\n\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\n\t\t/*rough values*/\n\t\tthe_rti.cpu_idle_time = the_rti.sampling_period_duration - the_rti.total_cpu_time_diff;\n\t\tif (!the_rti.sampling_period_duration) the_rti.sampling_period_duration=1;\n\t\tthe_rti.total_cpu_usage = (u32) (100 * the_rti.total_cpu_time_diff / the_rti.sampling_period_duration);\n\t\tif (the_rti.total_cpu_time_diff + the_rti.cpu_idle_time==0) the_rti.total_cpu_time_diff ++;\n\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / (the_rti.total_cpu_time_diff + the_rti.cpu_idle_time) );\n\n#else\n\t\t/*oops, we have no choice but to assume 100% cpu usage during this period*/\n\t\tif (!proc_k_u_time) {\n\t\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t\tproc_k_u_time = last_proc_k_u_time + the_rti.sampling_period_duration;\n\t\t\tthe_rti.cpu_idle_time = 0;\n\t\t\tthe_rti.total_cpu_usage = 100;\n\t\t\tif (the_rti.sampling_period_duration)\n\t\t\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / the_rti.sampling_period_duration);\n\t\t} else {\n\t\t\tu64 samp_sys_time, idle;\n\t\t\tthe_rti.total_cpu_time_diff = (u32) ((proc_k_u_time - last_proc_k_u_time)/1000);\n\n\t\t\t/*we're not that accurate....*/\n\t\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration) {\n\t\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\t\t\t}\n\n\t\t\tif (!proc_idle_time)\n\t\t\t\tproc_idle_time = last_proc_idle_time + (the_rti.sampling_period_duration - the_rti.total_cpu_time_diff);\n\n\t\t\tsamp_sys_time = proc_k_u_time - last_proc_k_u_time;\n\t\t\tidle = proc_idle_time - last_proc_idle_time;\n\t\t\tthe_rti.cpu_idle_time = (u32) (idle/1000);\n\t\t\tif (samp_sys_time) {\n\t\t\t\tthe_rti.total_cpu_usage = (u32) ( (samp_sys_time - idle) / (samp_sys_time / 100) );\n\t\t\t\tthe_rti.process_cpu_usage = (u32) (100*the_rti.process_cpu_time_diff / (samp_sys_time/1000));\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tlast_update_time = entry_time;\n\tlast_process_k_u_time = process_k_u_time;\n\n\tGlobalMemoryStatus(&ms);\n\tthe_rti.physical_memory = ms.dwTotalPhys;\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = (u64) gpac_allocated_memory;\n#endif\n\tthe_rti.physical_memory_avail = ms.dwAvailPhys;\n\n#if defined(_WIN32_WCE)\n\tlast_total_k_u_time = total_cpu_time;\n\tif (!the_rti.process_memory) the_rti.process_memory = mem_usage_at_startup - ms.dwAvailPhys;\n#else\n\tlast_proc_idle_time = proc_idle_time;\n\tlast_proc_k_u_time = proc_k_u_time;\n#endif\n\n\tif (!the_rti.gpac_memory) the_rti.gpac_memory = the_rti.process_memory;\n\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn GF_TRUE;\n}\n\n\n#elif defined(GPAC_CONFIG_DARWIN) && !defined(GPAC_IPHONE)\n\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <sys/vmmeter.h>\n#include <mach/mach_init.h>\n#include <mach/mach_host.h>\n#include <mach/mach_port.h>\n#include <mach/mach_traps.h>\n#include <mach/task_info.h>\n#include <mach/thread_info.h>\n#include <mach/thread_act.h>\n#include <mach/vm_region.h>\n#include <mach/vm_map.h>\n#include <mach/task.h>\n#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060\n#include <mach/shared_region.h>\n#else\n#include <mach/shared_memory_server.h>\n#endif\n#include <mach/mach_error.h>\n\nstatic u64 total_physical_memory = 0;\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tsize_t length;\n\tu32 entry_time, i, percent;\n\tint mib[6];\n\tu64 result;\n\tint pagesize;\n\tu64 process_u_k_time;\n\tdouble utime, stime;\n\tvm_statistics_data_t vmstat;\n\ttask_t task;\n\tkern_return_t error;\n\tthread_array_t thread_table;\n\tunsigned table_size;\n\tthread_basic_info_t thi;\n\tthread_basic_info_data_t thi_data;\n\tstruct task_basic_info ti;\n\tmach_msg_type_number_t count = HOST_VM_INFO_COUNT, size = sizeof(ti);\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn 0;\n\t}\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_PAGESIZE;\n\tlength = sizeof(pagesize);\n\tif (sysctl(mib, 2, &pagesize, &length, NULL, 0) < 0) {\n\t\treturn 0;\n\t}\n\n\tif (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS) {\n\t\treturn 0;\n\t}\n\n\tthe_rti.physical_memory = (vmstat.wire_count + vmstat.active_count + vmstat.inactive_count + vmstat.free_count)* pagesize;\n\tthe_rti.physical_memory_avail = vmstat.free_count * pagesize;\n\n\tif (!total_physical_memory) {\n\t\tmib[0] = CTL_HW;\n\t\tmib[1] = HW_MEMSIZE;\n\t\tlength = sizeof(u64);\n\t\tif (sysctl(mib, 2, &result, &length, NULL, 0) >= 0) {\n\t\t\ttotal_physical_memory = result;\n\t\t}\n\t}\n\tthe_rti.physical_memory = total_physical_memory;\n\n\terror = task_for_pid(mach_task_self(), the_rti.pid, &task);\n\tif (error) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get process task for PID %d: error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\n\terror = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&ti, &size);\n\tif (error) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get process task info (PID %d): error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\n\tpercent = 0;\n\tutime = ti.user_time.seconds + ti.user_time.microseconds * 1e-6;\n\tstime = ti.system_time.seconds + ti.system_time.microseconds * 1e-6;\n\terror = task_threads(task, &thread_table, &table_size);\n\tif (error != KERN_SUCCESS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] Cannot get threads task for PID %d: error %d\\n\", the_rti.pid, error));\n\t\treturn 0;\n\t}\n\tthi = &thi_data;\n\tfor (i = 0; i != table_size; ++i) {\n\t\tcount = THREAD_BASIC_INFO_COUNT;\n\t\terror = thread_info(thread_table[i], THREAD_BASIC_INFO, (thread_info_t)thi, &count);\n\t\tif (error != KERN_SUCCESS) {\n\t\t\tmach_error(\"[RTI] Unexpected thread_info() call return\", error);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[RTI] Unexpected thread info for PID %d\\n\", the_rti.pid));\n\t\t\tbreak;\n\t\t}\n\t\tif ((thi->flags & TH_FLAGS_IDLE) == 0) {\n\t\t\tutime += thi->user_time.seconds + thi->user_time.microseconds * 1e-6;\n\t\t\tstime += thi->system_time.seconds + thi->system_time.microseconds * 1e-6;\n\t\t\tpercent +=  (u32) (100 * (double)thi->cpu_usage / TH_USAGE_SCALE);\n\t\t}\n\t}\n\tvm_deallocate(mach_task_self(), (vm_offset_t)thread_table, table_size * sizeof(thread_array_t));\n\tmach_port_deallocate(mach_task_self(), task);\n\n\tprocess_u_k_time = utime + stime;\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = (entry_time - last_update_time);\n\t\tthe_rti.process_cpu_time_diff = (process_u_k_time - last_process_k_u_time) * 10;\n\n\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t/*TODO*/\n\t\tthe_rti.cpu_idle_time = 0;\n\t\tthe_rti.total_cpu_usage = 0;\n\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\n\t\tthe_rti.process_cpu_usage = percent;\n\t} else {\n\t\tmem_at_startup = the_rti.physical_memory_avail;\n\t}\n\tthe_rti.process_memory = mem_at_startup - the_rti.physical_memory_avail;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = gpac_allocated_memory;\n#endif\n\n\tlast_process_k_u_time = process_u_k_time;\n\tlast_cpu_idle_time = 0;\n\tlast_update_time = entry_time;\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn 1;\n}\n\n//linux\n#else\n\nBool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tu32 entry_time;\n\tu64 process_u_k_time;\n\tu32 u_k_time, idle_time;\n#if 0\n\tchar szProc[100];\n#endif\n\tchar line[2048];\n\tFILE *f;\n\n\tassert(sys_init);\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn 0;\n\t}\n\n\tu_k_time = idle_time = 0;\n\tf = gf_fopen(\"/proc/stat\", \"r\");\n\tif (f) {\n\t\tu32 k_time, nice_time, u_time;\n\t\tif (fgets(line, 128, f) != NULL) {\n\t\t\tif (sscanf(line, \"cpu  %u %u %u %u\\n\", &u_time, &k_time, &nice_time, &idle_time) == 4) {\n\t\t\t\tu_k_time = u_time + k_time + nice_time;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t}\n\n\tprocess_u_k_time = 0;\n\tthe_rti.process_memory = 0;\n\n\t/*FIXME? under LinuxThreads this will only fetch stats for the calling thread, we would have to enumerate /proc to get\n\tthe complete CPU usage of all therads of the process...*/\n#if 0\n\tsprintf(szProc, \"/proc/%d/stat\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\tfflush(f);\n\t\tif (fgets(line, 2048, f) != NULL) {\n\t\t\tchar state;\n\t\t\tchar *start;\n\t\t\tlong cutime, cstime, priority, nice, itrealvalue, rss;\n\t\t\tint exit_signal, processor;\n\t\t\tunsigned long flags, minflt, cminflt, majflt, cmajflt, utime, stime,starttime, vsize, rlim, startcode, endcode, startstack, kstkesp, kstkeip, signal, blocked, sigignore, sigcatch, wchan, nswap, cnswap, rem;\n\t\t\tint ppid, pgrp ,session, tty_nr, tty_pgrp, res;\n\t\t\tstart = strchr(line, ')');\n\t\t\tif (start) start += 2;\n\t\t\telse {\n\t\t\t\tstart = strchr(line, ' ');\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tres = sscanf(start,\"%c %d %d %d %d %d %lu %lu %lu %lu \\\n%lu %lu %lu %ld %ld %ld %ld %ld %ld %lu \\\n%lu %ld %lu %lu %lu %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %d %d\",\n\t\t\t             &state, &ppid, &pgrp, &session, &tty_nr, &tty_pgrp, &flags, &minflt, &cminflt, &majflt,\n\t\t\t             &cmajflt, &utime, &stime, &cutime, &cstime, &priority, &nice, &itrealvalue, &rem, &starttime,\n\t\t\t             &vsize, &rss, &rlim, &startcode, &endcode, &startstack, &kstkesp, &kstkeip, &signal, &blocked,\n\t\t\t             &sigignore, &sigcatch, &wchan, &nswap, &cnswap, &exit_signal, &processor);\n\n\t\t\tif (res) process_u_k_time = (u64) (cutime + cstime);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] PROC %s parse error\\n\", szProc));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] error reading pid/stat\\n\\n\", szProc));\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n\tsprintf(szProc, \"/proc/%d/status\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"VmSize:\", 7)) {\n\t\t\t\tsscanf(line, \"VmSize: %\"LLD\" kB\",  &the_rti.process_memory);\n\t\t\t\tthe_rti.process_memory *= 1024;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n#endif\n\n\n#ifndef GPAC_IPHONE\n\tthe_rti.physical_memory = the_rti.physical_memory_avail = 0;\n\tf = gf_fopen(\"/proc/meminfo\", \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"MemTotal:\", 9)) {\n\t\t\t\tsscanf(line, \"MemTotal: \"LLU\" kB\",  &the_rti.physical_memory);\n\t\t\t\tthe_rti.physical_memory *= 1024;\n\t\t\t} else if (!strnicmp(line, \"MemFree:\", 8)) {\n\t\t\t\tsscanf(line, \"MemFree: \"LLU\" kB\",  &the_rti.physical_memory_avail);\n\t\t\t\tthe_rti.physical_memory_avail *= 1024;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open /proc/meminfo\\n\"));\n\t}\n#endif\n\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = (entry_time - last_update_time);\n\t\tthe_rti.process_cpu_time_diff = (u32) (process_u_k_time - last_process_k_u_time) * 10;\n\n\t\t/*oops, we have no choice but to assume 100% cpu usage during this period*/\n\t\tif (!u_k_time) {\n\t\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t\tu_k_time = (u32) (last_cpu_u_k_time + the_rti.sampling_period_duration);\n\t\t\tthe_rti.cpu_idle_time = 0;\n\t\t\tthe_rti.total_cpu_usage = 100;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / the_rti.sampling_period_duration);\n\t\t} else {\n\t\t\tu64 samp_sys_time;\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.total_cpu_time_diff = (u32) (u_k_time - last_cpu_u_k_time)*10;\n\n\t\t\t/*we're not that accurate....*/\n\t\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration)\n\t\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\n\n\t\t\tif (!idle_time) idle_time = (the_rti.sampling_period_duration - the_rti.total_cpu_time_diff)/10;\n\t\t\tsamp_sys_time = u_k_time - last_cpu_u_k_time;\n\t\t\tthe_rti.cpu_idle_time = (u32) (idle_time - last_cpu_idle_time);\n\t\t\tthe_rti.total_cpu_usage = (u32) ( 100 * samp_sys_time / (the_rti.cpu_idle_time + samp_sys_time ) );\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.cpu_idle_time *= 10;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / (the_rti.cpu_idle_time + 10*samp_sys_time ) );\n\t\t}\n\t} else {\n\t\tmem_at_startup = the_rti.physical_memory_avail;\n\t}\n\tthe_rti.process_memory = mem_at_startup - the_rti.physical_memory_avail;\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = gpac_allocated_memory;\n#endif\n\n\tlast_process_k_u_time = process_u_k_time;\n\tlast_cpu_idle_time = idle_time;\n\tlast_cpu_u_k_time = u_k_time;\n\tlast_update_time = entry_time;\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn 1;\n}\n\n#endif\n\nGF_EXPORT\nBool gf_sys_get_rti(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tBool res = gf_sys_get_rti_os(refresh_time_ms, rti, flags);\n\tif (res) {\n\t\tif (!rti->process_memory) rti->process_memory = memory_at_gpac_startup - rti->physical_memory_avail;\n\t\tif (!rti->gpac_memory) rti->gpac_memory = memory_at_gpac_startup - rti->physical_memory_avail;\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nchar * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\n\troot_tmp = gf_strdup(szPath);\n\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\n\tstrcat(szPath, \"gpac_cache\");\n\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}\n\n\nGF_EXPORT\nBool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}\n\n\nstruct GF_GlobalLock {\n\tconst char * resourceName;\n};\n\n\n#ifndef WIN32\n#define CPF_CLOEXEC 1\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nstruct _GF_GlobalLock_opaque {\n\tchar * resourceName;\n\tchar * pidFile;\n\tint fd;\n};\n\nGF_GlobalLock * gf_create_PID_file( const char * resourceName )\n{\n\tconst char * prefix = \"/gpac_lock_\";\n\tconst char * dir = gf_get_default_cache_directory();\n\tchar * pidfile;\n\tint flags;\n\tint status;\n\tpidfile = gf_malloc(strlen(dir)+strlen(prefix)+strlen(resourceName)+1);\n\tstrcpy(pidfile, dir);\n\tstrcat(pidfile, prefix);\n\t/* Use only valid names for file */\n\t{\n\t\tconst char *res;\n\t\tchar * pid = &(pidfile[strlen(pidfile)]);\n\t\tfor (res = resourceName; *res ; res++) {\n\t\t\tif (*res >= 'A' && *res <= 'z')\n\t\t\t\t*pid = * res;\n\t\t\telse\n\t\t\t\t*pid = '_';\n\t\t\tpid++;\n\t\t}\n\t\t*pid = '\\0';\n\t}\n\tint fd = open(pidfile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t\tgoto exit;\n\t/* Get the flags */\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags == -1) {\n\t\tgoto exit;\n\t}\n\t/* Set FD_CLOEXEC, so exclusive lock will be removed on exit, so even if GPAC crashes,\n\t* lock will be allowed for next instance */\n\tflags |= FD_CLOEXEC;\n\t/* Now, update the flags */\n\tif (fcntl(fd, F_SETFD, flags) == -1) {\n\t\tgoto exit;\n\t}\n\n\t/* Now, we try to lock the file */\n\t{\n\t\tstruct flock fl;\n\t\tfl.l_type = F_WRLCK;\n\t\tfl.l_whence = SEEK_SET;\n\t\tfl.l_start = fl.l_len = 0;\n\t\tstatus = fcntl(fd, F_SETLK, &fl);\n\t}\n\n\tif (status == -1) {\n\t\tgoto exit;\n\t}\n\n\tif (ftruncate(fd, 0) == -1) {\n\t\tgoto exit;\n\t}\n\t/* Write the PID */\n\t{\n\t\tint sz = 100;\n\t\tchar * buf = gf_malloc( sz );\n\t\tsz = snprintf(buf, sz, \"%ld\\n\", (long) getpid());\n\t\tif (write(fd, buf, sz) != sz) {\n\t\t\tgf_free(buf);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tsync();\n\t{\n\t\tGF_GlobalLock * lock = gf_malloc( sizeof(GF_GlobalLock));\n\t\tlock->resourceName = gf_strdup(resourceName);\n\t\tlock->pidFile = pidfile;\n\t\tlock->fd = fd;\n\t\treturn lock;\n\t}\nexit:\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn NULL;\n}\n#else /* WIN32 */\nstruct _GF_GlobalLock_opaque {\n\tchar * resourceName;\n\tHANDLE hMutex; /*a named mutex is a system-mode object on windows*/\n};\n#endif\n\nGF_EXPORT\nGF_GlobalLock * gf_global_resource_lock(const char * resourceName) {\n#ifdef WIN32\n#ifdef _WIN32_WCE\n\tunsigned short sWResourceName[MAX_PATH];\n#endif\n\tDWORD lastErr;\n\tGF_GlobalLock *lock = gf_malloc(sizeof(GF_GlobalLock));\n\tlock->resourceName = gf_strdup(resourceName);\n\n\t/*first ensure mutex is created*/\n#ifdef _WIN32_WCE\n\tCE_CharToWide((char *)resourceName, sWResourceName);\n\tlock->hMutex = CreateMutex(NULL, TRUE, sWResourceName);\n#else\n\tlock->hMutex = CreateMutex(NULL, TRUE, resourceName);\n#endif\n\tlastErr = GetLastError();\n\tif (lastErr && lastErr == ERROR_ALREADY_EXISTS)\n\t\treturn NULL;\n\tif (!lock->hMutex)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't create mutex for global lock: %d\\n\", lastErr));\n\t\treturn NULL;\n\t}\n\n\t/*then lock it*/\n\tswitch (WaitForSingleObject(lock->hMutex, INFINITE)) {\n\tcase WAIT_ABANDONED:\n\tcase WAIT_TIMEOUT:\n\t\tassert(0); /*serious error: someone has modified the object elsewhere*/\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't get the global lock\\n\"));\n\t\tgf_global_resource_unlock(lock);\n\t\treturn NULL;\n\t}\n\n\treturn lock;\n#else /* WIN32 */\n\treturn gf_create_PID_file(resourceName);\n#endif /* WIN32 */\n}\n\n/*!\n * Unlock a previouly locked resource\n * \\param lock The resource to unlock\n * \\return GF_OK if evertything went fine\n */\nGF_EXPORT\nGF_Err gf_global_resource_unlock(GF_GlobalLock * lock) {\n\tif (!lock)\n\t\treturn GF_BAD_PARAM;\n#ifndef WIN32\n\tassert( lock->pidFile);\n\tclose(lock->fd);\n\tif (unlink(lock->pidFile))\n\t\tperror(\"Failed to unlink lock file\");\n\tgf_free(lock->pidFile);\n\tlock->pidFile = NULL;\n\tlock->fd = -1;\n#else /* WIN32 */\n\t{\n\t\t/*MSDN: \"The mutex object is destroyed when its last handle has been closed.\"*/\n\t\tBOOL ret = ReleaseMutex(lock->hMutex);\n\t\tif (!ret) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't release mutex for global lock: %d\\n\", err));\n\t\t}\n\t\tret = CloseHandle(lock->hMutex);\n\t\tif (!ret) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MUTEX, (\"[Mutex] Couldn't destroy mutex for global lock: %d\\n\", err));\n\t\t}\n\t}\n#endif\n\tif (lock->resourceName)\n\t\tgf_free(lock->resourceName);\n\tlock->resourceName = NULL;\n\tgf_free(lock);\n\treturn GF_OK;\n}\n\n#ifdef GPAC_ANDROID\n\nfm_callback_func fm_cbk = NULL;\nstatic void *fm_cbk_obj = NULL;\n\nvoid gf_fm_request_set_callback(void *cbk_obj, fm_callback_func cbk_func) {\n\tfm_cbk = cbk_func;\n\tfm_cbk_obj = cbk_obj;\n}\n\nvoid gf_fm_request_call(u32 type, u32 param, int *value) {\n\tif (fm_cbk)\n\t\tfm_cbk(fm_cbk_obj, type, param, value);\n}\n\n#endif //GPAC_ANDROID\n\nGF_EXPORT\ns32 gf_gettimeofday(struct timeval *tp, void *tz) {\n\treturn gettimeofday(tp, tz);\n}\n\n\nstatic u32 ntp_shift = GF_NTP_SEC_1900_TO_1970;\n\nGF_EXPORT\nvoid gf_net_set_ntp_shift(s32 shift)\n{\n\tntp_shift = GF_NTP_SEC_1900_TO_1970 + shift;\n}\n\n/*\n\t\tNTP tools\n*/\nGF_EXPORT\nvoid gf_net_get_ntp(u32 *sec, u32 *frac)\n{\n\tu64 frac_part;\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\tif (sec) {\n\t\t*sec = (u32) (now.tv_sec) + ntp_shift;\n\t}\n\n\tif (frac) {\n\t\tfrac_part = now.tv_usec * 0xFFFFFFFFULL;\n\t\tfrac_part /= 1000000;\n\t\t*frac = (u32) ( frac_part );\n\t}\n}\n\nGF_EXPORT\nu64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}\n\nGF_EXPORT\ns32 gf_net_get_ntp_diff_ms(u64 ntp)\n{\n\tu32 remote_s, remote_f, local_s, local_f;\n\ts64 local, remote;\n\n\tremote_s = (ntp >> 32);\n\tremote_f = (u32) (ntp & 0xFFFFFFFFULL);\n\tgf_net_get_ntp(&local_s, &local_f);\n\n\tlocal = local_s;\n\tlocal *= 1000;\n\tlocal += ((u64) local_f)*1000 / 0xFFFFFFFFULL;\n\n\tremote = remote_s;\n\tremote *= 1000;\n\tremote += ((u64) remote_f)*1000 / 0xFFFFFFFFULL;\n\n\treturn (s32) (local - remote);\n}\n\n\n\nGF_EXPORT\ns32 gf_net_get_timezone()\n{\n#if defined(_WIN32_WCE)\n\treturn 0;\n#else\n\t//this has been commented due to some reports of broken implementation on some systems ...\n\t//\t\ts32 val = timezone;\n\t//\t\treturn val;\n\n\n\t/*FIXME - avoid errors at midnight when estimating timezone this does not work !!*/\n\ts32 t_timezone;\n\tstruct tm t_gmt, t_local;\n\ttime_t t_time;\n\tt_time = time(NULL);\n\tt_gmt = *gmtime(&t_time);\n\tt_local = *localtime(&t_time);\n\n\tt_timezone = (t_gmt.tm_hour - t_local.tm_hour) * 3600 + (t_gmt.tm_min - t_local.tm_min) * 60;\n\treturn t_timezone;\n#endif\n\n}\n\n//no mkgmtime on mingw..., use our own\n#if (defined(WIN32) && defined(__GNUC__))\n\nstatic Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\tstatic const u32 days_per_month[2][12] = {\n\t\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n\t\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n\t};\n\ttime_t time=0;\n\tint i;\n\n\tfor (i=70; i<tm->tm_year; i++) {\n\t\ttime += leap_year(i) ? 366 : 365;\n\t}\n\n\tfor (i=0; i<tm->tm_mon; ++i) {\n\t\ttime += days_per_month[leap_year(tm->tm_year)][i];\n\t}\n\ttime += tm->tm_mday - 1;\n\ttime *= 24;\n\ttime += tm->tm_hour;\n\ttime *= 60;\n\ttime += tm->tm_min;\n\ttime *= 60;\n\ttime += tm->tm_sec;\n\treturn time;\n}\n\n#elif defined(WIN32)\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn  _mkgmtime(tm);\n}\n\n#elif defined(GPAC_ANDROID)\n#include <time64.h>\n#if defined(__LP64__)\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn timegm64(tm);\n}\n#else\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\tstatic const time_t kTimeMax = ~(1L << (sizeof(time_t) * CHAR_BIT - 1));\n\tstatic const time_t kTimeMin = (1L << (sizeof(time_t) * CHAR_BIT - 1));\n\ttime64_t result = timegm64(tm);\n\tif (result < kTimeMin || result > kTimeMax)\n\t\treturn -1;\n\treturn result;\n}\n#endif\n\n#else\n\nstatic time_t gf_mktime_utc(struct tm *tm)\n{\n\treturn timegm(tm);\n}\n\n#endif\n\nGF_EXPORT\nu64 gf_net_parse_date(const char *val)\n{\n\tu64 current_time;\n\tchar szDay[50], szMonth[50];\n\tu32 year, month, day, h, m, s, ms;\n\ts32 oh, om;\n\tFloat secs;\n\tBool neg_time_zone = GF_FALSE;\n\n#ifdef _WIN32_WCE\n\tSYSTEMTIME syst;\n\tFILETIME filet;\n#else\n\tstruct tm t;\n\tmemset(&t, 0, sizeof(struct tm));\n#endif\n\n\tszDay[0] = szMonth[0] = 0;\n\tyear = month = day = h = m = s = 0;\n\toh = om = 0;\n\tsecs = 0;\n\n\tif (sscanf(val, \"%d-%d-%dT%d:%d:%gZ\", &year, &month, &day, &h, &m, &secs) == 6) {\n\t}\n\telse if (sscanf(val, \"%d-%d-%dT%d:%d:%g-%d:%d\", &year, &month, &day, &h, &m, &secs, &oh, &om) == 8) {\n\t\tneg_time_zone = GF_TRUE;\n\t}\n\telse if (sscanf(val, \"%d-%d-%dT%d:%d:%g+%d:%d\", &year, &month, &day, &h, &m, &secs, &oh, &om) == 8) {\n\t}\n\telse if (sscanf(val, \"%3s, %d %3s %d %d:%d:%d\", szDay, &day, szMonth, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse if (sscanf(val, \"%9s, %d-%3s-%d %02d:%02d:%02d GMT\", szDay, &day, szMonth, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse if (sscanf(val, \"%3s %3s %d %02d:%02d:%02d %d\", szDay, szMonth, &day, &year, &h, &m, &s)==7) {\n\t\tsecs  = (Float) s;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[Core] Cannot parse date string %s\\n\", val));\n\t\treturn 0;\n\t}\n\n\tif (month) {\n\t\tmonth -= 1;\n\t} else {\n\t\tif (!strcmp(szMonth, \"Jan\")) month = 0;\n\t\telse if (!strcmp(szMonth, \"Feb\")) month = 1;\n\t\telse if (!strcmp(szMonth, \"Mar\")) month = 2;\n\t\telse if (!strcmp(szMonth, \"Apr\")) month = 3;\n\t\telse if (!strcmp(szMonth, \"May\")) month = 4;\n\t\telse if (!strcmp(szMonth, \"Jun\")) month = 5;\n\t\telse if (!strcmp(szMonth, \"Jul\")) month = 6;\n\t\telse if (!strcmp(szMonth, \"Aug\")) month = 7;\n\t\telse if (!strcmp(szMonth, \"Sep\")) month = 8;\n\t\telse if (!strcmp(szMonth, \"Oct\")) month = 9;\n\t\telse if (!strcmp(szMonth, \"Nov\")) month = 10;\n\t\telse if (!strcmp(szMonth, \"Dec\")) month = 11;\n\t}\n\n#ifdef _WIN32_WCE\n\tmemset(&syst, 0, sizeof(SYSTEMTIME));\n\tsyst.wYear = year;\n\tsyst.wMonth = month + 1;\n\tsyst.wDay = day;\n\tsyst.wHour = h;\n\tsyst.wMinute = m;\n\tsyst.wSecond = (u32) secs;\n\tSystemTimeToFileTime(&syst, &filet);\n\tcurrent_time = (u64) ((*(LONGLONG *) &filet - TIMESPEC_TO_FILETIME_OFFSET) / 10000000);\n\n#else\n\n\tt.tm_year = year>1000 ? year-1900 : year;\n\tt.tm_mday = day;\n\tt.tm_hour = h;\n\tt.tm_min = m;\n\tt.tm_sec = (u32) secs;\n\tt.tm_mon = month;\n\n\tif (strlen(szDay) ) {\n\t\tif (!strcmp(szDay, \"Mon\") || !strcmp(szDay, \"Monday\")) t.tm_wday = 0;\n\t\telse if (!strcmp(szDay, \"Tue\") || !strcmp(szDay, \"Tuesday\")) t.tm_wday = 1;\n\t\telse if (!strcmp(szDay, \"Wed\") || !strcmp(szDay, \"Wednesday\")) t.tm_wday = 2;\n\t\telse if (!strcmp(szDay, \"Thu\") || !strcmp(szDay, \"Thursday\")) t.tm_wday = 3;\n\t\telse if (!strcmp(szDay, \"Fri\") || !strcmp(szDay, \"Friday\")) t.tm_wday = 4;\n\t\telse if (!strcmp(szDay, \"Sat\") || !strcmp(szDay, \"Saturday\")) t.tm_wday = 5;\n\t\telse if (!strcmp(szDay, \"Sun\") || !strcmp(szDay, \"Sunday\")) t.tm_wday = 6;\n\t}\n\n\tcurrent_time = gf_mktime_utc(&t);\n\n\tif ((s64) current_time == -1) {\n\t\t//use 1 ms\n\t\treturn 1;\n\t}\n\tif (current_time == 0) {\n\t\t//use 1 ms\n\t\treturn 1;\n\t}\n\n#endif\n\n\tif (om || oh) {\n\t\ts32 diff = (60*oh + om)*60;\n\t\tif (neg_time_zone) diff = -diff;\n\t\tcurrent_time = current_time + diff;\n\t}\n\tcurrent_time *= 1000;\n\tms = (u32) ( (secs - (u32) secs) * 1000);\n\treturn current_time + ms;\n}\n\nGF_EXPORT\nu64 gf_net_get_utc()\n{\n\tu64 current_time;\n\tDouble msec;\n\tu32 sec, frac;\n\n\tgf_net_get_ntp(&sec, &frac);\n\tcurrent_time = sec - GF_NTP_SEC_1900_TO_1970;\n\tcurrent_time *= 1000;\n\tmsec = frac*1000.0;\n\tmsec /= 0xFFFFFFFF;\n\tcurrent_time += (u64) msec;\n\treturn current_time;\n}\n\n\n\nGF_EXPORT\nGF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tif (i > 15) {\n\t\t\t\t// force error check below\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n"], "filenames": ["src/utils/os_divers.c"], "buggy_code_start_loc": [1990], "buggy_code_end_loc": [1992], "fixing_code_start_loc": [1991], "fixing_code_end_loc": [1999], "type": "CWE-787", "message": "gf_bin128_parse in utils/os_divers.c in GPAC 0.7.1 has a buffer overflow issue for the crypt feature when encountering a crafted_drm_file.xml file.", "other": {"cve": {"id": "CVE-2019-11222", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-15T12:31:36.507", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gf_bin128_parse in utils/os_divers.c in GPAC 0.7.1 has a buffer overflow issue for the crypt feature when encountering a crafted_drm_file.xml file."}, {"lang": "es", "value": "gf_bin128_parse in utils/os_divers.c en GPAC 0.7.1 tiene un problema de desbordamiento de b\u00fafer para la funcionalidad criptogr\u00e1fica cuando se encuentra con un archivo crafted_drm_file.xml."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "2CC18384-9350-47D7-A07D-C7D29622AE9E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/f3698bb1bce62402805c3fda96551a23101a32f9", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1204", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1205", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/f3698bb1bce62402805c3fda96551a23101a32f9"}}