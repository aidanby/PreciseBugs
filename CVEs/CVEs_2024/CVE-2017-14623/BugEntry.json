{"buggy_code": ["// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ldap\n\nimport (\n\t\"errors\"\n\n\t\"gopkg.in/asn1-ber.v1\"\n)\n\n// SimpleBindRequest represents a username/password bind operation\ntype SimpleBindRequest struct {\n\t// Username is the name of the Directory object that the client wishes to bind as\n\tUsername string\n\t// Password is the credentials to bind with\n\tPassword string\n\t// Controls are optional controls to send with the bind request\n\tControls []Control\n}\n\n// SimpleBindResult contains the response from the server\ntype SimpleBindResult struct {\n\tControls []Control\n}\n\n// NewSimpleBindRequest returns a bind request\nfunc NewSimpleBindRequest(username string, password string, controls []Control) *SimpleBindRequest {\n\treturn &SimpleBindRequest{\n\t\tUsername: username,\n\t\tPassword: password,\n\t\tControls: controls,\n\t}\n}\n\nfunc (bindRequest *SimpleBindRequest) encode() *ber.Packet {\n\trequest := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationBindRequest, nil, \"Bind Request\")\n\trequest.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, 3, \"Version\"))\n\trequest.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, bindRequest.Username, \"User Name\"))\n\trequest.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, bindRequest.Password, \"Password\"))\n\n\trequest.AppendChild(encodeControls(bindRequest.Controls))\n\n\treturn request\n}\n\n// SimpleBind performs the simple bind operation defined in the given request\nfunc (l *Conn) SimpleBind(simpleBindRequest *SimpleBindRequest) (*SimpleBindResult, error) {\n\tpacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"LDAP Request\")\n\tpacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, l.nextMessageID(), \"MessageID\"))\n\tencodedBindRequest := simpleBindRequest.encode()\n\tpacket.AppendChild(encodedBindRequest)\n\n\tif l.Debug {\n\t\tber.PrintPacket(packet)\n\t}\n\n\tmsgCtx, err := l.sendMessage(packet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.finishMessage(msgCtx)\n\n\tpacketResponse, ok := <-msgCtx.responses\n\tif !ok {\n\t\treturn nil, NewError(ErrorNetwork, errors.New(\"ldap: response channel closed\"))\n\t}\n\tpacket, err = packetResponse.ReadPacket()\n\tl.Debug.Printf(\"%d: got response %p\", msgCtx.id, packet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif l.Debug {\n\t\tif err := addLDAPDescriptions(packet); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tber.PrintPacket(packet)\n\t}\n\n\tresult := &SimpleBindResult{\n\t\tControls: make([]Control, 0),\n\t}\n\n\tif len(packet.Children) == 3 {\n\t\tfor _, child := range packet.Children[2].Children {\n\t\t\tresult.Controls = append(result.Controls, DecodeControl(child))\n\t\t}\n\t}\n\n\tresultCode, resultDescription := getLDAPResultCode(packet)\n\tif resultCode != 0 {\n\t\treturn result, NewError(resultCode, errors.New(resultDescription))\n\t}\n\n\treturn result, nil\n}\n\n// Bind performs a bind with the given username and password\nfunc (l *Conn) Bind(username, password string) error {\n\tpacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"LDAP Request\")\n\tpacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, l.nextMessageID(), \"MessageID\"))\n\tbindRequest := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationBindRequest, nil, \"Bind Request\")\n\tbindRequest.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, 3, \"Version\"))\n\tbindRequest.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, username, \"User Name\"))\n\tbindRequest.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, password, \"Password\"))\n\tpacket.AppendChild(bindRequest)\n\n\tif l.Debug {\n\t\tber.PrintPacket(packet)\n\t}\n\n\tmsgCtx, err := l.sendMessage(packet)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer l.finishMessage(msgCtx)\n\n\tpacketResponse, ok := <-msgCtx.responses\n\tif !ok {\n\t\treturn NewError(ErrorNetwork, errors.New(\"ldap: response channel closed\"))\n\t}\n\tpacket, err = packetResponse.ReadPacket()\n\tl.Debug.Printf(\"%d: got response %p\", msgCtx.id, packet)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif l.Debug {\n\t\tif err := addLDAPDescriptions(packet); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tber.PrintPacket(packet)\n\t}\n\n\tresultCode, resultDescription := getLDAPResultCode(packet)\n\tif resultCode != 0 {\n\t\treturn NewError(resultCode, errors.New(resultDescription))\n\t}\n\n\treturn nil\n}\n", "package ldap\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/asn1-ber.v1\"\n)\n\n// LDAP Result Codes\nconst (\n\tLDAPResultSuccess                      = 0\n\tLDAPResultOperationsError              = 1\n\tLDAPResultProtocolError                = 2\n\tLDAPResultTimeLimitExceeded            = 3\n\tLDAPResultSizeLimitExceeded            = 4\n\tLDAPResultCompareFalse                 = 5\n\tLDAPResultCompareTrue                  = 6\n\tLDAPResultAuthMethodNotSupported       = 7\n\tLDAPResultStrongAuthRequired           = 8\n\tLDAPResultReferral                     = 10\n\tLDAPResultAdminLimitExceeded           = 11\n\tLDAPResultUnavailableCriticalExtension = 12\n\tLDAPResultConfidentialityRequired      = 13\n\tLDAPResultSaslBindInProgress           = 14\n\tLDAPResultNoSuchAttribute              = 16\n\tLDAPResultUndefinedAttributeType       = 17\n\tLDAPResultInappropriateMatching        = 18\n\tLDAPResultConstraintViolation          = 19\n\tLDAPResultAttributeOrValueExists       = 20\n\tLDAPResultInvalidAttributeSyntax       = 21\n\tLDAPResultNoSuchObject                 = 32\n\tLDAPResultAliasProblem                 = 33\n\tLDAPResultInvalidDNSyntax              = 34\n\tLDAPResultAliasDereferencingProblem    = 36\n\tLDAPResultInappropriateAuthentication  = 48\n\tLDAPResultInvalidCredentials           = 49\n\tLDAPResultInsufficientAccessRights     = 50\n\tLDAPResultBusy                         = 51\n\tLDAPResultUnavailable                  = 52\n\tLDAPResultUnwillingToPerform           = 53\n\tLDAPResultLoopDetect                   = 54\n\tLDAPResultNamingViolation              = 64\n\tLDAPResultObjectClassViolation         = 65\n\tLDAPResultNotAllowedOnNonLeaf          = 66\n\tLDAPResultNotAllowedOnRDN              = 67\n\tLDAPResultEntryAlreadyExists           = 68\n\tLDAPResultObjectClassModsProhibited    = 69\n\tLDAPResultAffectsMultipleDSAs          = 71\n\tLDAPResultOther                        = 80\n\n\tErrorNetwork            = 200\n\tErrorFilterCompile      = 201\n\tErrorFilterDecompile    = 202\n\tErrorDebugging          = 203\n\tErrorUnexpectedMessage  = 204\n\tErrorUnexpectedResponse = 205\n)\n\n// LDAPResultCodeMap contains string descriptions for LDAP error codes\nvar LDAPResultCodeMap = map[uint8]string{\n\tLDAPResultSuccess:                      \"Success\",\n\tLDAPResultOperationsError:              \"Operations Error\",\n\tLDAPResultProtocolError:                \"Protocol Error\",\n\tLDAPResultTimeLimitExceeded:            \"Time Limit Exceeded\",\n\tLDAPResultSizeLimitExceeded:            \"Size Limit Exceeded\",\n\tLDAPResultCompareFalse:                 \"Compare False\",\n\tLDAPResultCompareTrue:                  \"Compare True\",\n\tLDAPResultAuthMethodNotSupported:       \"Auth Method Not Supported\",\n\tLDAPResultStrongAuthRequired:           \"Strong Auth Required\",\n\tLDAPResultReferral:                     \"Referral\",\n\tLDAPResultAdminLimitExceeded:           \"Admin Limit Exceeded\",\n\tLDAPResultUnavailableCriticalExtension: \"Unavailable Critical Extension\",\n\tLDAPResultConfidentialityRequired:      \"Confidentiality Required\",\n\tLDAPResultSaslBindInProgress:           \"Sasl Bind In Progress\",\n\tLDAPResultNoSuchAttribute:              \"No Such Attribute\",\n\tLDAPResultUndefinedAttributeType:       \"Undefined Attribute Type\",\n\tLDAPResultInappropriateMatching:        \"Inappropriate Matching\",\n\tLDAPResultConstraintViolation:          \"Constraint Violation\",\n\tLDAPResultAttributeOrValueExists:       \"Attribute Or Value Exists\",\n\tLDAPResultInvalidAttributeSyntax:       \"Invalid Attribute Syntax\",\n\tLDAPResultNoSuchObject:                 \"No Such Object\",\n\tLDAPResultAliasProblem:                 \"Alias Problem\",\n\tLDAPResultInvalidDNSyntax:              \"Invalid DN Syntax\",\n\tLDAPResultAliasDereferencingProblem:    \"Alias Dereferencing Problem\",\n\tLDAPResultInappropriateAuthentication:  \"Inappropriate Authentication\",\n\tLDAPResultInvalidCredentials:           \"Invalid Credentials\",\n\tLDAPResultInsufficientAccessRights:     \"Insufficient Access Rights\",\n\tLDAPResultBusy:                         \"Busy\",\n\tLDAPResultUnavailable:                  \"Unavailable\",\n\tLDAPResultUnwillingToPerform:           \"Unwilling To Perform\",\n\tLDAPResultLoopDetect:                   \"Loop Detect\",\n\tLDAPResultNamingViolation:              \"Naming Violation\",\n\tLDAPResultObjectClassViolation:         \"Object Class Violation\",\n\tLDAPResultNotAllowedOnNonLeaf:          \"Not Allowed On Non Leaf\",\n\tLDAPResultNotAllowedOnRDN:              \"Not Allowed On RDN\",\n\tLDAPResultEntryAlreadyExists:           \"Entry Already Exists\",\n\tLDAPResultObjectClassModsProhibited:    \"Object Class Mods Prohibited\",\n\tLDAPResultAffectsMultipleDSAs:          \"Affects Multiple DSAs\",\n\tLDAPResultOther:                        \"Other\",\n\n\tErrorNetwork:            \"Network Error\",\n\tErrorFilterCompile:      \"Filter Compile Error\",\n\tErrorFilterDecompile:    \"Filter Decompile Error\",\n\tErrorDebugging:          \"Debugging Error\",\n\tErrorUnexpectedMessage:  \"Unexpected Message\",\n\tErrorUnexpectedResponse: \"Unexpected Response\",\n}\n\nfunc getLDAPResultCode(packet *ber.Packet) (code uint8, description string) {\n\tif packet == nil {\n\t\treturn ErrorUnexpectedResponse, \"Empty packet\"\n\t} else if len(packet.Children) >= 2 {\n\t\tresponse := packet.Children[1]\n\t\tif response == nil {\n\t\t\treturn ErrorUnexpectedResponse, \"Empty response in packet\"\n\t\t}\n\t\tif response.ClassType == ber.ClassApplication && response.TagType == ber.TypeConstructed && len(response.Children) >= 3 {\n\t\t\t// Children[1].Children[2] is the diagnosticMessage which is guaranteed to exist as seen here: https://tools.ietf.org/html/rfc4511#section-4.1.9\n\t\t\treturn uint8(response.Children[0].Value.(int64)), response.Children[2].Value.(string)\n\t\t}\n\t}\n\n\treturn ErrorNetwork, \"Invalid packet format\"\n}\n\n// Error holds LDAP error information\ntype Error struct {\n\t// Err is the underlying error\n\tErr error\n\t// ResultCode is the LDAP error code\n\tResultCode uint8\n}\n\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"LDAP Result Code %d %q: %s\", e.ResultCode, LDAPResultCodeMap[e.ResultCode], e.Err.Error())\n}\n\n// NewError creates an LDAP error with the given code and underlying error\nfunc NewError(resultCode uint8, err error) error {\n\treturn &Error{ResultCode: resultCode, Err: err}\n}\n\n// IsErrorWithCode returns true if the given error is an LDAP error with the given result code\nfunc IsErrorWithCode(err error, desiredResultCode uint8) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\n\tserverError, ok := err.(*Error)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn serverError.ResultCode == desiredResultCode\n}\n", "package ldap_test\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"gopkg.in/ldap.v2\"\n)\n\nvar ldapServer = \"ldap.itd.umich.edu\"\nvar ldapPort = uint16(389)\nvar ldapTLSPort = uint16(636)\nvar baseDN = \"dc=umich,dc=edu\"\nvar filter = []string{\n\t\"(cn=cis-fac)\",\n\t\"(&(owner=*)(cn=cis-fac))\",\n\t\"(&(objectclass=rfc822mailgroup)(cn=*Computer*))\",\n\t\"(&(objectclass=rfc822mailgroup)(cn=*Mathematics*))\"}\nvar attributes = []string{\n\t\"cn\",\n\t\"description\"}\n\nfunc TestDial(t *testing.T) {\n\tfmt.Printf(\"TestDial: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\tfmt.Printf(\"TestDial: finished...\\n\")\n}\n\nfunc TestDialTLS(t *testing.T) {\n\tfmt.Printf(\"TestDialTLS: starting...\\n\")\n\tl, err := ldap.DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\tfmt.Printf(\"TestDialTLS: finished...\\n\")\n}\n\nfunc TestStartTLS(t *testing.T) {\n\tfmt.Printf(\"TestStartTLS: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"TestStartTLS: finished...\\n\")\n}\n\nfunc TestSearch(t *testing.T) {\n\tfmt.Printf(\"TestSearch: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[0],\n\t\tattributes,\n\t\tnil)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearch: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n}\n\nfunc TestSearchStartTLS(t *testing.T) {\n\tfmt.Printf(\"TestSearchStartTLS: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[0],\n\t\tattributes,\n\t\tnil)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchStartTLS: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tfmt.Printf(\"TestSearchStartTLS: upgrading with startTLS\\n\")\n\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tsr, err = l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchStartTLS: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n}\n\nfunc TestSearchWithPaging(t *testing.T) {\n\tfmt.Printf(\"TestSearchWithPaging: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\terr = l.Bind(\"\", \"\")\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\tnil)\n\tsr, err := l.SearchWithPaging(searchRequest, 5)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tsearchRequest = ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\t[]ldap.Control{ldap.NewControlPaging(5)})\n\tsr, err = l.SearchWithPaging(searchRequest, 5)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tsearchRequest = ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\t[]ldap.Control{ldap.NewControlPaging(500)})\n\tsr, err = l.SearchWithPaging(searchRequest, 5)\n\tif err == nil {\n\t\tt.Errorf(\"expected an error when paging size in control in search request doesn't match size given in call, got none\")\n\t\treturn\n\t}\n}\n\nfunc searchGoroutine(t *testing.T, l *ldap.Conn, results chan *ldap.SearchResult, i int) {\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tbaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n\t\tfilter[i],\n\t\tattributes,\n\t\tnil)\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\tresults <- nil\n\t\treturn\n\t}\n\tresults <- sr\n}\n\nfunc testMultiGoroutineSearch(t *testing.T, TLS bool, startTLS bool) {\n\tfmt.Printf(\"TestMultiGoroutineSearch: starting...\\n\")\n\tvar l *ldap.Conn\n\tvar err error\n\tif TLS {\n\t\tl, err = ldap.DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n\t\tif err != nil {\n\t\t\tt.Errorf(err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer l.Close()\n\t} else {\n\t\tl, err = ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\t\tif err != nil {\n\t\t\tt.Errorf(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif startTLS {\n\t\t\tfmt.Printf(\"TestMultiGoroutineSearch: using StartTLS...\\n\")\n\t\t\terr := l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t}\n\t}\n\n\tresults := make([]chan *ldap.SearchResult, len(filter))\n\tfor i := range filter {\n\t\tresults[i] = make(chan *ldap.SearchResult)\n\t\tgo searchGoroutine(t, l, results[i], i)\n\t}\n\tfor i := range filter {\n\t\tsr := <-results[i]\n\t\tif sr == nil {\n\t\t\tt.Errorf(\"Did not receive results from goroutine for %q\", filter[i])\n\t\t} else {\n\t\t\tfmt.Printf(\"TestMultiGoroutineSearch(%d): %s -> num of entries = %d\\n\", i, filter[i], len(sr.Entries))\n\t\t}\n\t}\n}\n\nfunc TestMultiGoroutineSearch(t *testing.T) {\n\ttestMultiGoroutineSearch(t, false, false)\n\ttestMultiGoroutineSearch(t, true, true)\n\ttestMultiGoroutineSearch(t, false, true)\n}\n\nfunc TestEscapeFilter(t *testing.T) {\n\tif got, want := ldap.EscapeFilter(\"a\\x00b(c)d*e\\\\f\"), `a\\00b\\28c\\29d\\2ae\\5cf`; got != want {\n\t\tt.Errorf(\"Got %s, expected %s\", want, got)\n\t}\n\tif got, want := ldap.EscapeFilter(\"Lu\u010di\u0107\"), `Lu\\c4\\8di\\c4\\87`; got != want {\n\t\tt.Errorf(\"Got %s, expected %s\", want, got)\n\t}\n}\n\nfunc TestCompare(t *testing.T) {\n\tfmt.Printf(\"TestCompare: starting...\\n\")\n\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tdefer l.Close()\n\n\tdn := \"cn=math mich,ou=User Groups,ou=Groups,dc=umich,dc=edu\"\n\tattribute := \"cn\"\n\tvalue := \"math mich\"\n\n\tsr, err := l.Compare(dn, attribute, value)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestCompare: -> %v\\n\", sr)\n}\n"], "fixing_code": ["// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ldap\n\nimport (\n\t\"errors\"\n\n\tber \"gopkg.in/asn1-ber.v1\"\n)\n\n// SimpleBindRequest represents a username/password bind operation\ntype SimpleBindRequest struct {\n\t// Username is the name of the Directory object that the client wishes to bind as\n\tUsername string\n\t// Password is the credentials to bind with\n\tPassword string\n\t// Controls are optional controls to send with the bind request\n\tControls []Control\n\t// AllowEmptyPassword sets whether the client allows binding with an empty password\n\t// (normally used for unauthenticated bind).\n\tAllowEmptyPassword bool\n}\n\n// SimpleBindResult contains the response from the server\ntype SimpleBindResult struct {\n\tControls []Control\n}\n\n// NewSimpleBindRequest returns a bind request\nfunc NewSimpleBindRequest(username string, password string, controls []Control) *SimpleBindRequest {\n\treturn &SimpleBindRequest{\n\t\tUsername:           username,\n\t\tPassword:           password,\n\t\tControls:           controls,\n\t\tAllowEmptyPassword: false,\n\t}\n}\n\nfunc (bindRequest *SimpleBindRequest) encode() *ber.Packet {\n\trequest := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationBindRequest, nil, \"Bind Request\")\n\trequest.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, 3, \"Version\"))\n\trequest.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, bindRequest.Username, \"User Name\"))\n\trequest.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, bindRequest.Password, \"Password\"))\n\n\trequest.AppendChild(encodeControls(bindRequest.Controls))\n\n\treturn request\n}\n\n// SimpleBind performs the simple bind operation defined in the given request\nfunc (l *Conn) SimpleBind(simpleBindRequest *SimpleBindRequest) (*SimpleBindResult, error) {\n\tif simpleBindRequest.Password == \"\" && !simpleBindRequest.AllowEmptyPassword {\n\t\treturn nil, NewError(ErrorEmptyPassword, errors.New(\"ldap: empty password not allowed by the client\"))\n\t}\n\n\tpacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"LDAP Request\")\n\tpacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, l.nextMessageID(), \"MessageID\"))\n\tencodedBindRequest := simpleBindRequest.encode()\n\tpacket.AppendChild(encodedBindRequest)\n\n\tif l.Debug {\n\t\tber.PrintPacket(packet)\n\t}\n\n\tmsgCtx, err := l.sendMessage(packet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.finishMessage(msgCtx)\n\n\tpacketResponse, ok := <-msgCtx.responses\n\tif !ok {\n\t\treturn nil, NewError(ErrorNetwork, errors.New(\"ldap: response channel closed\"))\n\t}\n\tpacket, err = packetResponse.ReadPacket()\n\tl.Debug.Printf(\"%d: got response %p\", msgCtx.id, packet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif l.Debug {\n\t\tif err := addLDAPDescriptions(packet); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tber.PrintPacket(packet)\n\t}\n\n\tresult := &SimpleBindResult{\n\t\tControls: make([]Control, 0),\n\t}\n\n\tif len(packet.Children) == 3 {\n\t\tfor _, child := range packet.Children[2].Children {\n\t\t\tresult.Controls = append(result.Controls, DecodeControl(child))\n\t\t}\n\t}\n\n\tresultCode, resultDescription := getLDAPResultCode(packet)\n\tif resultCode != 0 {\n\t\treturn result, NewError(resultCode, errors.New(resultDescription))\n\t}\n\n\treturn result, nil\n}\n\n// Bind performs a bind with the given username and password.\n//\n// It does not allow unauthenticated bind (i.e. empty password). Use the UnauthenticatedBind method\n// for that.\nfunc (l *Conn) Bind(username, password string) error {\n\treq := &SimpleBindRequest{\n\t\tUsername:           username,\n\t\tPassword:           password,\n\t\tAllowEmptyPassword: false,\n\t}\n\t_, err := l.SimpleBind(req)\n\treturn err\n}\n\n// UnauthenticatedBind performs an unauthenticated bind.\n//\n// A username may be provided for trace (e.g. logging) purpose only, but it is normally not\n// authenticated or otherwise validated by the LDAP server.\n//\n// See https://tools.ietf.org/html/rfc4513#section-5.1.2 .\n// See https://tools.ietf.org/html/rfc4513#section-6.3.1 .\nfunc (l *Conn) UnauthenticatedBind(username string) error {\n\treq := &SimpleBindRequest{\n\t\tUsername:           username,\n\t\tPassword:           \"\",\n\t\tAllowEmptyPassword: true,\n\t}\n\t_, err := l.SimpleBind(req)\n\treturn err\n}\n", "package ldap\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/asn1-ber.v1\"\n)\n\n// LDAP Result Codes\nconst (\n\tLDAPResultSuccess                      = 0\n\tLDAPResultOperationsError              = 1\n\tLDAPResultProtocolError                = 2\n\tLDAPResultTimeLimitExceeded            = 3\n\tLDAPResultSizeLimitExceeded            = 4\n\tLDAPResultCompareFalse                 = 5\n\tLDAPResultCompareTrue                  = 6\n\tLDAPResultAuthMethodNotSupported       = 7\n\tLDAPResultStrongAuthRequired           = 8\n\tLDAPResultReferral                     = 10\n\tLDAPResultAdminLimitExceeded           = 11\n\tLDAPResultUnavailableCriticalExtension = 12\n\tLDAPResultConfidentialityRequired      = 13\n\tLDAPResultSaslBindInProgress           = 14\n\tLDAPResultNoSuchAttribute              = 16\n\tLDAPResultUndefinedAttributeType       = 17\n\tLDAPResultInappropriateMatching        = 18\n\tLDAPResultConstraintViolation          = 19\n\tLDAPResultAttributeOrValueExists       = 20\n\tLDAPResultInvalidAttributeSyntax       = 21\n\tLDAPResultNoSuchObject                 = 32\n\tLDAPResultAliasProblem                 = 33\n\tLDAPResultInvalidDNSyntax              = 34\n\tLDAPResultAliasDereferencingProblem    = 36\n\tLDAPResultInappropriateAuthentication  = 48\n\tLDAPResultInvalidCredentials           = 49\n\tLDAPResultInsufficientAccessRights     = 50\n\tLDAPResultBusy                         = 51\n\tLDAPResultUnavailable                  = 52\n\tLDAPResultUnwillingToPerform           = 53\n\tLDAPResultLoopDetect                   = 54\n\tLDAPResultNamingViolation              = 64\n\tLDAPResultObjectClassViolation         = 65\n\tLDAPResultNotAllowedOnNonLeaf          = 66\n\tLDAPResultNotAllowedOnRDN              = 67\n\tLDAPResultEntryAlreadyExists           = 68\n\tLDAPResultObjectClassModsProhibited    = 69\n\tLDAPResultAffectsMultipleDSAs          = 71\n\tLDAPResultOther                        = 80\n\n\tErrorNetwork            = 200\n\tErrorFilterCompile      = 201\n\tErrorFilterDecompile    = 202\n\tErrorDebugging          = 203\n\tErrorUnexpectedMessage  = 204\n\tErrorUnexpectedResponse = 205\n\tErrorEmptyPassword      = 206\n)\n\n// LDAPResultCodeMap contains string descriptions for LDAP error codes\nvar LDAPResultCodeMap = map[uint8]string{\n\tLDAPResultSuccess:                      \"Success\",\n\tLDAPResultOperationsError:              \"Operations Error\",\n\tLDAPResultProtocolError:                \"Protocol Error\",\n\tLDAPResultTimeLimitExceeded:            \"Time Limit Exceeded\",\n\tLDAPResultSizeLimitExceeded:            \"Size Limit Exceeded\",\n\tLDAPResultCompareFalse:                 \"Compare False\",\n\tLDAPResultCompareTrue:                  \"Compare True\",\n\tLDAPResultAuthMethodNotSupported:       \"Auth Method Not Supported\",\n\tLDAPResultStrongAuthRequired:           \"Strong Auth Required\",\n\tLDAPResultReferral:                     \"Referral\",\n\tLDAPResultAdminLimitExceeded:           \"Admin Limit Exceeded\",\n\tLDAPResultUnavailableCriticalExtension: \"Unavailable Critical Extension\",\n\tLDAPResultConfidentialityRequired:      \"Confidentiality Required\",\n\tLDAPResultSaslBindInProgress:           \"Sasl Bind In Progress\",\n\tLDAPResultNoSuchAttribute:              \"No Such Attribute\",\n\tLDAPResultUndefinedAttributeType:       \"Undefined Attribute Type\",\n\tLDAPResultInappropriateMatching:        \"Inappropriate Matching\",\n\tLDAPResultConstraintViolation:          \"Constraint Violation\",\n\tLDAPResultAttributeOrValueExists:       \"Attribute Or Value Exists\",\n\tLDAPResultInvalidAttributeSyntax:       \"Invalid Attribute Syntax\",\n\tLDAPResultNoSuchObject:                 \"No Such Object\",\n\tLDAPResultAliasProblem:                 \"Alias Problem\",\n\tLDAPResultInvalidDNSyntax:              \"Invalid DN Syntax\",\n\tLDAPResultAliasDereferencingProblem:    \"Alias Dereferencing Problem\",\n\tLDAPResultInappropriateAuthentication:  \"Inappropriate Authentication\",\n\tLDAPResultInvalidCredentials:           \"Invalid Credentials\",\n\tLDAPResultInsufficientAccessRights:     \"Insufficient Access Rights\",\n\tLDAPResultBusy:                         \"Busy\",\n\tLDAPResultUnavailable:                  \"Unavailable\",\n\tLDAPResultUnwillingToPerform:           \"Unwilling To Perform\",\n\tLDAPResultLoopDetect:                   \"Loop Detect\",\n\tLDAPResultNamingViolation:              \"Naming Violation\",\n\tLDAPResultObjectClassViolation:         \"Object Class Violation\",\n\tLDAPResultNotAllowedOnNonLeaf:          \"Not Allowed On Non Leaf\",\n\tLDAPResultNotAllowedOnRDN:              \"Not Allowed On RDN\",\n\tLDAPResultEntryAlreadyExists:           \"Entry Already Exists\",\n\tLDAPResultObjectClassModsProhibited:    \"Object Class Mods Prohibited\",\n\tLDAPResultAffectsMultipleDSAs:          \"Affects Multiple DSAs\",\n\tLDAPResultOther:                        \"Other\",\n\n\tErrorNetwork:            \"Network Error\",\n\tErrorFilterCompile:      \"Filter Compile Error\",\n\tErrorFilterDecompile:    \"Filter Decompile Error\",\n\tErrorDebugging:          \"Debugging Error\",\n\tErrorUnexpectedMessage:  \"Unexpected Message\",\n\tErrorUnexpectedResponse: \"Unexpected Response\",\n\tErrorEmptyPassword:      \"Empty password not allowed by the client\",\n}\n\nfunc getLDAPResultCode(packet *ber.Packet) (code uint8, description string) {\n\tif packet == nil {\n\t\treturn ErrorUnexpectedResponse, \"Empty packet\"\n\t} else if len(packet.Children) >= 2 {\n\t\tresponse := packet.Children[1]\n\t\tif response == nil {\n\t\t\treturn ErrorUnexpectedResponse, \"Empty response in packet\"\n\t\t}\n\t\tif response.ClassType == ber.ClassApplication && response.TagType == ber.TypeConstructed && len(response.Children) >= 3 {\n\t\t\t// Children[1].Children[2] is the diagnosticMessage which is guaranteed to exist as seen here: https://tools.ietf.org/html/rfc4511#section-4.1.9\n\t\t\treturn uint8(response.Children[0].Value.(int64)), response.Children[2].Value.(string)\n\t\t}\n\t}\n\n\treturn ErrorNetwork, \"Invalid packet format\"\n}\n\n// Error holds LDAP error information\ntype Error struct {\n\t// Err is the underlying error\n\tErr error\n\t// ResultCode is the LDAP error code\n\tResultCode uint8\n}\n\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"LDAP Result Code %d %q: %s\", e.ResultCode, LDAPResultCodeMap[e.ResultCode], e.Err.Error())\n}\n\n// NewError creates an LDAP error with the given code and underlying error\nfunc NewError(resultCode uint8, err error) error {\n\treturn &Error{ResultCode: resultCode, Err: err}\n}\n\n// IsErrorWithCode returns true if the given error is an LDAP error with the given result code\nfunc IsErrorWithCode(err error, desiredResultCode uint8) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\n\tserverError, ok := err.(*Error)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn serverError.ResultCode == desiredResultCode\n}\n", "package ldap\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nvar ldapServer = \"ldap.itd.umich.edu\"\nvar ldapPort = uint16(389)\nvar ldapTLSPort = uint16(636)\nvar baseDN = \"dc=umich,dc=edu\"\nvar filter = []string{\n\t\"(cn=cis-fac)\",\n\t\"(&(owner=*)(cn=cis-fac))\",\n\t\"(&(objectclass=rfc822mailgroup)(cn=*Computer*))\",\n\t\"(&(objectclass=rfc822mailgroup)(cn=*Mathematics*))\"}\nvar attributes = []string{\n\t\"cn\",\n\t\"description\"}\n\nfunc TestDial(t *testing.T) {\n\tfmt.Printf(\"TestDial: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\tfmt.Printf(\"TestDial: finished...\\n\")\n}\n\nfunc TestDialTLS(t *testing.T) {\n\tfmt.Printf(\"TestDialTLS: starting...\\n\")\n\tl, err := DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\tfmt.Printf(\"TestDialTLS: finished...\\n\")\n}\n\nfunc TestStartTLS(t *testing.T) {\n\tfmt.Printf(\"TestStartTLS: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"TestStartTLS: finished...\\n\")\n}\n\nfunc TestSearch(t *testing.T) {\n\tfmt.Printf(\"TestSearch: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tsearchRequest := NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[0],\n\t\tattributes,\n\t\tnil)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearch: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n}\n\nfunc TestSearchStartTLS(t *testing.T) {\n\tfmt.Printf(\"TestSearchStartTLS: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tsearchRequest := NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[0],\n\t\tattributes,\n\t\tnil)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchStartTLS: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tfmt.Printf(\"TestSearchStartTLS: upgrading with startTLS\\n\")\n\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tsr, err = l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchStartTLS: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n}\n\nfunc TestSearchWithPaging(t *testing.T) {\n\tfmt.Printf(\"TestSearchWithPaging: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\terr = l.UnauthenticatedBind(\"\")\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tsearchRequest := NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\tnil)\n\tsr, err := l.SearchWithPaging(searchRequest, 5)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tsearchRequest = NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\t[]Control{NewControlPaging(5)})\n\tsr, err = l.SearchWithPaging(searchRequest, 5)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n\n\tsearchRequest = NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[2],\n\t\tattributes,\n\t\t[]Control{NewControlPaging(500)})\n\tsr, err = l.SearchWithPaging(searchRequest, 5)\n\tif err == nil {\n\t\tt.Errorf(\"expected an error when paging size in control in search request doesn't match size given in call, got none\")\n\t\treturn\n\t}\n}\n\nfunc searchGoroutine(t *testing.T, l *Conn, results chan *SearchResult, i int) {\n\tsearchRequest := NewSearchRequest(\n\t\tbaseDN,\n\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n\t\tfilter[i],\n\t\tattributes,\n\t\tnil)\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\tresults <- nil\n\t\treturn\n\t}\n\tresults <- sr\n}\n\nfunc testMultiGoroutineSearch(t *testing.T, TLS bool, startTLS bool) {\n\tfmt.Printf(\"TestMultiGoroutineSearch: starting...\\n\")\n\tvar l *Conn\n\tvar err error\n\tif TLS {\n\t\tl, err = DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n\t\tif err != nil {\n\t\t\tt.Errorf(err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer l.Close()\n\t} else {\n\t\tl, err = Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\t\tif err != nil {\n\t\t\tt.Errorf(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif startTLS {\n\t\t\tfmt.Printf(\"TestMultiGoroutineSearch: using StartTLS...\\n\")\n\t\t\terr := l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t}\n\t}\n\n\tresults := make([]chan *SearchResult, len(filter))\n\tfor i := range filter {\n\t\tresults[i] = make(chan *SearchResult)\n\t\tgo searchGoroutine(t, l, results[i], i)\n\t}\n\tfor i := range filter {\n\t\tsr := <-results[i]\n\t\tif sr == nil {\n\t\t\tt.Errorf(\"Did not receive results from goroutine for %q\", filter[i])\n\t\t} else {\n\t\t\tfmt.Printf(\"TestMultiGoroutineSearch(%d): %s -> num of entries = %d\\n\", i, filter[i], len(sr.Entries))\n\t\t}\n\t}\n}\n\nfunc TestMultiGoroutineSearch(t *testing.T) {\n\ttestMultiGoroutineSearch(t, false, false)\n\ttestMultiGoroutineSearch(t, true, true)\n\ttestMultiGoroutineSearch(t, false, true)\n}\n\nfunc TestEscapeFilter(t *testing.T) {\n\tif got, want := EscapeFilter(\"a\\x00b(c)d*e\\\\f\"), `a\\00b\\28c\\29d\\2ae\\5cf`; got != want {\n\t\tt.Errorf(\"Got %s, expected %s\", want, got)\n\t}\n\tif got, want := EscapeFilter(\"Lu\u010di\u0107\"), `Lu\\c4\\8di\\c4\\87`; got != want {\n\t\tt.Errorf(\"Got %s, expected %s\", want, got)\n\t}\n}\n\nfunc TestCompare(t *testing.T) {\n\tfmt.Printf(\"TestCompare: starting...\\n\")\n\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tdefer l.Close()\n\n\tdn := \"cn=math mich,ou=User Groups,ou=Groups,dc=umich,dc=edu\"\n\tattribute := \"cn\"\n\tvalue := \"math mich\"\n\n\tsr, err := l.Compare(dn, attribute, value)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t\treturn\n\t}\n\n\tfmt.Printf(\"TestCompare: -> %v\\n\", sr)\n}\n"], "filenames": ["bind.go", "error.go", "ldap_test.go"], "buggy_code_start_loc": [10, 56, 1], "buggy_code_end_loc": [143, 106, 259], "fixing_code_start_loc": [10, 57, 1], "fixing_code_end_loc": [137, 109, 257], "type": "CWE-287", "message": "In the ldap.v2 (aka go-ldap) package through 2.5.0 for Go, an attacker may be able to login with an empty password. This issue affects an application using this package if these conditions are met: (1) it relies only on the return error of the Bind function call to determine whether a user is authorized (i.e., a nil return value is interpreted as successful authorization) and (2) it is used with an LDAP server allowing unauthenticated bind.", "other": {"cve": {"id": "CVE-2017-14623", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-20T23:29:00.247", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the ldap.v2 (aka go-ldap) package through 2.5.0 for Go, an attacker may be able to login with an empty password. This issue affects an application using this package if these conditions are met: (1) it relies only on the return error of the Bind function call to determine whether a user is authorized (i.e., a nil return value is interpreted as successful authorization) and (2) it is used with an LDAP server allowing unauthenticated bind."}, {"lang": "es", "value": "En el paquete ldap.v2 (tambi\u00e9n conocido como go-ldap) hasta la versi\u00f3n 2.5.0 para Go, un atacante podr\u00eda ser capaz de iniciar sesi\u00f3n con una contrase\u00f1a vac\u00eda. Este problema afecta a una aplicaci\u00f3n que usa este paquete si se cumplen las siguientes condiciones: (1) solo depende del error de retorno de la llamada de funci\u00f3n Bind para determinar si un usuario est\u00e1 autorizado (por ejemplo, si se interpreta un valor nulo como una autorizaci\u00f3n con \u00e9xito) y (2) se emplea con un servidor LDAP que permita el enlace sin autenticaci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-ldap_project:ldap:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "5AFC31F6-1078-4377-AEF0-6249089C93B3"}]}]}], "references": [{"url": "https://github.com/go-ldap/ldap/commit/95ede1266b237bf8e9aa5dce0b3250e51bfefe66", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/go-ldap/ldap/pull/126", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-ldap/ldap/commit/95ede1266b237bf8e9aa5dce0b3250e51bfefe66"}}