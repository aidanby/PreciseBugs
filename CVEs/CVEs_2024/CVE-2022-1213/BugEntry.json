{"buggy_code": ["<?php\r\nheader(\"Content-type: text/css\", true);\r\n\r\n/**\r\n * Refetches CSS as it was hosted on our server.\r\n * I can swear there is some bugs regarding relative CSS and base URL path.\r\n * This script is required if LHC is hosted on HTTPS but site itself is hosted on HTTP, because browser forbids downloading content from insecure site except images\r\n * themself\r\n * */\r\nif ($Params['user_parameters_unordered']['cobrowsemode'] == 'onlineuser'){\r\n    $ouser = erLhcoreClassModelChatOnlineUser::fetch($Params['user_parameters']['chat_id']);\r\n    $browse = erLhcoreClassCoBrowse::getBrowseInstanceByOnlineUser($ouser);\r\n} else {\r\n    $chat = erLhcoreClassChat::getSession()->load('erLhcoreClassModelChat', $Params['user_parameters']['chat_id']);\r\n    $browse = erLhcoreClassCoBrowse::getBrowseInstance($chat);\r\n}\r\n\r\n$url = parse_url($_GET['base']);\r\n\r\n// Only http/https supported\r\nif (!in_array($url['scheme'],['http','https']) || (isset($url['port']) && !in_array($url['port'],[80,443]))) {\r\n    exit;\r\n}\r\n\r\n// Some basic validation\r\nif (isset($url['host']) && $url['host'] != '' && strpos($_GET['css'], $_SERVER['HTTP_HOST']) === false) {\r\n\r\n    $urlCSS = parse_url($_GET['css']);\r\n\r\n    // Just our attempt to fix CSS, BaseURL, Relative path madness\r\n    if (! isset($urlCSS['host']) || $urlCSS['host'] == '') {\r\n        if (strpos($_GET['css'], '../') !== false) {            \r\n            $numberOfTime = substr_count($_GET['css'], '../');\r\n            $match = str_replace('../', '', $_GET['css']);  \r\n                      \r\n            $parts = explode('/', rtrim($_GET['base'],'/'));            \r\n            $imagePathToCss = array_slice($parts, 0, count($parts) - $numberOfTime);\r\n            \r\n            $urlCSSDownload = implode('/', $imagePathToCss) . $match;                      \r\n        } else {\r\n            $urlCSSDownload = $url['scheme'] . '://' . $url['host'] . '/' . ltrim($_GET['css'], '/');\r\n        }\r\n    } else {\r\n\r\n        if (!in_array($urlCSS['scheme'],['http','https']) || (isset($urlCSS['port']) && !in_array($urlCSS['port'],[80,443]))) {\r\n            exit;\r\n        }\r\n\r\n        $urlCSSDownload = $_GET['css'];\r\n    }\r\n\r\n    $ch = curl_init();\r\n    curl_setopt($ch, CURLOPT_URL, $urlCSSDownload);\r\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0);\r\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\r\n    curl_setopt($ch, CURLOPT_REFERER, $_GET['base']);\r\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2 GTB5');\r\n    curl_setopt($ch, CURLOPT_HEADER, true);\r\n    $response = curl_exec($ch);\r\n\r\n    if (curl_errno($ch)) {   // should be 0\r\n        curl_close($ch);\r\n        exit;\r\n    }\r\n\r\n    $curl_info = curl_getinfo($ch);\r\n    $contentType = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);\r\n    $header_size = $curl_info['header_size'];\r\n\r\n    $cssContent = substr($response, $header_size);\r\n\r\n    if ($contentType != 'text/css') {\r\n        exit;\r\n    }\r\n\r\n    if ($cssContent !== false) {        \r\n        if (preg_match_all(\"/url\\(\\s*[\\'|\\\"]?([A-Za-z0-9_\\-\\/\\.\\\\%?&#]+)[\\'|\\\"]?\\s*\\)/ix\", $cssContent, $urlMatches)) {\r\n            $urlMatches = array_unique($urlMatches[1]);\r\n            foreach ($urlMatches as $match) {\r\n                $match = str_replace('\\\\', '/', $match);\r\n                // Replace path if it is realtive\r\n                if (strpos($match, 'http') === false) {\r\n                    $appendMatch = '';\r\n                    $matchOriginal = $match;\r\n                    \r\n                    if (strpos($match, '?') !== false) {\r\n                        $matchParts = explode('?', $match);\r\n                        $match = $matchParts[0];\r\n                        $appendMatch = '?' . $matchParts[1];\r\n                    }\r\n                    \r\n                    // Fix relative path\r\n                    if (strpos($match, '../') !== false) {\r\n                        $numberOfTime = substr_count($match, '../');\r\n                        $match = str_replace('../', '', $match);\r\n                        \r\n                        $parts = explode('/', $_GET['css']);\r\n                        array_pop($parts);\r\n                        \r\n                        $imagePathToCss = array_slice($parts, 0, count($parts) - $numberOfTime);\r\n                        \r\n                        $cssContent = str_replace($matchOriginal, $url['scheme'] . '://' . str_replace('//', '/', $url['host'] . '/' . implode('/', $imagePathToCss) . '/' . $match . $appendMatch), $cssContent);\r\n                    } else { // Absolute path\r\n                        $cssContent = str_replace($matchOriginal, $url['scheme'] . '://' . str_replace('//', '/', $url['host'] . '/' . $match . $appendMatch), $cssContent);\r\n                    }\r\n                }\r\n            }\r\n        }        \r\n    }\r\n    echo $cssContent;\r\n}\r\n\r\nexit();\r\n?>"], "fixing_code": ["<?php\r\nheader(\"Content-type: text/css\", true);\r\n\r\n/**\r\n * Refetches CSS as it was hosted on our server.\r\n * I can swear there is some bugs regarding relative CSS and base URL path.\r\n * This script is required if LHC is hosted on HTTPS but site itself is hosted on HTTP, because browser forbids downloading content from insecure site except images\r\n * themself\r\n * */\r\nif ($Params['user_parameters_unordered']['cobrowsemode'] == 'onlineuser'){\r\n    $ouser = erLhcoreClassModelChatOnlineUser::fetch($Params['user_parameters']['chat_id']);\r\n    $browse = erLhcoreClassCoBrowse::getBrowseInstanceByOnlineUser($ouser);\r\n} else {\r\n    $chat = erLhcoreClassChat::getSession()->load('erLhcoreClassModelChat', $Params['user_parameters']['chat_id']);\r\n    $browse = erLhcoreClassCoBrowse::getBrowseInstance($chat);\r\n}\r\n\r\n$base = trim($_GET['base']);\r\n\r\nif (!filter_var($base, FILTER_VALIDATE_URL)) {\r\n    exit;\r\n}\r\n\r\n$url = parse_url($base);\r\n\r\n// Only http/https supported\r\nif (!in_array($url['scheme'],['http','https']) || (isset($url['port']) && !in_array($url['port'],[80,443]))) {\r\n    exit;\r\n}\r\n\r\n// Some basic validation\r\nif (isset($url['host']) && $url['host'] != '' && strpos($_GET['css'], $_SERVER['HTTP_HOST']) === false) {\r\n\r\n    $urlCSS = parse_url($_GET['css']);\r\n\r\n    // Just our attempt to fix CSS, BaseURL, Relative path madness\r\n    if (! isset($urlCSS['host']) || $urlCSS['host'] == '') {\r\n        if (strpos($_GET['css'], '../') !== false) {            \r\n            $numberOfTime = substr_count($_GET['css'], '../');\r\n            $match = str_replace('../', '', $_GET['css']);  \r\n                      \r\n            $parts = explode('/', rtrim($_GET['base'],'/'));            \r\n            $imagePathToCss = array_slice($parts, 0, count($parts) - $numberOfTime);\r\n            \r\n            $urlCSSDownload = implode('/', $imagePathToCss) . $match;                      \r\n        } else {\r\n            $urlCSSDownload = $url['scheme'] . '://' . $url['host'] . '/' . ltrim($_GET['css'], '/');\r\n        }\r\n    } else {\r\n\r\n        if (!filter_var($_GET['css'], FILTER_VALIDATE_URL) || !in_array($urlCSS['scheme'],['http','https']) || (isset($urlCSS['port']) && !in_array($urlCSS['port'],[80,443]))) {\r\n            exit;\r\n        }\r\n\r\n        $urlCSSDownload = $_GET['css'];\r\n    }\r\n\r\n    $ch = curl_init();\r\n    curl_setopt($ch, CURLOPT_URL, $urlCSSDownload);\r\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0);\r\n    curl_setopt($ch, CURLOPT_TIMEOUT, 5);\r\n    curl_setopt($ch, CURLOPT_REFERER, $_GET['base']);\r\n    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2 GTB5');\r\n    curl_setopt($ch, CURLOPT_HEADER, true);\r\n    $response = curl_exec($ch);\r\n\r\n    if (curl_errno($ch)) {   // should be 0\r\n        curl_close($ch);\r\n        exit;\r\n    }\r\n\r\n    $curl_info = curl_getinfo($ch);\r\n    $contentType = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);\r\n    $header_size = $curl_info['header_size'];\r\n\r\n    $cssContent = substr($response, $header_size);\r\n\r\n    if ($contentType != 'text/css') {\r\n        exit;\r\n    }\r\n\r\n    if ($cssContent !== false) {        \r\n        if (preg_match_all(\"/url\\(\\s*[\\'|\\\"]?([A-Za-z0-9_\\-\\/\\.\\\\%?&#]+)[\\'|\\\"]?\\s*\\)/ix\", $cssContent, $urlMatches)) {\r\n            $urlMatches = array_unique($urlMatches[1]);\r\n            foreach ($urlMatches as $match) {\r\n                $match = str_replace('\\\\', '/', $match);\r\n                // Replace path if it is realtive\r\n                if (strpos($match, 'http') === false) {\r\n                    $appendMatch = '';\r\n                    $matchOriginal = $match;\r\n                    \r\n                    if (strpos($match, '?') !== false) {\r\n                        $matchParts = explode('?', $match);\r\n                        $match = $matchParts[0];\r\n                        $appendMatch = '?' . $matchParts[1];\r\n                    }\r\n                    \r\n                    // Fix relative path\r\n                    if (strpos($match, '../') !== false) {\r\n                        $numberOfTime = substr_count($match, '../');\r\n                        $match = str_replace('../', '', $match);\r\n                        \r\n                        $parts = explode('/', $_GET['css']);\r\n                        array_pop($parts);\r\n                        \r\n                        $imagePathToCss = array_slice($parts, 0, count($parts) - $numberOfTime);\r\n                        \r\n                        $cssContent = str_replace($matchOriginal, $url['scheme'] . '://' . str_replace('//', '/', $url['host'] . '/' . implode('/', $imagePathToCss) . '/' . $match . $appendMatch), $cssContent);\r\n                    } else { // Absolute path\r\n                        $cssContent = str_replace($matchOriginal, $url['scheme'] . '://' . str_replace('//', '/', $url['host'] . '/' . $match . $appendMatch), $cssContent);\r\n                    }\r\n                }\r\n            }\r\n        }        \r\n    }\r\n    echo $cssContent;\r\n}\r\n\r\nexit();\r\n?>"], "filenames": ["lhc_web/modules/lhcobrowse/proxycss.php"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [46], "fixing_code_start_loc": [18], "fixing_code_end_loc": [52], "type": "CWE-918", "message": "SSRF filter bypass port 80, 433 in GitHub repository livehelperchat/livehelperchat prior to 3.67v. An attacker could make the application perform arbitrary requests, bypass CVE-2022-1191", "other": {"cve": {"id": "CVE-2022-1213", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-05T04:15:08.847", "lastModified": "2022-04-13T18:39:26.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SSRF filter bypass port 80, 433 in GitHub repository livehelperchat/livehelperchat prior to 3.67v. An attacker could make the application perform arbitrary requests, bypass CVE-2022-1191"}, {"lang": "es", "value": "Una omisi\u00f3n del filtro SSRF en el puerto 80, 433 en el repositorio de GitHub livehelperchat/livehelperchat versiones anteriores a 3.67v. Un atacante podr\u00eda hacer que la aplicaci\u00f3n llevara a cabo peticiones arbitrarias, omitiendo CVE-2022-1191"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:livehelperchat:live_helper_chat:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.97", "matchCriteriaId": "F349805D-9BF0-4730-9824-F4A3DB5272A3"}]}]}], "references": [{"url": "https://github.com/livehelperchat/livehelperchat/commit/abc9599ee7aded466ca216741dcaea533c908111", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/084387f6-5b9c-4017-baa2-5fcf65b051e1", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/livehelperchat/livehelperchat/commit/abc9599ee7aded466ca216741dcaea533c908111"}}