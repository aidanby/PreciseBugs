{"buggy_code": ["//---------------------------------------------------------------------------------\n//\n//  Little Color Management System\n//  Copyright (c) 1998-2016 Marti Maria Saguer\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//---------------------------------------------------------------------------------\n//\n\n#include \"lcms2_internal.h\"\n\n// Tag Serialization  -----------------------------------------------------------------------------\n// This file implements every single tag and tag type as described in the ICC spec. Some types\n// have been deprecated, like ncl and Data. There is no implementation for those types as there\n// are no profiles holding them. The programmer can also extend this list by defining his own types\n// by using the appropriate plug-in. There are three types of plug ins regarding that. First type\n// allows to define new tags using any existing type. Next plug-in type allows to define new types\n// and the third one is very specific: allows to extend the number of elements in the multiprocessing\n// elements special type.\n//--------------------------------------------------------------------------------------------------\n\n// Some broken types\n#define cmsCorbisBrokenXYZtype    ((cmsTagTypeSignature) 0x17A505B8)\n#define cmsMonacoBrokenCurveType  ((cmsTagTypeSignature) 0x9478ee00)\n\n// This is the linked list that keeps track of the defined types\ntypedef struct _cmsTagTypeLinkedList_st {\n\n    cmsTagTypeHandler Handler;\n    struct _cmsTagTypeLinkedList_st* Next;\n\n} _cmsTagTypeLinkedList;\n\n// Some macros to define callbacks.\n#define READ_FN(x)  Type_##x##_Read\n#define WRITE_FN(x) Type_##x##_Write\n#define FREE_FN(x)  Type_##x##_Free\n#define DUP_FN(x)   Type_##x##_Dup\n\n// Helper macro to define a handler. Callbacks do have a fixed naming convention.\n#define TYPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), DUP_FN(x), FREE_FN(x), NULL, 0 }\n\n// Helper macro to define a MPE handler. Callbacks do have a fixed naming convention\n#define TYPE_MPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), GenericMPEdup, GenericMPEfree, NULL, 0 }\n\n// Register a new type handler. This routine is shared between normal types and MPE. LinkedList points to the optional list head\nstatic\ncmsBool RegisterTypesPlugin(cmsContext id, cmsPluginBase* Data, _cmsMemoryClient pos)\n{\n    cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(id, pos);\n    _cmsTagTypeLinkedList *pt;\n\n    // Calling the function with NULL as plug-in would unregister the plug in.\n    if (Data == NULL) {\n\n        // There is no need to set free the memory, as pool is destroyed as a whole.\n        ctx ->TagTypes = NULL;\n        return TRUE;\n    }\n\n    // Registering happens in plug-in memory pool.\n    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagTypeLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Handler   = Plugin ->Handler;\n    pt ->Next      = ctx ->TagTypes;\n\n    ctx ->TagTypes = pt;\n     \n    return TRUE;\n}\n\n// Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons \n// made by plug-ins and then the built-in defaults.\nstatic\ncmsTagTypeHandler* GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* PluginLinkedList, _cmsTagTypeLinkedList* DefaultLinkedList)\n{\n    _cmsTagTypeLinkedList* pt;\n\n    for (pt = PluginLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    for (pt = DefaultLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    return NULL;\n}\n\n\n// Auxiliary to convert UTF-32 to UTF-16 in some cases\nstatic\ncmsBool _cmsWriteWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, const wchar_t* Array)\n{\n    cmsUInt32Number i;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(!(Array == NULL && n > 0));\n\n    for (i=0; i < n; i++) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Array[i])) return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Auxiliary to read an array of wchar_t\nstatic\ncmsBool _cmsReadWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, wchar_t* Array)\n{\n    cmsUInt32Number i;\n    cmsUInt16Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    for (i=0; i < n; i++) {\n\n        if (Array != NULL) {\n\n            if (!_cmsReadUInt16Number(io, &tmp)) return FALSE;\n            Array[i] = (wchar_t) tmp;\n        }\n        else {\n            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;\n        }\n\n    }\n    return TRUE;\n}\n\n// To deal with position tables\ntypedef cmsBool (* PositionTableEntryFn)(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag);\n\n// Helper function to deal with position tables as described in ICC spec 4.3\n// A table of n elements is readed, where first comes n records containing offsets and sizes and\n// then a block containing the data itself. This allows to reuse same data in more than one entry\nstatic\ncmsBool ReadPositionTable(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER* io,\n                              cmsUInt32Number Count,\n                              cmsUInt32Number BaseOffset,\n                              void *Cargo,\n                              PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n\n    // Let's take the offsets to each element\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt32Number(io, &ElementOffsets[i])) goto Error;\n        if (!_cmsReadUInt32Number(io, &ElementSizes[i])) goto Error;\n\n        ElementOffsets[i] += BaseOffset;\n    }\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!io -> Seek(io, ElementOffsets[i])) goto Error;\n\n        // This is the reader callback\n        if (!ElementFn(self, io, Cargo, i, ElementSizes[i])) goto Error;\n    }\n\n    // Success\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}\n\n// Same as anterior, but for write position tables\nstatic\ncmsBool WritePositionTable(struct _cms_typehandler_struct* self,\n                               cmsIOHANDLER* io,\n                               cmsUInt32Number SizeOfTag,\n                               cmsUInt32Number Count,\n                               cmsUInt32Number BaseOffset,\n                               void *Cargo,\n                               PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number DirectoryPos, CurrentPos, Before;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n\n     // Create table\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Keep starting position of curve offsets\n    DirectoryPos = io ->Tell(io);\n\n    // Write a fake directory to be filled latter on\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each element. Keep track of the size as well.\n    for (i=0; i < Count; i++) {\n\n        Before = io ->Tell(io);\n        ElementOffsets[i] = Before - BaseOffset;\n\n        // Callback to write...\n        if (!ElementFn(self, io, Cargo, i, SizeOfTag)) goto Error;\n\n        // Now the size\n        ElementSizes[i] = io ->Tell(io) - Before;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i <  Count; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}\n\n\n// ********************************************************************************\n// Type XYZ. Only one value is allowed\n// ********************************************************************************\n\n//The XYZType contains an array of three encoded values for the XYZ tristimulus\n//values. Tristimulus values must be non-negative. The signed encoding allows for\n//implementation optimizations by minimizing the number of fixed formats.\n\n\nstatic\nvoid *Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIEXYZ* xyz;\n\n    *nItems = 0;\n    xyz = (cmsCIEXYZ*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIEXYZ));\n    if (xyz == NULL) return NULL;\n\n    if (!_cmsReadXYZNumber(io, xyz)) {\n        _cmsFree(self ->ContextID, xyz);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) xyz;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_XYZ_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    return _cmsWriteXYZNumber(io, (cmsCIEXYZ*) Ptr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_XYZ_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIEXYZ));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_XYZ_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\nstatic\ncmsTagTypeSignature DecideXYZtype(cmsFloat64Number ICCVersion, const void *Data)\n{\n    return cmsSigXYZType;\n\n    cmsUNUSED_PARAMETER(ICCVersion);\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type chromaticity. Only one value is allowed\n// ********************************************************************************\n// The chromaticity tag type provides basic chromaticity data and type of\n// phosphors or colorants of a monitor to applications and utilities.\n\nstatic\nvoid *Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIExyYTRIPLE* chrm;\n    cmsUInt16Number nChans, Table;\n\n    *nItems = 0;\n    chrm =  (cmsCIExyYTRIPLE*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIExyYTRIPLE));\n    if (chrm == NULL) return NULL;\n\n    if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n\n    // Let's recover from a bug introduced in early versions of lcms1\n    if (nChans == 0 && SizeOfTag == 32) {\n\n        if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n        if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n    }\n\n    if (nChans != 3) goto Error;\n\n    if (!_cmsReadUInt16Number(io, &Table)) goto Error;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.y)) goto Error;\n\n    chrm ->Red.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.y)) goto Error;\n\n    chrm ->Green.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.y)) goto Error;\n\n    chrm ->Blue.Y = 1.0;\n\n    *nItems = 1;\n    return (void*) chrm;\n\nError:\n    _cmsFree(self ->ContextID, (void*) chrm);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  SaveOneChromaticity(cmsFloat64Number x, cmsFloat64Number y, cmsIOHANDLER* io)\n{\n    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(x))) return FALSE;\n    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(y))) return FALSE;\n\n    return TRUE;\n}\n\nstatic\ncmsBool  Type_Chromaticity_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsCIExyYTRIPLE* chrm = (cmsCIExyYTRIPLE*) Ptr;\n\n    if (!_cmsWriteUInt16Number(io, 3)) return FALSE;        // nChannels\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Table\n\n    if (!SaveOneChromaticity(chrm -> Red.x,   chrm -> Red.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Green.x, chrm -> Green.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Blue.x,  chrm -> Blue.y, io)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Chromaticity_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigColorantOrderType\n// ********************************************************************************\n\n// This is an optional tag which specifies the laydown order in which colorants will\n// be printed on an n-colorant device. The laydown order may be the same as the\n// channel generation order listed in the colorantTableTag or the channel order of a\n// colour space such as CMYK, in which case this tag is not needed. When this is not\n// the case (for example, ink-towers sometimes use the order KCMY), this tag may be\n// used to specify the laydown order of the colorants.\n\n\nstatic\nvoid *Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number* ColorantOrder;\n    cmsUInt32Number Count;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (Count > cmsMAXCHANNELS) return NULL;\n\n    ColorantOrder = (cmsUInt8Number*) _cmsCalloc(self ->ContextID, cmsMAXCHANNELS, sizeof(cmsUInt8Number));\n    if (ColorantOrder == NULL) return NULL;\n\n    // We use FF as end marker\n    memset(ColorantOrder, 0xFF, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    if (io ->Read(io, ColorantOrder, sizeof(cmsUInt8Number), Count) != Count) {\n\n        _cmsFree(self ->ContextID, (void*) ColorantOrder);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) ColorantOrder;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool Type_ColorantOrderType_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number*  ColorantOrder = (cmsUInt8Number*) Ptr;\n    cmsUInt32Number i, sz, Count;\n\n    // Get the length\n    for (Count=i=0; i < cmsMAXCHANNELS; i++) {\n        if (ColorantOrder[i] != 0xFF) Count++;\n    }\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n\n    sz = Count * sizeof(cmsUInt8Number);\n    if (!io -> Write(io, sz, ColorantOrder)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_ColorantOrderType_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_ColorantOrderType_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigS15Fixed16ArrayType\n// ********************************************************************************\n// This type represents an array of generic 4-byte/32-bit fixed point quantity.\n// The number of values is determined from the size of the tag.\n\nstatic\nvoid *Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &array_double[i])) {\n\n            _cmsFree(self ->ContextID, array_double);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}\n\nstatic\ncmsBool Type_S15Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_S15Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}\n\n\nstatic\nvoid Type_S15Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigU16Fixed16ArrayType\n// ********************************************************************************\n// This type represents an array of generic 4-byte/32-bit quantity.\n// The number of values is determined from the size of the tag.\n\n\nstatic\nvoid *Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number v;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsReadUInt32Number(io, &v)) {\n            _cmsFree(self ->ContextID, (void*) array_double);\n            return NULL;\n        }\n\n        // Convert to cmsFloat64Number\n        array_double[i] =  (cmsFloat64Number) (v / 65536.0);\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}\n\nstatic\ncmsBool Type_U16Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        cmsUInt32Number v = (cmsUInt32Number) floor(Value[i]*65536.0 + 0.5);\n\n        if (!_cmsWriteUInt32Number(io, v)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_U16Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}\n\nstatic\nvoid Type_U16Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigSignatureType\n// ********************************************************************************\n//\n// The signatureType contains a four-byte sequence, Sequences of less than four\n// characters are padded at the end with spaces, 20h.\n// Typically this type is used for registered tags that can be displayed on many\n// development systems as a sequence of four characters.\n\nstatic\nvoid *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));\n    if (SigPtr == NULL) return NULL;\n\n     if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;\n     *nItems = 1;\n\n     return SigPtr;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_Signature_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSignature* SigPtr = (cmsSignature*) Ptr;\n\n    return _cmsWriteUInt32Number(io, *SigPtr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Signature_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsSignature));\n}\n\nstatic\nvoid Type_Signature_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigTextType\n// ********************************************************************************\n//\n// The textType is a simple text structure that contains a 7-bit ASCII text string.\n// The length of the string is obtained by subtracting 8 from the element size portion\n// of the tag itself. This string must be terminated with a 00h byte.\n\nstatic\nvoid *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    cmsMLU* mlu = NULL;\n\n    // Create a container\n    mlu = cmsMLUalloc(self ->ContextID, 1);\n    if (mlu == NULL) return NULL;\n\n    *nItems = 0;\n\n    // We need to store the \"\\0\" at the end, so +1\n    if (SizeOfTag == UINT_MAX) goto Error;\n\n    Text = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n    if (Text == NULL) goto Error;\n\n    if (io -> Read(io, Text, sizeof(char), SizeOfTag) != SizeOfTag) goto Error;\n\n    // Make sure text is properly ended\n    Text[SizeOfTag] = 0;\n    *nItems = 1;\n\n    // Keep the result\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n\n    _cmsFree(self ->ContextID, Text);\n    return (void*) mlu;\n\nError:\n    if (mlu != NULL)\n        cmsMLUfree(mlu);\n    if (Text != NULL)\n        _cmsFree(self ->ContextID, Text);\n\n    return NULL;\n}\n\n// The conversion implies to choose a language. So, we choose the actual language.\nstatic\ncmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsUInt32Number size;\n    cmsBool  rc;\n    char* Text;\n\n    // Get the size of the string. Note there is an extra \"\\0\" at the end\n    size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    if (size == 0) return FALSE;       // Cannot be zero!\n\n    // Create memory\n    Text = (char*) _cmsMalloc(self ->ContextID, size);\n    if (Text == NULL) return FALSE;\n\n    cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);\n\n    // Write it, including separator\n    rc = io ->Write(io, size, Text);\n\n    _cmsFree(self ->ContextID, Text);\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_Text_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\ncmsTagTypeSignature DecideTextType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextType;\n\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDataType\n// ********************************************************************************\n\n// General purpose data type\nstatic\nvoid *Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCData* BinData;\n    cmsUInt32Number LenOfData;\n\n    *nItems = 0;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    LenOfData = SizeOfTag - sizeof(cmsUInt32Number);\n    if (LenOfData > INT_MAX) return NULL;\n\n    BinData = (cmsICCData*) _cmsMalloc(self ->ContextID, sizeof(cmsICCData) + LenOfData - 1);\n    if (BinData == NULL) return NULL;\n\n    BinData ->len = LenOfData;\n    if (!_cmsReadUInt32Number(io, &BinData->flag)) {\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    if (io -> Read(io, BinData ->data, sizeof(cmsUInt8Number), LenOfData) != LenOfData) {\n\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    *nItems = 1;\n\n    return (void*) BinData;\n}\n\n\nstatic\ncmsBool Type_Data_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n   cmsICCData* BinData = (cmsICCData*) Ptr;\n\n   if (!_cmsWriteUInt32Number(io, BinData ->flag)) return FALSE;\n\n   return io ->Write(io, BinData ->len, BinData ->data);\n\n   cmsUNUSED_PARAMETER(nItems);\n   cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Data_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsICCData* BinData = (cmsICCData*) Ptr;\n\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCData) + BinData ->len - 1);\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Data_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigTextDescriptionType\n// ********************************************************************************\n\nstatic\nvoid *Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    cmsMLU* mlu = NULL;\n    cmsUInt32Number  AsciiCount;\n    cmsUInt32Number  i, UnicodeCode, UnicodeCount;\n    cmsUInt16Number  ScriptCodeCode, Dummy;\n    cmsUInt8Number   ScriptCodeCount;\n\n    *nItems = 0;\n\n    //  One dword should be there\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    // Read len of ASCII\n    if (!_cmsReadUInt32Number(io, &AsciiCount)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Check for size\n    if (SizeOfTag < AsciiCount) return NULL;\n\n    // All seems Ok, allocate the container\n    mlu = cmsMLUalloc(self ->ContextID, 1);\n    if (mlu == NULL) return NULL;\n\n    // As many memory as size of tag\n    Text = (char*) _cmsMalloc(self ->ContextID, AsciiCount + 1);\n    if (Text == NULL) goto Error;\n\n    // Read it\n    if (io ->Read(io, Text, sizeof(char), AsciiCount) != AsciiCount) goto Error;\n    SizeOfTag -= AsciiCount;\n\n    // Make sure there is a terminator\n    Text[AsciiCount] = 0;\n\n    // Set the MLU entry. From here we can be tolerant to wrong types\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n    _cmsFree(self ->ContextID, (void*) Text);\n    Text = NULL;\n\n    // Skip Unicode code\n    if (SizeOfTag < 2* sizeof(cmsUInt32Number)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCode)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCount)) goto Done;\n    SizeOfTag -= 2* sizeof(cmsUInt32Number);\n\n    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n\n    for (i=0; i < UnicodeCount; i++) {\n        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n    }\n    SizeOfTag -= UnicodeCount*sizeof(cmsUInt16Number);\n\n    // Skip ScriptCode code if present. Some buggy profiles does have less\n    // data that stricttly required. We need to skip it as this type may come\n    // embedded in other types.\n\n    if (SizeOfTag >= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number) + 67) {\n\n        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;\n        if (!_cmsReadUInt8Number(io,  &ScriptCodeCount)) goto Done;\n\n        // Skip rest of tag\n        for (i=0; i < 67; i++) {\n            if (!io ->Read(io, &Dummy, sizeof(cmsUInt8Number), 1)) goto Error;\n        }\n    }\n\nDone:\n\n    *nItems = 1;\n    return mlu;\n\nError:\n    if (Text) _cmsFree(self ->ContextID, (void*) Text);\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}\n\n\n// This tag can come IN UNALIGNED SIZE. In order to prevent issues, we force zeros on description to align it\nstatic\ncmsBool  Type_Text_Description_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    char *Text = NULL;\n    wchar_t *Wide = NULL;\n    cmsUInt32Number len, len_text, len_tag_requirement, len_aligned;\n    cmsBool  rc = FALSE;\n    char Filler[68];\n\n    // Used below for writting zeroes\n    memset(Filler, 0, sizeof(Filler));\n\n    // Get the len of string\n    len = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n\n    // Specification ICC.1:2001-04 (v2.4.0): It has been found that textDescriptionType can contain misaligned data\n    //(see clause 4.1 for the definition of \ufffdaligned\ufffd). Because the Unicode language\n    // code and Unicode count immediately follow the ASCII description, their\n    // alignment is not correct if the ASCII count is not a multiple of four. The\n    // ScriptCode code is misaligned when the ASCII count is odd. Profile reading and\n    // writing software must be written carefully in order to handle these alignment\n    // problems.\n    //\n    // The above last sentence suggest to handle alignment issues in the\n    // parser. The provided example (Table 69 on Page 60) makes this clear. \n    // The padding only in the ASCII count is not sufficient for a aligned tag\n    // size, with the same text size in ASCII and Unicode.\n\n    // Null strings\n    if (len <= 0) {\n\n        Text = (char*)    _cmsDupMem(self ->ContextID, \"\", sizeof(char));\n        Wide = (wchar_t*) _cmsDupMem(self ->ContextID, L\"\", sizeof(wchar_t));\n    }\n    else {\n        // Create independent buffers\n        Text = (char*) _cmsCalloc(self ->ContextID, len, sizeof(char));\n        if (Text == NULL) goto Error;\n\n        Wide = (wchar_t*) _cmsCalloc(self ->ContextID, len, sizeof(wchar_t));\n        if (Wide == NULL) goto Error;\n\n        // Get both representations.\n        cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry,  Text, len * sizeof(char));\n        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n    }\n\n    // Tell the real text len including the null terminator and padding\n    len_text = (cmsUInt32Number) strlen(Text) + 1;\n    // Compute an total tag size requirement\n    len_tag_requirement = (8+4+len_text+4+4+2*len_text+2+1+67);\n    len_aligned = _cmsALIGNLONG(len_tag_requirement);\n\n  // * cmsUInt32Number       count;          * Description length\n  // * cmsInt8Number         desc[count]     * NULL terminated ascii string\n  // * cmsUInt32Number       ucLangCode;     * UniCode language code\n  // * cmsUInt32Number       ucCount;        * UniCode description length\n  // * cmsInt16Number        ucDesc[ucCount];* The UniCode description\n  // * cmsUInt16Number       scCode;         * ScriptCode code\n  // * cmsUInt8Number        scCount;        * ScriptCode count\n  // * cmsInt8Number         scDesc[67];     * ScriptCode Description\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    if (!io ->Write(io, len_text, Text)) goto Error;\n\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // ucLanguageCode\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    // Note that in some compilers sizeof(cmsUInt16Number) != sizeof(wchar_t)\n    if (!_cmsWriteWCharArray(io, len_text, Wide)) goto Error;\n\n    // ScriptCode Code & count (unused)\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt8Number(io, 0)) goto Error;\n\n    if (!io ->Write(io, 67, Filler)) goto Error;\n\n    // possibly add pad at the end of tag\n    if(len_aligned - len_tag_requirement > 0)\n      if (!io ->Write(io, len_aligned - len_tag_requirement, Filler)) goto Error;\n\n    rc = TRUE;\n\nError:\n    if (Text) _cmsFree(self ->ContextID, Text);\n    if (Wide) _cmsFree(self ->ContextID, Wide);\n\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_Text_Description_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\ncmsTagTypeSignature DecideTextDescType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextDescriptionType;\n\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type cmsSigCurveType\n// ********************************************************************************\n\nstatic\nvoid *Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number Count;\n    cmsToneCurve* NewGamma;\n    \n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    switch (Count) {\n\n           case 0:   // Linear.\n               {\n                   cmsFloat64Number SingleGamma = 1.0;\n\n                   NewGamma = cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n                   if (!NewGamma) return NULL;\n                   *nItems = 1;\n                   return NewGamma;\n               }\n              \n           case 1:  // Specified as the exponent of gamma function\n               {\n                   cmsUInt16Number SingleGammaFixed;\n                   cmsFloat64Number SingleGamma;\n\n                   if (!_cmsReadUInt16Number(io, &SingleGammaFixed)) return NULL;\n                   SingleGamma = _cms8Fixed8toDouble(SingleGammaFixed);\n\n                   *nItems = 1;\n                   return cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n               }\n\n           default:  // Curve\n\n               if (Count > 0x7FFF)\n                   return NULL; // This is to prevent bad guys for doing bad things\n\n               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, Count, NULL);\n               if (!NewGamma) return NULL;\n\n               if (!_cmsReadUInt16Array(io, Count, NewGamma -> Table16)) return NULL;\n\n               *nItems = 1;\n               return NewGamma;\n    }\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_Curve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n\n    if (Curve ->nSegments == 1 && Curve ->Segments[0].Type == 1) {\n\n            // Single gamma, preserve number\n            cmsUInt16Number SingleGammaFixed = _cmsDoubleTo8Fixed8(Curve ->Segments[0].Params[0]);\n\n            if (!_cmsWriteUInt32Number(io, 1)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, SingleGammaFixed)) return FALSE;\n            return TRUE;\n\n    }\n\n    if (!_cmsWriteUInt32Number(io, Curve ->nEntries)) return FALSE;\n    return _cmsWriteUInt16Array(io, Curve ->nEntries, Curve ->Table16);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Curve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_Curve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigParametricCurveType\n// ********************************************************************************\n\n\n// Decide which curve type to use on writting\nstatic\ncmsTagTypeSignature DecideCurveType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Data;\n\n    if (ICCVersion < 4.0) return cmsSigCurveType;\n    if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric\n    if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves\n    if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves\n\n    return cmsSigParametricCurveType;\n}\n\nstatic\nvoid *Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    static const int ParamsByType[] = { 1, 3, 4, 5, 7 };\n    cmsFloat64Number Params[10];\n    cmsUInt16Number Type;\n    int i, n;\n    cmsToneCurve* NewGamma;\n\n    if (!_cmsReadUInt16Number(io, &Type)) return NULL;\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;   // Reserved\n\n    if (Type > 4) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown parametric curve type '%d'\", Type);\n        return NULL;\n    }\n\n    memset(Params, 0, sizeof(Params));\n    n = ParamsByType[Type];\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &Params[i])) return NULL;\n    }\n\n    NewGamma = cmsBuildParametricToneCurve(self ->ContextID, Type+1, Params);\n\n    *nItems = 1;\n    return NewGamma;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_ParametricCurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n    int i, nParams, typen;\n    static const int ParamsByType[] = { 0, 1, 3, 4, 5, 7 };\n\n    typen = Curve -> Segments[0].Type;\n\n    if (Curve ->nSegments > 1 || typen < 1) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Multisegment or Inverted parametric curves cannot be written\");\n        return FALSE;\n    }\n\n    if (typen > 5) {\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported parametric curve\");\n        return FALSE;\n    }\n\n    nParams = ParamsByType[typen];\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) (Curve ->Segments[0].Type - 1))) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Reserved\n\n    for (i=0; i < nParams; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Curve -> Segments[0].Params[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_ParametricCurve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ParametricCurve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDateTimeType\n// ********************************************************************************\n\n// A 12-byte value representation of the time and date, where the byte usage is assigned\n// as specified in table 1. The actual values are encoded as 16-bit unsigned integers\n// (uInt16Number - see 5.1.6).\n//\n// All the dateTimeNumber values in a profile shall be in Coordinated Universal Time\n// (UTC, also known as GMT or ZULU Time). Profile writers are required to convert local\n// time to UTC when setting these values. Programmes that display these values may show\n// the dateTimeNumber as UTC, show the equivalent local time (at current locale), or\n// display both UTC and local versions of the dateTimeNumber.\n\nstatic\nvoid *Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsDateTimeNumber timestamp;\n    struct tm * NewDateTime;\n\n    *nItems = 0;\n    NewDateTime = (struct tm*) _cmsMalloc(self ->ContextID, sizeof(struct tm));\n    if (NewDateTime == NULL) return NULL;\n\n    if (io->Read(io, &timestamp, sizeof(cmsDateTimeNumber), 1) != 1) return NULL;\n\n     _cmsDecodeDateTimeNumber(&timestamp, NewDateTime);\n\n     *nItems = 1;\n     return NewDateTime;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_DateTime_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    struct tm * DateTime = (struct tm*) Ptr;\n    cmsDateTimeNumber timestamp;\n\n    _cmsEncodeDateTimeNumber(&timestamp, DateTime);\n    if (!io ->Write(io, sizeof(cmsDateTimeNumber), &timestamp)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_DateTime_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(struct tm));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_DateTime_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n\n// ********************************************************************************\n// Type icMeasurementType\n// ********************************************************************************\n\n/*\nThe measurementType information refers only to the internal profile data and is\nmeant to provide profile makers an alternative to the default measurement\nspecifications.\n*/\n\nstatic\nvoid *Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCMeasurementConditions mc;\n\n\t\n    memset(&mc, 0, sizeof(mc));\n\t\n    if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;\n    if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &mc.Flare)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.IlluminantType)) return NULL;\n\n    *nItems = 1;\n    return _cmsDupMem(self ->ContextID, &mc, sizeof(cmsICCMeasurementConditions));\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_Measurement_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCMeasurementConditions* mc =(cmsICCMeasurementConditions*) Ptr;\n\n    if (!_cmsWriteUInt32Number(io, mc->Observer)) return FALSE;\n    if (!_cmsWriteXYZNumber(io,    &mc->Backing)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->Geometry)) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, mc->Flare)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCMeasurementConditions));\n\n     cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Measurement_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigMultiLocalizedUnicodeType\n// ********************************************************************************\n//\n//   Do NOT trust SizeOfTag as there is an issue on the definition of profileSequenceDescTag. See the TechNote from\n//   Max Derhak and Rohit Patil about this: basically the size of the string table should be guessed and cannot be\n//   taken from the size of tag if this tag is embedded as part of bigger structures (profileSequenceDescTag, for instance)\n//\n\nstatic\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        // Now deal with Len and offset.\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n\n        // Check for overflow\n        if (Offset < (SizeOfHeader + 8)) goto Error;\n\n        // True begin of the string\n        BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        // Ajust to wchar_t elements\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        // To guess maximum size, add offset + len\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    // Now read the remaining of tag and fill all strings. Subtract the directory\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n        NumOfWchar = 0;\n\n    }\n    else\n    {\n        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n        if (Block == NULL) goto Error;\n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}\n\nstatic\ncmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu =(cmsMLU*) Ptr;\n    cmsUInt32Number HeaderSize;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number i;\n\n    if (Ptr == NULL) {\n\n          // Empty placeholder\n          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n          if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n          return TRUE;\n    }\n\n    if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n\n    HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);\n\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        Len    =  mlu ->Entries[i].Len;\n        Offset =  mlu ->Entries[i].StrW;\n\n        Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);\n        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;\n\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;\n        if (!_cmsWriteUInt32Number(io, Len)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;\n    }\n\n    if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_MLU_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_MLU_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigLut8Type\n// ********************************************************************************\n\n// Decide which LUT type to use on writting\nstatic\ncmsTagTypeSignature DecideLUTtypeA2B(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutAtoBType;\n    }\n}\n\nstatic\ncmsTagTypeSignature DecideLUTtypeB2A(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutBtoAType;\n    }\n}\n\n/*\nThis structure represents a colour transform using tables of 8-bit precision.\nThis type contains four processing elements: a 3 by 3 matrix (which shall be\nthe identity matrix unless the input colour space is XYZ), a set of one dimensional\ninput tables, a multidimensional lookup table, and a set of one dimensional output\ntables. Data is processed using these elements via the following sequence:\n(matrix) -> (1d input tables)  -> (multidimensional lookup table - CLUT) -> (1d output tables)\n\nByte Position   Field Length (bytes)  Content Encoded as...\n8                  1          Number of Input Channels (i)    uInt8Number\n9                  1          Number of Output Channels (o)   uInt8Number\n10                 1          Number of CLUT grid points (identical for each side) (g) uInt8Number\n11                 1          Reserved for padding (fill with 00h)\n\n12..15             4          Encoded e00 parameter   s15Fixed16Number\n*/\n\n\n// Read 8 bit tables as gamma functions\nstatic\ncmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)\n{\n    cmsUInt8Number* Temp = NULL;\n    int i, j;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n    if (nChannels <= 0) return FALSE;\n\n    memset(Tables, 0, sizeof(Tables));\n\n    Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);\n    if (Temp == NULL) return FALSE;\n\n    for (i=0; i < nChannels; i++) {\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n        if (Tables[i] == NULL) goto Error;\n    }\n\n    for (i=0; i < nChannels; i++) {\n\n        if (io ->Read(io, Temp, 256, 1) != 1) goto Error;\n\n        for (j=0; j < 256; j++)\n            Tables[i]->Table16[j] = (cmsUInt16Number) FROM_8_TO_16(Temp[j]);\n    }\n\n    _cmsFree(ContextID, Temp);\n    Temp = NULL;\n\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    if (Temp) _cmsFree(ContextID, Temp);\n    return FALSE;\n}\n\n\nstatic\ncmsBool Write8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsUInt32Number n, _cmsStageToneCurvesData* Tables)\n{\n    int j;\n    cmsUInt32Number i;\n    cmsUInt8Number val;\n\n    for (i=0; i < n; i++) {\n\n        if (Tables) {\n\n            // Usual case of identity curves\n            if ((Tables ->TheCurves[i]->nEntries == 2) && \n                (Tables->TheCurves[i]->Table16[0] == 0) && \n                (Tables->TheCurves[i]->Table16[1] == 65535)) {\n\n                    for (j=0; j < 256; j++) {\n                        if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) j)) return FALSE;\n                    }\n            }\n            else \n                if (Tables ->TheCurves[i]->nEntries != 256) {\n                    cmsSignalError(ContextID, cmsERROR_RANGE, \"LUT8 needs 256 entries on prelinearization\");\n                    return FALSE;                \n                }\n                else\n                    for (j=0; j < 256; j++) {\n\n                        val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);\n\n                        if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n                    }\n        }\n    }\n    return TRUE;\n}\n\n\n// Check overflow\nstatic\ncmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)\n{\n    cmsUInt32Number rv = 1, rc;\n\n    if (a == 0) return 0;\n    if (n == 0) return 0;\n\n    for (; b > 0; b--) {\n\n        rv *= a;\n\n        // Check for overflow\n        if (rv > UINT_MAX / a) return (cmsUInt32Number) -1;\n\n    }\n\n    rc = rv * n;\n\n    if (rv != rc / n) return (cmsUInt32Number) -1;\n    return rc;\n}\n\n\n// That will create a MPE LUT with Matrix, pre tables, CLUT and post tables.\n// 8 bit lut may be scaled easely to v4 PCS, but we need also to properly adjust\n// PCS on BToAxx tags and AtoB if abstract. We need to fix input direction.\n\nstatic\nvoid *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsUInt8Number* Temp = NULL;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize, i;\n    cmsFloat64Number Matrix[3*3];\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) goto Error;\n\n     if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) goto Error;\n\n    // Do some checking\n    if (InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels > cmsMAXCHANNELS) goto Error;\n\n   // Allocates an empty Pipeline\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates if not identity...\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    // Get input tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, InputChannels)) goto Error;\n\n    // Get 3D CLUT. Check the overflow....\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *PtrW, *T;\n       \n        PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);\n        if (Temp == NULL) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (io ->Read(io, Temp, nTabSize, 1) != 1) {\n            _cmsFree(self ->ContextID, T);\n            _cmsFree(self ->ContextID, Temp);\n            goto Error;\n        }\n\n        for (i = 0; i < nTabSize; i++) {\n\n            *PtrW++ = FROM_8_TO_16(Temp[i]);\n        }\n        _cmsFree(self ->ContextID, Temp);\n        Temp = NULL;\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T)))\n            goto Error;\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, OutputChannels)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// We only allow a specific MPE structure: Matrix plus prelin, plus clut, plus post-lin.\nstatic\ncmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number j, nTabSize;\n    cmsUInt8Number  val;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    int clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n    if (mpe ->Type == cmsSigMatrixElemType) {\n\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT8\");\n        return FALSE;\n    }\n\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else\n        clutPoints    = clut->Params->nSamples[0];\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->OutputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n\n\n    if (MatMPE != NULL) {\n\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;\n\n    }\n    else {\n\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n    // The prelinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;\n\n    nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n\n        // The 3D CLUT.\n        if (clut != NULL) {\n\n            for (j=0; j < nTabSize; j++) {\n\n                val = (cmsUInt8Number) FROM_16_TO_8(clut ->Tab.T[j]);\n                if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n            }\n        }\n    }\n\n    // The postlinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->OutputChannels, PostMPE)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_LUT8_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUT8_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// ********************************************************************************\n// Type cmsSigLut16Type\n// ********************************************************************************\n\n// Read 16 bit tables as gamma functions\nstatic\ncmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)\n{\n    int i;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    // Maybe an empty table? (this is a lcms extension)\n    if (nEntries <= 0) return TRUE;\n\n    // Check for malicious profiles\n    if (nEntries < 2) return FALSE;\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n\n    // Init table to zero\n    memset(Tables, 0, sizeof(Tables));\n\n    for (i=0; i < nChannels; i++) {\n\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, nEntries, NULL);\n        if (Tables[i] == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nEntries, Tables[i]->Table16)) goto Error;\n    }\n\n\n    // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    return FALSE;\n}\n\nstatic\ncmsBool Write16bitTables(cmsContext ContextID, cmsIOHANDLER* io, _cmsStageToneCurvesData* Tables)\n{\n    int j;\n    cmsUInt32Number i;\n    cmsUInt16Number val;\n    int nEntries;\n\n    _cmsAssert(Tables != NULL);\n\n    nEntries = Tables->TheCurves[0]->nEntries;\n\n    for (i=0; i < Tables ->nCurves; i++) {\n\n        for (j=0; j < nEntries; j++) {\n\n            val = Tables->TheCurves[i]->Table16[j];        \n            if (!_cmsWriteUInt16Number(io, val)) return FALSE;\n        }\n    }\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(ContextID);\n}\n\nstatic\nvoid *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize;\n    cmsFloat64Number Matrix[3*3];\n    cmsUInt16Number InputEntries, OutputEntries;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) return NULL;   // 255 maximum\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    // Do some checking\n    if (InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels > cmsMAXCHANNELS) goto Error;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates on 3 channels\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;\n    if (!_cmsReadUInt16Number(io, &OutputEntries)) goto Error;\n\n    if (InputEntries > 0x7FFF || OutputEntries > 0x7FFF) goto Error;\n    if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Get input tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, InputChannels, InputEntries)) goto Error;\n\n    // Get 3D CLUT\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *T;\n\n        T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nTabSize, T)) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, OutputChannels, OutputEntries)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// We only allow some specific MPE structures: Matrix plus prelin, plus clut, plus post-lin.\n// Some empty defaults are created for missing parts\n\nstatic\ncmsBool  Type_LUT16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number nTabSize;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    int i, InputChannels, OutputChannels, clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n    if (mpe != NULL && mpe ->Type == cmsSigMatrixElemType) {\n\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT16\");\n        return FALSE;\n    }\n\n    InputChannels  = cmsPipelineInputChannels(NewLUT);\n    OutputChannels = cmsPipelineOutputChannels(NewLUT);\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else\n        clutPoints    = clut->Params->nSamples[0];\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) InputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) OutputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n\n\n    if (MatMPE != NULL) {\n\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;\n    }\n    else {\n\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n\n    if (PreMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n            if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n    }\n\n    if (PostMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n    }\n\n    // The prelinearization table\n\n    if (PreMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < InputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    nTabSize = uipow(OutputChannels, clutPoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n        // The 3D CLUT.\n        if (clut != NULL) {\n            if (!_cmsWriteUInt16Array(io, nTabSize, clut->Tab.T)) return FALSE;\n        }\n    }\n\n    // The postlinearization table\n    if (PostMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < OutputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_LUT16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUT16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigLutAToBType\n// ********************************************************************************\n\n\n// V4 stuff. Read matrix for LutAtoB and LutBtoA\n\nstatic\ncmsStage* ReadMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset)\n{\n    cmsFloat64Number dMat[3*3];\n    cmsFloat64Number dOff[3];\n    cmsStage* Mat;\n\n    // Go to address\n    if (!io -> Seek(io, Offset)) return NULL;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io, &dMat[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[2])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[3])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[4])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[5])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[6])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[7])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[8])) return NULL;\n\n    if (!_cmsRead15Fixed16Number(io, &dOff[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[2])) return NULL;\n\n    Mat = cmsStageAllocMatrix(self ->ContextID, 3, 3, dMat, dOff);\n\n     return Mat;\n}\n\n\n\n\n//  V4 stuff. Read CLUT part for LutAtoB and LutBtoA\n\nstatic\ncmsStage* ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, int InputChannels, int OutputChannels)\n{\n    cmsUInt8Number  gridPoints8[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number GridPoints[cmsMAXCHANNELS], i;\n    cmsUInt8Number  Precision;\n    cmsStage* CLUT;\n    _cmsStageCLutData* Data;\n\n    if (!io -> Seek(io, Offset)) return NULL;\n    if (io -> Read(io, gridPoints8, cmsMAXCHANNELS, 1) != 1) return NULL;\n\n\n    for (i=0; i < cmsMAXCHANNELS; i++) {\n\n        if (gridPoints8[i] == 1) return NULL; // Impossible value, 0 for no CLUT and then 2 at least\n        GridPoints[i] = gridPoints8[i];\n    }\n\n    if (!_cmsReadUInt8Number(io, &Precision)) return NULL;\n\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    CLUT = cmsStageAllocCLut16bitGranular(self ->ContextID, GridPoints, InputChannels, OutputChannels, NULL);\n    if (CLUT == NULL) return NULL;\n\n    Data = (_cmsStageCLutData*) CLUT ->Data;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        cmsUInt8Number  v;\n\n        for (i=0; i < Data ->nEntries; i++) {\n\n            if (io ->Read(io, &v, sizeof(cmsUInt8Number), 1) != 1) return NULL;\n            Data ->Tab.T[i] = FROM_8_TO_16(v);\n        }\n\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsReadUInt16Array(io, Data->nEntries, Data ->Tab.T)) {\n                cmsStageFree(CLUT);\n                return NULL;\n            }\n        }\n        else {\n            cmsStageFree(CLUT);\n            cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return NULL;\n        }\n\n        return CLUT;\n}\n\nstatic\ncmsToneCurve* ReadEmbeddedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n    switch (BaseType) {\n\n            case cmsSigCurveType:\n                return (cmsToneCurve*) Type_Curve_Read(self, io, &nItems, 0);\n\n            case cmsSigParametricCurveType:\n                return (cmsToneCurve*) Type_ParametricCurve_Read(self, io, &nItems, 0);\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) BaseType);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return NULL;\n    }\n}\n\n\n// Read a set of curves from specific offset\nstatic\ncmsStage* ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, cmsUInt32Number nCurves)\n{\n    cmsToneCurve* Curves[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n    cmsStage* Lin = NULL;\n\n    if (nCurves > cmsMAXCHANNELS) return FALSE;\n\n    if (!io -> Seek(io, Offset)) return FALSE;\n\n    for (i=0; i < nCurves; i++)\n        Curves[i] = NULL;\n\n    for (i=0; i < nCurves; i++) {\n\n        Curves[i] = ReadEmbeddedCurve(self, io);\n        if (Curves[i] == NULL) goto Error;\n        if (!_cmsReadAlignment(io)) goto Error;\n\n    }\n\n    Lin = cmsStageAllocToneCurves(self ->ContextID, nCurves, Curves);\n\nError:\n    for (i=0; i < nCurves; i++)\n        cmsFreeToneCurve(Curves[i]);\n\n    return Lin;\n}\n\n\n// LutAtoB type\n\n// This structure represents a colour transform. The type contains up to five processing\n// elements which are stored in the AtoBTag tag in the following order: a set of one\n// dimensional curves, a 3 by 3 matrix with offset terms, a set of one dimensional curves,\n// a multidimensional lookup table, and a set of one dimensional output curves.\n// Data are processed using these elements via the following sequence:\n//\n//(\"A\" curves) -> (multidimensional lookup table - CLUT) -> (\"M\" curves) -> (matrix) -> (\"B\" curves).\n//\n/*\nIt is possible to use any or all of these processing elements. At least one processing element\nmust be included.Only the following combinations are allowed:\n\nB\nM - Matrix - B\nA - CLUT - B\nA - CLUT - M - Matrix - B\n\n*/\n\nstatic\nvoid* Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number      BaseOffset;\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n   // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// Write a set of curves\nstatic\ncmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)\n{\n    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;\n\n    // Write the Matrix\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;\n\n    if (m ->Offset != NULL) {\n\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;\n    }\n    else {\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n\n    }\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// Write a set of curves\nstatic\ncmsBool WriteSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsTagTypeSignature Type, cmsStage* mpe)\n{\n    cmsUInt32Number i, n;\n    cmsTagTypeSignature CurrentType;\n    cmsToneCurve** Curves;\n\n\n    n      = cmsStageOutputChannels(mpe);\n    Curves = _cmsStageGetPtrToCurveSet(mpe);\n\n    for (i=0; i < n; i++) {\n\n        // If this is a table-based curve, use curve type even on V4\n        CurrentType = Type;\n\n        if ((Curves[i] ->nSegments == 0)||\n            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n            CurrentType = cmsSigCurveType;\n        else\n        if (Curves[i] ->Segments[0].Type < 0)\n            CurrentType = cmsSigCurveType;\n\n        if (!_cmsWriteTypeBase(io, CurrentType)) return FALSE;\n\n        switch (CurrentType) {\n\n            case cmsSigCurveType:\n                if (!Type_Curve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            case cmsSigParametricCurveType:\n                if (!Type_ParametricCurve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) Type);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return FALSE;\n        }\n\n        if (!_cmsWriteAlignment(io)) return FALSE;\n    }\n\n\n    return TRUE;\n}\n\n\nstatic\ncmsBool WriteCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt8Number  Precision, cmsStage* mpe)\n{\n    cmsUInt8Number  gridPoints[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number i;\n    _cmsStageCLutData* CLUT = ( _cmsStageCLutData*) mpe -> Data;\n\n    if (CLUT ->HasFloatValues) {\n         cmsSignalError(self ->ContextID, cmsERROR_NOT_SUITABLE, \"Cannot save floating point data, CLUT are 8 or 16 bit only\");\n         return FALSE;\n    }\n\n    memset(gridPoints, 0, sizeof(gridPoints));\n    for (i=0; i < (cmsUInt32Number) CLUT ->Params ->nInputs; i++)\n        gridPoints[i] = (cmsUInt8Number) CLUT ->Params ->nSamples[i];\n\n    if (!io -> Write(io, cmsMAXCHANNELS*sizeof(cmsUInt8Number), gridPoints)) return FALSE;\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) Precision)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        for (i=0; i < CLUT->nEntries; i++) {\n\n            if (!_cmsWriteUInt8Number(io, FROM_16_TO_8(CLUT->Tab.T[i]))) return FALSE;\n        }\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsWriteUInt16Array(io, CLUT->nEntries, CLUT ->Tab.T)) return FALSE;\n        }\n        else {\n             cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return FALSE;\n        }\n\n        if (!_cmsWriteAlignment(io)) return FALSE;\n\n        return TRUE;\n}\n\n\n\n\nstatic\ncmsBool Type_LUTA2B_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    int inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage * Matrix = NULL;\n    cmsStage * CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n    // Get the base for all offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (Lut ->Elements != NULL)\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &M, &Matrix, &B))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &A, &CLUT, &B))\n                    if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType,\n                        cmsSigMatrixElemType, cmsSigCurveSetElemType, &A, &CLUT, &M, &Matrix, &B)) {\n\n                            cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutAToB\");\n                            return FALSE;\n                    }\n\n    // Get input, output channels\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    // Write channel count\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    // Keep directory to be filled latter\n    DirectoryPos = io ->Tell(io);\n\n    // Write the directory\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_LUTA2B_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUTA2B_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// LutBToA type\n\nstatic\nvoid* Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      BaseOffset;     // Actual position in file\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    // Padding\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n/*\nB\nB - Matrix - M\nB - CLUT - A\nB - Matrix - M - CLUT - A\n*/\n\nstatic\ncmsBool  Type_LUTB2A_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    int inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage *Matrix = NULL;\n    cmsStage *CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &B, &Matrix, &M))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &CLUT, &A))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n                    cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &Matrix, &M, &CLUT, &A)) {\n                        cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutBToA\");\n                        return FALSE;\n                }\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    DirectoryPos = io ->Tell(io);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\n\nstatic\nvoid* Type_LUTB2A_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUTB2A_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\n// ********************************************************************************\n// Type cmsSigColorantTableType\n// ********************************************************************************\n/*\nThe purpose of this tag is to identify the colorants used in the profile by a\nunique name and set of XYZ or L*a*b* values to give the colorant an unambiguous\nvalue. The first colorant listed is the colorant of the first device channel of\na lut tag. The second colorant listed is the colorant of the second device channel\nof a lut tag, and so on.\n*/\n\nstatic\nvoid *Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number i, Count;\n    cmsNAMEDCOLORLIST* List;\n    char Name[34];\n    cmsUInt16Number PCS[3];\n\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (Count > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many colorants '%d'\", Count);\n        return NULL;\n    }\n\n    List = cmsAllocNamedColorList(self ->ContextID, Count, 0, \"\", \"\");\n    for (i=0; i < Count; i++) {\n\n        if (io ->Read(io, Name, 32, 1) != 1) goto Error;\n        Name[33] = 0;\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n\n        if (!cmsAppendNamedColor(List, Name, PCS, NULL)) goto Error;\n\n    }\n\n    *nItems = 1;\n    return List;\n\nError:\n    *nItems = 0;\n    cmsFreeNamedColorList(List);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n\n// Saves a colorant table. It is using the named color structure for simplicity sake\nstatic\ncmsBool  Type_ColorantTable_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    int i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n        char root[33];\n        cmsUInt16Number PCS[3];\n\n        if (!cmsNamedColorInfo(NamedColorList, i, root, NULL, NULL, PCS, NULL)) return 0;\n        root[32] = 0;\n\n        if (!io ->Write(io, 32, root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_ColorantTable_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_ColorantTable_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigNamedColor2Type\n// ********************************************************************************\n//\n//The namedColor2Type is a count value and array of structures that provide color\n//coordinates for 7-bit ASCII color names. For each named color, a PCS and optional\n//device representation of the color are given. Both representations are 16-bit values.\n//The device representation corresponds to the header\ufffds \ufffdcolor space of data\ufffd field.\n//This representation should be consistent with the \ufffdnumber of device components\ufffd\n//field in the namedColor2Type. If this field is 0, device coordinates are not provided.\n//The PCS representation corresponds to the header\ufffds PCS field. The PCS representation\n//is always provided. Color names are fixed-length, 32-byte fields including null\n//termination. In order to maintain maximum portability, it is strongly recommended\n//that special characters of the 7-bit ASCII set not be used.\n\nstatic\nvoid *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n\n    cmsUInt32Number      vendorFlag;     // Bottom 16 bits for ICC use\n    cmsUInt32Number      count;          // Count of named colors\n    cmsUInt32Number      nDeviceCoords;  // Num of device coordinates\n    char                 prefix[32];     // Prefix for each color name\n    char                 suffix[32];     // Suffix for each color name\n    cmsNAMEDCOLORLIST*  v;\n    cmsUInt32Number i;\n\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;\n    if (!_cmsReadUInt32Number(io, &count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;\n\n    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;\n    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;\n\n    prefix[31] = suffix[31] = 0;\n\n    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);\n    if (v == NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many named colors '%d'\", count);\n        return NULL;\n    }\n\n    if (nDeviceCoords > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many device coordinates '%d'\", nDeviceCoords);\n        return 0;\n    }\n    for (i=0; i < count; i++) {\n\n        cmsUInt16Number PCS[3];\n        cmsUInt16Number Colorant[cmsMAXCHANNELS];\n        char Root[33];\n\n        memset(Colorant, 0, sizeof(Colorant));\n        if (io -> Read(io, Root, 32, 1) != 1) return NULL;\n        Root[32] = 0;  // To prevent exploits\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;\n\n        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;\n    }\n\n    *nItems = 1;\n    return (void*) v ;\n\nError:\n    cmsFreeNamedColorList(v);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// Saves a named color list into a named color profile\nstatic\ncmsBool Type_NamedColor_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    char                prefix[33];     // Prefix for each color name\n    char                suffix[33];     // Suffix for each color name\n    int i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, NamedColorList ->ColorantCount)) return FALSE;\n\n    strncpy(prefix, (const char*) NamedColorList->Prefix, 32);\n    strncpy(suffix, (const char*) NamedColorList->Suffix, 32);\n\n    suffix[32] = prefix[32] = 0;\n\n    if (!io ->Write(io, 32, prefix)) return FALSE;\n    if (!io ->Write(io, 32, suffix)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n       cmsUInt16Number PCS[3];\n       cmsUInt16Number Colorant[cmsMAXCHANNELS];\n       char Root[33];\n\n        if (!cmsNamedColorInfo(NamedColorList, i, Root, NULL, NULL, PCS, Colorant)) return 0;\n        Root[32] = 0;\n        if (!io ->Write(io, 32 , Root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, NamedColorList ->ColorantCount, Colorant)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_NamedColor_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigProfileSequenceDescType\n// ********************************************************************************\n\n// This type is an array of structures, each of which contains information from the\n// header fields and tags from the original profiles which were combined to create\n// the final profile. The order of the structures is the order in which the profiles\n// were combined and includes a structure for the final profile. This provides a\n// description of the profile sequence from source to destination,\n// typically used with the DeviceLink profile.\n\nstatic\ncmsBool ReadEmbeddedText(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU** mlu, cmsUInt32Number SizeOfTag)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n\n    switch (BaseType) {\n\n       case cmsSigTextType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu = (cmsMLU*)Type_Text_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       case cmsSigTextDescriptionType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_Text_Description_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n           /*\n           TBD: Size is needed for MLU, and we have no idea on which is the available size\n           */\n\n       case cmsSigMultiLocalizedUnicodeType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_MLU_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       default: return FALSE;\n    }\n}\n\n\nstatic\nvoid *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number i, Count;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n    OutSeq ->n = Count;\n\n    // Get structures as well\n\n    for (i=0; i < Count; i++) {\n\n        cmsPSEQDESC* sec = &OutSeq -> seq[i];\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceMfg)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceModel)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt64Number(io, &sec ->attributes)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt64Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt64Number);\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!ReadEmbeddedText(self, io, &sec ->Manufacturer, SizeOfTag)) goto Error;\n        if (!ReadEmbeddedText(self, io, &sec ->Model, SizeOfTag)) goto Error;\n    }\n\n    *nItems = 1;\n    return OutSeq;\n\nError:\n    cmsFreeProfileSequenceDescription(OutSeq);\n    return NULL;\n}\n\n\n// Aux--Embed a text description type. It can be of type text description or multilocalized unicode\n// and it depends of the version number passed on cmsTagDescriptor structure instead of stack\nstatic\ncmsBool  SaveDescription(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* Text)\n{\n    if (self ->ICCVersion < 0x4000000) {\n\n        if (!_cmsWriteTypeBase(io, cmsSigTextDescriptionType)) return FALSE;\n        return Type_Text_Description_Write(self, io, Text, 1);\n    }\n    else {\n        if (!_cmsWriteTypeBase(io, cmsSigMultiLocalizedUnicodeType)) return FALSE;\n        return Type_MLU_Write(self, io, Text, 1);\n    }\n}\n\n\nstatic\ncmsBool  Type_ProfileSequenceDesc_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, Seq->n)) return FALSE;\n\n    for (i=0; i < Seq ->n; i++) {\n\n        cmsPSEQDESC* sec = &Seq -> seq[i];\n\n        if (!_cmsWriteUInt32Number(io, sec ->deviceMfg)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->deviceModel)) return FALSE;\n        if (!_cmsWriteUInt64Number(io, &sec ->attributes)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->technology)) return FALSE;\n\n        if (!SaveDescription(self, io, sec ->Manufacturer)) return FALSE;\n        if (!SaveDescription(self, io, sec ->Model)) return FALSE;\n    }\n\n     return TRUE;\n\n     cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ProfileSequenceDesc_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigProfileSequenceIdType\n// ********************************************************************************\n/*\nIn certain workflows using ICC Device Link Profiles, it is necessary to identify the\noriginal profiles that were combined to create the Device Link Profile.\nThis type is an array of structures, each of which contains information for\nidentification of a profile used in a sequence\n*/\n\n\nstatic\ncmsBool ReadSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq = (cmsSEQ*) Cargo;\n    cmsPSEQDESC* seq = &OutSeq ->seq[n];\n\n    if (io -> Read(io, seq ->ProfileID.ID8, 16, 1) != 1) return FALSE;\n    if (!ReadEmbeddedText(self, io, &seq ->Description, SizeOfTag)) return FALSE;\n\n    return TRUE;\n}\n\n\n\nstatic\nvoid *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number Count;\n    cmsUInt32Number BaseOffset;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get table count\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Allocate an empty structure\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n\n    // Read the position table\n    if (!ReadPositionTable(self, io, Count, BaseOffset, OutSeq, ReadSeqID)) {\n\n        cmsFreeProfileSequenceDescription(OutSeq);\n        return NULL;\n    }\n\n    // Success\n    *nItems = 1;\n    return OutSeq;\n\n}\n\n\nstatic\ncmsBool WriteSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Cargo;\n\n    if (!io ->Write(io, 16, Seq ->seq[n].ProfileID.ID8)) return FALSE;\n\n    // Store here the MLU\n    if (!SaveDescription(self, io, Seq ->seq[n].Description)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_ProfileSequenceId_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number BaseOffset;\n\n    // Keep the base offset\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // This is the table count\n    if (!_cmsWriteUInt32Number(io, Seq ->n)) return FALSE;\n\n    // This is the position table and content\n    if (!WritePositionTable(self, io, 0, Seq ->n, BaseOffset, Seq, WriteSeqID)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ProfileSequenceId_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigUcrBgType\n// ********************************************************************************\n/*\nThis type contains curves representing the under color removal and black\ngeneration and a text string which is a general description of the method used\nfor the ucr/bg.\n*/\n\nstatic\nvoid *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUcrBg* n = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n    cmsUInt32Number CountUcr, CountBg;\n    char* ASCIIString;\n\n    *nItems = 0;\n    if (n == NULL) return NULL;\n\n    // First curve is Under color removal\n    if (!_cmsReadUInt32Number(io, &CountUcr)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Ucr = cmsBuildTabulatedToneCurve16(self ->ContextID, CountUcr, NULL);\n    if (n ->Ucr == NULL) return NULL;\n\n    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= CountUcr * sizeof(cmsUInt16Number);\n\n    // Second curve is Black generation\n    if (!_cmsReadUInt32Number(io, &CountBg)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Bg = cmsBuildTabulatedToneCurve16(self ->ContextID, CountBg, NULL);\n    if (n ->Bg == NULL) return NULL;\n    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) return NULL;\n    if (SizeOfTag < CountBg * sizeof(cmsUInt16Number)) return NULL;\n    SizeOfTag -= CountBg * sizeof(cmsUInt16Number);\n    if (SizeOfTag == UINT_MAX) return NULL;\n\n    // Now comes the text. The length is specified by the tag size\n    n ->Desc = cmsMLUalloc(self ->ContextID, 1);\n    if (n ->Desc == NULL) return NULL;\n\n    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n    if (io ->Read(io, ASCIIString, sizeof(char), SizeOfTag) != SizeOfTag) return NULL;\n    ASCIIString[SizeOfTag] = 0;\n    cmsMLUsetASCII(n ->Desc, cmsNoLanguage, cmsNoCountry, ASCIIString);\n    _cmsFree(self ->ContextID, ASCIIString);\n\n    *nItems = 1;\n    return (void*) n;\n}\n\nstatic\ncmsBool  Type_UcrBg_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUcrBg* Value = (cmsUcrBg*) Ptr;\n    cmsUInt32Number TextSize;\n    char* Text;\n\n    // First curve is Under color removal\n    if (!_cmsWriteUInt32Number(io, Value ->Ucr ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Ucr ->nEntries, Value ->Ucr ->Table16)) return FALSE;\n\n    // Then black generation\n    if (!_cmsWriteUInt32Number(io, Value ->Bg ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Bg ->nEntries, Value ->Bg ->Table16)) return FALSE;\n\n    // Now comes the text. The length is specified by the tag size\n    TextSize = cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n    if (cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, Text, TextSize) != TextSize) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n    cmsUcrBg* NewUcrBg = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n\n    if (NewUcrBg == NULL) return NULL;\n\n    NewUcrBg ->Bg   = cmsDupToneCurve(Src ->Bg);\n    NewUcrBg ->Ucr  = cmsDupToneCurve(Src ->Ucr);\n    NewUcrBg ->Desc = cmsMLUdup(Src ->Desc);\n\n    return (void*) NewUcrBg;\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_UcrBg_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n   cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n\n   if (Src ->Ucr) cmsFreeToneCurve(Src ->Ucr);\n   if (Src ->Bg)  cmsFreeToneCurve(Src ->Bg);\n   if (Src ->Desc) cmsMLUfree(Src ->Desc);\n\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigCrdInfoType\n// ********************************************************************************\n\n/*\nThis type contains the PostScript product name to which this profile corresponds\nand the names of the companion CRDs. Recall that a single profile can generate\nmultiple CRDs. It is implemented as a MLU being the language code \"PS\" and then\ncountry varies for each element:\n\n                nm: PostScript product name\n                #0: Rendering intent 0 CRD name\n                #1: Rendering intent 1 CRD name\n                #2: Rendering intent 2 CRD name\n                #3: Rendering intent 3 CRD name\n*/\n\n\n\n// Auxiliary, read an string specified as count + string\nstatic\ncmsBool  ReadCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)\n{\n    cmsUInt32Number Count;\n    char* Text;\n\n    if (*SizeOfTag < sizeof(cmsUInt32Number)) return FALSE;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return FALSE;\n\n    if (Count > UINT_MAX - sizeof(cmsUInt32Number)) return FALSE;\n    if (*SizeOfTag < Count + sizeof(cmsUInt32Number)) return FALSE;\n\n    Text     = (char*) _cmsMalloc(self ->ContextID, Count+1);\n    if (Text == NULL) return FALSE;\n\n    if (io ->Read(io, Text, sizeof(cmsUInt8Number), Count) != Count) {\n        _cmsFree(self ->ContextID, Text);\n        return FALSE;\n    }\n\n    Text[Count] = 0;\n\n    cmsMLUsetASCII(mlu, \"PS\", Section, Text);\n    _cmsFree(self ->ContextID, Text);\n\n    *SizeOfTag -= (Count + sizeof(cmsUInt32Number));\n    return TRUE;\n}\n\nstatic\ncmsBool  WriteCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)\n{\n cmsUInt32Number TextSize;\n char* Text;\n\n    TextSize = cmsMLUgetASCII(mlu, \"PS\", Section, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n\n    if (!_cmsWriteUInt32Number(io, TextSize)) return FALSE;\n\n    if (cmsMLUgetASCII(mlu, \"PS\", Section, Text, TextSize) == 0) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n}\n\nstatic\nvoid *Type_CrdInfo_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu = cmsMLUalloc(self ->ContextID, 5);\n\n    *nItems = 0;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"nm\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#0\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#1\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#2\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#3\")) goto Error;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    cmsMLUfree(mlu);\n    return NULL;\n\n}\n\nstatic\ncmsBool  Type_CrdInfo_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    if (!WriteCountAndSting(self, io, mlu, \"nm\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#0\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#1\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#2\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#3\")) goto Error;\n\n    return TRUE;\n\nError:\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_CrdInfo_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_CrdInfo_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// ********************************************************************************\n// Type cmsSigScreeningType\n// ********************************************************************************\n//\n//The screeningType describes various screening parameters including screen\n//frequency, screening angle, and spot shape.\n\nstatic\nvoid *Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsScreening* sc = NULL;\n    cmsUInt32Number i;\n\n    sc = (cmsScreening*) _cmsMallocZero(self ->ContextID, sizeof(cmsScreening));\n    if (sc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &sc ->Flag)) goto Error;\n    if (!_cmsReadUInt32Number(io, &sc ->nChannels)) goto Error;\n\n    if (sc ->nChannels > cmsMAXCHANNELS - 1)\n        sc ->nChannels = cmsMAXCHANNELS - 1;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].Frequency)) goto Error;\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].ScreenAngle)) goto Error;\n        if (!_cmsReadUInt32Number(io, &sc ->Channels[i].SpotShape)) goto Error;\n    }\n\n\n    *nItems = 1;\n\n    return (void*) sc;\n\nError:\n    if (sc != NULL)\n        _cmsFree(self ->ContextID, sc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool Type_Screening_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsScreening* sc = (cmsScreening* ) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, sc ->Flag)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->nChannels)) return FALSE;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].Frequency)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].ScreenAngle)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sc ->Channels[i].SpotShape)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Screening_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsScreening));\n\n   cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_Screening_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigViewingConditionsType\n// ********************************************************************************\n//\n//This type represents a set of viewing condition parameters including:\n//CIE \ufffdabsolute\ufffd illuminant white point tristimulus values and CIE \ufffdabsolute\ufffd\n//surround tristimulus values.\n\nstatic\nvoid *Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCViewingConditions* vc = NULL;\n\n    vc = (cmsICCViewingConditions*) _cmsMallocZero(self ->ContextID, sizeof(cmsICCViewingConditions));\n    if (vc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadXYZNumber(io, &vc ->IlluminantXYZ)) goto Error;\n    if (!_cmsReadXYZNumber(io, &vc ->SurroundXYZ)) goto Error;\n    if (!_cmsReadUInt32Number(io, &vc ->IlluminantType)) goto Error;\n\n    *nItems = 1;\n\n    return (void*) vc;\n\nError:\n    if (vc != NULL)\n        _cmsFree(self ->ContextID, vc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool Type_ViewingConditions_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCViewingConditions* sc = (cmsICCViewingConditions* ) Ptr;\n\n    if (!_cmsWriteXYZNumber(io, &sc ->IlluminantXYZ)) return FALSE;\n    if (!_cmsWriteXYZNumber(io, &sc ->SurroundXYZ)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_ViewingConditions_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self->ContextID, Ptr, sizeof(cmsICCViewingConditions));\n\n   cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_ViewingConditions_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigMultiProcessElementType\n// ********************************************************************************\n\n\nstatic\nvoid* GenericMPEdup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsStageDup((cmsStage*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid GenericMPEfree(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsStageFree((cmsStage*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// Each curve is stored in one or more curve segments, with break-points specified between curve segments.\n// The first curve segment always starts at \ufffdInfinity, and the last curve segment always ends at +Infinity. The\n// first and last curve segments shall be specified in terms of a formula, whereas the other segments shall be\n// specified either in terms of a formula, or by a sampled curve.\n\n\n// Read an embedded segmented curve\nstatic\ncmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsCurveSegSignature ElementSig;\n    cmsUInt32Number i, j;\n    cmsUInt16Number nSegments;\n    cmsCurveSegment*  Segments;\n    cmsToneCurve* Curve;\n    cmsFloat32Number PrevBreak = -1E22F;    // - infinite\n\n    // Take signature and channels for each element.\n     if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return NULL;\n\n     // That should be a segmented curve\n     if (ElementSig != cmsSigSegmentedCurve) return NULL;\n\n     if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n     if (!_cmsReadUInt16Number(io, &nSegments)) return NULL;\n     if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n     if (nSegments < 1) return NULL;\n     Segments = (cmsCurveSegment*) _cmsCalloc(self ->ContextID, nSegments, sizeof(cmsCurveSegment));\n     if (Segments == NULL) return NULL;\n\n     // Read breakpoints\n     for (i=0; i < (cmsUInt32Number) nSegments - 1; i++) {\n\n         Segments[i].x0 = PrevBreak;\n         if (!_cmsReadFloat32Number(io, &Segments[i].x1)) goto Error;\n         PrevBreak = Segments[i].x1;\n     }\n\n     Segments[nSegments-1].x0 = PrevBreak;\n     Segments[nSegments-1].x1 = 1E22F;     // A big cmsFloat32Number number\n\n     // Read segments\n     for (i=0; i < nSegments; i++) {\n\n          if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) goto Error;\n          if (!_cmsReadUInt32Number(io, NULL)) goto Error;\n\n           switch (ElementSig) {\n\n            case cmsSigFormulaCurveSeg: {\n\n                cmsUInt16Number Type;\n                cmsUInt32Number ParamsByType[] = {4, 5, 5 };\n\n                if (!_cmsReadUInt16Number(io, &Type)) goto Error;\n                if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n\n                Segments[i].Type = Type + 6;\n                if (Type > 2) goto Error;\n\n                for (j=0; j < ParamsByType[Type]; j++) {\n\n                    cmsFloat32Number f;\n                    if (!_cmsReadFloat32Number(io, &f)) goto Error;\n                    Segments[i].Params[j] = f;\n                }\n                }\n                break;\n\n\n            case cmsSigSampledCurveSeg: {\n                cmsUInt32Number Count;\n\n                if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n                Segments[i].nGridPoints = Count;\n                Segments[i].SampledPoints = (cmsFloat32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsFloat32Number));\n                if (Segments[i].SampledPoints == NULL) goto Error;\n\n                for (j=0; j < Count; j++) {\n                    if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;\n                }\n                }\n                break;\n\n            default:\n                {\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve element type '%s' found.\", String);\n                }\n                return NULL;\n\n         }\n     }\n\n     Curve = cmsBuildSegmentedToneCurve(self ->ContextID, nSegments, Segments);\n\n     for (i=0; i < nSegments; i++) {\n         if (Segments[i].SampledPoints) _cmsFree(self ->ContextID, Segments[i].SampledPoints);\n     }\n     _cmsFree(self ->ContextID, Segments);\n     return Curve;\n\nError:\n     if (Segments) _cmsFree(self ->ContextID, Segments);\n     return NULL;\n}\n\n\nstatic\ncmsBool ReadMPECurve(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     void* Cargo,\n                     cmsUInt32Number n,\n                     cmsUInt32Number SizeOfTag)\n{\n      cmsToneCurve** GammaTables = ( cmsToneCurve**) Cargo;\n\n      GammaTables[n] = ReadSegmentedCurve(self, io);\n      return (GammaTables[n] != NULL);\n\n      cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\nvoid *Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number i, BaseOffset;\n    cmsToneCurve** GammaTables;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans != OutputChans) return NULL;\n\n    GammaTables = (cmsToneCurve**) _cmsCalloc(self ->ContextID, InputChans, sizeof(cmsToneCurve*));\n    if (GammaTables == NULL) return NULL;\n\n    if (ReadPositionTable(self, io, InputChans, BaseOffset, GammaTables, ReadMPECurve)) {\n\n        mpe = cmsStageAllocToneCurves(self ->ContextID, InputChans, GammaTables);\n    }\n    else {\n        mpe = NULL;\n    }\n\n    for (i=0; i < InputChans; i++) {\n        if (GammaTables[i]) cmsFreeToneCurve(GammaTables[i]);\n    }\n\n    _cmsFree(self ->ContextID, GammaTables);\n    *nItems = (mpe != NULL) ? 1 : 0;\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// Write a single segmented curve. NO CHECK IS PERFORMED ON VALIDITY\nstatic\ncmsBool WriteSegmentedCurve(cmsIOHANDLER* io, cmsToneCurve* g)\n{\n    cmsUInt32Number i, j;\n    cmsCurveSegment* Segments = g ->Segments;\n    cmsUInt32Number nSegments = g ->nSegments;\n\n    if (!_cmsWriteUInt32Number(io, cmsSigSegmentedCurve)) goto Error;\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) nSegments)) goto Error;\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n    // Write the break-points\n    for (i=0; i < nSegments - 1; i++) {\n        if (!_cmsWriteFloat32Number(io, Segments[i].x1)) goto Error;\n    }\n\n    // Write the segments\n    for (i=0; i < g ->nSegments; i++) {\n\n        cmsCurveSegment* ActualSeg = Segments + i;\n\n        if (ActualSeg -> Type == 0) {\n\n            // This is a sampled curve\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigSampledCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints)) goto Error;\n\n            for (j=0; j < g ->Segments[i].nGridPoints; j++) {\n                if (!_cmsWriteFloat32Number(io, ActualSeg -> SampledPoints[j])) goto Error;\n            }\n\n        }\n        else {\n            int Type;\n            cmsUInt32Number ParamsByType[] = { 4, 5, 5 };\n\n            // This is a formula-based\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigFormulaCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n\n            // We only allow 1, 2 and 3 as types\n            Type = ActualSeg ->Type - 6;\n            if (Type > 2 || Type < 0) goto Error;\n\n            if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Type)) goto Error;\n            if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n            for (j=0; j < ParamsByType[Type]; j++) {\n                if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) ActualSeg ->Params[j])) goto Error;\n            }\n        }\n\n        // It seems there is no need to align. Code is here, and for safety commented out\n        // if (!_cmsWriteAlignment(io)) goto Error;\n    }\n\n    return TRUE;\n\nError:\n    return FALSE;\n}\n\n\nstatic\ncmsBool WriteMPECurve(struct _cms_typehandler_struct* self,\n                      cmsIOHANDLER* io,\n                      void* Cargo,\n                      cmsUInt32Number n,\n                      cmsUInt32Number SizeOfTag)\n{\n    _cmsStageToneCurvesData* Curves  = (_cmsStageToneCurvesData*) Cargo;\n\n    return WriteSegmentedCurve(io, Curves ->TheCurves[n]);\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(self);\n}\n\n// Write a curve, checking first for validity\nstatic\ncmsBool  Type_MPEcurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number BaseOffset;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageToneCurvesData* Curves = (_cmsStageToneCurvesData*) mpe ->Data;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Write the header. Since those are curves, input and output channels are same\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n\n    if (!WritePositionTable(self, io, 0,\n                                mpe ->InputChannels, BaseOffset, Curves, WriteMPECurve)) return FALSE;\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\n\n// The matrix is organized as an array of PxQ+Q elements, where P is the number of input channels to the\n// matrix, and Q is the number of output channels. The matrix elements are each float32Numbers. The array\n// is organized as follows:\n// array = [e11, e12, \ufffd, e1P, e21, e22, \ufffd, e2P, \ufffd, eQ1, eQ2, \ufffd, eQP, e1, e2, \ufffd, eQ]\n\nstatic\nvoid *Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe;\n    cmsUInt16Number   InputChans, OutputChans;\n    cmsUInt32Number   nElems, i;\n    cmsFloat64Number* Matrix;\n    cmsFloat64Number* Offsets;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n\n    nElems = InputChans * OutputChans;\n\n    // Input and output chans may be ANY (up to 0xffff)\n    Matrix = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, nElems, sizeof(cmsFloat64Number));\n    if (Matrix == NULL) return NULL;\n\n    Offsets = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, OutputChans, sizeof(cmsFloat64Number));\n    if (Offsets == NULL) {\n\n        _cmsFree(self ->ContextID, Matrix);\n        return NULL;\n    }\n\n    for (i=0; i < nElems; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) return NULL;\n        Matrix[i] = v;\n    }\n\n\n    for (i=0; i < OutputChans; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) return NULL;\n        Offsets[i] = v;\n    }\n\n\n    mpe = cmsStageAllocMatrix(self ->ContextID, OutputChans, InputChans, Matrix, Offsets);\n    _cmsFree(self ->ContextID, Matrix);\n    _cmsFree(self ->ContextID, Offsets);\n\n    *nItems = 1;\n\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_MPEmatrix_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, nElems;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageMatrixData* Matrix = (_cmsStageMatrixData*) mpe ->Data;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    nElems = mpe ->InputChannels * mpe ->OutputChannels;\n\n    for (i=0; i < nElems; i++) {\n        if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Double[i])) return FALSE;\n    }\n\n\n    for (i=0; i < mpe ->OutputChannels; i++) {\n\n        if (Matrix ->Offset == NULL) {\n\n               if (!_cmsWriteFloat32Number(io, 0)) return FALSE;\n        }\n        else {\n               if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Offset[i])) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\nstatic\nvoid *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt8Number Dimensions8[16];\n    cmsUInt32Number i, nMaxGrids, GridPoints[MAX_INPUT_DIMENSIONS];\n    _cmsStageCLutData* clut;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans == 0) goto Error;\n    if (OutputChans == 0) goto Error;\n\n    if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)\n        goto Error;\n\n    // Copy MAX_INPUT_DIMENSIONS at most. Expand to cmsUInt32Number\n    nMaxGrids = InputChans > MAX_INPUT_DIMENSIONS ? MAX_INPUT_DIMENSIONS : InputChans;\n    for (i=0; i < nMaxGrids; i++) GridPoints[i] = (cmsUInt32Number) Dimensions8[i];\n\n    // Allocate the true CLUT\n    mpe = cmsStageAllocCLutFloatGranular(self ->ContextID, GridPoints, InputChans, OutputChans, NULL);\n    if (mpe == NULL) goto Error;\n\n    // Read the data\n    clut = (_cmsStageCLutData*) mpe ->Data;\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsReadFloat32Number(io, &clut ->Tab.TFloat[i])) goto Error;\n    }\n\n    *nItems = 1;\n    return mpe;\n\nError:\n    *nItems = 0;\n    if (mpe != NULL) cmsStageFree(mpe);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// Write a CLUT in floating point\nstatic\ncmsBool  Type_MPEclut_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number Dimensions8[16];  // 16 because the spec says 16 and not max number of channels\n    cmsUInt32Number i;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe ->Data;\n\n    // Check for maximum number of channels supported by lcms\n    if (mpe -> InputChannels > MAX_INPUT_DIMENSIONS) return FALSE;\n\n    // Only floats are supported in MPE\n    if (clut ->HasFloatValues == FALSE) return FALSE;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    memset(Dimensions8, 0, sizeof(Dimensions8));\n\n    for (i=0; i < mpe ->InputChannels; i++)\n        Dimensions8[i] = (cmsUInt8Number) clut ->Params ->nSamples[i];\n\n    if (!io ->Write(io, 16, Dimensions8)) return FALSE;\n\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsWriteFloat32Number(io, clut ->Tab.TFloat[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\n// This is the list of built-in MPE types\nstatic _cmsTagTypeLinkedList SupportedMPEtypes[] = {\n\n{{ (cmsTagTypeSignature) cmsSigBAcsElemType, NULL, NULL, NULL, NULL, NULL, 0 }, &SupportedMPEtypes[1] },   // Ignore those elements for now\n{{ (cmsTagTypeSignature) cmsSigEAcsElemType, NULL, NULL, NULL, NULL, NULL, 0 }, &SupportedMPEtypes[2] },   // (That's what the spec says)\n\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCurveSetElemType,     MPEcurve),      &SupportedMPEtypes[3] },\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigMatrixElemType,       MPEmatrix),     &SupportedMPEtypes[4] },\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCLutElemType,         MPEclut),        NULL },\n};\n\n_cmsTagTypePluginChunkType _cmsMPETypePluginChunk = { NULL };\n\nstatic\ncmsBool ReadMPEElem(struct _cms_typehandler_struct* self,\n                    cmsIOHANDLER* io,\n                    void* Cargo,\n                    cmsUInt32Number n,\n                    cmsUInt32Number SizeOfTag)\n{\n    cmsStageSignature ElementSig;\n    cmsTagTypeHandler* TypeHandler;\n    cmsUInt32Number nItems;\n    cmsPipeline *NewLUT = (cmsPipeline *) Cargo;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n\n    // Take signature and channels for each element.\n    if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return FALSE;\n\n    // The reserved placeholder\n    if (!_cmsReadUInt32Number(io, NULL)) return FALSE;\n\n    // Read diverse MPE types\n    TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk ->TagTypes, SupportedMPEtypes);\n    if (TypeHandler == NULL)  {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n        // An unknown element was found.\n        cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown MPE type '%s' found.\", String);\n        return FALSE;\n    }\n\n    // If no read method, just ignore the element (valid for cmsSigBAcsElemType and cmsSigEAcsElemType)\n    // Read the MPE. No size is given\n    if (TypeHandler ->ReadPtr != NULL) {\n\n        // This is a real element which should be read and processed\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag)))\n            return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(n);\n}\n\n\n// This is the main dispatcher for MPE\nstatic\nvoid *Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number ElementCount;\n    cmsPipeline *NewLUT = NULL;\n    cmsUInt32Number BaseOffset;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Read channels and element count\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChans, OutputChans);\n    if (NewLUT == NULL) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &ElementCount)) return NULL;\n\n    if (!ReadPositionTable(self, io, ElementCount, BaseOffset, NewLUT, ReadMPEElem)) {\n        if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n        *nItems = 0;\n        return NULL;\n    }\n\n    // Success\n    *nItems = 1;\n    return NewLUT;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n\n// This one is a liitle bit more complex, so we don't use position tables this time.\nstatic\ncmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, BaseOffset, DirectoryPos, CurrentPos;\n    int inputChan, outputChan;\n    cmsUInt32Number ElemCount;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL, Before;\n    cmsStageSignature ElementSig;\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsStage* Elem = Lut ->Elements;\n    cmsTagTypeHandler* TypeHandler;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n    ElemCount  = cmsPipelineStageCount(Lut);\n\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Write the head\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) outputChan)) goto Error;\n    if (!_cmsWriteUInt32Number(io, (cmsUInt16Number) ElemCount)) goto Error;\n\n    DirectoryPos = io ->Tell(io);\n\n    // Write a fake directory to be filled latter on\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each single tag. Keep track of the size as well.\n    for (i=0; i < ElemCount; i++) {\n\n        ElementOffsets[i] = io ->Tell(io) - BaseOffset;\n\n        ElementSig = Elem ->Type;\n\n        TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk->TagTypes, SupportedMPEtypes);\n        if (TypeHandler == NULL)  {\n\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n                 // An unknow element was found.\n                 cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Found unknown MPE type '%s'\", String);\n                 goto Error;\n        }\n\n        if (!_cmsWriteUInt32Number(io, ElementSig)) goto Error;\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n        Before = io ->Tell(io);\n        if (!TypeHandler ->WritePtr(self, io, Elem, 1)) goto Error;\n        if (!_cmsWriteAlignment(io)) goto Error;\n\n        ElementSizes[i] = io ->Tell(io) - Before;\n\n        Elem = Elem ->Next;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_MPE_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_MPE_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigVcgtType\n// ********************************************************************************\n\n\n#define cmsVideoCardGammaTableType    0\n#define cmsVideoCardGammaFormulaType  1\n\n// Used internally\ntypedef struct {\n    double Gamma;\n    double Min;\n    double Max;\n} _cmsVCGTGAMMA;\n\n\nstatic\nvoid *Type_vcgt_Read(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     cmsUInt32Number* nItems,\n                     cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number TagType, n, i;\n    cmsToneCurve** Curves;\n\n    *nItems = 0;\n\n    // Read tag type\n    if (!_cmsReadUInt32Number(io, &TagType)) return NULL;\n\n    // Allocate space for the array\n    Curves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (Curves == NULL) return NULL;\n\n    // There are two possible flavors\n    switch (TagType) {\n\n    // Gamma is stored as a table\n    case cmsVideoCardGammaTableType:\n    {\n       cmsUInt16Number nChannels, nElems, nBytes;\n\n       // Check channel count, which should be 3 (we don't support monochrome this time)\n       if (!_cmsReadUInt16Number(io, &nChannels)) goto Error;\n\n       if (nChannels != 3) {\n           cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported number of channels for VCGT '%d'\", nChannels);\n           goto Error;\n       }\n\n       // Get Table element count and bytes per element\n       if (!_cmsReadUInt16Number(io, &nElems)) goto Error;\n       if (!_cmsReadUInt16Number(io, &nBytes)) goto Error;\n\n       // Adobe's quirk fixup. Fixing broken profiles...\n       if (nElems == 256 && nBytes == 1 && SizeOfTag == 1576)\n           nBytes = 2;\n\n\n       // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           Curves[n] = cmsBuildTabulatedToneCurve16(self ->ContextID, nElems, NULL);\n           if (Curves[n] == NULL) goto Error;\n\n           // On depending on byte depth\n           switch (nBytes) {\n\n           // One byte, 0..255\n           case 1:\n               for (i=0; i < nElems; i++) {\n\n                   cmsUInt8Number v;\n\n                      if (!_cmsReadUInt8Number(io, &v)) goto Error;\n                      Curves[n] ->Table16[i] = FROM_8_TO_16(v);\n               }\n               break;\n\n           // One word 0..65535\n           case 2:\n              if (!_cmsReadUInt16Array(io, nElems, Curves[n]->Table16)) goto Error;\n              break;\n\n          // Unsupported\n           default:\n              cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported bit depth for VCGT '%d'\", nBytes * 8);\n              goto Error;\n           }\n       } // For all 3 channels\n    }\n    break;\n\n   // In this case, gamma is stored as a formula\n   case cmsVideoCardGammaFormulaType:\n   {\n       _cmsVCGTGAMMA Colorant[3];\n\n        // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           double Params[10];\n\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Gamma)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Min)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Max)) goto Error;\n\n            // Parametric curve type 5 is:\n            // Y = (aX + b)^Gamma + e | X >= d\n            // Y = cX + f             | X < d\n\n            // vcgt formula is:\n            // Y = (Max \ufffd Min) * (X ^ Gamma) + Min\n\n            // So, the translation is\n            // a = (Max \ufffd Min) ^ ( 1 / Gamma)\n            // e = Min\n            // b=c=d=f=0\n\n           Params[0] = Colorant[n].Gamma;\n           Params[1] = pow((Colorant[n].Max - Colorant[n].Min), (1.0 / Colorant[n].Gamma));\n           Params[2] = 0;\n           Params[3] = 0;\n           Params[4] = 0;\n           Params[5] = Colorant[n].Min;\n           Params[6] = 0;\n\n           Curves[n] = cmsBuildParametricToneCurve(self ->ContextID, 5, Params);\n           if (Curves[n] == NULL) goto Error;\n       }\n   }\n   break;\n\n   // Unsupported\n   default:\n      cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported tag type for VCGT '%d'\", TagType);\n      goto Error;\n   }\n\n   *nItems = 1;\n   return (void*) Curves;\n\n// Regret,  free all resources\nError:\n\n    cmsFreeToneCurveTriple(Curves);\n    _cmsFree(self ->ContextID, Curves);\n    return NULL;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// We don't support all flavors, only 16bits tables and formula\nstatic\ncmsBool Type_vcgt_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve** Curves =  (cmsToneCurve**) Ptr;\n    cmsUInt32Number i, j;\n\n    if (cmsGetToneCurveParametricType(Curves[0]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[1]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[2]) == 5) {\n\n            if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaFormulaType)) return FALSE;\n\n            // Save parameters\n            for (i=0; i < 3; i++) {\n\n                _cmsVCGTGAMMA v;\n\n                v.Gamma = Curves[i] ->Segments[0].Params[0];\n                v.Min   = Curves[i] ->Segments[0].Params[5];\n                v.Max   = pow(Curves[i] ->Segments[0].Params[1], v.Gamma) + v.Min;\n\n                if (!_cmsWrite15Fixed16Number(io, v.Gamma)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Min)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Max)) return FALSE;\n            }\n    }\n\n    else {\n\n        // Always store as a table of 256 words\n        if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaTableType)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 3)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 256)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n        for (i=0; i < 3; i++) {\n            for (j=0; j < 256; j++) {\n\n                cmsFloat32Number v = cmsEvalToneCurveFloat(Curves[i], (cmsFloat32Number) (j / 255.0));\n                cmsUInt16Number  n = _cmsQuickSaturateWord(v * 65535.0);\n\n                if (!_cmsWriteUInt16Number(io, n)) return FALSE;\n            }\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsToneCurve** OldCurves =  (cmsToneCurve**) Ptr;\n    cmsToneCurve** NewCurves;\n\n    NewCurves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (NewCurves == NULL) return NULL;\n\n    NewCurves[0] = cmsDupToneCurve(OldCurves[0]);\n    NewCurves[1] = cmsDupToneCurve(OldCurves[1]);\n    NewCurves[2] = cmsDupToneCurve(OldCurves[2]);\n\n    return (void*) NewCurves;\n\n    cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_vcgt_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeToneCurveTriple((cmsToneCurve**) Ptr);\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDictType\n// ********************************************************************************\n\n// Single column of the table can point to wchar or MLUC elements. Holds arrays of data\ntypedef struct {\n    cmsContext ContextID;\n    cmsUInt32Number *Offsets;\n    cmsUInt32Number *Sizes;\n} _cmsDICelem;\n\ntypedef struct {\n    _cmsDICelem Name, Value, DisplayName, DisplayValue;\n\n} _cmsDICarray;\n\n// Allocate an empty array element\nstatic\ncmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)\n{\n    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Offsets == NULL) return FALSE;\n\n    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Sizes == NULL) {\n\n        _cmsFree(ContextID, e -> Offsets);\n        return FALSE;\n    }\n\n    e ->ContextID = ContextID;\n    return TRUE;\n}\n\n// Free an array element\nstatic\nvoid FreeElem(_cmsDICelem* e)\n{\n    if (e ->Offsets != NULL)  _cmsFree(e -> ContextID, e -> Offsets);\n    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e -> Sizes);\n    e->Offsets = e ->Sizes = NULL;\n}\n\n// Get rid of whole array\nstatic\nvoid FreeArray( _cmsDICarray* a)\n{\n    if (a ->Name.Offsets != NULL) FreeElem(&a->Name);\n    if (a ->Value.Offsets != NULL) FreeElem(&a ->Value);\n    if (a ->DisplayName.Offsets != NULL) FreeElem(&a->DisplayName);\n    if (a ->DisplayValue.Offsets != NULL) FreeElem(&a ->DisplayValue);\n}\n\n\n// Allocate whole array\nstatic\ncmsBool AllocArray(cmsContext ContextID, _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    // Empty values\n    memset(a, 0, sizeof(_cmsDICarray));\n\n    // On depending on record size, create column arrays\n    if (!AllocElem(ContextID, &a ->Name, Count)) goto Error;\n    if (!AllocElem(ContextID, &a ->Value, Count)) goto Error;\n\n    if (Length > 16) {\n        if (!AllocElem(ContextID, &a -> DisplayName, Count)) goto Error;\n\n    }\n    if (Length > 24) {\n        if (!AllocElem(ContextID, &a ->DisplayValue, Count)) goto Error;\n    }\n    return TRUE;\n\nError:\n    FreeArray(a);\n    return FALSE;\n}\n\n// Read one element\nstatic\ncmsBool ReadOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsUInt32Number BaseOffset)\n{\n    if (!_cmsReadUInt32Number(io, &e->Offsets[i])) return FALSE;\n    if (!_cmsReadUInt32Number(io, &e ->Sizes[i])) return FALSE;\n\n    // An offset of zero has special meaning and shal be preserved\n    if (e ->Offsets[i] > 0)\n        e ->Offsets[i] += BaseOffset;\n    return TRUE;\n}\n\n\nstatic\ncmsBool ReadOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number i;\n\n    // Read column arrays\n    for (i=0; i < Count; i++) {\n\n        if (!ReadOneElem(io, &a -> Name, i, BaseOffset)) return FALSE;\n        if (!ReadOneElem(io, &a -> Value, i, BaseOffset)) return FALSE;\n\n        if (Length > 16) {\n\n            if (!ReadOneElem(io, &a ->DisplayName, i, BaseOffset)) return FALSE;\n\n        }\n\n        if (Length > 24) {\n\n            if (!ReadOneElem(io, & a -> DisplayValue, i, BaseOffset)) return FALSE;\n        }\n    }\n    return TRUE;\n}\n\n\n// Write one element\nstatic\ncmsBool WriteOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i)\n{\n    if (!_cmsWriteUInt32Number(io, e->Offsets[i])) return FALSE;\n    if (!_cmsWriteUInt32Number(io, e ->Sizes[i])) return FALSE;\n\n    return TRUE;\n}\n\nstatic\ncmsBool WriteOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneElem(io, &a -> Name, i)) return FALSE;\n        if (!WriteOneElem(io, &a -> Value, i))  return FALSE;\n\n        if (Length > 16) {\n\n            if (!WriteOneElem(io, &a -> DisplayName, i))  return FALSE;\n        }\n\n        if (Length > 24) {\n\n            if (!WriteOneElem(io, &a -> DisplayValue, i))  return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic\ncmsBool ReadOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, wchar_t ** wcstr)\n{\n\n    cmsUInt32Number nChars;\n\n      // Special case for undefined strings (see ICC Votable\n      // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n      if (e -> Offsets[i] == 0) {\n\n          *wcstr = NULL;\n          return TRUE;\n      }\n\n      if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n      nChars = e ->Sizes[i] / sizeof(cmsUInt16Number);\n\n\n      *wcstr = (wchar_t*) _cmsMallocZero(e ->ContextID, (nChars + 1) * sizeof(wchar_t));\n      if (*wcstr == NULL) return FALSE;\n\n      if (!_cmsReadWCharArray(io, nChars, *wcstr)) {\n          _cmsFree(e ->ContextID, *wcstr);\n          return FALSE;\n      }\n\n      // End of string marker\n      (*wcstr)[nChars] = 0;\n      return TRUE;\n}\n\nstatic\ncmsUInt32Number mywcslen(const wchar_t *s)\n{\n    const wchar_t *p;\n\n    p = s;\n    while (*p)\n        p++;\n\n    return (cmsUInt32Number)(p - s);\n}\n\nstatic\ncmsBool WriteOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const wchar_t * wcstr, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before = io ->Tell(io);\n    cmsUInt32Number n;\n\n    e ->Offsets[i] = Before - BaseOffset;\n\n    if (wcstr == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    n = mywcslen(wcstr);\n    if (!_cmsWriteWCharArray(io,  n, wcstr)) return FALSE;\n\n    e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}\n\nstatic\ncmsBool ReadOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsMLU** mlu)\n{\n    cmsUInt32Number nItems = 0;\n\n    // A way to get null MLUCs\n    if (e -> Offsets[i] == 0 || e ->Sizes[i] == 0) {\n\n        *mlu = NULL;\n        return TRUE;\n    }\n\n    if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n    *mlu = (cmsMLU*) Type_MLU_Read(self, io, &nItems, e ->Sizes[i]);\n    return *mlu != NULL;\n}\n\nstatic\ncmsBool WriteOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const cmsMLU* mlu, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before;\n\n     // Special case for undefined strings (see ICC Votable\n     // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n     if (mlu == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    Before = io ->Tell(io);\n    e ->Offsets[i] = Before - BaseOffset;\n\n    if (!Type_MLU_Write(self, io, (void*) mlu, 1)) return FALSE;\n\n    e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}\n\n\nstatic\nvoid *Type_Dictionary_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n   cmsHANDLE hDict;\n   cmsUInt32Number i, Count, Length;\n   cmsUInt32Number BaseOffset;\n   _cmsDICarray a;\n   wchar_t *NameWCS = NULL, *ValueWCS = NULL;\n   cmsMLU *DisplayNameMLU = NULL, *DisplayValueMLU=NULL;\n   cmsBool rc;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get name-value record count\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Get rec length\n    if (!_cmsReadUInt32Number(io, &Length)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Check for valid lengths\n    if (Length != 16 && Length != 24 && Length != 32) {\n         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown record length in dictionary '%d'\", Length);\n         return NULL;\n    }\n\n    // Creates an empty dictionary\n    hDict = cmsDictAlloc(self -> ContextID);\n    if (hDict == NULL) return NULL;\n\n    // On depending on record size, create column arrays\n    if (!AllocArray(self -> ContextID, &a, Count, Length)) goto Error;\n\n    // Read column arrays\n    if (!ReadOffsetArray(io, &a, Count, Length, BaseOffset)) goto Error;\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!ReadOneWChar(io, &a.Name, i, &NameWCS)) goto Error;\n        if (!ReadOneWChar(io, &a.Value, i, &ValueWCS)) goto Error;\n\n        if (Length > 16) {\n            if (!ReadOneMLUC(self, io, &a.DisplayName, i, &DisplayNameMLU)) goto Error;\n        }\n\n        if (Length > 24) {\n            if (!ReadOneMLUC(self, io, &a.DisplayValue, i, &DisplayValueMLU)) goto Error;\n        }\n\n        if (NameWCS == NULL || ValueWCS == NULL) {\n        \n            cmsSignalError(self->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Bad dictionary Name/Value\");        \n            rc = FALSE;\n        }\n        else {\n\n            rc = cmsDictAddEntry(hDict, NameWCS, ValueWCS, DisplayNameMLU, DisplayValueMLU);\n        }\n\n        if (NameWCS != NULL) _cmsFree(self ->ContextID, NameWCS);\n        if (ValueWCS != NULL) _cmsFree(self ->ContextID, ValueWCS);\n        if (DisplayNameMLU != NULL) cmsMLUfree(DisplayNameMLU);\n        if (DisplayValueMLU != NULL) cmsMLUfree(DisplayValueMLU);\n\n        if (!rc) goto Error;\n    }\n\n   FreeArray(&a);\n   *nItems = 1;\n   return (void*) hDict;\n\nError:\n   FreeArray(&a);\n   cmsDictFree(hDict);\n   return NULL;\n}\n\n\nstatic\ncmsBool Type_Dictionary_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsHANDLE hDict = (cmsHANDLE) Ptr;\n    const cmsDICTentry* p;\n    cmsBool AnyName, AnyValue;\n    cmsUInt32Number i, Count, Length;\n    cmsUInt32Number DirectoryPos, CurrentPos, BaseOffset;\n   _cmsDICarray a;\n\n    if (hDict == NULL) return FALSE;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Let's inspect the dictionary\n    Count = 0; AnyName = FALSE; AnyValue = FALSE;\n    for (p = cmsDictGetEntryList(hDict); p != NULL; p = cmsDictNextEntry(p)) {\n\n        if (p ->DisplayName != NULL) AnyName = TRUE;\n        if (p ->DisplayValue != NULL) AnyValue = TRUE;\n        Count++;\n    }\n\n    Length = 16;\n    if (AnyName)  Length += 8;\n    if (AnyValue) Length += 8;\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, Length)) return FALSE;\n\n    // Keep starting position of offsets table\n    DirectoryPos = io ->Tell(io);\n\n    // Allocate offsets array\n    if (!AllocArray(self ->ContextID, &a, Count, Length)) goto Error;\n\n    // Write a fake directory to be filled latter on\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    // Write each element. Keep track of the size as well.\n    p = cmsDictGetEntryList(hDict);\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneWChar(io, &a.Name, i,  p ->Name, BaseOffset)) goto Error;\n        if (!WriteOneWChar(io, &a.Value, i, p ->Value, BaseOffset)) goto Error;\n\n        if (p ->DisplayName != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayName, i, p ->DisplayName, BaseOffset)) goto Error;\n        }\n\n        if (p ->DisplayValue != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayValue, i, p ->DisplayValue, BaseOffset)) goto Error;\n        }\n\n       p = cmsDictNextEntry(p);\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    FreeArray(&a);\n    return TRUE;\n\nError:\n    FreeArray(&a);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_Dictionary_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*)  cmsDictDup((cmsHANDLE) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_Dictionary_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsDictFree((cmsHANDLE) Ptr);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type support main routines\n// ********************************************************************************\n\n\n// This is the list of built-in types\nstatic _cmsTagTypeLinkedList SupportedTagTypes[] = {\n\n{TYPE_HANDLER(cmsSigChromaticityType,          Chromaticity),        &SupportedTagTypes[1] },\n{TYPE_HANDLER(cmsSigColorantOrderType,         ColorantOrderType),   &SupportedTagTypes[2] },\n{TYPE_HANDLER(cmsSigS15Fixed16ArrayType,       S15Fixed16),          &SupportedTagTypes[3] },\n{TYPE_HANDLER(cmsSigU16Fixed16ArrayType,       U16Fixed16),          &SupportedTagTypes[4] },\n{TYPE_HANDLER(cmsSigTextType,                  Text),                &SupportedTagTypes[5] },\n{TYPE_HANDLER(cmsSigTextDescriptionType,       Text_Description),    &SupportedTagTypes[6] },\n{TYPE_HANDLER(cmsSigCurveType,                 Curve),               &SupportedTagTypes[7] },\n{TYPE_HANDLER(cmsSigParametricCurveType,       ParametricCurve),     &SupportedTagTypes[8] },\n{TYPE_HANDLER(cmsSigDateTimeType,              DateTime),            &SupportedTagTypes[9] },\n{TYPE_HANDLER(cmsSigLut8Type,                  LUT8),                &SupportedTagTypes[10] },\n{TYPE_HANDLER(cmsSigLut16Type,                 LUT16),               &SupportedTagTypes[11] },\n{TYPE_HANDLER(cmsSigColorantTableType,         ColorantTable),       &SupportedTagTypes[12] },\n{TYPE_HANDLER(cmsSigNamedColor2Type,           NamedColor),          &SupportedTagTypes[13] },\n{TYPE_HANDLER(cmsSigMultiLocalizedUnicodeType, MLU),                 &SupportedTagTypes[14] },\n{TYPE_HANDLER(cmsSigProfileSequenceDescType,   ProfileSequenceDesc), &SupportedTagTypes[15] },\n{TYPE_HANDLER(cmsSigSignatureType,             Signature),           &SupportedTagTypes[16] },\n{TYPE_HANDLER(cmsSigMeasurementType,           Measurement),         &SupportedTagTypes[17] },\n{TYPE_HANDLER(cmsSigDataType,                  Data),                &SupportedTagTypes[18] },\n{TYPE_HANDLER(cmsSigLutAtoBType,               LUTA2B),              &SupportedTagTypes[19] },\n{TYPE_HANDLER(cmsSigLutBtoAType,               LUTB2A),              &SupportedTagTypes[20] },\n{TYPE_HANDLER(cmsSigUcrBgType,                 UcrBg),               &SupportedTagTypes[21] },\n{TYPE_HANDLER(cmsSigCrdInfoType,               CrdInfo),             &SupportedTagTypes[22] },\n{TYPE_HANDLER(cmsSigMultiProcessElementType,   MPE),                 &SupportedTagTypes[23] },\n{TYPE_HANDLER(cmsSigScreeningType,             Screening),           &SupportedTagTypes[24] },\n{TYPE_HANDLER(cmsSigViewingConditionsType,     ViewingConditions),   &SupportedTagTypes[25] },\n{TYPE_HANDLER(cmsSigXYZType,                   XYZ),                 &SupportedTagTypes[26] },\n{TYPE_HANDLER(cmsCorbisBrokenXYZtype,          XYZ),                 &SupportedTagTypes[27] },\n{TYPE_HANDLER(cmsMonacoBrokenCurveType,        Curve),               &SupportedTagTypes[28] },\n{TYPE_HANDLER(cmsSigProfileSequenceIdType,     ProfileSequenceId),   &SupportedTagTypes[29] },\n{TYPE_HANDLER(cmsSigDictType,                  Dictionary),          &SupportedTagTypes[30] },\n{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n};\n\n\n_cmsTagTypePluginChunkType _cmsTagTypePluginChunk = { NULL };\n\n\n\n// Duplicates the zone of memory used by the plug-in in the new context\nstatic\nvoid DupTagTypeList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src, \n                    int loc)\n{\n   _cmsTagTypePluginChunkType newHead = { NULL };\n   _cmsTagTypeLinkedList*  entry;\n   _cmsTagTypeLinkedList*  Anterior = NULL;\n   _cmsTagTypePluginChunkType* head = (_cmsTagTypePluginChunkType*) src->chunks[loc];\n\n   // Walk the list copying all nodes\n   for (entry = head->TagTypes;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagTypeLinkedList *newEntry = ( _cmsTagTypeLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagTypeLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.TagTypes == NULL)\n               newHead.TagTypes = newEntry;\n   }\n\n   ctx ->chunks[loc] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagTypePluginChunkType));\n}\n\n\nvoid _cmsAllocTagTypePluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, TagTypePlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[TagTypePlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n}\n\nvoid _cmsAllocMPETypePluginChunk(struct _cmsContext_struct* ctx, \n                               const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, MPEPlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[MPEPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n\n}\n\n\n// Both kind of plug-ins share same structure\ncmsBool  _cmsRegisterTagTypePlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data, TagTypePlugin);\n}\n\ncmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data,MPEPlugin);\n}\n\n\n// Wrapper for tag types\ncmsTagTypeHandler* _cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)\n{\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(ContextID, TagTypePlugin);\n\n    return GetHandler(sig, ctx->TagTypes, SupportedTagTypes);\n}\n\n// ********************************************************************************\n// Tag support main routines\n// ********************************************************************************\n\ntypedef struct _cmsTagLinkedList_st {\n\n            cmsTagSignature Signature;\n            cmsTagDescriptor Descriptor;\n            struct _cmsTagLinkedList_st* Next;\n\n} _cmsTagLinkedList;\n\n// This is the list of built-in tags\nstatic _cmsTagLinkedList SupportedTags[] = {\n\n    { cmsSigAToB0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[1]},\n    { cmsSigAToB1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[2]},\n    { cmsSigAToB2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[3]},\n    { cmsSigBToA0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[4]},\n    { cmsSigBToA1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[5]},\n    { cmsSigBToA2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[6]},\n\n    // Allow corbis  and its broken XYZ type\n    { cmsSigRedColorantTag,         { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[7]},\n    { cmsSigGreenColorantTag,       { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[8]},\n    { cmsSigBlueColorantTag,        { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[9]},\n\n    { cmsSigRedTRCTag,              { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[10]},\n    { cmsSigGreenTRCTag,            { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[11]},\n    { cmsSigBlueTRCTag,             { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[12]},\n\n    { cmsSigCalibrationDateTimeTag, { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[13]},\n    { cmsSigCharTargetTag,          { 1, 1, { cmsSigTextType },     NULL}, &SupportedTags[14]},\n\n    { cmsSigChromaticAdaptationTag, { 9, 1, { cmsSigS15Fixed16ArrayType }, NULL}, &SupportedTags[15]},\n    { cmsSigChromaticityTag,        { 1, 1, { cmsSigChromaticityType    }, NULL}, &SupportedTags[16]},\n    { cmsSigColorantOrderTag,       { 1, 1, { cmsSigColorantOrderType   }, NULL}, &SupportedTags[17]},\n    { cmsSigColorantTableTag,       { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[18]},\n    { cmsSigColorantTableOutTag,    { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[19]},\n\n    { cmsSigCopyrightTag,           { 1, 3, { cmsSigTextType,  cmsSigMultiLocalizedUnicodeType, cmsSigTextDescriptionType}, DecideTextType}, &SupportedTags[20]},\n    { cmsSigDateTimeTag,            { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[21]},\n\n    { cmsSigDeviceMfgDescTag,       { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[22]},\n    { cmsSigDeviceModelDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[23]},\n\n    { cmsSigGamutTag,               { 1, 3, { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[24]},\n\n    { cmsSigGrayTRCTag,             { 1, 2, { cmsSigCurveType, cmsSigParametricCurveType }, DecideCurveType}, &SupportedTags[25]},\n    { cmsSigLuminanceTag,           { 1, 1, { cmsSigXYZType }, NULL}, &SupportedTags[26]},\n\n    { cmsSigMediaBlackPointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[27]},\n    { cmsSigMediaWhitePointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[28]},\n\n    { cmsSigNamedColor2Tag,         { 1, 1, { cmsSigNamedColor2Type }, NULL}, &SupportedTags[29]},\n\n    { cmsSigPreview0Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[30]},\n    { cmsSigPreview1Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[31]},\n    { cmsSigPreview2Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[32]},\n\n    { cmsSigProfileDescriptionTag,  { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[33]},\n    { cmsSigProfileSequenceDescTag, { 1, 1, { cmsSigProfileSequenceDescType }, NULL}, &SupportedTags[34]},\n    { cmsSigTechnologyTag,          { 1, 1, { cmsSigSignatureType }, NULL},  &SupportedTags[35]},\n\n    { cmsSigColorimetricIntentImageStateTag,   { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[36]},\n    { cmsSigPerceptualRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[37]},\n    { cmsSigSaturationRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[38]},\n\n    { cmsSigMeasurementTag,         { 1, 1, { cmsSigMeasurementType }, NULL}, &SupportedTags[39]},\n\n    { cmsSigPs2CRD0Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[40]},\n    { cmsSigPs2CRD1Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[41]},\n    { cmsSigPs2CRD2Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[42]},\n    { cmsSigPs2CRD3Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[43]},\n    { cmsSigPs2CSATag,              { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[44]},\n    { cmsSigPs2RenderingIntentTag,  { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[45]},\n\n    { cmsSigViewingCondDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[46]},\n\n    { cmsSigUcrBgTag,               { 1, 1, { cmsSigUcrBgType}, NULL},    &SupportedTags[47]},\n    { cmsSigCrdInfoTag,             { 1, 1, { cmsSigCrdInfoType}, NULL},  &SupportedTags[48]},\n\n    { cmsSigDToB0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[49]},\n    { cmsSigDToB1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[50]},\n    { cmsSigDToB2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[51]},\n    { cmsSigDToB3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[52]},\n    { cmsSigBToD0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[53]},\n    { cmsSigBToD1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[54]},\n    { cmsSigBToD2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[55]},\n    { cmsSigBToD3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[56]},\n\n    { cmsSigScreeningDescTag,       { 1, 1, { cmsSigTextDescriptionType },    NULL}, &SupportedTags[57]},\n    { cmsSigViewingConditionsTag,   { 1, 1, { cmsSigViewingConditionsType },  NULL}, &SupportedTags[58]},\n\n    { cmsSigScreeningTag,           { 1, 1, { cmsSigScreeningType},          NULL }, &SupportedTags[59]},\n    { cmsSigVcgtTag,                { 1, 1, { cmsSigVcgtType},               NULL }, &SupportedTags[60]},\n    { cmsSigMetaTag,                { 1, 1, { cmsSigDictType},               NULL }, &SupportedTags[61]},\n    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL }, &SupportedTags[62]},\n    { cmsSigProfileDescriptionMLTag,{ 1, 1, { cmsSigMultiLocalizedUnicodeType}, NULL}, &SupportedTags[63]},\n    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n\n\n};\n\n/*\n    Not supported                 Why\n    =======================       =========================================\n    cmsSigOutputResponseTag   ==> WARNING, POSSIBLE PATENT ON THIS SUBJECT!\n    cmsSigNamedColorTag       ==> Deprecated\n    cmsSigDataTag             ==> Ancient, unused\n    cmsSigDeviceSettingsTag   ==> Deprecated, useless\n*/\n\n\n_cmsTagPluginChunkType _cmsTagPluginChunk = { NULL };\n\n\n// Duplicates the zone of memory used by the plug-in in the new context\nstatic\nvoid DupTagList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src)\n{\n   _cmsTagPluginChunkType newHead = { NULL };\n   _cmsTagLinkedList*  entry;\n   _cmsTagLinkedList*  Anterior = NULL;\n   _cmsTagPluginChunkType* head = (_cmsTagPluginChunkType*) src->chunks[TagPlugin];\n\n   // Walk the list copying all nodes\n   for (entry = head->Tag;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagLinkedList *newEntry = ( _cmsTagLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.Tag == NULL)\n               newHead.Tag = newEntry;\n   }\n\n   ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagPluginChunkType));\n}\n\nvoid _cmsAllocTagPluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n\n        DupTagList(ctx, src);\n    }\n    else {\n        static _cmsTagPluginChunkType TagPluginChunk = { NULL };\n        ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagPluginChunk, sizeof(_cmsTagPluginChunkType));\n    }\n\n}\n\ncmsBool  _cmsRegisterTagPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    cmsPluginTag* Plugin = (cmsPluginTag*) Data;\n    _cmsTagLinkedList *pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(id, TagPlugin);\n\n    if (Data == NULL) {\n\n        TagPluginChunk->Tag = NULL;\n        return TRUE;\n    }\n\n    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Signature  = Plugin ->Signature;\n    pt ->Descriptor = Plugin ->Descriptor;\n    pt ->Next       = TagPluginChunk ->Tag;\n\n    TagPluginChunk ->Tag = pt;\n    \n    return TRUE;\n}\n\n// Return a descriptor for a given tag or NULL\ncmsTagDescriptor* _cmsGetTagDescriptor(cmsContext ContextID, cmsTagSignature sig)\n{\n    _cmsTagLinkedList* pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(ContextID, TagPlugin);\n\n    for (pt = TagPluginChunk->Tag;\n             pt != NULL;\n             pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    for (pt = SupportedTags;\n            pt != NULL;\n            pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    return NULL;\n}\n\n"], "fixing_code": ["//---------------------------------------------------------------------------------\n//\n//  Little Color Management System\n//  Copyright (c) 1998-2016 Marti Maria Saguer\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//---------------------------------------------------------------------------------\n//\n\n#include \"lcms2_internal.h\"\n\n// Tag Serialization  -----------------------------------------------------------------------------\n// This file implements every single tag and tag type as described in the ICC spec. Some types\n// have been deprecated, like ncl and Data. There is no implementation for those types as there\n// are no profiles holding them. The programmer can also extend this list by defining his own types\n// by using the appropriate plug-in. There are three types of plug ins regarding that. First type\n// allows to define new tags using any existing type. Next plug-in type allows to define new types\n// and the third one is very specific: allows to extend the number of elements in the multiprocessing\n// elements special type.\n//--------------------------------------------------------------------------------------------------\n\n// Some broken types\n#define cmsCorbisBrokenXYZtype    ((cmsTagTypeSignature) 0x17A505B8)\n#define cmsMonacoBrokenCurveType  ((cmsTagTypeSignature) 0x9478ee00)\n\n// This is the linked list that keeps track of the defined types\ntypedef struct _cmsTagTypeLinkedList_st {\n\n    cmsTagTypeHandler Handler;\n    struct _cmsTagTypeLinkedList_st* Next;\n\n} _cmsTagTypeLinkedList;\n\n// Some macros to define callbacks.\n#define READ_FN(x)  Type_##x##_Read\n#define WRITE_FN(x) Type_##x##_Write\n#define FREE_FN(x)  Type_##x##_Free\n#define DUP_FN(x)   Type_##x##_Dup\n\n// Helper macro to define a handler. Callbacks do have a fixed naming convention.\n#define TYPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), DUP_FN(x), FREE_FN(x), NULL, 0 }\n\n// Helper macro to define a MPE handler. Callbacks do have a fixed naming convention\n#define TYPE_MPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), GenericMPEdup, GenericMPEfree, NULL, 0 }\n\n// Register a new type handler. This routine is shared between normal types and MPE. LinkedList points to the optional list head\nstatic\ncmsBool RegisterTypesPlugin(cmsContext id, cmsPluginBase* Data, _cmsMemoryClient pos)\n{\n    cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(id, pos);\n    _cmsTagTypeLinkedList *pt;\n\n    // Calling the function with NULL as plug-in would unregister the plug in.\n    if (Data == NULL) {\n\n        // There is no need to set free the memory, as pool is destroyed as a whole.\n        ctx ->TagTypes = NULL;\n        return TRUE;\n    }\n\n    // Registering happens in plug-in memory pool.\n    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagTypeLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Handler   = Plugin ->Handler;\n    pt ->Next      = ctx ->TagTypes;\n\n    ctx ->TagTypes = pt;\n     \n    return TRUE;\n}\n\n// Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons \n// made by plug-ins and then the built-in defaults.\nstatic\ncmsTagTypeHandler* GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* PluginLinkedList, _cmsTagTypeLinkedList* DefaultLinkedList)\n{\n    _cmsTagTypeLinkedList* pt;\n\n    for (pt = PluginLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    for (pt = DefaultLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    return NULL;\n}\n\n\n// Auxiliary to convert UTF-32 to UTF-16 in some cases\nstatic\ncmsBool _cmsWriteWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, const wchar_t* Array)\n{\n    cmsUInt32Number i;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(!(Array == NULL && n > 0));\n\n    for (i=0; i < n; i++) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Array[i])) return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Auxiliary to read an array of wchar_t\nstatic\ncmsBool _cmsReadWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, wchar_t* Array)\n{\n    cmsUInt32Number i;\n    cmsUInt16Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    for (i=0; i < n; i++) {\n\n        if (Array != NULL) {\n\n            if (!_cmsReadUInt16Number(io, &tmp)) return FALSE;\n            Array[i] = (wchar_t) tmp;\n        }\n        else {\n            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;\n        }\n\n    }\n    return TRUE;\n}\n\n// To deal with position tables\ntypedef cmsBool (* PositionTableEntryFn)(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag);\n\n// Helper function to deal with position tables as described in ICC spec 4.3\n// A table of n elements is readed, where first comes n records containing offsets and sizes and\n// then a block containing the data itself. This allows to reuse same data in more than one entry\nstatic\ncmsBool ReadPositionTable(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER* io,\n                              cmsUInt32Number Count,\n                              cmsUInt32Number BaseOffset,\n                              void *Cargo,\n                              PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n\n    // Let's take the offsets to each element\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt32Number(io, &ElementOffsets[i])) goto Error;\n        if (!_cmsReadUInt32Number(io, &ElementSizes[i])) goto Error;\n\n        ElementOffsets[i] += BaseOffset;\n    }\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!io -> Seek(io, ElementOffsets[i])) goto Error;\n\n        // This is the reader callback\n        if (!ElementFn(self, io, Cargo, i, ElementSizes[i])) goto Error;\n    }\n\n    // Success\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}\n\n// Same as anterior, but for write position tables\nstatic\ncmsBool WritePositionTable(struct _cms_typehandler_struct* self,\n                               cmsIOHANDLER* io,\n                               cmsUInt32Number SizeOfTag,\n                               cmsUInt32Number Count,\n                               cmsUInt32Number BaseOffset,\n                               void *Cargo,\n                               PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number DirectoryPos, CurrentPos, Before;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n\n     // Create table\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Keep starting position of curve offsets\n    DirectoryPos = io ->Tell(io);\n\n    // Write a fake directory to be filled latter on\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each element. Keep track of the size as well.\n    for (i=0; i < Count; i++) {\n\n        Before = io ->Tell(io);\n        ElementOffsets[i] = Before - BaseOffset;\n\n        // Callback to write...\n        if (!ElementFn(self, io, Cargo, i, SizeOfTag)) goto Error;\n\n        // Now the size\n        ElementSizes[i] = io ->Tell(io) - Before;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i <  Count; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}\n\n\n// ********************************************************************************\n// Type XYZ. Only one value is allowed\n// ********************************************************************************\n\n//The XYZType contains an array of three encoded values for the XYZ tristimulus\n//values. Tristimulus values must be non-negative. The signed encoding allows for\n//implementation optimizations by minimizing the number of fixed formats.\n\n\nstatic\nvoid *Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIEXYZ* xyz;\n\n    *nItems = 0;\n    xyz = (cmsCIEXYZ*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIEXYZ));\n    if (xyz == NULL) return NULL;\n\n    if (!_cmsReadXYZNumber(io, xyz)) {\n        _cmsFree(self ->ContextID, xyz);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) xyz;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_XYZ_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    return _cmsWriteXYZNumber(io, (cmsCIEXYZ*) Ptr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_XYZ_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIEXYZ));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_XYZ_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\nstatic\ncmsTagTypeSignature DecideXYZtype(cmsFloat64Number ICCVersion, const void *Data)\n{\n    return cmsSigXYZType;\n\n    cmsUNUSED_PARAMETER(ICCVersion);\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type chromaticity. Only one value is allowed\n// ********************************************************************************\n// The chromaticity tag type provides basic chromaticity data and type of\n// phosphors or colorants of a monitor to applications and utilities.\n\nstatic\nvoid *Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIExyYTRIPLE* chrm;\n    cmsUInt16Number nChans, Table;\n\n    *nItems = 0;\n    chrm =  (cmsCIExyYTRIPLE*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIExyYTRIPLE));\n    if (chrm == NULL) return NULL;\n\n    if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n\n    // Let's recover from a bug introduced in early versions of lcms1\n    if (nChans == 0 && SizeOfTag == 32) {\n\n        if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n        if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n    }\n\n    if (nChans != 3) goto Error;\n\n    if (!_cmsReadUInt16Number(io, &Table)) goto Error;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.y)) goto Error;\n\n    chrm ->Red.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.y)) goto Error;\n\n    chrm ->Green.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.y)) goto Error;\n\n    chrm ->Blue.Y = 1.0;\n\n    *nItems = 1;\n    return (void*) chrm;\n\nError:\n    _cmsFree(self ->ContextID, (void*) chrm);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  SaveOneChromaticity(cmsFloat64Number x, cmsFloat64Number y, cmsIOHANDLER* io)\n{\n    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(x))) return FALSE;\n    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(y))) return FALSE;\n\n    return TRUE;\n}\n\nstatic\ncmsBool  Type_Chromaticity_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsCIExyYTRIPLE* chrm = (cmsCIExyYTRIPLE*) Ptr;\n\n    if (!_cmsWriteUInt16Number(io, 3)) return FALSE;        // nChannels\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Table\n\n    if (!SaveOneChromaticity(chrm -> Red.x,   chrm -> Red.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Green.x, chrm -> Green.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Blue.x,  chrm -> Blue.y, io)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Chromaticity_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigColorantOrderType\n// ********************************************************************************\n\n// This is an optional tag which specifies the laydown order in which colorants will\n// be printed on an n-colorant device. The laydown order may be the same as the\n// channel generation order listed in the colorantTableTag or the channel order of a\n// colour space such as CMYK, in which case this tag is not needed. When this is not\n// the case (for example, ink-towers sometimes use the order KCMY), this tag may be\n// used to specify the laydown order of the colorants.\n\n\nstatic\nvoid *Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number* ColorantOrder;\n    cmsUInt32Number Count;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (Count > cmsMAXCHANNELS) return NULL;\n\n    ColorantOrder = (cmsUInt8Number*) _cmsCalloc(self ->ContextID, cmsMAXCHANNELS, sizeof(cmsUInt8Number));\n    if (ColorantOrder == NULL) return NULL;\n\n    // We use FF as end marker\n    memset(ColorantOrder, 0xFF, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    if (io ->Read(io, ColorantOrder, sizeof(cmsUInt8Number), Count) != Count) {\n\n        _cmsFree(self ->ContextID, (void*) ColorantOrder);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) ColorantOrder;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool Type_ColorantOrderType_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number*  ColorantOrder = (cmsUInt8Number*) Ptr;\n    cmsUInt32Number i, sz, Count;\n\n    // Get the length\n    for (Count=i=0; i < cmsMAXCHANNELS; i++) {\n        if (ColorantOrder[i] != 0xFF) Count++;\n    }\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n\n    sz = Count * sizeof(cmsUInt8Number);\n    if (!io -> Write(io, sz, ColorantOrder)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_ColorantOrderType_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_ColorantOrderType_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigS15Fixed16ArrayType\n// ********************************************************************************\n// This type represents an array of generic 4-byte/32-bit fixed point quantity.\n// The number of values is determined from the size of the tag.\n\nstatic\nvoid *Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &array_double[i])) {\n\n            _cmsFree(self ->ContextID, array_double);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}\n\nstatic\ncmsBool Type_S15Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_S15Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}\n\n\nstatic\nvoid Type_S15Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigU16Fixed16ArrayType\n// ********************************************************************************\n// This type represents an array of generic 4-byte/32-bit quantity.\n// The number of values is determined from the size of the tag.\n\n\nstatic\nvoid *Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number v;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsReadUInt32Number(io, &v)) {\n            _cmsFree(self ->ContextID, (void*) array_double);\n            return NULL;\n        }\n\n        // Convert to cmsFloat64Number\n        array_double[i] =  (cmsFloat64Number) (v / 65536.0);\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}\n\nstatic\ncmsBool Type_U16Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        cmsUInt32Number v = (cmsUInt32Number) floor(Value[i]*65536.0 + 0.5);\n\n        if (!_cmsWriteUInt32Number(io, v)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_U16Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}\n\nstatic\nvoid Type_U16Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigSignatureType\n// ********************************************************************************\n//\n// The signatureType contains a four-byte sequence, Sequences of less than four\n// characters are padded at the end with spaces, 20h.\n// Typically this type is used for registered tags that can be displayed on many\n// development systems as a sequence of four characters.\n\nstatic\nvoid *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));\n    if (SigPtr == NULL) return NULL;\n\n     if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;\n     *nItems = 1;\n\n     return SigPtr;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_Signature_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSignature* SigPtr = (cmsSignature*) Ptr;\n\n    return _cmsWriteUInt32Number(io, *SigPtr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Signature_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsSignature));\n}\n\nstatic\nvoid Type_Signature_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigTextType\n// ********************************************************************************\n//\n// The textType is a simple text structure that contains a 7-bit ASCII text string.\n// The length of the string is obtained by subtracting 8 from the element size portion\n// of the tag itself. This string must be terminated with a 00h byte.\n\nstatic\nvoid *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    cmsMLU* mlu = NULL;\n\n    // Create a container\n    mlu = cmsMLUalloc(self ->ContextID, 1);\n    if (mlu == NULL) return NULL;\n\n    *nItems = 0;\n\n    // We need to store the \"\\0\" at the end, so +1\n    if (SizeOfTag == UINT_MAX) goto Error;\n\n    Text = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n    if (Text == NULL) goto Error;\n\n    if (io -> Read(io, Text, sizeof(char), SizeOfTag) != SizeOfTag) goto Error;\n\n    // Make sure text is properly ended\n    Text[SizeOfTag] = 0;\n    *nItems = 1;\n\n    // Keep the result\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n\n    _cmsFree(self ->ContextID, Text);\n    return (void*) mlu;\n\nError:\n    if (mlu != NULL)\n        cmsMLUfree(mlu);\n    if (Text != NULL)\n        _cmsFree(self ->ContextID, Text);\n\n    return NULL;\n}\n\n// The conversion implies to choose a language. So, we choose the actual language.\nstatic\ncmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsUInt32Number size;\n    cmsBool  rc;\n    char* Text;\n\n    // Get the size of the string. Note there is an extra \"\\0\" at the end\n    size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    if (size == 0) return FALSE;       // Cannot be zero!\n\n    // Create memory\n    Text = (char*) _cmsMalloc(self ->ContextID, size);\n    if (Text == NULL) return FALSE;\n\n    cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);\n\n    // Write it, including separator\n    rc = io ->Write(io, size, Text);\n\n    _cmsFree(self ->ContextID, Text);\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_Text_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\ncmsTagTypeSignature DecideTextType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextType;\n\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDataType\n// ********************************************************************************\n\n// General purpose data type\nstatic\nvoid *Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCData* BinData;\n    cmsUInt32Number LenOfData;\n\n    *nItems = 0;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    LenOfData = SizeOfTag - sizeof(cmsUInt32Number);\n    if (LenOfData > INT_MAX) return NULL;\n\n    BinData = (cmsICCData*) _cmsMalloc(self ->ContextID, sizeof(cmsICCData) + LenOfData - 1);\n    if (BinData == NULL) return NULL;\n\n    BinData ->len = LenOfData;\n    if (!_cmsReadUInt32Number(io, &BinData->flag)) {\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    if (io -> Read(io, BinData ->data, sizeof(cmsUInt8Number), LenOfData) != LenOfData) {\n\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    *nItems = 1;\n\n    return (void*) BinData;\n}\n\n\nstatic\ncmsBool Type_Data_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n   cmsICCData* BinData = (cmsICCData*) Ptr;\n\n   if (!_cmsWriteUInt32Number(io, BinData ->flag)) return FALSE;\n\n   return io ->Write(io, BinData ->len, BinData ->data);\n\n   cmsUNUSED_PARAMETER(nItems);\n   cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Data_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsICCData* BinData = (cmsICCData*) Ptr;\n\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCData) + BinData ->len - 1);\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Data_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigTextDescriptionType\n// ********************************************************************************\n\nstatic\nvoid *Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    cmsMLU* mlu = NULL;\n    cmsUInt32Number  AsciiCount;\n    cmsUInt32Number  i, UnicodeCode, UnicodeCount;\n    cmsUInt16Number  ScriptCodeCode, Dummy;\n    cmsUInt8Number   ScriptCodeCount;\n\n    *nItems = 0;\n\n    //  One dword should be there\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    // Read len of ASCII\n    if (!_cmsReadUInt32Number(io, &AsciiCount)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Check for size\n    if (SizeOfTag < AsciiCount) return NULL;\n\n    // All seems Ok, allocate the container\n    mlu = cmsMLUalloc(self ->ContextID, 1);\n    if (mlu == NULL) return NULL;\n\n    // As many memory as size of tag\n    Text = (char*) _cmsMalloc(self ->ContextID, AsciiCount + 1);\n    if (Text == NULL) goto Error;\n\n    // Read it\n    if (io ->Read(io, Text, sizeof(char), AsciiCount) != AsciiCount) goto Error;\n    SizeOfTag -= AsciiCount;\n\n    // Make sure there is a terminator\n    Text[AsciiCount] = 0;\n\n    // Set the MLU entry. From here we can be tolerant to wrong types\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n    _cmsFree(self ->ContextID, (void*) Text);\n    Text = NULL;\n\n    // Skip Unicode code\n    if (SizeOfTag < 2* sizeof(cmsUInt32Number)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCode)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCount)) goto Done;\n    SizeOfTag -= 2* sizeof(cmsUInt32Number);\n\n    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n\n    for (i=0; i < UnicodeCount; i++) {\n        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n    }\n    SizeOfTag -= UnicodeCount*sizeof(cmsUInt16Number);\n\n    // Skip ScriptCode code if present. Some buggy profiles does have less\n    // data that stricttly required. We need to skip it as this type may come\n    // embedded in other types.\n\n    if (SizeOfTag >= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number) + 67) {\n\n        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;\n        if (!_cmsReadUInt8Number(io,  &ScriptCodeCount)) goto Done;\n\n        // Skip rest of tag\n        for (i=0; i < 67; i++) {\n            if (!io ->Read(io, &Dummy, sizeof(cmsUInt8Number), 1)) goto Error;\n        }\n    }\n\nDone:\n\n    *nItems = 1;\n    return mlu;\n\nError:\n    if (Text) _cmsFree(self ->ContextID, (void*) Text);\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}\n\n\n// This tag can come IN UNALIGNED SIZE. In order to prevent issues, we force zeros on description to align it\nstatic\ncmsBool  Type_Text_Description_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    char *Text = NULL;\n    wchar_t *Wide = NULL;\n    cmsUInt32Number len, len_text, len_tag_requirement, len_aligned;\n    cmsBool  rc = FALSE;\n    char Filler[68];\n\n    // Used below for writting zeroes\n    memset(Filler, 0, sizeof(Filler));\n\n    // Get the len of string\n    len = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n\n    // Specification ICC.1:2001-04 (v2.4.0): It has been found that textDescriptionType can contain misaligned data\n    //(see clause 4.1 for the definition of \ufffdaligned\ufffd). Because the Unicode language\n    // code and Unicode count immediately follow the ASCII description, their\n    // alignment is not correct if the ASCII count is not a multiple of four. The\n    // ScriptCode code is misaligned when the ASCII count is odd. Profile reading and\n    // writing software must be written carefully in order to handle these alignment\n    // problems.\n    //\n    // The above last sentence suggest to handle alignment issues in the\n    // parser. The provided example (Table 69 on Page 60) makes this clear. \n    // The padding only in the ASCII count is not sufficient for a aligned tag\n    // size, with the same text size in ASCII and Unicode.\n\n    // Null strings\n    if (len <= 0) {\n\n        Text = (char*)    _cmsDupMem(self ->ContextID, \"\", sizeof(char));\n        Wide = (wchar_t*) _cmsDupMem(self ->ContextID, L\"\", sizeof(wchar_t));\n    }\n    else {\n        // Create independent buffers\n        Text = (char*) _cmsCalloc(self ->ContextID, len, sizeof(char));\n        if (Text == NULL) goto Error;\n\n        Wide = (wchar_t*) _cmsCalloc(self ->ContextID, len, sizeof(wchar_t));\n        if (Wide == NULL) goto Error;\n\n        // Get both representations.\n        cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry,  Text, len * sizeof(char));\n        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n    }\n\n    // Tell the real text len including the null terminator and padding\n    len_text = (cmsUInt32Number) strlen(Text) + 1;\n    // Compute an total tag size requirement\n    len_tag_requirement = (8+4+len_text+4+4+2*len_text+2+1+67);\n    len_aligned = _cmsALIGNLONG(len_tag_requirement);\n\n  // * cmsUInt32Number       count;          * Description length\n  // * cmsInt8Number         desc[count]     * NULL terminated ascii string\n  // * cmsUInt32Number       ucLangCode;     * UniCode language code\n  // * cmsUInt32Number       ucCount;        * UniCode description length\n  // * cmsInt16Number        ucDesc[ucCount];* The UniCode description\n  // * cmsUInt16Number       scCode;         * ScriptCode code\n  // * cmsUInt8Number        scCount;        * ScriptCode count\n  // * cmsInt8Number         scDesc[67];     * ScriptCode Description\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    if (!io ->Write(io, len_text, Text)) goto Error;\n\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // ucLanguageCode\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    // Note that in some compilers sizeof(cmsUInt16Number) != sizeof(wchar_t)\n    if (!_cmsWriteWCharArray(io, len_text, Wide)) goto Error;\n\n    // ScriptCode Code & count (unused)\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt8Number(io, 0)) goto Error;\n\n    if (!io ->Write(io, 67, Filler)) goto Error;\n\n    // possibly add pad at the end of tag\n    if(len_aligned - len_tag_requirement > 0)\n      if (!io ->Write(io, len_aligned - len_tag_requirement, Filler)) goto Error;\n\n    rc = TRUE;\n\nError:\n    if (Text) _cmsFree(self ->ContextID, Text);\n    if (Wide) _cmsFree(self ->ContextID, Wide);\n\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_Text_Description_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\ncmsTagTypeSignature DecideTextDescType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextDescriptionType;\n\n    cmsUNUSED_PARAMETER(Data);\n}\n\n\n// ********************************************************************************\n// Type cmsSigCurveType\n// ********************************************************************************\n\nstatic\nvoid *Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number Count;\n    cmsToneCurve* NewGamma;\n    \n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    switch (Count) {\n\n           case 0:   // Linear.\n               {\n                   cmsFloat64Number SingleGamma = 1.0;\n\n                   NewGamma = cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n                   if (!NewGamma) return NULL;\n                   *nItems = 1;\n                   return NewGamma;\n               }\n              \n           case 1:  // Specified as the exponent of gamma function\n               {\n                   cmsUInt16Number SingleGammaFixed;\n                   cmsFloat64Number SingleGamma;\n\n                   if (!_cmsReadUInt16Number(io, &SingleGammaFixed)) return NULL;\n                   SingleGamma = _cms8Fixed8toDouble(SingleGammaFixed);\n\n                   *nItems = 1;\n                   return cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n               }\n\n           default:  // Curve\n\n               if (Count > 0x7FFF)\n                   return NULL; // This is to prevent bad guys for doing bad things\n\n               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, Count, NULL);\n               if (!NewGamma) return NULL;\n\n               if (!_cmsReadUInt16Array(io, Count, NewGamma -> Table16)) return NULL;\n\n               *nItems = 1;\n               return NewGamma;\n    }\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_Curve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n\n    if (Curve ->nSegments == 1 && Curve ->Segments[0].Type == 1) {\n\n            // Single gamma, preserve number\n            cmsUInt16Number SingleGammaFixed = _cmsDoubleTo8Fixed8(Curve ->Segments[0].Params[0]);\n\n            if (!_cmsWriteUInt32Number(io, 1)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, SingleGammaFixed)) return FALSE;\n            return TRUE;\n\n    }\n\n    if (!_cmsWriteUInt32Number(io, Curve ->nEntries)) return FALSE;\n    return _cmsWriteUInt16Array(io, Curve ->nEntries, Curve ->Table16);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Curve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_Curve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigParametricCurveType\n// ********************************************************************************\n\n\n// Decide which curve type to use on writting\nstatic\ncmsTagTypeSignature DecideCurveType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Data;\n\n    if (ICCVersion < 4.0) return cmsSigCurveType;\n    if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric\n    if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves\n    if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves\n\n    return cmsSigParametricCurveType;\n}\n\nstatic\nvoid *Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    static const int ParamsByType[] = { 1, 3, 4, 5, 7 };\n    cmsFloat64Number Params[10];\n    cmsUInt16Number Type;\n    int i, n;\n    cmsToneCurve* NewGamma;\n\n    if (!_cmsReadUInt16Number(io, &Type)) return NULL;\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;   // Reserved\n\n    if (Type > 4) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown parametric curve type '%d'\", Type);\n        return NULL;\n    }\n\n    memset(Params, 0, sizeof(Params));\n    n = ParamsByType[Type];\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &Params[i])) return NULL;\n    }\n\n    NewGamma = cmsBuildParametricToneCurve(self ->ContextID, Type+1, Params);\n\n    *nItems = 1;\n    return NewGamma;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_ParametricCurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n    int i, nParams, typen;\n    static const int ParamsByType[] = { 0, 1, 3, 4, 5, 7 };\n\n    typen = Curve -> Segments[0].Type;\n\n    if (Curve ->nSegments > 1 || typen < 1) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Multisegment or Inverted parametric curves cannot be written\");\n        return FALSE;\n    }\n\n    if (typen > 5) {\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported parametric curve\");\n        return FALSE;\n    }\n\n    nParams = ParamsByType[typen];\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) (Curve ->Segments[0].Type - 1))) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Reserved\n\n    for (i=0; i < nParams; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Curve -> Segments[0].Params[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_ParametricCurve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ParametricCurve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDateTimeType\n// ********************************************************************************\n\n// A 12-byte value representation of the time and date, where the byte usage is assigned\n// as specified in table 1. The actual values are encoded as 16-bit unsigned integers\n// (uInt16Number - see 5.1.6).\n//\n// All the dateTimeNumber values in a profile shall be in Coordinated Universal Time\n// (UTC, also known as GMT or ZULU Time). Profile writers are required to convert local\n// time to UTC when setting these values. Programmes that display these values may show\n// the dateTimeNumber as UTC, show the equivalent local time (at current locale), or\n// display both UTC and local versions of the dateTimeNumber.\n\nstatic\nvoid *Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsDateTimeNumber timestamp;\n    struct tm * NewDateTime;\n\n    *nItems = 0;\n    NewDateTime = (struct tm*) _cmsMalloc(self ->ContextID, sizeof(struct tm));\n    if (NewDateTime == NULL) return NULL;\n\n    if (io->Read(io, &timestamp, sizeof(cmsDateTimeNumber), 1) != 1) return NULL;\n\n     _cmsDecodeDateTimeNumber(&timestamp, NewDateTime);\n\n     *nItems = 1;\n     return NewDateTime;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_DateTime_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    struct tm * DateTime = (struct tm*) Ptr;\n    cmsDateTimeNumber timestamp;\n\n    _cmsEncodeDateTimeNumber(&timestamp, DateTime);\n    if (!io ->Write(io, sizeof(cmsDateTimeNumber), &timestamp)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_DateTime_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(struct tm));\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_DateTime_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n\n// ********************************************************************************\n// Type icMeasurementType\n// ********************************************************************************\n\n/*\nThe measurementType information refers only to the internal profile data and is\nmeant to provide profile makers an alternative to the default measurement\nspecifications.\n*/\n\nstatic\nvoid *Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCMeasurementConditions mc;\n\n\t\n    memset(&mc, 0, sizeof(mc));\n\t\n    if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;\n    if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &mc.Flare)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.IlluminantType)) return NULL;\n\n    *nItems = 1;\n    return _cmsDupMem(self ->ContextID, &mc, sizeof(cmsICCMeasurementConditions));\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool  Type_Measurement_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCMeasurementConditions* mc =(cmsICCMeasurementConditions*) Ptr;\n\n    if (!_cmsWriteUInt32Number(io, mc->Observer)) return FALSE;\n    if (!_cmsWriteXYZNumber(io,    &mc->Backing)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->Geometry)) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, mc->Flare)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCMeasurementConditions));\n\n     cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_Measurement_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigMultiLocalizedUnicodeType\n// ********************************************************************************\n//\n//   Do NOT trust SizeOfTag as there is an issue on the definition of profileSequenceDescTag. See the TechNote from\n//   Max Derhak and Rohit Patil about this: basically the size of the string table should be guessed and cannot be\n//   taken from the size of tag if this tag is embedded as part of bigger structures (profileSequenceDescTag, for instance)\n//\n\nstatic\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        // Now deal with Len and offset.\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n\n        // Check for overflow\n        if (Offset < (SizeOfHeader + 8)) goto Error;\n        if ((Offset + Len) > SizeOfTag + 8) goto Error;\n\n        // True begin of the string\n        BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        // Ajust to wchar_t elements\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        // To guess maximum size, add offset + len\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    // Now read the remaining of tag and fill all strings. Subtract the directory\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n        NumOfWchar = 0;\n\n    }\n    else\n    {\n        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n        if (Block == NULL) goto Error;\n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}\n\nstatic\ncmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu =(cmsMLU*) Ptr;\n    cmsUInt32Number HeaderSize;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number i;\n\n    if (Ptr == NULL) {\n\n          // Empty placeholder\n          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n          if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n          return TRUE;\n    }\n\n    if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n\n    HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);\n\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        Len    =  mlu ->Entries[i].Len;\n        Offset =  mlu ->Entries[i].StrW;\n\n        Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);\n        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;\n\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;\n        if (!_cmsWriteUInt32Number(io, Len)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;\n    }\n\n    if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_MLU_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_MLU_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigLut8Type\n// ********************************************************************************\n\n// Decide which LUT type to use on writting\nstatic\ncmsTagTypeSignature DecideLUTtypeA2B(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutAtoBType;\n    }\n}\n\nstatic\ncmsTagTypeSignature DecideLUTtypeB2A(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutBtoAType;\n    }\n}\n\n/*\nThis structure represents a colour transform using tables of 8-bit precision.\nThis type contains four processing elements: a 3 by 3 matrix (which shall be\nthe identity matrix unless the input colour space is XYZ), a set of one dimensional\ninput tables, a multidimensional lookup table, and a set of one dimensional output\ntables. Data is processed using these elements via the following sequence:\n(matrix) -> (1d input tables)  -> (multidimensional lookup table - CLUT) -> (1d output tables)\n\nByte Position   Field Length (bytes)  Content Encoded as...\n8                  1          Number of Input Channels (i)    uInt8Number\n9                  1          Number of Output Channels (o)   uInt8Number\n10                 1          Number of CLUT grid points (identical for each side) (g) uInt8Number\n11                 1          Reserved for padding (fill with 00h)\n\n12..15             4          Encoded e00 parameter   s15Fixed16Number\n*/\n\n\n// Read 8 bit tables as gamma functions\nstatic\ncmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)\n{\n    cmsUInt8Number* Temp = NULL;\n    int i, j;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n    if (nChannels <= 0) return FALSE;\n\n    memset(Tables, 0, sizeof(Tables));\n\n    Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);\n    if (Temp == NULL) return FALSE;\n\n    for (i=0; i < nChannels; i++) {\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n        if (Tables[i] == NULL) goto Error;\n    }\n\n    for (i=0; i < nChannels; i++) {\n\n        if (io ->Read(io, Temp, 256, 1) != 1) goto Error;\n\n        for (j=0; j < 256; j++)\n            Tables[i]->Table16[j] = (cmsUInt16Number) FROM_8_TO_16(Temp[j]);\n    }\n\n    _cmsFree(ContextID, Temp);\n    Temp = NULL;\n\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    if (Temp) _cmsFree(ContextID, Temp);\n    return FALSE;\n}\n\n\nstatic\ncmsBool Write8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsUInt32Number n, _cmsStageToneCurvesData* Tables)\n{\n    int j;\n    cmsUInt32Number i;\n    cmsUInt8Number val;\n\n    for (i=0; i < n; i++) {\n\n        if (Tables) {\n\n            // Usual case of identity curves\n            if ((Tables ->TheCurves[i]->nEntries == 2) && \n                (Tables->TheCurves[i]->Table16[0] == 0) && \n                (Tables->TheCurves[i]->Table16[1] == 65535)) {\n\n                    for (j=0; j < 256; j++) {\n                        if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) j)) return FALSE;\n                    }\n            }\n            else \n                if (Tables ->TheCurves[i]->nEntries != 256) {\n                    cmsSignalError(ContextID, cmsERROR_RANGE, \"LUT8 needs 256 entries on prelinearization\");\n                    return FALSE;                \n                }\n                else\n                    for (j=0; j < 256; j++) {\n\n                        val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);\n\n                        if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n                    }\n        }\n    }\n    return TRUE;\n}\n\n\n// Check overflow\nstatic\ncmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)\n{\n    cmsUInt32Number rv = 1, rc;\n\n    if (a == 0) return 0;\n    if (n == 0) return 0;\n\n    for (; b > 0; b--) {\n\n        rv *= a;\n\n        // Check for overflow\n        if (rv > UINT_MAX / a) return (cmsUInt32Number) -1;\n\n    }\n\n    rc = rv * n;\n\n    if (rv != rc / n) return (cmsUInt32Number) -1;\n    return rc;\n}\n\n\n// That will create a MPE LUT with Matrix, pre tables, CLUT and post tables.\n// 8 bit lut may be scaled easely to v4 PCS, but we need also to properly adjust\n// PCS on BToAxx tags and AtoB if abstract. We need to fix input direction.\n\nstatic\nvoid *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsUInt8Number* Temp = NULL;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize, i;\n    cmsFloat64Number Matrix[3*3];\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) goto Error;\n\n     if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) goto Error;\n\n    // Do some checking\n    if (InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels > cmsMAXCHANNELS) goto Error;\n\n   // Allocates an empty Pipeline\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates if not identity...\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    // Get input tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, InputChannels)) goto Error;\n\n    // Get 3D CLUT. Check the overflow....\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *PtrW, *T;\n       \n        PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);\n        if (Temp == NULL) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (io ->Read(io, Temp, nTabSize, 1) != 1) {\n            _cmsFree(self ->ContextID, T);\n            _cmsFree(self ->ContextID, Temp);\n            goto Error;\n        }\n\n        for (i = 0; i < nTabSize; i++) {\n\n            *PtrW++ = FROM_8_TO_16(Temp[i]);\n        }\n        _cmsFree(self ->ContextID, Temp);\n        Temp = NULL;\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T)))\n            goto Error;\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, OutputChannels)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// We only allow a specific MPE structure: Matrix plus prelin, plus clut, plus post-lin.\nstatic\ncmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number j, nTabSize;\n    cmsUInt8Number  val;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    int clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n    if (mpe ->Type == cmsSigMatrixElemType) {\n\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT8\");\n        return FALSE;\n    }\n\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else\n        clutPoints    = clut->Params->nSamples[0];\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->OutputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n\n\n    if (MatMPE != NULL) {\n\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;\n\n    }\n    else {\n\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n    // The prelinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;\n\n    nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n\n        // The 3D CLUT.\n        if (clut != NULL) {\n\n            for (j=0; j < nTabSize; j++) {\n\n                val = (cmsUInt8Number) FROM_16_TO_8(clut ->Tab.T[j]);\n                if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n            }\n        }\n    }\n\n    // The postlinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->OutputChannels, PostMPE)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_LUT8_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUT8_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// ********************************************************************************\n// Type cmsSigLut16Type\n// ********************************************************************************\n\n// Read 16 bit tables as gamma functions\nstatic\ncmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)\n{\n    int i;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    // Maybe an empty table? (this is a lcms extension)\n    if (nEntries <= 0) return TRUE;\n\n    // Check for malicious profiles\n    if (nEntries < 2) return FALSE;\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n\n    // Init table to zero\n    memset(Tables, 0, sizeof(Tables));\n\n    for (i=0; i < nChannels; i++) {\n\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, nEntries, NULL);\n        if (Tables[i] == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nEntries, Tables[i]->Table16)) goto Error;\n    }\n\n\n    // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    return FALSE;\n}\n\nstatic\ncmsBool Write16bitTables(cmsContext ContextID, cmsIOHANDLER* io, _cmsStageToneCurvesData* Tables)\n{\n    int j;\n    cmsUInt32Number i;\n    cmsUInt16Number val;\n    int nEntries;\n\n    _cmsAssert(Tables != NULL);\n\n    nEntries = Tables->TheCurves[0]->nEntries;\n\n    for (i=0; i < Tables ->nCurves; i++) {\n\n        for (j=0; j < nEntries; j++) {\n\n            val = Tables->TheCurves[i]->Table16[j];        \n            if (!_cmsWriteUInt16Number(io, val)) return FALSE;\n        }\n    }\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(ContextID);\n}\n\nstatic\nvoid *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize;\n    cmsFloat64Number Matrix[3*3];\n    cmsUInt16Number InputEntries, OutputEntries;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) return NULL;   // 255 maximum\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    // Do some checking\n    if (InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels > cmsMAXCHANNELS) goto Error;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates on 3 channels\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;\n    if (!_cmsReadUInt16Number(io, &OutputEntries)) goto Error;\n\n    if (InputEntries > 0x7FFF || OutputEntries > 0x7FFF) goto Error;\n    if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Get input tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, InputChannels, InputEntries)) goto Error;\n\n    // Get 3D CLUT\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *T;\n\n        T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nTabSize, T)) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, OutputChannels, OutputEntries)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// We only allow some specific MPE structures: Matrix plus prelin, plus clut, plus post-lin.\n// Some empty defaults are created for missing parts\n\nstatic\ncmsBool  Type_LUT16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number nTabSize;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    int i, InputChannels, OutputChannels, clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n    if (mpe != NULL && mpe ->Type == cmsSigMatrixElemType) {\n\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT16\");\n        return FALSE;\n    }\n\n    InputChannels  = cmsPipelineInputChannels(NewLUT);\n    OutputChannels = cmsPipelineOutputChannels(NewLUT);\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else\n        clutPoints    = clut->Params->nSamples[0];\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) InputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) OutputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n\n\n    if (MatMPE != NULL) {\n\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;\n    }\n    else {\n\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n\n    if (PreMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n            if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n    }\n\n    if (PostMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n    }\n\n    // The prelinearization table\n\n    if (PreMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < InputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    nTabSize = uipow(OutputChannels, clutPoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n        // The 3D CLUT.\n        if (clut != NULL) {\n            if (!_cmsWriteUInt16Array(io, nTabSize, clut->Tab.T)) return FALSE;\n        }\n    }\n\n    // The postlinearization table\n    if (PostMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < OutputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_LUT16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUT16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigLutAToBType\n// ********************************************************************************\n\n\n// V4 stuff. Read matrix for LutAtoB and LutBtoA\n\nstatic\ncmsStage* ReadMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset)\n{\n    cmsFloat64Number dMat[3*3];\n    cmsFloat64Number dOff[3];\n    cmsStage* Mat;\n\n    // Go to address\n    if (!io -> Seek(io, Offset)) return NULL;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io, &dMat[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[2])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[3])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[4])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[5])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[6])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[7])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[8])) return NULL;\n\n    if (!_cmsRead15Fixed16Number(io, &dOff[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[2])) return NULL;\n\n    Mat = cmsStageAllocMatrix(self ->ContextID, 3, 3, dMat, dOff);\n\n     return Mat;\n}\n\n\n\n\n//  V4 stuff. Read CLUT part for LutAtoB and LutBtoA\n\nstatic\ncmsStage* ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, int InputChannels, int OutputChannels)\n{\n    cmsUInt8Number  gridPoints8[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number GridPoints[cmsMAXCHANNELS], i;\n    cmsUInt8Number  Precision;\n    cmsStage* CLUT;\n    _cmsStageCLutData* Data;\n\n    if (!io -> Seek(io, Offset)) return NULL;\n    if (io -> Read(io, gridPoints8, cmsMAXCHANNELS, 1) != 1) return NULL;\n\n\n    for (i=0; i < cmsMAXCHANNELS; i++) {\n\n        if (gridPoints8[i] == 1) return NULL; // Impossible value, 0 for no CLUT and then 2 at least\n        GridPoints[i] = gridPoints8[i];\n    }\n\n    if (!_cmsReadUInt8Number(io, &Precision)) return NULL;\n\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    CLUT = cmsStageAllocCLut16bitGranular(self ->ContextID, GridPoints, InputChannels, OutputChannels, NULL);\n    if (CLUT == NULL) return NULL;\n\n    Data = (_cmsStageCLutData*) CLUT ->Data;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        cmsUInt8Number  v;\n\n        for (i=0; i < Data ->nEntries; i++) {\n\n            if (io ->Read(io, &v, sizeof(cmsUInt8Number), 1) != 1) return NULL;\n            Data ->Tab.T[i] = FROM_8_TO_16(v);\n        }\n\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsReadUInt16Array(io, Data->nEntries, Data ->Tab.T)) {\n                cmsStageFree(CLUT);\n                return NULL;\n            }\n        }\n        else {\n            cmsStageFree(CLUT);\n            cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return NULL;\n        }\n\n        return CLUT;\n}\n\nstatic\ncmsToneCurve* ReadEmbeddedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n    switch (BaseType) {\n\n            case cmsSigCurveType:\n                return (cmsToneCurve*) Type_Curve_Read(self, io, &nItems, 0);\n\n            case cmsSigParametricCurveType:\n                return (cmsToneCurve*) Type_ParametricCurve_Read(self, io, &nItems, 0);\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) BaseType);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return NULL;\n    }\n}\n\n\n// Read a set of curves from specific offset\nstatic\ncmsStage* ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, cmsUInt32Number nCurves)\n{\n    cmsToneCurve* Curves[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n    cmsStage* Lin = NULL;\n\n    if (nCurves > cmsMAXCHANNELS) return FALSE;\n\n    if (!io -> Seek(io, Offset)) return FALSE;\n\n    for (i=0; i < nCurves; i++)\n        Curves[i] = NULL;\n\n    for (i=0; i < nCurves; i++) {\n\n        Curves[i] = ReadEmbeddedCurve(self, io);\n        if (Curves[i] == NULL) goto Error;\n        if (!_cmsReadAlignment(io)) goto Error;\n\n    }\n\n    Lin = cmsStageAllocToneCurves(self ->ContextID, nCurves, Curves);\n\nError:\n    for (i=0; i < nCurves; i++)\n        cmsFreeToneCurve(Curves[i]);\n\n    return Lin;\n}\n\n\n// LutAtoB type\n\n// This structure represents a colour transform. The type contains up to five processing\n// elements which are stored in the AtoBTag tag in the following order: a set of one\n// dimensional curves, a 3 by 3 matrix with offset terms, a set of one dimensional curves,\n// a multidimensional lookup table, and a set of one dimensional output curves.\n// Data are processed using these elements via the following sequence:\n//\n//(\"A\" curves) -> (multidimensional lookup table - CLUT) -> (\"M\" curves) -> (matrix) -> (\"B\" curves).\n//\n/*\nIt is possible to use any or all of these processing elements. At least one processing element\nmust be included.Only the following combinations are allowed:\n\nB\nM - Matrix - B\nA - CLUT - B\nA - CLUT - M - Matrix - B\n\n*/\n\nstatic\nvoid* Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number      BaseOffset;\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n   // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// Write a set of curves\nstatic\ncmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)\n{\n    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;\n\n    // Write the Matrix\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;\n\n    if (m ->Offset != NULL) {\n\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;\n    }\n    else {\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n\n    }\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// Write a set of curves\nstatic\ncmsBool WriteSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsTagTypeSignature Type, cmsStage* mpe)\n{\n    cmsUInt32Number i, n;\n    cmsTagTypeSignature CurrentType;\n    cmsToneCurve** Curves;\n\n\n    n      = cmsStageOutputChannels(mpe);\n    Curves = _cmsStageGetPtrToCurveSet(mpe);\n\n    for (i=0; i < n; i++) {\n\n        // If this is a table-based curve, use curve type even on V4\n        CurrentType = Type;\n\n        if ((Curves[i] ->nSegments == 0)||\n            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n            CurrentType = cmsSigCurveType;\n        else\n        if (Curves[i] ->Segments[0].Type < 0)\n            CurrentType = cmsSigCurveType;\n\n        if (!_cmsWriteTypeBase(io, CurrentType)) return FALSE;\n\n        switch (CurrentType) {\n\n            case cmsSigCurveType:\n                if (!Type_Curve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            case cmsSigParametricCurveType:\n                if (!Type_ParametricCurve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) Type);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return FALSE;\n        }\n\n        if (!_cmsWriteAlignment(io)) return FALSE;\n    }\n\n\n    return TRUE;\n}\n\n\nstatic\ncmsBool WriteCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt8Number  Precision, cmsStage* mpe)\n{\n    cmsUInt8Number  gridPoints[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number i;\n    _cmsStageCLutData* CLUT = ( _cmsStageCLutData*) mpe -> Data;\n\n    if (CLUT ->HasFloatValues) {\n         cmsSignalError(self ->ContextID, cmsERROR_NOT_SUITABLE, \"Cannot save floating point data, CLUT are 8 or 16 bit only\");\n         return FALSE;\n    }\n\n    memset(gridPoints, 0, sizeof(gridPoints));\n    for (i=0; i < (cmsUInt32Number) CLUT ->Params ->nInputs; i++)\n        gridPoints[i] = (cmsUInt8Number) CLUT ->Params ->nSamples[i];\n\n    if (!io -> Write(io, cmsMAXCHANNELS*sizeof(cmsUInt8Number), gridPoints)) return FALSE;\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) Precision)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        for (i=0; i < CLUT->nEntries; i++) {\n\n            if (!_cmsWriteUInt8Number(io, FROM_16_TO_8(CLUT->Tab.T[i]))) return FALSE;\n        }\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsWriteUInt16Array(io, CLUT->nEntries, CLUT ->Tab.T)) return FALSE;\n        }\n        else {\n             cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return FALSE;\n        }\n\n        if (!_cmsWriteAlignment(io)) return FALSE;\n\n        return TRUE;\n}\n\n\n\n\nstatic\ncmsBool Type_LUTA2B_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    int inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage * Matrix = NULL;\n    cmsStage * CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n    // Get the base for all offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (Lut ->Elements != NULL)\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &M, &Matrix, &B))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &A, &CLUT, &B))\n                    if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType,\n                        cmsSigMatrixElemType, cmsSigCurveSetElemType, &A, &CLUT, &M, &Matrix, &B)) {\n\n                            cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutAToB\");\n                            return FALSE;\n                    }\n\n    // Get input, output channels\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    // Write channel count\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    // Keep directory to be filled latter\n    DirectoryPos = io ->Tell(io);\n\n    // Write the directory\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_LUTA2B_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUTA2B_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// LutBToA type\n\nstatic\nvoid* Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      BaseOffset;     // Actual position in file\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    // Padding\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n/*\nB\nB - Matrix - M\nB - CLUT - A\nB - Matrix - M - CLUT - A\n*/\n\nstatic\ncmsBool  Type_LUTB2A_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    int inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage *Matrix = NULL;\n    cmsStage *CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &B, &Matrix, &M))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &CLUT, &A))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n                    cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &Matrix, &M, &CLUT, &A)) {\n                        cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutBToA\");\n                        return FALSE;\n                }\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    DirectoryPos = io ->Tell(io);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\n\nstatic\nvoid* Type_LUTB2A_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_LUTB2A_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\n// ********************************************************************************\n// Type cmsSigColorantTableType\n// ********************************************************************************\n/*\nThe purpose of this tag is to identify the colorants used in the profile by a\nunique name and set of XYZ or L*a*b* values to give the colorant an unambiguous\nvalue. The first colorant listed is the colorant of the first device channel of\na lut tag. The second colorant listed is the colorant of the second device channel\nof a lut tag, and so on.\n*/\n\nstatic\nvoid *Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number i, Count;\n    cmsNAMEDCOLORLIST* List;\n    char Name[34];\n    cmsUInt16Number PCS[3];\n\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (Count > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many colorants '%d'\", Count);\n        return NULL;\n    }\n\n    List = cmsAllocNamedColorList(self ->ContextID, Count, 0, \"\", \"\");\n    for (i=0; i < Count; i++) {\n\n        if (io ->Read(io, Name, 32, 1) != 1) goto Error;\n        Name[33] = 0;\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n\n        if (!cmsAppendNamedColor(List, Name, PCS, NULL)) goto Error;\n\n    }\n\n    *nItems = 1;\n    return List;\n\nError:\n    *nItems = 0;\n    cmsFreeNamedColorList(List);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n\n// Saves a colorant table. It is using the named color structure for simplicity sake\nstatic\ncmsBool  Type_ColorantTable_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    int i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n        char root[33];\n        cmsUInt16Number PCS[3];\n\n        if (!cmsNamedColorInfo(NamedColorList, i, root, NULL, NULL, PCS, NULL)) return 0;\n        root[32] = 0;\n\n        if (!io ->Write(io, 32, root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_ColorantTable_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_ColorantTable_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigNamedColor2Type\n// ********************************************************************************\n//\n//The namedColor2Type is a count value and array of structures that provide color\n//coordinates for 7-bit ASCII color names. For each named color, a PCS and optional\n//device representation of the color are given. Both representations are 16-bit values.\n//The device representation corresponds to the header\ufffds \ufffdcolor space of data\ufffd field.\n//This representation should be consistent with the \ufffdnumber of device components\ufffd\n//field in the namedColor2Type. If this field is 0, device coordinates are not provided.\n//The PCS representation corresponds to the header\ufffds PCS field. The PCS representation\n//is always provided. Color names are fixed-length, 32-byte fields including null\n//termination. In order to maintain maximum portability, it is strongly recommended\n//that special characters of the 7-bit ASCII set not be used.\n\nstatic\nvoid *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n\n    cmsUInt32Number      vendorFlag;     // Bottom 16 bits for ICC use\n    cmsUInt32Number      count;          // Count of named colors\n    cmsUInt32Number      nDeviceCoords;  // Num of device coordinates\n    char                 prefix[32];     // Prefix for each color name\n    char                 suffix[32];     // Suffix for each color name\n    cmsNAMEDCOLORLIST*  v;\n    cmsUInt32Number i;\n\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;\n    if (!_cmsReadUInt32Number(io, &count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;\n\n    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;\n    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;\n\n    prefix[31] = suffix[31] = 0;\n\n    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);\n    if (v == NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many named colors '%d'\", count);\n        return NULL;\n    }\n\n    if (nDeviceCoords > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many device coordinates '%d'\", nDeviceCoords);\n        return 0;\n    }\n    for (i=0; i < count; i++) {\n\n        cmsUInt16Number PCS[3];\n        cmsUInt16Number Colorant[cmsMAXCHANNELS];\n        char Root[33];\n\n        memset(Colorant, 0, sizeof(Colorant));\n        if (io -> Read(io, Root, 32, 1) != 1) return NULL;\n        Root[32] = 0;  // To prevent exploits\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;\n\n        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;\n    }\n\n    *nItems = 1;\n    return (void*) v ;\n\nError:\n    cmsFreeNamedColorList(v);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// Saves a named color list into a named color profile\nstatic\ncmsBool Type_NamedColor_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    char                prefix[33];     // Prefix for each color name\n    char                suffix[33];     // Suffix for each color name\n    int i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, NamedColorList ->ColorantCount)) return FALSE;\n\n    strncpy(prefix, (const char*) NamedColorList->Prefix, 32);\n    strncpy(suffix, (const char*) NamedColorList->Suffix, 32);\n\n    suffix[32] = prefix[32] = 0;\n\n    if (!io ->Write(io, 32, prefix)) return FALSE;\n    if (!io ->Write(io, 32, suffix)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n       cmsUInt16Number PCS[3];\n       cmsUInt16Number Colorant[cmsMAXCHANNELS];\n       char Root[33];\n\n        if (!cmsNamedColorInfo(NamedColorList, i, Root, NULL, NULL, PCS, Colorant)) return 0;\n        Root[32] = 0;\n        if (!io ->Write(io, 32 , Root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, NamedColorList ->ColorantCount, Colorant)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid* Type_NamedColor_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigProfileSequenceDescType\n// ********************************************************************************\n\n// This type is an array of structures, each of which contains information from the\n// header fields and tags from the original profiles which were combined to create\n// the final profile. The order of the structures is the order in which the profiles\n// were combined and includes a structure for the final profile. This provides a\n// description of the profile sequence from source to destination,\n// typically used with the DeviceLink profile.\n\nstatic\ncmsBool ReadEmbeddedText(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU** mlu, cmsUInt32Number SizeOfTag)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n\n    switch (BaseType) {\n\n       case cmsSigTextType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu = (cmsMLU*)Type_Text_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       case cmsSigTextDescriptionType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_Text_Description_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n           /*\n           TBD: Size is needed for MLU, and we have no idea on which is the available size\n           */\n\n       case cmsSigMultiLocalizedUnicodeType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_MLU_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       default: return FALSE;\n    }\n}\n\n\nstatic\nvoid *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number i, Count;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n    OutSeq ->n = Count;\n\n    // Get structures as well\n\n    for (i=0; i < Count; i++) {\n\n        cmsPSEQDESC* sec = &OutSeq -> seq[i];\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceMfg)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceModel)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt64Number(io, &sec ->attributes)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt64Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt64Number);\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!ReadEmbeddedText(self, io, &sec ->Manufacturer, SizeOfTag)) goto Error;\n        if (!ReadEmbeddedText(self, io, &sec ->Model, SizeOfTag)) goto Error;\n    }\n\n    *nItems = 1;\n    return OutSeq;\n\nError:\n    cmsFreeProfileSequenceDescription(OutSeq);\n    return NULL;\n}\n\n\n// Aux--Embed a text description type. It can be of type text description or multilocalized unicode\n// and it depends of the version number passed on cmsTagDescriptor structure instead of stack\nstatic\ncmsBool  SaveDescription(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* Text)\n{\n    if (self ->ICCVersion < 0x4000000) {\n\n        if (!_cmsWriteTypeBase(io, cmsSigTextDescriptionType)) return FALSE;\n        return Type_Text_Description_Write(self, io, Text, 1);\n    }\n    else {\n        if (!_cmsWriteTypeBase(io, cmsSigMultiLocalizedUnicodeType)) return FALSE;\n        return Type_MLU_Write(self, io, Text, 1);\n    }\n}\n\n\nstatic\ncmsBool  Type_ProfileSequenceDesc_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, Seq->n)) return FALSE;\n\n    for (i=0; i < Seq ->n; i++) {\n\n        cmsPSEQDESC* sec = &Seq -> seq[i];\n\n        if (!_cmsWriteUInt32Number(io, sec ->deviceMfg)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->deviceModel)) return FALSE;\n        if (!_cmsWriteUInt64Number(io, &sec ->attributes)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->technology)) return FALSE;\n\n        if (!SaveDescription(self, io, sec ->Manufacturer)) return FALSE;\n        if (!SaveDescription(self, io, sec ->Model)) return FALSE;\n    }\n\n     return TRUE;\n\n     cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ProfileSequenceDesc_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigProfileSequenceIdType\n// ********************************************************************************\n/*\nIn certain workflows using ICC Device Link Profiles, it is necessary to identify the\noriginal profiles that were combined to create the Device Link Profile.\nThis type is an array of structures, each of which contains information for\nidentification of a profile used in a sequence\n*/\n\n\nstatic\ncmsBool ReadSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq = (cmsSEQ*) Cargo;\n    cmsPSEQDESC* seq = &OutSeq ->seq[n];\n\n    if (io -> Read(io, seq ->ProfileID.ID8, 16, 1) != 1) return FALSE;\n    if (!ReadEmbeddedText(self, io, &seq ->Description, SizeOfTag)) return FALSE;\n\n    return TRUE;\n}\n\n\n\nstatic\nvoid *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number Count;\n    cmsUInt32Number BaseOffset;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get table count\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Allocate an empty structure\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n\n    // Read the position table\n    if (!ReadPositionTable(self, io, Count, BaseOffset, OutSeq, ReadSeqID)) {\n\n        cmsFreeProfileSequenceDescription(OutSeq);\n        return NULL;\n    }\n\n    // Success\n    *nItems = 1;\n    return OutSeq;\n\n}\n\n\nstatic\ncmsBool WriteSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Cargo;\n\n    if (!io ->Write(io, 16, Seq ->seq[n].ProfileID.ID8)) return FALSE;\n\n    // Store here the MLU\n    if (!SaveDescription(self, io, Seq ->seq[n].Description)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_ProfileSequenceId_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number BaseOffset;\n\n    // Keep the base offset\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // This is the table count\n    if (!_cmsWriteUInt32Number(io, Seq ->n)) return FALSE;\n\n    // This is the position table and content\n    if (!WritePositionTable(self, io, 0, Seq ->n, BaseOffset, Seq, WriteSeqID)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_ProfileSequenceId_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigUcrBgType\n// ********************************************************************************\n/*\nThis type contains curves representing the under color removal and black\ngeneration and a text string which is a general description of the method used\nfor the ucr/bg.\n*/\n\nstatic\nvoid *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUcrBg* n = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n    cmsUInt32Number CountUcr, CountBg;\n    char* ASCIIString;\n\n    *nItems = 0;\n    if (n == NULL) return NULL;\n\n    // First curve is Under color removal\n    if (!_cmsReadUInt32Number(io, &CountUcr)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Ucr = cmsBuildTabulatedToneCurve16(self ->ContextID, CountUcr, NULL);\n    if (n ->Ucr == NULL) return NULL;\n\n    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= CountUcr * sizeof(cmsUInt16Number);\n\n    // Second curve is Black generation\n    if (!_cmsReadUInt32Number(io, &CountBg)) return NULL;\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Bg = cmsBuildTabulatedToneCurve16(self ->ContextID, CountBg, NULL);\n    if (n ->Bg == NULL) return NULL;\n    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) return NULL;\n    if (SizeOfTag < CountBg * sizeof(cmsUInt16Number)) return NULL;\n    SizeOfTag -= CountBg * sizeof(cmsUInt16Number);\n    if (SizeOfTag == UINT_MAX) return NULL;\n\n    // Now comes the text. The length is specified by the tag size\n    n ->Desc = cmsMLUalloc(self ->ContextID, 1);\n    if (n ->Desc == NULL) return NULL;\n\n    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n    if (io ->Read(io, ASCIIString, sizeof(char), SizeOfTag) != SizeOfTag) return NULL;\n    ASCIIString[SizeOfTag] = 0;\n    cmsMLUsetASCII(n ->Desc, cmsNoLanguage, cmsNoCountry, ASCIIString);\n    _cmsFree(self ->ContextID, ASCIIString);\n\n    *nItems = 1;\n    return (void*) n;\n}\n\nstatic\ncmsBool  Type_UcrBg_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUcrBg* Value = (cmsUcrBg*) Ptr;\n    cmsUInt32Number TextSize;\n    char* Text;\n\n    // First curve is Under color removal\n    if (!_cmsWriteUInt32Number(io, Value ->Ucr ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Ucr ->nEntries, Value ->Ucr ->Table16)) return FALSE;\n\n    // Then black generation\n    if (!_cmsWriteUInt32Number(io, Value ->Bg ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Bg ->nEntries, Value ->Bg ->Table16)) return FALSE;\n\n    // Now comes the text. The length is specified by the tag size\n    TextSize = cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n    if (cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, Text, TextSize) != TextSize) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n    cmsUcrBg* NewUcrBg = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n\n    if (NewUcrBg == NULL) return NULL;\n\n    NewUcrBg ->Bg   = cmsDupToneCurve(Src ->Bg);\n    NewUcrBg ->Ucr  = cmsDupToneCurve(Src ->Ucr);\n    NewUcrBg ->Desc = cmsMLUdup(Src ->Desc);\n\n    return (void*) NewUcrBg;\n\n    cmsUNUSED_PARAMETER(n);\n}\n\nstatic\nvoid Type_UcrBg_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n   cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n\n   if (Src ->Ucr) cmsFreeToneCurve(Src ->Ucr);\n   if (Src ->Bg)  cmsFreeToneCurve(Src ->Bg);\n   if (Src ->Desc) cmsMLUfree(Src ->Desc);\n\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigCrdInfoType\n// ********************************************************************************\n\n/*\nThis type contains the PostScript product name to which this profile corresponds\nand the names of the companion CRDs. Recall that a single profile can generate\nmultiple CRDs. It is implemented as a MLU being the language code \"PS\" and then\ncountry varies for each element:\n\n                nm: PostScript product name\n                #0: Rendering intent 0 CRD name\n                #1: Rendering intent 1 CRD name\n                #2: Rendering intent 2 CRD name\n                #3: Rendering intent 3 CRD name\n*/\n\n\n\n// Auxiliary, read an string specified as count + string\nstatic\ncmsBool  ReadCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)\n{\n    cmsUInt32Number Count;\n    char* Text;\n\n    if (*SizeOfTag < sizeof(cmsUInt32Number)) return FALSE;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return FALSE;\n\n    if (Count > UINT_MAX - sizeof(cmsUInt32Number)) return FALSE;\n    if (*SizeOfTag < Count + sizeof(cmsUInt32Number)) return FALSE;\n\n    Text     = (char*) _cmsMalloc(self ->ContextID, Count+1);\n    if (Text == NULL) return FALSE;\n\n    if (io ->Read(io, Text, sizeof(cmsUInt8Number), Count) != Count) {\n        _cmsFree(self ->ContextID, Text);\n        return FALSE;\n    }\n\n    Text[Count] = 0;\n\n    cmsMLUsetASCII(mlu, \"PS\", Section, Text);\n    _cmsFree(self ->ContextID, Text);\n\n    *SizeOfTag -= (Count + sizeof(cmsUInt32Number));\n    return TRUE;\n}\n\nstatic\ncmsBool  WriteCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)\n{\n cmsUInt32Number TextSize;\n char* Text;\n\n    TextSize = cmsMLUgetASCII(mlu, \"PS\", Section, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n\n    if (!_cmsWriteUInt32Number(io, TextSize)) return FALSE;\n\n    if (cmsMLUgetASCII(mlu, \"PS\", Section, Text, TextSize) == 0) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n}\n\nstatic\nvoid *Type_CrdInfo_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu = cmsMLUalloc(self ->ContextID, 5);\n\n    *nItems = 0;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"nm\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#0\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#1\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#2\")) goto Error;\n    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, \"#3\")) goto Error;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    cmsMLUfree(mlu);\n    return NULL;\n\n}\n\nstatic\ncmsBool  Type_CrdInfo_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    if (!WriteCountAndSting(self, io, mlu, \"nm\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#0\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#1\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#2\")) goto Error;\n    if (!WriteCountAndSting(self, io, mlu, \"#3\")) goto Error;\n\n    return TRUE;\n\nError:\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_CrdInfo_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_CrdInfo_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// ********************************************************************************\n// Type cmsSigScreeningType\n// ********************************************************************************\n//\n//The screeningType describes various screening parameters including screen\n//frequency, screening angle, and spot shape.\n\nstatic\nvoid *Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsScreening* sc = NULL;\n    cmsUInt32Number i;\n\n    sc = (cmsScreening*) _cmsMallocZero(self ->ContextID, sizeof(cmsScreening));\n    if (sc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &sc ->Flag)) goto Error;\n    if (!_cmsReadUInt32Number(io, &sc ->nChannels)) goto Error;\n\n    if (sc ->nChannels > cmsMAXCHANNELS - 1)\n        sc ->nChannels = cmsMAXCHANNELS - 1;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].Frequency)) goto Error;\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].ScreenAngle)) goto Error;\n        if (!_cmsReadUInt32Number(io, &sc ->Channels[i].SpotShape)) goto Error;\n    }\n\n\n    *nItems = 1;\n\n    return (void*) sc;\n\nError:\n    if (sc != NULL)\n        _cmsFree(self ->ContextID, sc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool Type_Screening_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsScreening* sc = (cmsScreening* ) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, sc ->Flag)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->nChannels)) return FALSE;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].Frequency)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].ScreenAngle)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sc ->Channels[i].SpotShape)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_Screening_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsScreening));\n\n   cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_Screening_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n// ********************************************************************************\n// Type cmsSigViewingConditionsType\n// ********************************************************************************\n//\n//This type represents a set of viewing condition parameters including:\n//CIE \ufffdabsolute\ufffd illuminant white point tristimulus values and CIE \ufffdabsolute\ufffd\n//surround tristimulus values.\n\nstatic\nvoid *Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCViewingConditions* vc = NULL;\n\n    vc = (cmsICCViewingConditions*) _cmsMallocZero(self ->ContextID, sizeof(cmsICCViewingConditions));\n    if (vc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadXYZNumber(io, &vc ->IlluminantXYZ)) goto Error;\n    if (!_cmsReadXYZNumber(io, &vc ->SurroundXYZ)) goto Error;\n    if (!_cmsReadUInt32Number(io, &vc ->IlluminantType)) goto Error;\n\n    *nItems = 1;\n\n    return (void*) vc;\n\nError:\n    if (vc != NULL)\n        _cmsFree(self ->ContextID, vc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\nstatic\ncmsBool Type_ViewingConditions_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCViewingConditions* sc = (cmsICCViewingConditions* ) Ptr;\n\n    if (!_cmsWriteXYZNumber(io, &sc ->IlluminantXYZ)) return FALSE;\n    if (!_cmsWriteXYZNumber(io, &sc ->SurroundXYZ)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid* Type_ViewingConditions_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self->ContextID, Ptr, sizeof(cmsICCViewingConditions));\n\n   cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_ViewingConditions_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigMultiProcessElementType\n// ********************************************************************************\n\n\nstatic\nvoid* GenericMPEdup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsStageDup((cmsStage*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid GenericMPEfree(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsStageFree((cmsStage*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n// Each curve is stored in one or more curve segments, with break-points specified between curve segments.\n// The first curve segment always starts at \ufffdInfinity, and the last curve segment always ends at +Infinity. The\n// first and last curve segments shall be specified in terms of a formula, whereas the other segments shall be\n// specified either in terms of a formula, or by a sampled curve.\n\n\n// Read an embedded segmented curve\nstatic\ncmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsCurveSegSignature ElementSig;\n    cmsUInt32Number i, j;\n    cmsUInt16Number nSegments;\n    cmsCurveSegment*  Segments;\n    cmsToneCurve* Curve;\n    cmsFloat32Number PrevBreak = -1E22F;    // - infinite\n\n    // Take signature and channels for each element.\n     if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return NULL;\n\n     // That should be a segmented curve\n     if (ElementSig != cmsSigSegmentedCurve) return NULL;\n\n     if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n     if (!_cmsReadUInt16Number(io, &nSegments)) return NULL;\n     if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n     if (nSegments < 1) return NULL;\n     Segments = (cmsCurveSegment*) _cmsCalloc(self ->ContextID, nSegments, sizeof(cmsCurveSegment));\n     if (Segments == NULL) return NULL;\n\n     // Read breakpoints\n     for (i=0; i < (cmsUInt32Number) nSegments - 1; i++) {\n\n         Segments[i].x0 = PrevBreak;\n         if (!_cmsReadFloat32Number(io, &Segments[i].x1)) goto Error;\n         PrevBreak = Segments[i].x1;\n     }\n\n     Segments[nSegments-1].x0 = PrevBreak;\n     Segments[nSegments-1].x1 = 1E22F;     // A big cmsFloat32Number number\n\n     // Read segments\n     for (i=0; i < nSegments; i++) {\n\n          if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) goto Error;\n          if (!_cmsReadUInt32Number(io, NULL)) goto Error;\n\n           switch (ElementSig) {\n\n            case cmsSigFormulaCurveSeg: {\n\n                cmsUInt16Number Type;\n                cmsUInt32Number ParamsByType[] = {4, 5, 5 };\n\n                if (!_cmsReadUInt16Number(io, &Type)) goto Error;\n                if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n\n                Segments[i].Type = Type + 6;\n                if (Type > 2) goto Error;\n\n                for (j=0; j < ParamsByType[Type]; j++) {\n\n                    cmsFloat32Number f;\n                    if (!_cmsReadFloat32Number(io, &f)) goto Error;\n                    Segments[i].Params[j] = f;\n                }\n                }\n                break;\n\n\n            case cmsSigSampledCurveSeg: {\n                cmsUInt32Number Count;\n\n                if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n                Segments[i].nGridPoints = Count;\n                Segments[i].SampledPoints = (cmsFloat32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsFloat32Number));\n                if (Segments[i].SampledPoints == NULL) goto Error;\n\n                for (j=0; j < Count; j++) {\n                    if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;\n                }\n                }\n                break;\n\n            default:\n                {\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve element type '%s' found.\", String);\n                }\n                return NULL;\n\n         }\n     }\n\n     Curve = cmsBuildSegmentedToneCurve(self ->ContextID, nSegments, Segments);\n\n     for (i=0; i < nSegments; i++) {\n         if (Segments[i].SampledPoints) _cmsFree(self ->ContextID, Segments[i].SampledPoints);\n     }\n     _cmsFree(self ->ContextID, Segments);\n     return Curve;\n\nError:\n     if (Segments) _cmsFree(self ->ContextID, Segments);\n     return NULL;\n}\n\n\nstatic\ncmsBool ReadMPECurve(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     void* Cargo,\n                     cmsUInt32Number n,\n                     cmsUInt32Number SizeOfTag)\n{\n      cmsToneCurve** GammaTables = ( cmsToneCurve**) Cargo;\n\n      GammaTables[n] = ReadSegmentedCurve(self, io);\n      return (GammaTables[n] != NULL);\n\n      cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\nvoid *Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number i, BaseOffset;\n    cmsToneCurve** GammaTables;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans != OutputChans) return NULL;\n\n    GammaTables = (cmsToneCurve**) _cmsCalloc(self ->ContextID, InputChans, sizeof(cmsToneCurve*));\n    if (GammaTables == NULL) return NULL;\n\n    if (ReadPositionTable(self, io, InputChans, BaseOffset, GammaTables, ReadMPECurve)) {\n\n        mpe = cmsStageAllocToneCurves(self ->ContextID, InputChans, GammaTables);\n    }\n    else {\n        mpe = NULL;\n    }\n\n    for (i=0; i < InputChans; i++) {\n        if (GammaTables[i]) cmsFreeToneCurve(GammaTables[i]);\n    }\n\n    _cmsFree(self ->ContextID, GammaTables);\n    *nItems = (mpe != NULL) ? 1 : 0;\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// Write a single segmented curve. NO CHECK IS PERFORMED ON VALIDITY\nstatic\ncmsBool WriteSegmentedCurve(cmsIOHANDLER* io, cmsToneCurve* g)\n{\n    cmsUInt32Number i, j;\n    cmsCurveSegment* Segments = g ->Segments;\n    cmsUInt32Number nSegments = g ->nSegments;\n\n    if (!_cmsWriteUInt32Number(io, cmsSigSegmentedCurve)) goto Error;\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) nSegments)) goto Error;\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n    // Write the break-points\n    for (i=0; i < nSegments - 1; i++) {\n        if (!_cmsWriteFloat32Number(io, Segments[i].x1)) goto Error;\n    }\n\n    // Write the segments\n    for (i=0; i < g ->nSegments; i++) {\n\n        cmsCurveSegment* ActualSeg = Segments + i;\n\n        if (ActualSeg -> Type == 0) {\n\n            // This is a sampled curve\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigSampledCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints)) goto Error;\n\n            for (j=0; j < g ->Segments[i].nGridPoints; j++) {\n                if (!_cmsWriteFloat32Number(io, ActualSeg -> SampledPoints[j])) goto Error;\n            }\n\n        }\n        else {\n            int Type;\n            cmsUInt32Number ParamsByType[] = { 4, 5, 5 };\n\n            // This is a formula-based\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigFormulaCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n\n            // We only allow 1, 2 and 3 as types\n            Type = ActualSeg ->Type - 6;\n            if (Type > 2 || Type < 0) goto Error;\n\n            if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Type)) goto Error;\n            if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n            for (j=0; j < ParamsByType[Type]; j++) {\n                if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) ActualSeg ->Params[j])) goto Error;\n            }\n        }\n\n        // It seems there is no need to align. Code is here, and for safety commented out\n        // if (!_cmsWriteAlignment(io)) goto Error;\n    }\n\n    return TRUE;\n\nError:\n    return FALSE;\n}\n\n\nstatic\ncmsBool WriteMPECurve(struct _cms_typehandler_struct* self,\n                      cmsIOHANDLER* io,\n                      void* Cargo,\n                      cmsUInt32Number n,\n                      cmsUInt32Number SizeOfTag)\n{\n    _cmsStageToneCurvesData* Curves  = (_cmsStageToneCurvesData*) Cargo;\n\n    return WriteSegmentedCurve(io, Curves ->TheCurves[n]);\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(self);\n}\n\n// Write a curve, checking first for validity\nstatic\ncmsBool  Type_MPEcurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number BaseOffset;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageToneCurvesData* Curves = (_cmsStageToneCurvesData*) mpe ->Data;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Write the header. Since those are curves, input and output channels are same\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n\n    if (!WritePositionTable(self, io, 0,\n                                mpe ->InputChannels, BaseOffset, Curves, WriteMPECurve)) return FALSE;\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\n\n// The matrix is organized as an array of PxQ+Q elements, where P is the number of input channels to the\n// matrix, and Q is the number of output channels. The matrix elements are each float32Numbers. The array\n// is organized as follows:\n// array = [e11, e12, \ufffd, e1P, e21, e22, \ufffd, e2P, \ufffd, eQ1, eQ2, \ufffd, eQP, e1, e2, \ufffd, eQ]\n\nstatic\nvoid *Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe;\n    cmsUInt16Number   InputChans, OutputChans;\n    cmsUInt32Number   nElems, i;\n    cmsFloat64Number* Matrix;\n    cmsFloat64Number* Offsets;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n\n    nElems = InputChans * OutputChans;\n\n    // Input and output chans may be ANY (up to 0xffff)\n    Matrix = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, nElems, sizeof(cmsFloat64Number));\n    if (Matrix == NULL) return NULL;\n\n    Offsets = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, OutputChans, sizeof(cmsFloat64Number));\n    if (Offsets == NULL) {\n\n        _cmsFree(self ->ContextID, Matrix);\n        return NULL;\n    }\n\n    for (i=0; i < nElems; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) return NULL;\n        Matrix[i] = v;\n    }\n\n\n    for (i=0; i < OutputChans; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) return NULL;\n        Offsets[i] = v;\n    }\n\n\n    mpe = cmsStageAllocMatrix(self ->ContextID, OutputChans, InputChans, Matrix, Offsets);\n    _cmsFree(self ->ContextID, Matrix);\n    _cmsFree(self ->ContextID, Offsets);\n\n    *nItems = 1;\n\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\nstatic\ncmsBool  Type_MPEmatrix_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, nElems;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageMatrixData* Matrix = (_cmsStageMatrixData*) mpe ->Data;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    nElems = mpe ->InputChannels * mpe ->OutputChannels;\n\n    for (i=0; i < nElems; i++) {\n        if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Double[i])) return FALSE;\n    }\n\n\n    for (i=0; i < mpe ->OutputChannels; i++) {\n\n        if (Matrix ->Offset == NULL) {\n\n               if (!_cmsWriteFloat32Number(io, 0)) return FALSE;\n        }\n        else {\n               if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Offset[i])) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\nstatic\nvoid *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt8Number Dimensions8[16];\n    cmsUInt32Number i, nMaxGrids, GridPoints[MAX_INPUT_DIMENSIONS];\n    _cmsStageCLutData* clut;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans == 0) goto Error;\n    if (OutputChans == 0) goto Error;\n\n    if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)\n        goto Error;\n\n    // Copy MAX_INPUT_DIMENSIONS at most. Expand to cmsUInt32Number\n    nMaxGrids = InputChans > MAX_INPUT_DIMENSIONS ? MAX_INPUT_DIMENSIONS : InputChans;\n    for (i=0; i < nMaxGrids; i++) GridPoints[i] = (cmsUInt32Number) Dimensions8[i];\n\n    // Allocate the true CLUT\n    mpe = cmsStageAllocCLutFloatGranular(self ->ContextID, GridPoints, InputChans, OutputChans, NULL);\n    if (mpe == NULL) goto Error;\n\n    // Read the data\n    clut = (_cmsStageCLutData*) mpe ->Data;\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsReadFloat32Number(io, &clut ->Tab.TFloat[i])) goto Error;\n    }\n\n    *nItems = 1;\n    return mpe;\n\nError:\n    *nItems = 0;\n    if (mpe != NULL) cmsStageFree(mpe);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n// Write a CLUT in floating point\nstatic\ncmsBool  Type_MPEclut_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number Dimensions8[16];  // 16 because the spec says 16 and not max number of channels\n    cmsUInt32Number i;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe ->Data;\n\n    // Check for maximum number of channels supported by lcms\n    if (mpe -> InputChannels > MAX_INPUT_DIMENSIONS) return FALSE;\n\n    // Only floats are supported in MPE\n    if (clut ->HasFloatValues == FALSE) return FALSE;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    memset(Dimensions8, 0, sizeof(Dimensions8));\n\n    for (i=0; i < mpe ->InputChannels; i++)\n        Dimensions8[i] = (cmsUInt8Number) clut ->Params ->nSamples[i];\n\n    if (!io ->Write(io, 16, Dimensions8)) return FALSE;\n\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsWriteFloat32Number(io, clut ->Tab.TFloat[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n\n// This is the list of built-in MPE types\nstatic _cmsTagTypeLinkedList SupportedMPEtypes[] = {\n\n{{ (cmsTagTypeSignature) cmsSigBAcsElemType, NULL, NULL, NULL, NULL, NULL, 0 }, &SupportedMPEtypes[1] },   // Ignore those elements for now\n{{ (cmsTagTypeSignature) cmsSigEAcsElemType, NULL, NULL, NULL, NULL, NULL, 0 }, &SupportedMPEtypes[2] },   // (That's what the spec says)\n\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCurveSetElemType,     MPEcurve),      &SupportedMPEtypes[3] },\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigMatrixElemType,       MPEmatrix),     &SupportedMPEtypes[4] },\n{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCLutElemType,         MPEclut),        NULL },\n};\n\n_cmsTagTypePluginChunkType _cmsMPETypePluginChunk = { NULL };\n\nstatic\ncmsBool ReadMPEElem(struct _cms_typehandler_struct* self,\n                    cmsIOHANDLER* io,\n                    void* Cargo,\n                    cmsUInt32Number n,\n                    cmsUInt32Number SizeOfTag)\n{\n    cmsStageSignature ElementSig;\n    cmsTagTypeHandler* TypeHandler;\n    cmsUInt32Number nItems;\n    cmsPipeline *NewLUT = (cmsPipeline *) Cargo;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n\n    // Take signature and channels for each element.\n    if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return FALSE;\n\n    // The reserved placeholder\n    if (!_cmsReadUInt32Number(io, NULL)) return FALSE;\n\n    // Read diverse MPE types\n    TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk ->TagTypes, SupportedMPEtypes);\n    if (TypeHandler == NULL)  {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n        // An unknown element was found.\n        cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown MPE type '%s' found.\", String);\n        return FALSE;\n    }\n\n    // If no read method, just ignore the element (valid for cmsSigBAcsElemType and cmsSigEAcsElemType)\n    // Read the MPE. No size is given\n    if (TypeHandler ->ReadPtr != NULL) {\n\n        // This is a real element which should be read and processed\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag)))\n            return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(n);\n}\n\n\n// This is the main dispatcher for MPE\nstatic\nvoid *Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number ElementCount;\n    cmsPipeline *NewLUT = NULL;\n    cmsUInt32Number BaseOffset;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Read channels and element count\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChans, OutputChans);\n    if (NewLUT == NULL) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &ElementCount)) return NULL;\n\n    if (!ReadPositionTable(self, io, ElementCount, BaseOffset, NewLUT, ReadMPEElem)) {\n        if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n        *nItems = 0;\n        return NULL;\n    }\n\n    // Success\n    *nItems = 1;\n    return NewLUT;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n\n// This one is a liitle bit more complex, so we don't use position tables this time.\nstatic\ncmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, BaseOffset, DirectoryPos, CurrentPos;\n    int inputChan, outputChan;\n    cmsUInt32Number ElemCount;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL, Before;\n    cmsStageSignature ElementSig;\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsStage* Elem = Lut ->Elements;\n    cmsTagTypeHandler* TypeHandler;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n    ElemCount  = cmsPipelineStageCount(Lut);\n\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Write the head\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) outputChan)) goto Error;\n    if (!_cmsWriteUInt32Number(io, (cmsUInt16Number) ElemCount)) goto Error;\n\n    DirectoryPos = io ->Tell(io);\n\n    // Write a fake directory to be filled latter on\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each single tag. Keep track of the size as well.\n    for (i=0; i < ElemCount; i++) {\n\n        ElementOffsets[i] = io ->Tell(io) - BaseOffset;\n\n        ElementSig = Elem ->Type;\n\n        TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk->TagTypes, SupportedMPEtypes);\n        if (TypeHandler == NULL)  {\n\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n                 // An unknow element was found.\n                 cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Found unknown MPE type '%s'\", String);\n                 goto Error;\n        }\n\n        if (!_cmsWriteUInt32Number(io, ElementSig)) goto Error;\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n        Before = io ->Tell(io);\n        if (!TypeHandler ->WritePtr(self, io, Elem, 1)) goto Error;\n        if (!_cmsWriteAlignment(io)) goto Error;\n\n        ElementSizes[i] = io ->Tell(io) - Before;\n\n        Elem = Elem ->Next;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_MPE_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid Type_MPE_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type cmsSigVcgtType\n// ********************************************************************************\n\n\n#define cmsVideoCardGammaTableType    0\n#define cmsVideoCardGammaFormulaType  1\n\n// Used internally\ntypedef struct {\n    double Gamma;\n    double Min;\n    double Max;\n} _cmsVCGTGAMMA;\n\n\nstatic\nvoid *Type_vcgt_Read(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     cmsUInt32Number* nItems,\n                     cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number TagType, n, i;\n    cmsToneCurve** Curves;\n\n    *nItems = 0;\n\n    // Read tag type\n    if (!_cmsReadUInt32Number(io, &TagType)) return NULL;\n\n    // Allocate space for the array\n    Curves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (Curves == NULL) return NULL;\n\n    // There are two possible flavors\n    switch (TagType) {\n\n    // Gamma is stored as a table\n    case cmsVideoCardGammaTableType:\n    {\n       cmsUInt16Number nChannels, nElems, nBytes;\n\n       // Check channel count, which should be 3 (we don't support monochrome this time)\n       if (!_cmsReadUInt16Number(io, &nChannels)) goto Error;\n\n       if (nChannels != 3) {\n           cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported number of channels for VCGT '%d'\", nChannels);\n           goto Error;\n       }\n\n       // Get Table element count and bytes per element\n       if (!_cmsReadUInt16Number(io, &nElems)) goto Error;\n       if (!_cmsReadUInt16Number(io, &nBytes)) goto Error;\n\n       // Adobe's quirk fixup. Fixing broken profiles...\n       if (nElems == 256 && nBytes == 1 && SizeOfTag == 1576)\n           nBytes = 2;\n\n\n       // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           Curves[n] = cmsBuildTabulatedToneCurve16(self ->ContextID, nElems, NULL);\n           if (Curves[n] == NULL) goto Error;\n\n           // On depending on byte depth\n           switch (nBytes) {\n\n           // One byte, 0..255\n           case 1:\n               for (i=0; i < nElems; i++) {\n\n                   cmsUInt8Number v;\n\n                      if (!_cmsReadUInt8Number(io, &v)) goto Error;\n                      Curves[n] ->Table16[i] = FROM_8_TO_16(v);\n               }\n               break;\n\n           // One word 0..65535\n           case 2:\n              if (!_cmsReadUInt16Array(io, nElems, Curves[n]->Table16)) goto Error;\n              break;\n\n          // Unsupported\n           default:\n              cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported bit depth for VCGT '%d'\", nBytes * 8);\n              goto Error;\n           }\n       } // For all 3 channels\n    }\n    break;\n\n   // In this case, gamma is stored as a formula\n   case cmsVideoCardGammaFormulaType:\n   {\n       _cmsVCGTGAMMA Colorant[3];\n\n        // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           double Params[10];\n\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Gamma)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Min)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Max)) goto Error;\n\n            // Parametric curve type 5 is:\n            // Y = (aX + b)^Gamma + e | X >= d\n            // Y = cX + f             | X < d\n\n            // vcgt formula is:\n            // Y = (Max \ufffd Min) * (X ^ Gamma) + Min\n\n            // So, the translation is\n            // a = (Max \ufffd Min) ^ ( 1 / Gamma)\n            // e = Min\n            // b=c=d=f=0\n\n           Params[0] = Colorant[n].Gamma;\n           Params[1] = pow((Colorant[n].Max - Colorant[n].Min), (1.0 / Colorant[n].Gamma));\n           Params[2] = 0;\n           Params[3] = 0;\n           Params[4] = 0;\n           Params[5] = Colorant[n].Min;\n           Params[6] = 0;\n\n           Curves[n] = cmsBuildParametricToneCurve(self ->ContextID, 5, Params);\n           if (Curves[n] == NULL) goto Error;\n       }\n   }\n   break;\n\n   // Unsupported\n   default:\n      cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported tag type for VCGT '%d'\", TagType);\n      goto Error;\n   }\n\n   *nItems = 1;\n   return (void*) Curves;\n\n// Regret,  free all resources\nError:\n\n    cmsFreeToneCurveTriple(Curves);\n    _cmsFree(self ->ContextID, Curves);\n    return NULL;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n\n\n// We don't support all flavors, only 16bits tables and formula\nstatic\ncmsBool Type_vcgt_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve** Curves =  (cmsToneCurve**) Ptr;\n    cmsUInt32Number i, j;\n\n    if (cmsGetToneCurveParametricType(Curves[0]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[1]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[2]) == 5) {\n\n            if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaFormulaType)) return FALSE;\n\n            // Save parameters\n            for (i=0; i < 3; i++) {\n\n                _cmsVCGTGAMMA v;\n\n                v.Gamma = Curves[i] ->Segments[0].Params[0];\n                v.Min   = Curves[i] ->Segments[0].Params[5];\n                v.Max   = pow(Curves[i] ->Segments[0].Params[1], v.Gamma) + v.Min;\n\n                if (!_cmsWrite15Fixed16Number(io, v.Gamma)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Min)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Max)) return FALSE;\n            }\n    }\n\n    else {\n\n        // Always store as a table of 256 words\n        if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaTableType)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 3)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 256)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n        for (i=0; i < 3; i++) {\n            for (j=0; j < 256; j++) {\n\n                cmsFloat32Number v = cmsEvalToneCurveFloat(Curves[i], (cmsFloat32Number) (j / 255.0));\n                cmsUInt16Number  n = _cmsQuickSaturateWord(v * 65535.0);\n\n                if (!_cmsWriteUInt16Number(io, n)) return FALSE;\n            }\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n    cmsUNUSED_PARAMETER(nItems);\n}\n\nstatic\nvoid* Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsToneCurve** OldCurves =  (cmsToneCurve**) Ptr;\n    cmsToneCurve** NewCurves;\n\n    NewCurves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (NewCurves == NULL) return NULL;\n\n    NewCurves[0] = cmsDupToneCurve(OldCurves[0]);\n    NewCurves[1] = cmsDupToneCurve(OldCurves[1]);\n    NewCurves[2] = cmsDupToneCurve(OldCurves[2]);\n\n    return (void*) NewCurves;\n\n    cmsUNUSED_PARAMETER(n);\n}\n\n\nstatic\nvoid Type_vcgt_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeToneCurveTriple((cmsToneCurve**) Ptr);\n    _cmsFree(self ->ContextID, Ptr);\n}\n\n\n// ********************************************************************************\n// Type cmsSigDictType\n// ********************************************************************************\n\n// Single column of the table can point to wchar or MLUC elements. Holds arrays of data\ntypedef struct {\n    cmsContext ContextID;\n    cmsUInt32Number *Offsets;\n    cmsUInt32Number *Sizes;\n} _cmsDICelem;\n\ntypedef struct {\n    _cmsDICelem Name, Value, DisplayName, DisplayValue;\n\n} _cmsDICarray;\n\n// Allocate an empty array element\nstatic\ncmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)\n{\n    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Offsets == NULL) return FALSE;\n\n    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Sizes == NULL) {\n\n        _cmsFree(ContextID, e -> Offsets);\n        return FALSE;\n    }\n\n    e ->ContextID = ContextID;\n    return TRUE;\n}\n\n// Free an array element\nstatic\nvoid FreeElem(_cmsDICelem* e)\n{\n    if (e ->Offsets != NULL)  _cmsFree(e -> ContextID, e -> Offsets);\n    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e -> Sizes);\n    e->Offsets = e ->Sizes = NULL;\n}\n\n// Get rid of whole array\nstatic\nvoid FreeArray( _cmsDICarray* a)\n{\n    if (a ->Name.Offsets != NULL) FreeElem(&a->Name);\n    if (a ->Value.Offsets != NULL) FreeElem(&a ->Value);\n    if (a ->DisplayName.Offsets != NULL) FreeElem(&a->DisplayName);\n    if (a ->DisplayValue.Offsets != NULL) FreeElem(&a ->DisplayValue);\n}\n\n\n// Allocate whole array\nstatic\ncmsBool AllocArray(cmsContext ContextID, _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    // Empty values\n    memset(a, 0, sizeof(_cmsDICarray));\n\n    // On depending on record size, create column arrays\n    if (!AllocElem(ContextID, &a ->Name, Count)) goto Error;\n    if (!AllocElem(ContextID, &a ->Value, Count)) goto Error;\n\n    if (Length > 16) {\n        if (!AllocElem(ContextID, &a -> DisplayName, Count)) goto Error;\n\n    }\n    if (Length > 24) {\n        if (!AllocElem(ContextID, &a ->DisplayValue, Count)) goto Error;\n    }\n    return TRUE;\n\nError:\n    FreeArray(a);\n    return FALSE;\n}\n\n// Read one element\nstatic\ncmsBool ReadOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsUInt32Number BaseOffset)\n{\n    if (!_cmsReadUInt32Number(io, &e->Offsets[i])) return FALSE;\n    if (!_cmsReadUInt32Number(io, &e ->Sizes[i])) return FALSE;\n\n    // An offset of zero has special meaning and shal be preserved\n    if (e ->Offsets[i] > 0)\n        e ->Offsets[i] += BaseOffset;\n    return TRUE;\n}\n\n\nstatic\ncmsBool ReadOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number i;\n\n    // Read column arrays\n    for (i=0; i < Count; i++) {\n\n        if (!ReadOneElem(io, &a -> Name, i, BaseOffset)) return FALSE;\n        if (!ReadOneElem(io, &a -> Value, i, BaseOffset)) return FALSE;\n\n        if (Length > 16) {\n\n            if (!ReadOneElem(io, &a ->DisplayName, i, BaseOffset)) return FALSE;\n\n        }\n\n        if (Length > 24) {\n\n            if (!ReadOneElem(io, & a -> DisplayValue, i, BaseOffset)) return FALSE;\n        }\n    }\n    return TRUE;\n}\n\n\n// Write one element\nstatic\ncmsBool WriteOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i)\n{\n    if (!_cmsWriteUInt32Number(io, e->Offsets[i])) return FALSE;\n    if (!_cmsWriteUInt32Number(io, e ->Sizes[i])) return FALSE;\n\n    return TRUE;\n}\n\nstatic\ncmsBool WriteOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneElem(io, &a -> Name, i)) return FALSE;\n        if (!WriteOneElem(io, &a -> Value, i))  return FALSE;\n\n        if (Length > 16) {\n\n            if (!WriteOneElem(io, &a -> DisplayName, i))  return FALSE;\n        }\n\n        if (Length > 24) {\n\n            if (!WriteOneElem(io, &a -> DisplayValue, i))  return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic\ncmsBool ReadOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, wchar_t ** wcstr)\n{\n\n    cmsUInt32Number nChars;\n\n      // Special case for undefined strings (see ICC Votable\n      // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n      if (e -> Offsets[i] == 0) {\n\n          *wcstr = NULL;\n          return TRUE;\n      }\n\n      if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n      nChars = e ->Sizes[i] / sizeof(cmsUInt16Number);\n\n\n      *wcstr = (wchar_t*) _cmsMallocZero(e ->ContextID, (nChars + 1) * sizeof(wchar_t));\n      if (*wcstr == NULL) return FALSE;\n\n      if (!_cmsReadWCharArray(io, nChars, *wcstr)) {\n          _cmsFree(e ->ContextID, *wcstr);\n          return FALSE;\n      }\n\n      // End of string marker\n      (*wcstr)[nChars] = 0;\n      return TRUE;\n}\n\nstatic\ncmsUInt32Number mywcslen(const wchar_t *s)\n{\n    const wchar_t *p;\n\n    p = s;\n    while (*p)\n        p++;\n\n    return (cmsUInt32Number)(p - s);\n}\n\nstatic\ncmsBool WriteOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const wchar_t * wcstr, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before = io ->Tell(io);\n    cmsUInt32Number n;\n\n    e ->Offsets[i] = Before - BaseOffset;\n\n    if (wcstr == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    n = mywcslen(wcstr);\n    if (!_cmsWriteWCharArray(io,  n, wcstr)) return FALSE;\n\n    e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}\n\nstatic\ncmsBool ReadOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsMLU** mlu)\n{\n    cmsUInt32Number nItems = 0;\n\n    // A way to get null MLUCs\n    if (e -> Offsets[i] == 0 || e ->Sizes[i] == 0) {\n\n        *mlu = NULL;\n        return TRUE;\n    }\n\n    if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n    *mlu = (cmsMLU*) Type_MLU_Read(self, io, &nItems, e ->Sizes[i]);\n    return *mlu != NULL;\n}\n\nstatic\ncmsBool WriteOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const cmsMLU* mlu, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before;\n\n     // Special case for undefined strings (see ICC Votable\n     // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n     if (mlu == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    Before = io ->Tell(io);\n    e ->Offsets[i] = Before - BaseOffset;\n\n    if (!Type_MLU_Write(self, io, (void*) mlu, 1)) return FALSE;\n\n    e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}\n\n\nstatic\nvoid *Type_Dictionary_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n   cmsHANDLE hDict;\n   cmsUInt32Number i, Count, Length;\n   cmsUInt32Number BaseOffset;\n   _cmsDICarray a;\n   wchar_t *NameWCS = NULL, *ValueWCS = NULL;\n   cmsMLU *DisplayNameMLU = NULL, *DisplayValueMLU=NULL;\n   cmsBool rc;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get name-value record count\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Get rec length\n    if (!_cmsReadUInt32Number(io, &Length)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Check for valid lengths\n    if (Length != 16 && Length != 24 && Length != 32) {\n         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown record length in dictionary '%d'\", Length);\n         return NULL;\n    }\n\n    // Creates an empty dictionary\n    hDict = cmsDictAlloc(self -> ContextID);\n    if (hDict == NULL) return NULL;\n\n    // On depending on record size, create column arrays\n    if (!AllocArray(self -> ContextID, &a, Count, Length)) goto Error;\n\n    // Read column arrays\n    if (!ReadOffsetArray(io, &a, Count, Length, BaseOffset)) goto Error;\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!ReadOneWChar(io, &a.Name, i, &NameWCS)) goto Error;\n        if (!ReadOneWChar(io, &a.Value, i, &ValueWCS)) goto Error;\n\n        if (Length > 16) {\n            if (!ReadOneMLUC(self, io, &a.DisplayName, i, &DisplayNameMLU)) goto Error;\n        }\n\n        if (Length > 24) {\n            if (!ReadOneMLUC(self, io, &a.DisplayValue, i, &DisplayValueMLU)) goto Error;\n        }\n\n        if (NameWCS == NULL || ValueWCS == NULL) {\n        \n            cmsSignalError(self->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Bad dictionary Name/Value\");        \n            rc = FALSE;\n        }\n        else {\n\n            rc = cmsDictAddEntry(hDict, NameWCS, ValueWCS, DisplayNameMLU, DisplayValueMLU);\n        }\n\n        if (NameWCS != NULL) _cmsFree(self ->ContextID, NameWCS);\n        if (ValueWCS != NULL) _cmsFree(self ->ContextID, ValueWCS);\n        if (DisplayNameMLU != NULL) cmsMLUfree(DisplayNameMLU);\n        if (DisplayValueMLU != NULL) cmsMLUfree(DisplayValueMLU);\n\n        if (!rc) goto Error;\n    }\n\n   FreeArray(&a);\n   *nItems = 1;\n   return (void*) hDict;\n\nError:\n   FreeArray(&a);\n   cmsDictFree(hDict);\n   return NULL;\n}\n\n\nstatic\ncmsBool Type_Dictionary_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsHANDLE hDict = (cmsHANDLE) Ptr;\n    const cmsDICTentry* p;\n    cmsBool AnyName, AnyValue;\n    cmsUInt32Number i, Count, Length;\n    cmsUInt32Number DirectoryPos, CurrentPos, BaseOffset;\n   _cmsDICarray a;\n\n    if (hDict == NULL) return FALSE;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Let's inspect the dictionary\n    Count = 0; AnyName = FALSE; AnyValue = FALSE;\n    for (p = cmsDictGetEntryList(hDict); p != NULL; p = cmsDictNextEntry(p)) {\n\n        if (p ->DisplayName != NULL) AnyName = TRUE;\n        if (p ->DisplayValue != NULL) AnyValue = TRUE;\n        Count++;\n    }\n\n    Length = 16;\n    if (AnyName)  Length += 8;\n    if (AnyValue) Length += 8;\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, Length)) return FALSE;\n\n    // Keep starting position of offsets table\n    DirectoryPos = io ->Tell(io);\n\n    // Allocate offsets array\n    if (!AllocArray(self ->ContextID, &a, Count, Length)) goto Error;\n\n    // Write a fake directory to be filled latter on\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    // Write each element. Keep track of the size as well.\n    p = cmsDictGetEntryList(hDict);\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneWChar(io, &a.Name, i,  p ->Name, BaseOffset)) goto Error;\n        if (!WriteOneWChar(io, &a.Value, i, p ->Value, BaseOffset)) goto Error;\n\n        if (p ->DisplayName != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayName, i, p ->DisplayName, BaseOffset)) goto Error;\n        }\n\n        if (p ->DisplayValue != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayValue, i, p ->DisplayValue, BaseOffset)) goto Error;\n        }\n\n       p = cmsDictNextEntry(p);\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    FreeArray(&a);\n    return TRUE;\n\nError:\n    FreeArray(&a);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n\n\nstatic\nvoid* Type_Dictionary_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*)  cmsDictDup((cmsHANDLE) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\nstatic\nvoid Type_Dictionary_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsDictFree((cmsHANDLE) Ptr);\n    cmsUNUSED_PARAMETER(self);\n}\n\n\n// ********************************************************************************\n// Type support main routines\n// ********************************************************************************\n\n\n// This is the list of built-in types\nstatic _cmsTagTypeLinkedList SupportedTagTypes[] = {\n\n{TYPE_HANDLER(cmsSigChromaticityType,          Chromaticity),        &SupportedTagTypes[1] },\n{TYPE_HANDLER(cmsSigColorantOrderType,         ColorantOrderType),   &SupportedTagTypes[2] },\n{TYPE_HANDLER(cmsSigS15Fixed16ArrayType,       S15Fixed16),          &SupportedTagTypes[3] },\n{TYPE_HANDLER(cmsSigU16Fixed16ArrayType,       U16Fixed16),          &SupportedTagTypes[4] },\n{TYPE_HANDLER(cmsSigTextType,                  Text),                &SupportedTagTypes[5] },\n{TYPE_HANDLER(cmsSigTextDescriptionType,       Text_Description),    &SupportedTagTypes[6] },\n{TYPE_HANDLER(cmsSigCurveType,                 Curve),               &SupportedTagTypes[7] },\n{TYPE_HANDLER(cmsSigParametricCurveType,       ParametricCurve),     &SupportedTagTypes[8] },\n{TYPE_HANDLER(cmsSigDateTimeType,              DateTime),            &SupportedTagTypes[9] },\n{TYPE_HANDLER(cmsSigLut8Type,                  LUT8),                &SupportedTagTypes[10] },\n{TYPE_HANDLER(cmsSigLut16Type,                 LUT16),               &SupportedTagTypes[11] },\n{TYPE_HANDLER(cmsSigColorantTableType,         ColorantTable),       &SupportedTagTypes[12] },\n{TYPE_HANDLER(cmsSigNamedColor2Type,           NamedColor),          &SupportedTagTypes[13] },\n{TYPE_HANDLER(cmsSigMultiLocalizedUnicodeType, MLU),                 &SupportedTagTypes[14] },\n{TYPE_HANDLER(cmsSigProfileSequenceDescType,   ProfileSequenceDesc), &SupportedTagTypes[15] },\n{TYPE_HANDLER(cmsSigSignatureType,             Signature),           &SupportedTagTypes[16] },\n{TYPE_HANDLER(cmsSigMeasurementType,           Measurement),         &SupportedTagTypes[17] },\n{TYPE_HANDLER(cmsSigDataType,                  Data),                &SupportedTagTypes[18] },\n{TYPE_HANDLER(cmsSigLutAtoBType,               LUTA2B),              &SupportedTagTypes[19] },\n{TYPE_HANDLER(cmsSigLutBtoAType,               LUTB2A),              &SupportedTagTypes[20] },\n{TYPE_HANDLER(cmsSigUcrBgType,                 UcrBg),               &SupportedTagTypes[21] },\n{TYPE_HANDLER(cmsSigCrdInfoType,               CrdInfo),             &SupportedTagTypes[22] },\n{TYPE_HANDLER(cmsSigMultiProcessElementType,   MPE),                 &SupportedTagTypes[23] },\n{TYPE_HANDLER(cmsSigScreeningType,             Screening),           &SupportedTagTypes[24] },\n{TYPE_HANDLER(cmsSigViewingConditionsType,     ViewingConditions),   &SupportedTagTypes[25] },\n{TYPE_HANDLER(cmsSigXYZType,                   XYZ),                 &SupportedTagTypes[26] },\n{TYPE_HANDLER(cmsCorbisBrokenXYZtype,          XYZ),                 &SupportedTagTypes[27] },\n{TYPE_HANDLER(cmsMonacoBrokenCurveType,        Curve),               &SupportedTagTypes[28] },\n{TYPE_HANDLER(cmsSigProfileSequenceIdType,     ProfileSequenceId),   &SupportedTagTypes[29] },\n{TYPE_HANDLER(cmsSigDictType,                  Dictionary),          &SupportedTagTypes[30] },\n{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n};\n\n\n_cmsTagTypePluginChunkType _cmsTagTypePluginChunk = { NULL };\n\n\n\n// Duplicates the zone of memory used by the plug-in in the new context\nstatic\nvoid DupTagTypeList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src, \n                    int loc)\n{\n   _cmsTagTypePluginChunkType newHead = { NULL };\n   _cmsTagTypeLinkedList*  entry;\n   _cmsTagTypeLinkedList*  Anterior = NULL;\n   _cmsTagTypePluginChunkType* head = (_cmsTagTypePluginChunkType*) src->chunks[loc];\n\n   // Walk the list copying all nodes\n   for (entry = head->TagTypes;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagTypeLinkedList *newEntry = ( _cmsTagTypeLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagTypeLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.TagTypes == NULL)\n               newHead.TagTypes = newEntry;\n   }\n\n   ctx ->chunks[loc] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagTypePluginChunkType));\n}\n\n\nvoid _cmsAllocTagTypePluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, TagTypePlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[TagTypePlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n}\n\nvoid _cmsAllocMPETypePluginChunk(struct _cmsContext_struct* ctx, \n                               const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, MPEPlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[MPEPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n\n}\n\n\n// Both kind of plug-ins share same structure\ncmsBool  _cmsRegisterTagTypePlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data, TagTypePlugin);\n}\n\ncmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data,MPEPlugin);\n}\n\n\n// Wrapper for tag types\ncmsTagTypeHandler* _cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)\n{\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(ContextID, TagTypePlugin);\n\n    return GetHandler(sig, ctx->TagTypes, SupportedTagTypes);\n}\n\n// ********************************************************************************\n// Tag support main routines\n// ********************************************************************************\n\ntypedef struct _cmsTagLinkedList_st {\n\n            cmsTagSignature Signature;\n            cmsTagDescriptor Descriptor;\n            struct _cmsTagLinkedList_st* Next;\n\n} _cmsTagLinkedList;\n\n// This is the list of built-in tags\nstatic _cmsTagLinkedList SupportedTags[] = {\n\n    { cmsSigAToB0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[1]},\n    { cmsSigAToB1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[2]},\n    { cmsSigAToB2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[3]},\n    { cmsSigBToA0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[4]},\n    { cmsSigBToA1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[5]},\n    { cmsSigBToA2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[6]},\n\n    // Allow corbis  and its broken XYZ type\n    { cmsSigRedColorantTag,         { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[7]},\n    { cmsSigGreenColorantTag,       { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[8]},\n    { cmsSigBlueColorantTag,        { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[9]},\n\n    { cmsSigRedTRCTag,              { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[10]},\n    { cmsSigGreenTRCTag,            { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[11]},\n    { cmsSigBlueTRCTag,             { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[12]},\n\n    { cmsSigCalibrationDateTimeTag, { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[13]},\n    { cmsSigCharTargetTag,          { 1, 1, { cmsSigTextType },     NULL}, &SupportedTags[14]},\n\n    { cmsSigChromaticAdaptationTag, { 9, 1, { cmsSigS15Fixed16ArrayType }, NULL}, &SupportedTags[15]},\n    { cmsSigChromaticityTag,        { 1, 1, { cmsSigChromaticityType    }, NULL}, &SupportedTags[16]},\n    { cmsSigColorantOrderTag,       { 1, 1, { cmsSigColorantOrderType   }, NULL}, &SupportedTags[17]},\n    { cmsSigColorantTableTag,       { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[18]},\n    { cmsSigColorantTableOutTag,    { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[19]},\n\n    { cmsSigCopyrightTag,           { 1, 3, { cmsSigTextType,  cmsSigMultiLocalizedUnicodeType, cmsSigTextDescriptionType}, DecideTextType}, &SupportedTags[20]},\n    { cmsSigDateTimeTag,            { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[21]},\n\n    { cmsSigDeviceMfgDescTag,       { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[22]},\n    { cmsSigDeviceModelDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[23]},\n\n    { cmsSigGamutTag,               { 1, 3, { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[24]},\n\n    { cmsSigGrayTRCTag,             { 1, 2, { cmsSigCurveType, cmsSigParametricCurveType }, DecideCurveType}, &SupportedTags[25]},\n    { cmsSigLuminanceTag,           { 1, 1, { cmsSigXYZType }, NULL}, &SupportedTags[26]},\n\n    { cmsSigMediaBlackPointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[27]},\n    { cmsSigMediaWhitePointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[28]},\n\n    { cmsSigNamedColor2Tag,         { 1, 1, { cmsSigNamedColor2Type }, NULL}, &SupportedTags[29]},\n\n    { cmsSigPreview0Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[30]},\n    { cmsSigPreview1Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[31]},\n    { cmsSigPreview2Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[32]},\n\n    { cmsSigProfileDescriptionTag,  { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[33]},\n    { cmsSigProfileSequenceDescTag, { 1, 1, { cmsSigProfileSequenceDescType }, NULL}, &SupportedTags[34]},\n    { cmsSigTechnologyTag,          { 1, 1, { cmsSigSignatureType }, NULL},  &SupportedTags[35]},\n\n    { cmsSigColorimetricIntentImageStateTag,   { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[36]},\n    { cmsSigPerceptualRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[37]},\n    { cmsSigSaturationRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[38]},\n\n    { cmsSigMeasurementTag,         { 1, 1, { cmsSigMeasurementType }, NULL}, &SupportedTags[39]},\n\n    { cmsSigPs2CRD0Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[40]},\n    { cmsSigPs2CRD1Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[41]},\n    { cmsSigPs2CRD2Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[42]},\n    { cmsSigPs2CRD3Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[43]},\n    { cmsSigPs2CSATag,              { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[44]},\n    { cmsSigPs2RenderingIntentTag,  { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[45]},\n\n    { cmsSigViewingCondDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[46]},\n\n    { cmsSigUcrBgTag,               { 1, 1, { cmsSigUcrBgType}, NULL},    &SupportedTags[47]},\n    { cmsSigCrdInfoTag,             { 1, 1, { cmsSigCrdInfoType}, NULL},  &SupportedTags[48]},\n\n    { cmsSigDToB0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[49]},\n    { cmsSigDToB1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[50]},\n    { cmsSigDToB2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[51]},\n    { cmsSigDToB3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[52]},\n    { cmsSigBToD0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[53]},\n    { cmsSigBToD1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[54]},\n    { cmsSigBToD2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[55]},\n    { cmsSigBToD3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[56]},\n\n    { cmsSigScreeningDescTag,       { 1, 1, { cmsSigTextDescriptionType },    NULL}, &SupportedTags[57]},\n    { cmsSigViewingConditionsTag,   { 1, 1, { cmsSigViewingConditionsType },  NULL}, &SupportedTags[58]},\n\n    { cmsSigScreeningTag,           { 1, 1, { cmsSigScreeningType},          NULL }, &SupportedTags[59]},\n    { cmsSigVcgtTag,                { 1, 1, { cmsSigVcgtType},               NULL }, &SupportedTags[60]},\n    { cmsSigMetaTag,                { 1, 1, { cmsSigDictType},               NULL }, &SupportedTags[61]},\n    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL }, &SupportedTags[62]},\n    { cmsSigProfileDescriptionMLTag,{ 1, 1, { cmsSigMultiLocalizedUnicodeType}, NULL}, &SupportedTags[63]},\n    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n\n\n};\n\n/*\n    Not supported                 Why\n    =======================       =========================================\n    cmsSigOutputResponseTag   ==> WARNING, POSSIBLE PATENT ON THIS SUBJECT!\n    cmsSigNamedColorTag       ==> Deprecated\n    cmsSigDataTag             ==> Ancient, unused\n    cmsSigDeviceSettingsTag   ==> Deprecated, useless\n*/\n\n\n_cmsTagPluginChunkType _cmsTagPluginChunk = { NULL };\n\n\n// Duplicates the zone of memory used by the plug-in in the new context\nstatic\nvoid DupTagList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src)\n{\n   _cmsTagPluginChunkType newHead = { NULL };\n   _cmsTagLinkedList*  entry;\n   _cmsTagLinkedList*  Anterior = NULL;\n   _cmsTagPluginChunkType* head = (_cmsTagPluginChunkType*) src->chunks[TagPlugin];\n\n   // Walk the list copying all nodes\n   for (entry = head->Tag;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagLinkedList *newEntry = ( _cmsTagLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.Tag == NULL)\n               newHead.Tag = newEntry;\n   }\n\n   ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagPluginChunkType));\n}\n\nvoid _cmsAllocTagPluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n\n        DupTagList(ctx, src);\n    }\n    else {\n        static _cmsTagPluginChunkType TagPluginChunk = { NULL };\n        ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagPluginChunk, sizeof(_cmsTagPluginChunkType));\n    }\n\n}\n\ncmsBool  _cmsRegisterTagPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    cmsPluginTag* Plugin = (cmsPluginTag*) Data;\n    _cmsTagLinkedList *pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(id, TagPlugin);\n\n    if (Data == NULL) {\n\n        TagPluginChunk->Tag = NULL;\n        return TRUE;\n    }\n\n    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Signature  = Plugin ->Signature;\n    pt ->Descriptor = Plugin ->Descriptor;\n    pt ->Next       = TagPluginChunk ->Tag;\n\n    TagPluginChunk ->Tag = pt;\n    \n    return TRUE;\n}\n\n// Return a descriptor for a given tag or NULL\ncmsTagDescriptor* _cmsGetTagDescriptor(cmsContext ContextID, cmsTagSignature sig)\n{\n    _cmsTagLinkedList* pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(ContextID, TagPlugin);\n\n    for (pt = TagPluginChunk->Tag;\n             pt != NULL;\n             pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    for (pt = SupportedTags;\n            pt != NULL;\n            pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    return NULL;\n}\n\n"], "filenames": ["src/cmstypes.c"], "buggy_code_start_loc": [1462], "buggy_code_end_loc": [1462], "fixing_code_start_loc": [1463], "fixing_code_end_loc": [1464], "type": "CWE-125", "message": "The Type_MLU_Read function in cmstypes.c in Little CMS (aka lcms2) allows remote attackers to obtain sensitive information or cause a denial of service via an image with a crafted ICC profile, which triggers an out-of-bounds heap read.", "other": {"cve": {"id": "CVE-2016-10165", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-03T19:59:00.177", "lastModified": "2018-10-30T16:27:32.030", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Type_MLU_Read function in cmstypes.c in Little CMS (aka lcms2) allows remote attackers to obtain sensitive information or cause a denial of service via an image with a crafted ICC profile, which triggers an out-of-bounds heap read."}, {"lang": "es", "value": "La funci\u00f3n Type_MLU_Read en cmstypes.c en Little CMS (tambi\u00e9n conocido como lcms2) permite a atacantes remotos obtener informaci\u00f3n sensible o provocar una denegaci\u00f3n de servicio a trav\u00e9s de una imagen con un perfil ICC manipulado, lo que desencadena una lectura de memoria din\u00e1mica fuera de l\u00edmites."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:littlecms:little_cms_color_engine:*:*:*:*:*:*:*:*", "matchCriteriaId": "136B7EFE-BB8B-42B3-BD81-4E25BEE19041"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-01/msg00174.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2079.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2658.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2017/dsa-3774", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/23/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/25/14", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/95808", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039596", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2999", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:3046", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:3264", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:3267", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:3268", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:3453", "source": "cve@mitre.org"}, {"url": "https://github.com/mm2/Little-CMS/commit/5ca71a7bc18b6897ab21d815d15e218e204581e2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20171019-0001/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3770-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3770-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mm2/Little-CMS/commit/5ca71a7bc18b6897ab21d815d15e218e204581e2"}}