{"buggy_code": ["package content\n\nimport (\n\t\"archive/tar\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tdigest \"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\n// ResolveName resolves name from descriptor\nfunc ResolveName(desc ocispec.Descriptor) (string, bool) {\n\tname, ok := desc.Annotations[ocispec.AnnotationTitle]\n\treturn name, ok\n}\n\n// tarDirectory walks the directory specified by path, and tar those files with a new\n// path prefix.\nfunc tarDirectory(root, prefix string, w io.Writer, stripTimes bool) error {\n\ttw := tar.NewWriter(w)\n\tdefer tw.Close()\n\tif err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Rename path\n\t\tname, err := filepath.Rel(root, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tname = filepath.Join(prefix, name)\n\t\tname = filepath.ToSlash(name)\n\n\t\t// Generate header\n\t\tvar link string\n\t\tmode := info.Mode()\n\t\tif mode&os.ModeSymlink != 0 {\n\t\t\tif link, err = os.Readlink(path); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\theader, err := tar.FileInfoHeader(info, link)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, path)\n\t\t}\n\t\theader.Name = name\n\t\theader.Uid = 0\n\t\theader.Gid = 0\n\t\theader.Uname = \"\"\n\t\theader.Gname = \"\"\n\n\t\tif stripTimes {\n\t\t\theader.ModTime = time.Time{}\n\t\t\theader.AccessTime = time.Time{}\n\t\t\theader.ChangeTime = time.Time{}\n\t\t}\n\n\t\t// Write file\n\t\tif err := tw.WriteHeader(header); err != nil {\n\t\t\treturn errors.Wrap(err, \"tar\")\n\t\t}\n\t\tif mode.IsRegular() {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tif _, err := io.Copy(tw, file); err != nil {\n\t\t\t\treturn errors.Wrap(err, path)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// extractTarDirectory extracts tar file to a directory specified by the `root`\n// parameter. The file name prefix is ensured to be the string specified by the\n// `prefix` parameter and is trimmed.\nfunc extractTarDirectory(root, prefix string, r io.Reader) error {\n\ttr := tar.NewReader(r)\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Name check\n\t\tname := header.Name\n\t\tpath, err := filepath.Rel(prefix, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif strings.HasPrefix(path, \"../\") {\n\t\t\treturn fmt.Errorf(\"%q does not have prefix %q\", name, prefix)\n\t\t}\n\t\tpath = filepath.Join(root, path)\n\n\t\t// Create content\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeReg:\n\t\t\terr = writeFile(path, tr, header.FileInfo().Mode())\n\t\tcase tar.TypeDir:\n\t\t\terr = os.MkdirAll(path, header.FileInfo().Mode())\n\t\tcase tar.TypeLink:\n\t\t\terr = os.Link(header.Linkname, path)\n\t\tcase tar.TypeSymlink:\n\t\t\terr = os.Symlink(header.Linkname, path)\n\t\tdefault:\n\t\t\tcontinue // Non-regular files are skipped\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Change access time and modification time if possible (error ignored)\n\t\tos.Chtimes(path, header.AccessTime, header.ModTime)\n\t}\n}\n\nfunc writeFile(path string, r io.Reader, perm os.FileMode) error {\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = io.Copy(file, r)\n\treturn err\n}\n\nfunc extractTarGzip(root, prefix, filename, checksum string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tzr, err := gzip.NewReader(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zr.Close()\n\tvar r io.Reader = zr\n\tvar verifier digest.Verifier\n\tif checksum != \"\" {\n\t\tif digest, err := digest.Parse(checksum); err == nil {\n\t\t\tverifier = digest.Verifier()\n\t\t\tr = io.TeeReader(r, verifier)\n\t\t}\n\t}\n\tif err := extractTarDirectory(root, prefix, r); err != nil {\n\t\treturn err\n\t}\n\tif verifier != nil && !verifier.Verified() {\n\t\treturn errors.New(\"content digest mismatch\")\n\t}\n\treturn nil\n}\n", "package oras\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\torascontent \"github.com/deislabs/oras/pkg/content\"\n\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/remotes\"\n\t\"github.com/containerd/containerd/remotes/docker\"\n\t\"github.com/docker/distribution/configuration\"\n\t\"github.com/docker/distribution/registry\"\n\t_ \"github.com/docker/distribution/registry/storage/driver/inmemory\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/phayes/freeport\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\nvar (\n\ttestTarball  = \"../../testdata/charts/chartmuseum-1.8.2.tgz\"\n\ttestDir      = \"../../testdata/charts/chartmuseum\"\n\ttestDirFiles = []string{\n\t\t\"Chart.yaml\",\n\t\t\"values.yaml\",\n\t\t\"README.md\",\n\t\t\"templates/_helpers.tpl\",\n\t\t\"templates/NOTES.txt\",\n\t\t\"templates/service.yaml\",\n\t\t\".helmignore\",\n\t}\n)\n\ntype ORASTestSuite struct {\n\tsuite.Suite\n\tDockerRegistryHost string\n}\n\nfunc newContext() context.Context {\n\treturn context.Background()\n}\n\nfunc newResolver() remotes.Resolver {\n\treturn docker.NewResolver(docker.ResolverOptions{})\n}\n\n// Start Docker registry\nfunc (suite *ORASTestSuite) SetupSuite() {\n\tconfig := &configuration.Configuration{}\n\tport, err := freeport.GetFreePort()\n\tif err != nil {\n\t\tsuite.Nil(err, \"no error finding free port for test registry\")\n\t}\n\tsuite.DockerRegistryHost = fmt.Sprintf(\"localhost:%d\", port)\n\tconfig.HTTP.Addr = fmt.Sprintf(\":%d\", port)\n\tconfig.HTTP.DrainTimeout = time.Duration(10) * time.Second\n\tconfig.Storage = map[string]configuration.Parameters{\"inmemory\": map[string]interface{}{}}\n\tdockerRegistry, err := registry.NewRegistry(context.Background(), config)\n\tsuite.Nil(err, \"no error finding free port for test registry\")\n\n\tgo dockerRegistry.ListenAndServe()\n}\n\n// Push files to docker registry\nfunc (suite *ORASTestSuite) Test_0_Push() {\n\tvar (\n\t\terr         error\n\t\tref         string\n\t\tdesc        ocispec.Descriptor\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.FileStore\n\t)\n\n\t_, err = Push(newContext(), nil, ref, nil, descriptors)\n\tsuite.NotNil(err, \"error pushing with empty resolver\")\n\n\t_, err = Push(newContext(), newResolver(), ref, nil, descriptors)\n\tsuite.NotNil(err, \"error pushing when context missing hostname\")\n\n\tref = fmt.Sprintf(\"%s/empty:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, nil, descriptors)\n\tsuite.Nil(err, \"no error pushing with empty descriptors\")\n\n\t// Load descriptors with test chart tgz (as single layer)\n\tstore = orascontent.NewFileStore(\"\")\n\tbasename := filepath.Base(testTarball)\n\tdesc, err = store.Add(basename, \"\", testTarball)\n\tsuite.Nil(err, \"no error loading test chart\")\n\tdescriptors = []ocispec.Descriptor{desc}\n\n\tref = fmt.Sprintf(\"%s/chart-tgz:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test chart tgz (as single layer)\")\n\n\t// Load descriptors with test chart dir (each file as layer)\n\ttestDirAbs, err := filepath.Abs(testDir)\n\tsuite.Nil(err, \"no error parsing test directory\")\n\tstore = orascontent.NewFileStore(testDirAbs)\n\tdescriptors = []ocispec.Descriptor{}\n\tvar ff = func(pathX string, infoX os.FileInfo, errX error) error {\n\t\tif !infoX.IsDir() {\n\t\t\tfilename := filepath.Join(filepath.Dir(pathX), infoX.Name())\n\t\t\tname := filepath.ToSlash(filename)\n\t\t\tdesc, err = store.Add(name, \"\", filename)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdescriptors = append(descriptors, desc)\n\t\t}\n\t\treturn nil\n\t}\n\n\tcwd, _ := os.Getwd()\n\tos.Chdir(testDir)\n\tfilepath.Walk(\".\", ff)\n\tos.Chdir(cwd)\n\n\tref = fmt.Sprintf(\"%s/chart-dir:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test chart dir (each file as layer)\")\n}\n\n// Pull files and verify descriptors\nfunc (suite *ORASTestSuite) Test_1_Pull() {\n\tvar (\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t)\n\n\t_, descriptors, err = Pull(newContext(), nil, ref, nil)\n\tsuite.NotNil(err, \"error pulling with empty resolver\")\n\tsuite.Nil(descriptors, \"descriptors nil pulling with empty resolver\")\n\n\t// Pull non-existant\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/nonexistant:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.NotNil(err, \"error pulling non-existant ref\")\n\tsuite.Nil(descriptors, \"descriptors empty with error\")\n\n\t// Pull chart-tgz\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/chart-tgz:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling chart-tgz ref\")\n\n\t// Verify the descriptors, single layer/file\n\tcontent, err := ioutil.ReadFile(testTarball)\n\tsuite.Nil(err, \"no error loading test chart\")\n\tname := filepath.Base(testTarball)\n\t_, actualContent, ok := store.GetByName(name)\n\tsuite.True(ok, \"find in memory\")\n\tsuite.Equal(content, actualContent, \".tgz content matches on pull\")\n\n\t// Pull chart-dir\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/chart-dir:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling chart-dir ref\")\n\n\t// Verify the descriptors, multiple layers/files\n\tcwd, _ := os.Getwd()\n\tos.Chdir(testDir)\n\tfor _, filename := range testDirFiles {\n\t\tcontent, err = ioutil.ReadFile(filename)\n\t\tsuite.Nil(err, fmt.Sprintf(\"no error loading %s\", filename))\n\t\t_, actualContent, ok := store.GetByName(filename)\n\t\tsuite.True(ok, \"find in memory\")\n\t\tsuite.Equal(content, actualContent, fmt.Sprintf(\"%s content matches on pull\", filename))\n\t}\n\tos.Chdir(cwd)\n}\n\n// Push and pull with customized media types\nfunc (suite *ORASTestSuite) Test_2_MediaType() {\n\tvar (\n\t\ttestData = [][]string{\n\t\t\t{\"hi.txt\", \"application/vnd.me.hi\", \"hi\"},\n\t\t\t{\"bye.txt\", \"application/vnd.me.bye\", \"bye\"},\n\t\t}\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t)\n\n\t// Push content with customized media types\n\tstore = orascontent.NewMemoryStore()\n\tdescriptors = nil\n\tfor _, data := range testData {\n\t\tdesc := store.Add(data[0], data[1], []byte(data[2]))\n\t\tdescriptors = append(descriptors, desc)\n\t}\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test data with customized media type\")\n\n\t// Pull with all media types\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(2, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[2])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n\n\t// Pull with specified media type\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithAllowedMediaType(testData[0][1]))\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(1, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData[:1] {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[2])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n\n\t// Pull with non-existing media type\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithAllowedMediaType(\"non.existing.media.type\"))\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(0, len(descriptors), \"number of contents matches on pull\")\n}\n\n// Pull with condition\nfunc (suite *ORASTestSuite) Test_3_Conditional_Pull() {\n\tvar (\n\t\ttestData = [][]string{\n\t\t\t{\"version.txt\", \"edge\"},\n\t\t\t{\"content.txt\", \"hello world\"},\n\t\t}\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t\tstop        bool\n\t)\n\n\t// Push test content\n\tstore = orascontent.NewMemoryStore()\n\tdescriptors = nil\n\tfor _, data := range testData {\n\t\tdesc := store.Add(data[0], \"\", []byte(data[1]))\n\t\tdescriptors = append(descriptors, desc)\n\t}\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test data\")\n\n\t// Pull all contents in sequence\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS)\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(2, len(descriptors), \"number of contents matches on pull\")\n\tfor i, data := range testData {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[1])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t\tname, _ := orascontent.ResolveName(descriptors[i])\n\t\tsuite.Equal(data[0], name, \"content sequence matches on pull\")\n\t}\n\n\t// Selective pull contents: stop at the very beginning\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS,\n\t\tWithPullBaseHandler(images.HandlerFunc(func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {\n\t\t\tif name, ok := orascontent.ResolveName(desc); ok && name == testData[0][0] {\n\t\t\t\treturn nil, ErrStopProcessing\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t})))\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(0, len(descriptors), \"number of contents matches on pull\")\n\n\t// Selective pull contents: stop in the middle\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\tstop = false\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS,\n\t\tWithPullBaseHandler(images.HandlerFunc(func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {\n\t\t\tif stop {\n\t\t\t\treturn nil, ErrStopProcessing\n\t\t\t}\n\t\t\tif name, ok := orascontent.ResolveName(desc); ok && name == testData[0][0] {\n\t\t\t\tstop = true\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t})))\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(1, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData[:1] {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[1])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n}\n\nfunc TestORASTestSuite(t *testing.T) {\n\tsuite.Run(t, new(ORASTestSuite))\n}\n"], "fixing_code": ["package content\n\nimport (\n\t\"archive/tar\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tdigest \"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\n// ResolveName resolves name from descriptor\nfunc ResolveName(desc ocispec.Descriptor) (string, bool) {\n\tname, ok := desc.Annotations[ocispec.AnnotationTitle]\n\treturn name, ok\n}\n\n// tarDirectory walks the directory specified by path, and tar those files with a new\n// path prefix.\nfunc tarDirectory(root, prefix string, w io.Writer, stripTimes bool) error {\n\ttw := tar.NewWriter(w)\n\tdefer tw.Close()\n\tif err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Rename path\n\t\tname, err := filepath.Rel(root, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tname = filepath.Join(prefix, name)\n\t\tname = filepath.ToSlash(name)\n\n\t\t// Generate header\n\t\tvar link string\n\t\tmode := info.Mode()\n\t\tif mode&os.ModeSymlink != 0 {\n\t\t\tif link, err = os.Readlink(path); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\theader, err := tar.FileInfoHeader(info, link)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, path)\n\t\t}\n\t\theader.Name = name\n\t\theader.Uid = 0\n\t\theader.Gid = 0\n\t\theader.Uname = \"\"\n\t\theader.Gname = \"\"\n\n\t\tif stripTimes {\n\t\t\theader.ModTime = time.Time{}\n\t\t\theader.AccessTime = time.Time{}\n\t\t\theader.ChangeTime = time.Time{}\n\t\t}\n\n\t\t// Write file\n\t\tif err := tw.WriteHeader(header); err != nil {\n\t\t\treturn errors.Wrap(err, \"tar\")\n\t\t}\n\t\tif mode.IsRegular() {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tif _, err := io.Copy(tw, file); err != nil {\n\t\t\t\treturn errors.Wrap(err, path)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// extractTarDirectory extracts tar file to a directory specified by the `root`\n// parameter. The file name prefix is ensured to be the string specified by the\n// `prefix` parameter and is trimmed.\nfunc extractTarDirectory(root, prefix string, r io.Reader) error {\n\ttr := tar.NewReader(r)\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Name check\n\t\tname := header.Name\n\t\tpath, err := ensureBasePath(root, prefix, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpath = filepath.Join(root, path)\n\n\t\t// Link check\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeLink, tar.TypeSymlink:\n\t\t\tlink := header.Linkname\n\t\t\tif !filepath.IsAbs(link) {\n\t\t\t\tlink = filepath.Join(filepath.Dir(name), link)\n\t\t\t}\n\t\t\tif _, err := ensureBasePath(root, prefix, link); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Create content\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeReg:\n\t\t\terr = writeFile(path, tr, header.FileInfo().Mode())\n\t\tcase tar.TypeDir:\n\t\t\terr = os.MkdirAll(path, header.FileInfo().Mode())\n\t\tcase tar.TypeLink:\n\t\t\terr = os.Link(header.Linkname, path)\n\t\tcase tar.TypeSymlink:\n\t\t\terr = os.Symlink(header.Linkname, path)\n\t\tdefault:\n\t\t\tcontinue // Non-regular files are skipped\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Change access time and modification time if possible (error ignored)\n\t\tos.Chtimes(path, header.AccessTime, header.ModTime)\n\t}\n}\n\n// ensureBasePath ensures the target path is in the base path,\n// returning its relative path to the base path.\nfunc ensureBasePath(root, base, target string) (string, error) {\n\tpath, err := filepath.Rel(base, target)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcleanPath := filepath.ToSlash(filepath.Clean(path))\n\tif cleanPath == \"..\" || strings.HasPrefix(cleanPath, \"../\") {\n\t\treturn \"\", fmt.Errorf(\"%q is outside of %q\", target, base)\n\t}\n\n\t// No symbolic link allowed in the relative path\n\tdir := filepath.Dir(path)\n\tfor dir != \".\" {\n\t\tif info, err := os.Lstat(filepath.Join(root, dir)); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t} else if info.Mode()&os.ModeSymlink != 0 {\n\t\t\treturn \"\", fmt.Errorf(\"no symbolic link allowed between %q and %q\", base, target)\n\t\t}\n\t\tdir = filepath.Dir(dir)\n\t}\n\n\treturn path, nil\n}\n\nfunc writeFile(path string, r io.Reader, perm os.FileMode) error {\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = io.Copy(file, r)\n\treturn err\n}\n\nfunc extractTarGzip(root, prefix, filename, checksum string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tzr, err := gzip.NewReader(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zr.Close()\n\tvar r io.Reader = zr\n\tvar verifier digest.Verifier\n\tif checksum != \"\" {\n\t\tif digest, err := digest.Parse(checksum); err == nil {\n\t\t\tverifier = digest.Verifier()\n\t\t\tr = io.TeeReader(r, verifier)\n\t\t}\n\t}\n\tif err := extractTarDirectory(root, prefix, r); err != nil {\n\t\treturn err\n\t}\n\tif verifier != nil && !verifier.Verified() {\n\t\treturn errors.New(\"content digest mismatch\")\n\t}\n\treturn nil\n}\n", "package oras\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t_ \"crypto/sha256\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\torascontent \"github.com/deislabs/oras/pkg/content\"\n\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/remotes\"\n\t\"github.com/containerd/containerd/remotes/docker\"\n\t\"github.com/docker/distribution/configuration\"\n\t\"github.com/docker/distribution/registry\"\n\t_ \"github.com/docker/distribution/registry/storage/driver/inmemory\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/phayes/freeport\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\nvar (\n\ttestTarball  = \"../../testdata/charts/chartmuseum-1.8.2.tgz\"\n\ttestDir      = \"../../testdata/charts/chartmuseum\"\n\ttestDirFiles = []string{\n\t\t\"Chart.yaml\",\n\t\t\"values.yaml\",\n\t\t\"README.md\",\n\t\t\"templates/_helpers.tpl\",\n\t\t\"templates/NOTES.txt\",\n\t\t\"templates/service.yaml\",\n\t\t\".helmignore\",\n\t}\n)\n\ntype ORASTestSuite struct {\n\tsuite.Suite\n\tDockerRegistryHost string\n}\n\nfunc newContext() context.Context {\n\treturn context.Background()\n}\n\nfunc newResolver() remotes.Resolver {\n\treturn docker.NewResolver(docker.ResolverOptions{})\n}\n\n// Start Docker registry\nfunc (suite *ORASTestSuite) SetupSuite() {\n\tconfig := &configuration.Configuration{}\n\tport, err := freeport.GetFreePort()\n\tif err != nil {\n\t\tsuite.Nil(err, \"no error finding free port for test registry\")\n\t}\n\tsuite.DockerRegistryHost = fmt.Sprintf(\"localhost:%d\", port)\n\tconfig.HTTP.Addr = fmt.Sprintf(\":%d\", port)\n\tconfig.HTTP.DrainTimeout = time.Duration(10) * time.Second\n\tconfig.Storage = map[string]configuration.Parameters{\"inmemory\": map[string]interface{}{}}\n\tdockerRegistry, err := registry.NewRegistry(context.Background(), config)\n\tsuite.Nil(err, \"no error finding free port for test registry\")\n\n\tgo dockerRegistry.ListenAndServe()\n}\n\n// Push files to docker registry\nfunc (suite *ORASTestSuite) Test_0_Push() {\n\tvar (\n\t\terr         error\n\t\tref         string\n\t\tdesc        ocispec.Descriptor\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.FileStore\n\t)\n\n\t_, err = Push(newContext(), nil, ref, nil, descriptors)\n\tsuite.NotNil(err, \"error pushing with empty resolver\")\n\n\t_, err = Push(newContext(), newResolver(), ref, nil, descriptors)\n\tsuite.NotNil(err, \"error pushing when context missing hostname\")\n\n\tref = fmt.Sprintf(\"%s/empty:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, nil, descriptors)\n\tsuite.Nil(err, \"no error pushing with empty descriptors\")\n\n\t// Load descriptors with test chart tgz (as single layer)\n\tstore = orascontent.NewFileStore(\"\")\n\tbasename := filepath.Base(testTarball)\n\tdesc, err = store.Add(basename, \"\", testTarball)\n\tsuite.Nil(err, \"no error loading test chart\")\n\tdescriptors = []ocispec.Descriptor{desc}\n\n\tref = fmt.Sprintf(\"%s/chart-tgz:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test chart tgz (as single layer)\")\n\n\t// Load descriptors with test chart dir (each file as layer)\n\ttestDirAbs, err := filepath.Abs(testDir)\n\tsuite.Nil(err, \"no error parsing test directory\")\n\tstore = orascontent.NewFileStore(testDirAbs)\n\tdescriptors = []ocispec.Descriptor{}\n\tvar ff = func(pathX string, infoX os.FileInfo, errX error) error {\n\t\tif !infoX.IsDir() {\n\t\t\tfilename := filepath.Join(filepath.Dir(pathX), infoX.Name())\n\t\t\tname := filepath.ToSlash(filename)\n\t\t\tdesc, err = store.Add(name, \"\", filename)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdescriptors = append(descriptors, desc)\n\t\t}\n\t\treturn nil\n\t}\n\n\tcwd, _ := os.Getwd()\n\tos.Chdir(testDir)\n\tfilepath.Walk(\".\", ff)\n\tos.Chdir(cwd)\n\n\tref = fmt.Sprintf(\"%s/chart-dir:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test chart dir (each file as layer)\")\n}\n\n// Pull files and verify descriptors\nfunc (suite *ORASTestSuite) Test_1_Pull() {\n\tvar (\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t)\n\n\t_, descriptors, err = Pull(newContext(), nil, ref, nil)\n\tsuite.NotNil(err, \"error pulling with empty resolver\")\n\tsuite.Nil(descriptors, \"descriptors nil pulling with empty resolver\")\n\n\t// Pull non-existant\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/nonexistant:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.NotNil(err, \"error pulling non-existant ref\")\n\tsuite.Nil(descriptors, \"descriptors empty with error\")\n\n\t// Pull chart-tgz\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/chart-tgz:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling chart-tgz ref\")\n\n\t// Verify the descriptors, single layer/file\n\tcontent, err := ioutil.ReadFile(testTarball)\n\tsuite.Nil(err, \"no error loading test chart\")\n\tname := filepath.Base(testTarball)\n\t_, actualContent, ok := store.GetByName(name)\n\tsuite.True(ok, \"find in memory\")\n\tsuite.Equal(content, actualContent, \".tgz content matches on pull\")\n\n\t// Pull chart-dir\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/chart-dir:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling chart-dir ref\")\n\n\t// Verify the descriptors, multiple layers/files\n\tcwd, _ := os.Getwd()\n\tos.Chdir(testDir)\n\tfor _, filename := range testDirFiles {\n\t\tcontent, err = ioutil.ReadFile(filename)\n\t\tsuite.Nil(err, fmt.Sprintf(\"no error loading %s\", filename))\n\t\t_, actualContent, ok := store.GetByName(filename)\n\t\tsuite.True(ok, \"find in memory\")\n\t\tsuite.Equal(content, actualContent, fmt.Sprintf(\"%s content matches on pull\", filename))\n\t}\n\tos.Chdir(cwd)\n}\n\n// Push and pull with customized media types\nfunc (suite *ORASTestSuite) Test_2_MediaType() {\n\tvar (\n\t\ttestData = [][]string{\n\t\t\t{\"hi.txt\", \"application/vnd.me.hi\", \"hi\"},\n\t\t\t{\"bye.txt\", \"application/vnd.me.bye\", \"bye\"},\n\t\t}\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t)\n\n\t// Push content with customized media types\n\tstore = orascontent.NewMemoryStore()\n\tdescriptors = nil\n\tfor _, data := range testData {\n\t\tdesc := store.Add(data[0], data[1], []byte(data[2]))\n\t\tdescriptors = append(descriptors, desc)\n\t}\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test data with customized media type\")\n\n\t// Pull with all media types\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store)\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(2, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[2])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n\n\t// Pull with specified media type\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithAllowedMediaType(testData[0][1]))\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(1, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData[:1] {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[2])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n\n\t// Pull with non-existing media type\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/media-type:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithAllowedMediaType(\"non.existing.media.type\"))\n\tsuite.Nil(err, \"no error pulling media-type ref\")\n\tsuite.Equal(0, len(descriptors), \"number of contents matches on pull\")\n}\n\n// Pull with condition\nfunc (suite *ORASTestSuite) Test_3_Conditional_Pull() {\n\tvar (\n\t\ttestData = [][]string{\n\t\t\t{\"version.txt\", \"edge\"},\n\t\t\t{\"content.txt\", \"hello world\"},\n\t\t}\n\t\terr         error\n\t\tref         string\n\t\tdescriptors []ocispec.Descriptor\n\t\tstore       *orascontent.Memorystore\n\t\tstop        bool\n\t)\n\n\t// Push test content\n\tstore = orascontent.NewMemoryStore()\n\tdescriptors = nil\n\tfor _, data := range testData {\n\t\tdesc := store.Add(data[0], \"\", []byte(data[1]))\n\t\tdescriptors = append(descriptors, desc)\n\t}\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, err = Push(newContext(), newResolver(), ref, store, descriptors)\n\tsuite.Nil(err, \"no error pushing test data\")\n\n\t// Pull all contents in sequence\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS)\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(2, len(descriptors), \"number of contents matches on pull\")\n\tfor i, data := range testData {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[1])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t\tname, _ := orascontent.ResolveName(descriptors[i])\n\t\tsuite.Equal(data[0], name, \"content sequence matches on pull\")\n\t}\n\n\t// Selective pull contents: stop at the very beginning\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS,\n\t\tWithPullBaseHandler(images.HandlerFunc(func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {\n\t\t\tif name, ok := orascontent.ResolveName(desc); ok && name == testData[0][0] {\n\t\t\t\treturn nil, ErrStopProcessing\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t})))\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(0, len(descriptors), \"number of contents matches on pull\")\n\n\t// Selective pull contents: stop in the middle\n\tstore = orascontent.NewMemoryStore()\n\tref = fmt.Sprintf(\"%s/conditional-pull:test\", suite.DockerRegistryHost)\n\tstop = false\n\t_, descriptors, err = Pull(newContext(), newResolver(), ref, store, WithPullByBFS,\n\t\tWithPullBaseHandler(images.HandlerFunc(func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {\n\t\t\tif stop {\n\t\t\t\treturn nil, ErrStopProcessing\n\t\t\t}\n\t\t\tif name, ok := orascontent.ResolveName(desc); ok && name == testData[0][0] {\n\t\t\t\tstop = true\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t})))\n\tsuite.Nil(err, \"no error pulling ref\")\n\tsuite.Equal(1, len(descriptors), \"number of contents matches on pull\")\n\tfor _, data := range testData[:1] {\n\t\t_, actualContent, ok := store.GetByName(data[0])\n\t\tsuite.True(ok, \"find in memory\")\n\t\tcontent := []byte(data[1])\n\t\tsuite.Equal(content, actualContent, \"test content matches on pull\")\n\t}\n}\n\n// Test for vulnerability GHSA-g5v4-5x39-vwhx\nfunc (suite *ORASTestSuite) Test_4_GHSA_g5v4_5x39_vwhx() {\n\tvar testVulnerability = func(headers []tar.Header, tag string, expectedError string) {\n\t\t// Step 1: build malicious tar+gzip\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tdigester := digest.Canonical.Digester()\n\t\tzw := gzip.NewWriter(io.MultiWriter(buf, digester.Hash()))\n\t\ttarDigester := digest.Canonical.Digester()\n\t\ttw := tar.NewWriter(io.MultiWriter(zw, tarDigester.Hash()))\n\t\tfor _, header := range headers {\n\t\t\terr := tw.WriteHeader(&header)\n\t\t\tsuite.Nil(err, \"error writing header\")\n\t\t}\n\t\terr := tw.Close()\n\t\tsuite.Nil(err, \"error closing tar\")\n\t\terr = zw.Close()\n\t\tsuite.Nil(err, \"error closing gzip\")\n\n\t\t// Step 2: construct malicious descriptor\n\t\tevilDesc := ocispec.Descriptor{\n\t\t\tMediaType: ocispec.MediaTypeImageLayerGzip,\n\t\t\tDigest:    digester.Digest(),\n\t\t\tSize:      int64(buf.Len()),\n\t\t\tAnnotations: map[string]string{\n\t\t\t\torascontent.AnnotationDigest: tarDigester.Digest().String(),\n\t\t\t\torascontent.AnnotationUnpack: \"true\",\n\t\t\t\tocispec.AnnotationTitle:      \"foo\",\n\t\t\t},\n\t\t}\n\n\t\t// Step 3: upload malicious artifact to registry\n\t\tmemoryStore := orascontent.NewMemoryStore()\n\t\tmemoryStore.Set(evilDesc, buf.Bytes())\n\t\tref := fmt.Sprintf(\"%s/evil:%s\", suite.DockerRegistryHost, tag)\n\t\t_, err = Push(newContext(), newResolver(), ref, memoryStore, []ocispec.Descriptor{evilDesc})\n\t\tsuite.Nil(err, \"no error pushing test data\")\n\n\t\t// Step 4: pull malicious tar with oras filestore and ensure error\n\t\ttempDir, err := ioutil.TempDir(\"\", \"oras_test\")\n\t\tif err != nil {\n\t\t\tsuite.FailNow(\"error creating temp directory\", err)\n\t\t}\n\t\tdefer os.RemoveAll(tempDir)\n\t\tstore := orascontent.NewFileStore(tempDir)\n\t\tdefer store.Close()\n\t\tref = fmt.Sprintf(\"%s/evil:%s\", suite.DockerRegistryHost, tag)\n\t\t_, _, err = Pull(newContext(), newResolver(), ref, store)\n\t\tsuite.NotNil(err, \"error expected pulling malicious tar\")\n\t\tsuite.Contains(err.Error(),\n\t\t\texpectedError,\n\t\t\t\"did not get correct error message\",\n\t\t)\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\theaders       []tar.Header\n\t\ttag           string\n\t\texpectedError string\n\t}{\n\t\t{\n\t\t\tname: \"Test symbolic link path traversal\",\n\t\t\theaders: []tar.Header{\n\t\t\t\t{\n\t\t\t\t\tTypeflag: tar.TypeDir,\n\t\t\t\t\tName:     \"foo/subdir/\",\n\t\t\t\t\tMode:     0755,\n\t\t\t\t},\n\t\t\t\t{ // Symbolic link to `foo`\n\t\t\t\t\tTypeflag: tar.TypeSymlink,\n\t\t\t\t\tName:     \"foo/subdir/parent\",\n\t\t\t\t\tLinkname: \"..\",\n\t\t\t\t\tMode:     0755,\n\t\t\t\t},\n\t\t\t\t{ // Symbolic link to `../etc/passwd`\n\t\t\t\t\tTypeflag: tar.TypeSymlink,\n\t\t\t\t\tName:     \"foo/subdir/parent/passwd\",\n\t\t\t\t\tLinkname: \"../../etc/passwd\",\n\t\t\t\t\tMode:     0644,\n\t\t\t\t},\n\t\t\t\t{ // Symbolic link to `../etc`\n\t\t\t\t\tTypeflag: tar.TypeSymlink,\n\t\t\t\t\tName:     \"foo/subdir/parent/etc\",\n\t\t\t\t\tLinkname: \"../../etc\",\n\t\t\t\t\tMode:     0644,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttag:           \"symlink_path\",\n\t\t\texpectedError: \"no symbolic link allowed\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test symbolic link pointing to outside\",\n\t\t\theaders: []tar.Header{\n\t\t\t\t{ // Symbolic link to `/etc/passwd`\n\t\t\t\t\tTypeflag: tar.TypeSymlink,\n\t\t\t\t\tName:     \"foo/passwd\",\n\t\t\t\t\tLinkname: \"../../../etc/passwd\",\n\t\t\t\t\tMode:     0644,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttag:           \"symlink\",\n\t\t\texpectedError: \"is outside of\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test hard link pointing to outside\",\n\t\t\theaders: []tar.Header{\n\t\t\t\t{ // Hard link to `/etc/passwd`\n\t\t\t\t\tTypeflag: tar.TypeLink,\n\t\t\t\t\tName:     \"foo/passwd\",\n\t\t\t\t\tLinkname: \"../../../etc/passwd\",\n\t\t\t\t\tMode:     0644,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttag:           \"hardlink\",\n\t\t\texpectedError: \"is outside of\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tsuite.T().Log(test.name)\n\t\ttestVulnerability(test.headers, test.tag, test.expectedError)\n\t}\n}\n\nfunc TestORASTestSuite(t *testing.T) {\n\tsuite.Run(t, new(ORASTestSuite))\n}\n"], "filenames": ["pkg/content/utils.go", "pkg/oras/oras_test.go"], "buggy_code_start_loc": [104, 3], "buggy_code_end_loc": [134, 315], "fixing_code_start_loc": [104, 4], "fixing_code_end_loc": [172, 445], "type": "CWE-59", "message": "ORAS is open source software which enables a way to push OCI Artifacts to OCI Conformant registries. ORAS is both a CLI for initial testing and a Go Module. In ORAS from version 0.4.0 and before version 0.9.0, there is a \"zip-slip\" vulnerability. The directory support feature allows the downloaded gzipped tarballs to be automatically extracted to the user-specified directory where the tarball can have symbolic links and hard links. A well-crafted tarball or tarballs allow malicious artifact providers linking, writing, or overwriting specific files on the host filesystem outside of the user-specified directory unexpectedly with the same permissions as the user who runs `oras pull`. Users of the affected versions are impacted if they are `oras` CLI users who runs `oras pull`, or if they are Go programs, which invoke `github.com/deislabs/oras/pkg/content.FileStore`. The problem has been fixed in version 0.9.0. For `oras` CLI users, there is no workarounds other than pulling from a trusted artifact provider. For `oras` package users, the workaround is to not use `github.com/deislabs/oras/pkg/content.FileStore`, and use other content stores instead, or pull from a trusted artifact provider.", "other": {"cve": {"id": "CVE-2021-21272", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-25T19:15:12.847", "lastModified": "2022-10-25T15:53:33.050", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ORAS is open source software which enables a way to push OCI Artifacts to OCI Conformant registries. ORAS is both a CLI for initial testing and a Go Module. In ORAS from version 0.4.0 and before version 0.9.0, there is a \"zip-slip\" vulnerability. The directory support feature allows the downloaded gzipped tarballs to be automatically extracted to the user-specified directory where the tarball can have symbolic links and hard links. A well-crafted tarball or tarballs allow malicious artifact providers linking, writing, or overwriting specific files on the host filesystem outside of the user-specified directory unexpectedly with the same permissions as the user who runs `oras pull`. Users of the affected versions are impacted if they are `oras` CLI users who runs `oras pull`, or if they are Go programs, which invoke `github.com/deislabs/oras/pkg/content.FileStore`. The problem has been fixed in version 0.9.0. For `oras` CLI users, there is no workarounds other than pulling from a trusted artifact provider. For `oras` package users, the workaround is to not use `github.com/deislabs/oras/pkg/content.FileStore`, and use other content stores instead, or pull from a trusted artifact provider."}, {"lang": "es", "value": "ORAS es un software de c\u00f3digo abierto que permite una forma de empujar artefactos OCI a registros conformes con OCI. ORAS es tanto un CLI para pruebas iniciales como un m\u00f3dulo Go. En ORAS a partir de la versi\u00f3n 0.4.0 y anterior a la versi\u00f3n 0.9.0, existe una vulnerabilidad de \"deslizamiento de zip\". La funci\u00f3n de soporte de directorios permite que los tarballs gzipped descargados se extraigan autom\u00e1ticamente al directorio especificado por el usuario, donde el tarball puede tener enlaces simb\u00f3licos y enlaces duros. Un tarball o tarballs bien elaborados permiten a los proveedores de artefactos maliciosos enlazar, escribir o sobrescribir archivos espec\u00edficos en el sistema de archivos del host fuera del directorio especificado por el usuario de forma inesperada con los mismos permisos que el usuario que ejecuta `oras pull`. Los usuarios de las versiones afectadas se ven afectados si son usuarios de `oras` CLI que ejecutan `oras pull`, o si son programas Go, que invocan `github.com/deislabs/oras/pkg/content.FileStore`. El problema ha sido corregido en la versi\u00f3n 0.9.0. Para los usuarios de la CLI de `oras`, no hay ninguna soluci\u00f3n que no sea la de extraer de un proveedor de artefactos de confianza. Para los usuarios del paquete `oras`, la soluci\u00f3n es no utilizar `github.com/deislabs/oras/pkg/content.FileStore`, y utilizar otros almacenes de contenido en su lugar, o tirar de un proveedor de artefactos de confianza"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:deislabs:oras:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.9.0", "matchCriteriaId": "93510360-3674-4A55-9BB0-5FA39B53B970"}]}]}], "references": [{"url": "https://github.com/deislabs/oras/commit/96cd90423303f1bb42bd043cb4c36085e6e91e8e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/deislabs/oras/releases/tag/v0.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/deislabs/oras/security/advisories/GHSA-g5v4-5x39-vwhx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/github.com/deislabs/oras/pkg/oras", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/deislabs/oras/commit/96cd90423303f1bb42bd043cb4c36085e6e91e8e"}}