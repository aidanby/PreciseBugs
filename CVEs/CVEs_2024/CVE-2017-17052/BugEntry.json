{"buggy_code": ["/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/user.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/rtmutex.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/seccomp.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n#include <linux/uprobes.h>\n#include <linux/aio.h>\n#include <linux/compiler.h>\n#include <linux/sysctl.h>\n#include <linux/kcov.h>\n#include <linux/livepatch.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n/*\n * Minimum number of threads to boot the kernel\n */\n#define MIN_THREADS 20\n\n/*\n * Maximum number of threads\n */\n#define MAX_THREADS FUTEX_TID_MASK\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads;\t\t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\nvoid __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic struct kmem_cache *task_struct_cachep;\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n#endif\n\nvoid __weak arch_release_thread_stack(unsigned long *stack)\n{\n}\n\n#ifndef CONFIG_ARCH_THREAD_STACK_ALLOCATOR\n\n/*\n * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a\n * kmemcache based allocator.\n */\n# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)\n\n#ifdef CONFIG_VMAP_STACK\n/*\n * vmalloc() is a bit slow, and calling vfree() enough times will force a TLB\n * flush.  Try to minimize the number of calls by caching stacks.\n */\n#define NR_CACHED_STACKS 2\nstatic DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);\n\nstatic int free_vm_stack_cache(unsigned int cpu)\n{\n\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];\n\n\t\tif (!vm_stack)\n\t\t\tcontinue;\n\n\t\tvfree(vm_stack->addr);\n\t\tcached_vm_stacks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n#ifdef CONFIG_VMAP_STACK\n\tvoid *stack;\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\ttsk->stack_vm_area = s;\n\t\treturn s->addr;\n\t}\n\n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_SIZE,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\n\t/*\n\t * We can't call find_vm_area() in interrupt context, and\n\t * free_thread_stack() can be called in interrupt context,\n\t * so cache the vm_struct.\n\t */\n\tif (stack)\n\t\ttsk->stack_vm_area = find_vm_area(stack);\n\treturn stack;\n#else\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\n\treturn page ? page_address(page) : NULL;\n#endif\n}\n\nstatic inline void free_thread_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tif (task_stack_vm_area(tsk)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\t\tif (this_cpu_cmpxchg(cached_stacks[i],\n\t\t\t\t\tNULL, tsk->stack_vm_area) != NULL)\n\t\t\t\tcontinue;\n\n\t\t\treturn;\n\t\t}\n\n\t\tvfree_atomic(tsk->stack);\n\t\treturn;\n\t}\n#endif\n\n\t__free_pages(virt_to_page(tsk->stack), THREAD_SIZE_ORDER);\n}\n# else\nstatic struct kmem_cache *thread_stack_cache;\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk,\n\t\t\t\t\t\t  int node)\n{\n\treturn kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n\nvoid thread_stack_cache_init(void)\n{\n\tthread_stack_cache = kmem_cache_create(\"thread_stack\", THREAD_SIZE,\n\t\t\t\t\t      THREAD_SIZE, 0, NULL);\n\tBUG_ON(thread_stack_cache == NULL);\n}\n# endif\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstatic void account_kernel_stack(struct task_struct *tsk, int account)\n{\n\tvoid *stack = task_stack_page(tsk);\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {\n\t\t\tmod_zone_page_state(page_zone(vm->pages[i]),\n\t\t\t\t\t    NR_KERNEL_STACK_KB,\n\t\t\t\t\t    PAGE_SIZE / 1024 * account);\n\t\t}\n\n\t\t/* All stack pages belong to the same memcg. */\n\t\tmod_memcg_page_state(vm->pages[0], MEMCG_KERNEL_STACK_KB,\n\t\t\t\t     account * (THREAD_SIZE / 1024));\n\t} else {\n\t\t/*\n\t\t * All stack pages are in the same zone and belong to the\n\t\t * same memcg.\n\t\t */\n\t\tstruct page *first_page = virt_to_page(stack);\n\n\t\tmod_zone_page_state(page_zone(first_page), NR_KERNEL_STACK_KB,\n\t\t\t\t    THREAD_SIZE / 1024 * account);\n\n\t\tmod_memcg_page_state(first_page, MEMCG_KERNEL_STACK_KB,\n\t\t\t\t     account * (THREAD_SIZE / 1024));\n\t}\n}\n\nstatic void release_task_stack(struct task_struct *tsk)\n{\n\tif (WARN_ON(tsk->state != TASK_DEAD))\n\t\treturn;  /* Better to leak the stack than to free prematurely */\n\n\taccount_kernel_stack(tsk, -1);\n\tarch_release_thread_stack(tsk->stack);\n\tfree_thread_stack(tsk);\n\ttsk->stack = NULL;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = NULL;\n#endif\n}\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}\n#endif\n\nvoid free_task(struct task_struct *tsk)\n{\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\t/*\n\t * The task is finally done with both the stack and thread_info,\n\t * so free both.\n\t */\n\trelease_task_stack(tsk);\n#else\n\t/*\n\t * If the task had a separate stack allocation, it should be gone\n\t * by now.\n\t */\n\tWARN_ON_ONCE(atomic_read(&tsk->stack_refcount) != 0);\n#endif\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tput_seccomp_filter(tsk);\n\tarch_release_task_struct(tsk);\n\tif (tsk->flags & PF_KTHREAD)\n\t\tfree_kthread_struct(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t/*\n\t * __mmdrop is not safe to call from softirq context on x86 due to\n\t * pgd_dtor so postpone it to the async context\n\t */\n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (atomic_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\nvoid __init __weak arch_task_cache_init(void) { }\n\n/*\n * set_max_threads\n */\nstatic void set_max_threads(unsigned int max_threads_suggested)\n{\n\tu64 threads;\n\n\t/*\n\t * The number of threads shall be limited such that the thread\n\t * structures may only consume a small part of the available memory.\n\t */\n\tif (fls64(totalram_pages) + fls64(PAGE_SIZE) > 64)\n\t\tthreads = MAX_THREADS;\n\telse\n\t\tthreads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,\n\t\t\t\t    (u64) THREAD_SIZE * 8UL);\n\n\tif (threads > max_threads_suggested)\n\t\tthreads = max_threads_suggested;\n\n\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);\n}\n\n#ifdef CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT\n/* Initialized by the architecture: */\nint arch_task_struct_size __read_mostly;\n#endif\n\nvoid __init fork_init(void)\n{\n\tint i;\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\t0\n#endif\n\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);\n\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep = kmem_cache_create(\"task_struct\",\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\tset_max_threads(MAX_THREADS);\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n\n\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\tinit_user_ns.ucount_max[i] = max_threads/2;\n\t}\n\n#ifdef CONFIG_VMAP_STACK\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",\n\t\t\t  NULL, free_vm_stack_cache);\n#endif\n}\n\nint __weak arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nvoid set_task_stack_end_magic(struct task_struct *tsk)\n{\n\tunsigned long *stackend;\n\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig, int node)\n{\n\tstruct task_struct *tsk;\n\tunsigned long *stack;\n\tstruct vm_struct *stack_vm_area;\n\tint err;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = tsk_fork_get_node(orig);\n\ttsk = alloc_task_struct_node(node);\n\tif (!tsk)\n\t\treturn NULL;\n\n\tstack = alloc_thread_stack_node(tsk, node);\n\tif (!stack)\n\t\tgoto free_tsk;\n\n\tstack_vm_area = task_stack_vm_area(tsk);\n\n\terr = arch_dup_task_struct(tsk, orig);\n\n\t/*\n\t * arch_dup_task_struct() clobbers the stack-related fields.  Make\n\t * sure they're properly initialized before using any stack-related\n\t * functions again.\n\t */\n\ttsk->stack = stack;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = stack_vm_area;\n#endif\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tatomic_set(&tsk->stack_refcount, 1);\n#endif\n\n\tif (err)\n\t\tgoto free_stack;\n\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * We must handle setting up seccomp filters once we're under\n\t * the sighand lock in case orig has changed between now and\n\t * then. Until then, filter must be NULL to avoid messing up\n\t * the usage counts on the error path calling free_task.\n\t */\n\ttsk->seccomp.filter = NULL;\n#endif\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tset_task_stack_end_magic(tsk);\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_canary();\n#endif\n\n\t/*\n\t * One for us, one for whoever does the \"release_task()\" (usually\n\t * parent)\n\t */\n\tatomic_set(&tsk->usage, 2);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\ttsk->task_frag.page = NULL;\n\ttsk->wake_q.next = NULL;\n\n\taccount_kernel_stack(tsk, 1);\n\n\tkcov_task_init(tsk);\n\n#ifdef CONFIG_FAULT_INJECTION\n\ttsk->fail_nth = 0;\n#endif\n\n\treturn tsk;\n\nfree_stack:\n\tfree_thread_stack(tsk);\nfree_tsk:\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic __latent_entropy int dup_mmap(struct mm_struct *mm,\n\t\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, *prev, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tLIST_HEAD(uf);\n\n\tuprobe_start_dup_mmap();\n\tif (down_write_killable(&oldmm->mmap_sem)) {\n\t\tretval = -EINTR;\n\t\tgoto fail_uprobe_end;\n\t}\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\t/* No ordering required: file already has been exposed. */\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\tretval = khugepaged_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tprev = NULL;\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tINIT_LIST_HEAD(&tmp->anon_vma_chain);\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~(VM_LOCKED | VM_LOCKONFAULT);\n\t\ttmp->vm_next = tmp->vm_prev = NULL;\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file_inode(file);\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\t\ttmp->vm_prev = prev;\n\t\tprev = tmp;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\tdup_userfaultfd_complete(&uf);\nfail_uprobe_end:\n\tuprobe_end_dup_mmap();\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tdown_write(&oldmm->mmap_sem);\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\tup_write(&oldmm->mmap_sem);\n\treturn 0;\n}\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tmm->ioctx_table = NULL;\n#endif\n}\n\nstatic void mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tmm->owner = p;\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tprintk(KERN_ALERT \"BUG: Bad rss-counter state \"\n\t\t\t\t\t  \"mm:%p idx:%d val:%ld\\n\", mm, i, x);\n\t}\n\n\tif (atomic_long_read(&mm->nr_ptes))\n\t\tpr_alert(\"BUG: non-zero nr_ptes on freeing mm: %ld\\n\",\n\t\t\t\tatomic_long_read(&mm->nr_ptes));\n\tif (mm_nr_pmds(mm))\n\t\tpr_alert(\"BUG: non-zero nr_pmds on freeing mm: %ld\\n\",\n\t\t\t\tmm_nr_pmds(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct *mm_alloc(void)\n{\n\tstruct mm_struct *mm;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\treturn NULL;\n\n\tmemset(mm, 0, sizeof(*mm));\n\treturn mm_init(mm, current, current_user_ns());\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tcheck_mm(mm);\n\tput_user_ns(mm->user_ns);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\nstatic inline void __mmput(struct mm_struct *mm)\n{\n\tVM_BUG_ON(atomic_read(&mm->mm_users));\n\n\tuprobe_clear_state(mm);\n\texit_aio(mm);\n\tksm_exit(mm);\n\tkhugepaged_exit(mm); /* must run before exit_mmap */\n\texit_mmap(mm);\n\tmm_put_huge_zero_page(mm);\n\tset_mm_exe_file(mm, NULL);\n\tif (!list_empty(&mm->mmlist)) {\n\t\tspin_lock(&mmlist_lock);\n\t\tlist_del(&mm->mmlist);\n\t\tspin_unlock(&mmlist_lock);\n\t}\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\tmmdrop(mm);\n}\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users))\n\t\t__mmput(mm);\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n#ifdef CONFIG_MMU\nstatic void mmput_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm = container_of(work, struct mm_struct, async_put_work);\n\t__mmput(mm);\n}\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n#endif\n\n/**\n * set_mm_exe_file - change a reference to the mm's executable file\n *\n * This changes mm's executable file (shown as symlink /proc/[pid]/exe).\n *\n * Main users are mmput() and sys_execve(). Callers prevent concurrent\n * invocations: in mmput() nobody alive left, in execve task is single\n * threaded. sys_prctl(PR_SET_MM_MAP/EXE_FILE) also needs to set the\n * mm->exe_file, but does so without using set_mm_exe_file() in order\n * to do avoid the need for any locks.\n */\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct file *old_exe_file;\n\n\t/*\n\t * It is safe to dereference the exe_file without RCU as\n\t * this function is only called if nobody else can access\n\t * this mm -- see comment above for justification.\n\t */\n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tif (old_exe_file)\n\t\tfput(old_exe_file);\n}\n\n/**\n * get_mm_exe_file - acquire a reference to the mm's executable file\n *\n * Returns %NULL if mm has no associated executable file.\n * User must release file via fput().\n */\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_mm_exe_file);\n\n/**\n * get_task_exe_file - acquire a reference to the task's executable file\n *\n * Returns %NULL if task's mm (if any) has no associated executable file or\n * this is a kernel thread with borrowed mm (see the comment above get_task_mm).\n * User must release file via fput().\n */\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_task_exe_file);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, mode)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n\t\t\t\tstruct completion *vfork)\n{\n\tint killed;\n\n\tfreezer_do_not_count();\n\tkilled = wait_for_completion_killable(vfork);\n\tfreezer_count();\n\n\tif (killed) {\n\t\ttask_lock(child);\n\t\tchild->vfork_done = NULL;\n\t\ttask_unlock(child);\n\t}\n\n\tput_task_struct(child);\n\treturn killed;\n}\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tsys_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstatic struct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\t/* initialize the new vmacache entries */\n\tvmacache_flush(tsk);\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\tspin_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\tspin_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\tspin_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\tstruct io_context *new_ioc;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\tioc_task_link(ioc);\n\t\ttsk->io_context = ioc;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\tnew_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);\n\t\tif (unlikely(!new_ioc))\n\t\t\treturn -ENOMEM;\n\n\t\tnew_ioc->ioprio = ioc->ioprio;\n\t\tput_io_context(new_ioc);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}\n\n#ifdef CONFIG_POSIX_TIMERS\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tunsigned long cpu_limit;\n\n\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tsig->cputime_expires.prof_exp = cpu_limit * NSEC_PER_SEC;\n\t\tsig->cputimer.running = true;\n\t}\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n#else\nstatic inline void posix_cpu_timers_init_group(struct signal_struct *sig) { }\n#endif\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\tatomic_set(&sig->sigcnt, 1);\n\n\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */\n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\n\treturn 0;\n}\n\nstatic void copy_seccomp(struct task_struct *p)\n{\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * Must be called with sighand->lock held, which is common to\n\t * all threads in the group. Holding cred_guard_mutex is not\n\t * needed because this new task is not yet running and cannot\n\t * be racing exec.\n\t */\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Ref-count the new filter user, and assign it. */\n\tget_seccomp_filter(current);\n\tp->seccomp = current->seccomp;\n\n\t/*\n\t * Explicitly enable no_new_privs here in case it got set\n\t * between the task_struct being duplicated and holding the\n\t * sighand lock. The seccomp state and nnp must be in sync.\n\t */\n\tif (task_no_new_privs(current))\n\t\ttask_set_no_new_privs(p);\n\n\t/*\n\t * If the parent gained a seccomp mode after copying thread\n\t * flags and between before we held the sighand lock, we have\n\t * to manually enable the seccomp thread flag here.\n\t */\n\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)\n\t\tset_tsk_thread_flag(p, TIF_SECCOMP);\n#endif\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT;\n\tp->pi_waiters_leftmost = NULL;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_POSIX_TIMERS\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = 0;\n\ttsk->cputime_expires.virt_exp = 0;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n#else\nstatic inline void posix_cpu_timers_init(struct task_struct *tsk) { }\n#endif\n\nstatic inline void\ninit_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)\n{\n\t task->pids[type].pid = pid;\n}\n\nstatic inline void rcu_copy_process(struct task_struct *p)\n{\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_read_unlock_special.s = 0;\n\tp->rcu_blocked_node = NULL;\n\tINIT_LIST_HEAD(&p->rcu_node_entry);\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n#ifdef CONFIG_TASKS_RCU\n\tp->rcu_tasks_holdout = false;\n\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);\n\tp->rcu_tasks_idle_cpu = -1;\n#endif /* #ifdef CONFIG_TASKS_RCU */\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic __latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tunsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tunsigned long tls,\n\t\t\t\t\tint node)\n{\n\tint retval;\n\tstruct task_struct *p;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) !=\n\t\t\t\tcurrent->nsproxy->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->start_time = ktime_get_ns();\n\tp->real_start_time = ktime_get_boot_ns();\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_init(&p->mems_allowed_seq);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n\tp->hardirqs_enabled = 0;\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->exit_signal = -1;\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = (clone_flags & CSIGNAL);\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\tcgroup_threadgroup_change_begin(current);\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted the the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p);\n\tif (retval)\n\t\tgoto bad_fork_free_pid;\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n\t*/\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\tif (unlikely(!(ns_of_pid(pid)->nr_hashed & PIDNS_HASH_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\tatomic_inc(&current->signal->sigcnt);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\tcgroup_threadgroup_change_end(current);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p);\nbad_fork_free_pid:\n\tcgroup_threadgroup_change_end(current);\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nstatic inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); /* not really needed */\n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\ttask = copy_process(CLONE_VM, 0, 0, NULL, &init_struct_pid, 0, 0,\n\t\t\t    cpu_to_node(cpu));\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong _do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr,\n\t      unsigned long tls)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if ((clone_flags & CSIGNAL) != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(clone_flags, stack_start, stack_size,\n\t\t\t child_tidptr, NULL, trace, tls, NUMA_NO_NODE);\n\tadd_latent_entropy();\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\t\tstruct pid *pid;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tpid = get_task_pid(p, PIDTYPE_PID);\n\t\tnr = pid_vnr(pid);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t\tget_task_struct(p);\n\t\t}\n\n\t\twake_up_new_task(p);\n\n\t\t/* forking complete and child started to run, tell ptracer */\n\t\tif (unlikely(trace))\n\t\t\tptrace_event_pid(trace, pid);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);\n\t\t}\n\n\t\tput_pid(pid);\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef CONFIG_HAVE_COPY_THREAD_TLS\n/* For compatibility with architectures that call do_fork directly rather than\n * using the syscall entry points below. */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\treturn _do_fork(clone_flags, stack_start, stack_size,\n\t\t\tparent_tidptr, child_tidptr, 0);\n}\n#endif\n\n/*\n * Create a kernel thread.\n */\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}\n\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\treturn _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);\n#else\n\t/* can not support in nommu mode */\n\treturn -EINVAL;\n#endif\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_VFORK\nSYSCALL_DEFINE0(vfork)\n{\n\treturn _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0,\n\t\t\t0, NULL, NULL, 0);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t unsigned long, tls,\n\t\t int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\tint, stack_size,\n\t\tint __user *, parent_tidptr,\n\t\tint __user *, child_tidptr,\n\t\tunsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\treturn _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n}\n#endif\n\nvoid walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)\n{\n\tstruct task_struct *leader, *parent, *child;\n\tint res;\n\n\tread_lock(&tasklist_lock);\n\tleader = top = top->group_leader;\ndown:\n\tfor_each_thread(leader, parent) {\n\t\tlist_for_each_entry(child, &parent->children, sibling) {\n\t\t\tres = visitor(child, data);\n\t\t\tif (res) {\n\t\t\t\tif (res < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tleader = child;\n\t\t\t\tgoto down;\n\t\t\t}\nup:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (leader != top) {\n\t\tchild = leader;\n\t\tparent = child->real_parent;\n\t\tleader = parent->group_leader;\n\t\tgoto up;\n\t}\nout:\n\tread_unlock(&tasklist_lock);\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|\n\t\t\tSLAB_NOTRACK|SLAB_ACCOUNT, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\t/*\n\t * FIXME! The \"sizeof(struct mm_struct)\" currently includes the\n\t * whole struct cpumask for the OFFSTACK case. We could change\n\t * this to *only* allocate as much of it as required by the\n\t * maximum number of CPU's we can ever have.  The cpumask_allocation\n\t * is at the end of the structure, exactly for that reason.\n\t */\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);\n\tmmap_init();\n\tnsproxy_cache_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call.\n */\nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|\n\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP))\n\t\treturn -EINVAL;\n\t/*\n\t * Not implemented, but pretend it works if there is nothing\n\t * to unshare.  Note that unsharing the address space or the\n\t * signal handlers also need to unshare the signal queues (aka\n\t * CLONE_THREAD).\n\t */\n\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (!thread_group_empty(current))\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (atomic_read(&current->sighand->count) > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & CLONE_VM) {\n\t\tif (!current_is_single_threaded())\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread group\n\t * and unshare the filesystem root and working directories.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (unshare_flags & CLONE_VM)\n\t\tunshare_flags |= CLONE_SIGHAND;\n\t/*\n\t * If unsharing a signal handlers, must also unshare the signal queues.\n\t */\n\tif (unshare_flags & CLONE_SIGHAND)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (unshare_flags & CLONE_NEWNS)\n\t\tunshare_flags |= CLONE_FS;\n\n\terr = check_unshare_flags(unshare_flags);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\terr = unshare_fs(unshare_flags, &new_fs);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\terr = unshare_fd(unshare_flags, &new_fd);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fs;\n\terr = unshare_userns(unshare_flags, &new_cred);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fd;\n\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\t\t\t new_cred, new_fs);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_cred;\n\n\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\t\tif (unshare_flags & CLONE_NEWIPC) {\n\t\t\t/* Orphan segments in old ns (see sem above). */\n\t\t\texit_shm(current);\n\t\t\tshm_init_task(current);\n\t\t}\n\n\t\tif (new_nsproxy)\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tspin_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\n\t\tif (new_cred) {\n\t\t\t/* Install the new user namespace */\n\t\t\tcommit_creds(new_cred);\n\t\t\tnew_cred = NULL;\n\t\t}\n\t}\n\n\tperf_event_namespaces(current);\n\nbad_unshare_cleanup_cred:\n\tif (new_cred)\n\t\tput_cred(new_cred);\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n\nint sysctl_max_threads(struct ctl_table *table, int write,\n\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint ret;\n\tint threads = max_threads;\n\tint min = MIN_THREADS;\n\tint max = MAX_THREADS;\n\n\tt = *table;\n\tt.data = &threads;\n\tt.extra1 = &min;\n\tt.extra2 = &max;\n\n\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tset_max_threads(threads);\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/user.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/rtmutex.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/seccomp.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n#include <linux/uprobes.h>\n#include <linux/aio.h>\n#include <linux/compiler.h>\n#include <linux/sysctl.h>\n#include <linux/kcov.h>\n#include <linux/livepatch.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n/*\n * Minimum number of threads to boot the kernel\n */\n#define MIN_THREADS 20\n\n/*\n * Maximum number of threads\n */\n#define MAX_THREADS FUTEX_TID_MASK\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads;\t\t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\nvoid __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic struct kmem_cache *task_struct_cachep;\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n#endif\n\nvoid __weak arch_release_thread_stack(unsigned long *stack)\n{\n}\n\n#ifndef CONFIG_ARCH_THREAD_STACK_ALLOCATOR\n\n/*\n * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a\n * kmemcache based allocator.\n */\n# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)\n\n#ifdef CONFIG_VMAP_STACK\n/*\n * vmalloc() is a bit slow, and calling vfree() enough times will force a TLB\n * flush.  Try to minimize the number of calls by caching stacks.\n */\n#define NR_CACHED_STACKS 2\nstatic DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);\n\nstatic int free_vm_stack_cache(unsigned int cpu)\n{\n\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];\n\n\t\tif (!vm_stack)\n\t\t\tcontinue;\n\n\t\tvfree(vm_stack->addr);\n\t\tcached_vm_stacks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n#ifdef CONFIG_VMAP_STACK\n\tvoid *stack;\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\ttsk->stack_vm_area = s;\n\t\treturn s->addr;\n\t}\n\n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_SIZE,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\n\t/*\n\t * We can't call find_vm_area() in interrupt context, and\n\t * free_thread_stack() can be called in interrupt context,\n\t * so cache the vm_struct.\n\t */\n\tif (stack)\n\t\ttsk->stack_vm_area = find_vm_area(stack);\n\treturn stack;\n#else\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\n\treturn page ? page_address(page) : NULL;\n#endif\n}\n\nstatic inline void free_thread_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tif (task_stack_vm_area(tsk)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\t\tif (this_cpu_cmpxchg(cached_stacks[i],\n\t\t\t\t\tNULL, tsk->stack_vm_area) != NULL)\n\t\t\t\tcontinue;\n\n\t\t\treturn;\n\t\t}\n\n\t\tvfree_atomic(tsk->stack);\n\t\treturn;\n\t}\n#endif\n\n\t__free_pages(virt_to_page(tsk->stack), THREAD_SIZE_ORDER);\n}\n# else\nstatic struct kmem_cache *thread_stack_cache;\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk,\n\t\t\t\t\t\t  int node)\n{\n\treturn kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n\nvoid thread_stack_cache_init(void)\n{\n\tthread_stack_cache = kmem_cache_create(\"thread_stack\", THREAD_SIZE,\n\t\t\t\t\t      THREAD_SIZE, 0, NULL);\n\tBUG_ON(thread_stack_cache == NULL);\n}\n# endif\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstatic void account_kernel_stack(struct task_struct *tsk, int account)\n{\n\tvoid *stack = task_stack_page(tsk);\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {\n\t\t\tmod_zone_page_state(page_zone(vm->pages[i]),\n\t\t\t\t\t    NR_KERNEL_STACK_KB,\n\t\t\t\t\t    PAGE_SIZE / 1024 * account);\n\t\t}\n\n\t\t/* All stack pages belong to the same memcg. */\n\t\tmod_memcg_page_state(vm->pages[0], MEMCG_KERNEL_STACK_KB,\n\t\t\t\t     account * (THREAD_SIZE / 1024));\n\t} else {\n\t\t/*\n\t\t * All stack pages are in the same zone and belong to the\n\t\t * same memcg.\n\t\t */\n\t\tstruct page *first_page = virt_to_page(stack);\n\n\t\tmod_zone_page_state(page_zone(first_page), NR_KERNEL_STACK_KB,\n\t\t\t\t    THREAD_SIZE / 1024 * account);\n\n\t\tmod_memcg_page_state(first_page, MEMCG_KERNEL_STACK_KB,\n\t\t\t\t     account * (THREAD_SIZE / 1024));\n\t}\n}\n\nstatic void release_task_stack(struct task_struct *tsk)\n{\n\tif (WARN_ON(tsk->state != TASK_DEAD))\n\t\treturn;  /* Better to leak the stack than to free prematurely */\n\n\taccount_kernel_stack(tsk, -1);\n\tarch_release_thread_stack(tsk->stack);\n\tfree_thread_stack(tsk);\n\ttsk->stack = NULL;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = NULL;\n#endif\n}\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}\n#endif\n\nvoid free_task(struct task_struct *tsk)\n{\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\t/*\n\t * The task is finally done with both the stack and thread_info,\n\t * so free both.\n\t */\n\trelease_task_stack(tsk);\n#else\n\t/*\n\t * If the task had a separate stack allocation, it should be gone\n\t * by now.\n\t */\n\tWARN_ON_ONCE(atomic_read(&tsk->stack_refcount) != 0);\n#endif\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tput_seccomp_filter(tsk);\n\tarch_release_task_struct(tsk);\n\tif (tsk->flags & PF_KTHREAD)\n\t\tfree_kthread_struct(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t/*\n\t * __mmdrop is not safe to call from softirq context on x86 due to\n\t * pgd_dtor so postpone it to the async context\n\t */\n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (atomic_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\nvoid __init __weak arch_task_cache_init(void) { }\n\n/*\n * set_max_threads\n */\nstatic void set_max_threads(unsigned int max_threads_suggested)\n{\n\tu64 threads;\n\n\t/*\n\t * The number of threads shall be limited such that the thread\n\t * structures may only consume a small part of the available memory.\n\t */\n\tif (fls64(totalram_pages) + fls64(PAGE_SIZE) > 64)\n\t\tthreads = MAX_THREADS;\n\telse\n\t\tthreads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,\n\t\t\t\t    (u64) THREAD_SIZE * 8UL);\n\n\tif (threads > max_threads_suggested)\n\t\tthreads = max_threads_suggested;\n\n\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);\n}\n\n#ifdef CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT\n/* Initialized by the architecture: */\nint arch_task_struct_size __read_mostly;\n#endif\n\nvoid __init fork_init(void)\n{\n\tint i;\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\t0\n#endif\n\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);\n\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep = kmem_cache_create(\"task_struct\",\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\tset_max_threads(MAX_THREADS);\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n\n\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\tinit_user_ns.ucount_max[i] = max_threads/2;\n\t}\n\n#ifdef CONFIG_VMAP_STACK\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",\n\t\t\t  NULL, free_vm_stack_cache);\n#endif\n}\n\nint __weak arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nvoid set_task_stack_end_magic(struct task_struct *tsk)\n{\n\tunsigned long *stackend;\n\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig, int node)\n{\n\tstruct task_struct *tsk;\n\tunsigned long *stack;\n\tstruct vm_struct *stack_vm_area;\n\tint err;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = tsk_fork_get_node(orig);\n\ttsk = alloc_task_struct_node(node);\n\tif (!tsk)\n\t\treturn NULL;\n\n\tstack = alloc_thread_stack_node(tsk, node);\n\tif (!stack)\n\t\tgoto free_tsk;\n\n\tstack_vm_area = task_stack_vm_area(tsk);\n\n\terr = arch_dup_task_struct(tsk, orig);\n\n\t/*\n\t * arch_dup_task_struct() clobbers the stack-related fields.  Make\n\t * sure they're properly initialized before using any stack-related\n\t * functions again.\n\t */\n\ttsk->stack = stack;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = stack_vm_area;\n#endif\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tatomic_set(&tsk->stack_refcount, 1);\n#endif\n\n\tif (err)\n\t\tgoto free_stack;\n\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * We must handle setting up seccomp filters once we're under\n\t * the sighand lock in case orig has changed between now and\n\t * then. Until then, filter must be NULL to avoid messing up\n\t * the usage counts on the error path calling free_task.\n\t */\n\ttsk->seccomp.filter = NULL;\n#endif\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tset_task_stack_end_magic(tsk);\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_canary();\n#endif\n\n\t/*\n\t * One for us, one for whoever does the \"release_task()\" (usually\n\t * parent)\n\t */\n\tatomic_set(&tsk->usage, 2);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\ttsk->task_frag.page = NULL;\n\ttsk->wake_q.next = NULL;\n\n\taccount_kernel_stack(tsk, 1);\n\n\tkcov_task_init(tsk);\n\n#ifdef CONFIG_FAULT_INJECTION\n\ttsk->fail_nth = 0;\n#endif\n\n\treturn tsk;\n\nfree_stack:\n\tfree_thread_stack(tsk);\nfree_tsk:\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic __latent_entropy int dup_mmap(struct mm_struct *mm,\n\t\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, *prev, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tLIST_HEAD(uf);\n\n\tuprobe_start_dup_mmap();\n\tif (down_write_killable(&oldmm->mmap_sem)) {\n\t\tretval = -EINTR;\n\t\tgoto fail_uprobe_end;\n\t}\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\t/* No ordering required: file already has been exposed. */\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\tretval = khugepaged_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tprev = NULL;\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tINIT_LIST_HEAD(&tmp->anon_vma_chain);\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~(VM_LOCKED | VM_LOCKONFAULT);\n\t\ttmp->vm_next = tmp->vm_prev = NULL;\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file_inode(file);\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\t\ttmp->vm_prev = prev;\n\t\tprev = tmp;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\tdup_userfaultfd_complete(&uf);\nfail_uprobe_end:\n\tuprobe_end_dup_mmap();\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tdown_write(&oldmm->mmap_sem);\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\tup_write(&oldmm->mmap_sem);\n\treturn 0;\n}\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tmm->ioctx_table = NULL;\n#endif\n}\n\nstatic void mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tmm->owner = p;\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tprintk(KERN_ALERT \"BUG: Bad rss-counter state \"\n\t\t\t\t\t  \"mm:%p idx:%d val:%ld\\n\", mm, i, x);\n\t}\n\n\tif (atomic_long_read(&mm->nr_ptes))\n\t\tpr_alert(\"BUG: non-zero nr_ptes on freeing mm: %ld\\n\",\n\t\t\t\tatomic_long_read(&mm->nr_ptes));\n\tif (mm_nr_pmds(mm))\n\t\tpr_alert(\"BUG: non-zero nr_pmds on freeing mm: %ld\\n\",\n\t\t\t\tmm_nr_pmds(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct *mm_alloc(void)\n{\n\tstruct mm_struct *mm;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\treturn NULL;\n\n\tmemset(mm, 0, sizeof(*mm));\n\treturn mm_init(mm, current, current_user_ns());\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tcheck_mm(mm);\n\tput_user_ns(mm->user_ns);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\nstatic inline void __mmput(struct mm_struct *mm)\n{\n\tVM_BUG_ON(atomic_read(&mm->mm_users));\n\n\tuprobe_clear_state(mm);\n\texit_aio(mm);\n\tksm_exit(mm);\n\tkhugepaged_exit(mm); /* must run before exit_mmap */\n\texit_mmap(mm);\n\tmm_put_huge_zero_page(mm);\n\tset_mm_exe_file(mm, NULL);\n\tif (!list_empty(&mm->mmlist)) {\n\t\tspin_lock(&mmlist_lock);\n\t\tlist_del(&mm->mmlist);\n\t\tspin_unlock(&mmlist_lock);\n\t}\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\tmmdrop(mm);\n}\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users))\n\t\t__mmput(mm);\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n#ifdef CONFIG_MMU\nstatic void mmput_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm = container_of(work, struct mm_struct, async_put_work);\n\t__mmput(mm);\n}\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n#endif\n\n/**\n * set_mm_exe_file - change a reference to the mm's executable file\n *\n * This changes mm's executable file (shown as symlink /proc/[pid]/exe).\n *\n * Main users are mmput() and sys_execve(). Callers prevent concurrent\n * invocations: in mmput() nobody alive left, in execve task is single\n * threaded. sys_prctl(PR_SET_MM_MAP/EXE_FILE) also needs to set the\n * mm->exe_file, but does so without using set_mm_exe_file() in order\n * to do avoid the need for any locks.\n */\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct file *old_exe_file;\n\n\t/*\n\t * It is safe to dereference the exe_file without RCU as\n\t * this function is only called if nobody else can access\n\t * this mm -- see comment above for justification.\n\t */\n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tif (old_exe_file)\n\t\tfput(old_exe_file);\n}\n\n/**\n * get_mm_exe_file - acquire a reference to the mm's executable file\n *\n * Returns %NULL if mm has no associated executable file.\n * User must release file via fput().\n */\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_mm_exe_file);\n\n/**\n * get_task_exe_file - acquire a reference to the task's executable file\n *\n * Returns %NULL if task's mm (if any) has no associated executable file or\n * this is a kernel thread with borrowed mm (see the comment above get_task_mm).\n * User must release file via fput().\n */\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_task_exe_file);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, mode)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n\t\t\t\tstruct completion *vfork)\n{\n\tint killed;\n\n\tfreezer_do_not_count();\n\tkilled = wait_for_completion_killable(vfork);\n\tfreezer_count();\n\n\tif (killed) {\n\t\ttask_lock(child);\n\t\tchild->vfork_done = NULL;\n\t\ttask_unlock(child);\n\t}\n\n\tput_task_struct(child);\n\treturn killed;\n}\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tsys_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstatic struct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\t/* initialize the new vmacache entries */\n\tvmacache_flush(tsk);\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\tspin_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\tspin_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\tspin_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\tstruct io_context *new_ioc;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\tioc_task_link(ioc);\n\t\ttsk->io_context = ioc;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\tnew_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);\n\t\tif (unlikely(!new_ioc))\n\t\t\treturn -ENOMEM;\n\n\t\tnew_ioc->ioprio = ioc->ioprio;\n\t\tput_io_context(new_ioc);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}\n\n#ifdef CONFIG_POSIX_TIMERS\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tunsigned long cpu_limit;\n\n\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tsig->cputime_expires.prof_exp = cpu_limit * NSEC_PER_SEC;\n\t\tsig->cputimer.running = true;\n\t}\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n#else\nstatic inline void posix_cpu_timers_init_group(struct signal_struct *sig) { }\n#endif\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\tatomic_set(&sig->sigcnt, 1);\n\n\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */\n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\n\treturn 0;\n}\n\nstatic void copy_seccomp(struct task_struct *p)\n{\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * Must be called with sighand->lock held, which is common to\n\t * all threads in the group. Holding cred_guard_mutex is not\n\t * needed because this new task is not yet running and cannot\n\t * be racing exec.\n\t */\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Ref-count the new filter user, and assign it. */\n\tget_seccomp_filter(current);\n\tp->seccomp = current->seccomp;\n\n\t/*\n\t * Explicitly enable no_new_privs here in case it got set\n\t * between the task_struct being duplicated and holding the\n\t * sighand lock. The seccomp state and nnp must be in sync.\n\t */\n\tif (task_no_new_privs(current))\n\t\ttask_set_no_new_privs(p);\n\n\t/*\n\t * If the parent gained a seccomp mode after copying thread\n\t * flags and between before we held the sighand lock, we have\n\t * to manually enable the seccomp thread flag here.\n\t */\n\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)\n\t\tset_tsk_thread_flag(p, TIF_SECCOMP);\n#endif\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT;\n\tp->pi_waiters_leftmost = NULL;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_POSIX_TIMERS\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = 0;\n\ttsk->cputime_expires.virt_exp = 0;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n#else\nstatic inline void posix_cpu_timers_init(struct task_struct *tsk) { }\n#endif\n\nstatic inline void\ninit_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)\n{\n\t task->pids[type].pid = pid;\n}\n\nstatic inline void rcu_copy_process(struct task_struct *p)\n{\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_read_unlock_special.s = 0;\n\tp->rcu_blocked_node = NULL;\n\tINIT_LIST_HEAD(&p->rcu_node_entry);\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n#ifdef CONFIG_TASKS_RCU\n\tp->rcu_tasks_holdout = false;\n\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);\n\tp->rcu_tasks_idle_cpu = -1;\n#endif /* #ifdef CONFIG_TASKS_RCU */\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic __latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tunsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tunsigned long tls,\n\t\t\t\t\tint node)\n{\n\tint retval;\n\tstruct task_struct *p;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) !=\n\t\t\t\tcurrent->nsproxy->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->start_time = ktime_get_ns();\n\tp->real_start_time = ktime_get_boot_ns();\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_init(&p->mems_allowed_seq);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n\tp->hardirqs_enabled = 0;\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->exit_signal = -1;\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = (clone_flags & CSIGNAL);\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\tcgroup_threadgroup_change_begin(current);\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted the the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p);\n\tif (retval)\n\t\tgoto bad_fork_free_pid;\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n\t*/\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\tif (unlikely(!(ns_of_pid(pid)->nr_hashed & PIDNS_HASH_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\tatomic_inc(&current->signal->sigcnt);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\tcgroup_threadgroup_change_end(current);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p);\nbad_fork_free_pid:\n\tcgroup_threadgroup_change_end(current);\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nstatic inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); /* not really needed */\n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\ttask = copy_process(CLONE_VM, 0, 0, NULL, &init_struct_pid, 0, 0,\n\t\t\t    cpu_to_node(cpu));\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong _do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr,\n\t      unsigned long tls)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if ((clone_flags & CSIGNAL) != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(clone_flags, stack_start, stack_size,\n\t\t\t child_tidptr, NULL, trace, tls, NUMA_NO_NODE);\n\tadd_latent_entropy();\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\t\tstruct pid *pid;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tpid = get_task_pid(p, PIDTYPE_PID);\n\t\tnr = pid_vnr(pid);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t\tget_task_struct(p);\n\t\t}\n\n\t\twake_up_new_task(p);\n\n\t\t/* forking complete and child started to run, tell ptracer */\n\t\tif (unlikely(trace))\n\t\t\tptrace_event_pid(trace, pid);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);\n\t\t}\n\n\t\tput_pid(pid);\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef CONFIG_HAVE_COPY_THREAD_TLS\n/* For compatibility with architectures that call do_fork directly rather than\n * using the syscall entry points below. */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\treturn _do_fork(clone_flags, stack_start, stack_size,\n\t\t\tparent_tidptr, child_tidptr, 0);\n}\n#endif\n\n/*\n * Create a kernel thread.\n */\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}\n\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\treturn _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);\n#else\n\t/* can not support in nommu mode */\n\treturn -EINVAL;\n#endif\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_VFORK\nSYSCALL_DEFINE0(vfork)\n{\n\treturn _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0,\n\t\t\t0, NULL, NULL, 0);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t unsigned long, tls,\n\t\t int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\tint, stack_size,\n\t\tint __user *, parent_tidptr,\n\t\tint __user *, child_tidptr,\n\t\tunsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\treturn _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n}\n#endif\n\nvoid walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)\n{\n\tstruct task_struct *leader, *parent, *child;\n\tint res;\n\n\tread_lock(&tasklist_lock);\n\tleader = top = top->group_leader;\ndown:\n\tfor_each_thread(leader, parent) {\n\t\tlist_for_each_entry(child, &parent->children, sibling) {\n\t\t\tres = visitor(child, data);\n\t\t\tif (res) {\n\t\t\t\tif (res < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tleader = child;\n\t\t\t\tgoto down;\n\t\t\t}\nup:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (leader != top) {\n\t\tchild = leader;\n\t\tparent = child->real_parent;\n\t\tleader = parent->group_leader;\n\t\tgoto up;\n\t}\nout:\n\tread_unlock(&tasklist_lock);\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|\n\t\t\tSLAB_NOTRACK|SLAB_ACCOUNT, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\t/*\n\t * FIXME! The \"sizeof(struct mm_struct)\" currently includes the\n\t * whole struct cpumask for the OFFSTACK case. We could change\n\t * this to *only* allocate as much of it as required by the\n\t * maximum number of CPU's we can ever have.  The cpumask_allocation\n\t * is at the end of the structure, exactly for that reason.\n\t */\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);\n\tmmap_init();\n\tnsproxy_cache_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call.\n */\nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|\n\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP))\n\t\treturn -EINVAL;\n\t/*\n\t * Not implemented, but pretend it works if there is nothing\n\t * to unshare.  Note that unsharing the address space or the\n\t * signal handlers also need to unshare the signal queues (aka\n\t * CLONE_THREAD).\n\t */\n\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (!thread_group_empty(current))\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (atomic_read(&current->sighand->count) > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & CLONE_VM) {\n\t\tif (!current_is_single_threaded())\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread group\n\t * and unshare the filesystem root and working directories.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (unshare_flags & CLONE_VM)\n\t\tunshare_flags |= CLONE_SIGHAND;\n\t/*\n\t * If unsharing a signal handlers, must also unshare the signal queues.\n\t */\n\tif (unshare_flags & CLONE_SIGHAND)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (unshare_flags & CLONE_NEWNS)\n\t\tunshare_flags |= CLONE_FS;\n\n\terr = check_unshare_flags(unshare_flags);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\terr = unshare_fs(unshare_flags, &new_fs);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\terr = unshare_fd(unshare_flags, &new_fd);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fs;\n\terr = unshare_userns(unshare_flags, &new_cred);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fd;\n\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\t\t\t new_cred, new_fs);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_cred;\n\n\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\t\tif (unshare_flags & CLONE_NEWIPC) {\n\t\t\t/* Orphan segments in old ns (see sem above). */\n\t\t\texit_shm(current);\n\t\t\tshm_init_task(current);\n\t\t}\n\n\t\tif (new_nsproxy)\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tspin_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\n\t\tif (new_cred) {\n\t\t\t/* Install the new user namespace */\n\t\t\tcommit_creds(new_cred);\n\t\t\tnew_cred = NULL;\n\t\t}\n\t}\n\n\tperf_event_namespaces(current);\n\nbad_unshare_cleanup_cred:\n\tif (new_cred)\n\t\tput_cred(new_cred);\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n\nint sysctl_max_threads(struct ctl_table *table, int write,\n\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint ret;\n\tint threads = max_threads;\n\tint min = MIN_THREADS;\n\tint max = MAX_THREADS;\n\n\tt = *table;\n\tt.data = &threads;\n\tt.extra1 = &min;\n\tt.extra2 = &max;\n\n\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tset_max_threads(threads);\n\n\treturn 0;\n}\n"], "filenames": ["kernel/fork.c"], "buggy_code_start_loc": [808], "buggy_code_end_loc": [808], "fixing_code_start_loc": [809], "fixing_code_end_loc": [810], "type": "CWE-416", "message": "The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program.", "other": {"cve": {"id": "CVE-2017-17052", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-29T03:29:00.267", "lastModified": "2023-01-19T15:45:39.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program."}, {"lang": "es", "value": "La funci\u00f3n mm_init en kernel/fork.c en el kernel de Linux en versiones anteriores a la 4.12.10 no elimina el miembro ->exe_file del mm_struct de un nuevo proceso. Esto permite que un atacante local logre un uso de memoria previamente liberada o que, posiblemente, tenga otro impacto sin especificar ejecutando un programa especialmente manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.7", "versionEndExcluding": "4.9.46", "matchCriteriaId": "838B9038-52BF-4099-86BB-AB2A3A8E62B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.12.10", "matchCriteriaId": "228B0872-5ADF-4033-B9EE-75A0E0E3D4D0"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2b7e8665b4ff51c034c55df3cff76518d1a9ee3a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://www.securityfocus.com/bid/102009", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.12.10", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a"}}