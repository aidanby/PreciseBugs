{"buggy_code": ["/*\n * Glue code for optimized assembly version of  Salsa20.\n *\n * Copyright (c) 2007 Tan Swee Heng <thesweeheng@gmail.com>\n *\n * The assembly codes are public domain assembly codes written by Daniel. J.\n * Bernstein <djb@cr.yp.to>. The codes are modified to include indentation\n * and to remove extraneous comments and functions that are not needed.\n * - i586 version, renamed as salsa20-i586-asm_32.S\n *   available from <http://cr.yp.to/snuffle/salsa20/x86-pm/salsa20.s>\n * - x86-64 version, renamed as salsa20-x86_64-asm_64.S\n *   available from <http://cr.yp.to/snuffle/salsa20/amd64-3/salsa20.s>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/crypto.h>\n\n#define SALSA20_IV_SIZE        8U\n#define SALSA20_MIN_KEY_SIZE  16U\n#define SALSA20_MAX_KEY_SIZE  32U\n\nstruct salsa20_ctx\n{\n\tu32 input[16];\n};\n\nasmlinkage void salsa20_keysetup(struct salsa20_ctx *ctx, const u8 *k,\n\t\t\t\t u32 keysize, u32 ivsize);\nasmlinkage void salsa20_ivsetup(struct salsa20_ctx *ctx, const u8 *iv);\nasmlinkage void salsa20_encrypt_bytes(struct salsa20_ctx *ctx,\n\t\t\t\t      const u8 *src, u8 *dst, u32 bytes);\n\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t  unsigned int keysize)\n{\n\tstruct salsa20_ctx *ctx = crypto_tfm_ctx(tfm);\n\tsalsa20_keysetup(ctx, key, keysize*8, SALSA20_IV_SIZE*8);\n\treturn 0;\n}\n\nstatic int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name           =   \"salsa20\",\n\t.cra_driver_name    =   \"salsa20-asm\",\n\t.cra_priority       =   200,\n\t.cra_flags          =   CRYPTO_ALG_TYPE_BLKCIPHER,\n\t.cra_type           =   &crypto_blkcipher_type,\n\t.cra_blocksize      =   1,\n\t.cra_ctxsize        =   sizeof(struct salsa20_ctx),\n\t.cra_alignmask      =\t3,\n\t.cra_module         =   THIS_MODULE,\n\t.cra_u              =   {\n\t\t.blkcipher = {\n\t\t\t.setkey         =   setkey,\n\t\t\t.encrypt        =   encrypt,\n\t\t\t.decrypt        =   encrypt,\n\t\t\t.min_keysize    =   SALSA20_MIN_KEY_SIZE,\n\t\t\t.max_keysize    =   SALSA20_MAX_KEY_SIZE,\n\t\t\t.ivsize         =   SALSA20_IV_SIZE,\n\t\t}\n\t}\n};\n\nstatic int __init init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nmodule_init(init);\nmodule_exit(fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm (optimized assembly version)\");\nMODULE_ALIAS_CRYPTO(\"salsa20\");\nMODULE_ALIAS_CRYPTO(\"salsa20-asm\");\n", "/*\n * Salsa20: Salsa20 stream cipher algorithm\n *\n * Copyright (c) 2007 Tan Swee Heng <thesweeheng@gmail.com>\n *\n * Derived from:\n * - salsa20.c: Public domain C code by Daniel J. Bernstein <djb@cr.yp.to>\n *\n * Salsa20 is a stream cipher candidate in eSTREAM, the ECRYPT Stream\n * Cipher Project. It is designed by Daniel J. Bernstein <djb@cr.yp.to>.\n * More information about eSTREAM and Salsa20 can be found here:\n *   http://www.ecrypt.eu.org/stream/\n *   http://cr.yp.to/snuffle.html\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <crypto/algapi.h>\n#include <asm/byteorder.h>\n\n#define SALSA20_IV_SIZE        8U\n#define SALSA20_MIN_KEY_SIZE  16U\n#define SALSA20_MAX_KEY_SIZE  32U\n\n/*\n * Start of code taken from D. J. Bernstein's reference implementation.\n * With some modifications and optimizations made to suit our needs.\n */\n\n/*\nsalsa20-ref.c version 20051118\nD. J. Bernstein\nPublic domain.\n*/\n\n#define U32TO8_LITTLE(p, v) \\\n\t{ (p)[0] = (v >>  0) & 0xff; (p)[1] = (v >>  8) & 0xff; \\\n\t  (p)[2] = (v >> 16) & 0xff; (p)[3] = (v >> 24) & 0xff; }\n#define U8TO32_LITTLE(p)   \\\n\t(((u32)((p)[0])      ) | ((u32)((p)[1]) <<  8) | \\\n\t ((u32)((p)[2]) << 16) | ((u32)((p)[3]) << 24)   )\n\nstruct salsa20_ctx\n{\n\tu32 input[16];\n};\n\nstatic void salsa20_wordtobyte(u8 output[64], const u32 input[16])\n{\n\tu32 x[16];\n\tint i;\n\n\tmemcpy(x, input, sizeof(x));\n\tfor (i = 20; i > 0; i -= 2) {\n\t\tx[ 4] ^= rol32((x[ 0] + x[12]),  7);\n\t\tx[ 8] ^= rol32((x[ 4] + x[ 0]),  9);\n\t\tx[12] ^= rol32((x[ 8] + x[ 4]), 13);\n\t\tx[ 0] ^= rol32((x[12] + x[ 8]), 18);\n\t\tx[ 9] ^= rol32((x[ 5] + x[ 1]),  7);\n\t\tx[13] ^= rol32((x[ 9] + x[ 5]),  9);\n\t\tx[ 1] ^= rol32((x[13] + x[ 9]), 13);\n\t\tx[ 5] ^= rol32((x[ 1] + x[13]), 18);\n\t\tx[14] ^= rol32((x[10] + x[ 6]),  7);\n\t\tx[ 2] ^= rol32((x[14] + x[10]),  9);\n\t\tx[ 6] ^= rol32((x[ 2] + x[14]), 13);\n\t\tx[10] ^= rol32((x[ 6] + x[ 2]), 18);\n\t\tx[ 3] ^= rol32((x[15] + x[11]),  7);\n\t\tx[ 7] ^= rol32((x[ 3] + x[15]),  9);\n\t\tx[11] ^= rol32((x[ 7] + x[ 3]), 13);\n\t\tx[15] ^= rol32((x[11] + x[ 7]), 18);\n\t\tx[ 1] ^= rol32((x[ 0] + x[ 3]),  7);\n\t\tx[ 2] ^= rol32((x[ 1] + x[ 0]),  9);\n\t\tx[ 3] ^= rol32((x[ 2] + x[ 1]), 13);\n\t\tx[ 0] ^= rol32((x[ 3] + x[ 2]), 18);\n\t\tx[ 6] ^= rol32((x[ 5] + x[ 4]),  7);\n\t\tx[ 7] ^= rol32((x[ 6] + x[ 5]),  9);\n\t\tx[ 4] ^= rol32((x[ 7] + x[ 6]), 13);\n\t\tx[ 5] ^= rol32((x[ 4] + x[ 7]), 18);\n\t\tx[11] ^= rol32((x[10] + x[ 9]),  7);\n\t\tx[ 8] ^= rol32((x[11] + x[10]),  9);\n\t\tx[ 9] ^= rol32((x[ 8] + x[11]), 13);\n\t\tx[10] ^= rol32((x[ 9] + x[ 8]), 18);\n\t\tx[12] ^= rol32((x[15] + x[14]),  7);\n\t\tx[13] ^= rol32((x[12] + x[15]),  9);\n\t\tx[14] ^= rol32((x[13] + x[12]), 13);\n\t\tx[15] ^= rol32((x[14] + x[13]), 18);\n\t}\n\tfor (i = 0; i < 16; ++i)\n\t\tx[i] += input[i];\n\tfor (i = 0; i < 16; ++i)\n\t\tU32TO8_LITTLE(output + 4 * i,x[i]);\n}\n\nstatic const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nstatic void salsa20_keysetup(struct salsa20_ctx *ctx, const u8 *k, u32 kbytes)\n{\n\tconst char *constants;\n\n\tctx->input[1] = U8TO32_LITTLE(k + 0);\n\tctx->input[2] = U8TO32_LITTLE(k + 4);\n\tctx->input[3] = U8TO32_LITTLE(k + 8);\n\tctx->input[4] = U8TO32_LITTLE(k + 12);\n\tif (kbytes == 32) { /* recommended */\n\t\tk += 16;\n\t\tconstants = sigma;\n\t} else { /* kbytes == 16 */\n\t\tconstants = tau;\n\t}\n\tctx->input[11] = U8TO32_LITTLE(k + 0);\n\tctx->input[12] = U8TO32_LITTLE(k + 4);\n\tctx->input[13] = U8TO32_LITTLE(k + 8);\n\tctx->input[14] = U8TO32_LITTLE(k + 12);\n\tctx->input[0] = U8TO32_LITTLE(constants + 0);\n\tctx->input[5] = U8TO32_LITTLE(constants + 4);\n\tctx->input[10] = U8TO32_LITTLE(constants + 8);\n\tctx->input[15] = U8TO32_LITTLE(constants + 12);\n}\n\nstatic void salsa20_ivsetup(struct salsa20_ctx *ctx, const u8 *iv)\n{\n\tctx->input[6] = U8TO32_LITTLE(iv + 0);\n\tctx->input[7] = U8TO32_LITTLE(iv + 4);\n\tctx->input[8] = 0;\n\tctx->input[9] = 0;\n}\n\nstatic void salsa20_encrypt_bytes(struct salsa20_ctx *ctx, u8 *dst,\n\t\t\t\t  const u8 *src, unsigned int bytes)\n{\n\tu8 buf[64];\n\n\tif (dst != src)\n\t\tmemcpy(dst, src, bytes);\n\n\twhile (bytes) {\n\t\tsalsa20_wordtobyte(buf, ctx->input);\n\n\t\tctx->input[8]++;\n\t\tif (!ctx->input[8])\n\t\t\tctx->input[9]++;\n\n\t\tif (bytes <= 64) {\n\t\t\tcrypto_xor(dst, buf, bytes);\n\t\t\treturn;\n\t\t}\n\n\t\tcrypto_xor(dst, buf, 64);\n\t\tbytes -= 64;\n\t\tdst += 64;\n\t}\n}\n\n/*\n * End of code taken from D. J. Bernstein's reference implementation.\n */\n\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t  unsigned int keysize)\n{\n\tstruct salsa20_ctx *ctx = crypto_tfm_ctx(tfm);\n\tsalsa20_keysetup(ctx, key, keysize);\n\treturn 0;\n}\n\nstatic int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name           =   \"salsa20\",\n\t.cra_driver_name    =   \"salsa20-generic\",\n\t.cra_priority       =   100,\n\t.cra_flags          =   CRYPTO_ALG_TYPE_BLKCIPHER,\n\t.cra_type           =   &crypto_blkcipher_type,\n\t.cra_blocksize      =   1,\n\t.cra_ctxsize        =   sizeof(struct salsa20_ctx),\n\t.cra_alignmask      =\t3,\n\t.cra_module         =   THIS_MODULE,\n\t.cra_u              =   {\n\t\t.blkcipher = {\n\t\t\t.setkey         =   setkey,\n\t\t\t.encrypt        =   encrypt,\n\t\t\t.decrypt        =   encrypt,\n\t\t\t.min_keysize    =   SALSA20_MIN_KEY_SIZE,\n\t\t\t.max_keysize    =   SALSA20_MAX_KEY_SIZE,\n\t\t\t.ivsize         =   SALSA20_IV_SIZE,\n\t\t}\n\t}\n};\n\nstatic int __init salsa20_generic_mod_init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit salsa20_generic_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nmodule_init(salsa20_generic_mod_init);\nmodule_exit(salsa20_generic_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm\");\nMODULE_ALIAS_CRYPTO(\"salsa20\");\nMODULE_ALIAS_CRYPTO(\"salsa20-generic\");\n"], "fixing_code": ["/*\n * Glue code for optimized assembly version of  Salsa20.\n *\n * Copyright (c) 2007 Tan Swee Heng <thesweeheng@gmail.com>\n *\n * The assembly codes are public domain assembly codes written by Daniel. J.\n * Bernstein <djb@cr.yp.to>. The codes are modified to include indentation\n * and to remove extraneous comments and functions that are not needed.\n * - i586 version, renamed as salsa20-i586-asm_32.S\n *   available from <http://cr.yp.to/snuffle/salsa20/x86-pm/salsa20.s>\n * - x86-64 version, renamed as salsa20-x86_64-asm_64.S\n *   available from <http://cr.yp.to/snuffle/salsa20/amd64-3/salsa20.s>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/crypto.h>\n\n#define SALSA20_IV_SIZE        8U\n#define SALSA20_MIN_KEY_SIZE  16U\n#define SALSA20_MAX_KEY_SIZE  32U\n\nstruct salsa20_ctx\n{\n\tu32 input[16];\n};\n\nasmlinkage void salsa20_keysetup(struct salsa20_ctx *ctx, const u8 *k,\n\t\t\t\t u32 keysize, u32 ivsize);\nasmlinkage void salsa20_ivsetup(struct salsa20_ctx *ctx, const u8 *iv);\nasmlinkage void salsa20_encrypt_bytes(struct salsa20_ctx *ctx,\n\t\t\t\t      const u8 *src, u8 *dst, u32 bytes);\n\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t  unsigned int keysize)\n{\n\tstruct salsa20_ctx *ctx = crypto_tfm_ctx(tfm);\n\tsalsa20_keysetup(ctx, key, keysize*8, SALSA20_IV_SIZE*8);\n\treturn 0;\n}\n\nstatic int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name           =   \"salsa20\",\n\t.cra_driver_name    =   \"salsa20-asm\",\n\t.cra_priority       =   200,\n\t.cra_flags          =   CRYPTO_ALG_TYPE_BLKCIPHER,\n\t.cra_type           =   &crypto_blkcipher_type,\n\t.cra_blocksize      =   1,\n\t.cra_ctxsize        =   sizeof(struct salsa20_ctx),\n\t.cra_alignmask      =\t3,\n\t.cra_module         =   THIS_MODULE,\n\t.cra_u              =   {\n\t\t.blkcipher = {\n\t\t\t.setkey         =   setkey,\n\t\t\t.encrypt        =   encrypt,\n\t\t\t.decrypt        =   encrypt,\n\t\t\t.min_keysize    =   SALSA20_MIN_KEY_SIZE,\n\t\t\t.max_keysize    =   SALSA20_MAX_KEY_SIZE,\n\t\t\t.ivsize         =   SALSA20_IV_SIZE,\n\t\t}\n\t}\n};\n\nstatic int __init init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nmodule_init(init);\nmodule_exit(fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm (optimized assembly version)\");\nMODULE_ALIAS_CRYPTO(\"salsa20\");\nMODULE_ALIAS_CRYPTO(\"salsa20-asm\");\n", "/*\n * Salsa20: Salsa20 stream cipher algorithm\n *\n * Copyright (c) 2007 Tan Swee Heng <thesweeheng@gmail.com>\n *\n * Derived from:\n * - salsa20.c: Public domain C code by Daniel J. Bernstein <djb@cr.yp.to>\n *\n * Salsa20 is a stream cipher candidate in eSTREAM, the ECRYPT Stream\n * Cipher Project. It is designed by Daniel J. Bernstein <djb@cr.yp.to>.\n * More information about eSTREAM and Salsa20 can be found here:\n *   http://www.ecrypt.eu.org/stream/\n *   http://cr.yp.to/snuffle.html\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <crypto/algapi.h>\n#include <asm/byteorder.h>\n\n#define SALSA20_IV_SIZE        8U\n#define SALSA20_MIN_KEY_SIZE  16U\n#define SALSA20_MAX_KEY_SIZE  32U\n\n/*\n * Start of code taken from D. J. Bernstein's reference implementation.\n * With some modifications and optimizations made to suit our needs.\n */\n\n/*\nsalsa20-ref.c version 20051118\nD. J. Bernstein\nPublic domain.\n*/\n\n#define U32TO8_LITTLE(p, v) \\\n\t{ (p)[0] = (v >>  0) & 0xff; (p)[1] = (v >>  8) & 0xff; \\\n\t  (p)[2] = (v >> 16) & 0xff; (p)[3] = (v >> 24) & 0xff; }\n#define U8TO32_LITTLE(p)   \\\n\t(((u32)((p)[0])      ) | ((u32)((p)[1]) <<  8) | \\\n\t ((u32)((p)[2]) << 16) | ((u32)((p)[3]) << 24)   )\n\nstruct salsa20_ctx\n{\n\tu32 input[16];\n};\n\nstatic void salsa20_wordtobyte(u8 output[64], const u32 input[16])\n{\n\tu32 x[16];\n\tint i;\n\n\tmemcpy(x, input, sizeof(x));\n\tfor (i = 20; i > 0; i -= 2) {\n\t\tx[ 4] ^= rol32((x[ 0] + x[12]),  7);\n\t\tx[ 8] ^= rol32((x[ 4] + x[ 0]),  9);\n\t\tx[12] ^= rol32((x[ 8] + x[ 4]), 13);\n\t\tx[ 0] ^= rol32((x[12] + x[ 8]), 18);\n\t\tx[ 9] ^= rol32((x[ 5] + x[ 1]),  7);\n\t\tx[13] ^= rol32((x[ 9] + x[ 5]),  9);\n\t\tx[ 1] ^= rol32((x[13] + x[ 9]), 13);\n\t\tx[ 5] ^= rol32((x[ 1] + x[13]), 18);\n\t\tx[14] ^= rol32((x[10] + x[ 6]),  7);\n\t\tx[ 2] ^= rol32((x[14] + x[10]),  9);\n\t\tx[ 6] ^= rol32((x[ 2] + x[14]), 13);\n\t\tx[10] ^= rol32((x[ 6] + x[ 2]), 18);\n\t\tx[ 3] ^= rol32((x[15] + x[11]),  7);\n\t\tx[ 7] ^= rol32((x[ 3] + x[15]),  9);\n\t\tx[11] ^= rol32((x[ 7] + x[ 3]), 13);\n\t\tx[15] ^= rol32((x[11] + x[ 7]), 18);\n\t\tx[ 1] ^= rol32((x[ 0] + x[ 3]),  7);\n\t\tx[ 2] ^= rol32((x[ 1] + x[ 0]),  9);\n\t\tx[ 3] ^= rol32((x[ 2] + x[ 1]), 13);\n\t\tx[ 0] ^= rol32((x[ 3] + x[ 2]), 18);\n\t\tx[ 6] ^= rol32((x[ 5] + x[ 4]),  7);\n\t\tx[ 7] ^= rol32((x[ 6] + x[ 5]),  9);\n\t\tx[ 4] ^= rol32((x[ 7] + x[ 6]), 13);\n\t\tx[ 5] ^= rol32((x[ 4] + x[ 7]), 18);\n\t\tx[11] ^= rol32((x[10] + x[ 9]),  7);\n\t\tx[ 8] ^= rol32((x[11] + x[10]),  9);\n\t\tx[ 9] ^= rol32((x[ 8] + x[11]), 13);\n\t\tx[10] ^= rol32((x[ 9] + x[ 8]), 18);\n\t\tx[12] ^= rol32((x[15] + x[14]),  7);\n\t\tx[13] ^= rol32((x[12] + x[15]),  9);\n\t\tx[14] ^= rol32((x[13] + x[12]), 13);\n\t\tx[15] ^= rol32((x[14] + x[13]), 18);\n\t}\n\tfor (i = 0; i < 16; ++i)\n\t\tx[i] += input[i];\n\tfor (i = 0; i < 16; ++i)\n\t\tU32TO8_LITTLE(output + 4 * i,x[i]);\n}\n\nstatic const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nstatic void salsa20_keysetup(struct salsa20_ctx *ctx, const u8 *k, u32 kbytes)\n{\n\tconst char *constants;\n\n\tctx->input[1] = U8TO32_LITTLE(k + 0);\n\tctx->input[2] = U8TO32_LITTLE(k + 4);\n\tctx->input[3] = U8TO32_LITTLE(k + 8);\n\tctx->input[4] = U8TO32_LITTLE(k + 12);\n\tif (kbytes == 32) { /* recommended */\n\t\tk += 16;\n\t\tconstants = sigma;\n\t} else { /* kbytes == 16 */\n\t\tconstants = tau;\n\t}\n\tctx->input[11] = U8TO32_LITTLE(k + 0);\n\tctx->input[12] = U8TO32_LITTLE(k + 4);\n\tctx->input[13] = U8TO32_LITTLE(k + 8);\n\tctx->input[14] = U8TO32_LITTLE(k + 12);\n\tctx->input[0] = U8TO32_LITTLE(constants + 0);\n\tctx->input[5] = U8TO32_LITTLE(constants + 4);\n\tctx->input[10] = U8TO32_LITTLE(constants + 8);\n\tctx->input[15] = U8TO32_LITTLE(constants + 12);\n}\n\nstatic void salsa20_ivsetup(struct salsa20_ctx *ctx, const u8 *iv)\n{\n\tctx->input[6] = U8TO32_LITTLE(iv + 0);\n\tctx->input[7] = U8TO32_LITTLE(iv + 4);\n\tctx->input[8] = 0;\n\tctx->input[9] = 0;\n}\n\nstatic void salsa20_encrypt_bytes(struct salsa20_ctx *ctx, u8 *dst,\n\t\t\t\t  const u8 *src, unsigned int bytes)\n{\n\tu8 buf[64];\n\n\tif (dst != src)\n\t\tmemcpy(dst, src, bytes);\n\n\twhile (bytes) {\n\t\tsalsa20_wordtobyte(buf, ctx->input);\n\n\t\tctx->input[8]++;\n\t\tif (!ctx->input[8])\n\t\t\tctx->input[9]++;\n\n\t\tif (bytes <= 64) {\n\t\t\tcrypto_xor(dst, buf, bytes);\n\t\t\treturn;\n\t\t}\n\n\t\tcrypto_xor(dst, buf, 64);\n\t\tbytes -= 64;\n\t\tdst += 64;\n\t}\n}\n\n/*\n * End of code taken from D. J. Bernstein's reference implementation.\n */\n\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t  unsigned int keysize)\n{\n\tstruct salsa20_ctx *ctx = crypto_tfm_ctx(tfm);\n\tsalsa20_keysetup(ctx, key, keysize);\n\treturn 0;\n}\n\nstatic int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name           =   \"salsa20\",\n\t.cra_driver_name    =   \"salsa20-generic\",\n\t.cra_priority       =   100,\n\t.cra_flags          =   CRYPTO_ALG_TYPE_BLKCIPHER,\n\t.cra_type           =   &crypto_blkcipher_type,\n\t.cra_blocksize      =   1,\n\t.cra_ctxsize        =   sizeof(struct salsa20_ctx),\n\t.cra_alignmask      =\t3,\n\t.cra_module         =   THIS_MODULE,\n\t.cra_u              =   {\n\t\t.blkcipher = {\n\t\t\t.setkey         =   setkey,\n\t\t\t.encrypt        =   encrypt,\n\t\t\t.decrypt        =   encrypt,\n\t\t\t.min_keysize    =   SALSA20_MIN_KEY_SIZE,\n\t\t\t.max_keysize    =   SALSA20_MAX_KEY_SIZE,\n\t\t\t.ivsize         =   SALSA20_IV_SIZE,\n\t\t}\n\t}\n};\n\nstatic int __init salsa20_generic_mod_init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit salsa20_generic_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nmodule_init(salsa20_generic_mod_init);\nmodule_exit(salsa20_generic_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm\");\nMODULE_ALIAS_CRYPTO(\"salsa20\");\nMODULE_ALIAS_CRYPTO(\"salsa20-generic\");\n"], "filenames": ["arch/x86/crypto/salsa20_glue.c", "crypto/salsa20_generic.c"], "buggy_code_start_loc": [62, 191], "buggy_code_end_loc": [69, 198], "fixing_code_start_loc": [61, 190], "fixing_code_end_loc": [61, 190], "type": "CWE-20", "message": "The Salsa20 encryption algorithm in the Linux kernel before 4.14.8 does not correctly handle zero-length inputs, allowing a local attacker able to use the AF_ALG-based skcipher interface (CONFIG_CRYPTO_USER_API_SKCIPHER) to cause a denial of service (uninitialized-memory free and kernel crash) or have unspecified other impact by executing a crafted sequence of system calls that use the blkcipher_walk API. Both the generic implementation (crypto/salsa20_generic.c) and x86 implementation (arch/x86/crypto/salsa20_glue.c) of Salsa20 were vulnerable.", "other": {"cve": {"id": "CVE-2017-17805", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-20T23:29:00.327", "lastModified": "2023-01-19T15:45:33.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Salsa20 encryption algorithm in the Linux kernel before 4.14.8 does not correctly handle zero-length inputs, allowing a local attacker able to use the AF_ALG-based skcipher interface (CONFIG_CRYPTO_USER_API_SKCIPHER) to cause a denial of service (uninitialized-memory free and kernel crash) or have unspecified other impact by executing a crafted sequence of system calls that use the blkcipher_walk API. Both the generic implementation (crypto/salsa20_generic.c) and x86 implementation (arch/x86/crypto/salsa20_glue.c) of Salsa20 were vulnerable."}, {"lang": "es", "value": "El algoritmo de cifrado Salsa20 en el kernel de Linux en versiones anteriores a la 4.14.8 no maneja correctamente las entradas de longitud cero, lo que permite a un atacante local capaz de utilizar la interfaz skcipher basada en AF_ALG (CONFIG_CRYPTO_USER_API_SKCIPHER) provocar una denegaci\u00f3n de servicio (liberaci\u00f3n de memoria no inicializada y fallo del kernel) o provocar otro impacto no especificado ejecutando una secuencia manipulada de llamadas al sistema que utilizan la API blkcipher_walk. Tanto la implementaci\u00f3n gen\u00e9rica (crypto/salsa20_generic.c) como la implementaci\u00f3n x86 (arch/x86/crypto/salsa20_glue.c) de Salsa20 eran vulnerables."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.25", "versionEndExcluding": "3.2.97", "matchCriteriaId": "9C38EF6C-BEB1-4C3B-965F-1BA7A9E0F84C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.52", "matchCriteriaId": "B97C01AC-F470-4190-AC38-30DE3DFDCCAC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.89", "matchCriteriaId": "BBA93779-9E2C-4161-9DC3-569588ECB754"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.49", "matchCriteriaId": "F3C1F309-D954-4BB7-AC02-30FC58BE76F9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.107", "matchCriteriaId": "EEE9C869-86BF-4DBF-8EBB-FC14AD5A7019"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.71", "matchCriteriaId": "A25E81B4-C400-4932-8841-3116C21DF3DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.8", "matchCriteriaId": "342F6BB8-126D-4E05-915F-4CDC362F5C51"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "D8CD4569-8BFA-4654-9CAB-2882D4CAE57D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:sp2:*:*:*:*:*:*", "matchCriteriaId": "57CFAD92-EECD-417D-ADDB-8178C320B204"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:sp3:*:*:*:*:*:*", "matchCriteriaId": "C1DCD75C-9775-4922-8A44-C4707C640946"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:extra:*:*:*:*:*:*", "matchCriteriaId": "AD1AEFA5-9D43-4DD2-9088-7B37D5F220C4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "55C5561F-BE86-4EEA-99D4-8697F8BD9DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:sp2:*:*:*:*:*:*", "matchCriteriaId": "F84B2729-7B52-4505-9656-1BD31B980705"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:sp3:*:*:*:*:*:*", "matchCriteriaId": "631BB7F0-5F27-4244-8E72-428DA824C75B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server_for_raspberry_pi:12:sp2:*:*:*:*:*:*", "matchCriteriaId": "4605D055-EA6E-4C90-9277-AC067E1BD02D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ecaaab5649781c5a0effdaf298a925063020500e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00006.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00007.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00008.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00014.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00016.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/102291", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3083", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2473", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00004.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3620-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3620-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3632-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4073", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4082", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.14.8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e"}}