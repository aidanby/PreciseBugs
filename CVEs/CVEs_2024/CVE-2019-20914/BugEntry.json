{"buggy_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2010-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dwgrewrite.c: load a DWG file and rewrite it,\n * optionally as a different version.\n *\n * written by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"../src/config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n\n#include <dwg.h>\n#include \"../src/common.h\"\n#include \"suffix.inc\"\n\nstatic int opts = 1;\n\nstatic int help (void);\n// int verbosity(int argc, char **argv, int i, unsigned int *opts);\n//#include \"common.inc\"\n\nstatic int\nusage (void)\n{\n  printf (\"\\nUsage: dwgrewrite [-v[N]] [--as rNNNN] <dwg_input_file.dwg> \"\n          \"[<dwg_output_file.dwg>]\\n\");\n  return 1;\n}\nstatic int\nopt_version (void)\n{\n  printf (\"dwgrewrite %s\\n\", PACKAGE_VERSION);\n  return 0;\n}\nstatic int\nhelp (void)\n{\n  printf (\"\\nUsage: dwgrewrite [OPTION]... INFILE [OUTFILE]\\n\");\n  printf (\"Rewrites the DWG as another DWG.\\n\");\n  printf (\"Default OUTFILE: INFILE with <-rewrite.dwg> appended.\\n\"\n          \"\\n\");\n#ifdef HAVE_GETOPT_LONG\n  printf (\"  -v[0-9], --verbose [0-9]  verbosity\\n\");\n  printf (\"  --as rNNNN                save as version\\n\");\n  printf (\"           Valid versions:\\n\");\n  printf (\"             r12, r14, r2000\\n\");\n  printf (\"           Planned versions:\\n\");\n  printf (\"             r9, r10, r11, r2004, r2007, r2010, r2013, r2018\\n\");\n  printf (\"  -o dwgfile, --file        \\n\");\n  printf (\"           --help           display this help and exit\\n\");\n  printf (\"           --version        output version information and exit\\n\"\n          \"\\n\");\n#else\n  printf (\"  -v[0-9]     verbosity\\n\");\n  printf (\"  -a rNNNN    save as version\\n\");\n  printf (\"              Valid versions:\\n\");\n  printf (\"                r12, r14, r2000 (default)\\n\");\n  printf (\"              Planned versions:\\n\");\n  printf (\"                r9, r10, r11, r2004, r2007, r2010, r2013, r2018\\n\");\n  printf (\"  -o dwgfile\\n\");\n  printf (\"  -h          display this help and exit\\n\");\n  printf (\"  -i          output version information and exit\\n\"\n          \"\\n\");\n#endif\n  printf (\"GNU LibreDWG online manual: \"\n          \"<https://www.gnu.org/software/libredwg/>\\n\");\n  return 0;\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int error;\n  int i = 1;\n  Dwg_Data dwg;\n  char *filename_in;\n  const char *version = NULL;\n  char *filename_out = NULL;\n  Dwg_Version_Type dwg_version;\n  BITCODE_BL num_objects;\n  int c;\n#ifdef HAVE_GETOPT_LONG\n  int option_index = 0;\n  static struct option long_options[]\n      = { { \"verbose\", 1, &opts, 1 }, // optional\n          { \"file\", 1, 0, 'o' },      { \"as\", 1, 0, 'a' }, { \"help\", 0, 0, 0 },\n          { \"version\", 0, 0, 0 },     { NULL, 0, NULL, 0 } };\n#endif\n\n  // check args\n  if (argc < 2)\n    return usage ();\n\n  while\n#ifdef HAVE_GETOPT_LONG\n      ((c = getopt_long (argc, argv, \":a:v::o:h\", long_options, &option_index))\n       != -1)\n#else\n      ((c = getopt (argc, argv, \":a:v::o:hi\")) != -1)\n#endif\n    {\n      if (c == -1)\n        break;\n      switch (c)\n        {\n        case ':': // missing arg\n          if (optarg && !strcmp (optarg, \"v\"))\n            {\n              opts = 1;\n              break;\n            }\n          fprintf (stderr, \"%s: option '-%c' requires an argument\\n\", argv[0],\n                   optopt);\n          break;\n#ifdef HAVE_GETOPT_LONG\n        case 0:\n          /* This option sets a flag */\n          if (!strcmp (long_options[option_index].name, \"verbose\"))\n            {\n              if (opts < 0 || opts > 9)\n                return usage ();\n#  if defined(USE_TRACING) && defined(HAVE_SETENV)\n              {\n                char v[2];\n                *v = opts + '0';\n                *(v + 1) = 0;\n                setenv (\"LIBREDWG_TRACE\", v, 1);\n              }\n#  endif\n              break;\n            }\n          if (!strcmp (long_options[option_index].name, \"version\"))\n            return opt_version ();\n          if (!strcmp (long_options[option_index].name, \"help\"))\n            return help ();\n          break;\n#else\n        case 'i':\n          return opt_version ();\n#endif\n        case 'o':\n          filename_out = optarg;\n          break;\n        case 'a':\n          dwg_version = dwg_version_as (optarg);\n          if (dwg_version == R_INVALID)\n            {\n              fprintf (stderr, \"Invalid version '%s'\\n\", argv[1]);\n              return usage ();\n            }\n          version = optarg;\n          break;\n        case 'v': // support -v3 and -v\n          i = (optind > 0 && optind < argc) ? optind - 1 : 1;\n          if (!memcmp (argv[i], \"-v\", 2))\n            {\n              opts = argv[i][2] ? argv[i][2] - '0' : 1;\n            }\n          if (opts < 0 || opts > 9)\n            return usage ();\n#if defined(USE_TRACING) && defined(HAVE_SETENV)\n          {\n            char v[2];\n            *v = opts + '0';\n            *(v + 1) = 0;\n            setenv (\"LIBREDWG_TRACE\", v, 1);\n          }\n#endif\n          break;\n        case 'h':\n          return help ();\n        case '?':\n          fprintf (stderr, \"%s: invalid option '-%c' ignored\\n\", argv[0],\n                   optopt);\n          break;\n        default:\n          return usage ();\n        }\n    }\n  i = optind;\n\n  memset (&dwg, 0, sizeof (Dwg_Data));\n  dwg.opts = opts;\n\n  filename_in = argv[i];\n  if (!filename_in)\n    {\n      puts (\"No input file specified\");\n      return 1;\n    }\n  if (!filename_out)\n    {\n      if (argc > i + 1)\n        filename_out = argv[i + 1];\n      else\n        filename_out = suffix (filename_in, \"-rewrite.dwg\");\n    }\n  if (!filename_out || !strcmp (filename_in, filename_out))\n    {\n      if (filename_out != argv[i + 1])\n        free (filename_out);\n      return usage ();\n    }\n\n  /*\n   * some very simple testing\n   */\n  printf (\"Reading DWG file %s\\n\", filename_in);\n  error = dwg_read_file (filename_in, &dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    fprintf (stderr, \"READ ERROR 0x%x\\n\", error);\n  num_objects = dwg.num_objects;\n  if (!num_objects)\n    {\n      printf (\"Read 0 objects\\n\");\n      if (error >= DWG_ERR_CRITICAL)\n        {\n          if (filename_out != argv[i + 1])\n            free (filename_out);\n          return error;\n        }\n    }\n\n  if (opts)\n    printf (\"\\n\");\n  printf (\"Writing DWG file %s\", filename_out);\n#ifndef USE_WRITE\n  error = 1;\n#else\n  if (version)\n    { // forced -as-rXXX\n      printf (\" as %s\\n\", version);\n      if (dwg.header.from_version != dwg.header.version)\n        dwg.header.from_version = dwg.header.version;\n      // else keep from_version\n      dwg.header.version = dwg_version;\n    }\n  else if (dwg.header.version < R_13 || dwg.header.version > R_2000)\n    {\n      // we cannot yet write pre-r13 or 2004+\n      printf (\" as r2000\\n\");\n      dwg.header.version = R_2000;\n    }\n  else\n    {\n      printf (\"\\n\");\n    }\n\n  {\n    struct stat attrib;\n    if (!stat (filename_out, &attrib)) // exists\n      {\n        if (S_ISREG (attrib.st_mode) &&        // refuse to remove a directory\n            (access (filename_out, W_OK) == 0) // is writable\n#ifndef _WIN32\n            // refuse to remove a symlink. even with overwrite. security\n            && !S_ISLNK (attrib.st_mode)\n#endif\n            )\n          unlink (filename_out);\n        else\n          {\n            fprintf (stderr, \"Not writable file or symlink: %s\\n\",\n                     filename_out);\n            error |= DWG_ERR_IOERROR;\n          }\n      }\n  }\n  error = dwg_write_file (filename_out, &dwg);\n#endif\n\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      printf (\"WRITE ERROR 0x%x\\n\", error);\n      if (filename_out != argv[i + 1])\n        free (filename_out);\n      return error;\n    }\n  dwg_free (&dwg); // this is slow, but on needed on low memory systems\n\n#ifdef USE_WRITE\n  // try to read again\n  if (opts)\n    printf (\"\\n\");\n  printf (\"Re-reading created file %s\\n\", filename_out);\n  error = dwg_read_file (filename_out, &dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    printf (\"re-READ ERROR 0x%x\\n\", error);\n  if (num_objects && (num_objects != dwg.num_objects))\n    printf (\"re-READ num_objects: %lu, should be %lu\\n\",\n            (unsigned long)dwg.num_objects, (unsigned long)num_objects);\n  dwg_free (&dwg);\n#endif\n  if (filename_out != argv[i + 1])\n    free (filename_out);\n  return error >= DWG_ERR_CRITICAL ? error : 0;\n}\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n#define REFS_PER_REALLOC 100\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf);                \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \"\\n\", _obj->nam)\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\\n\", _obj->nam)\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf)    FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf)   FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf)   FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf)   FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf)  FIELD_CAST(nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf)  FIELD_CAST(nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf)  FIELD_CAST(nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf)  FIELD_CAST(nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf)  FIELD_CAST(nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf)  FIELD_CAST(nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf)   FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf)  FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER { if (!_obj->nam) _obj->nam = strdup (\"\"); }       \\\n    FIELDG (nam, TV, dxf);                                                    \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings)                                         \\\n          {                                                                   \\\n            FIELD_TU (nam, dxf)                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                     \\\n      }                                                                       \\\n    FIELD_G_TRACE (nam, TF, dxf);                                             \\\n  }\n#define FIELD_TFF(nam, len, dxf)  FIELD_TF(nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (dat, (BITCODE_TU)_obj->nam);                              \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  _FIELD_DD(nam, _default, dxf);                                              \\\n  LOG_TRACE (#nam \": %f [DD %d]\\n\", _obj->nam, dxf)\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, d1, dxf);                                               \\\n    _FIELD_DD (nam.y, d2, dxf + 10);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [2DD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD(nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD_1(nam, dxf)   FIELD_3BD(nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \"\\n\", _obj->nam.days,        \\\n               _obj->nam.ms);                                                 \\\n  }\n\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, &_obj->color);                                        \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n\n#define SUB_FIELD_CMC(o, nam, dxf1, dxf2) bit_write_CMC (dat, &_obj->o.nam)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n// No overflow check with IS_RELEASE\n#ifdef IS_RELEASE\n#  define OVERFLOW_CHECK(nam, size)\n#  define OVERFLOW_CHECK_LV(nam, size)\n#else\n#  define OVERFLOW_CHECK(nam, size)                                           \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#  define OVERFLOW_CHECK_LV(nam, size)                                        \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);             \\\n        size = 0;                                                             \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#endif\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK (nam, _obj->size)                                            \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], FIELD_VALUE (nam[vcount - 1].x),                \\\n                 FIELD_VALUE (nam[vcount - 1].y), dxf);                       \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, obj->tio.object->num_reactors)                  \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,         \\\n                     _obj->nam[vcount])                                       \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, size, dxf)                                        \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            bit_write_TV (dat, _obj->nam[vcount]);                            \\\n            LOG_TRACE (#nam \"[%d]: %s\\n\", (int)vcount, _obj->nam[vcount])     \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_TU (dat, (BITCODE_TU)_obj->nam[vcount]);                \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0 };                                 \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\\n\", handle_code, dxf)        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && hdlptr->handleref.code != handle_code   \\\n            && (handle_code == 4 && hdlptr->handleref.code < 6))              \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      hdlptr->handleref.code);                                \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &hdlptr->handleref);                            \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\\n\", ARGS_REF (hdlptr), dxf)  \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\\n\", (int)vcount, handle_code,  \\\n                   dxf)                                                       \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\\n\", (int)vcount,        \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define START_HANDLE_STREAM                                                   \\\n  *hdl_dat = *dat;                                                            \\\n  if (dat->version >= R_2007 && obj->bitsize)                                 \\\n    bit_set_position (hdl_dat, obj->hdlpos);                                  \\\n  if (!obj->bitsize)                                                          \\\n    {                                                                         \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM @%lu.%u (%lu)\\n\",          \\\n                 dat->byte, dat->bit, obj->address);                          \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n    }                                                                         \\\n  RESET_VER\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0; \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;                               \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\")                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;                    \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    LOG_INFO (\"Encode object \" #token \"\\n\")\n\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_2000 && _obj->num_reactors > 0x1000)                  \\\n    {                                                                         \\\n      fprintf (stderr, \"Invalid num_reactors: %ld\\n\",                         \\\n               (long)_obj->num_reactors);                                     \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj,\n                              Bit_Chain *str_dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat, Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, int size);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nint\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  unsigned char pvzbit;\n  long unsigned int pvzadr;\n  long unsigned int pvzadr_2;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *hdl_dat;\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat;\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s from version %s\\n\",\n               version_codes[dwg->header.version],\n               version_codes[dwg->header.from_version])\n  else\n    LOG_TRACE (\"Encode version %s\\n\", version_codes[dwg->header.version])\n  dat->byte += 6;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version)\n      {\n        _obj->is_maint = 0;\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x11; // ?\n            break;\n          case R_10:\n            _obj->dwg_version = 0x12; // ?\n            break;\n          case R_11:\n            _obj->dwg_version = 0x13; // ?\n            break;\n          case R_13:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x16;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19;\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x4;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_4:\n          case R_2_0:\n          case R_2_1:\n          case R_2_5:\n          case R_2_6:\n          default:\n            break;\n          }\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    if (!dwg->header.num_sections) /* Usually 3-5, max 6 */\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            dat->from_version = R_11; // to trigger IF_ENCODE_FROM_EARLIER defaults\n            if (dat->version <= dat->from_version)\n              dat->from_version = dat->version - 1;\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section\n          = calloc (dwg->header.num_sections, sizeof (Dwg_Section));\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version)\n          {\n            BITCODE_RS tmpunknown[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_rs), tmpunknown, sizeof (tmpunknown));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\")\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    /* System Section */\n    typedef union _system_section\n    {\n      unsigned char data[0x14]; // 20byte: 5*4\n      struct\n      {\n        uint32_t section_type; /* 0x4163043b */\n        uint32_t decomp_data_size;\n        uint32_t comp_data_size;\n        uint32_t compression_type;\n        uint32_t checksum; // see section_page_checksum\n      } fields;\n    } system_section;\n\n    system_section ss;\n    Dwg_Section *section;\n\n    Dwg_Object *obj = NULL;\n    struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n    const int size = sizeof (struct Dwg_R2004_Header);\n    char encrypted_data[size];\n    unsigned int rseed = 1;\n    uint32_t checksum;\n\n    LOG_ERROR (WE_CAN \"We don't encode the R2004_section_map yet\")\n\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = calloc (dwg->header.section_infohdr.num_desc,\n                                         sizeof (Dwg_Section_Info));\n\n    dat->byte = 0x80;\n    for (i = 0; i < (BITCODE_BL)size; i++)\n      {\n        rseed *= 0x343fd;\n        rseed += 0x269ec3;\n        encrypted_data[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n      }\n    LOG_TRACE (\"\\n#### Write 2004 File Header ####\\n\");\n    dat->byte = 0x80;\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dat->size = dat->byte + 0x80;\n        bit_chain_alloc (dat);\n      }\n    memcpy (&dat->chain[0x80], encrypted_data, size);\n    LOG_INFO (\"@0x%lx\\n\", dat->byte);\n\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n\n    dwg->r2004_header.checksum = 0;\n    dwg->r2004_header.checksum = dwg_section_page_checksum (0, dat, size);\n\n    /*-------------------------------------------------------------------------\n     * Section Page Map\n     */\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Write System Section (Section Page Map) ===\\n\");\n#ifndef HAVE_COMPRESS_R2004_SECTION\n    dwg->r2004_header.comp_data_size = dwg->r2004_header.decomp_data_size;\n    dwg->r2004_header.compression_type = 0;\n#endif\n    FIELD_RL (section_type, 0); // should be 0x4163043b\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    dwg_section_page_checksum (dwg->r2004_header.checksum, dat, size);\n    FIELD_RL (checksum, 0);\n    LOG_TRACE (\"\\n\")\n\n    LOG_WARN (\"TODO write_R2004_section_map(dat, dwg)\")\n    LOG_TRACE (\"\\n\")\n\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  if (!dwg->header.thumbnail_address)\n    dwg->header.thumbnail_address = dat->byte;\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, (char *)dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL size;\n    dwg_bmp (dwg, &size);\n    if (size > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", size, dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte, dwg->num_classes);\n  dwg->header.section[SECTION_CLASSES_R13].number = 1;\n  dwg->header.section[SECTION_CLASSES_R13].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      bit_write_TV (dat, klass->appname);\n      bit_write_TV (dat, klass->cppname);\n      bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->wasazombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long address, end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n      assert (dat->byte);\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0\n      if (dwg->header.version >= R_1_2)\n        {\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[SECTION_HANDLES_R13].number = 2;\n  dwg->header.section[SECTION_HANDLES_R13].address = dat->byte;\n\n  sec_size = 0;\n  pvzadr = dat->byte; // Correct value of section size must be written later\n  dat->byte += 2;\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n      assert (pvzadr);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n  if (dwg->header.version >= R_1_2)\n    {\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  pvzadr = dat->byte;\n  assert (pvzadr);\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[SECTION_HANDLES_R13].size\n      = dat->byte - dwg->header.section[SECTION_HANDLES_R13].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n  if (dwg->header.version >= R_13 && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          if (dwg->header.version <= R_2000)\n            {\n              _obj->num_sections = dwg->header.num_sections;\n              for (i = 0; i < _obj->num_sections; i++)\n                {\n                  _obj->section[i].nr = dwg->header.section[i].number;\n                  _obj->section[i].address = dwg->header.section[i].address;\n                  _obj->section[i].size = dwg->header.section[i].size;\n                }\n              // TODO handlers\n            }\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n        }\n\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %x != %x\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n        }\n      FIELD_BLx (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (char *)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13)\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT Section 4\n   * In a DXF under header_vars\n   */\n  if (dwg->header.num_sections > SECTION_MEASUREMENT_R13)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[SECTION_MEASUREMENT_R13].number = 4;\n      dwg->header.section[SECTION_MEASUREMENT_R13].address = dat->byte;\n      dwg->header.section[SECTION_MEASUREMENT_R13].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL]\\n\", dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n\n  /* Write section addresses\n   */\n  assert (section_address);\n  dat->byte = section_address;\n  dat->bit = 0;\n  LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      bit_write_RC (dat, dwg->header.section[j].number);\n      bit_write_RL (dat, dwg->header.section[j].address);\n      bit_write_RL (dat, dwg->header.section[j].size);\n      LOG_TRACE (\"section[%u].number: %2d [RC]\\n\", j,\n                 (int)dwg->header.section[j].number)\n      LOG_TRACE (\"section[%u].offset: 0x%x [RLx]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size: %4d [RL]\\n\", j,\n                 (int)dwg->header.section[j].size)\n    }\n\n  /* Write CRC's\n   */\n  bit_write_CRC (dat, 0, 0);\n  dat->byte -= 2;\n  ckr = bit_read_CRC (dat);\n  dat->byte -= 2;\n  switch (dwg->header.num_sections)\n    {\n    case 3:\n      ckr ^= 0xA598;\n      break;\n    case 4:\n      ckr ^= 0x8101;\n      break;\n    case 5:\n      ckr ^= 0x3CC4;\n      break;\n    case 6:\n      ckr ^= 0x8461;\n      break;\n    default:\n      break;\n    }\n  bit_write_RS (dat, ckr);\n  LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n\n  return 0;\n}\n\nstatic int\nencode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  return DWG_ERR_NOTYETSUPPORTED;\n}\n\n// needed for r2004+ encode and decode (check-only) (unused)\n// p 4.3: first calc with seed 0, then compress, then recalc with prev.\n// checksum\nuint32_t\ndwg_section_page_checksum (const uint32_t seed, Bit_Chain *restrict dat, uint32_t size)\n{\n  uint32_t sum1 = seed & 0xffff;\n  uint32_t sum2 = seed >> 0x10;\n  unsigned char *data = &(dat->chain[dat->byte]);\n\n  while (size)\n    {\n      uint32_t i;\n      uint32_t chunksize = size < 0x15b0 ? size : 0x15b0;\n      size -= chunksize;\n      for (i = 0; i < chunksize; i++)\n        {\n          sum1 += *data++;\n          sum2 += sum1;\n        }\n      sum1 %= 0xFFF1;\n      sum2 %= 0xFFF1;\n    }\n  return (sum2 << 0x10) | (sum1 & 0xffff);\n}\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_INDXF))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass || !klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  int error = 0;\n  int is_entity;\n  unsigned long pos;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INTERNALERROR;\n  is_entity = dwg_class_is_entity (klass);\n\n  if (dwg->opts & DWG_OPTS_INDXF) // DXF import\n    {\n      pos = bit_position (dat);\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n\n  oldpos = bit_position (dat);\n  assert (address);\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // TODO: calculate size from the fields. either <0x7fff or more\n  // patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010) {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS]\\n\", obj->size, obj->type)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_encode_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_encode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_encode_VBA_PROJECT(dat, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (obj->parent, obj);\n        }\n      else if ((error = dwg_encode_variable_type (obj->parent, dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          Dwg_Data *dwg = obj->parent;\n          int is_entity;\n          int i = obj->type - 500;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          if (klass && obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n            is_entity = dwg_class_is_entity (klass);\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n          else if (klass)\n            error = dwg_encode_UNKNOWN_ENT (dat, obj);\n          else // not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");\n              error = DWG_ERR_UNHANDLEDCLASS;\n              SINCE (R_2000)\n              {\n                bit_write_RL (dat, obj->bitsize);\n                LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n                          dat->byte - 4, dat->bit);\n              }\n              bit_write_H (dat, &obj->handle);\n              LOG_INFO (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n              // write obj->size bytes, excl. bitsize and handle.\n              // overshoot the bitsize and handle size.\n              bit_write_TF (dat, obj->tio.unknown, obj->size);\n            }\n        }\n    }\n\n  /* DXF: patchup size and bitsize */\n  if (!obj->size)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      assert (address);\n      obj->size = dat->byte - address - 2; // excludes the CRC\n      if (dat->bit)\n        obj->size++;\n      //assert (obj->bitsize); // on errors\n      if (!obj->bitsize)\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff)\n        // TODO: with overlarge sizes >0x7fff memmove dat\n        LOG_ERROR (\"Unhandled size %u > 0x7fff\", (unsigned)obj->size);\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = obj->size * 8 - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /*\n   if (obj->supertype != DWG_SUPERTYPE_UNKNOWN)\n   {\n     fprintf (stderr, \"Begin address:\\t%10lu\\n\", address);\n     fprintf (stderr, \"Last address:\\t%10lu\\tSize: %10lu\\n\", dat->byte,\n   obj->size); fprintf (stderr, \"End address:\\t%10lu (calculated)\\n\", address +\n   2 + obj->size);\n   }\n   */\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\", obj->address,\n                  obj->size, end_address, dat->byte, (long)(end_address - dat->byte));\n      dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     int i)\n{\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          bit_write_RC (dat, data->u.eed_0.length);\n          bit_write_RS_LE (dat, data->u.eed_0.codepage);\n          bit_write_TF (dat, data->u.eed_0.string, data->u.eed_0.length);\n          LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\",\n                     data->u.eed_0.length, data->u.eed_0.codepage, data->u.eed_0.string);\n        }\n        LATER_VERSIONS\n        {\n          BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n          bit_write_RS (dat, data->u.eed_0_r2007.length);\n          for (int j = 0; j < data->u.eed_0_r2007.length; j++)\n            bit_write_RS (dat, *s++);\n#ifdef _WIN32\n          LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                     (int)data->u.eed_0_r2007.length, data->u.eed_0_r2007.string);\n#else\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n            {\n              char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                         (int)data->u.eed_0_r2007.length, u8);\n              free (u8);\n            }\n#endif\n        }\n      }\n      break;\n    case 2:\n      bit_write_RC (dat, data->u.eed_2.byte);\n      LOG_TRACE (\"byte: %d [RC]\\n\", (int)data->u.eed_2.byte);\n      break;\n    case 3:\n      bit_write_RL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: %d [RL]\\n\", (int)data->u.eed_3.layer);\n      break;\n    case 4:\n      bit_write_RC (dat, data->u.eed_4.length);\n      bit_write_TF (dat, data->u.eed_4.data, data->u.eed_4.length);\n      LOG_TRACE (\"binary: \\\"%s\\\" [TF %d]\\n\", data->u.eed_4.data,\n                 data->u.eed_4.length);\n      break;\n    case 5:\n      bit_write_RLL (dat, data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x\\\"%lX\\\" [RLL]\\n\", (unsigned long)data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      bit_write_RD (dat, data->u.eed_10.point.x);\n      bit_write_RD (dat, data->u.eed_10.point.y);\n      bit_write_RD (dat, data->u.eed_10.point.z);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  return 0;\n}\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  unsigned long off = obj->address;\n\n#define LOG_POS\n  // LOG_INSANE (\" @%lu.%u\\n\", dat->byte - off, dat->bit)\n\n  int i, num_eed = obj->tio.object->num_eed;\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      BITCODE_BS size = eed->size;\n      if (size)\n        {\n          bit_write_BS (dat, size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\\n\", i, size);\n          LOG_POS\n          bit_write_H (dat, &eed->handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\\n\", i,\n                     ARGS_H (eed->handle));\n          LOG_POS\n          if (eed->raw)\n            {\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n            }\n        }\n      if (!eed->raw && eed->data) // indxf\n        {\n          dwg_encode_eed_data (dat, eed->data, i);\n          LOG_POS\n        }\n    }\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_POS\n#undef LOG_POS\n    return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat)\n    return DWG_ERR_INVALIDDWG;\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = obj->address * 8 + obj->bitsize;\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj, Dwg_Data *restrict dwg,\n                      Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_HANDLE_DATA for objects.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Object *ord = obj->tio.object;\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = bit_position (dat) + obj->bitsize; // the handle stream offset\n  SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n  error |= dwg_encode_eed (dat, obj);\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n\n  bit_write_BL (dat, ord->num_reactors);\n  LOG_TRACE (\"num_reactors: \" FORMAT_BL \" [BL]\\n\", ord->num_reactors);\n  SINCE (R_2004)\n  {\n    bit_write_B (dat, ord->xdic_missing_flag);\n    LOG_TRACE (\"xdic_missing_flag: \" FORMAT_B \" [B]\\n\",\n               ord->xdic_missing_flag);\n  }\n  SINCE (R_2013)\n  {\n    bit_write_B (dat, ord->has_ds_binary_data);\n    LOG_TRACE (\"has_ds_binary_data: \" FORMAT_B \" [B]\\n\",\n               ord->has_ds_binary_data);\n  }\n  return error;\n}\n\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int old_from = (int)dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      dwg->opts |= (DWG_OPTS_MINIMAL | DWG_OPTS_INDXF);\n      dat->from_version = dat->version - 1;\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n      _obj->HANDSEED = calloc(1, sizeof(Dwg_Object_Ref));\n      _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj, int size)\n{\n  Dwg_Resbuf *rbuf = obj->xdata;\n  enum RES_BUF_VALUE_TYPE type;\n  int i, j = 0;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      type = get_base_value_type (rbuf->type);\n      switch (type)\n        {\n        case VT_STRING:\n          UNTIL (R_2007)\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            bit_write_RC (dat, rbuf->value.str.codepage);\n            if (rbuf->value.str.u.data)\n              bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n            else\n              bit_write_TF (dat, (char*)\"\", 0);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", j,\n                       rbuf->value.str.u.data, rbuf->value.str.size,\n                       rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            for (i = 0; i < rbuf->value.str.size; i++)\n              bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n          }\n          break;\n        case VT_REAL:\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", j, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          break;\n        case VT_INT32:\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\\n\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          break;\n        case VT_INT64:\n          bit_write_BLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", j,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%d]: (%f,%f,%f) [3RD %d]\\n\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          break;\n        case VT_BINARY:\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_H \" [H %d]\\n\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type)\n          return DWG_ERR_INVALIDEED;\n        }\n      rbuf = rbuf->next;\n      j++;\n    }\n  return 0;\n}\n\nchar *encrypt_sat1 (BITCODE_BL blocksize, BITCODE_RC *acis_data, int *idx)\n{\n  char *encr_sat_data = calloc (blocksize, 1);\n  int i = *idx;\n  int j;\n  for (j = 0; j < (int)blocksize; j++)\n    {\n      if (acis_data[j] <= 32)\n        encr_sat_data[i++] = acis_data[j];\n      else\n        encr_sat_data[i++] = acis_data[j] - 159;\n      /* TODO reversion of:\n      if (encr_sat_data[j] <= 32)\n        acis_data[i++] = encr_sat_data[j];\n      else\n        acis_data[i++] = 159 - encr_sat_data[j];\n      */\n    }\n  *idx = i;\n  return encr_sat_data;\n}\n\n#undef IS_ENCODER\n"], "fixing_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2010-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dwgrewrite.c: load a DWG file and rewrite it,\n * optionally as a different version.\n *\n * written by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"../src/config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n\n#include <dwg.h>\n#include \"../src/common.h\"\n#include \"suffix.inc\"\n\nstatic int opts = 1;\n\nstatic int help (void);\n// int verbosity(int argc, char **argv, int i, unsigned int *opts);\n//#include \"common.inc\"\n\nstatic int\nusage (void)\n{\n  printf (\"\\nUsage: dwgrewrite [-v[N]] [--as rNNNN] <dwg_input_file.dwg> \"\n          \"[<dwg_output_file.dwg>]\\n\");\n  return 1;\n}\nstatic int\nopt_version (void)\n{\n  printf (\"dwgrewrite %s\\n\", PACKAGE_VERSION);\n  return 0;\n}\nstatic int\nhelp (void)\n{\n  printf (\"\\nUsage: dwgrewrite [OPTION]... INFILE [OUTFILE]\\n\");\n  printf (\"Rewrites the DWG as another DWG.\\n\");\n  printf (\"Default OUTFILE: INFILE with <-rewrite.dwg> appended.\\n\"\n          \"\\n\");\n#ifdef HAVE_GETOPT_LONG\n  printf (\"  -v[0-9], --verbose [0-9]  verbosity\\n\");\n  printf (\"  --as rNNNN                save as version\\n\");\n  printf (\"           Valid versions:\\n\");\n  printf (\"             r12, r14, r2000\\n\");\n  printf (\"           Planned versions:\\n\");\n  printf (\"             r9, r10, r11, r2004, r2007, r2010, r2013, r2018\\n\");\n  printf (\"  -o dwgfile, --file        \\n\");\n  printf (\"           --help           display this help and exit\\n\");\n  printf (\"           --version        output version information and exit\\n\"\n          \"\\n\");\n#else\n  printf (\"  -v[0-9]     verbosity\\n\");\n  printf (\"  -a rNNNN    save as version\\n\");\n  printf (\"              Valid versions:\\n\");\n  printf (\"                r12, r14, r2000 (default)\\n\");\n  printf (\"              Planned versions:\\n\");\n  printf (\"                r9, r10, r11, r2004, r2007, r2010, r2013, r2018\\n\");\n  printf (\"  -o dwgfile\\n\");\n  printf (\"  -h          display this help and exit\\n\");\n  printf (\"  -i          output version information and exit\\n\"\n          \"\\n\");\n#endif\n  printf (\"GNU LibreDWG online manual: \"\n          \"<https://www.gnu.org/software/libredwg/>\\n\");\n  return 0;\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int error;\n  int i = 1;\n  Dwg_Data dwg;\n  char *filename_in;\n  const char *version = NULL;\n  char *filename_out = NULL;\n  Dwg_Version_Type dwg_version;\n  BITCODE_BL num_objects;\n  int c;\n#ifdef HAVE_GETOPT_LONG\n  int option_index = 0;\n  static struct option long_options[]\n      = { { \"verbose\", 1, &opts, 1 }, // optional\n          { \"file\", 1, 0, 'o' },      { \"as\", 1, 0, 'a' }, { \"help\", 0, 0, 0 },\n          { \"version\", 0, 0, 0 },     { NULL, 0, NULL, 0 } };\n#endif\n\n  // check args\n  if (argc < 2)\n    return usage ();\n\n  while\n#ifdef HAVE_GETOPT_LONG\n      ((c = getopt_long (argc, argv, \":a:v::o:h\", long_options, &option_index))\n       != -1)\n#else\n      ((c = getopt (argc, argv, \":a:v::o:hi\")) != -1)\n#endif\n    {\n      if (c == -1)\n        break;\n      switch (c)\n        {\n        case ':': // missing arg\n          if (optarg && !strcmp (optarg, \"v\"))\n            {\n              opts = 1;\n              break;\n            }\n          fprintf (stderr, \"%s: option '-%c' requires an argument\\n\", argv[0],\n                   optopt);\n          break;\n#ifdef HAVE_GETOPT_LONG\n        case 0:\n          /* This option sets a flag */\n          if (!strcmp (long_options[option_index].name, \"verbose\"))\n            {\n              if (opts < 0 || opts > 9)\n                return usage ();\n#  if defined(USE_TRACING) && defined(HAVE_SETENV)\n              {\n                char v[2];\n                *v = opts + '0';\n                *(v + 1) = 0;\n                setenv (\"LIBREDWG_TRACE\", v, 1);\n              }\n#  endif\n              break;\n            }\n          if (!strcmp (long_options[option_index].name, \"version\"))\n            return opt_version ();\n          if (!strcmp (long_options[option_index].name, \"help\"))\n            return help ();\n          break;\n#else\n        case 'i':\n          return opt_version ();\n#endif\n        case 'o':\n          filename_out = optarg;\n          break;\n        case 'a':\n          dwg_version = dwg_version_as (optarg);\n          if (dwg_version == R_INVALID)\n            {\n              fprintf (stderr, \"Invalid version '%s'\\n\", argv[1]);\n              return usage ();\n            }\n          version = optarg;\n          break;\n        case 'v': // support -v3 and -v\n          i = (optind > 0 && optind < argc) ? optind - 1 : 1;\n          if (!memcmp (argv[i], \"-v\", 2))\n            {\n              opts = argv[i][2] ? argv[i][2] - '0' : 1;\n            }\n          if (opts < 0 || opts > 9)\n            return usage ();\n#if defined(USE_TRACING) && defined(HAVE_SETENV)\n          {\n            char v[2];\n            *v = opts + '0';\n            *(v + 1) = 0;\n            setenv (\"LIBREDWG_TRACE\", v, 1);\n          }\n#endif\n          break;\n        case 'h':\n          return help ();\n        case '?':\n          fprintf (stderr, \"%s: invalid option '-%c' ignored\\n\", argv[0],\n                   optopt);\n          break;\n        default:\n          return usage ();\n        }\n    }\n  i = optind;\n\n  memset (&dwg, 0, sizeof (Dwg_Data));\n  dwg.opts = opts & 0xf;\n\n  filename_in = argv[i];\n  if (!filename_in)\n    {\n      puts (\"No input file specified\");\n      return 1;\n    }\n  if (!filename_out)\n    {\n      if (argc > i + 1)\n        filename_out = argv[i + 1];\n      else\n        filename_out = suffix (filename_in, \"-rewrite.dwg\");\n    }\n  if (!filename_out || !strcmp (filename_in, filename_out))\n    {\n      if (filename_out != argv[i + 1])\n        free (filename_out);\n      return usage ();\n    }\n\n  /*\n   * some very simple testing\n   */\n  printf (\"Reading DWG file %s\\n\", filename_in);\n  error = dwg_read_file (filename_in, &dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    fprintf (stderr, \"READ ERROR 0x%x\\n\", error);\n  num_objects = dwg.num_objects;\n  if (!num_objects)\n    {\n      printf (\"Read 0 objects\\n\");\n      if (error >= DWG_ERR_CRITICAL)\n        {\n          if (filename_out != argv[i + 1])\n            free (filename_out);\n          return error;\n        }\n    }\n\n  if (opts)\n    printf (\"\\n\");\n  printf (\"Writing DWG file %s\", filename_out);\n#ifndef USE_WRITE\n  error = 1;\n#else\n  if (version)\n    { // forced -as-rXXX\n      printf (\" as %s\\n\", version);\n      if (dwg.header.from_version != dwg.header.version)\n        dwg.header.from_version = dwg.header.version;\n      // else keep from_version\n      dwg.header.version = dwg_version;\n    }\n  else if (dwg.header.version < R_13 || dwg.header.version > R_2000)\n    {\n      // we cannot yet write pre-r13 or 2004+\n      printf (\" as r2000\\n\");\n      dwg.header.version = R_2000;\n    }\n  else\n    {\n      printf (\"\\n\");\n    }\n\n  {\n    struct stat attrib;\n    if (!stat (filename_out, &attrib)) // exists\n      {\n        if (S_ISREG (attrib.st_mode) &&        // refuse to remove a directory\n            (access (filename_out, W_OK) == 0) // is writable\n#ifndef _WIN32\n            // refuse to remove a symlink. even with overwrite. security\n            && !S_ISLNK (attrib.st_mode)\n#endif\n            )\n          unlink (filename_out);\n        else\n          {\n            fprintf (stderr, \"Not writable file or symlink: %s\\n\",\n                     filename_out);\n            error |= DWG_ERR_IOERROR;\n          }\n      }\n  }\n  error = dwg_write_file (filename_out, &dwg);\n#endif\n\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      printf (\"WRITE ERROR 0x%x\\n\", error);\n      if (filename_out != argv[i + 1])\n        free (filename_out);\n      return error;\n    }\n  dwg_free (&dwg); // this is slow, but on needed on low memory systems\n\n#ifdef USE_WRITE\n  // try to read again\n  if (opts)\n    printf (\"\\n\");\n  printf (\"Re-reading created file %s\\n\", filename_out);\n  error = dwg_read_file (filename_out, &dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    printf (\"re-READ ERROR 0x%x\\n\", error);\n  if (num_objects && (num_objects != dwg.num_objects))\n    printf (\"re-READ num_objects: %lu, should be %lu\\n\",\n            (unsigned long)dwg.num_objects, (unsigned long)num_objects);\n  dwg_free (&dwg);\n#endif\n  if (filename_out != argv[i + 1])\n    free (filename_out);\n  return error >= DWG_ERR_CRITICAL ? error : 0;\n}\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n#define REFS_PER_REALLOC 100\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf);                \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \"\\n\", _obj->nam)\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\\n\", _obj->nam)\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf)    FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf)   FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf)   FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf)   FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf)  FIELD_CAST(nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf)  FIELD_CAST(nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf)  FIELD_CAST(nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf)  FIELD_CAST(nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf)  FIELD_CAST(nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf)  FIELD_CAST(nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf)   FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf)  FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER { if (!_obj->nam) _obj->nam = strdup (\"\"); }       \\\n    FIELDG (nam, TV, dxf);                                                    \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings)                                         \\\n          {                                                                   \\\n            FIELD_TU (nam, dxf)                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                     \\\n      }                                                                       \\\n    FIELD_G_TRACE (nam, TF, dxf);                                             \\\n  }\n#define FIELD_TFF(nam, len, dxf)  FIELD_TF(nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (dat, (BITCODE_TU)_obj->nam);                              \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  _FIELD_DD(nam, _default, dxf);                                              \\\n  LOG_TRACE (#nam \": %f [DD %d]\\n\", _obj->nam, dxf)\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, d1, dxf);                                               \\\n    _FIELD_DD (nam.y, d2, dxf + 10);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [2DD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD(nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD_1(nam, dxf)   FIELD_3BD(nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \"\\n\", _obj->nam.days,        \\\n               _obj->nam.ms);                                                 \\\n  }\n\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, &_obj->color);                                        \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n\n#define SUB_FIELD_CMC(o, nam, dxf1, dxf2) bit_write_CMC (dat, &_obj->o.nam)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n// No overflow check with IS_RELEASE\n#ifdef IS_RELEASE\n#  define OVERFLOW_CHECK(nam, size)\n#  define OVERFLOW_CHECK_LV(nam, size)\n#else\n#  define OVERFLOW_CHECK(nam, size)                                           \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#  define OVERFLOW_CHECK_LV(nam, size)                                        \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);             \\\n        size = 0;                                                             \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#endif\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK (nam, _obj->size)                                            \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], FIELD_VALUE (nam[vcount - 1].x),                \\\n                 FIELD_VALUE (nam[vcount - 1].y), dxf);                       \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, obj->tio.object->num_reactors)                  \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,         \\\n                     _obj->nam[vcount])                                       \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, size, dxf)                                        \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            bit_write_TV (dat, _obj->nam[vcount]);                            \\\n            LOG_TRACE (#nam \"[%d]: %s\\n\", (int)vcount, _obj->nam[vcount])     \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_TU (dat, (BITCODE_TU)_obj->nam[vcount]);                \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0 };                                 \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\\n\", handle_code, dxf)        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && hdlptr->handleref.code != handle_code   \\\n            && (handle_code == 4 && hdlptr->handleref.code < 6))              \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      hdlptr->handleref.code);                                \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &hdlptr->handleref);                            \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\\n\", ARGS_REF (hdlptr), dxf)  \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\\n\", (int)vcount, handle_code,  \\\n                   dxf)                                                       \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\\n\", (int)vcount,        \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define START_HANDLE_STREAM                                                   \\\n  *hdl_dat = *dat;                                                            \\\n  if (dat->version >= R_2007 && obj->bitsize)                                 \\\n    bit_set_position (hdl_dat, obj->hdlpos);                                  \\\n  if (!obj->bitsize)                                                          \\\n    {                                                                         \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM @%lu.%u (%lu)\\n\",          \\\n                 dat->byte, dat->bit, obj->address);                          \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n    }                                                                         \\\n  RESET_VER\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0; \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;                               \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\")                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;                    \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    LOG_INFO (\"Encode object \" #token \"\\n\")\n\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_2000 && _obj->num_reactors > 0x1000)                  \\\n    {                                                                         \\\n      fprintf (stderr, \"Invalid num_reactors: %ld\\n\",                         \\\n               (long)_obj->num_reactors);                                     \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj,\n                              Bit_Chain *str_dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat, Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, int size);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nint\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  unsigned char pvzbit;\n  long unsigned int pvzadr;\n  long unsigned int pvzadr_2;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *hdl_dat;\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat;\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s from version %s\\n\",\n               version_codes[dwg->header.version],\n               version_codes[dwg->header.from_version])\n  else\n    LOG_TRACE (\"Encode version %s\\n\", version_codes[dwg->header.version])\n  dat->byte += 6;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version)\n      {\n        _obj->is_maint = 0;\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x11; // ?\n            break;\n          case R_10:\n            _obj->dwg_version = 0x12; // ?\n            break;\n          case R_11:\n            _obj->dwg_version = 0x13; // ?\n            break;\n          case R_13:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x16;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19;\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x4;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_4:\n          case R_2_0:\n          case R_2_1:\n          case R_2_5:\n          case R_2_6:\n          default:\n            break;\n          }\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    if (!dwg->header.num_sections) /* Usually 3-5, max 6 */\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            dat->from_version = R_11; // to trigger IF_ENCODE_FROM_EARLIER defaults\n            if (dat->version <= dat->from_version)\n              dat->from_version = dat->version - 1;\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section\n          = calloc (dwg->header.num_sections, sizeof (Dwg_Section));\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version)\n          {\n            BITCODE_RS tmpunknown[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_rs), tmpunknown, sizeof (tmpunknown));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\")\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    /* System Section */\n    typedef union _system_section\n    {\n      unsigned char data[0x14]; // 20byte: 5*4\n      struct\n      {\n        uint32_t section_type; /* 0x4163043b */\n        uint32_t decomp_data_size;\n        uint32_t comp_data_size;\n        uint32_t compression_type;\n        uint32_t checksum; // see section_page_checksum\n      } fields;\n    } system_section;\n\n    system_section ss;\n    Dwg_Section *section;\n\n    Dwg_Object *obj = NULL;\n    struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n    const int size = sizeof (struct Dwg_R2004_Header);\n    char encrypted_data[size];\n    unsigned int rseed = 1;\n    uint32_t checksum;\n\n    LOG_ERROR (WE_CAN \"We don't encode the R2004_section_map yet\")\n\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = calloc (dwg->header.section_infohdr.num_desc,\n                                         sizeof (Dwg_Section_Info));\n\n    dat->byte = 0x80;\n    for (i = 0; i < (BITCODE_BL)size; i++)\n      {\n        rseed *= 0x343fd;\n        rseed += 0x269ec3;\n        encrypted_data[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n      }\n    LOG_TRACE (\"\\n#### Write 2004 File Header ####\\n\");\n    dat->byte = 0x80;\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dat->size = dat->byte + 0x80;\n        bit_chain_alloc (dat);\n      }\n    memcpy (&dat->chain[0x80], encrypted_data, size);\n    LOG_INFO (\"@0x%lx\\n\", dat->byte);\n\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n\n    dwg->r2004_header.checksum = 0;\n    dwg->r2004_header.checksum = dwg_section_page_checksum (0, dat, size);\n\n    /*-------------------------------------------------------------------------\n     * Section Page Map\n     */\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Write System Section (Section Page Map) ===\\n\");\n#ifndef HAVE_COMPRESS_R2004_SECTION\n    dwg->r2004_header.comp_data_size = dwg->r2004_header.decomp_data_size;\n    dwg->r2004_header.compression_type = 0;\n#endif\n    FIELD_RL (section_type, 0); // should be 0x4163043b\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    dwg_section_page_checksum (dwg->r2004_header.checksum, dat, size);\n    FIELD_RL (checksum, 0);\n    LOG_TRACE (\"\\n\")\n\n    LOG_WARN (\"TODO write_R2004_section_map(dat, dwg)\")\n    LOG_TRACE (\"\\n\")\n\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  if (!dwg->header.thumbnail_address)\n    dwg->header.thumbnail_address = dat->byte;\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, (char *)dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL size;\n    dwg_bmp (dwg, &size);\n    if (size > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", size, dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte, dwg->num_classes);\n  dwg->header.section[SECTION_CLASSES_R13].number = 1;\n  dwg->header.section[SECTION_CLASSES_R13].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      bit_write_TV (dat, klass->appname);\n      bit_write_TV (dat, klass->cppname);\n      bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->wasazombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long address, end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n      assert (dat->byte);\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0\n      if (dwg->header.version >= R_1_2)\n        {\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[SECTION_HANDLES_R13].number = 2;\n  dwg->header.section[SECTION_HANDLES_R13].address = dat->byte;\n\n  sec_size = 0;\n  pvzadr = dat->byte; // Correct value of section size must be written later\n  dat->byte += 2;\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n      assert (pvzadr);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n  if (dwg->header.version >= R_1_2)\n    {\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  pvzadr = dat->byte;\n  assert (pvzadr);\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[SECTION_HANDLES_R13].size\n      = dat->byte - dwg->header.section[SECTION_HANDLES_R13].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n  if (dwg->header.version >= R_13 && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          if (dwg->header.version <= R_2000)\n            {\n              _obj->num_sections = dwg->header.num_sections;\n              for (i = 0; i < _obj->num_sections; i++)\n                {\n                  _obj->section[i].nr = dwg->header.section[i].number;\n                  _obj->section[i].address = dwg->header.section[i].address;\n                  _obj->section[i].size = dwg->header.section[i].size;\n                }\n              // TODO handlers\n            }\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n        }\n\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %x != %x\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n        }\n      FIELD_BLx (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (char *)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13)\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT Section 4\n   * In a DXF under header_vars\n   */\n  if (dwg->header.num_sections > SECTION_MEASUREMENT_R13)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[SECTION_MEASUREMENT_R13].number = 4;\n      dwg->header.section[SECTION_MEASUREMENT_R13].address = dat->byte;\n      dwg->header.section[SECTION_MEASUREMENT_R13].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL]\\n\", dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n\n  /* Write section addresses\n   */\n  assert (section_address);\n  dat->byte = section_address;\n  dat->bit = 0;\n  LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      bit_write_RC (dat, dwg->header.section[j].number);\n      bit_write_RL (dat, dwg->header.section[j].address);\n      bit_write_RL (dat, dwg->header.section[j].size);\n      LOG_TRACE (\"section[%u].number: %2d [RC]\\n\", j,\n                 (int)dwg->header.section[j].number)\n      LOG_TRACE (\"section[%u].offset: 0x%x [RLx]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size: %4d [RL]\\n\", j,\n                 (int)dwg->header.section[j].size)\n    }\n\n  /* Write CRC's\n   */\n  bit_write_CRC (dat, 0, 0);\n  dat->byte -= 2;\n  ckr = bit_read_CRC (dat);\n  dat->byte -= 2;\n  switch (dwg->header.num_sections)\n    {\n    case 3:\n      ckr ^= 0xA598;\n      break;\n    case 4:\n      ckr ^= 0x8101;\n      break;\n    case 5:\n      ckr ^= 0x3CC4;\n      break;\n    case 6:\n      ckr ^= 0x8461;\n      break;\n    default:\n      break;\n    }\n  bit_write_RS (dat, ckr);\n  LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n\n  return 0;\n}\n\nstatic int\nencode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  return DWG_ERR_NOTYETSUPPORTED;\n}\n\n// needed for r2004+ encode and decode (check-only) (unused)\n// p 4.3: first calc with seed 0, then compress, then recalc with prev.\n// checksum\nuint32_t\ndwg_section_page_checksum (const uint32_t seed, Bit_Chain *restrict dat, uint32_t size)\n{\n  uint32_t sum1 = seed & 0xffff;\n  uint32_t sum2 = seed >> 0x10;\n  unsigned char *data = &(dat->chain[dat->byte]);\n\n  while (size)\n    {\n      uint32_t i;\n      uint32_t chunksize = size < 0x15b0 ? size : 0x15b0;\n      size -= chunksize;\n      for (i = 0; i < chunksize; i++)\n        {\n          sum1 += *data++;\n          sum2 += sum1;\n        }\n      sum1 %= 0xFFF1;\n      sum2 %= 0xFFF1;\n    }\n  return (sum2 << 0x10) | (sum1 & 0xffff);\n}\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_INDXF))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass || !klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  int error = 0;\n  int is_entity;\n  unsigned long pos;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INTERNALERROR;\n  is_entity = dwg_class_is_entity (klass);\n\n  if (dwg->opts & DWG_OPTS_INDXF) // DXF import\n    {\n      pos = bit_position (dat);\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n\n  oldpos = bit_position (dat);\n  assert (address);\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // TODO: calculate size from the fields. either <0x7fff or more\n  // patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010) {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS]\\n\", obj->size, obj->type)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_encode_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_encode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_encode_VBA_PROJECT(dat, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (obj->parent, obj);\n        }\n      else if ((error = dwg_encode_variable_type (obj->parent, dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          Dwg_Data *dwg = obj->parent;\n          int is_entity;\n          int i = obj->type - 500;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          if (klass && obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n            is_entity = dwg_class_is_entity (klass);\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n          else if (klass)\n            error = dwg_encode_UNKNOWN_ENT (dat, obj);\n          else // not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");\n              error = DWG_ERR_UNHANDLEDCLASS;\n              SINCE (R_2000)\n              {\n                bit_write_RL (dat, obj->bitsize);\n                LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n                          dat->byte - 4, dat->bit);\n              }\n              bit_write_H (dat, &obj->handle);\n              LOG_INFO (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n              // write obj->size bytes, excl. bitsize and handle.\n              // overshoot the bitsize and handle size.\n              bit_write_TF (dat, obj->tio.unknown, obj->size);\n            }\n        }\n    }\n\n  /* DXF: patchup size and bitsize */\n  if (!obj->size)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      assert (address);\n      obj->size = dat->byte - address - 2; // excludes the CRC\n      if (dat->bit)\n        obj->size++;\n      //assert (obj->bitsize); // on errors\n      if (!obj->bitsize)\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff)\n        // TODO: with overlarge sizes >0x7fff memmove dat\n        LOG_ERROR (\"Unhandled size %u > 0x7fff\", (unsigned)obj->size);\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = obj->size * 8 - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /*\n   if (obj->supertype != DWG_SUPERTYPE_UNKNOWN)\n   {\n     fprintf (stderr, \"Begin address:\\t%10lu\\n\", address);\n     fprintf (stderr, \"Last address:\\t%10lu\\tSize: %10lu\\n\", dat->byte,\n   obj->size); fprintf (stderr, \"End address:\\t%10lu (calculated)\\n\", address +\n   2 + obj->size);\n   }\n   */\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\", obj->address,\n                  obj->size, end_address, dat->byte, (long)(end_address - dat->byte));\n      dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     int i)\n{\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          bit_write_RC (dat, data->u.eed_0.length);\n          bit_write_RS_LE (dat, data->u.eed_0.codepage);\n          bit_write_TF (dat, data->u.eed_0.string, data->u.eed_0.length);\n          LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\",\n                     data->u.eed_0.length, data->u.eed_0.codepage, data->u.eed_0.string);\n        }\n        LATER_VERSIONS\n        {\n          BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n          bit_write_RS (dat, data->u.eed_0_r2007.length);\n          for (int j = 0; j < data->u.eed_0_r2007.length; j++)\n            bit_write_RS (dat, *s++);\n#ifdef _WIN32\n          LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                     (int)data->u.eed_0_r2007.length, data->u.eed_0_r2007.string);\n#else\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n            {\n              char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                         (int)data->u.eed_0_r2007.length, u8);\n              free (u8);\n            }\n#endif\n        }\n      }\n      break;\n    case 2:\n      bit_write_RC (dat, data->u.eed_2.byte);\n      LOG_TRACE (\"byte: %d [RC]\\n\", (int)data->u.eed_2.byte);\n      break;\n    case 3:\n      bit_write_RL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: %d [RL]\\n\", (int)data->u.eed_3.layer);\n      break;\n    case 4:\n      bit_write_RC (dat, data->u.eed_4.length);\n      bit_write_TF (dat, data->u.eed_4.data, data->u.eed_4.length);\n      LOG_TRACE (\"binary: \\\"%s\\\" [TF %d]\\n\", data->u.eed_4.data,\n                 data->u.eed_4.length);\n      break;\n    case 5:\n      bit_write_RLL (dat, data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x\\\"%lX\\\" [RLL]\\n\", (unsigned long)data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      bit_write_RD (dat, data->u.eed_10.point.x);\n      bit_write_RD (dat, data->u.eed_10.point.y);\n      bit_write_RD (dat, data->u.eed_10.point.z);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  return 0;\n}\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  unsigned long off = obj->address;\n\n#define LOG_POS\n  // LOG_INSANE (\" @%lu.%u\\n\", dat->byte - off, dat->bit)\n\n  int i, num_eed = obj->tio.object->num_eed;\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      BITCODE_BS size = eed->size;\n      if (size)\n        {\n          bit_write_BS (dat, size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\\n\", i, size);\n          LOG_POS\n          bit_write_H (dat, &eed->handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\\n\", i,\n                     ARGS_H (eed->handle));\n          LOG_POS\n          if (eed->raw)\n            {\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n            }\n        }\n      if (!eed->raw && eed->data) // indxf\n        {\n          dwg_encode_eed_data (dat, eed->data, i);\n          LOG_POS\n        }\n    }\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_POS\n#undef LOG_POS\n    return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat)\n    return DWG_ERR_INVALIDDWG;\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = obj->address * 8 + obj->bitsize;\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj, Dwg_Data *restrict dwg,\n                      Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_HANDLE_DATA for objects.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Object *ord = obj->tio.object;\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = bit_position (dat) + obj->bitsize; // the handle stream offset\n  SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n  error |= dwg_encode_eed (dat, obj);\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n\n  bit_write_BL (dat, ord->num_reactors);\n  LOG_TRACE (\"num_reactors: \" FORMAT_BL \" [BL]\\n\", ord->num_reactors);\n  SINCE (R_2004)\n  {\n    bit_write_B (dat, ord->xdic_missing_flag);\n    LOG_TRACE (\"xdic_missing_flag: \" FORMAT_B \" [B]\\n\",\n               ord->xdic_missing_flag);\n  }\n  SINCE (R_2013)\n  {\n    bit_write_B (dat, ord->has_ds_binary_data);\n    LOG_TRACE (\"has_ds_binary_data: \" FORMAT_B \" [B]\\n\",\n               ord->has_ds_binary_data);\n  }\n  return error;\n}\n\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int old_from = (int)dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      dwg->opts |= DWG_OPTS_MINIMAL;\n      dat->from_version = dat->version - 1;\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n      _obj->HANDSEED = calloc(1, sizeof(Dwg_Object_Ref));\n      _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj, int size)\n{\n  Dwg_Resbuf *rbuf = obj->xdata;\n  enum RES_BUF_VALUE_TYPE type;\n  int i, j = 0;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      type = get_base_value_type (rbuf->type);\n      switch (type)\n        {\n        case VT_STRING:\n          UNTIL (R_2007)\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            bit_write_RC (dat, rbuf->value.str.codepage);\n            if (rbuf->value.str.u.data)\n              bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n            else\n              bit_write_TF (dat, (char*)\"\", 0);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", j,\n                       rbuf->value.str.u.data, rbuf->value.str.size,\n                       rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            for (i = 0; i < rbuf->value.str.size; i++)\n              bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n          }\n          break;\n        case VT_REAL:\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", j, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          break;\n        case VT_INT32:\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\\n\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          break;\n        case VT_INT64:\n          bit_write_BLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", j,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%d]: (%f,%f,%f) [3RD %d]\\n\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          break;\n        case VT_BINARY:\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_H \" [H %d]\\n\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type)\n          return DWG_ERR_INVALIDEED;\n        }\n      rbuf = rbuf->next;\n      j++;\n    }\n  return 0;\n}\n\nchar *encrypt_sat1 (BITCODE_BL blocksize, BITCODE_RC *acis_data, int *idx)\n{\n  char *encr_sat_data = calloc (blocksize, 1);\n  int i = *idx;\n  int j;\n  for (j = 0; j < (int)blocksize; j++)\n    {\n      if (acis_data[j] <= 32)\n        encr_sat_data[i++] = acis_data[j];\n      else\n        encr_sat_data[i++] = acis_data[j] - 159;\n      /* TODO reversion of:\n      if (encr_sat_data[j] <= 32)\n        acis_data[i++] = encr_sat_data[j];\n      else\n        acis_data[i++] = 159 - encr_sat_data[j];\n      */\n    }\n  *idx = i;\n  return encr_sat_data;\n}\n\n#undef IS_ENCODER\n"], "filenames": ["programs/dwgrewrite.c", "src/encode.c"], "buggy_code_start_loc": [200, 2423], "buggy_code_end_loc": [201, 2424], "fixing_code_start_loc": [200, 2423], "fixing_code_end_loc": [201, 2424], "type": "CWE-476", "message": "An issue was discovered in GNU LibreDWG through 0.9.3. There is a NULL pointer dereference in the function dwg_encode_common_entity_handle_data in common_entity_handle_data.spec.", "other": {"cve": {"id": "CVE-2019-20914", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-16T18:15:13.597", "lastModified": "2020-07-22T18:19:19.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in GNU LibreDWG through 0.9.3. There is a NULL pointer dereference in the function dwg_encode_common_entity_handle_data in common_entity_handle_data.spec."}, {"lang": "es", "value": "Se detect\u00f3 un problema en GNU LibreDWG versiones hasta 0.9.3. Se presenta una desreferencia del puntero NULL en la funci\u00f3n dwg_encode_common_entity_handle_data en el archivo common_entity_handle_data.spec"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.3", "matchCriteriaId": "28E3A7DE-65A0-4A6B-BF63-00F627CF17CB"}]}]}], "references": [{"url": "https://github.com/LibreDWG/libredwg/commit/3b837bb72d6b9ab4d563faa211f90efc257e3c96", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibreDWG/libredwg/issues/178", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/3b837bb72d6b9ab4d563faa211f90efc257e3c96"}}