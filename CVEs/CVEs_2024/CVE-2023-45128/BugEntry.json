{"buggy_code": ["---\nid: csrf\n---\n\n# CSRF\n\nCSRF middleware for [Fiber](https://github.com/gofiber/fiber) that provides [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) protection by passing a csrf token via cookies. This cookie value will be used to compare against the client csrf token on requests, other than those defined as \"safe\" by [RFC9110#section-9.2.1](https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1) \\(GET, HEAD, OPTIONS, or TRACE\\). When the csrf token is invalid, this middleware will return the `fiber.ErrForbidden` error. \n\nCSRF Tokens are generated on GET requests. You can retrieve the CSRF token with `c.Locals(contextKey)`, where `contextKey` is the string you set in the config (see Custom Config below).\n\nWhen no `csrf_` cookie is set, or the token has expired, a new token will be generated and `csrf_` cookie set.\n\n:::note\nThis middleware uses our [Storage](https://github.com/gofiber/storage) package to support various databases through a single interface. The default configuration for this middleware saves data to memory, see the examples below for other databases.\n:::\n\n## Security Considerations\n\nThis middleware is designed to protect against CSRF attacks. It does not protect against other attack vectors, such as XSS, and should be used in combination with other security measures.\n\n:::warning\nNever use 'safe' methods to mutate data. For example, never use a GET request to delete a resource. This middleware will not protect against CSRF attacks on 'safe' methods.\n:::\n\n### The Double Submit Cookie Pattern (Default)\n\nIn the default configuration, the middleware will generate and store tokens using the `fiber.Storage` interface. These tokens are not associated with a user session, and, therefore, a Double Submit Cookie pattern is used to validate the token. This means that the token is stored in a cookie and also sent as a header on requests. The middleware will compare the cookie value with the header value to validate the token. This is a secure method of validating the token, as cookies are not accessible to JavaScript and, therefore, cannot be read by an attacker.\n\n:::warning\nWhen using this method, it is important that you set the `CookieSameSite` option to `Lax` or `Strict` and that the Extractor is not `CsrfFromCookie`, and KeyLookup is not `cookie:<name>`.\n:::\n\n### The Synchronizer Token Pattern (Session)\n\nWhen using this middleware with a user session, the middleware can be configured to store the token in the session. This method is recommended when using a user session as it is generally more secure than the Double Submit Cookie Pattern.\n\n:::warning\nWhen using this method, pre-sessions are required and will be created if a session is not already present. This means that the middleware will create a session for every safe request, even if the request does not require a session. Therefore it is required that the existence of a session is not used to indicate that a user is logged in or authenticated, and that a session value is used to indicate this instead.\n:::\n\n### Defense In Depth\n\nWhen using this middleware, it is recommended that you serve your pages over HTTPS, that the `CookieSecure` option is set to `true`, and that the `CookieSameSite` option is set to `Lax` or `Strict`. This will ensure that the cookie is only sent over HTTPS and that it is not sent on requests from external sites.\n\n### Referer Checking\n\nFor HTTPS requests, this middleware performs strict referer checking. This means that even if a subdomain can set or modify cookies on your domain, it can\u2019t force a user to post to your application since that request won\u2019t come from your own exact domain.\n\n### Token Lifecycle\n\nTokens are valid until they expire, or until they are deleted. By default, tokens are valid for 1 hour and each subsequent request will extend the expiration by 1 hour. This means that if a user makes a request every hour, the token will never expire. If a user makes a request after the token has expired, then a new token will be generated and the `csrf_` cookie will be set again. This means that the token will only expire if the user does not make a request for the duration of the expiration time.\n\n#### Token Reuse\n\nBy default tokens may be used multiple times. This means that the token will not be deleted after it has been used. If you would like to delete the token after it has been used, then you can set the `SingleUseToken` option to `true`. This will delete the token after it has been used, and a new token will be generated on the next request.\n\n:::note\nUsing `SingleUseToken` comes with usability tradeoffs, and therefore is not enabled by default. It can interfere with the user experience if the user has multiple tabs open, or if the user uses the back button.\n:::\n\n#### Deleting Tokens\n\nWhen the authorization status changes, the CSRF token should be deleted and a new one generated. This can be done by calling `handler.DeleteToken(c)`. This will remove the token found in the request context from the storage and set the `csrf_` cookie to an empty value. The next 'safe' request will generate a new token and set the cookie again.\n\n```go\nif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t// handle error\n\t}\n}\n```\n\n:::note\nIf you are using this middleware with the fiber session middleware, then you can simply call `session.Destroy()`, `session.Regenerate()`, or `session.Reset()` to delete session and the token stored therein.\n:::\n\n### BREACH\n\nIt is important to note that the token is sent as a header on every request, and if you include the token in a page that is vulnerable to [BREACH](https://en.wikipedia.org/wiki/BREACH), then an attacker may be able to extract the token. To mitigate this, you should take steps such as ensuring that your pages are served over HTTPS, that HTTP compression is disabled, and rate limiting requests.\n\n## Signatures\n\n```go\nfunc New(config ...Config) fiber.Handler\n```\n\n## Examples\n\nImport the middleware package that is part of the Fiber web framework\n\n```go\nimport (\n    \"github.com/gofiber/fiber/v2\"\n    \"github.com/gofiber/fiber/v2/middleware/csrf\"\n)\n```\n\nAfter you initiate your Fiber app, you can use the following possibilities:\n\n```go\n// Initialize default config\napp.Use(csrf.New())\n\n// Or extend your config for customization\napp.Use(csrf.New(csrf.Config{\n    KeyLookup:      \"header:X-Csrf-Token\",\n    CookieName:     \"csrf_\",\n\tCookieSameSite: \"Lax\",\n    Expiration:     1 * time.Hour,\n    KeyGenerator:   utils.UUIDv4,\n    Extractor:      func(c *fiber.Ctx) (string, error) { ... },\n}))\n```\n\n:::note\nKeyLookup will be ignored if Extractor is explicitly set.\n:::\n\n### Use with fiber/middleware/session (recommended)\n\nIt's recommended to use this middleware with [fiber/middleware/session](https://docs.gofiber.io/api/middleware/session) to store the CSRF token in the session. This is generally more secure than the default configuration.\n\n## Config\n\n### Config\n\n| Property          | Type                               | Description                                                                                                                                                                                                                                                                                  | Default                      |\n|:------------------|:-----------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------|\n| Next              | `func(*fiber.Ctx) bool`            | Next defines a function to skip this middleware when returned true.                                                                                                                                                                                                                          | `nil`                        |\n| KeyLookup         | `string`                           | KeyLookup is a string in the form of \"`<source>:<key>`\" that is used to create an Extractor that extracts the token from the request. Possible values: \"`header:<name>`\", \"`query:<name>`\", \"`param:<name>`\", \"`form:<name>`\", \"`cookie:<name>`\". Ignored if an Extractor is explicitly set. | \"header:X-CSRF-Token\"        |\n| CookieName        | `string`                           | Name of the csrf cookie. This cookie will store the csrf key.                                                                                                                                                                                                                                | \"csrf_\"                      |\n| CookieDomain      | `string`                           | Domain of the CSRF cookie.                                                                                                                                                                                                                                                                   | \"\"                           |\n| CookiePath        | `string`                           | Path of the CSRF cookie.                                                                                                                                                                                                                                                                     | \"\"                           |\n| CookieSecure      | `bool`                             | Indicates if the CSRF cookie is secure.                                                                                                                                                                                                                                                      | false                        |\n| CookieHTTPOnly    | `bool`                             | Indicates if the CSRF cookie is HTTP-only.                                                                                                                                                                                                                                                   | false                        |\n| CookieSameSite    | `string`                           | Value of SameSite cookie.                                                                                                                                                                                                                                                                    | \"Lax\"                        |\n| CookieSessionOnly | `bool`                             | Decides whether the cookie should last for only the browser session. Ignores Expiration if set to true.                                                                                                                                                                                      | false                        |\n| Expiration        | `time.Duration`                    | Expiration is the duration before the CSRF token will expire.                                                                                                                                                                                                                                | 1 * time.Hour                |\n| SingleUseToken    | `bool`                             | SingleUseToken indicates if the CSRF token be destroyed and a new one generated on each use. (See TokenLifecycle)                                                                                                                                                                            | false                        |\n| Storage           | `fiber.Storage`                    | Store is used to store the state of the middleware.                                                                                                                                                                                                                                          | `nil`                        |\n| Session           | `*session.Store`                   | Session is used to store the state of the middleware. Overrides Storage if set.                                                                                                                                                                                                              | `nil`                        |\n| SessionKey        | `string`                           | SessionKey is the key used to store the token in the session.                                                                                                                                                                                                                                | \"fiber.csrf.token\"           |\n| ContextKey        | `string`                           | Context key to store the generated CSRF token into the context. If left empty, the token will not be stored in the context.                                                                                                                                                                  | \"\"                           |\n| KeyGenerator      | `func() string`                    | KeyGenerator creates a new CSRF token.                                                                                                                                                                                                                                                       | utils.UUID                   |\n| CookieExpires     | `time.Duration` (Deprecated)       | Deprecated: Please use Expiration.                                                                                                                                                                                                                                                           | 0                            |\n| Cookie            | `*fiber.Cookie` (Deprecated)       | Deprecated: Please use Cookie* related fields.                                                                                                                                                                                                                                               | `nil`                        |\n| TokenLookup       | `string` (Deprecated)              | Deprecated: Please use KeyLookup.                                                                                                                                                                                                                                                            | \"\"                           |\n| ErrorHandler      | `fiber.ErrorHandler`               | ErrorHandler is executed when an error is returned from fiber.Handler.                                                                                                                                                                                                                       | DefaultErrorHandler          |\n| Extractor         | `func(*fiber.Ctx) (string, error)` | Extractor returns the CSRF token. If set, this will be used in place of an Extractor based on KeyLookup.                                                                                                                                                                                     | Extractor based on KeyLookup |\n| HandlerContextKey | `string`                           | HandlerContextKey is used to store the CSRF Handler into context.                                                                                                                                                                                                                            | \"fiber.csrf.handler\"         |\n\n## Default Config\n\n```go\nvar ConfigDefault = Config{\n\tKeyLookup:         \"header:\" + HeaderName,\n\tCookieName:        \"csrf_\",\n\tCookieSameSite:    \"Lax\",\n\tExpiration:        1 * time.Hour,\n\tKeyGenerator:      utils.UUIDv4,\n\tErrorHandler:      defaultErrorHandler,\n\tExtractor:         CsrfFromHeader(HeaderName),\n\tSessionKey:        \"fiber.csrf.token\",\n\tHandlerContextKey: \"fiber.csrf.handler\",\n}\n```\n\n## Recommended Config (with session)\n\n```go\nvar ConfigDefault = Config{\n\tKeyLookup:         \"header:\" + HeaderName,\n\tCookieName:        \"csrf_\",\n\tCookieSameSite:    \"Lax\",\n\tCookieSessionOnly: true,\n\tCookieHTTPOnly:    true,\n\tExpiration:        1 * time.Hour,\n\tKeyGenerator:      utils.UUIDv4,\n\tErrorHandler:      defaultErrorHandler,\n\tExtractor:         CsrfFromHeader(HeaderName),\n\tSession:           session.Store,\n\tSessionKey:        \"fiber.csrf.token\",\n\tHandlerContextKey: \"fiber.csrf.handler\",\n}\n```\n\n## Constants\n\n```go\nconst (\n    HeaderName = \"X-Csrf-Token\"\n)\n```\n\n### Custom Storage/Database\n\nYou can use any storage from our [storage](https://github.com/gofiber/storage/) package.\n\n```go\nstorage := sqlite3.New() // From github.com/gofiber/storage/sqlite3\napp.Use(csrf.New(csrf.Config{\n\tStorage: storage,\n}))\n```\n", "package csrf\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nvar (\n\tErrTokenNotFound = errors.New(\"csrf token not found\")\n\tErrTokenInvalid  = errors.New(\"csrf token invalid\")\n\tErrNoReferer     = errors.New(\"referer not supplied\")\n\tErrBadReferer    = errors.New(\"referer invalid\")\n\tdummyValue       = []byte{'+'}\n)\n\ntype CSRFHandler struct {\n\tconfig         *Config\n\tsessionManager *sessionManager\n\tstorageManager *storageManager\n}\n\n// New creates a new middleware handler\nfunc New(config ...Config) fiber.Handler {\n\t// Set default config\n\tcfg := configDefault(config...)\n\n\t// Create manager to simplify storage operations ( see *_manager.go )\n\tvar sessionManager *sessionManager\n\tvar storageManager *storageManager\n\tif cfg.Session != nil {\n\t\t// Register the Token struct in the session store\n\t\tcfg.Session.RegisterType(Token{})\n\n\t\tsessionManager = newSessionManager(cfg.Session, cfg.SessionKey)\n\t} else {\n\t\tstorageManager = newStorageManager(cfg.Storage)\n\t}\n\n\t// Return new handler\n\treturn func(c *fiber.Ctx) error {\n\t\t// Don't execute middleware if Next returns true\n\t\tif cfg.Next != nil && cfg.Next(c) {\n\t\t\treturn c.Next()\n\t\t}\n\n\t\t// Store the CSRF handler in the context if a context key is specified\n\t\tif cfg.HandlerContextKey != \"\" {\n\t\t\tc.Locals(cfg.HandlerContextKey, &CSRFHandler{\n\t\t\t\tconfig:         &cfg,\n\t\t\t\tsessionManager: sessionManager,\n\t\t\t\tstorageManager: storageManager,\n\t\t\t})\n\t\t}\n\n\t\tvar token string\n\n\t\t// Action depends on the HTTP method\n\t\tswitch c.Method() {\n\t\tcase fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:\n\t\t\tcookieToken := c.Cookies(cfg.CookieName)\n\n\t\t\tif cookieToken != \"\" {\n\t\t\t\trawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)\n\n\t\t\t\tif rawToken != nil {\n\t\t\t\t\ttoken = string(rawToken)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\t// Assume that anything not defined as 'safe' by RFC7231 needs protection\n\n\t\t\t// Enforce an origin check for HTTPS connections.\n\t\t\tif c.Protocol() == \"https\" {\n\t\t\t\tif err := refererMatchesHost(c); err != nil {\n\t\t\t\t\treturn cfg.ErrorHandler(c, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract token from client request i.e. header, query, param, form or cookie\n\t\t\textractedToken, err := cfg.Extractor(c)\n\t\t\tif err != nil {\n\t\t\t\treturn cfg.ErrorHandler(c, err)\n\t\t\t}\n\n\t\t\tif extractedToken == \"\" {\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenNotFound)\n\t\t\t}\n\n\t\t\t// If not using CsrfFromCookie extractor, check that the token matches the cookie\n\t\t\t// This is to prevent CSRF attacks by using a Double Submit Cookie method\n\t\t\t// Useful when we do not have access to the users Session\n\t\t\tif !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenInvalid)\n\t\t\t}\n\n\t\t\trawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n\n\t\t\tif rawToken == nil {\n\t\t\t\t// If token is not in storage, expire the cookie\n\t\t\t\texpireCSRFCookie(c, cfg)\n\t\t\t\t// and return an error\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenNotFound)\n\t\t\t}\n\t\t\tif cfg.SingleUseToken {\n\t\t\t\t// If token is single use, delete it from storage\n\t\t\t\tdeleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n\t\t\t} else {\n\t\t\t\ttoken = string(rawToken)\n\t\t\t}\n\t\t}\n\n\t\t// Generate CSRF token if not exist\n\t\tif token == \"\" {\n\t\t\t// And generate a new token\n\t\t\ttoken = cfg.KeyGenerator()\n\t\t}\n\n\t\t// Create or extend the token in the storage\n\t\tcreateOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)\n\n\t\t// Update the CSRF cookie\n\t\tupdateCSRFCookie(c, cfg, token)\n\n\t\t// Tell the browser that a new header value is generated\n\t\tc.Vary(fiber.HeaderCookie)\n\n\t\t// Store the token in the context if a context key is specified\n\t\tif cfg.ContextKey != \"\" {\n\t\t\tc.Locals(cfg.ContextKey, token)\n\t\t}\n\n\t\t// Continue stack\n\t\treturn c.Next()\n\t}\n}\n\n// getTokenFromStorage returns the raw token from the storage\n// returns nil if the token does not exist, is expired or is invalid\nfunc getTokenFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) []byte {\n\tif cfg.Session != nil {\n\t\treturn sessionManager.getRaw(c, token, dummyValue)\n\t}\n\treturn storageManager.getRaw(token)\n}\n\n// createOrExtendTokenInStorage creates or extends the token in the storage\nfunc createOrExtendTokenInStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) {\n\tif cfg.Session != nil {\n\t\tsessionManager.setRaw(c, token, dummyValue, cfg.Expiration)\n\t} else {\n\t\tstorageManager.setRaw(token, dummyValue, cfg.Expiration)\n\t}\n}\n\nfunc deleteTokenFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) {\n\tif cfg.Session != nil {\n\t\tsessionManager.delRaw(c)\n\t} else {\n\t\tstorageManager.delRaw(token)\n\t}\n}\n\n// Update CSRF cookie\n// if expireCookie is true, the cookie will expire immediately\nfunc updateCSRFCookie(c *fiber.Ctx, cfg Config, token string) {\n\tsetCSRFCookie(c, cfg, token, cfg.Expiration)\n}\n\nfunc expireCSRFCookie(c *fiber.Ctx, cfg Config) {\n\tsetCSRFCookie(c, cfg, \"\", -time.Hour)\n}\n\nfunc setCSRFCookie(c *fiber.Ctx, cfg Config, token string, expiry time.Duration) {\n\tcookie := &fiber.Cookie{\n\t\tName:        cfg.CookieName,\n\t\tValue:       token,\n\t\tDomain:      cfg.CookieDomain,\n\t\tPath:        cfg.CookiePath,\n\t\tSecure:      cfg.CookieSecure,\n\t\tHTTPOnly:    cfg.CookieHTTPOnly,\n\t\tSameSite:    cfg.CookieSameSite,\n\t\tSessionOnly: cfg.CookieSessionOnly,\n\t\tExpires:     time.Now().Add(expiry),\n\t}\n\n\t// Set the CSRF cookie to the response\n\tc.Cookie(cookie)\n}\n\n// DeleteToken removes the token found in the context from the storage\n// and expires the CSRF cookie\nfunc (handler *CSRFHandler) DeleteToken(c *fiber.Ctx) error {\n\t// Get the config from the context\n\tconfig := handler.config\n\tif config == nil {\n\t\tpanic(\"CSRFHandler config not found in context\")\n\t}\n\t// Extract token from the client request cookie\n\tcookieToken := c.Cookies(config.CookieName)\n\tif cookieToken == \"\" {\n\t\treturn config.ErrorHandler(c, ErrTokenNotFound)\n\t}\n\t// Remove the token from storage\n\tdeleteTokenFromStorage(c, cookieToken, *config, handler.sessionManager, handler.storageManager)\n\t// Expire the cookie\n\texpireCSRFCookie(c, *config)\n\treturn nil\n}\n\n// isCsrfFromCookie checks if the extractor is set to ExtractFromCookie\nfunc isCsrfFromCookie(extractor interface{}) bool {\n\treturn reflect.ValueOf(extractor).Pointer() == reflect.ValueOf(CsrfFromCookie).Pointer()\n}\n\n// refererMatchesHost checks that the referer header matches the host header\n// returns an error if the referer header is not present or is invalid\n// returns nil if the referer header is valid\nfunc refererMatchesHost(c *fiber.Ctx) error {\n\treferer := c.Get(fiber.HeaderReferer)\n\tif referer == \"\" {\n\t\treturn ErrNoReferer\n\t}\n\tif referer != c.Protocol()+\"://\"+c.Hostname() {\n\t\treturn ErrBadReferer\n\t}\n\treturn nil\n}\n", "package csrf\n\nimport (\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/session\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc Test_CSRF(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\tmethods := [4]string{fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace}\n\n\tfor _, method := range methods {\n\t\t// Generate CSRF token\n\t\tctx.Request.Header.SetMethod(method)\n\t\th(ctx)\n\n\t\t// Without CSRF cookie\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Empty/invalid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Valid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(method)\n\t\th(ctx)\n\t\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\t\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, token)\n\t\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\t}\n}\n\nfunc Test_CSRF_WithSession(t *testing.T) {\n\tt.Parallel()\n\n\t// session store\n\tstore := session.New(session.Config{\n\t\tKeyLookup: \"cookie:_session\",\n\t})\n\n\t// fiber instance\n\tapp := fiber.New()\n\n\t// fiber context\n\tctx := &fasthttp.RequestCtx{}\n\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n\n\t// get session\n\tsess, err := store.Get(app.AcquireCtx(ctx))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, true, sess.Fresh())\n\n\t// the session string is no longer be 123\n\tnewSessionIDString := sess.ID()\n\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n\n\t// middleware config\n\tconfig := Config{\n\t\tSession: store,\n\t}\n\n\t// middleware\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\n\tmethods := [4]string{fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace}\n\n\tfor _, method := range methods {\n\t\t// Generate CSRF token\n\t\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\n\t\t// Without CSRF cookie\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Empty/invalid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Valid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(method)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\t\tfor _, header := range strings.Split(token, \";\") {\n\t\t\tif strings.Split(strings.TrimSpace(header), \"=\")[0] == ConfigDefault.CookieName {\n\t\t\t\ttoken = strings.Split(header, \"=\")[1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, token)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\t}\n}\n\n// go test -run Test_CSRF_SingleUseToken\nfunc Test_CSRF_SingleUseToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{\n\t\tSingleUseToken: true,\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Use the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tnewToken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\tnewToken = strings.Split(strings.Split(newToken, \";\")[0], \"=\")[1]\n\tif token == newToken {\n\t\tt.Error(\"new token should not be the same as the old token\")\n\t}\n\n\t// Use the CSRF token again\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\n// go test -run Test_CSRF_Next\nfunc Test_CSRF_Next(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\tapp.Use(New(Config{\n\t\tNext: func(_ *fiber.Ctx) bool {\n\t\t\treturn true\n\t\t},\n\t}))\n\n\tresp, err := app.Test(httptest.NewRequest(fiber.MethodGet, \"/\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, fiber.StatusNotFound, resp.StatusCode)\n}\n\nfunc Test_CSRF_Invalid_KeyLookup(t *testing.T) {\n\tt.Parallel()\n\tdefer func() {\n\t\tutils.AssertEqual(t, \"[CSRF] KeyLookup must in the form of <source>:<key>\", recover())\n\t}()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"I:am:invalid\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n}\n\nfunc Test_CSRF_From_Form(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"form:_csrf\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMEApplicationForm)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMEApplicationForm)\n\tctx.Request.SetBodyString(\"_csrf=\" + token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_From_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"query:_csrf\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/?_csrf=\" + utils.UUIDv4())\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.SetRequestURI(\"/?_csrf=\" + token)\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Param(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tcsrfGroup := app.Group(\"/:csrf\", New(Config{KeyLookup: \"param:csrf\"}))\n\n\tcsrfGroup.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/\" + utils.UUIDv4())\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\" + utils.UUIDv4())\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.SetRequestURI(\"/\" + token)\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Cookie(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tcsrfGroup := app.Group(\"/\", New(Config{KeyLookup: \"cookie:csrf\"}))\n\n\tcsrfGroup.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/\")\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf=\"+utils.UUIDv4()+\";\")\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf=\"+token+\";\")\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Custom(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\textractor := func(c *fiber.Ctx) (string, error) {\n\t\tbody := string(c.Body())\n\t\t// Generate the correct extractor to get the token from the correct location\n\t\tselectors := strings.Split(body, \"=\")\n\n\t\tif len(selectors) != 2 || selectors[1] == \"\" {\n\t\t\treturn \"\", errMissingParam\n\t\t}\n\t\treturn selectors[1], nil\n\t}\n\n\tapp.Use(New(Config{Extractor: extractor}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMETextPlain)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMETextPlain)\n\tctx.Request.SetBodyString(\"_csrf=\" + token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_Referer(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{CookieSecure: true}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Test Correct Referer\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Test Wrong Referer\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://csrf.example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_DeleteToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tconfig := ConfigDefault\n\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Delete the CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\t\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\th(ctx)\n\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_DeleteToken_WithSession(t *testing.T) {\n\tt.Parallel()\n\n\t// session store\n\tstore := session.New(session.Config{\n\t\tKeyLookup: \"cookie:_session\",\n\t})\n\n\t// fiber instance\n\tapp := fiber.New()\n\n\t// fiber context\n\tctx := &fasthttp.RequestCtx{}\n\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n\n\t// get session\n\tsess, err := store.Get(app.AcquireCtx(ctx))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, true, sess.Fresh())\n\n\t// the session string is no longer be 123\n\tnewSessionIDString := sess.ID()\n\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n\n\t// middleware config\n\tconfig := Config{\n\t\tSession: store,\n\t}\n\n\t// middleware\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Delete the CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\t\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\th(ctx)\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_ErrorHandler_InvalidToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, ErrTokenInvalid, err)\n\t\treturn ctx.Status(419).Send([]byte(\"invalid CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{ErrorHandler: errHandler}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\n\t// invalid CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"invalid CSRF token\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_ErrorHandler_EmptyToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, errMissingHeader, err)\n\t\treturn ctx.Status(419).Send([]byte(\"empty CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{ErrorHandler: errHandler}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\n\t// empty CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"empty CSRF token\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_ErrorHandler_MissingReferer(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, ErrNoReferer, err)\n\t\treturn ctx.Status(419).Send([]byte(\"empty CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{\n\t\tCookieSecure: true,\n\t\tErrorHandler: errHandler,\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_Cookie_Injection_Exploit(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Inject CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf_=pwned;\")\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Exploit CSRF token we just injected\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf_=pwned;\")\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode(), \"CSRF exploit successful\")\n}\n\n// TODO: use this test case and make the unsafe header value bug from https://github.com/gofiber/fiber/issues/2045 reproducible and permanently fixed/tested by this testcase\n// func Test_CSRF_UnsafeHeaderValue(t *testing.T) {\n//  t.Parallel()\n// \tapp := fiber.New()\n\n// \tapp.Use(New())\n// \tapp.Get(\"/\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n// \tapp.Get(\"/test\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n// \tapp.Post(\"/\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n\n// \tresp, err := app.Test(httptest.NewRequest(fiber.MethodGet, \"/\", nil))\n// \tutils.AssertEqual(t, nil, err)\n// \tutils.AssertEqual(t, fiber.StatusOK, resp.StatusCode)\n\n// \tvar token string\n// \tfor _, c := range resp.Cookies() {\n// \t\tif c.Name != ConfigDefault.CookieName {\n// \t\t\tcontinue\n// \t\t}\n// \t\ttoken = c.Value\n// \t\tbreak\n// \t}\n\n// \tfmt.Println(\"token\", token)\n\n// \tgetReq := httptest.NewRequest(fiber.MethodGet, \"/\", nil)\n// \tgetReq.Header.Set(HeaderName, token)\n// \tresp, err = app.Test(getReq)\n\n// \tgetReq = httptest.NewRequest(fiber.MethodGet, \"/test\", nil)\n// \tgetReq.Header.Set(\"X-Requested-With\", \"XMLHttpRequest\")\n// \tgetReq.Header.Set(fiber.HeaderCacheControl, \"no\")\n// \tgetReq.Header.Set(HeaderName, token)\n\n// \tresp, err = app.Test(getReq)\n\n// \tgetReq.Header.Set(fiber.HeaderAccept, \"*/*\")\n// \tgetReq.Header.Del(HeaderName)\n// \tresp, err = app.Test(getReq)\n\n// \tpostReq := httptest.NewRequest(fiber.MethodPost, \"/\", nil)\n// \tpostReq.Header.Set(\"X-Requested-With\", \"XMLHttpRequest\")\n// \tpostReq.Header.Set(HeaderName, token)\n// \tresp, err = app.Test(postReq)\n// }\n\n// go test -v -run=^$ -bench=Benchmark_Middleware_CSRF_Check -benchmem -count=4\nfunc Benchmark_Middleware_CSRF_Check(b *testing.B) {\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusTeapot)\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n\n\tutils.AssertEqual(b, fiber.StatusTeapot, fctx.Response.Header.StatusCode())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Middleware_CSRF_GenerateToken -benchmem -count=4\nfunc Benchmark_Middleware_CSRF_GenerateToken(b *testing.B) {\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusTeapot)\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n\n\tutils.AssertEqual(b, fiber.StatusTeapot, fctx.Response.Header.StatusCode())\n}\n", "package csrf\n\nimport (\n\t\"errors\"\n\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nvar (\n\terrMissingHeader = errors.New(\"missing csrf token in header\")\n\terrMissingQuery  = errors.New(\"missing csrf token in query\")\n\terrMissingParam  = errors.New(\"missing csrf token in param\")\n\terrMissingForm   = errors.New(\"missing csrf token in form\")\n\terrMissingCookie = errors.New(\"missing csrf token in cookie\")\n)\n\n// csrfFromParam returns a function that extracts token from the url param string.\nfunc CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Params(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", errMissingParam\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromForm returns a function that extracts a token from a multipart-form.\nfunc CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.FormValue(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", errMissingForm\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromCookie returns a function that extracts token from the cookie header.\nfunc CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Cookies(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", errMissingCookie\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromHeader returns a function that extracts token from the request header.\nfunc CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Get(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", errMissingHeader\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromQuery returns a function that extracts token from the query string.\nfunc CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Query(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", errMissingQuery\n\t\t}\n\t\treturn token, nil\n\t}\n}\n", "package csrf\n\nimport (\n\t\"crypto/subtle\"\n)\n\nfunc compareTokens(a, b []byte) bool {\n\treturn subtle.ConstantTimeCompare(a, b) == 1\n}\n"], "fixing_code": ["---\nid: csrf\n---\n\n# CSRF\n\nCSRF middleware for [Fiber](https://github.com/gofiber/fiber) that provides [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) protection by passing a csrf token via cookies. This cookie value will be used to compare against the client csrf token on requests, other than those defined as \"safe\" by [RFC9110#section-9.2.1](https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1) \\(GET, HEAD, OPTIONS, or TRACE\\). When the csrf token is invalid, this middleware will return the `fiber.ErrForbidden` error. \n\nCSRF Tokens are generated on GET requests. You can retrieve the CSRF token with `c.Locals(contextKey)`, where `contextKey` is the string you set in the config (see Custom Config below).\n\nWhen no `csrf_` cookie is set, or the token has expired, a new token will be generated and `csrf_` cookie set.\n\n:::note\nThis middleware uses our [Storage](https://github.com/gofiber/storage) package to support various databases through a single interface. The default configuration for this middleware saves data to memory, see the examples below for other databases.\n:::\n\n## Security Considerations\n\nThis middleware is designed to protect against CSRF attacks. It does not protect against other attack vectors, such as XSS, and should be used in combination with other security measures.\n\n:::warning\nNever use 'safe' methods to mutate data. For example, never use a GET request to delete a resource. This middleware will not protect against CSRF attacks on 'safe' methods.\n:::\n\n### The Double Submit Cookie Pattern (Default)\n\nIn the default configuration, the middleware will generate and store tokens using the `fiber.Storage` interface. These tokens are not associated with a user session, and, therefore, a Double Submit Cookie pattern is used to validate the token. This means that the token is stored in a cookie and also sent as a header on requests. The middleware will compare the cookie value with the header value to validate the token. This is a secure method of validating the token, as cookies are not accessible to JavaScript and, therefore, cannot be read by an attacker.\n\n:::warning\nWhen using this method, it is important that you set the `CookieSameSite` option to `Lax` or `Strict` and that the Extractor is not `CsrfFromCookie`, and KeyLookup is not `cookie:<name>`.\n:::\n\n### The Synchronizer Token Pattern (Session)\n\nWhen using this middleware with a user session, the middleware can be configured to store the token in the session. This method is recommended when using a user session as it is generally more secure than the Double Submit Cookie Pattern.\n\n:::warning\nWhen using this method, pre-sessions are required and will be created if a session is not already present. This means that the middleware will create a session for every safe request, even if the request does not require a session. Therefore it is required that the existence of a session is not used to indicate that a user is logged in or authenticated, and that a session value is used to indicate this instead.\n:::\n\n### Defense In Depth\n\nWhen using this middleware, it is recommended that you serve your pages over HTTPS, that the `CookieSecure` option is set to `true`, and that the `CookieSameSite` option is set to `Lax` or `Strict`. This will ensure that the cookie is only sent over HTTPS and that it is not sent on requests from external sites.\n\n:::note\nCookie prefixes __Host- and __Secure- can be used to further secure the cookie. However, these prefixes are not supported by all browsers and there are some other limitations. See [MDN#Set-Cookie#cookie_prefixes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes) for more information.\n\nTo use these prefixes, set the `CookieName` option to `__Host-csrf_` or `__Secure-csrf_`.\n:::\n\n### Referer Checking\n\nFor HTTPS requests, this middleware performs strict referer checking. This means that even if a subdomain can set or modify cookies on your domain, it can\u2019t force a user to post to your application since that request won\u2019t come from your own exact domain.\n\n:::warning\nReferer checking is required for https requests protected by CSRF. All modern browsers will automatically include the Referer header in requests, including those made with the JS Fetch API. However, if you are using this middleware with a custom client you must ensure that the client sends a valid Referer header.\n:::\n\n### Token Lifecycle\n\nTokens are valid until they expire, or until they are deleted. By default, tokens are valid for 1 hour and each subsequent request will extend the expiration by 1 hour. This means that if a user makes a request every hour, the token will never expire. If a user makes a request after the token has expired, then a new token will be generated and the `csrf_` cookie will be set again. This means that the token will only expire if the user does not make a request for the duration of the expiration time.\n\n#### Token Reuse\n\nBy default tokens may be used multiple times. This means that the token will not be deleted after it has been used. If you would like to delete the token after it has been used, then you can set the `SingleUseToken` option to `true`. This will delete the token after it has been used, and a new token will be generated on the next request.\n\n:::note\nUsing `SingleUseToken` comes with usability tradeoffs, and therefore is not enabled by default. It can interfere with the user experience if the user has multiple tabs open, or if the user uses the back button.\n:::\n\n#### Deleting Tokens\n\nWhen the authorization status changes, the CSRF token should be deleted and a new one generated. This can be done by calling `handler.DeleteToken(c)`. This will remove the token found in the request context from the storage and set the `csrf_` cookie to an empty value. The next 'safe' request will generate a new token and set the cookie again.\n\n```go\nif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t// handle error\n\t}\n}\n```\n\n:::note\nIf you are using this middleware with the fiber session middleware, then you can simply call `session.Destroy()`, `session.Regenerate()`, or `session.Reset()` to delete session and the token stored therein.\n:::\n\n### BREACH\n\nIt is important to note that the token is sent as a header on every request, and if you include the token in a page that is vulnerable to [BREACH](https://en.wikipedia.org/wiki/BREACH), then an attacker may be able to extract the token. To mitigate this, you should take steps such as ensuring that your pages are served over HTTPS, that HTTP compression is disabled, and rate limiting requests.\n\n## Signatures\n\n```go\nfunc New(config ...Config) fiber.Handler\n```\n\n## Examples\n\nImport the middleware package that is part of the Fiber web framework\n\n```go\nimport (\n    \"github.com/gofiber/fiber/v2\"\n    \"github.com/gofiber/fiber/v2/middleware/csrf\"\n)\n```\n\nAfter you initiate your Fiber app, you can use the following possibilities:\n\n```go\n// Initialize default config\napp.Use(csrf.New())\n\n// Or extend your config for customization\napp.Use(csrf.New(csrf.Config{\n    KeyLookup:      \"header:X-Csrf-Token\",\n    CookieName:     \"csrf_\",\n\tCookieSameSite: \"Lax\",\n    Expiration:     1 * time.Hour,\n    KeyGenerator:   utils.UUIDv4,\n    Extractor:      func(c *fiber.Ctx) (string, error) { ... },\n}))\n```\n\n:::note\nKeyLookup will be ignored if Extractor is explicitly set.\n:::\n\n### Use with fiber/middleware/session (recommended)\n\nIt's recommended to use this middleware with [fiber/middleware/session](https://docs.gofiber.io/api/middleware/session) to store the CSRF token in the session. This is generally more secure than the default configuration.\n\n## Config\n\n### Config\n\n| Property          | Type                               | Description                                                                                                                                                                                                                                                                                  | Default                      |\n|:------------------|:-----------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------|\n| Next              | `func(*fiber.Ctx) bool`            | Next defines a function to skip this middleware when returned true.                                                                                                                                                                                                                          | `nil`                        |\n| KeyLookup         | `string`                           | KeyLookup is a string in the form of \"`<source>:<key>`\" that is used to create an Extractor that extracts the token from the request. Possible values: \"`header:<name>`\", \"`query:<name>`\", \"`param:<name>`\", \"`form:<name>`\", \"`cookie:<name>`\". Ignored if an Extractor is explicitly set. | \"header:X-CSRF-Token\"        |\n| CookieName        | `string`                           | Name of the csrf cookie. This cookie will store the csrf key.                                                                                                                                                                                                                                | \"csrf_\"                      |\n| CookieDomain      | `string`                           | Domain of the CSRF cookie.                                                                                                                                                                                                                                                                   | \"\"                           |\n| CookiePath        | `string`                           | Path of the CSRF cookie.                                                                                                                                                                                                                                                                     | \"\"                           |\n| CookieSecure      | `bool`                             | Indicates if the CSRF cookie is secure.                                                                                                                                                                                                                                                      | false                        |\n| CookieHTTPOnly    | `bool`                             | Indicates if the CSRF cookie is HTTP-only.                                                                                                                                                                                                                                                   | false                        |\n| CookieSameSite    | `string`                           | Value of SameSite cookie.                                                                                                                                                                                                                                                                    | \"Lax\"                        |\n| CookieSessionOnly | `bool`                             | Decides whether the cookie should last for only the browser session. Ignores Expiration if set to true.                                                                                                                                                                                      | false                        |\n| Expiration        | `time.Duration`                    | Expiration is the duration before the CSRF token will expire.                                                                                                                                                                                                                                | 1 * time.Hour                |\n| SingleUseToken    | `bool`                             | SingleUseToken indicates if the CSRF token be destroyed and a new one generated on each use. (See TokenLifecycle)                                                                                                                                                                            | false                        |\n| Storage           | `fiber.Storage`                    | Store is used to store the state of the middleware.                                                                                                                                                                                                                                          | `nil`                        |\n| Session           | `*session.Store`                   | Session is used to store the state of the middleware. Overrides Storage if set.                                                                                                                                                                                                              | `nil`                        |\n| SessionKey        | `string`                           | SessionKey is the key used to store the token in the session.                                                                                                                                                                                                                                | \"fiber.csrf.token\"           |\n| ContextKey        | `string`                           | Context key to store the generated CSRF token into the context. If left empty, the token will not be stored in the context.                                                                                                                                                                  | \"\"                           |\n| KeyGenerator      | `func() string`                    | KeyGenerator creates a new CSRF token.                                                                                                                                                                                                                                                       | utils.UUID                   |\n| CookieExpires     | `time.Duration` (Deprecated)       | Deprecated: Please use Expiration.                                                                                                                                                                                                                                                           | 0                            |\n| Cookie            | `*fiber.Cookie` (Deprecated)       | Deprecated: Please use Cookie* related fields.                                                                                                                                                                                                                                               | `nil`                        |\n| TokenLookup       | `string` (Deprecated)              | Deprecated: Please use KeyLookup.                                                                                                                                                                                                                                                            | \"\"                           |\n| ErrorHandler      | `fiber.ErrorHandler`               | ErrorHandler is executed when an error is returned from fiber.Handler.                                                                                                                                                                                                                       | DefaultErrorHandler          |\n| Extractor         | `func(*fiber.Ctx) (string, error)` | Extractor returns the CSRF token. If set, this will be used in place of an Extractor based on KeyLookup.                                                                                                                                                                                     | Extractor based on KeyLookup |\n| HandlerContextKey | `string`                           | HandlerContextKey is used to store the CSRF Handler into context.                                                                                                                                                                                                                            | \"fiber.csrf.handler\"         |\n\n## Default Config\n\n```go\nvar ConfigDefault = Config{\n\tKeyLookup:         \"header:\" + HeaderName,\n\tCookieName:        \"csrf_\",\n\tCookieSameSite:    \"Lax\",\n\tExpiration:        1 * time.Hour,\n\tKeyGenerator:      utils.UUIDv4,\n\tErrorHandler:      defaultErrorHandler,\n\tExtractor:         CsrfFromHeader(HeaderName),\n\tSessionKey:        \"fiber.csrf.token\",\n\tHandlerContextKey: \"fiber.csrf.handler\",\n}\n```\n\n## Recommended Config (with session)\n\n```go\nvar ConfigDefault = Config{\n\tKeyLookup:         \"header:\" + HeaderName,\n\tCookieName:        \"csrf_\",\n\tCookieSameSite:    \"Lax\",\n\tCookieSessionOnly: true,\n\tCookieHTTPOnly:    true,\n\tExpiration:        1 * time.Hour,\n\tKeyGenerator:      utils.UUIDv4,\n\tErrorHandler:      defaultErrorHandler,\n\tExtractor:         CsrfFromHeader(HeaderName),\n\tSession:           session.Store,\n\tSessionKey:        \"fiber.csrf.token\",\n\tHandlerContextKey: \"fiber.csrf.handler\",\n}\n```\n\n## Constants\n\n```go\nconst (\n    HeaderName = \"X-Csrf-Token\"\n)\n```\n\n### Custom Storage/Database\n\nYou can use any storage from our [storage](https://github.com/gofiber/storage/) package.\n\n```go\nstorage := sqlite3.New() // From github.com/gofiber/storage/sqlite3\napp.Use(csrf.New(csrf.Config{\n\tStorage: storage,\n}))\n```\n", "package csrf\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nvar (\n\tErrTokenNotFound = errors.New(\"csrf token not found\")\n\tErrTokenInvalid  = errors.New(\"csrf token invalid\")\n\tErrNoReferer     = errors.New(\"referer not supplied\")\n\tErrBadReferer    = errors.New(\"referer invalid\")\n\tdummyValue       = []byte{'+'}\n)\n\ntype CSRFHandler struct {\n\tconfig         *Config\n\tsessionManager *sessionManager\n\tstorageManager *storageManager\n}\n\n// New creates a new middleware handler\nfunc New(config ...Config) fiber.Handler {\n\t// Set default config\n\tcfg := configDefault(config...)\n\n\t// Create manager to simplify storage operations ( see *_manager.go )\n\tvar sessionManager *sessionManager\n\tvar storageManager *storageManager\n\tif cfg.Session != nil {\n\t\t// Register the Token struct in the session store\n\t\tcfg.Session.RegisterType(Token{})\n\n\t\tsessionManager = newSessionManager(cfg.Session, cfg.SessionKey)\n\t} else {\n\t\tstorageManager = newStorageManager(cfg.Storage)\n\t}\n\n\t// Return new handler\n\treturn func(c *fiber.Ctx) error {\n\t\t// Don't execute middleware if Next returns true\n\t\tif cfg.Next != nil && cfg.Next(c) {\n\t\t\treturn c.Next()\n\t\t}\n\n\t\t// Store the CSRF handler in the context if a context key is specified\n\t\tif cfg.HandlerContextKey != \"\" {\n\t\t\tc.Locals(cfg.HandlerContextKey, &CSRFHandler{\n\t\t\t\tconfig:         &cfg,\n\t\t\t\tsessionManager: sessionManager,\n\t\t\t\tstorageManager: storageManager,\n\t\t\t})\n\t\t}\n\n\t\tvar token string\n\n\t\t// Action depends on the HTTP method\n\t\tswitch c.Method() {\n\t\tcase fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:\n\t\t\tcookieToken := c.Cookies(cfg.CookieName)\n\n\t\t\tif cookieToken != \"\" {\n\t\t\t\traw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)\n\n\t\t\t\tif raw != nil {\n\t\t\t\t\ttoken = cookieToken // Token is valid, safe to set it\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\t// Assume that anything not defined as 'safe' by RFC7231 needs protection\n\n\t\t\t// Enforce an origin check for HTTPS connections.\n\t\t\tif c.Protocol() == \"https\" {\n\t\t\t\tif err := refererMatchesHost(c); err != nil {\n\t\t\t\t\treturn cfg.ErrorHandler(c, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract token from client request i.e. header, query, param, form or cookie\n\t\t\textractedToken, err := cfg.Extractor(c)\n\t\t\tif err != nil {\n\t\t\t\treturn cfg.ErrorHandler(c, err)\n\t\t\t}\n\n\t\t\tif extractedToken == \"\" {\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenNotFound)\n\t\t\t}\n\n\t\t\t// If not using CsrfFromCookie extractor, check that the token matches the cookie\n\t\t\t// This is to prevent CSRF attacks by using a Double Submit Cookie method\n\t\t\t// Useful when we do not have access to the users Session\n\t\t\tif !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenInvalid)\n\t\t\t}\n\n\t\t\traw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n\n\t\t\tif raw == nil {\n\t\t\t\t// If token is not in storage, expire the cookie\n\t\t\t\texpireCSRFCookie(c, cfg)\n\t\t\t\t// and return an error\n\t\t\t\treturn cfg.ErrorHandler(c, ErrTokenNotFound)\n\t\t\t}\n\t\t\tif cfg.SingleUseToken {\n\t\t\t\t// If token is single use, delete it from storage\n\t\t\t\tdeleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n\t\t\t} else {\n\t\t\t\ttoken = extractedToken // Token is valid, safe to set it\n\t\t\t}\n\t\t}\n\n\t\t// Generate CSRF token if not exist\n\t\tif token == \"\" {\n\t\t\t// And generate a new token\n\t\t\ttoken = cfg.KeyGenerator()\n\t\t}\n\n\t\t// Create or extend the token in the storage\n\t\tcreateOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)\n\n\t\t// Update the CSRF cookie\n\t\tupdateCSRFCookie(c, cfg, token)\n\n\t\t// Tell the browser that a new header value is generated\n\t\tc.Vary(fiber.HeaderCookie)\n\n\t\t// Store the token in the context if a context key is specified\n\t\tif cfg.ContextKey != \"\" {\n\t\t\tc.Locals(cfg.ContextKey, token)\n\t\t}\n\n\t\t// Continue stack\n\t\treturn c.Next()\n\t}\n}\n\n// getRawFromStorage returns the raw value from the storage for the given token\n// returns nil if the token does not exist, is expired or is invalid\nfunc getRawFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) []byte {\n\tif cfg.Session != nil {\n\t\treturn sessionManager.getRaw(c, token, dummyValue)\n\t}\n\treturn storageManager.getRaw(token)\n}\n\n// createOrExtendTokenInStorage creates or extends the token in the storage\nfunc createOrExtendTokenInStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) {\n\tif cfg.Session != nil {\n\t\tsessionManager.setRaw(c, token, dummyValue, cfg.Expiration)\n\t} else {\n\t\tstorageManager.setRaw(token, dummyValue, cfg.Expiration)\n\t}\n}\n\nfunc deleteTokenFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) {\n\tif cfg.Session != nil {\n\t\tsessionManager.delRaw(c)\n\t} else {\n\t\tstorageManager.delRaw(token)\n\t}\n}\n\n// Update CSRF cookie\n// if expireCookie is true, the cookie will expire immediately\nfunc updateCSRFCookie(c *fiber.Ctx, cfg Config, token string) {\n\tsetCSRFCookie(c, cfg, token, cfg.Expiration)\n}\n\nfunc expireCSRFCookie(c *fiber.Ctx, cfg Config) {\n\tsetCSRFCookie(c, cfg, \"\", -time.Hour)\n}\n\nfunc setCSRFCookie(c *fiber.Ctx, cfg Config, token string, expiry time.Duration) {\n\tcookie := &fiber.Cookie{\n\t\tName:        cfg.CookieName,\n\t\tValue:       token,\n\t\tDomain:      cfg.CookieDomain,\n\t\tPath:        cfg.CookiePath,\n\t\tSecure:      cfg.CookieSecure,\n\t\tHTTPOnly:    cfg.CookieHTTPOnly,\n\t\tSameSite:    cfg.CookieSameSite,\n\t\tSessionOnly: cfg.CookieSessionOnly,\n\t\tExpires:     time.Now().Add(expiry),\n\t}\n\n\t// Set the CSRF cookie to the response\n\tc.Cookie(cookie)\n}\n\n// DeleteToken removes the token found in the context from the storage\n// and expires the CSRF cookie\nfunc (handler *CSRFHandler) DeleteToken(c *fiber.Ctx) error {\n\t// Get the config from the context\n\tconfig := handler.config\n\tif config == nil {\n\t\tpanic(\"CSRFHandler config not found in context\")\n\t}\n\t// Extract token from the client request cookie\n\tcookieToken := c.Cookies(config.CookieName)\n\tif cookieToken == \"\" {\n\t\treturn config.ErrorHandler(c, ErrTokenNotFound)\n\t}\n\t// Remove the token from storage\n\tdeleteTokenFromStorage(c, cookieToken, *config, handler.sessionManager, handler.storageManager)\n\t// Expire the cookie\n\texpireCSRFCookie(c, *config)\n\treturn nil\n}\n\n// isCsrfFromCookie checks if the extractor is set to ExtractFromCookie\nfunc isCsrfFromCookie(extractor interface{}) bool {\n\treturn reflect.ValueOf(extractor).Pointer() == reflect.ValueOf(CsrfFromCookie).Pointer()\n}\n\n// refererMatchesHost checks that the referer header matches the host header\n// returns an error if the referer header is not present or is invalid\n// returns nil if the referer header is valid\nfunc refererMatchesHost(c *fiber.Ctx) error {\n\treferer := c.Get(fiber.HeaderReferer)\n\tif referer == \"\" {\n\t\treturn ErrNoReferer\n\t}\n\n\trefererURL, err := url.Parse(referer)\n\tif err != nil {\n\t\treturn ErrBadReferer\n\t}\n\n\tif refererURL.Scheme+\"://\"+refererURL.Host != c.Protocol()+\"://\"+c.Hostname() {\n\t\treturn ErrBadReferer\n\t}\n\n\treturn nil\n}\n", "package csrf\n\nimport (\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/session\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc Test_CSRF(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\tmethods := [4]string{fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace}\n\n\tfor _, method := range methods {\n\t\t// Generate CSRF token\n\t\tctx.Request.Header.SetMethod(method)\n\t\th(ctx)\n\n\t\t// Without CSRF cookie\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Empty/invalid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Valid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(method)\n\t\th(ctx)\n\t\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\t\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, token)\n\t\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\t}\n}\n\nfunc Test_CSRF_WithSession(t *testing.T) {\n\tt.Parallel()\n\n\t// session store\n\tstore := session.New(session.Config{\n\t\tKeyLookup: \"cookie:_session\",\n\t})\n\n\t// fiber instance\n\tapp := fiber.New()\n\n\t// fiber context\n\tctx := &fasthttp.RequestCtx{}\n\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n\n\t// get session\n\tsess, err := store.Get(app.AcquireCtx(ctx))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, true, sess.Fresh())\n\n\t// the session string is no longer be 123\n\tnewSessionIDString := sess.ID()\n\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n\n\t// middleware config\n\tconfig := Config{\n\t\tSession: store,\n\t}\n\n\t// middleware\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\n\tmethods := [4]string{fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace}\n\n\tfor _, method := range methods {\n\t\t// Generate CSRF token\n\t\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\n\t\t// Without CSRF cookie\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Empty/invalid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t\t// Valid CSRF token\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(method)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\th(ctx)\n\t\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\t\tfor _, header := range strings.Split(token, \";\") {\n\t\t\tif strings.Split(strings.TrimSpace(header), \"=\")[0] == ConfigDefault.CookieName {\n\t\t\t\ttoken = strings.Split(header, \"=\")[1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tctx.Request.Reset()\n\t\tctx.Response.Reset()\n\t\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\t\tctx.Request.Header.Set(HeaderName, token)\n\t\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\t\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\t\th(ctx)\n\t\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\t}\n}\n\n// go test -run Test_CSRF_ExpiredToken\nfunc Test_CSRF_ExpiredToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{\n\t\tExpiration: 1 * time.Second,\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Use the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Wait for the token to expire\n\ttime.Sleep(1 * time.Second)\n\n\t// Expired CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\n// go test -run Test_CSRF_ExpiredToken_WithSession\nfunc Test_CSRF_ExpiredToken_WithSession(t *testing.T) {\n\tt.Parallel()\n\n\t// session store\n\tstore := session.New(session.Config{\n\t\tKeyLookup: \"cookie:_session\",\n\t})\n\n\t// fiber instance\n\tapp := fiber.New()\n\n\t// fiber context\n\tctx := &fasthttp.RequestCtx{}\n\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n\n\t// get session\n\tsess, err := store.Get(app.AcquireCtx(ctx))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, true, sess.Fresh())\n\n\t// get session id\n\tnewSessionIDString := sess.ID()\n\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n\n\t// middleware config\n\tconfig := Config{\n\t\tSession:    store,\n\t\tExpiration: 1 * time.Second,\n\t}\n\n\t// middleware\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\tfor _, header := range strings.Split(token, \";\") {\n\t\tif strings.Split(strings.TrimSpace(header), \"=\")[0] == ConfigDefault.CookieName {\n\t\t\ttoken = strings.Split(header, \"=\")[1]\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Use the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Wait for the token to expire\n\ttime.Sleep(1 * time.Second)\n\n\t// Expired CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\n// go test -run Test_CSRF_MultiUseToken\nfunc Test_CSRF_MultiUseToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{\n\t\tKeyLookup: \"header:X-CSRF-Token\",\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(\"X-CSRF-Token\", \"johndoe\")\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(\"X-CSRF-Token\", token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tnewToken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\tnewToken = strings.Split(strings.Split(newToken, \";\")[0], \"=\")[1]\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Check if the token is not a dummy value\n\tutils.AssertEqual(t, token, newToken)\n}\n\n// go test -run Test_CSRF_SingleUseToken\nfunc Test_CSRF_SingleUseToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{\n\t\tSingleUseToken: true,\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Use the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tnewToken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\tnewToken = strings.Split(strings.Split(newToken, \";\")[0], \"=\")[1]\n\tif token == newToken {\n\t\tt.Error(\"new token should not be the same as the old token\")\n\t}\n\n\t// Use the CSRF token again\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\n// go test -run Test_CSRF_Next\nfunc Test_CSRF_Next(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\tapp.Use(New(Config{\n\t\tNext: func(_ *fiber.Ctx) bool {\n\t\t\treturn true\n\t\t},\n\t}))\n\n\tresp, err := app.Test(httptest.NewRequest(fiber.MethodGet, \"/\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, fiber.StatusNotFound, resp.StatusCode)\n}\n\nfunc Test_CSRF_Invalid_KeyLookup(t *testing.T) {\n\tt.Parallel()\n\tdefer func() {\n\t\tutils.AssertEqual(t, \"[CSRF] KeyLookup must in the form of <source>:<key>\", recover())\n\t}()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"I:am:invalid\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n}\n\nfunc Test_CSRF_From_Form(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"form:_csrf\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMEApplicationForm)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMEApplicationForm)\n\tctx.Request.SetBodyString(\"_csrf=\" + token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_From_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{KeyLookup: \"query:_csrf\"}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/?_csrf=\" + utils.UUIDv4())\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.SetRequestURI(\"/?_csrf=\" + token)\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Param(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tcsrfGroup := app.Group(\"/:csrf\", New(Config{KeyLookup: \"param:csrf\"}))\n\n\tcsrfGroup.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/\" + utils.UUIDv4())\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\" + utils.UUIDv4())\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.SetRequestURI(\"/\" + token)\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Cookie(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tcsrfGroup := app.Group(\"/\", New(Config{KeyLookup: \"cookie:csrf\"}))\n\n\tcsrfGroup.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.SetRequestURI(\"/\")\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf=\"+utils.UUIDv4()+\";\")\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf=\"+token+\";\")\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"OK\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_From_Custom(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\textractor := func(c *fiber.Ctx) (string, error) {\n\t\tbody := string(c.Body())\n\t\t// Generate the correct extractor to get the token from the correct location\n\t\tselectors := strings.Split(body, \"=\")\n\n\t\tif len(selectors) != 2 || selectors[1] == \"\" {\n\t\t\treturn \"\", ErrMissingParam\n\t\t}\n\t\treturn selectors[1], nil\n\t}\n\n\tapp.Use(New(Config{Extractor: extractor}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Invalid CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMETextPlain)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Generate CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMETextPlain)\n\tctx.Request.SetBodyString(\"_csrf=\" + token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_Referer(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New(Config{CookieSecure: true}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Test Correct Referer with port\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.URI().SetScheme(\"https\")\n\tctx.Request.URI().SetHost(\"example.com:8443\")\n\tctx.Request.Header.SetProtocol(\"https\")\n\tctx.Request.Header.SetHost(\"example.com:8443\")\n\tctx.Request.Header.Set(fiber.HeaderReferer, ctx.Request.URI().String())\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Test Correct Referer with ReverseProxy\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.URI().SetScheme(\"https\")\n\tctx.Request.URI().SetHost(\"10.0.1.42.com:8443\")\n\tctx.Request.Header.SetProtocol(\"https\")\n\tctx.Request.Header.SetHost(\"10.0.1.42:8443\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedFor, `192.0.2.43, \"[2001:db8:cafe::17]\"`)\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Test Correct Referer with ReverseProxy Missing X-Forwarded-* Headers\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.URI().SetScheme(\"https\")\n\tctx.Request.URI().SetHost(\"10.0.1.42:8443\")\n\tctx.Request.Header.SetProtocol(\"https\")\n\tctx.Request.Header.SetHost(\"10.0.1.42:8443\")\n\tctx.Request.Header.Set(fiber.HeaderXUrlScheme, \"https\") // We need to set this header to make sure c.Protocol() returns https\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n\n\t// Test Correct Referer with path\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com/action/items?gogogo=true\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n\n\t// Test Wrong Referer\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://csrf.example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_DeleteToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tconfig := ConfigDefault\n\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Delete the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\t\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\th(ctx)\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_DeleteToken_WithSession(t *testing.T) {\n\tt.Parallel()\n\n\t// session store\n\tstore := session.New(session.Config{\n\t\tKeyLookup: \"cookie:_session\",\n\t})\n\n\t// fiber instance\n\tapp := fiber.New()\n\n\t// fiber context\n\tctx := &fasthttp.RequestCtx{}\n\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n\n\t// get session\n\tsess, err := store.Get(app.AcquireCtx(ctx))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, true, sess.Fresh())\n\n\t// the session string is no longer be 123\n\tnewSessionIDString := sess.ID()\n\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n\n\t// middleware config\n\tconfig := Config{\n\t\tSession: store,\n\t}\n\n\t// middleware\n\tapp.Use(New(config))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Delete the CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tif handler, ok := app.AcquireCtx(ctx).Locals(ConfigDefault.HandlerContextKey).(*CSRFHandler); ok {\n\t\tif err := handler.DeleteToken(app.AcquireCtx(ctx)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\th(ctx)\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_ErrorHandler_InvalidToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, ErrTokenInvalid, err)\n\t\treturn ctx.Status(419).Send([]byte(\"invalid CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{ErrorHandler: errHandler}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\n\t// invalid CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, \"johndoe\")\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"invalid CSRF token\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_ErrorHandler_EmptyToken(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, ErrMissingHeader, err)\n\t\treturn ctx.Status(419).Send([]byte(\"empty CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{ErrorHandler: errHandler}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\n\t// empty CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n\tutils.AssertEqual(t, \"empty CSRF token\", string(ctx.Response.Body()))\n}\n\nfunc Test_CSRF_ErrorHandler_MissingReferer(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\terrHandler := func(ctx *fiber.Ctx, err error) error {\n\t\tutils.AssertEqual(t, ErrNoReferer, err)\n\t\treturn ctx.Status(419).Send([]byte(\"empty CSRF token\"))\n\t}\n\n\tapp.Use(New(Config{\n\t\tCookieSecure: true,\n\t\tErrorHandler: errHandler,\n\t}))\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n\th(ctx)\n\tutils.AssertEqual(t, 419, ctx.Response.StatusCode())\n}\n\nfunc Test_CSRF_Cookie_Injection_Exploit(t *testing.T) {\n\tt.Parallel()\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\n\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Inject CSRF token\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf_=pwned;\")\n\tctx.Request.SetRequestURI(\"/\")\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\t// Exploit CSRF token we just injected\n\tctx.Request.Reset()\n\tctx.Response.Reset()\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\tctx.Request.Header.Set(fiber.HeaderCookie, \"csrf_=pwned;\")\n\th(ctx)\n\tutils.AssertEqual(t, 403, ctx.Response.StatusCode(), \"CSRF exploit successful\")\n}\n\n// TODO: use this test case and make the unsafe header value bug from https://github.com/gofiber/fiber/issues/2045 reproducible and permanently fixed/tested by this testcase\n// func Test_CSRF_UnsafeHeaderValue(t *testing.T) {\n//  t.Parallel()\n// \tapp := fiber.New()\n\n// \tapp.Use(New())\n// \tapp.Get(\"/\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n// \tapp.Get(\"/test\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n// \tapp.Post(\"/\", func(c *fiber.Ctx) error {\n// \t\treturn c.SendStatus(fiber.StatusOK)\n// \t})\n\n// \tresp, err := app.Test(httptest.NewRequest(fiber.MethodGet, \"/\", nil))\n// \tutils.AssertEqual(t, nil, err)\n// \tutils.AssertEqual(t, fiber.StatusOK, resp.StatusCode)\n\n// \tvar token string\n// \tfor _, c := range resp.Cookies() {\n// \t\tif c.Name != ConfigDefault.CookieName {\n// \t\t\tcontinue\n// \t\t}\n// \t\ttoken = c.Value\n// \t\tbreak\n// \t}\n\n// \tfmt.Println(\"token\", token)\n\n// \tgetReq := httptest.NewRequest(fiber.MethodGet, \"/\", nil)\n// \tgetReq.Header.Set(HeaderName, token)\n// \tresp, err = app.Test(getReq)\n\n// \tgetReq = httptest.NewRequest(fiber.MethodGet, \"/test\", nil)\n// \tgetReq.Header.Set(\"X-Requested-With\", \"XMLHttpRequest\")\n// \tgetReq.Header.Set(fiber.HeaderCacheControl, \"no\")\n// \tgetReq.Header.Set(HeaderName, token)\n\n// \tresp, err = app.Test(getReq)\n\n// \tgetReq.Header.Set(fiber.HeaderAccept, \"*/*\")\n// \tgetReq.Header.Del(HeaderName)\n// \tresp, err = app.Test(getReq)\n\n// \tpostReq := httptest.NewRequest(fiber.MethodPost, \"/\", nil)\n// \tpostReq.Header.Set(\"X-Requested-With\", \"XMLHttpRequest\")\n// \tpostReq.Header.Set(HeaderName, token)\n// \tresp, err = app.Test(postReq)\n// }\n\n// go test -v -run=^$ -bench=Benchmark_Middleware_CSRF_Check -benchmem -count=4\nfunc Benchmark_Middleware_CSRF_Check(b *testing.B) {\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusTeapot)\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\th(ctx)\n\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n\n\tctx.Request.Header.SetMethod(fiber.MethodPost)\n\tctx.Request.Header.Set(HeaderName, token)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n\n\tutils.AssertEqual(b, fiber.StatusTeapot, fctx.Response.Header.StatusCode())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Middleware_CSRF_GenerateToken -benchmem -count=4\nfunc Benchmark_Middleware_CSRF_GenerateToken(b *testing.B) {\n\tapp := fiber.New()\n\n\tapp.Use(New())\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusTeapot)\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\th := app.Handler()\n\tctx := &fasthttp.RequestCtx{}\n\n\t// Generate CSRF token\n\tctx.Request.Header.SetMethod(fiber.MethodGet)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n\n\tutils.AssertEqual(b, fiber.StatusTeapot, fctx.Response.Header.StatusCode())\n}\n", "package csrf\n\nimport (\n\t\"errors\"\n\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nvar (\n\tErrMissingHeader = errors.New(\"missing csrf token in header\")\n\tErrMissingQuery  = errors.New(\"missing csrf token in query\")\n\tErrMissingParam  = errors.New(\"missing csrf token in param\")\n\tErrMissingForm   = errors.New(\"missing csrf token in form\")\n\tErrMissingCookie = errors.New(\"missing csrf token in cookie\")\n)\n\n// csrfFromParam returns a function that extracts token from the url param string.\nfunc CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Params(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", ErrMissingParam\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromForm returns a function that extracts a token from a multipart-form.\nfunc CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.FormValue(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", ErrMissingForm\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromCookie returns a function that extracts token from the cookie header.\nfunc CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Cookies(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", ErrMissingCookie\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromHeader returns a function that extracts token from the request header.\nfunc CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Get(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", ErrMissingHeader\n\t\t}\n\t\treturn token, nil\n\t}\n}\n\n// csrfFromQuery returns a function that extracts token from the query string.\nfunc CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {\n\treturn func(c *fiber.Ctx) (string, error) {\n\t\ttoken := c.Query(param)\n\t\tif token == \"\" {\n\t\t\treturn \"\", ErrMissingQuery\n\t\t}\n\t\treturn token, nil\n\t}\n}\n", "package csrf\n\nimport (\n\t\"crypto/subtle\"\n)\n\nfunc compareTokens(a, b []byte) bool {\n\treturn subtle.ConstantTimeCompare(a, b) == 1\n}\n\nfunc compareStrings(a, b string) bool {\n\treturn subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1\n}\n"], "filenames": ["docs/api/middleware/csrf.md", "middleware/csrf/csrf.go", "middleware/csrf/csrf_test.go", "middleware/csrf/extractors.go", "middleware/csrf/helpers.go"], "buggy_code_start_loc": [44, 4, 6, 10, 9], "buggy_code_end_loc": [47, 228, 673, 67, 9], "fixing_code_start_loc": [45, 5, 7, 10, 10], "fixing_code_end_loc": [58, 237, 892, 67, 14], "type": "CWE-20", "message": "Fiber is an express inspired web framework written in Go. A Cross-Site Request Forgery (CSRF) vulnerability has been identified in the application, which allows an attacker to inject arbitrary values and forge malicious requests on behalf of a user. This vulnerability can allow an attacker to inject arbitrary values without any authentication, or perform various malicious actions on behalf of an authenticated user, potentially compromising the security and integrity of the application. The vulnerability is caused by improper validation and enforcement of CSRF tokens within the application. This issue has been addressed in version 2.50.0 and users are advised to upgrade. Users should take additional security measures like captchas or Two-Factor Authentication (2FA) and set Session cookies with SameSite=Lax or SameSite=Secure, and the Secure and HttpOnly attributes as defense in depth measures. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-45128", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-16T21:15:11.137", "lastModified": "2023-10-23T15:26:25.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fiber is an express inspired web framework written in Go. A Cross-Site Request Forgery (CSRF) vulnerability has been identified in the application, which allows an attacker to inject arbitrary values and forge malicious requests on behalf of a user. This vulnerability can allow an attacker to inject arbitrary values without any authentication, or perform various malicious actions on behalf of an authenticated user, potentially compromising the security and integrity of the application. The vulnerability is caused by improper validation and enforcement of CSRF tokens within the application. This issue has been addressed in version 2.50.0 and users are advised to upgrade. Users should take additional security measures like captchas or Two-Factor Authentication (2FA) and set Session cookies with SameSite=Lax or SameSite=Secure, and the Secure and HttpOnly attributes as defense in depth measures. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Fiber es un framework web inspirado en Express escrito en Go. Se ha identificado una vulnerabilidad de Cross-Site Request Forgery (CSRF) en la aplicaci\u00f3n, que permite a un atacante inyectar valores arbitrarios y falsificar solicitudes maliciosas en nombre de un usuario. Esta vulnerabilidad puede permitir a un atacante inyectar valores arbitrarios sin ninguna autenticaci\u00f3n o realizar diversas acciones maliciosas en nombre de un usuario autenticado, comprometiendo potencialmente la seguridad y la integridad de la aplicaci\u00f3n. La vulnerabilidad se debe a una validaci\u00f3n y aplicaci\u00f3n inadecuadas de los tokens CSRF dentro de la aplicaci\u00f3n. Este problema se solucion\u00f3 en la versi\u00f3n 2.50.0 y se recomienda a los usuarios que actualicen. Los usuarios deben tomar medidas de seguridad adicionales como captchas o autenticaci\u00f3n de dos factores (2FA) y configurar cookies de sesi\u00f3n con SameSite=Lax o SameSite=Secure, y los atributos Secure y HttpOnly como medidas de defensa en profundidad. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-352"}, {"lang": "en", "value": "CWE-565"}, {"lang": "en", "value": "CWE-807"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gofiber:fiber:*:*:*:*:*:go:*:*", "versionEndExcluding": "2.50.0", "matchCriteriaId": "D4CF7CB2-A259-42A1-A42F-26170DCC266D"}]}]}], "references": [{"url": "https://github.com/gofiber/fiber/commit/8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gofiber/fiber/security/advisories/GHSA-94w9-97p3-p368", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gofiber/fiber/commit/8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a"}}