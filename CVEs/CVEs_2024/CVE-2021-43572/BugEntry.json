{"buggy_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)\nand this project adheres to the following versioning pattern:\n\nGiven a version number MAJOR.MINOR.PATCH, increment:\n\n- MAJOR version when **breaking changes** are introduced;\n- MINOR version when **backwards compatible changes** are introduced;\n- PATCH version when backwards compatible bug **fixes** are implemented.\n\n\n## [Unreleased]\n\n## [2.0.0] - 2021-10-08\n### Added\n- root imports: from ellipticcurve import PrivateKey, PublicKey, Signature, Ecdsa, File\n### Changed\n- return type of toDer() methods from str to bytes\n- internal DER parsing structure for better maintainability, translatability and usability\n\n## [1.1.1] - 2021-06-06\n### Fixed\n- unstable results on certain curves due to missing modulo operator on signature verification\n\n## [1.1.0] - 2020-09-04\n### Added\n- recoveryId generation and encoding in Signatures\n\n## [1.0.0] - 2020-04-13\n### Added\n- first official version\n", "from ellipticcurve.utils.compatibility import *\nfrom ellipticcurve.privateKey import PrivateKey\nfrom ellipticcurve.publicKey import PublicKey\nfrom ellipticcurve.signature import Signature\nfrom ellipticcurve.utils.file import File\nfrom ellipticcurve.ecdsa import Ecdsa\n", "from hashlib import sha256\nfrom .signature import Signature\nfrom .math import Math\nfrom .utils.integer import RandomInteger\nfrom .utils.binary import numberFromByteString\nfrom .utils.compatibility import *\n\n\nclass Ecdsa:\n\n    @classmethod\n    def sign(cls, message, privateKey, hashfunc=sha256):\n        byteMessage = hashfunc(toBytes(message)).digest()\n        numberMessage = numberFromByteString(byteMessage)\n        curve = privateKey.curve\n\n        r, s, randSignPoint = 0, 0, None\n        while r == 0 or s == 0:\n            randNum = RandomInteger.between(1, curve.N - 1)\n            randSignPoint = Math.multiply(curve.G, n=randNum, A=curve.A, P=curve.P, N=curve.N)\n            r = randSignPoint.x % curve.N\n            s = ((numberMessage + r * privateKey.secret) * (Math.inv(randNum, curve.N))) % curve.N\n        recoveryId = randSignPoint.y & 1\n        if randSignPoint.y > curve.N:\n            recoveryId += 2\n\n        return Signature(r=r, s=s, recoveryId=recoveryId)\n\n    @classmethod\n    def verify(cls, message, signature, publicKey, hashfunc=sha256):\n        byteMessage = hashfunc(toBytes(message)).digest()\n        numberMessage = numberFromByteString(byteMessage)\n        curve = publicKey.curve\n        r = signature.r\n        s = signature.s\n        inv = Math.inv(s, curve.N)\n        u1 = Math.multiply(curve.G, n=(numberMessage * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)\n        u2 = Math.multiply(publicKey.point, n=(r * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)\n        add = Math.add(u1, u2, A=curve.A, P=curve.P)\n        modX = add.x % curve.N\n        return r == modX\n"], "fixing_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)\nand this project adheres to the following versioning pattern:\n\nGiven a version number MAJOR.MINOR.PATCH, increment:\n\n- MAJOR version when **breaking changes** are introduced;\n- MINOR version when **backwards compatible changes** are introduced;\n- PATCH version when backwards compatible bug **fixes** are implemented.\n\n\n## [Unreleased]\n### Fixed\n- Signature r and s range check\n\n## [2.0.0] - 2021-10-08\n### Added\n- root imports: from ellipticcurve import PrivateKey, PublicKey, Signature, Ecdsa, File\n### Changed\n- return type of toDer() methods from str to bytes\n- internal DER parsing structure for better maintainability, translatability and usability\n\n## [1.1.1] - 2021-06-06\n### Fixed\n- unstable results on certain curves due to missing modulo operator on signature verification\n\n## [1.1.0] - 2020-09-04\n### Added\n- recoveryId generation and encoding in Signatures\n\n## [1.0.0] - 2020-04-13\n### Added\n- first official version\n", "from .utils.compatibility import *\nfrom .privateKey import PrivateKey\nfrom .publicKey import PublicKey\nfrom .signature import Signature\nfrom .utils.file import File\nfrom .ecdsa import Ecdsa\n", "from hashlib import sha256\nfrom .signature import Signature\nfrom .math import Math\nfrom .utils.integer import RandomInteger\nfrom .utils.binary import numberFromByteString\nfrom .utils.compatibility import *\n\n\nclass Ecdsa:\n\n    @classmethod\n    def sign(cls, message, privateKey, hashfunc=sha256):\n        byteMessage = hashfunc(toBytes(message)).digest()\n        numberMessage = numberFromByteString(byteMessage)\n        curve = privateKey.curve\n\n        r, s, randSignPoint = 0, 0, None\n        while r == 0 or s == 0:\n            randNum = RandomInteger.between(1, curve.N - 1)\n            randSignPoint = Math.multiply(curve.G, n=randNum, A=curve.A, P=curve.P, N=curve.N)\n            r = randSignPoint.x % curve.N\n            s = ((numberMessage + r * privateKey.secret) * (Math.inv(randNum, curve.N))) % curve.N\n        recoveryId = randSignPoint.y & 1\n        if randSignPoint.y > curve.N:\n            recoveryId += 2\n\n        return Signature(r=r, s=s, recoveryId=recoveryId)\n\n    @classmethod\n    def verify(cls, message, signature, publicKey, hashfunc=sha256):\n        byteMessage = hashfunc(toBytes(message)).digest()\n        numberMessage = numberFromByteString(byteMessage)\n        curve = publicKey.curve\n        r = signature.r\n        s = signature.s\n        if not 1 <= r <= curve.N - 1:\n            return False\n        if not 1 <= s <= curve.N - 1:\n            return False\n        inv = Math.inv(s, curve.N)\n        u1 = Math.multiply(curve.G, n=(numberMessage * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)\n        u2 = Math.multiply(publicKey.point, n=(r * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)\n        add = Math.add(u1, u2, A=curve.A, P=curve.P)\n        modX = add.x % curve.N\n        return r == modX\n"], "filenames": ["CHANGELOG.md", "ellipticcurve/__init__.py", "ellipticcurve/ecdsa.py"], "buggy_code_start_loc": [15, 1, 35], "buggy_code_end_loc": [15, 7, 35], "fixing_code_start_loc": [16, 1, 36], "fixing_code_end_loc": [18, 7, 40], "type": "CWE-347", "message": "The verify function in the Stark Bank Python ECDSA library (aka starkbank-escada or ecdsa-python) before 2.0.1 fails to check that the signature is non-zero, which allows attackers to forge signatures on arbitrary messages.", "other": {"cve": {"id": "CVE-2021-43572", "sourceIdentifier": "cve@mitre.org", "published": "2021-11-09T22:15:07.727", "lastModified": "2022-03-24T15:57:18.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The verify function in the Stark Bank Python ECDSA library (aka starkbank-escada or ecdsa-python) before 2.0.1 fails to check that the signature is non-zero, which allows attackers to forge signatures on arbitrary messages."}, {"lang": "es", "value": "La funci\u00f3n verify de la biblioteca ECDSA de Stark Bank Python (tambi\u00e9n conocida como starkbank-escada o ecdsa-python) anterior a la versi\u00f3n 2.0.1 no comprueba que la firma sea distinta de cero, lo que permite a los atacantes falsificar firmas en mensajes arbitrarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starkbank:ecdsa-python:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.1", "matchCriteriaId": "62CFD9C8-BA6A-47ED-B3EE-254980A95216"}]}]}], "references": [{"url": "https://github.com/starkbank/ecdsa-python/commit/d136170666e9510eb63c2572551805807bd4c17f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/starkbank/ecdsa-python/releases/tag/v2.0.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://research.nccgroup.com/2021/11/08/technical-advisory-arbitrary-signature-forgery-in-stark-bank-ecdsa-libraries/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/starkbank/ecdsa-python/commit/d136170666e9510eb63c2572551805807bd4c17f"}}